! function(e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.JitsiMeetJS = t() : e.JitsiMeetJS = t()
}(window, (function() {
    return function(e) {
        var t = {};

        function n(i) {
            if (t[i]) return t[i].exports;
            var r = t[i] = {
                i: i,
                l: !1,
                exports: {}
            };
            return e[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports
        }
        return n.m = e, n.c = t, n.d = function(e, t, i) {
            n.o(e, t) || Object.defineProperty(e, t, {
                enumerable: !0,
                get: i
            })
        }, n.r = function(e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, n.t = function(e, t) {
            if (1 & t && (e = n(e)), 8 & t) return e;
            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
            var i = Object.create(null);
            if (n.r(i), Object.defineProperty(i, "default", {
                    enumerable: !0,
                    value: e
                }), 2 & t && "string" != typeof e)
                for (var r in e) n.d(i, r, function(t) {
                    return e[t]
                }.bind(null, r));
            return i
        }, n.n = function(e) {
            var t = e && e.__esModule ? function() {
                return e.default
            } : function() {
                return e
            };
            return n.d(t, "a", t), t
        }, n.o = function(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }, n.p = "", n(n.s = 133)
    }([function(e, t) {
        e.exports = {
            ADD_ICE_CANDIDATE_FAILED: "xmpp.add_ice_candidate_failed",
            AUDIO_MUTED_BY_FOCUS: "xmpp.audio_muted_by_focus",
            AUTHENTICATION_REQUIRED: "xmpp.authentication_required",
            BRIDGE_DOWN: "xmpp.bridge_down",
            CALL_ACCEPTED: "xmpp.callaccepted.jingle",
            CALL_INCOMING: "xmpp.callincoming.jingle",
            CALL_ENDED: "xmpp.callended.jingle",
            CHAT_ERROR_RECEIVED: "xmpp.chat_error_received",
            CONFERENCE_PROPERTIES_CHANGED: "xmpp.conference_properties_changed",
            CONNECTION_ESTABLISHED: "xmpp.connection.connected",
            CONNECTION_FAILED: "xmpp.connection.failed",
            CONNECTION_INTERRUPTED: "xmpp.connection.interrupted",
            CONNECTION_RESTORED: "xmpp.connection.restored",
            CONNECTION_ICE_FAILED: "xmpp.connection.ice.failed",
            CONNECTION_STATUS_CHANGED: "xmpp.connection.status.changed",
            DISPLAY_NAME_CHANGED: "xmpp.display_name_changed",
            EMUC_ROOM_ADDED: "xmpp.emuc_room_added",
            EMUC_ROOM_REMOVED: "xmpp.emuc_room_removed",
            ETHERPAD: "xmpp.etherpad",
            FOCUS_DISCONNECTED: "xmpp.focus_disconnected",
            FOCUS_LEFT: "xmpp.focus_left",
            GRACEFUL_SHUTDOWN: "xmpp.graceful_shutdown",
            ICE_RESTARTING: "rtc.ice_restarting",
            ICE_RESTART_SUCCESS: "rtc.ice_restart_success",
            KICKED: "xmpp.kicked",
            LOCAL_ROLE_CHANGED: "xmpp.localrole_changed",
            MEETING_ID_SET: "xmpp.meeting_id_set",
            MESSAGE_RECEIVED: "xmpp.message_received",
            PRIVATE_MESSAGE_RECEIVED: "xmpp.private_message_received",
            MUC_MEMBER_BOT_TYPE_CHANGED: "xmpp.muc_member_bot_type_changed",
            MUC_DESTROYED: "xmpp.muc_destroyed",
            MUC_JOINED: "xmpp.muc_joined",
            MUC_MEMBER_JOINED: "xmpp.muc_member_joined",
            MUC_MEMBER_LEFT: "xmpp.muc_member_left",
            MUC_LEFT: "xmpp.muc_left",
            MUC_ROLE_CHANGED: "xmpp.muc_role_changed",
            MUC_LOCK_CHANGED: "xmpp.muc_lock_changed",
            PARTICIPANT_AUDIO_MUTED: "xmpp.audio_muted",
            PARTICIPANT_VIDEO_MUTED: "xmpp.video_muted",
            PARTICIPANT_VIDEO_TYPE_CHANGED: "xmpp.video_type",
            PARTCIPANT_FEATURES_CHANGED: "xmpp.partcipant_features_changed",
            PASSWORD_REQUIRED: "xmpp.password_required",
            PEERCONNECTION_READY: "xmpp.peerconnection_ready",
            PHONE_NUMBER_CHANGED: "conference.phoneNumberChanged",
            PRESENCE_RECEIVED: "xmpp.presence_received",
            PRESENCE_STATUS: "xmpp.presence_status",
            PROMPT_FOR_LOGIN: "xmpp.prompt_for_login",
            READY_TO_JOIN: "xmpp.ready_to_join",
            RECORDER_STATE_CHANGED: "xmpp.recorderStateChanged",
            REMOTE_STATS: "xmpp.remote_stats",
            RENEGOTIATION_FAILED: "xmpp.renegotiation_failed",
            RESERVATION_ERROR: "xmpp.room_reservation_error",
            ROOM_CONNECT_ERROR: "xmpp.room_connect_error",
            ROOM_CONNECT_NOT_ALLOWED_ERROR: "xmpp.room_connect_error.not_allowed",
            ROOM_JOIN_ERROR: "xmpp.room_join_error",
            ROOM_MAX_USERS_ERROR: "xmpp.room_max_users_error",
            SENDING_CHAT_MESSAGE: "xmpp.sending_chat_message",
            SENDING_PRIVATE_CHAT_MESSAGE: "xmpp.sending_private_chat_message",
            SESSION_ACCEPT_TIMEOUT: "xmpp.session_accept_timeout",
            SPEAKER_STATS_RECEIVED: "xmpp.speaker_stats_received",
            CONFERENCE_TIMESTAMP_RECEIVED: "xmpp.conference_timestamp_received",
            START_MUTED_FROM_FOCUS: "xmpp.start_muted_from_focus",
            SUBJECT_CHANGED: "xmpp.subject_changed",
            SUSPEND_DETECTED: "xmpp.suspend_detected",
            TRANSCRIPTION_STATUS_CHANGED: "xmpp.transcription_status_changed",
            TRANSPORT_INFO: "xmpp.transportinfo.jingle",
            VIDEO_SIP_GW_AVAILABILITY_CHANGED: "xmpp.videoSIPGWAvailabilityChanged",
            VIDEO_SIP_GW_SESSION_STATE_CHANGED: "xmpp.videoSIPGWSessionStateChanged",
            ICE_CONNECTION_STATE_CHANGED: "xmpp.ice_connection_state_changed",
            JSON_MESSAGE_RECEIVED: "xmmp.json_message_received"
        }
    }, function(e, t, n) {
        (function(t) {
            var n;
            n = function() {
                "use strict";
                var e = void 0 !== t ? t : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};

                function n(e) {
                    return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    })(e)
                }

                function i(e) {
                    return function(e) {
                        if (Array.isArray(e)) {
                            for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
                            return n
                        }
                    }(e) || function(e) {
                        if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
                    }(e) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance")
                    }()
                }
                var r = function(e, t) {
                        var n = (65535 & e) + (65535 & t);
                        return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                    },
                    s = function(e) {
                        if ("string" != typeof e) throw new Error("str2binl was passed a non-string");
                        for (var t = [], n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << n % 32;
                        return t
                    },
                    o = function(e, t, n, i, s, o) {
                        return r((a = r(r(t, e), r(i, o))) << (c = s) | a >>> 32 - c, n);
                        var a, c
                    },
                    a = function(e, t, n, i, r, s, a) {
                        return o(t & n | ~t & i, e, t, r, s, a)
                    },
                    c = function(e, t, n, i, r, s, a) {
                        return o(t & i | n & ~i, e, t, r, s, a)
                    },
                    d = function(e, t, n, i, r, s, a) {
                        return o(t ^ n ^ i, e, t, r, s, a)
                    },
                    u = function(e, t, n, i, r, s, a) {
                        return o(n ^ (t | ~i), e, t, r, s, a)
                    },
                    l = function(e, t) {
                        e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
                        for (var n, i, s, o, l = 1732584193, h = -271733879, p = -1732584194, f = 271733878, m = 0; m < e.length; m += 16) n = l, i = h, s = p, o = f, l = a(l, h, p, f, e[m + 0], 7, -680876936), f = a(f, l, h, p, e[m + 1], 12, -389564586), p = a(p, f, l, h, e[m + 2], 17, 606105819), h = a(h, p, f, l, e[m + 3], 22, -1044525330), l = a(l, h, p, f, e[m + 4], 7, -176418897), f = a(f, l, h, p, e[m + 5], 12, 1200080426), p = a(p, f, l, h, e[m + 6], 17, -1473231341), h = a(h, p, f, l, e[m + 7], 22, -45705983), l = a(l, h, p, f, e[m + 8], 7, 1770035416), f = a(f, l, h, p, e[m + 9], 12, -1958414417), p = a(p, f, l, h, e[m + 10], 17, -42063), h = a(h, p, f, l, e[m + 11], 22, -1990404162), l = a(l, h, p, f, e[m + 12], 7, 1804603682), f = a(f, l, h, p, e[m + 13], 12, -40341101), p = a(p, f, l, h, e[m + 14], 17, -1502002290), h = a(h, p, f, l, e[m + 15], 22, 1236535329), l = c(l, h, p, f, e[m + 1], 5, -165796510), f = c(f, l, h, p, e[m + 6], 9, -1069501632), p = c(p, f, l, h, e[m + 11], 14, 643717713), h = c(h, p, f, l, e[m + 0], 20, -373897302), l = c(l, h, p, f, e[m + 5], 5, -701558691), f = c(f, l, h, p, e[m + 10], 9, 38016083), p = c(p, f, l, h, e[m + 15], 14, -660478335), h = c(h, p, f, l, e[m + 4], 20, -405537848), l = c(l, h, p, f, e[m + 9], 5, 568446438), f = c(f, l, h, p, e[m + 14], 9, -1019803690), p = c(p, f, l, h, e[m + 3], 14, -187363961), h = c(h, p, f, l, e[m + 8], 20, 1163531501), l = c(l, h, p, f, e[m + 13], 5, -1444681467), f = c(f, l, h, p, e[m + 2], 9, -51403784), p = c(p, f, l, h, e[m + 7], 14, 1735328473), h = c(h, p, f, l, e[m + 12], 20, -1926607734), l = d(l, h, p, f, e[m + 5], 4, -378558), f = d(f, l, h, p, e[m + 8], 11, -2022574463), p = d(p, f, l, h, e[m + 11], 16, 1839030562), h = d(h, p, f, l, e[m + 14], 23, -35309556), l = d(l, h, p, f, e[m + 1], 4, -1530992060), f = d(f, l, h, p, e[m + 4], 11, 1272893353), p = d(p, f, l, h, e[m + 7], 16, -155497632), h = d(h, p, f, l, e[m + 10], 23, -1094730640), l = d(l, h, p, f, e[m + 13], 4, 681279174), f = d(f, l, h, p, e[m + 0], 11, -358537222), p = d(p, f, l, h, e[m + 3], 16, -722521979), h = d(h, p, f, l, e[m + 6], 23, 76029189), l = d(l, h, p, f, e[m + 9], 4, -640364487), f = d(f, l, h, p, e[m + 12], 11, -421815835), p = d(p, f, l, h, e[m + 15], 16, 530742520), h = d(h, p, f, l, e[m + 2], 23, -995338651), l = u(l, h, p, f, e[m + 0], 6, -198630844), f = u(f, l, h, p, e[m + 7], 10, 1126891415), p = u(p, f, l, h, e[m + 14], 15, -1416354905), h = u(h, p, f, l, e[m + 5], 21, -57434055), l = u(l, h, p, f, e[m + 12], 6, 1700485571), f = u(f, l, h, p, e[m + 3], 10, -1894986606), p = u(p, f, l, h, e[m + 10], 15, -1051523), h = u(h, p, f, l, e[m + 1], 21, -2054922799), l = u(l, h, p, f, e[m + 8], 6, 1873313359), f = u(f, l, h, p, e[m + 15], 10, -30611744), p = u(p, f, l, h, e[m + 6], 15, -1560198380), h = u(h, p, f, l, e[m + 13], 21, 1309151649), l = u(l, h, p, f, e[m + 4], 6, -145523070), f = u(f, l, h, p, e[m + 11], 10, -1120210379), p = u(p, f, l, h, e[m + 2], 15, 718787259), h = u(h, p, f, l, e[m + 9], 21, -343485551), l = r(l, n), h = r(h, i), p = r(p, s), f = r(f, o);
                        return [l, h, p, f]
                    },
                    h = {
                        hexdigest: function(e) {
                            return function(e) {
                                for (var t = "", n = 0; n < 4 * e.length; n++) t += "0123456789abcdef".charAt(e[n >> 2] >> n % 4 * 8 + 4 & 15) + "0123456789abcdef".charAt(e[n >> 2] >> n % 4 * 8 & 15);
                                return t
                            }(l(s(e), 8 * e.length))
                        },
                        hash: function(e) {
                            return function(e) {
                                for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> n % 32 & 255);
                                return t
                            }(l(s(e), 8 * e.length))
                        }
                    };

                function p(e, t) {
                    e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;
                    var n, i, r, s, o, a, c, d, u = new Array(80),
                        l = 1732584193,
                        h = -271733879,
                        p = -1732584194,
                        g = 271733878,
                        S = -1009589776;
                    for (n = 0; n < e.length; n += 16) {
                        for (s = l, o = h, a = p, c = g, d = S, i = 0; i < 80; i++) u[i] = i < 16 ? e[n + i] : v(u[i - 3] ^ u[i - 8] ^ u[i - 14] ^ u[i - 16], 1), r = _(_(v(l, 5), f(i, h, p, g)), _(_(S, u[i]), m(i))), S = g, g = p, p = v(h, 30), h = l, l = r;
                        l = _(l, s), h = _(h, o), p = _(p, a), g = _(g, c), S = _(S, d)
                    }
                    return [l, h, p, g, S]
                }

                function f(e, t, n, i) {
                    return e < 20 ? t & n | ~t & i : e < 40 ? t ^ n ^ i : e < 60 ? t & n | t & i | n & i : t ^ n ^ i
                }

                function m(e) {
                    return e < 20 ? 1518500249 : e < 40 ? 1859775393 : e < 60 ? -1894007588 : -899497514
                }

                function g(e, t) {
                    var n = S(e);
                    n.length > 16 && (n = p(n, 8 * e.length));
                    for (var i = new Array(16), r = new Array(16), s = 0; s < 16; s++) i[s] = 909522486 ^ n[s], r[s] = 1549556828 ^ n[s];
                    var o = p(i.concat(S(t)), 512 + 8 * t.length);
                    return p(r.concat(o), 672)
                }

                function _(e, t) {
                    var n = (65535 & e) + (65535 & t);
                    return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                }

                function v(e, t) {
                    return e << t | e >>> 32 - t
                }

                function S(e) {
                    for (var t = [], n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << 24 - n % 32;
                    return t
                }

                function y(e) {
                    for (var t, n, i = "", r = 0; r < 4 * e.length; r += 3)
                        for (t = (e[r >> 2] >> 8 * (3 - r % 4) & 255) << 16 | (e[r + 1 >> 2] >> 8 * (3 - (r + 1) % 4) & 255) << 8 | e[r + 2 >> 2] >> 8 * (3 - (r + 2) % 4) & 255, n = 0; n < 4; n++) 8 * r + 6 * n > 32 * e.length ? i += "=" : i += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(t >> 6 * (3 - n) & 63);
                    return i
                }

                function E(e) {
                    for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> 24 - n % 32 & 255);
                    return t
                }
                var T = {
                        b64_hmac_sha1: function(e, t) {
                            return y(g(e, t))
                        },
                        b64_sha1: function(e) {
                            return y(p(S(e), 8 * e.length))
                        },
                        binb2str: E,
                        core_hmac_sha1: g,
                        str_hmac_sha1: function(e, t) {
                            return E(g(e, t))
                        },
                        str_sha1: function(e) {
                            return E(p(S(e), 8 * e.length))
                        }
                    },
                    b = function(e) {
                        var t, n, i = "",
                            r = e.length;
                        for (t = 0; t < r; t++)(n = e.charCodeAt(t)) >= 0 && n <= 127 ? i += e.charAt(t) : n > 2047 ? (i += String.fromCharCode(224 | n >> 12 & 15), i += String.fromCharCode(128 | n >> 6 & 63), i += String.fromCharCode(128 | n >> 0 & 63)) : (i += String.fromCharCode(192 | n >> 6 & 31), i += String.fromCharCode(128 | n >> 0 & 63));
                        return i
                    },
                    C = function(e) {
                        for (var t in e = e || {})
                            if (Object.prototype.hasOwnProperty.call(e, t)) {
                                var i = "",
                                    r = "",
                                    s = "",
                                    o = e[t],
                                    a = "object" === n(o),
                                    c = escape(unescape(a ? o.value : o));
                                a && (i = o.expires ? ";expires=" + o.expires : "", r = o.domain ? ";domain=" + o.domain : "", s = o.path ? ";path=" + o.path : ""), document.cookie = t + "=" + c + i + r + s
                            }
                    };

                function R(e, t) {
                    return new I.Builder(e, t)
                }

                function A(e) {
                    return new I.Builder("iq", e)
                }

                function w(e) {
                    return new I.Builder("presence", e)
                }
                var I = {
                    VERSION: "@VERSION@",
                    NS: {
                        HTTPBIND: "http://jabber.org/protocol/httpbind",
                        BOSH: "urn:xmpp:xbosh",
                        CLIENT: "jabber:client",
                        AUTH: "jabber:iq:auth",
                        ROSTER: "jabber:iq:roster",
                        PROFILE: "jabber:iq:profile",
                        DISCO_INFO: "http://jabber.org/protocol/disco#info",
                        DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
                        MUC: "http://jabber.org/protocol/muc",
                        SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
                        STREAM: "http://etherx.jabber.org/streams",
                        FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
                        BIND: "urn:ietf:params:xml:ns:xmpp-bind",
                        SESSION: "urn:ietf:params:xml:ns:xmpp-session",
                        VERSION: "jabber:iq:version",
                        STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
                        XHTML_IM: "http://jabber.org/protocol/xhtml-im",
                        XHTML: "http://www.w3.org/1999/xhtml"
                    },
                    XHTML: {
                        tags: ["a", "blockquote", "br", "cite", "em", "img", "li", "ol", "p", "span", "strong", "ul", "body"],
                        attributes: {
                            a: ["href"],
                            blockquote: ["style"],
                            br: [],
                            cite: ["style"],
                            em: [],
                            img: ["src", "alt", "style", "height", "width"],
                            li: ["style"],
                            ol: ["style"],
                            p: ["style"],
                            span: ["style"],
                            strong: [],
                            ul: ["style"],
                            body: []
                        },
                        css: ["background-color", "color", "font-family", "font-size", "font-style", "font-weight", "margin-left", "margin-right", "text-align", "text-decoration"],
                        validTag: function(e) {
                            for (var t = 0; t < I.XHTML.tags.length; t++)
                                if (e === I.XHTML.tags[t]) return !0;
                            return !1
                        },
                        validAttribute: function(e, t) {
                            if (void 0 !== I.XHTML.attributes[e] && I.XHTML.attributes[e].length > 0)
                                for (var n = 0; n < I.XHTML.attributes[e].length; n++)
                                    if (t === I.XHTML.attributes[e][n]) return !0;
                            return !1
                        },
                        validCSS: function(e) {
                            for (var t = 0; t < I.XHTML.css.length; t++)
                                if (e === I.XHTML.css[t]) return !0;
                            return !1
                        }
                    },
                    Status: {
                        ERROR: 0,
                        CONNECTING: 1,
                        CONNFAIL: 2,
                        AUTHENTICATING: 3,
                        AUTHFAIL: 4,
                        CONNECTED: 5,
                        DISCONNECTED: 6,
                        DISCONNECTING: 7,
                        ATTACHED: 8,
                        REDIRECT: 9,
                        CONNTIMEOUT: 10,
                        BINDREQUIRED: 11
                    },
                    ErrorCondition: {
                        BAD_FORMAT: "bad-format",
                        CONFLICT: "conflict",
                        MISSING_JID_NODE: "x-strophe-bad-non-anon-jid",
                        NO_AUTH_MECH: "no-auth-mech",
                        UNKNOWN_REASON: "unknown"
                    },
                    LogLevel: {
                        DEBUG: 0,
                        INFO: 1,
                        WARN: 2,
                        ERROR: 3,
                        FATAL: 4
                    },
                    ElementType: {
                        NORMAL: 1,
                        TEXT: 3,
                        CDATA: 4,
                        FRAGMENT: 11
                    },
                    TIMEOUT: 1.1,
                    SECONDARY_TIMEOUT: .1,
                    addNamespace: function(e, t) {
                        I.NS[e] = t
                    },
                    forEachChild: function(e, t, n) {
                        for (var i = 0; i < e.childNodes.length; i++) {
                            var r = e.childNodes[i];
                            r.nodeType !== I.ElementType.NORMAL || t && !this.isTagEqual(r, t) || n(r)
                        }
                    },
                    isTagEqual: function(e, t) {
                        return e.tagName === t
                    },
                    _xmlGenerator: null,
                    _makeGenerator: function() {
                        var e;
                        return void 0 === document.implementation.createDocument || document.implementation.createDocument && document.documentMode && document.documentMode < 10 ? (e = this._getIEXmlDom()).appendChild(e.createElement("strophe")) : e = document.implementation.createDocument("jabber:client", "strophe", null), e
                    },
                    xmlGenerator: function() {
                        return I._xmlGenerator || (I._xmlGenerator = I._makeGenerator()), I._xmlGenerator
                    },
                    _getIEXmlDom: function() {
                        for (var e = null, t = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"], n = 0; n < t.length && null === e; n++) try {
                            e = new ActiveXObject(t[n])
                        } catch (t) {
                            e = null
                        }
                        return e
                    },
                    xmlElement: function(e) {
                        if (!e) return null;
                        for (var t = I.xmlGenerator().createElement(e), i = 1; i < arguments.length; i++) {
                            var r = arguments[i];
                            if (r)
                                if ("string" == typeof r || "number" == typeof r) t.appendChild(I.xmlTextNode(r));
                                else if ("object" === n(r) && "function" == typeof r.sort)
                                for (var s = 0; s < r.length; s++) {
                                    var o = r[s];
                                    "object" === n(o) && "function" == typeof o.sort && void 0 !== o[1] && null !== o[1] && t.setAttribute(o[0], o[1])
                                } else if ("object" === n(r))
                                    for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && void 0 !== r[a] && null !== r[a] && t.setAttribute(a, r[a])
                        }
                        return t
                    },
                    xmlescape: function(e) {
                        return e = (e = (e = (e = (e = e.replace(/\&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/'/g, "&apos;")).replace(/"/g, "&quot;")
                    },
                    xmlunescape: function(e) {
                        return e = (e = (e = (e = (e = e.replace(/\&amp;/g, "&")).replace(/&lt;/g, "<")).replace(/&gt;/g, ">")).replace(/&apos;/g, "'")).replace(/&quot;/g, '"')
                    },
                    xmlTextNode: function(e) {
                        return I.xmlGenerator().createTextNode(e)
                    },
                    xmlHtmlNode: function(e) {
                        var t;
                        return DOMParser ? t = (new DOMParser).parseFromString(e, "text/xml") : ((t = new ActiveXObject("Microsoft.XMLDOM")).async = "false", t.loadXML(e)), t
                    },
                    getText: function(e) {
                        if (!e) return null;
                        var t = "";
                        0 === e.childNodes.length && e.nodeType === I.ElementType.TEXT && (t += e.nodeValue);
                        for (var n = 0; n < e.childNodes.length; n++) e.childNodes[n].nodeType === I.ElementType.TEXT && (t += e.childNodes[n].nodeValue);
                        return I.xmlescape(t)
                    },
                    copyElement: function(e) {
                        var t;
                        if (e.nodeType === I.ElementType.NORMAL) {
                            t = I.xmlElement(e.tagName);
                            for (var n = 0; n < e.attributes.length; n++) t.setAttribute(e.attributes[n].nodeName, e.attributes[n].value);
                            for (var i = 0; i < e.childNodes.length; i++) t.appendChild(I.copyElement(e.childNodes[i]))
                        } else e.nodeType === I.ElementType.TEXT && (t = I.xmlGenerator().createTextNode(e.nodeValue));
                        return t
                    },
                    createHtml: function(e) {
                        var t;
                        if (e.nodeType === I.ElementType.NORMAL) {
                            var i = e.nodeName.toLowerCase();
                            if (I.XHTML.validTag(i)) try {
                                t = I.xmlElement(i);
                                for (var r = 0; r < I.XHTML.attributes[i].length; r++) {
                                    var s = I.XHTML.attributes[i][r],
                                        o = e.getAttribute(s);
                                    if (null != o && "" !== o && !1 !== o && 0 !== o)
                                        if ("style" === s && "object" === n(o) && void 0 !== o.cssText && (o = o.cssText), "style" === s) {
                                            for (var a = [], c = o.split(";"), d = 0; d < c.length; d++) {
                                                var u = c[d].split(":"),
                                                    l = u[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                                if (I.XHTML.validCSS(l)) {
                                                    var h = u[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                                    a.push(l + ": " + h)
                                                }
                                            }
                                            a.length > 0 && (o = a.join("; "), t.setAttribute(s, o))
                                        } else t.setAttribute(s, o)
                                }
                                for (var p = 0; p < e.childNodes.length; p++) t.appendChild(I.createHtml(e.childNodes[p]))
                            } catch (e) {
                                t = I.xmlTextNode("")
                            } else {
                                t = I.xmlGenerator().createDocumentFragment();
                                for (var f = 0; f < e.childNodes.length; f++) t.appendChild(I.createHtml(e.childNodes[f]))
                            }
                        } else if (e.nodeType === I.ElementType.FRAGMENT) {
                            t = I.xmlGenerator().createDocumentFragment();
                            for (var m = 0; m < e.childNodes.length; m++) t.appendChild(I.createHtml(e.childNodes[m]))
                        } else e.nodeType === I.ElementType.TEXT && (t = I.xmlTextNode(e.nodeValue));
                        return t
                    },
                    escapeNode: function(e) {
                        return "string" != typeof e ? e : e.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40")
                    },
                    unescapeNode: function(e) {
                        return "string" != typeof e ? e : e.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\")
                    },
                    getNodeFromJid: function(e) {
                        return e.indexOf("@") < 0 ? null : e.split("@")[0]
                    },
                    getDomainFromJid: function(e) {
                        var t = I.getBareJidFromJid(e);
                        if (t.indexOf("@") < 0) return t;
                        var n = t.split("@");
                        return n.splice(0, 1), n.join("@")
                    },
                    getResourceFromJid: function(e) {
                        if (!e) return null;
                        var t = e.split("/");
                        return t.length < 2 ? null : (t.splice(0, 1), t.join("/"))
                    },
                    getBareJidFromJid: function(e) {
                        return e ? e.split("/")[0] : null
                    },
                    _handleError: function(e) {
                        void 0 !== e.stack && I.fatal(e.stack), e.sourceURL ? I.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message) : e.fileName ? I.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message) : I.fatal("error: " + e.message)
                    },
                    log: function(e, t) {
                        e === this.LogLevel.FATAL && "object" === n(window.console) && "function" == typeof window.console.error && window.console.error(t)
                    },
                    debug: function(e) {
                        this.log(this.LogLevel.DEBUG, e)
                    },
                    info: function(e) {
                        this.log(this.LogLevel.INFO, e)
                    },
                    warn: function(e) {
                        this.log(this.LogLevel.WARN, e)
                    },
                    error: function(e) {
                        this.log(this.LogLevel.ERROR, e)
                    },
                    fatal: function(e) {
                        this.log(this.LogLevel.FATAL, e)
                    },
                    serialize: function(e) {
                        if (!e) return null;
                        "function" == typeof e.tree && (e = e.tree());
                        var t = i(Array(e.attributes.length).keys()).map((function(t) {
                            return e.attributes[t].nodeName
                        }));
                        t.sort();
                        var n = t.reduce((function(t, n) {
                            return "".concat(t, " ").concat(n, '="').concat(I.xmlescape(e.attributes.getNamedItem(n).value), '"')
                        }), "<".concat(e.nodeName));
                        if (e.childNodes.length > 0) {
                            n += ">";
                            for (var r = 0; r < e.childNodes.length; r++) {
                                var s = e.childNodes[r];
                                switch (s.nodeType) {
                                    case I.ElementType.NORMAL:
                                        n += I.serialize(s);
                                        break;
                                    case I.ElementType.TEXT:
                                        n += I.xmlescape(s.nodeValue);
                                        break;
                                    case I.ElementType.CDATA:
                                        n += "<![CDATA[" + s.nodeValue + "]]>"
                                }
                            }
                            n += "</" + e.nodeName + ">"
                        } else n += "/>";
                        return n
                    },
                    _requestId: 0,
                    _connectionPlugins: {},
                    addConnectionPlugin: function(e, t) {
                        I._connectionPlugins[e] = t
                    },
                    Builder: function(e, t) {
                        "presence" !== e && "message" !== e && "iq" !== e || (t && !t.xmlns ? t.xmlns = I.NS.CLIENT : t || (t = {
                            xmlns: I.NS.CLIENT
                        })), this.nodeTree = I.xmlElement(e, t), this.node = this.nodeTree
                    }
                };
                I.Builder.prototype = {
                    tree: function() {
                        return this.nodeTree
                    },
                    toString: function() {
                        return I.serialize(this.nodeTree)
                    },
                    up: function() {
                        return this.node = this.node.parentNode, this
                    },
                    root: function() {
                        return this.node = this.nodeTree, this
                    },
                    attrs: function(e) {
                        for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (void 0 === e[t] ? this.node.removeAttribute(t) : this.node.setAttribute(t, e[t]));
                        return this
                    },
                    c: function(e, t, n) {
                        var i = I.xmlElement(e, t, n);
                        return this.node.appendChild(i), "string" != typeof n && "number" != typeof n && (this.node = i), this
                    },
                    cnode: function(e) {
                        var t, n = I.xmlGenerator();
                        try {
                            t = void 0 !== n.importNode
                        } catch (e) {
                            t = !1
                        }
                        var i = t ? n.importNode(e, !0) : I.copyElement(e);
                        return this.node.appendChild(i), this.node = i, this
                    },
                    t: function(e) {
                        var t = I.xmlTextNode(e);
                        return this.node.appendChild(t), this
                    },
                    h: function(e) {
                        var t = document.createElement("body");
                        t.innerHTML = e;
                        for (var n = I.createHtml(t); n.childNodes.length > 0;) this.node.appendChild(n.childNodes[0]);
                        return this
                    }
                }, I.Handler = function(e, t, n, i, r, s, o) {
                    this.handler = e, this.ns = t, this.name = n, this.type = i, this.id = r, this.options = o || {
                        matchBareFromJid: !1,
                        ignoreNamespaceFragment: !1
                    }, this.options.matchBare && (I.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.'), this.options.matchBareFromJid = this.options.matchBare, delete this.options.matchBare), this.options.matchBareFromJid ? this.from = s ? I.getBareJidFromJid(s) : null : this.from = s, this.user = !0
                }, I.Handler.prototype = {
                    getNamespace: function(e) {
                        var t = e.getAttribute("xmlns");
                        return t && this.options.ignoreNamespaceFragment && (t = t.split("#")[0]), t
                    },
                    namespaceMatch: function(e) {
                        var t = this,
                            n = !1;
                        return !this.ns || (I.forEachChild(e, null, (function(e) {
                            t.getNamespace(e) === t.ns && (n = !0)
                        })), n || this.getNamespace(e) === this.ns)
                    },
                    isMatch: function(e) {
                        var t = e.getAttribute("from");
                        this.options.matchBareFromJid && (t = I.getBareJidFromJid(t));
                        var n = e.getAttribute("type");
                        return !(!this.namespaceMatch(e) || this.name && !I.isTagEqual(e, this.name) || this.type && (Array.isArray(this.type) ? -1 === this.type.indexOf(n) : n !== this.type) || this.id && e.getAttribute("id") !== this.id || this.from && t !== this.from)
                    },
                    run: function(e) {
                        var t = null;
                        try {
                            t = this.handler(e)
                        } catch (e) {
                            throw I._handleError(e), e
                        }
                        return t
                    },
                    toString: function() {
                        return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}"
                    }
                }, I.TimedHandler = function(e, t) {
                    this.period = e, this.handler = t, this.lastCalled = (new Date).getTime(), this.user = !0
                }, I.TimedHandler.prototype = {
                    run: function() {
                        return this.lastCalled = (new Date).getTime(), this.handler()
                    },
                    reset: function() {
                        this.lastCalled = (new Date).getTime()
                    },
                    toString: function() {
                        return "{TimedHandler: " + this.handler + "(" + this.period + ")}"
                    }
                }, I.Connection = function(e, t) {
                    var n = this;
                    this.service = e, this.options = t || {};
                    var i = this.options.protocol || "";
                    for (var r in 0 === e.indexOf("ws:") || 0 === e.indexOf("wss:") || 0 === i.indexOf("ws") ? this._proto = new I.Websocket(this) : this._proto = new I.Bosh(this), this.jid = "", this.domain = null, this.features = null, this._sasl_data = {}, this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.protocolErrorHandlers = {
                            HTTP: {},
                            websocket: {}
                        }, this._idleTimeout = null, this._disconnectTimeout = null, this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.do_authentication = !0, this.paused = !1, this.restored = !1, this._data = [], this._uniqueId = 0, this._sasl_success_handler = null, this._sasl_failure_handler = null, this._sasl_challenge_handler = null, this.maxRetries = 5, this._idleTimeout = setTimeout((function() {
                            return n._onIdle()
                        }), 100), C(this.options.cookies), this.registerSASLMechanisms(this.options.mechanisms), I._connectionPlugins)
                        if (Object.prototype.hasOwnProperty.call(I._connectionPlugins, r)) {
                            var s = function() {};
                            s.prototype = I._connectionPlugins[r], this[r] = new s, this[r].init(this)
                        }
                }, I.Connection.prototype = {
                    reset: function() {
                        this._proto._reset(), this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.restored = !1, this._data = [], this._requests = [], this._uniqueId = 0
                    },
                    pause: function() {
                        this.paused = !0
                    },
                    resume: function() {
                        this.paused = !1
                    },
                    getUniqueId: function(e) {
                        var t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
                            var t = 16 * Math.random() | 0;
                            return ("x" === e ? t : 3 & t | 8).toString(16)
                        }));
                        return "string" == typeof e || "number" == typeof e ? t + ":" + e : t + ""
                    },
                    addProtocolErrorHandler: function(e, t, n) {
                        this.protocolErrorHandlers[e][t] = n
                    },
                    connect: function(e, t, n, i, r, s, o) {
                        this.jid = e, this.authzid = I.getBareJidFromJid(this.jid), this.authcid = o || I.getNodeFromJid(this.jid), this.pass = t, this.servtype = "xmpp", this.connect_callback = n, this.disconnecting = !1, this.connected = !1, this.authenticated = !1, this.restored = !1, this.domain = I.getDomainFromJid(this.jid), this._changeConnectStatus(I.Status.CONNECTING, null), this._proto._connect(i, r, s)
                    },
                    attach: function(e, t, n, i, r, s, o) {
                        if (!(this._proto instanceof I.Bosh)) {
                            var a = new Error('The "attach" method can only be used with a BOSH connection.');
                            throw a.name = "StropheSessionError", a
                        }
                        this._proto._attach(e, t, n, i, r, s, o)
                    },
                    restore: function(e, t, n, i, r) {
                        if (!this._sessionCachingSupported()) {
                            var s = new Error('The "restore" method can only be used with a BOSH connection.');
                            throw s.name = "StropheSessionError", s
                        }
                        this._proto._restore(e, t, n, i, r)
                    },
                    _sessionCachingSupported: function() {
                        if (this._proto instanceof I.Bosh) {
                            if (!JSON) return !1;
                            try {
                                sessionStorage.setItem("_strophe_", "_strophe_"), sessionStorage.removeItem("_strophe_")
                            } catch (e) {
                                return !1
                            }
                            return !0
                        }
                        return !1
                    },
                    xmlInput: function(e) {},
                    xmlOutput: function(e) {},
                    rawInput: function(e) {},
                    rawOutput: function(e) {},
                    nextValidRid: function(e) {},
                    send: function(e) {
                        if (null !== e) {
                            if ("function" == typeof e.sort)
                                for (var t = 0; t < e.length; t++) this._queueData(e[t]);
                            else "function" == typeof e.tree ? this._queueData(e.tree()) : this._queueData(e);
                            this._proto._send()
                        }
                    },
                    flush: function() {
                        clearTimeout(this._idleTimeout), this._onIdle()
                    },
                    sendPresence: function(e, t, n, i) {
                        var r = this,
                            s = null;
                        "function" == typeof e.tree && (e = e.tree());
                        var o = e.getAttribute("id");
                        if (o || (o = this.getUniqueId("sendPresence"), e.setAttribute("id", o)), "function" == typeof t || "function" == typeof n) {
                            var a = this.addHandler((function(e) {
                                s && r.deleteTimedHandler(s), "error" === e.getAttribute("type") ? n && n(e) : t && t(e)
                            }), null, "presence", null, o);
                            i && (s = this.addTimedHandler(i, (function() {
                                return r.deleteHandler(a), n && n(null), !1
                            })))
                        }
                        return this.send(e), o
                    },
                    sendIQ: function(e, t, n, i) {
                        var r = this,
                            s = null;
                        "function" == typeof e.tree && (e = e.tree());
                        var o = e.getAttribute("id");
                        if (o || (o = this.getUniqueId("sendIQ"), e.setAttribute("id", o)), "function" == typeof t || "function" == typeof n) {
                            var a = this.addHandler((function(e) {
                                s && r.deleteTimedHandler(s);
                                var i = e.getAttribute("type");
                                if ("result" === i) t && t(e);
                                else {
                                    if ("error" !== i) {
                                        var o = new Error("Got bad IQ type of ".concat(i));
                                        throw o.name = "StropheError", o
                                    }
                                    n && n(e)
                                }
                            }), null, "iq", ["error", "result"], o);
                            i && (s = this.addTimedHandler(i, (function() {
                                return r.deleteHandler(a), n && n(null), !1
                            })))
                        }
                        return this.send(e), o
                    },
                    _queueData: function(e) {
                        if (null === e || !e.tagName || !e.childNodes) {
                            var t = new Error("Cannot queue non-DOMElement.");
                            throw t.name = "StropheError", t
                        }
                        this._data.push(e)
                    },
                    _sendRestart: function() {
                        var e = this;
                        this._data.push("restart"), this._proto._sendRestart(), this._idleTimeout = setTimeout((function() {
                            return e._onIdle()
                        }), 100)
                    },
                    addTimedHandler: function(e, t) {
                        var n = new I.TimedHandler(e, t);
                        return this.addTimeds.push(n), n
                    },
                    deleteTimedHandler: function(e) {
                        this.removeTimeds.push(e)
                    },
                    addHandler: function(e, t, n, i, r, s, o) {
                        var a = new I.Handler(e, t, n, i, r, s, o);
                        return this.addHandlers.push(a), a
                    },
                    deleteHandler: function(e) {
                        this.removeHandlers.push(e);
                        var t = this.addHandlers.indexOf(e);
                        t >= 0 && this.addHandlers.splice(t, 1)
                    },
                    registerSASLMechanisms: function(e) {
                        this.mechanisms = {}, (e = e || [I.SASLAnonymous, I.SASLExternal, I.SASLMD5, I.SASLOAuthBearer, I.SASLXOAuth2, I.SASLPlain, I.SASLSHA1]).forEach(this.registerSASLMechanism.bind(this))
                    },
                    registerSASLMechanism: function(e) {
                        this.mechanisms[e.prototype.name] = e
                    },
                    disconnect: function(e) {
                        if (this._changeConnectStatus(I.Status.DISCONNECTING, e), I.warn("Disconnect was called because: " + e), this.connected) {
                            var t = !1;
                            this.disconnecting = !0, this.authenticated && (t = w({
                                xmlns: I.NS.CLIENT,
                                type: "unavailable"
                            })), this._disconnectTimeout = this._addSysTimedHandler(3e3, this._onDisconnectTimeout.bind(this)), this._proto._disconnect(t)
                        } else I.warn("Disconnect was called before Strophe connected to the server"), this._proto._abortAllRequests(), this._doDisconnect()
                    },
                    _changeConnectStatus: function(e, t, n) {
                        for (var i in I._connectionPlugins)
                            if (Object.prototype.hasOwnProperty.call(I._connectionPlugins, i)) {
                                var r = this[i];
                                if (r.statusChanged) try {
                                    r.statusChanged(e, t)
                                } catch (e) {
                                    I.error("".concat(i, " plugin caused an exception changing status: ").concat(e))
                                }
                            } if (this.connect_callback) try {
                            this.connect_callback(e, t, n)
                        } catch (e) {
                            I._handleError(e), I.error("User connection callback caused an exception: ".concat(e))
                        }
                    },
                    _doDisconnect: function(e) {
                        "number" == typeof this._idleTimeout && clearTimeout(this._idleTimeout), null !== this._disconnectTimeout && (this.deleteTimedHandler(this._disconnectTimeout), this._disconnectTimeout = null), I.debug("_doDisconnect was called"), this._proto._doDisconnect(), this.authenticated = !1, this.disconnecting = !1, this.restored = !1, this.handlers = [], this.timedHandlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this._changeConnectStatus(I.Status.DISCONNECTED, e), this.connected = !1
                    },
                    _dataRecv: function(e, t) {
                        var n = this;
                        I.debug("_dataRecv called");
                        var i = this._proto._reqToData(e);
                        if (null !== i) {
                            for (this.xmlInput !== I.Connection.prototype.xmlInput && (i.nodeName === this._proto.strip && i.childNodes.length ? this.xmlInput(i.childNodes[0]) : this.xmlInput(i)), this.rawInput !== I.Connection.prototype.rawInput && (t ? this.rawInput(t) : this.rawInput(I.serialize(i))); this.removeHandlers.length > 0;) {
                                var r = this.removeHandlers.pop(),
                                    s = this.handlers.indexOf(r);
                                s >= 0 && this.handlers.splice(s, 1)
                            }
                            for (; this.addHandlers.length > 0;) this.handlers.push(this.addHandlers.pop());
                            if (this.disconnecting && this._proto._emptyQueue()) this._doDisconnect();
                            else {
                                var o = i.getAttribute("type");
                                if (null !== o && "terminate" === o) {
                                    if (this.disconnecting) return;
                                    var a = i.getAttribute("condition"),
                                        c = i.getElementsByTagName("conflict");
                                    return null !== a ? ("remote-stream-error" === a && c.length > 0 && (a = "conflict"), this._changeConnectStatus(I.Status.CONNFAIL, a)) : this._changeConnectStatus(I.Status.CONNFAIL, I.ErrorCondition.UNKOWN_REASON), void this._doDisconnect(a)
                                }
                                I.forEachChild(i, null, (function(e) {
                                    var t = n.handlers;
                                    n.handlers = [];
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        try {
                                            !r.isMatch(e) || !n.authenticated && r.user ? n.handlers.push(r) : r.run(e) && n.handlers.push(r)
                                        } catch (e) {
                                            I.warn("Removing Strophe handlers due to uncaught exception: " + e.message)
                                        }
                                    }
                                }))
                            }
                        }
                    },
                    mechanisms: {},
                    _connect_cb: function(e, t, n) {
                        var i;
                        I.debug("_connect_cb was called"), this.connected = !0;
                        try {
                            i = this._proto._reqToData(e)
                        } catch (e) {
                            if (e.name !== I.ErrorCondition.BAD_FORMAT) throw e;
                            this._changeConnectStatus(I.Status.CONNFAIL, I.ErrorCondition.BAD_FORMAT), this._doDisconnect(I.ErrorCondition.BAD_FORMAT)
                        }
                        if (i && (this.xmlInput !== I.Connection.prototype.xmlInput && (i.nodeName === this._proto.strip && i.childNodes.length ? this.xmlInput(i.childNodes[0]) : this.xmlInput(i)), this.rawInput !== I.Connection.prototype.rawInput && (n ? this.rawInput(n) : this.rawInput(I.serialize(i))), this._proto._connect_cb(i) !== I.Status.CONNFAIL))
                            if (i.getElementsByTagNameNS ? i.getElementsByTagNameNS(I.NS.STREAM, "features").length > 0 : i.getElementsByTagName("stream:features").length > 0 || i.getElementsByTagName("features").length > 0) {
                                var r = [],
                                    s = i.getElementsByTagName("mechanism");
                                if (s.length > 0)
                                    for (var o = 0; o < s.length; o++) {
                                        var a = I.getText(s[o]);
                                        this.mechanisms[a] && r.push(this.mechanisms[a])
                                    }
                                0 !== r.length || 0 !== i.getElementsByTagName("auth").length ? !1 !== this.do_authentication && this.authenticate(r) : this._proto._no_auth_received(t)
                            } else this._proto._no_auth_received(t)
                    },
                    sortMechanismsByPriority: function(e) {
                        for (var t = 0; t < e.length - 1; ++t) {
                            for (var n = t, i = t + 1; i < e.length; ++i) e[i].prototype.priority > e[n].prototype.priority && (n = i);
                            if (n !== t) {
                                var r = e[t];
                                e[t] = e[n], e[n] = r
                            }
                        }
                        return e
                    },
                    authenticate: function(e) {
                        this._attemptSASLAuth(e) || this._attemptLegacyAuth()
                    },
                    _attemptSASLAuth: function(e) {
                        e = this.sortMechanismsByPriority(e || []);
                        for (var t = !1, n = 0; n < e.length; ++n)
                            if (e[n].prototype.test(this)) {
                                this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null), this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null), this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null), this._sasl_mechanism = new e[n], this._sasl_mechanism.onStart(this);
                                var i = R("auth", {
                                    xmlns: I.NS.SASL,
                                    mechanism: this._sasl_mechanism.name
                                });
                                if (this._sasl_mechanism.isClientFirst) {
                                    var r = this._sasl_mechanism.onChallenge(this, null);
                                    i.t(btoa(r))
                                }
                                this.send(i.tree()), t = !0;
                                break
                            } return t
                    },
                    _sasl_challenge_cb: function(e) {
                        var t = atob(I.getText(e)),
                            n = this._sasl_mechanism.onChallenge(this, t),
                            i = R("response", {
                                xmlns: I.NS.SASL
                            });
                        return "" !== n && i.t(btoa(n)), this.send(i.tree()), !0
                    },
                    _attemptLegacyAuth: function() {
                        null === I.getNodeFromJid(this.jid) ? (this._changeConnectStatus(I.Status.CONNFAIL, I.ErrorCondition.MISSING_JID_NODE), this.disconnect(I.ErrorCondition.MISSING_JID_NODE)) : (this._changeConnectStatus(I.Status.AUTHENTICATING, null), this._addSysHandler(this._onLegacyAuthIQResult.bind(this), null, null, null, "_auth_1"), this.send(A({
                            type: "get",
                            to: this.domain,
                            id: "_auth_1"
                        }).c("query", {
                            xmlns: I.NS.AUTH
                        }).c("username", {}).t(I.getNodeFromJid(this.jid)).tree()))
                    },
                    _onLegacyAuthIQResult: function(e) {
                        var t = A({
                            type: "set",
                            id: "_auth_2"
                        }).c("query", {
                            xmlns: I.NS.AUTH
                        }).c("username", {}).t(I.getNodeFromJid(this.jid)).up().c("password").t(this.pass);
                        return I.getResourceFromJid(this.jid) || (this.jid = I.getBareJidFromJid(this.jid) + "/strophe"), t.up().c("resource", {}).t(I.getResourceFromJid(this.jid)), this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2"), this.send(t.tree()), !1
                    },
                    _sasl_success_cb: function(e) {
                        var t = this;
                        if (this._sasl_data["server-signature"]) {
                            var n, i = atob(I.getText(e)).match(/([a-z]+)=([^,]+)(,|$)/);
                            if ("v" === i[1] && (n = i[2]), n !== this._sasl_data["server-signature"]) return this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_data = {}, this._sasl_failure_cb(null)
                        }
                        I.info("SASL authentication succeeded."), this._sasl_mechanism && this._sasl_mechanism.onSuccess(), this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null);
                        var r = [],
                            s = function(e, n) {
                                for (; e.length;) t.deleteHandler(e.pop());
                                return t._onStreamFeaturesAfterSASL(n), !1
                            };
                        return r.push(this._addSysHandler((function(e) {
                            return s(r, e)
                        }), null, "stream:features", null, null)), r.push(this._addSysHandler((function(e) {
                            return s(r, e)
                        }), I.NS.STREAM, "features", null, null)), this._sendRestart(), !1
                    },
                    _onStreamFeaturesAfterSASL: function(e) {
                        this.features = e;
                        for (var t = 0; t < e.childNodes.length; t++) {
                            var n = e.childNodes[t];
                            "bind" === n.nodeName && (this.do_bind = !0), "session" === n.nodeName && (this.do_session = !0)
                        }
                        return this.do_bind ? (this.options.explicitResourceBinding ? this._changeConnectStatus(I.Status.BINDREQUIRED, null) : this.bind(), !1) : (this._changeConnectStatus(I.Status.AUTHFAIL, null), !1)
                    },
                    bind: function() {
                        if (this.do_bind) {
                            this._addSysHandler(this._onResourceBindResultIQ.bind(this), null, null, null, "_bind_auth_2");
                            var e = I.getResourceFromJid(this.jid);
                            e ? this.send(A({
                                type: "set",
                                id: "_bind_auth_2"
                            }).c("bind", {
                                xmlns: I.NS.BIND
                            }).c("resource", {}).t(e).tree()) : this.send(A({
                                type: "set",
                                id: "_bind_auth_2"
                            }).c("bind", {
                                xmlns: I.NS.BIND
                            }).tree())
                        } else I.log(I.LogLevel.INFO, 'Strophe.Connection.prototype.bind called but "do_bind" is false')
                    },
                    _onResourceBindResultIQ: function(e) {
                        var t;
                        if ("error" === e.getAttribute("type")) return I.warn("Resource binding failed."), e.getElementsByTagName("conflict").length > 0 && (t = I.ErrorCondition.CONFLICT), this._changeConnectStatus(I.Status.AUTHFAIL, t, e), !1;
                        var n = e.getElementsByTagName("bind");
                        if (!(n.length > 0)) return I.warn("Resource binding failed."), this._changeConnectStatus(I.Status.AUTHFAIL, null, e), !1;
                        var i = n[0].getElementsByTagName("jid");
                        i.length > 0 && (this.jid = I.getText(i[0]), this.do_session ? this._establishSession() : (this.authenticated = !0, this._changeConnectStatus(I.Status.CONNECTED, null)))
                    },
                    _establishSession: function() {
                        if (!this.do_session) throw new Error("Strophe.Connection.prototype._establishSession " + "called but apparently ".concat(I.NS.SESSION, " wasn't advertised by the server"));
                        this._addSysHandler(this._onSessionResultIQ.bind(this), null, null, null, "_session_auth_2"), this.send(A({
                            type: "set",
                            id: "_session_auth_2"
                        }).c("session", {
                            xmlns: I.NS.SESSION
                        }).tree())
                    },
                    _onSessionResultIQ: function(e) {
                        if ("result" === e.getAttribute("type")) this.authenticated = !0, this._changeConnectStatus(I.Status.CONNECTED, null);
                        else if ("error" === e.getAttribute("type")) return I.warn("Session creation failed."), this._changeConnectStatus(I.Status.AUTHFAIL, null, e), !1;
                        return !1
                    },
                    _sasl_failure_cb: function(e) {
                        return this._sasl_success_handler && (this.deleteHandler(this._sasl_success_handler), this._sasl_success_handler = null), this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_mechanism && this._sasl_mechanism.onFailure(), this._changeConnectStatus(I.Status.AUTHFAIL, null, e), !1
                    },
                    _auth2_cb: function(e) {
                        return "result" === e.getAttribute("type") ? (this.authenticated = !0, this._changeConnectStatus(I.Status.CONNECTED, null)) : "error" === e.getAttribute("type") && (this._changeConnectStatus(I.Status.AUTHFAIL, null, e), this.disconnect("authentication failed")), !1
                    },
                    _addSysTimedHandler: function(e, t) {
                        var n = new I.TimedHandler(e, t);
                        return n.user = !1, this.addTimeds.push(n), n
                    },
                    _addSysHandler: function(e, t, n, i, r) {
                        var s = new I.Handler(e, t, n, i, r);
                        return s.user = !1, this.addHandlers.push(s), s
                    },
                    _onDisconnectTimeout: function() {
                        return I.debug("_onDisconnectTimeout was called"), this._changeConnectStatus(I.Status.CONNTIMEOUT, null), this._proto._onDisconnectTimeout(), this._doDisconnect(), !1
                    },
                    _onIdle: function() {
                        for (var e = this; this.addTimeds.length > 0;) this.timedHandlers.push(this.addTimeds.pop());
                        for (; this.removeTimeds.length > 0;) {
                            var t = this.removeTimeds.pop(),
                                n = this.timedHandlers.indexOf(t);
                            n >= 0 && this.timedHandlers.splice(n, 1)
                        }
                        for (var i = (new Date).getTime(), r = [], s = 0; s < this.timedHandlers.length; s++) {
                            var o = this.timedHandlers[s];
                            !this.authenticated && o.user || (o.lastCalled + o.period - i <= 0 ? o.run() && r.push(o) : r.push(o))
                        }
                        this.timedHandlers = r, clearTimeout(this._idleTimeout), this._proto._onIdle(), this.connected && (this._idleTimeout = setTimeout((function() {
                            return e._onIdle()
                        }), 100))
                    }
                }, I.SASLMechanism = function(e, t, n) {
                    this.name = e, this.isClientFirst = t, this.priority = n
                }, I.SASLMechanism.prototype = {
                    test: function(e) {
                        return !0
                    },
                    onStart: function(e) {
                        this._connection = e
                    },
                    onChallenge: function(e, t) {
                        throw new Error("You should implement challenge handling!")
                    },
                    onFailure: function() {
                        this._connection = null
                    },
                    onSuccess: function() {
                        this._connection = null
                    }
                }, I.SASLAnonymous = function() {}, I.SASLAnonymous.prototype = new I.SASLMechanism("ANONYMOUS", !1, 20), I.SASLAnonymous.prototype.test = function(e) {
                    return null === e.authcid
                }, I.SASLPlain = function() {}, I.SASLPlain.prototype = new I.SASLMechanism("PLAIN", !0, 50), I.SASLPlain.prototype.test = function(e) {
                    return null !== e.authcid
                }, I.SASLPlain.prototype.onChallenge = function(e) {
                    var t = e.authzid;
                    return t += "\0", t += e.authcid, t += "\0", t += e.pass, b(t)
                }, I.SASLSHA1 = function() {}, I.SASLSHA1.prototype = new I.SASLMechanism("SCRAM-SHA-1", !0, 70), I.SASLSHA1.prototype.test = function(e) {
                    return null !== e.authcid
                }, I.SASLSHA1.prototype.onChallenge = function(e, t, n) {
                    var i = n || h.hexdigest("" + 1234567890 * Math.random()),
                        r = "n=" + b(e.authcid);
                    return r += ",r=", r += i, e._sasl_data.cnonce = i, e._sasl_data["client-first-message-bare"] = r, r = "n,," + r, this.onChallenge = function(e, t) {
                        for (var n, i, r, s, o, a, c, d, u = "c=biws,", l = "".concat(e._sasl_data["client-first-message-bare"], ",").concat(t, ","), h = e._sasl_data.cnonce, p = /([a-z]+)=([^,]+)(,|$)/; t.match(p);) {
                            var f = t.match(p);
                            switch (t = t.replace(f[0], ""), f[1]) {
                                case "r":
                                    n = f[2];
                                    break;
                                case "s":
                                    i = f[2];
                                    break;
                                case "i":
                                    r = f[2]
                            }
                        }
                        if (n.substr(0, h.length) !== h) return e._sasl_data = {}, e._sasl_failure_cb();
                        l += u += "r=" + n, i = atob(i), i += "\0\0\0";
                        var m = b(e.pass);
                        for (s = a = T.core_hmac_sha1(m, i), c = 1; c < r; c++) {
                            for (o = T.core_hmac_sha1(m, T.binb2str(a)), d = 0; d < 5; d++) s[d] ^= o[d];
                            a = o
                        }
                        s = T.binb2str(s);
                        var g = T.core_hmac_sha1(s, "Client Key"),
                            _ = T.str_hmac_sha1(s, "Server Key"),
                            v = T.core_hmac_sha1(T.str_sha1(T.binb2str(g)), l);
                        for (e._sasl_data["server-signature"] = T.b64_hmac_sha1(_, l), d = 0; d < 5; d++) g[d] ^= v[d];
                        return u += ",p=" + btoa(T.binb2str(g))
                    }, r
                }, I.SASLMD5 = function() {}, I.SASLMD5.prototype = new I.SASLMechanism("DIGEST-MD5", !1, 60), I.SASLMD5.prototype.test = function(e) {
                    return null !== e.authcid
                }, I.SASLMD5.prototype._quote = function(e) {
                    return '"' + e.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'
                }, I.SASLMD5.prototype.onChallenge = function(e, t, n) {
                    for (var i = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/, r = n || h.hexdigest("" + 1234567890 * Math.random()), s = "", o = null, a = ""; t.match(i);) {
                        var c = t.match(i);
                        switch (t = t.replace(c[0], ""), c[2] = c[2].replace(/^"(.+)"$/, "$1"), c[1]) {
                            case "realm":
                                s = c[2];
                                break;
                            case "nonce":
                                a = c[2];
                                break;
                            case "qop":
                                c[2];
                                break;
                            case "host":
                                o = c[2]
                        }
                    }
                    var d = e.servtype + "/" + e.domain;
                    null !== o && (d = d + "/" + o);
                    var u = b(e.authcid + ":" + s + ":" + this._connection.pass),
                        l = h.hash(u) + ":" + a + ":" + r,
                        p = "AUTHENTICATE:" + d,
                        f = "";
                    return f += "charset=utf-8,", f += "username=" + this._quote(b(e.authcid)) + ",", f += "realm=" + this._quote(s) + ",", f += "nonce=" + this._quote(a) + ",", f += "nc=00000001,", f += "cnonce=" + this._quote(r) + ",", f += "digest-uri=" + this._quote(d) + ",", f += "response=" + h.hexdigest(h.hexdigest(l) + ":" + a + ":00000001:" + r + ":auth:" + h.hexdigest(p)) + ",", f += "qop=auth", this.onChallenge = function() {
                        return ""
                    }, f
                }, I.SASLOAuthBearer = function() {}, I.SASLOAuthBearer.prototype = new I.SASLMechanism("OAUTHBEARER", !0, 40), I.SASLOAuthBearer.prototype.test = function(e) {
                    return null !== e.pass
                }, I.SASLOAuthBearer.prototype.onChallenge = function(e) {
                    var t = "n,";
                    return null !== e.authcid && (t = t + "a=" + e.authzid), t += ",", t += "", t += "auth=Bearer ", t += e.pass, t += "", b(t += "")
                }, I.SASLExternal = function() {}, I.SASLExternal.prototype = new I.SASLMechanism("EXTERNAL", !0, 10), I.SASLExternal.prototype.onChallenge = function(e) {
                    return e.authcid === e.authzid ? "" : e.authzid
                }, I.SASLXOAuth2 = function() {}, I.SASLXOAuth2.prototype = new I.SASLMechanism("X-OAUTH2", !0, 30), I.SASLXOAuth2.prototype.test = function(e) {
                    return null !== e.pass
                }, I.SASLXOAuth2.prototype.onChallenge = function(e) {
                    var t = "\0";
                    return null !== e.authcid && (t += e.authzid), t += "\0", t += e.pass, b(t)
                };
                var P = {
                        Strophe: I,
                        $build: R,
                        $iq: A,
                        $msg: function(e) {
                            return new I.Builder("message", e)
                        },
                        $pres: w,
                        SHA1: T,
                        MD5: h,
                        b64_hmac_sha1: T.b64_hmac_sha1,
                        b64_sha1: T.b64_sha1,
                        str_hmac_sha1: T.str_hmac_sha1,
                        str_sha1: T.str_sha1
                    },
                    D = P.Strophe,
                    O = P.$build;
                D.Request = function(e, t, n, i) {
                    this.id = ++D._requestId, this.xmlData = e, this.data = D.serialize(e), this.origFunc = t, this.func = t, this.rid = n, this.date = NaN, this.sends = i || 0, this.abort = !1, this.dead = null, this.age = function() {
                        return this.date ? (new Date - this.date) / 1e3 : 0
                    }, this.timeDead = function() {
                        return this.dead ? (new Date - this.dead) / 1e3 : 0
                    }, this.xhr = this._newXHR()
                }, D.Request.prototype = {
                    getResponse: function() {
                        var e = null;
                        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                            if ("parsererror" === (e = this.xhr.responseXML.documentElement).tagName) throw D.error("invalid response received"), D.error("responseText: " + this.xhr.responseText), D.error("responseXML: " + D.serialize(this.xhr.responseXML)), new Error("parsererror")
                        } else if (this.xhr.responseText) {
                            if (D.debug("Got responseText but no responseXML; attempting to parse it with DOMParser..."), !(e = (new DOMParser).parseFromString(this.xhr.responseText, "application/xml").documentElement)) throw new Error("Parsing produced null node");
                            if (e.querySelector("parsererror")) {
                                D.error("invalid response received: " + e.querySelector("parsererror").textContent), D.error("responseText: " + this.xhr.responseText);
                                var t = new Error;
                                throw t.name = D.ErrorCondition.BAD_FORMAT, t
                            }
                        }
                        return e
                    },
                    _newXHR: function() {
                        var e = null;
                        return window.XMLHttpRequest ? (e = new XMLHttpRequest).overrideMimeType && e.overrideMimeType("text/xml; charset=utf-8") : window.ActiveXObject && (e = new ActiveXObject("Microsoft.XMLHTTP")), e.onreadystatechange = this.func.bind(null, this), e
                    }
                }, D.Bosh = function(e) {
                    this._conn = e, this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.hold = 1, this.wait = 60, this.window = 5, this.errors = 0, this.inactivity = null, this.lastResponseHeaders = null, this._requests = []
                }, D.Bosh.prototype = {
                    strip: null,
                    _buildBody: function() {
                        var e = O("body", {
                            rid: this.rid++,
                            xmlns: D.NS.HTTPBIND
                        });
                        return null !== this.sid && e.attrs({
                            sid: this.sid
                        }), this._conn.options.keepalive && this._conn._sessionCachingSupported() && this._cacheSession(), e
                    },
                    _reset: function() {
                        this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.errors = 0, this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                    },
                    _connect: function(e, t, n) {
                        this.wait = e || this.wait, this.hold = t || this.hold, this.errors = 0;
                        var i = this._buildBody().attrs({
                            to: this._conn.domain,
                            "xml:lang": "en",
                            wait: this.wait,
                            hold: this.hold,
                            content: "text/xml; charset=utf-8",
                            ver: "1.6",
                            "xmpp:version": "1.0",
                            "xmlns:xmpp": D.NS.BOSH
                        });
                        n && i.attrs({
                            route: n
                        });
                        var r = this._conn._connect_cb;
                        this._requests.push(new D.Request(i.tree(), this._onRequestStateChange.bind(this, r.bind(this._conn)), i.tree().getAttribute("rid"))), this._throttledRequestHandler()
                    },
                    _attach: function(e, t, n, i, r, s, o) {
                        this._conn.jid = e, this.sid = t, this.rid = n, this._conn.connect_callback = i, this._conn.domain = D.getDomainFromJid(this._conn.jid), this._conn.authenticated = !0, this._conn.connected = !0, this.wait = r || this.wait, this.hold = s || this.hold, this.window = o || this.window, this._conn._changeConnectStatus(D.Status.ATTACHED, null)
                    },
                    _restore: function(e, t, n, i, r) {
                        var s = JSON.parse(window.sessionStorage.getItem("strophe-bosh-session"));
                        if (!(null != s && s.rid && s.sid && s.jid && (null == e || D.getBareJidFromJid(s.jid) === D.getBareJidFromJid(e) || null === D.getNodeFromJid(e) && D.getDomainFromJid(s.jid) === e))) {
                            var o = new Error("_restore: no restoreable session.");
                            throw o.name = "StropheSessionError", o
                        }
                        this._conn.restored = !0, this._attach(s.jid, s.sid, s.rid, t, n, i, r)
                    },
                    _cacheSession: function() {
                        this._conn.authenticated ? this._conn.jid && this.rid && this.sid && window.sessionStorage.setItem("strophe-bosh-session", JSON.stringify({
                            jid: this._conn.jid,
                            rid: this.rid,
                            sid: this.sid
                        })) : window.sessionStorage.removeItem("strophe-bosh-session")
                    },
                    _connect_cb: function(e) {
                        var t = e.getAttribute("type");
                        if (null !== t && "terminate" === t) {
                            var n = e.getAttribute("condition");
                            D.error("BOSH-Connection failed: " + n);
                            var i = e.getElementsByTagName("conflict");
                            return null !== n ? ("remote-stream-error" === n && i.length > 0 && (n = "conflict"), this._conn._changeConnectStatus(D.Status.CONNFAIL, n)) : this._conn._changeConnectStatus(D.Status.CONNFAIL, "unknown"), this._conn._doDisconnect(n), D.Status.CONNFAIL
                        }
                        this.sid || (this.sid = e.getAttribute("sid"));
                        var r = e.getAttribute("requests");
                        r && (this.window = parseInt(r, 10));
                        var s = e.getAttribute("hold");
                        s && (this.hold = parseInt(s, 10));
                        var o = e.getAttribute("wait");
                        o && (this.wait = parseInt(o, 10));
                        var a = e.getAttribute("inactivity");
                        a && (this.inactivity = parseInt(a, 10))
                    },
                    _disconnect: function(e) {
                        this._sendTerminate(e)
                    },
                    _doDisconnect: function() {
                        this.sid = null, this.rid = Math.floor(4294967295 * Math.random()), this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                    },
                    _emptyQueue: function() {
                        return 0 === this._requests.length
                    },
                    _callProtocolErrorHandlers: function(e) {
                        var t = this._getRequestStatus(e),
                            n = this._conn.protocolErrorHandlers.HTTP[t];
                        n && n.call(this, t)
                    },
                    _hitError: function(e) {
                        this.errors++, D.warn("request errored, status: " + e + ", number of errors: " + this.errors), this.errors > 4 && this._conn._onDisconnectTimeout()
                    },
                    _no_auth_received: function(e) {
                        D.warn("Server did not yet offer a supported authentication mechanism. Sending a blank poll request."), e = e ? e.bind(this._conn) : this._conn._connect_cb.bind(this._conn);
                        var t = this._buildBody();
                        this._requests.push(new D.Request(t.tree(), this._onRequestStateChange.bind(this, e), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
                    },
                    _onDisconnectTimeout: function() {
                        this._abortAllRequests()
                    },
                    _abortAllRequests: function() {
                        for (; this._requests.length > 0;) {
                            var e = this._requests.pop();
                            e.abort = !0, e.xhr.abort(), e.xhr.onreadystatechange = function() {}
                        }
                    },
                    _onIdle: function() {
                        var e = this._conn._data;
                        if (this._conn.authenticated && 0 === this._requests.length && 0 === e.length && !this._conn.disconnecting && (D.debug("no requests during idle cycle, sending blank request"), e.push(null)), !this._conn.paused) {
                            if (this._requests.length < 2 && e.length > 0) {
                                for (var t = this._buildBody(), n = 0; n < e.length; n++) null !== e[n] && ("restart" === e[n] ? t.attrs({
                                    to: this._conn.domain,
                                    "xml:lang": "en",
                                    "xmpp:restart": "true",
                                    "xmlns:xmpp": D.NS.BOSH
                                }) : t.cnode(e[n]).up());
                                delete this._conn._data, this._conn._data = [], this._requests.push(new D.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
                            }
                            if (this._requests.length > 0) {
                                var i = this._requests[0].age();
                                null !== this._requests[0].dead && this._requests[0].timeDead() > Math.floor(D.SECONDARY_TIMEOUT * this.wait) && this._throttledRequestHandler(), i > Math.floor(D.TIMEOUT * this.wait) && (D.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(D.TIMEOUT * this.wait) + " seconds since last activity"), this._throttledRequestHandler())
                            }
                        }
                    },
                    _getRequestStatus: function(e, t) {
                        var n;
                        if (4 === e.xhr.readyState) try {
                            n = e.xhr.status
                        } catch (e) {
                            D.error("Caught an error while retrieving a request's status, reqStatus: " + n)
                        }
                        return void 0 === n && (n = "number" == typeof t ? t : 0), n
                    },
                    _onRequestStateChange: function(e, t) {
                        if (D.debug("request id " + t.id + "." + t.sends + " state changed to " + t.xhr.readyState), t.abort) t.abort = !1;
                        else if (4 === t.xhr.readyState) {
                            var n = this._getRequestStatus(t);
                            if (this.lastResponseHeaders = t.xhr.getAllResponseHeaders(), this.disconnecting && n >= 400) return this._hitError(n), void this._callProtocolErrorHandlers(t);
                            var i = n > 0 && n < 500,
                                r = t.sends > this._conn.maxRetries;
                            if ((i || r) && (this._removeRequest(t), D.debug("request id " + t.id + " should now be removed")), 200 === n) {
                                var s = this._requests[0] === t;
                                (this._requests[1] === t || s && this._requests.length > 0 && this._requests[0].age() > Math.floor(D.SECONDARY_TIMEOUT * this.wait)) && this._restartRequest(0), this._conn.nextValidRid(Number(t.rid) + 1), D.debug("request id " + t.id + "." + t.sends + " got 200"), e(t), this.errors = 0
                            } else 0 === n || n >= 400 && n < 600 || n >= 12e3 ? (D.error("request id " + t.id + "." + t.sends + " error " + n + " happened"), this._hitError(n), this._callProtocolErrorHandlers(t), n >= 400 && n < 500 && (this._conn._changeConnectStatus(D.Status.DISCONNECTING, null), this._conn._doDisconnect())) : D.error("request id " + t.id + "." + t.sends + " error " + n + " happened");
                            i || r ? r && !this._conn.connected && this._conn._changeConnectStatus(D.Status.CONNFAIL, "giving-up") : this._throttledRequestHandler()
                        }
                    },
                    _processRequest: function(e) {
                        var t = this,
                            n = this._requests[e],
                            i = this._getRequestStatus(n, -1);
                        if (n.sends > this._conn.maxRetries) this._conn._onDisconnectTimeout();
                        else {
                            var r = n.age(),
                                s = !isNaN(r) && r > Math.floor(D.TIMEOUT * this.wait),
                                o = null !== n.dead && n.timeDead() > Math.floor(D.SECONDARY_TIMEOUT * this.wait),
                                a = 4 === n.xhr.readyState && (i < 1 || i >= 500);
                            if ((s || o || a) && (o && D.error("Request ".concat(this._requests[e].id, " timed out (secondary), restarting")), n.abort = !0, n.xhr.abort(), n.xhr.onreadystatechange = function() {}, this._requests[e] = new D.Request(n.xmlData, n.origFunc, n.rid, n.sends), n = this._requests[e]), 0 === n.xhr.readyState) {
                                D.debug("request id " + n.id + "." + n.sends + " posting");
                                try {
                                    var c = this._conn.options.contentType || "text/xml; charset=utf-8";
                                    n.xhr.open("POST", this._conn.service, !this._conn.options.sync), void 0 !== n.xhr.setRequestHeader && n.xhr.setRequestHeader("Content-Type", c), this._conn.options.withCredentials && (n.xhr.withCredentials = !0)
                                } catch (e) {
                                    return D.error("XHR open failed: " + e.toString()), this._conn.connected || this._conn._changeConnectStatus(D.Status.CONNFAIL, "bad-service"), void this._conn.disconnect()
                                }
                                var d = function() {
                                    if (n.date = new Date, t._conn.options.customHeaders) {
                                        var e = t._conn.options.customHeaders;
                                        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && n.xhr.setRequestHeader(i, e[i])
                                    }
                                    n.xhr.send(n.data)
                                };
                                if (n.sends > 1) {
                                    var u = 1e3 * Math.min(Math.floor(D.TIMEOUT * this.wait), Math.pow(n.sends, 3));
                                    setTimeout((function() {
                                        d()
                                    }), u)
                                } else d();
                                n.sends++, this._conn.xmlOutput !== D.Connection.prototype.xmlOutput && (n.xmlData.nodeName === this.strip && n.xmlData.childNodes.length ? this._conn.xmlOutput(n.xmlData.childNodes[0]) : this._conn.xmlOutput(n.xmlData)), this._conn.rawOutput !== D.Connection.prototype.rawOutput && this._conn.rawOutput(n.data)
                            } else D.debug("_processRequest: " + (0 === e ? "first" : "second") + " request has readyState of " + n.xhr.readyState)
                        }
                    },
                    _removeRequest: function(e) {
                        D.debug("removing request");
                        for (var t = this._requests.length - 1; t >= 0; t--) e === this._requests[t] && this._requests.splice(t, 1);
                        e.xhr.onreadystatechange = function() {}, this._throttledRequestHandler()
                    },
                    _restartRequest: function(e) {
                        var t = this._requests[e];
                        null === t.dead && (t.dead = new Date), this._processRequest(e)
                    },
                    _reqToData: function(e) {
                        try {
                            return e.getResponse()
                        } catch (e) {
                            if ("parsererror" !== e.message) throw e;
                            this._conn.disconnect("strophe-parsererror")
                        }
                    },
                    _sendTerminate: function(e) {
                        D.debug("_sendTerminate was called");
                        var t = this._buildBody().attrs({
                            type: "terminate"
                        });
                        e && t.cnode(e.tree());
                        var n = new D.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"));
                        this._requests.push(n), this._throttledRequestHandler()
                    },
                    _send: function() {
                        var e = this;
                        clearTimeout(this._conn._idleTimeout), this._throttledRequestHandler(), this._conn._idleTimeout = setTimeout((function() {
                            return e._conn._onIdle()
                        }), 100)
                    },
                    _sendRestart: function() {
                        this._throttledRequestHandler(), clearTimeout(this._conn._idleTimeout)
                    },
                    _throttledRequestHandler: function() {
                        this._requests ? D.debug("_throttledRequestHandler called with " + this._requests.length + " requests") : D.debug("_throttledRequestHandler called with undefined requests"), this._requests && 0 !== this._requests.length && (this._requests.length > 0 && this._processRequest(0), this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window && this._processRequest(1))
                    }
                };
                var N = P.Strophe,
                    M = P.$build;
                return N.Websocket = function(e) {
                    this._conn = e, this.strip = "wrapper";
                    var t = e.service;
                    if (0 !== t.indexOf("ws:") && 0 !== t.indexOf("wss:")) {
                        var n = "";
                        "ws" === e.options.protocol && "https:" !== window.location.protocol ? n += "ws" : n += "wss", n += "://" + window.location.host, 0 !== t.indexOf("/") ? n += window.location.pathname + t : n += t, e.service = n
                    }
                }, N.Websocket.prototype = {
                    _buildStream: function() {
                        return M("open", {
                            xmlns: N.NS.FRAMING,
                            to: this._conn.domain,
                            version: "1.0"
                        })
                    },
                    _check_streamerror: function(e, t) {
                        var n;
                        if (0 === (n = e.getElementsByTagNameNS ? e.getElementsByTagNameNS(N.NS.STREAM, "error") : e.getElementsByTagName("stream:error")).length) return !1;
                        for (var i = n[0], r = "", s = "", o = 0; o < i.childNodes.length; o++) {
                            var a = i.childNodes[o];
                            if ("urn:ietf:params:xml:ns:xmpp-streams" !== a.getAttribute("xmlns")) break;
                            "text" === a.nodeName ? s = a.textContent : r = a.nodeName
                        }
                        var c = "WebSocket stream error: ";
                        return c += r || "unknown", s && (c += " - " + s), N.error(c), this._conn._changeConnectStatus(t, r), this._conn._doDisconnect(), !0
                    },
                    _reset: function() {},
                    _connect: function() {
                        this._closeSocket(), this.socket = new WebSocket(this._conn.service, "xmpp"), this.socket.onopen = this._onOpen.bind(this), this.socket.onerror = this._onError.bind(this), this.socket.onclose = this._onClose.bind(this), this.socket.onmessage = this._connect_cb_wrapper.bind(this)
                    },
                    _connect_cb: function(e) {
                        if (this._check_streamerror(e, N.Status.CONNFAIL)) return N.Status.CONNFAIL
                    },
                    _handleStreamStart: function(e) {
                        var t = !1,
                            n = e.getAttribute("xmlns");
                        "string" != typeof n ? t = "Missing xmlns in <open />" : n !== N.NS.FRAMING && (t = "Wrong xmlns in <open />: " + n);
                        var i = e.getAttribute("version");
                        return "string" != typeof i ? t = "Missing version in <open />" : "1.0" !== i && (t = "Wrong version in <open />: " + i), !t || (this._conn._changeConnectStatus(N.Status.CONNFAIL, t), this._conn._doDisconnect(), !1)
                    },
                    _connect_cb_wrapper: function(e) {
                        if (0 === e.data.indexOf("<open ") || 0 === e.data.indexOf("<?xml")) {
                            var t = e.data.replace(/^(<\?.*?\?>\s*)*/, "");
                            if ("" === t) return;
                            var n = (new DOMParser).parseFromString(t, "text/xml").documentElement;
                            this._conn.xmlInput(n), this._conn.rawInput(e.data), this._handleStreamStart(n) && this._connect_cb(n)
                        } else if (0 === e.data.indexOf("<close ")) {
                            var i = (new DOMParser).parseFromString(e.data, "text/xml").documentElement;
                            this._conn.xmlInput(i), this._conn.rawInput(e.data);
                            var r = i.getAttribute("see-other-uri");
                            if (r) {
                                var s = this._conn.service;
                                (s.indexOf("wss:") >= 0 && r.indexOf("wss:") >= 0 || s.indexOf("ws:") >= 0) && (this._conn._changeConnectStatus(N.Status.REDIRECT, "Received see-other-uri, resetting connection"), this._conn.reset(), this._conn.service = r, this._connect())
                            } else this._conn._changeConnectStatus(N.Status.CONNFAIL, "Received closing stream"), this._conn._doDisconnect()
                        } else {
                            var o = this._streamWrap(e.data),
                                a = (new DOMParser).parseFromString(o, "text/xml").documentElement;
                            this.socket.onmessage = this._onMessage.bind(this), this._conn._connect_cb(a, null, e.data)
                        }
                    },
                    _disconnect: function(e) {
                        if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
                            e && this._conn.send(e);
                            var t = M("close", {
                                xmlns: N.NS.FRAMING
                            });
                            this._conn.xmlOutput(t.tree());
                            var n = N.serialize(t);
                            this._conn.rawOutput(n);
                            try {
                                this.socket.send(n)
                            } catch (e) {
                                N.warn("Couldn't send <close /> tag.")
                            }
                        }
                        this._conn._doDisconnect()
                    },
                    _doDisconnect: function() {
                        N.debug("WebSockets _doDisconnect was called"), this._closeSocket()
                    },
                    _streamWrap: function(e) {
                        return "<wrapper>" + e + "</wrapper>"
                    },
                    _closeSocket: function() {
                        if (this.socket) try {
                            this.socket.onclose = null, this.socket.onerror = null, this.socket.onmessage = null, this.socket.close()
                        } catch (e) {
                            N.debug(e.message)
                        }
                        this.socket = null
                    },
                    _emptyQueue: function() {
                        return !0
                    },
                    _onClose: function(e) {
                        this._conn.connected && !this._conn.disconnecting ? (N.error("Websocket closed unexpectedly"), this._conn._doDisconnect()) : e && 1006 === e.code && !this._conn.connected && this.socket ? (N.error("Websocket closed unexcectedly"), this._conn._changeConnectStatus(N.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._conn._doDisconnect()) : N.debug("Websocket closed")
                    },
                    _no_auth_received: function(e) {
                        N.error("Server did not offer a supported authentication mechanism"), this._conn._changeConnectStatus(N.Status.CONNFAIL, N.ErrorCondition.NO_AUTH_MECH), e && e.call(this._conn), this._conn._doDisconnect()
                    },
                    _onDisconnectTimeout: function() {},
                    _abortAllRequests: function() {},
                    _onError: function(e) {
                        N.error("Websocket error " + e), this._conn._changeConnectStatus(N.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._disconnect()
                    },
                    _onIdle: function() {
                        var e = this._conn._data;
                        if (e.length > 0 && !this._conn.paused) {
                            for (var t = 0; t < e.length; t++)
                                if (null !== e[t]) {
                                    var n = void 0;
                                    n = "restart" === e[t] ? this._buildStream().tree() : e[t];
                                    var i = N.serialize(n);
                                    this._conn.xmlOutput(n), this._conn.rawOutput(i), this.socket.send(i)
                                } this._conn._data = []
                        }
                    },
                    _onMessage: function(e) {
                        var t, n = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
                        if (e.data === n) return this._conn.rawInput(n), this._conn.xmlInput(e), void(this._conn.disconnecting || this._conn._doDisconnect());
                        if (0 === e.data.search("<open ")) {
                            if (t = (new DOMParser).parseFromString(e.data, "text/xml").documentElement, !this._handleStreamStart(t)) return
                        } else {
                            var i = this._streamWrap(e.data);
                            t = (new DOMParser).parseFromString(i, "text/xml").documentElement
                        }
                        return this._check_streamerror(t, N.Status.ERROR) ? void 0 : this._conn.disconnecting && "presence" === t.firstChild.nodeName && "unavailable" === t.firstChild.getAttribute("type") ? (this._conn.xmlInput(t), void this._conn.rawInput(N.serialize(t))) : void this._conn._dataRecv(t, e.data)
                    },
                    _onOpen: function() {
                        N.debug("Websocket open");
                        var e = this._buildStream();
                        this._conn.xmlOutput(e.tree());
                        var t = N.serialize(e);
                        this._conn.rawOutput(t), this.socket.send(t)
                    },
                    _reqToData: function(e) {
                        return e
                    },
                    _send: function() {
                        this._conn.flush()
                    },
                    _sendRestart: function() {
                        clearTimeout(this._conn._idleTimeout), this._conn._onIdle.bind(this._conn)()
                    }
                }, e.Strophe = P.Strophe, e.$build = P.$build, e.$iq = P.$iq, e.$msg = P.$msg, e.$pres = P.$pres, P
            }, e.exports = n()
        }).call(this, n(43))
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "AUDIO_INPUT_STATE_CHANGE", (function() {
            return i
        })), n.d(t, "AUTH_STATUS_CHANGED", (function() {
            return r
        })), n.d(t, "AVATAR_CHANGED", (function() {
            return s
        })), n.d(t, "BEFORE_STATISTICS_DISPOSED", (function() {
            return o
        })), n.d(t, "CONFERENCE_ERROR", (function() {
            return a
        })), n.d(t, "CONFERENCE_FAILED", (function() {
            return c
        })), n.d(t, "CONFERENCE_JOINED", (function() {
            return d
        })), n.d(t, "CONFERENCE_LEFT", (function() {
            return u
        })), n.d(t, "CONNECTION_ESTABLISHED", (function() {
            return l
        })), n.d(t, "CONNECTION_INTERRUPTED", (function() {
            return h
        })), n.d(t, "CONNECTION_RESTORED", (function() {
            return p
        })), n.d(t, "DATA_CHANNEL_OPENED", (function() {
            return f
        })), n.d(t, "DISPLAY_NAME_CHANGED", (function() {
            return m
        })), n.d(t, "DOMINANT_SPEAKER_CHANGED", (function() {
            return g
        })), n.d(t, "CONFERENCE_CREATED_TIMESTAMP", (function() {
            return _
        })), n.d(t, "DTMF_SUPPORT_CHANGED", (function() {
            return v
        })), n.d(t, "ENDPOINT_MESSAGE_RECEIVED", (function() {
            return S
        })), n.d(t, "JVB121_STATUS", (function() {
            return y
        })), n.d(t, "KICKED", (function() {
            return E
        })), n.d(t, "PARTICIPANT_KICKED", (function() {
            return T
        })), n.d(t, "LAST_N_ENDPOINTS_CHANGED", (function() {
            return b
        })), n.d(t, "LOCK_STATE_CHANGED", (function() {
            return C
        })), n.d(t, "SERVER_REGION_CHANGED", (function() {
            return R
        })), n.d(t, "MESSAGE_RECEIVED", (function() {
            return A
        })), n.d(t, "NO_AUDIO_INPUT", (function() {
            return w
        })), n.d(t, "NOISY_MIC", (function() {
            return I
        })), n.d(t, "PRIVATE_MESSAGE_RECEIVED", (function() {
            return P
        })), n.d(t, "PARTICIPANT_CONN_STATUS_CHANGED", (function() {
            return D
        })), n.d(t, "PARTCIPANT_FEATURES_CHANGED", (function() {
            return O
        })), n.d(t, "PARTICIPANT_PROPERTY_CHANGED", (function() {
            return N
        })), n.d(t, "P2P_STATUS", (function() {
            return M
        })), n.d(t, "PHONE_NUMBER_CHANGED", (function() {
            return L
        })), n.d(t, "PROPERTIES_CHANGED", (function() {
            return k
        })), n.d(t, "RECORDER_STATE_CHANGED", (function() {
            return x
        })), n.d(t, "VIDEO_SIP_GW_AVAILABILITY_CHANGED", (function() {
            return F
        })), n.d(t, "VIDEO_SIP_GW_SESSION_STATE_CHANGED", (function() {
            return j
        })), n.d(t, "START_MUTED_POLICY_CHANGED", (function() {
            return U
        })), n.d(t, "STARTED_MUTED", (function() {
            return H
        })), n.d(t, "SUBJECT_CHANGED", (function() {
            return J
        })), n.d(t, "SUSPEND_DETECTED", (function() {
            return B
        })), n.d(t, "TALK_WHILE_MUTED", (function() {
            return G
        })), n.d(t, "TRACK_ADDED", (function() {
            return $
        })), n.d(t, "TRACK_AUDIO_LEVEL_CHANGED", (function() {
            return V
        })), n.d(t, "TRACK_MUTE_CHANGED", (function() {
            return q
        })), n.d(t, "TRACK_REMOVED", (function() {
            return K
        })), n.d(t, "TRANSCRIPTION_STATUS_CHANGED", (function() {
            return W
        })), n.d(t, "USER_JOINED", (function() {
            return z
        })), n.d(t, "USER_LEFT", (function() {
            return X
        })), n.d(t, "USER_ROLE_CHANGED", (function() {
            return Q
        })), n.d(t, "USER_STATUS_CHANGED", (function() {
            return Y
        })), n.d(t, "BOT_TYPE_CHANGED", (function() {
            return Z
        }));
        const i = "conference.audio_input_state_changed",
            r = "conference.auth_status_changed",
            s = "conference.avatarChanged",
            o = "conference.beforeStatisticsDisposed",
            a = "conference.error",
            c = "conference.failed",
            d = "conference.joined",
            u = "conference.left",
            l = "conference.connectionEstablished",
            h = "conference.connectionInterrupted",
            p = "conference.connectionRestored",
            f = "conference.dataChannelOpened",
            m = "conference.displayNameChanged",
            g = "conference.dominantSpeaker",
            _ = "conference.createdTimestamp",
            v = "conference.dtmfSupportChanged",
            S = "conference.endpoint_message_received",
            y = "conference.jvb121Status",
            E = "conference.kicked",
            T = "conference.participant_kicked",
            b = "conference.lastNEndpointsChanged",
            C = "conference.lock_state_changed",
            R = "conference.server_region_changed",
            A = "conference.messageReceived",
            w = "conference.no_audio_input",
            I = "conference.noisy_mic",
            P = "conference.privateMessageReceived",
            D = "conference.participant_conn_status_changed",
            O = "conference.partcipant_features_changed",
            N = "conference.participant_property_changed",
            M = "conference.p2pStatus",
            L = "conference.phoneNumberChanged",
            k = "conference.propertiesChanged",
            x = "conference.recorderStateChanged",
            F = "conference.videoSIPGWAvailabilityChanged",
            j = "conference.videoSIPGWSessionStateChanged",
            U = "conference.start_muted_policy_changed",
            H = "conference.started_muted",
            J = "conference.subjectChanged",
            B = "conference.suspendDetected",
            G = "conference.talk_while_muted",
            $ = "conference.trackAdded",
            V = "conference.audioLevelsChanged",
            q = "conference.trackMuteChanged",
            K = "conference.trackRemoved",
            W = "conference.transcriptionStatusChanged",
            z = "conference.userJoined",
            X = "conference.userLeft",
            Q = "conference.roleChanged",
            Y = "conference.statusChanged",
            Z = "conference.bot_type_changed"
    }, function(e, t, n) {
        "use strict";
        var i = n(76);
        t.a = new i.a
    }, function(e, t, n) {
        var i = n(69),
            r = n(135),
            s = {},
            o = [],
            a = i.levels.TRACE;
        e.exports = {
            addGlobalTransport: function(e) {
                i.addGlobalTransport(e)
            },
            removeGlobalTransport: function(e) {
                i.removeGlobalTransport(e)
            },
            setGlobalOptions: function(e) {
                i.setGlobalOptions(e)
            },
            getLogger: function(e, t, n) {
                var r = new i(a, e, t, n);
                return e ? (s[e] = s[e] || [], s[e].push(r)) : o.push(r), r
            },
            setLogLevelById: function(e, t) {
                for (var n = t ? s[t] || [] : o, i = 0; i < n.length; i++) n[i].setLevel(e)
            },
            setLogLevel: function(e) {
                a = e;
                for (var t = 0; t < o.length; t++) o[t].setLevel(e);
                for (var n in s) {
                    var i = s[n] || [];
                    for (t = 0; t < i.length; t++) i[t].setLevel(e)
                }
            },
            levels: i.levels,
            LogCollector: r
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return S
            }));
            var i = n(19),
                r = n.n(i),
                s = n(7),
                o = n(75),
                a = n(33),
                c = n(52),
                d = n(78),
                u = n(3),
                l = n(53),
                h = n.n(l),
                p = n(16),
                f = n(26);
            const m = n(4).getLogger(e);
            let g, _ = !1;

            function v(e) {
                a.a.isBackendInitialized() || a.a.initBackend({
                    callStatsID: e.callStatsID,
                    callStatsSecret: e.callStatsSecret,
                    userName: e.userName,
                    aliasName: e.aliasName,
                    applicationName: e.applicationName,
                    getWiFiStatsMethod: e.getWiFiStatsMethod,
                    confID: e.confID
                }) || m.error("CallStats Backend initialization failed bad")
            }

            function S(e, t) {
                this.rtpStatsMap = new Map, this.eventEmitter = new r.a, this.xmpp = e, this.options = t || {}, this.callStatsIntegrationEnabled = this.options.callStatsID && this.options.callStatsSecret && !0 !== S.disableThirdPartyRequests, this.callStatsIntegrationEnabled && (this.callStatsApplicationLogsDisabled = this.options.callStatsApplicationLogsDisabled, u.a.isReactNative() ? v(this.options) : function(e) {
                    _ || (h.a.loadScript(e.customScriptUrl || "https://api.callstats.io/static/callstats-ws.min.js", !0, !0, void 0, () => v(e)), _ = !0)
                }(this.options), this.options.confID || m.warn('"confID" is not defined'), this.options.callStatsConfIDNamespace || m.warn('"callStatsConfIDNamespace" is not defined')), this.callsStatsInstances = new Map, S.instances.add(this)
            }
            S.init = function(e) {
                S.audioLevelsEnabled = !e.disableAudioLevels, "number" == typeof e.pcStatsInterval && (S.pcStatsInterval = e.pcStatsInterval), "number" == typeof e.audioLevelsInterval && (S.audioLevelsInterval = e.audioLevelsInterval), S.disableThirdPartyRequests = e.disableThirdPartyRequests
            }, S.audioLevelsEnabled = !1, S.audioLevelsInterval = 200, S.pcStatsInterval = 1e4, S.disableThirdPartyRequests = !1, S.analytics = o.a, Object.defineProperty(S, "instances", {
                get: () => (g || (g = new Set), g)
            }), S.prototype.startRemoteStats = function(e) {
                this.stopRemoteStats(e);
                try {
                    const t = new d.a(e, S.audioLevelsInterval, S.pcStatsInterval, this.eventEmitter);
                    t.start(S.audioLevelsEnabled), this.rtpStatsMap.set(e.id, t)
                } catch (e) {
                    m.error(`Failed to start collecting remote statistics: ${e}`)
                }
            }, S.localStats = [], S.startLocalStats = function(e, t) {
                if (!S.audioLevelsEnabled) return;
                const n = new c.a(e, S.audioLevelsInterval, t);
                this.localStats.push(n), n.start()
            }, S.prototype.addAudioLevelListener = function(e) {
                S.audioLevelsEnabled && this.eventEmitter.on(f.a, e)
            }, S.prototype.removeAudioLevelListener = function(e) {
                S.audioLevelsEnabled && this.eventEmitter.removeListener(f.a, e)
            }, S.prototype.addBeforeDisposedListener = function(e) {
                this.eventEmitter.on(f.b, e)
            }, S.prototype.removeBeforeDisposedListener = function(e) {
                this.eventEmitter.removeListener(f.b, e)
            }, S.prototype.addConnectionStatsListener = function(e) {
                this.eventEmitter.on(f.d, e)
            }, S.prototype.removeConnectionStatsListener = function(e) {
                this.eventEmitter.removeListener(f.d, e)
            }, S.prototype.addByteSentStatsListener = function(e) {
                this.eventEmitter.on(f.c, e)
            }, S.prototype.removeByteSentStatsListener = function(e) {
                this.eventEmitter.removeListener(f.c, e)
            }, S.prototype.dispose = function() {
                try {
                    this.callsStatsInstances.size || this.eventEmitter.emit(f.b);
                    for (const e of this.callsStatsInstances.values()) this.stopCallStats(e.tpc);
                    for (const e of this.rtpStatsMap.keys()) this._stopRemoteStats(e);
                    this.eventEmitter && this.eventEmitter.removeAllListeners()
                } finally {
                    S.instances.delete(this)
                }
            }, S.stopLocalStats = function(e) {
                if (S.audioLevelsEnabled)
                    for (let t = 0; t < S.localStats.length; t++)
                        if (S.localStats[t].stream === e) {
                            S.localStats.splice(t, 1)[0].stop();
                            break
                        }
            }, S.prototype._stopRemoteStats = function(e) {
                const t = this.rtpStatsMap.get(e);
                t && (t.stop(), this.rtpStatsMap.delete(e))
            }, S.prototype.stopRemoteStats = function(e) {
                this._stopRemoteStats(e.id)
            }, S.prototype.startCallStats = function(e, t) {
                if (!this.callStatsIntegrationEnabled) return;
                if (this.callsStatsInstances.has(e.id)) return void m.error("CallStats instance for ${tpc} exists already");
                m.info(`Starting CallStats for ${e}...`);
                const n = new a.a(e, {
                    confID: this._getCallStatsConfID(),
                    remoteUserID: t
                });
                this.callsStatsInstances.set(e.id, n)
            }, S._getAllCallStatsInstances = function() {
                const e = new Set;
                for (const t of S.instances)
                    for (const n of t.callsStatsInstances.values()) e.add(n);
                return e
            }, S.prototype._getCallStatsConfID = function() {
                return this.options.callStatsConfIDNamespace ? `${this.options.callStatsConfIDNamespace}/${this.options.roomName}` : this.options.roomName
            }, S.prototype.stopCallStats = function(e) {
                const t = this.callsStatsInstances.get(e.id);
                t && (1 === this.callsStatsInstances.size && this.eventEmitter.emit(f.b), this.callsStatsInstances.delete(e.id), t.sendTerminateEvent())
            }, S.prototype.isCallstatsEnabled = function() {
                return this.callStatsIntegrationEnabled
            }, S.prototype.sendConnectionResumeOrHoldEvent = function(e, t) {
                const n = this.callsStatsInstances.get(e.id);
                n && n.sendResumeOrHoldEvent(t)
            }, S.prototype.sendIceConnectionFailedEvent = function(e) {
                const t = this.callsStatsInstances.get(e.id);
                t && t.sendIceConnectionFailedEvent()
            }, S.prototype.sendMuteEvent = function(e, t, n) {
                const i = e && this.callsStatsInstances.get(e.id);
                a.a.sendMuteEvent(t, n, i)
            }, S.prototype.sendScreenSharingEvent = function(e, t) {
                for (const n of this.callsStatsInstances.values()) n.sendScreenSharingEvent(e, t)
            }, S.prototype.sendDominantSpeakerEvent = function(e) {
                for (const e of this.callsStatsInstances.values()) e.sendDominantSpeakerEvent();
                this.xmpp.sendDominantSpeakerEvent(e)
            }, S.sendActiveDeviceListEvent = function(e) {
                const t = S._getAllCallStatsInstances();
                if (t.size)
                    for (const n of t) a.a.sendActiveDeviceListEvent(e, n);
                else a.a.sendActiveDeviceListEvent(e, null)
            }, S.prototype.associateStreamWithVideoTag = function(e, t, n, i, r, s) {
                const o = this.callsStatsInstances.get(e.id);
                o && o.associateStreamWithVideoTag(t, n, i, r, s)
            }, S.sendGetUserMediaFailed = function(e) {
                const t = e instanceof p.a ? function(e) {
                        const t = new Error;
                        return t.stack = e.stack, t.name = (e.name || "Unknown error") + (e.gum && e.gum.error && e.gum.error.name ? ` - ${e.gum.error.name}` : ""), t.constraintName = e.gum && e.gum.constraints ? JSON.stringify(e.gum.constraints) : "", t.message = e.message, t
                    }(e) : e,
                    n = S._getAllCallStatsInstances();
                if (n.size)
                    for (const e of n) a.a.sendGetUserMediaFailed(t, e);
                else a.a.sendGetUserMediaFailed(t, null)
            }, S.prototype.sendCreateOfferFailed = function(e, t) {
                const n = this.callsStatsInstances.get(t.id);
                n && n.sendCreateOfferFailed(e)
            }, S.prototype.sendCreateAnswerFailed = function(e, t) {
                const n = this.callsStatsInstances.get(t.id);
                n && n.sendCreateAnswerFailed(e)
            }, S.prototype.sendSetLocalDescFailed = function(e, t) {
                const n = this.callsStatsInstances.get(t.id);
                n && n.sendSetLocalDescFailed(e)
            }, S.prototype.sendSetRemoteDescFailed = function(e, t) {
                const n = this.callsStatsInstances.get(t.id);
                n && n.sendSetRemoteDescFailed(e)
            }, S.prototype.sendAddIceCandidateFailed = function(e, t) {
                const n = this.callsStatsInstances.get(t.id);
                n && n.sendAddIceCandidateFailed(e)
            }, S.sendLog = function(e) {
                const t = new Set;
                for (const e of S.instances) {
                    if (e.callStatsApplicationLogsDisabled) return;
                    e.callsStatsInstances.size && t.add(e.callsStatsInstances.values().next().value)
                }
                if (t.size)
                    for (const n of t) a.a.sendApplicationLog(e, n);
                else a.a.sendApplicationLog(e, null)
            }, S.prototype.sendFeedback = function(e, t) {
                return S.analytics.sendEvent(s.n, {
                    rating: e,
                    comment: t
                }), a.a.sendFeedback(this._getCallStatsConfID(), e, t)
            }, S.LOCAL_JID = n(138).LOCAL_JID, S.reportGlobalError = function(e) {
                e instanceof p.a && e.gum ? S.sendGetUserMediaFailed(e) : S.sendLog(e)
            }, S.sendAnalyticsAndLog = function(e, t = {}) {
                if (!e) return void m.warn("No event or event name given.");
                let n;
                n = "object" == typeof e ? e : {
                    name: e,
                    properties: t
                }, m.log(JSON.stringify(n)), this.analytics.sendEvent(e, t)
            }, S.sendAnalytics = function(e, t = {}) {
                this.analytics.sendEvent(e, t)
            }
        }).call(this, "modules/statistics/statistics.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(4),
                r = n(35),
                s = n.n(r),
                o = n(3);
            const a = Object(i.getLogger)(e),
                c = {
                    filterSpecialChars: e => e ? e.replace(/[\\\/\{,\}\+]/g, "") : e,
                    iceparams(e, t) {
                        let n, i, r = null;
                        return (i = c.findLine(e, "a=ice-ufrag:", t)) && (n = c.findLine(e, "a=ice-pwd:", t)) && (r = {
                            ufrag: c.parseICEUfrag(i),
                            pwd: c.parseICEPwd(n)
                        }), r
                    },
                    parseICEUfrag: e => e.substring(12),
                    buildICEUfrag: e => `a=ice-ufrag:${e}`,
                    parseICEPwd: e => e.substring(10),
                    buildICEPwd: e => `a=ice-pwd:${e}`,
                    parseMID: e => e.substring(6),
                    parseMLine(e) {
                        const t = {},
                            n = e.substring(2).split(" ");
                        return t.media = n.shift(), t.port = n.shift(), t.proto = n.shift(), "" === n[n.length - 1] && n.pop(), t.fmt = n, t
                    },
                    buildMLine: e => `m=${e.media} ${e.port} ${e.proto} ${e.fmt.join(" ")}`,
                    parseRTPMap(e) {
                        const t = {};
                        let n = e.substring(9).split(" ");
                        return t.id = n.shift(), n = n[0].split("/"), t.name = n.shift(), t.clockrate = n.shift(), t.channels = n.length ? n.shift() : "1", t
                    },
                    parseSCTPMap(e) {
                        const t = e.substring(10).split(" ");
                        return [t[0], t[1], t.length > 2 ? t[2] : null]
                    },
                    buildRTPMap(e) {
                        let t = `a=rtpmap:${e.getAttribute("id")} ${e.getAttribute("name")}/${e.getAttribute("clockrate")}`;
                        return e.getAttribute("channels") && "1" !== e.getAttribute("channels") && (t += `/${e.getAttribute("channels")}`), t
                    },
                    parseCrypto(e) {
                        const t = {},
                            n = e.substring(9).split(" ");
                        return t.tag = n.shift(), t["crypto-suite"] = n.shift(), t["key-params"] = n.shift(), n.length && (t["session-params"] = n.join(" ")), t
                    },
                    parseFingerprint(e) {
                        const t = {},
                            n = e.substring(14).split(" ");
                        return t.hash = n.shift(), t.fingerprint = n.shift(), t
                    },
                    parseFmtp(e) {
                        const t = [];
                        let n = e.split(" ");
                        n.shift(), n = n.join(" ").split(";");
                        for (let e = 0; e < n.length; e++) {
                            let i = n[e].split("=")[0];
                            for (; i.length && " " === i[0];) i = i.substring(1);
                            const r = n[e].split("=")[1];
                            i && r ? t.push({
                                name: i,
                                value: r
                            }) : i && t.push({
                                name: "",
                                value: i
                            })
                        }
                        return t
                    },
                    parseICECandidate(e) {
                        const t = {},
                            n = e.split(" ");
                        t.foundation = n[0].substring(12), t.component = n[1], t.protocol = n[2].toLowerCase(), t.priority = n[3], t.ip = n[4], t.port = n[5], t.type = n[7], t.generation = 0;
                        for (let e = 8; e < n.length; e += 2) switch (n[e]) {
                            case "raddr":
                                t["rel-addr"] = n[e + 1];
                                break;
                            case "rport":
                                t["rel-port"] = n[e + 1];
                                break;
                            case "generation":
                                t.generation = n[e + 1];
                                break;
                            case "tcptype":
                                t.tcptype = n[e + 1];
                                break;
                            default:
                                a.log(`parseICECandidate not translating "${n[e]}" = "${n[e+1]}"`)
                        }
                        return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
                    },
                    buildICECandidate(e) {
                        let t = [`a=candidate:${e.foundation}`, e.component, e.protocol, e.priority, e.ip, e.port, "typ", e.type].join(" ");
                        switch (t += " ", e.type) {
                            case "srflx":
                            case "prflx":
                            case "relay":
                                e.hasOwnAttribute("rel-addr") && e.hasOwnAttribute("rel-port") && (t += "raddr", t += " ", t += e["rel-addr"], t += " ", t += "rport", t += " ", t += e["rel-port"], t += " ")
                        }
                        return e.hasOwnAttribute("tcptype") && (t += "tcptype", t += " ", t += e.tcptype, t += " "), t += "generation", t += " ", t += e.hasOwnAttribute("generation") ? e.generation : "0"
                    },
                    parseSSRC(e) {
                        const t = new Map,
                            n = e.split("\r\n");
                        for (let e = 0; e < n.length; e++)
                            if ("a=ssrc:" === n[e].substring(0, 7)) {
                                const i = n[e].split("a=ssrc:")[1].split(" ")[0];
                                t.get(i) || t.set(i, []), t.get(i).push(n[e])
                            } return t
                    },
                    parseRTCPFB(e) {
                        const t = e.substr(10).split(" "),
                            n = {};
                        return n.pt = t.shift(), n.type = t.shift(), n.params = t, n
                    },
                    parseExtmap(e) {
                        const t = e.substr(9).split(" "),
                            n = {};
                        return n.value = t.shift(), -1 === n.value.indexOf("/") ? n.direction = "both" : (n.direction = n.value.substr(n.value.indexOf("/") + 1), n.value = n.value.substr(0, n.value.indexOf("/"))), n.uri = t.shift(), n.params = t, n
                    },
                    findLine(e, t, n) {
                        let i = e.split("\r\n");
                        for (let e = 0; e < i.length; e++)
                            if (i[e].substring(0, t.length) === t) return i[e];
                        if (!n) return !1;
                        i = n.split("\r\n");
                        for (let e = 0; e < i.length; e++)
                            if (i[e].substring(0, t.length) === t) return i[e];
                        return !1
                    },
                    findLines(e, t, n) {
                        let i = e.split("\r\n");
                        const r = [];
                        for (let e = 0; e < i.length; e++) i[e].substring(0, t.length) === t && r.push(i[e]);
                        if (r.length || !n) return r;
                        i = n.split("\r\n");
                        for (let e = 0; e < i.length; e++) i[e].substring(0, t.length) === t && r.push(i[e]);
                        return r
                    },
                    candidateToJingle(e) {
                        if (0 === e.indexOf("candidate:")) e = `a=${e}`;
                        else if ("a=candidate:" !== e.substring(0, 12)) return a.log("parseCandidate called with a line that is not a candidate line"), a.log(e), null;
                        "\r\n" === e.substring(e.length - 2) && (e = e.substring(0, e.length - 2));
                        const t = {},
                            n = e.split(" ");
                        if ("typ" !== n[6]) return a.log("did not find typ in the right place"), a.log(e), null;
                        t.foundation = n[0].substring(12), t.component = n[1], t.protocol = n[2].toLowerCase(), t.priority = n[3], t.ip = n[4], t.port = n[5], t.type = n[7], t.generation = "0";
                        for (let e = 8; e < n.length; e += 2) switch (n[e]) {
                            case "raddr":
                                t["rel-addr"] = n[e + 1];
                                break;
                            case "rport":
                                t["rel-port"] = n[e + 1];
                                break;
                            case "generation":
                                t.generation = n[e + 1];
                                break;
                            case "tcptype":
                                t.tcptype = n[e + 1];
                                break;
                            default:
                                a.log(`not translating "${n[e]}" = "${n[e+1]}"`)
                        }
                        return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
                    },
                    candidateFromJingle(e) {
                        let t = "a=candidate:";
                        t += e.getAttribute("foundation"), t += " ", t += e.getAttribute("component"), t += " ";
                        let n = e.getAttribute("protocol");
                        switch (o.a.isFirefox() && "ssltcp" === n.toLowerCase() && (n = "tcp"), t += n, t += " ", t += e.getAttribute("priority"), t += " ", t += e.getAttribute("ip"), t += " ", t += e.getAttribute("port"), t += " ", t += "typ", t += ` ${e.getAttribute("type")}`, t += " ", e.getAttribute("type")) {
                            case "srflx":
                            case "prflx":
                            case "relay":
                                e.getAttribute("rel-addr") && e.getAttribute("rel-port") && (t += "raddr", t += " ", t += e.getAttribute("rel-addr"), t += " ", t += "rport", t += " ", t += e.getAttribute("rel-port"), t += " ")
                        }
                        return "tcp" === n.toLowerCase() && (t += "tcptype", t += " ", t += e.getAttribute("tcptype"), t += " "), t += "generation", t += " ", `${t+=e.getAttribute("generation")||"0"}\r\n`
                    },
                    parsePrimaryVideoSsrc(e) {
                        const t = e.ssrcs.map(e => e.id).filter((e, t, n) => n.indexOf(e) === t).length,
                            n = e.ssrcGroups && e.ssrcGroups.length || 0;
                        if (t > 1 && 0 === n) return;
                        let i = null;
                        if (1 === t) i = e.ssrcs[0].id;
                        else if (2 === t) {
                            const t = e.ssrcGroups.find(e => "FID" === e.semantics);
                            t && (i = t.ssrcs.split(" ")[0])
                        } else if (t >= 3) {
                            const t = e.ssrcGroups.find(e => "SIM" === e.semantics);
                            t && (i = t.ssrcs.split(" ")[0])
                        }
                        return i
                    },
                    generateSsrc: () => s.a.randomInt(1, 4294967295),
                    getSsrcAttribute(e, t, n) {
                        for (let i = 0; i < e.ssrcs.length; ++i) {
                            const r = e.ssrcs[i];
                            if (r.id === t && r.attribute === n) return r.value
                        }
                    },
                    parseGroupSsrcs: e => e.ssrcs.split(" ").map(e => parseInt(e, 10)),
                    getMedia: (e, t) => e.media.find(e => e.type === t),
                    getUfrag(e) {
                        const t = e.split("\n").filter(e => e.startsWith("a=ice-ufrag:"));
                        if (t.length > 0) return t[0].substr("a=ice-ufrag:".length)
                    },
                    preferVideoCodec(e, t) {
                        let n = null;
                        if (e && t) {
                            for (let i = 0; i < e.rtp.length; ++i) {
                                const r = e.rtp[i];
                                if (r.codec && r.codec.toLowerCase() === t.toLowerCase()) {
                                    n = r.payload;
                                    break
                                }
                            }
                            if (n) {
                                const t = e.payloads.toString().split(" ").map(e => parseInt(e, 10)),
                                    i = t.indexOf(n);
                                t.splice(i, 1), t.unshift(n), e.payloads = t.join(" ")
                            }
                        }
                    },
                    stripVideoCodec(e, t) {
                        if (!e || !t) return;
                        const n = [];
                        for (const i of e.rtp) i.codec && i.codec.toLowerCase() === t.toLowerCase() && n.push(i.payload);
                        if (n.length > 0) {
                            const t = n.map(e => `apt=${e}`),
                                i = e.fmtp.filter(e => -1 !== t.indexOf(e.config));
                            n.push(...i.map(e => e.payload));
                            const r = e.payloads.toString().split(" ").map(Number).filter(e => -1 === n.indexOf(e));
                            0 === r.length ? (e.port = 0, e.direction = "inactive", e.payloads = "*") : e.payloads = r.join(" "), e.rtp = e.rtp.filter(e => -1 !== r.indexOf(e.payload)), e.fmtp = e.fmtp.filter(e => -1 !== r.indexOf(e.payload)), e.rtcpFb && (e.rtcpFb = e.rtcpFb.filter(e => -1 !== r.indexOf(e.payload)))
                        }
                    }
                };
            t.a = c
        }).call(this, "modules/xmpp/SDPUtil.js")
    }, function(e, t, n) {
        "use strict";

        function i(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = null != arguments[t] ? arguments[t] : {},
                    i = Object.keys(n);
                "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                    return Object.getOwnPropertyDescriptor(n, e).enumerable
                })))), i.forEach((function(t) {
                    r(e, t, n[t])
                }))
            }
            return e
        }

        function r(e, t, n) {
            return t in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n, e
        }
        n.d(t, "t", (function() {
            return s
        })), n.d(t, "u", (function() {
            return o
        })), n.d(t, "v", (function() {
            return a
        })), n.d(t, "w", (function() {
            return c
        })), n.d(t, "a", (function() {
            return d
        })), n.d(t, "b", (function() {
            return u
        })), n.d(t, "c", (function() {
            return l
        })), n.d(t, "d", (function() {
            return h
        })), n.d(t, "e", (function() {
            return p
        })), n.d(t, "f", (function() {
            return f
        })), n.d(t, "g", (function() {
            return m
        })), n.d(t, "h", (function() {
            return g
        })), n.d(t, "i", (function() {
            return _
        })), n.d(t, "j", (function() {
            return v
        })), n.d(t, "k", (function() {
            return S
        })), n.d(t, "l", (function() {
            return y
        })), n.d(t, "m", (function() {
            return E
        })), n.d(t, "n", (function() {
            return T
        })), n.d(t, "o", (function() {
            return b
        })), n.d(t, "p", (function() {
            return C
        })), n.d(t, "q", (function() {
            return R
        })), n.d(t, "r", (function() {
            return A
        })), n.d(t, "s", (function() {
            return w
        })), n.d(t, "z", (function() {
            return I
        })), n.d(t, "B", (function() {
            return P
        })), n.d(t, "A", (function() {
            return D
        })), n.d(t, "C", (function() {
            return O
        })), n.d(t, "D", (function() {
            return N
        })), n.d(t, "E", (function() {
            return M
        })), n.d(t, "F", (function() {
            return L
        })), n.d(t, "J", (function() {
            return k
        })), n.d(t, "G", (function() {
            return x
        })), n.d(t, "H", (function() {
            return F
        })), n.d(t, "I", (function() {
            return j
        })), n.d(t, "K", (function() {
            return U
        })), n.d(t, "L", (function() {
            return H
        })), n.d(t, "M", (function() {
            return J
        })), n.d(t, "N", (function() {
            return B
        })), n.d(t, "x", (function() {
            return G
        })), n.d(t, "y", (function() {
            return $
        })), n.d(t, "O", (function() {
            return V
        }));
        const s = "operational",
            o = "page",
            a = "track",
            c = "ui",
            d = "restart",
            u = "session-accept.timeout",
            l = "session-initiate.received",
            h = "session-initiate.timeout",
            p = "terminate",
            f = "transport-replace.received",
            m = "transport-replace.success",
            g = "decline",
            _ = "established",
            v = "failed",
            S = "switch.to.jvb",
            y = "available.device",
            E = "connection.disconnected",
            T = "feedback",
            b = "ice.duration",
            C = "ice.establishment.duration.diff",
            R = "ice.state.changed",
            A = "track.no-bytes-sent",
            w = "track.unmuted",
            I = function() {
                return {
                    action: "bridge.down",
                    actionSubject: "bridge.down",
                    type: s
                }
            },
            P = function(e, t, n) {
                return {
                    type: s,
                    action: "connection.failed",
                    attributes: i({
                        error_type: e,
                        error_message: t
                    }, n)
                }
            };

        function D(e, t) {
            return {
                action: e,
                attributes: t,
                source: "conference",
                type: s
            }
        }
        const O = function(e, t) {
                const n = "connection.stage.reached";
                return {
                    action: n,
                    actionSubject: e,
                    attributes: t,
                    source: n,
                    type: s
                }
            },
            N = function(e, t, n) {
                return {
                    attributes: {
                        participant_id: e,
                        region: t,
                        rtt: n
                    },
                    name: "e2e_rtt",
                    type: s
                }
            },
            M = function() {
                return {
                    action: "focus.left",
                    actionSubject: "focus.left",
                    type: s
                }
            },
            L = function(e, t = {}) {
                return {
                    type: s,
                    source: "get.user.media",
                    action: e,
                    attributes: t
                }
            },
            k = function(e = {}) {
                return {
                    type: s,
                    source: "peer.conn.status",
                    action: "duration",
                    attributes: e
                }
            },
            x = function(e, t = {}) {
                return {
                    type: s,
                    action: e,
                    source: "jingle",
                    attributes: t
                }
            },
            F = function(e, t) {
                return {
                    attributes: {
                        media_type: e,
                        value: t
                    },
                    action: "track.no.data.from.source",
                    type: s
                }
            },
            j = function(e, t = {}) {
                return {
                    type: s,
                    action: e,
                    source: "p2p",
                    attributes: t
                }
            },
            U = function() {
                return {
                    type: s,
                    action: "remotely.muted"
                }
            },
            H = function(e) {
                return {
                    type: s,
                    action: "rtp.stats",
                    attributes: e
                }
            },
            J = function(e) {
                return {
                    type: s,
                    action: "rtt.by.region",
                    attributes: e
                }
            },
            B = function(e) {
                return {
                    type: s,
                    action: "transport.stats",
                    attributes: e
                }
            };

        function G(e, t, n) {
            return {
                type: s,
                action: "audio.output.problem",
                attributes: {
                    userID: e,
                    localAudioLevels: t,
                    remoteAudioLevels: n
                }
            }
        }
        const $ = function(e, t) {
                return {
                    type: s,
                    action: "bridge-channel.error",
                    attributes: {
                        code: e,
                        reason: t
                    }
                }
            },
            V = function(e) {
                return O("ttfm", e)
            }
    }, function(e, t) {
        e.exports = {
            CREATE_ANSWER_FAILED: "rtc.create_answer_failed",
            CREATE_OFFER_FAILED: "rtc.create_offer_failed",
            DATA_CHANNEL_OPEN: "rtc.data_channel_open",
            ENDPOINT_CONN_STATUS_CHANGED: "rtc.endpoint_conn_status_changed",
            DOMINANT_SPEAKER_CHANGED: "rtc.dominant_speaker_changed",
            LASTN_ENDPOINT_CHANGED: "rtc.lastn_endpoint_changed",
            GRANTED_PERMISSIONS: "rtc.granted_permissions",
            IS_SELECTED_CHANGED: "rtc.is_selected_change",
            LASTN_VALUE_CHANGED: "rtc.lastn_value_changed",
            LOCAL_TRACK_SSRC_UPDATED: "rtc.local_track_ssrc_updated",
            TRACK_ATTACHED: "rtc.track_attached",
            REMOTE_TRACK_ADDED: "rtc.remote_track_added",
            REMOTE_TRACK_MUTE: "rtc.remote_track_mute",
            REMOTE_TRACK_REMOVED: "rtc.remote_track_removed",
            REMOTE_TRACK_UNMUTE: "rtc.remote_track_unmute",
            SET_LOCAL_DESCRIPTION_FAILED: "rtc.set_local_description_failed",
            SET_REMOTE_DESCRIPTION_FAILED: "rtc.set_remote_description_failed",
            AUDIO_OUTPUT_DEVICE_CHANGED: "rtc.audio_output_device_changed",
            DEVICE_LIST_CHANGED: "rtc.device_list_changed",
            DEVICE_LIST_WILL_CHANGE: "rtc.device_list_will_change",
            DEVICE_LIST_AVAILABLE: "rtc.device_list_available",
            ENDPOINT_MESSAGE_RECEIVED: "rtc.endpoint_message_received",
            LOCAL_UFRAG_CHANGED: "rtc.local_ufrag_changed",
            REMOTE_UFRAG_CHANGED: "rtc.remote_ufrag_changed"
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        })), n.d(t, "b", (function() {
            return r
        })), n.d(t, "c", (function() {
            return s
        }));
        const i = "audio",
            r = "presenter",
            s = "video"
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(7),
                r = n(41),
                s = n.n(r),
                o = n(19),
                a = n.n(o),
                c = n(4),
                d = n(11),
                u = n.n(d),
                l = n(16),
                h = n(24),
                p = n(9),
                f = n(31),
                m = n.n(f),
                g = n(3),
                _ = n(8),
                v = n.n(_),
                S = n(42),
                y = n(6),
                E = n(5),
                T = n(14),
                b = n.n(T);

            function C(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {},
                        i = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), i.forEach((function(t) {
                        R(e, t, n[t])
                    }))
                }
                return e
            }

            function R(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const A = Object(c.getLogger)(e);
            g.a.usesAdapter() && n(151);
            const w = new a.a,
                I = 3e3,
                P = 720,
                D = ["audio", "video"],
                O = {
                    video: {
                        height: {
                            ideal: 720,
                            max: 720,
                            min: 240
                        }
                    }
                },
                N = 5;
            let M = "default",
                L = !1,
                k = !1,
                x = !1,
                F = !1,
                j = !1,
                U = !1;
            const H = document.createElement("audio"),
                J = void 0 !== H.setSinkId;
            let B, G;

            function $(e, t = {}) {
                const n = {
                        audio: !1,
                        video: !1
                    },
                    i = g.a.isFirefox() || g.a.isSafari() || g.a.isReactNative();
                if (e.indexOf("video") >= 0) {
                    if (n.video = {
                            mandatory: {},
                            optional: []
                        }, t.cameraDeviceId) i && (n.video.deviceId = t.cameraDeviceId), n.video.mandatory.sourceId = t.cameraDeviceId;
                    else {
                        const e = t.facingMode || s.a.USER;
                        i && (n.video.facingMode = e), n.video.optional.push({
                            facingMode: e
                        })
                    }(t.minFps || t.maxFps || t.fps) && ((t.minFps || t.fps) && (t.minFps = t.minFps || t.fps, n.video.mandatory.minFrameRate = t.minFps), t.maxFps && (n.video.mandatory.maxFrameRate = t.maxFps)),
                    function(e, t, n) {
                        m.a[n] && (t && (e.video.width = {
                            ideal: m.a[n].width
                        }, e.video.height = {
                            ideal: m.a[n].height
                        }), e.video.mandatory.minWidth = m.a[n].width, e.video.mandatory.minHeight = m.a[n].height), e.video.mandatory.minWidth && (e.video.mandatory.maxWidth = e.video.mandatory.minWidth), e.video.mandatory.minHeight && (e.video.mandatory.maxHeight = e.video.mandatory.minHeight)
                    }(n, i, t.resolution)
                }
                if (e.indexOf("audio") >= 0 && (g.a.isReactNative() ? n.audio = !0 : g.a.isFirefox() ? t.micDeviceId ? n.audio = {
                        mandatory: {},
                        deviceId: t.micDeviceId,
                        optional: [{
                            sourceId: t.micDeviceId
                        }]
                    } : n.audio = !0 : (n.audio = {
                        mandatory: {},
                        optional: []
                    }, t.micDeviceId && (i && (n.audio.deviceId = t.micDeviceId), n.audio.optional.push({
                        sourceId: t.micDeviceId
                    })), n.audio.optional.push({
                        echoCancellation: !x && !k
                    }, {
                        googEchoCancellation: !x && !k
                    }, {
                        googAutoGainControl: !j && !k
                    }, {
                        googNoiseSuppression: !F && !k
                    }, {
                        googHighpassFilter: !U && !k
                    }, {
                        googNoiseSuppression2: !F && !k
                    }, {
                        googEchoCancellation2: !x && !k
                    }, {
                        googAutoGainControl2: !j && !k
                    }))), e.indexOf("screen") >= 0)
                    if (g.a.isChrome()) n.video = {
                        mandatory: V(C({}, t, {
                            source: "screen"
                        })),
                        optional: []
                    };
                    else if (g.a.isFirefox()) n.video = {
                    mozMediaSource: "window",
                    mediaSource: "window",
                    frameRate: t.frameRate || {
                        min: N,
                        max: N
                    }
                };
                else {
                    const e = "'screen' WebRTC media source is supported only in Chrome and Firefox";
                    u.a.callErrorHandler(new Error(e)), A.error(e)
                }
                return e.indexOf("desktop") >= 0 && (n.video = {
                    mandatory: V(C({}, t, {
                        source: "desktop"
                    })),
                    optional: []
                }, g.a.isElectron() && t.screenShareAudio && t.desktopStream.indexOf("screen") >= 0 && (n.audio = {
                    mandatory: {
                        chromeMediaSource: n.video.mandatory.chromeMediaSource
                    }
                }, delete n.video.mandatory.chromeMediaSourceId)), t.bandwidth && (n.video || (n.video = {
                    mandatory: {},
                    optional: []
                }), n.video.optional.push({
                    bandwidth: t.bandwidth
                })), g.a.isFirefox() && t.firefox_fake_device && (n.fake = !0), n
            }

            function V(e = {}) {
                const {
                    desktopStream: t,
                    frameRate: n = {
                        min: N,
                        max: N
                    }
                } = e, {
                    max: i,
                    min: r
                } = n, s = {
                    chromeMediaSource: e.source,
                    maxWidth: window.screen.width,
                    maxHeight: window.screen.height
                };
                return "number" == typeof r && (s.minFrameRate = r), "number" == typeof i && (s.maxFrameRate = i), void 0 !== t && (s.chromeMediaSourceId = t), s
            }

            function q(e = {}) {
                const t = {
                        frameRate: N
                    },
                    {
                        desktopSharingFrameRate: n
                    } = e;
                return n && n.max && (t.frameRate = n.max), t
            }

            function K(e, t) {
                const n = Boolean(t) && t.getAudioTracks().length > 0,
                    i = Boolean(t) && t.getVideoTracks().length > 0,
                    r = {}; - 1 !== e.indexOf("video") && (r.video = i), -1 !== e.indexOf("audio") && (r.audio = n), w.emit(v.a.GRANTED_PERMISSIONS, r)
            }

            function W(e) {
                const t = e.filter(e => "audioinput" === e.kind).length,
                    n = e.filter(e => "audiooutput" === e.kind).length,
                    r = e.filter(e => "videoinput" === e.kind).length,
                    s = e.filter(e => "videooutput" === e.kind).length;
                e.forEach(e => {
                    const o = {
                        audio_input_device_count: t,
                        audio_output_device_count: n,
                        video_input_device_count: r,
                        video_output_device_count: s,
                        device_id: e.deviceId,
                        device_group_id: e.groupId,
                        device_kind: e.kind,
                        device_label: e.label
                    };
                    E.a.sendAnalytics(i.l, o)
                })
            }
            class z extends h.a {
                constructor() {
                    super(w)
                }
                init(e = {}) {
                    if ("boolean" == typeof e.disableAEC && (x = e.disableAEC, A.info(`Disable AEC: ${x}`)), "boolean" == typeof e.disableNS && (F = e.disableNS, A.info(`Disable NS: ${F}`)), "boolean" == typeof e.disableAP && (k = e.disableAP, A.info(`Disable AP: ${k}`)), "boolean" == typeof e.disableAGC && (j = e.disableAGC, A.info(`Disable AGC: ${j}`)), "boolean" == typeof e.disableHPF && (U = e.disableHPF, A.info(`Disable HPF: ${U}`)), B = void 0, window.clearInterval(G), G = void 0, this.enumerateDevices = function() {
                            if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) return e => {
                                navigator.mediaDevices.enumerateDevices().then(e, () => e([]))
                            }
                        }(), g.a.usesNewGumFlow()) this.RTCPeerConnectionType = RTCPeerConnection, this.attachMediaStream = Q((e, t) => {
                        e && (e.srcObject = t)
                    }), this.getStreamID = ({
                        id: e
                    }) => e, this.getTrackID = ({
                        id: e
                    }) => e;
                    else {
                        if (!g.a.isChromiumBased() && !g.a.isReactNative()) {
                            const e = "Endpoint does not appear to be WebRTC-capable";
                            throw A.error(e), new Error(e)
                        }
                        this.RTCPeerConnectionType = RTCPeerConnection, this.attachMediaStream = Q((e, t) => (function(e, t) {
                            let n, i = "srcObject";
                            i in e || (i = "mozSrcObject") in e || (i = null), i ? e[i] = t : (t && ((n = t.jitsiObjectURL) || (t.jitsiObjectURL = n = URL.createObjectURL(t))), e.src = n || "")
                        }(e, t), e)), this.getStreamID = function({
                            id: e
                        }) {
                            return "number" == typeof e ? e : y.a.filterSpecialChars(e)
                        }, this.getTrackID = ({
                            id: e
                        }) => e, MediaStream.prototype.getVideoTracks || (MediaStream.prototype.getVideoTracks = function() {
                            return this.videoTracks
                        }), MediaStream.prototype.getAudioTracks || (MediaStream.prototype.getAudioTracks = function() {
                            return this.audioTracks
                        })
                    }
                    this._initPCConstraints(e), S.a.init(e, this.getUserMediaWithConstraints.bind(this)), this.isDeviceListAvailable() && this.enumerateDevices(e => {
                        B = e.splice(0), A.debug("Available devices: ", B), W(B), w.emit(v.a.DEVICE_LIST_AVAILABLE, B);
                        const t = () => this.enumerateDevices(e => {
                            (function(e) {
                                return e.length !== B.length || e.map(t).sort().join("") !== B.map(t).sort().join("");

                                function t(e) {
                                    return JSON.stringify({
                                        kind: e.kind,
                                        deviceId: e.deviceId,
                                        groupId: e.groupId,
                                        label: e.label,
                                        facing: e.facing
                                    })
                                }
                            })(e) && function(e) {
                                B = e.slice(0), A.info("list of media devices has changed:", B), W(B), w.emit(v.a.DEVICE_LIST_WILL_CHANGE, e), w.emit(v.a.DEVICE_LIST_CHANGED, e)
                            }(e)
                        });
                        g.a.supportsDeviceChangeEvent() ? navigator.mediaDevices.addEventListener("devicechange", t) : G = window.setInterval(t, I)
                    })
                }
                _initPCConstraints(e) {
                    g.a.isFirefox() ? this.pcConstraints = {} : (g.a.isChromiumBased() || g.a.isReactNative()) && (this.pcConstraints = {
                        optional: [{
                            googHighStartBitrate: 0
                        }, {
                            googPayloadPadding: !0
                        }, {
                            googScreencastMinBitrate: 100
                        }, {
                            googCpuOveruseDetection: !0
                        }, {
                            googCpuOveruseEncodeUsage: !0
                        }, {
                            googCpuUnderuseThreshold: 55
                        }, {
                            googCpuOveruseThreshold: 85
                        }]
                    }, e.useIPv6 && this.pcConstraints.optional.push({
                        googIPv6: !0
                    }), this.p2pPcConstraints = JSON.parse(JSON.stringify(this.pcConstraints))), this.p2pPcConstraints = this.p2pPcConstraints || this.pcConstraints
                }
                getUserMediaWithConstraints(e, t = {}) {
                    const n = $(e, t);
                    return A.info("Get media constraints", n), new Promise((t, i) => {
                        navigator.mediaDevices.getUserMedia(n).then(n => {
                            A.log("onUserMediaSuccess"), K(e, n), t(n)
                        }).catch(t => {
                            A.warn("Failed to get access to local media. " + ` ${t} ${n} `), K(e, void 0), i(new l.a(t, n, e))
                        })
                    })
                }
                _newGetUserMediaWithConstraints(e, t = {}) {
                    return new Promise((n, i) => {
                        navigator.mediaDevices.getUserMedia(t).then(t => {
                            A.log("onUserMediaSuccess"), K(e, t), n(t)
                        }).catch(n => {
                            A.warn("Failed to get access to local media. " + ` ${n} ${t} `), K(e, void 0), i(new l.a(n, t, e))
                        })
                    })
                }
                _newGetDesktopMedia(e) {
                    return S.a.isSupported() && g.a.supportsVideo() ? new Promise((t, n) => {
                        S.a.obtainStream(this._parseDesktopSharingOptions(e), e => {
                            t(e)
                        }, e => {
                            n(e)
                        })
                    }) : Promise.reject(new Error("Desktop sharing is not supported!"))
                }
                obtainAudioAndVideoPermissions(e = {}) {
                    return e.devices = e.devices || [...D], e.resolution = e.resolution || P, e.devices.includes("desktop") && !S.a.isSupported() ? Promise.reject(new Error("Desktop sharing is not supported!")) : this._getAudioAndVideoStreams(e).then(t => (function(e, t) {
                        let n, i, r;
                        const s = [];
                        if (e) {
                            const t = e.audioVideo;
                            if (t) {
                                const e = t.getAudioTracks();
                                if (e.length) {
                                    n = new MediaStream;
                                    for (let t = 0; t < e.length; t++) n.addTrack(e[t])
                                }
                                const i = t.getVideoTracks();
                                if (i.length) {
                                    r = new MediaStream;
                                    for (let e = 0; e < i.length; e++) r.addTrack(i[e])
                                }
                            } else n = e.audio, r = e.video;
                            i = e.desktop
                        }
                        if (i) {
                            const {
                                stream: e,
                                sourceId: t,
                                sourceType: n
                            } = i;
                            s.push({
                                stream: e,
                                sourceId: t,
                                sourceType: n,
                                track: e.getVideoTracks()[0],
                                mediaType: p.c,
                                videoType: b.a.DESKTOP
                            })
                        }
                        return n && s.push({
                            stream: n,
                            track: n.getAudioTracks()[0],
                            mediaType: p.a,
                            videoType: null
                        }), r && s.push({
                            stream: r,
                            track: r.getVideoTracks()[0],
                            mediaType: p.c,
                            videoType: b.a.CAMERA,
                            resolution: t
                        }), s
                    })(t, e.resolution))
                }
                _getAudioAndVideoStreams(e) {
                    const t = e.devices.includes("desktop");
                    return e.devices = e.devices.filter(e => "desktop" !== e), (e.devices.length ? this.getUserMediaWithConstraints(e.devices, e) : Promise.resolve(null)).then(t => {
                        const n = this._getMissingTracks(e.devices, t);
                        return n.length ? (this.stopMediaStream(t), this.getUserMediaWithConstraints(n, e).then(() => Promise.reject(new l.a({
                            name: "UnknownError"
                        }, $(e.devices, e), n)))) : t
                    }).then(n => {
                        if (!t) return {
                            audioVideo: n
                        };
                        if (e.desktopSharingSourceDevice) throw this.stopMediaStream(n), new Error("Using a camera as screenshare source isnot supported on this browser.");
                        return new Promise((t, i) => {
                            S.a.obtainStream(this._parseDesktopSharingOptions(e), e => t({
                                audioVideo: n,
                                desktop: e
                            }), e => {
                                n && this.stopMediaStream(n), i(e)
                            })
                        })
                    })
                }
                _getMissingTracks(e = [], t) {
                    const n = [],
                        i = e.includes("audio"),
                        r = t && t.getAudioTracks().length > 0;
                    i && !r && n.push("audio");
                    const s = e.includes("video"),
                        o = t && t.getVideoTracks().length > 0;
                    return s && !o && n.push("video"), n
                }
                _parseDesktopSharingOptions(e) {
                    return C({}, e.desktopSharingExtensionExternalInstallation, {
                        desktopSharingSources: e.desktopSharingSources,
                        gumOptions: {
                            frameRate: e.desktopSharingFrameRate
                        },
                        trackOptions: q(e)
                    })
                }
                newObtainAudioAndVideoPermissions(e) {
                    A.info("Using the new gUM flow");
                    const t = [],
                        n = function() {
                            if (!(-1 !== (e.devices || []).indexOf("desktop"))) return Promise.resolve();
                            const {
                                desktopSharingExtensionExternalInstallation: t,
                                desktopSharingSourceDevice: n,
                                desktopSharingSources: i,
                                desktopSharingFrameRate: r
                            } = e;
                            if (n) {
                                const t = B && B.find(e => "videoinput" === e.kind && (e.deviceId === n || e.label === n));
                                if (!t) return Promise.reject(new l.a({
                                    name: "ConstraintNotSatisfiedError"
                                }, {}, [n]));
                                const i = ["video"],
                                    {
                                        gumOptions: r,
                                        trackOptions: s
                                    } = this._parseDesktopSharingOptions(e),
                                    o = {
                                        video: C({}, r, {
                                            deviceId: t.deviceId
                                        })
                                    };
                                return this._newGetUserMediaWithConstraints(i, o).then(e => {
                                    const t = e && e.getTracks()[0];
                                    return (t && t.applyConstraints ? t.applyConstraints(s) : Promise.resolve()).then(() => ({
                                        sourceType: "device",
                                        stream: e
                                    }))
                                })
                            }
                            return this._newGetDesktopMedia({
                                desktopSharingExtensionExternalInstallation: t,
                                desktopSharingSources: i,
                                desktopSharingFrameRate: r
                            })
                        }.bind(this),
                        i = function() {
                            const t = (e.devices || ["audio", "video"]).filter(e => "audio" === e || "video" === e && g.a.supportsVideo());
                            if (!t.length) return Promise.resolve();
                            const n = function(e = [], t = {}) {
                                const n = JSON.parse(JSON.stringify(t.constraints || O));
                                if (e.indexOf("video") >= 0)
                                    if (n.video || (n.video = {}), t.cameraDeviceId) n.video.deviceId = t.cameraDeviceId;
                                    else {
                                        const e = t.facingMode || s.a.USER;
                                        n.video.facingMode = e
                                    }
                                else n.video = !1;
                                return e.indexOf("audio") >= 0 ? (n.audio && "boolean" != typeof n.audio || (n.audio = {}), n.audio.optional || (n.audio.optional = []), n.audio.optional.push({
                                    sourceId: t.micDeviceId
                                }, {
                                    echoCancellation: !x && !k
                                }, {
                                    googEchoCancellation: !x && !k
                                }, {
                                    googAutoGainControl: !j && !k
                                }, {
                                    googNoiseSuppression: !F && !k
                                }, {
                                    googHighpassFilter: !U && !k
                                }, {
                                    googNoiseSuppression2: !F && !k
                                }, {
                                    googEchoCancellation2: !x && !k
                                }, {
                                    googAutoGainControl2: !j && !k
                                })) : n.audio = !1, e.indexOf("desktop") >= 0 && (n.video && "boolean" != typeof n.video || (n.video = {}), n.video = {
                                    mandatory: V(C({}, t, {
                                        source: "desktop"
                                    }))
                                }), n
                            }(t, e);
                            return A.info("Got media constraints: ", n), this._newGetUserMediaWithConstraints(t, n)
                        }.bind(this);
                    return n().then((function(e) {
                        if (!e) return;
                        const {
                            stream: n,
                            sourceId: i,
                            sourceType: r
                        } = e, s = n.getAudioTracks();
                        if (s.length) {
                            const e = new MediaStream(s);
                            t.push({
                                stream: e,
                                sourceId: i,
                                sourceType: r,
                                track: e.getAudioTracks()[0]
                            })
                        }
                        const o = n.getVideoTracks();
                        if (o.length) {
                            const e = new MediaStream(o);
                            t.push({
                                stream: e,
                                sourceId: i,
                                sourceType: r,
                                track: e.getVideoTracks()[0],
                                videoType: b.a.DESKTOP
                            })
                        }
                    })).then(i).then((function(n) {
                        if (!n) return;
                        const i = n.getAudioTracks();
                        if (i.length) {
                            const n = new MediaStream(i);
                            t.push({
                                stream: n,
                                track: n.getAudioTracks()[0],
                                effects: e.effects
                            })
                        }
                        const r = n.getVideoTracks();
                        if (r.length) {
                            const n = new MediaStream(r);
                            t.push({
                                stream: n,
                                track: n.getVideoTracks()[0],
                                videoType: b.a.CAMERA,
                                effects: e.effects
                            })
                        }
                    })).then(() => t).catch(e => (t.forEach(({
                        stream: e
                    }) => {
                        this.stopMediaStream(e)
                    }), Promise.reject(e)))
                }
                isDeviceListAvailable() {
                    return Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices)
                }
                isDeviceChangeAvailable(e) {
                    return "output" !== e && "audiooutput" !== e || J
                }
                stopMediaStream(e) {
                    if (!e) return;
                    e.getTracks().forEach(e => {
                        e.stop && e.stop()
                    }), e.stop && e.stop(), e.release && e.release();
                    const t = e.jitsiObjectURL;
                    t && (delete e.jitsiObjectURL, URL.revokeObjectURL(t))
                }
                isDesktopSharingEnabled() {
                    return S.a.isSupported()
                }
                setAudioOutputDevice(e) {
                    return this.isDeviceChangeAvailable("output") ? H.setSinkId(e).then(() => {
                        M = e, L = !0, A.log(`Audio output device set to ${e}`), w.emit(v.a.AUDIO_OUTPUT_DEVICE_CHANGED, e)
                    }) : Promise.reject(new Error("Audio output device change is not supported"))
                }
                getAudioOutputDevice() {
                    return M
                }
                getCurrentlyAvailableMediaDevices() {
                    return B
                }
                getEventDataForActiveDevice(e) {
                    const t = [],
                        n = {
                            deviceId: e.deviceId,
                            kind: e.kind,
                            label: e.label,
                            groupId: e.groupId
                        };
                    return t.push(n), {
                        deviceList: t
                    }
                }
                setSuspendVideo(e, t) {
                    e.optional || (e.optional = []), e.optional = e.optional.filter(e => !e.hasOwnProperty("googSuspendBelowMinBitrate")), t && e.optional.push({
                        googSuspendBelowMinBitrate: "true"
                    })
                }
            }
            const X = new z;

            function Q(e) {
                return function(t, n) {
                    const i = e.apply(X, arguments);
                    return n && X.isDeviceChangeAvailable("output") && n.getAudioTracks && n.getAudioTracks().length && L && t.setSinkId(X.getAudioOutputDevice()).catch((function(e) {
                        const n = new l.a(e, null, ["audiooutput"]);
                        u.a.callUnhandledRejectionHandler({
                            promise: this,
                            reason: n
                        }), A.warn("Failed to set audio output device for the element. Default audio output device will be used instead", t, n)
                    })), i
                }
            }
            t.a = X
        }).call(this, "modules/RTC/RTCUtils.js")
    }, function(e, t) {
        const n = [],
            i = window.onerror;
        const r = window.onunhandledrejection;
        window.onerror = function(...e) {
            n.forEach(t => t(...e)), i && i(...e)
        }, window.onunhandledrejection = function(e) {
            n.forEach(t => t(null, null, null, null, e.reason)), r && r(e)
        };
        const s = {
            addHandler(e) {
                n.push(e)
            },
            callErrorHandler(e) {
                const t = window.onerror;
                t && t(null, null, null, null, e)
            },
            callUnhandledRejectionHandler(e) {
                const t = window.onunhandledrejection;
                t && t(e)
            }
        };
        e.exports = s
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return A
            }));
            var i = n(4),
                r = n(74),
                s = n(11),
                o = n.n(s),
                a = n(2),
                c = n(65),
                d = n(24),
                u = n(29),
                l = n(9),
                h = n(3),
                p = n(8),
                f = n.n(p),
                m = n(10),
                g = n(5),
                _ = n(80),
                v = n(14),
                S = n.n(v);

            function y(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const E = Object(i.getLogger)(e);
            let T = 0,
                b = 0;

            function C(e, t) {
                const n = [];
                let i = null;
                return e.forEach(e => {
                    e.mediaType === l.a ? i = t.micDeviceId : e.videoType === S.a.CAMERA && (i = t.cameraDeviceId), b = Object(u.c)(b);
                    const r = new c.a(function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? arguments[t] : {},
                                i = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), i.forEach((function(t) {
                                y(e, t, n[t])
                            }))
                        }
                        return e
                    }({}, e, {
                        deviceId: i,
                        facingMode: t.facingMode,
                        rtcId: b,
                        effects: t.effects
                    }));
                    n.push(r)
                }), n
            }

            function R(e = []) {
                return e.map(e => {
                    const {
                        sourceId: t,
                        sourceType: n,
                        stream: i,
                        track: r,
                        videoType: s,
                        effects: o
                    } = e, {
                        deviceId: a,
                        facingMode: d
                    } = r.getSettings();
                    return b = Object(u.c)(b), new c.a({
                        deviceId: a,
                        facingMode: d,
                        mediaType: r.kind,
                        rtcId: b,
                        sourceId: t,
                        sourceType: n,
                        stream: i,
                        track: r,
                        videoType: s || null,
                        effects: o
                    })
                })
            }
            class A extends d.a {
                constructor(e, t = {}) {
                    super(), this.conference = e, this.peerConnections = new Map, this.localTracks = [], this.options = t, this._channel = null, this._channelOpen = !1, this._lastN = -1, this._lastNEndpoints = null, this._maxFrameHeight = void 0, this._pinnedEndpoint = null, this._selectedEndpoints = [], this._lastNChangeListener = this._onLastNChanged.bind(this), this._onDeviceListChanged = this._onDeviceListChanged.bind(this), this._updateAudioOutputForAudioTracks = this._updateAudioOutputForAudioTracks.bind(this), m.a.isDeviceChangeAvailable("output") && (m.a.addListener(f.a.AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), m.a.addListener(f.a.DEVICE_LIST_CHANGED, this._onDeviceListChanged))
                }
                destroy() {
                    m.a.removeListener(f.a.AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), m.a.removeListener(f.a.DEVICE_LIST_CHANGED, this._onDeviceListChanged), this.removeListener(f.a.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener), this._channelOpenListener && this.removeListener(f.a.DATA_CHANNEL_OPEN, this._channelOpenListener)
                }
                static newCreateLocalTracks(e) {
                    return R(e)
                }
                static obtainAudioAndVideoPermissions(e) {
                    const t = h.a.usesNewGumFlow();
                    return (t ? m.a.newObtainAudioAndVideoPermissions(e) : m.a.obtainAudioAndVideoPermissions(e)).then(n => t ? R(n) : C(n, e))
                }
                initializeBridgeChannel(e, t) {
                    this._channel = new r.a(e, t, this.eventEmitter), this._channelOpenListener = () => {
                        this._channelOpen = !0;
                        try {
                            this._channel.sendPinnedEndpointMessage(this._pinnedEndpoint), this._channel.sendSelectedEndpointsMessage(this._selectedEndpoints), void 0 !== this._maxFrameHeight && this._channel.sendReceiverVideoConstraintMessage(this._maxFrameHeight)
                        } catch (e) {
                            o.a.callErrorHandler(e), E.error(`Cannot send selected(${this._selectedEndpoint})` + `pinned(${this._pinnedEndpoint})` + `frameHeight(${this._maxFrameHeight}) endpoint message`, e)
                        }
                        this.removeListener(f.a.DATA_CHANNEL_OPEN, this._channelOpenListener), this._channelOpenListener = null, -1 !== this._lastN && this._channel.sendSetLastNMessage(this._lastN)
                    }, this.addListener(f.a.DATA_CHANNEL_OPEN, this._channelOpenListener), this.addListener(f.a.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener)
                }
                _onDeviceListChanged() {
                    this._updateAudioOutputForAudioTracks(m.a.getAudioOutputDevice())
                }
                _onLastNChanged(e = []) {
                    const t = this._lastNEndpoints || [];
                    let n = [],
                        i = [];
                    this._lastNEndpoints = e, n = t.filter(e => !this.isInLastN(e)), i = e.filter(e => -1 === t.indexOf(e)), this.conference.eventEmitter.emit(a.LAST_N_ENDPOINTS_CHANGED, n, i)
                }
                onCallEnded() {
                    this._channel && (this._channel && "websocket" === this._channel.mode && this._channel.close(), this._channel = null, this._channelOpen = !1)
                }
                setReceiverVideoConstraint(e) {
                    this._maxFrameHeight = e, this._channel && this._channelOpen && this._channel.sendReceiverVideoConstraintMessage(e)
                }
                selectEndpoints(e) {
                    this._selectedEndpoints = e, this._channel && this._channelOpen && this._channel.sendSelectedEndpointsMessage(e)
                }
                pinEndpoint(e) {
                    this._pinnedEndpoint = e, this._channel && this._channelOpen && this._channel.sendPinnedEndpointMessage(e)
                }
                static addListener(e, t) {
                    m.a.addListener(e, t)
                }
                static removeListener(e, t) {
                    m.a.removeListener(e, t)
                }
                static init(e = {}) {
                    return this.options = e, m.a.init(this.options)
                }
                createPeerConnection(e, t, n, i) {
                    const r = A.getPCConstraints(n);
                    void 0 !== i.abtestSuspendVideo && (m.a.setSuspendVideo(r, i.abtestSuspendVideo), g.a.analytics.addPermanentProperties({
                        abtestSuspendVideo: i.abtestSuspendVideo
                    })), h.a.supportsInsertableStreams() && (E.debug("E2EE - setting insertable streams constraints"), t.forceEncodedAudioInsertableStreams = !0, t.forceEncodedVideoInsertableStreams = !0), h.a.supportsSdpSemantics() && (t.sdpSemantics = "plan-b"), t.bundlePolicy = "max-bundle", T = Object(u.c)(T);
                    const s = new _.a(this, T, e, t, r, n, i);
                    return this.peerConnections.set(s.id, s), s
                }
                _removePeerConnection(e) {
                    const t = e.id;
                    return !!this.peerConnections.has(t) && (this.peerConnections.delete(t), !0)
                }
                addLocalTrack(e) {
                    if (!e) throw new Error("track must not be null nor undefined");
                    this.localTracks.push(e), e.conference = this.conference
                }
                getLastN() {
                    return this._lastN
                }
                getLocalVideoTrack() {
                    const e = this.getLocalTracks(l.c);
                    return e.length ? e[0] : void 0
                }
                getLocalAudioTrack() {
                    const e = this.getLocalTracks(l.a);
                    return e.length ? e[0] : void 0
                }
                getLocalTracks(e) {
                    let t = this.localTracks.slice();
                    return void 0 !== e && (t = t.filter(t => t.getType() === e)), t
                }
                getRemoteTracks(e) {
                    let t = [];
                    for (const n of this.peerConnections.values()) {
                        const i = n.getRemoteTracks(void 0, e);
                        i && (t = t.concat(i))
                    }
                    return t
                }
                setAudioMute(e) {
                    const t = [];
                    return this.getLocalTracks(l.a).forEach(n => {
                        t.push(e ? n.mute() : n.unmute())
                    }), Promise.all(t)
                }
                removeLocalTrack(e) {
                    const t = this.localTracks.indexOf(e); - 1 !== t && this.localTracks.splice(t, 1)
                }
                removeRemoteTracks(e) {
                    let t = [];
                    for (const n of this.peerConnections.values()) {
                        const i = n.removeRemoteTracks(e);
                        t = t.concat(i)
                    }
                    return E.debug(`Removed remote tracks for ${e}` + ` count: ${t.length}`), t
                }
                static getPCConstraints(e) {
                    const t = e ? m.a.p2pPcConstraints : m.a.pcConstraints;
                    return t ? JSON.parse(JSON.stringify(t)) : {}
                }
                static attachMediaStream(e, t) {
                    return m.a.attachMediaStream(e, t)
                }
                static getStreamID(e) {
                    return m.a.getStreamID(e)
                }
                static getTrackID(e) {
                    return m.a.getTrackID(e)
                }
                static isDeviceListAvailable() {
                    return m.a.isDeviceListAvailable()
                }
                static isDeviceChangeAvailable(e) {
                    return m.a.isDeviceChangeAvailable(e)
                }
                static isWebRtcSupported() {
                    return h.a.isSupported()
                }
                static getAudioOutputDevice() {
                    return m.a.getAudioOutputDevice()
                }
                static getCurrentlyAvailableMediaDevices() {
                    return m.a.getCurrentlyAvailableMediaDevices()
                }
                static getEventDataForActiveDevice(e) {
                    return m.a.getEventDataForActiveDevice(e)
                }
                static setAudioOutputDevice(e) {
                    return m.a.setAudioOutputDevice(e)
                }
                static isUserStream(e) {
                    return A.isUserStreamById(m.a.getStreamID(e))
                }
                static isUserStreamById(e) {
                    return e && "mixedmslabel" !== e && "default" !== e
                }
                static enumerateDevices(e) {
                    m.a.enumerateDevices(e)
                }
                static stopMediaStream(e) {
                    m.a.stopMediaStream(e)
                }
                static isDesktopSharingEnabled() {
                    return m.a.isDesktopSharingEnabled()
                }
                closeBridgeChannel() {
                    this._channel && (this._channel.close(), this._channelOpen = !1, this.removeListener(f.a.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener))
                }
                setAudioLevel(e, t, n, i) {
                    const r = e.getTrackBySSRC(t);
                    r && (r.isAudioTrack() ? (r.isLocal() !== i && E.error(`${r} was expected to ${i?"be":"not be"} local`), r.setAudioLevel(n, e)) : E.warn(`Received audio level for non-audio track: ${t}`))
                }
                sendChannelMessage(e, t) {
                    if (!this._channel) throw new Error("Channel support is disabled!");
                    this._channel.sendMessage(e, t)
                }
                setLastN(e) {
                    this._lastN !== e && (this._lastN = e, this._channel && this._channelOpen && this._channel.sendSetLastNMessage(e), this.eventEmitter.emit(f.a.LASTN_VALUE_CHANGED, e))
                }
                isInLastN(e) {
                    return !this._lastNEndpoints || this._lastNEndpoints.indexOf(e) > -1
                }
                _updateAudioOutputForAudioTracks(e) {
                    const t = this.getRemoteTracks(l.a);
                    for (const n of t) n.setAudioOutput(e)
                }
            }
        }).call(this, "modules/RTC/RTC.js")
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "CHROME_EXTENSION_GENERIC_ERROR", (function() {
            return i
        })), n.d(t, "CHROME_EXTENSION_INSTALLATION_ERROR", (function() {
            return r
        })), n.d(t, "CHROME_EXTENSION_USER_GESTURE_REQUIRED", (function() {
            return s
        })), n.d(t, "CHROME_EXTENSION_USER_CANCELED", (function() {
            return o
        })), n.d(t, "CONSTRAINT_FAILED", (function() {
            return a
        })), n.d(t, "ELECTRON_DESKTOP_PICKER_ERROR", (function() {
            return c
        })), n.d(t, "ELECTRON_DESKTOP_PICKER_NOT_FOUND", (function() {
            return d
        })), n.d(t, "FIREFOX_EXTENSION_NEEDED", (function() {
            return u
        })), n.d(t, "GENERAL", (function() {
            return l
        })), n.d(t, "NOT_FOUND", (function() {
            return h
        })), n.d(t, "PERMISSION_DENIED", (function() {
            return p
        })), n.d(t, "TRACK_IS_DISPOSED", (function() {
            return f
        })), n.d(t, "TRACK_NO_STREAM_FOUND", (function() {
            return m
        })), n.d(t, "UNSUPPORTED_RESOLUTION", (function() {
            return g
        }));
        const i = "gum.chrome_extension_generic_error",
            r = "gum.chrome_extension_installation_error",
            s = "gum.chrome_extension_user_gesture_required",
            o = "gum.chrome_extension_user_canceled",
            a = "gum.constraint_failed",
            c = "gum.electron_desktop_picker_error",
            d = "gum.electron_desktop_picker_not_found",
            u = "gum.firefox_extension_needed",
            l = "gum.general",
            h = "gum.not_found",
            p = "gum.permission_denied",
            f = "track.track_is_disposed",
            m = "track.no_stream_found",
            g = "gum.unsupported_resolution"
    }, function(e, t) {
        e.exports = {
            CAMERA: "camera",
            DESKTOP: "desktop"
        }
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "LOCAL_TRACK_STOPPED", (function() {
            return i
        })), n.d(t, "TRACK_AUDIO_LEVEL_CHANGED", (function() {
            return r
        })), n.d(t, "TRACK_AUDIO_OUTPUT_CHANGED", (function() {
            return s
        })), n.d(t, "TRACK_MUTE_CHANGED", (function() {
            return o
        })), n.d(t, "TRACK_VIDEOTYPE_CHANGED", (function() {
            return a
        })), n.d(t, "NO_DATA_FROM_SOURCE", (function() {
            return c
        }));
        const i = "track.stopped",
            r = "track.audioLevelsChanged",
            s = "track.audioOutputChanged",
            o = "track.trackMuteChanged",
            a = "track.videoTypeChanged",
            c = "track.no_data_from_source"
    }, function(e, t, n) {
        "use strict";
        var i = n(13);
        const r = {};

        function s(e, t, n) {
            if ("object" == typeof e && void 0 !== e.name) switch (this.gum = {
                error: e,
                constraints: t,
                devices: n && Array.isArray(n) ? n.slice(0) : void 0
            }, e.name) {
                case "NotAllowedError":
                case "PermissionDeniedError":
                case "SecurityError":
                    this.name = i.PERMISSION_DENIED, this.message = r[this.name] + (this.gum.devices || []).join(", ");
                    break;
                case "DevicesNotFoundError":
                case "NotFoundError":
                    this.name = i.NOT_FOUND, this.message = r[this.name] + (this.gum.devices || []).join(", ");
                    break;
                case "ConstraintNotSatisfiedError":
                case "OverconstrainedError": {
                    const s = e.constraintName || e.constraint;
                    t && t.video && (!n || n.indexOf("video") > -1) && ("minWidth" === s || "maxWidth" === s || "minHeight" === s || "maxHeight" === s || "width" === s || "height" === s || "deviceId" === s) ? (this.name = i.UNSUPPORTED_RESOLUTION, this.message = r[this.name] + function(e, t) {
                        if (t && t.video && t.video.mandatory) switch (e) {
                            case "width":
                                return t.video.mandatory.minWidth;
                            case "height":
                                return t.video.mandatory.minHeight;
                            default:
                                return t.video.mandatory[e] || ""
                        }
                        return ""
                    }(s, t)) : (this.name = i.CONSTRAINT_FAILED, this.message = r[this.name] + e.constraintName);
                    break
                }
                default:
                    this.name = i.GENERAL, this.message = e.message || r[this.name]
            } else {
                if ("string" != typeof e) throw new Error("Invalid arguments");
                r[e] ? (this.name = e, this.message = t || r[e]) : this.message = e
            }
            this.stack = e.stack || (new Error).stack
        }
        r[i.UNSUPPORTED_RESOLUTION] = "Video resolution is not supported: ", r[i.CHROME_EXTENSION_INSTALLATION_ERROR] = "Failed to install Chrome extension", r[i.CHROME_EXTENSION_USER_GESTURE_REQUIRED] = "Failed to install Chrome extension - installations can only be initiated by a user gesture.", r[i.CHROME_EXTENSION_USER_CANCELED] = "User canceled Chrome's screen sharing prompt", r[i.CHROME_EXTENSION_GENERIC_ERROR] = "Unknown error from Chrome extension", r[i.ELECTRON_DESKTOP_PICKER_ERROR] = "Unkown error from desktop picker", r[i.ELECTRON_DESKTOP_PICKER_NOT_FOUND] = "Failed to detect desktop picker", r[i.GENERAL] = "Generic getUserMedia error", r[i.PERMISSION_DENIED] = "User denied permission to use device(s): ", r[i.NOT_FOUND] = "Requested device(s) was/were not found: ", r[i.CONSTRAINT_FAILED] = "Constraint could not be satisfied: ", r[i.TRACK_IS_DISPOSED] = "Track has been already disposed", r[i.TRACK_NO_STREAM_FOUND] = "Track does not have an associated Media Stream", s.prototype = Object.create(Error.prototype), s.prototype.constructor = s, t.a = s
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return s
        }));
        var i = n(3),
            r = n(6);

        function s(e) {
            const t = e.split("\r\nm=");
            for (let e = 1, n = t.length; e < n; e++) {
                let i = `m=${t[e]}`;
                e !== n - 1 && (i += "\r\n"), t[e] = i
            }
            const n = `${t.shift()}\r\n`;
            this.media = t, this.raw = n + t.join(""), this.session = n
        }
        s.prototype.failICE = !1, s.prototype.removeTcpCandidates = !1, s.prototype.removeUdpCandidates = !1, s.prototype.getMediaSsrcMap = function() {
            const e = this,
                t = {};
            let n;
            for (let i = 0; i < e.media.length; i++) {
                n = r.a.findLines(e.media[i], "a=ssrc:");
                const s = {
                    mediaindex: i,
                    mid: r.a.parseMID(r.a.findLine(e.media[i], "a=mid:")),
                    ssrcs: {},
                    ssrcGroups: []
                };
                t[i] = s, n.forEach(e => {
                    const t = e.substring(7).split(" ")[0];
                    s.ssrcs[t] || (s.ssrcs[t] = {
                        ssrc: t,
                        lines: []
                    }), s.ssrcs[t].lines.push(e)
                }), (n = r.a.findLines(e.media[i], "a=ssrc-group:")).forEach(e => {
                    const t = e.indexOf(" "),
                        n = e.substr(0, t).substr(13),
                        i = e.substr(14 + n.length).split(" ");
                    i.length && s.ssrcGroups.push({
                        semantics: n,
                        ssrcs: i
                    })
                })
            }
            return t
        }, s.prototype.containsSSRC = function(e) {
            const t = this.getMediaSsrcMap();
            let n = !1;
            return Object.keys(t).forEach(i => {
                n || t[i].ssrcs[e] && (n = !0)
            }), n
        }, s.prototype.mangle = function() {
            let e, t, n, i, s, o;
            for (e = 0; e < this.media.length; e++)
                if ((n = this.media[e].split("\r\n")).pop(), "audio" === (i = r.a.parseMLine(n.shift())).media) {
                    for (s = "", i.fmt.length = 0, t = 0; t < n.length; t++) {
                        if ("a=rtpmap:" === n[t].substr(0, 9)) {
                            if ("CN" === (o = r.a.parseRTPMap(n[t])).name || "ISAC" === o.name) continue;
                            i.fmt.push(o.id)
                        }
                        s += `${n[t]}\r\n`
                    }
                    this.media[e] = `${r.a.buildMLine(i)}\r\n${s}`
                } this.raw = this.session + this.media.join("")
        }, s.prototype.removeSessionLines = function(e) {
            const t = this,
                n = r.a.findLines(this.session, e);
            return n.forEach(e => {
                t.session = t.session.replace(`${e}\r\n`, "")
            }), this.raw = this.session + this.media.join(""), n
        }, s.prototype.removeMediaLines = function(e, t) {
            const n = this,
                i = r.a.findLines(this.media[e], t);
            return i.forEach(t => {
                n.media[e] = n.media[e].replace(`${t}\r\n`, "")
            }), this.raw = this.session + this.media.join(""), i
        }, s.prototype.toJingle = function(e, t) {
            let n, s, o, a, c, d, u, l;
            if ((a = r.a.findLines(this.session, "a=group:")).length)
                for (n = 0; n < a.length; n++) {
                    const t = (l = a[n].split(" ")).shift().substr(8);
                    for (e.c("group", {
                            xmlns: "urn:xmpp:jingle:apps:grouping:0",
                            semantics: t
                        }), s = 0; s < l.length; s++) e.c("content", {
                        name: l[s]
                    }).up();
                    e.up()
                }
            for (n = 0; n < this.media.length; n++) {
                if ("audio" !== (c = r.a.parseMLine(this.media[n].split("\r\n")[0])).media && "video" !== c.media && "application" !== c.media) continue;
                const h = r.a.findLine(this.media[n], "a=ssrc:");
                u = !!h && h.substring(7).split(" ")[0], e.c("content", {
                    creator: t,
                    name: c.media
                });
                const p = r.a.findLine(this.media[n], "a=mid:");
                if (p) {
                    const t = r.a.parseMID(p);
                    e.attrs({
                        name: t
                    })
                }
                if (r.a.findLine(this.media[n], "a=rtpmap:").length) {
                    for (e.c("description", {
                            xmlns: "urn:xmpp:jingle:apps:rtp:1",
                            media: c.media
                        }), u && e.attrs({
                            ssrc: u
                        }), s = 0; s < c.fmt.length; s++) {
                        d = r.a.findLine(this.media[n], `a=rtpmap:${c.fmt[s]}`), e.c("payload-type", r.a.parseRTPMap(d));
                        const t = r.a.findLine(this.media[n], `a=fmtp:${c.fmt[s]}`);
                        if (t)
                            for (l = r.a.parseFmtp(t), o = 0; o < l.length; o++) e.c("parameter", l[o]).up();
                        this.rtcpFbToJingle(n, e, c.fmt[s]), e.up()
                    }
                    const t = r.a.findLines(this.media[n], "a=crypto:", this.session);
                    if (t.length && (e.c("encryption", {
                            required: 1
                        }), t.forEach(t => e.c("crypto", r.a.parseCrypto(t)).up()), e.up()), u) {
                        const t = r.a.parseSSRC(this.media[n]);
                        for (const [n, i] of t) e.c("source", {
                            ssrc: n,
                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                        }), i.forEach(t => {
                            const n = t.indexOf(" "),
                                i = t.substr(n + 1);
                            if (e.c("parameter"), -1 === i.indexOf(":")) e.attrs({
                                name: i
                            });
                            else {
                                const t = i.split(":", 2)[0];
                                e.attrs({
                                    name: t
                                });
                                let n = i.split(":", 2)[1];
                                n = r.a.filterSpecialChars(n), e.attrs({
                                    value: n
                                })
                            }
                            e.up()
                        }), e.up();
                        r.a.findLines(this.media[n], "a=ssrc-group:").forEach(t => {
                            const n = t.indexOf(" "),
                                i = t.substr(0, n).substr(13),
                                r = t.substr(14 + i.length).split(" ");
                            r.length && (e.c("ssrc-group", {
                                semantics: i,
                                xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                            }), r.forEach(t => e.c("source", {
                                ssrc: t
                            }).up()), e.up())
                        })
                    }
                    const h = r.a.findLines(this.media[n], "a=rid");
                    if (h.length && i.a.usesRidsForSimulcast()) {
                        const t = h.map(e => e.split(":")[1]).map(e => e.split(" ")[0]);
                        t.forEach(t => {
                            e.c("source", {
                                rid: t,
                                xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                            }), e.up()
                        }), r.a.findLine(this.media[n], "a=simulcast") && (e.c("rid-group", {
                            semantics: "SIM",
                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                        }), t.forEach(t => {
                            e.c("source", {
                                rid: t
                            }).up()
                        }), e.up())
                    }
                    if (r.a.findLine(this.media[n], "a=rtcp-mux") && e.c("rtcp-mux").up(), this.rtcpFbToJingle(n, e, "*"), (a = r.a.findLines(this.media[n], "a=extmap:")).length)
                        for (s = 0; s < a.length; s++) {
                            if (l = r.a.parseExtmap(a[s]), e.c("rtp-hdrext", {
                                    xmlns: "urn:xmpp:jingle:apps:rtp:rtp-hdrext:0",
                                    uri: l.uri,
                                    id: l.value
                                }), l.hasOwnProperty("direction")) switch (l.direction) {
                                case "sendonly":
                                    e.attrs({
                                        senders: "responder"
                                    });
                                    break;
                                case "recvonly":
                                    e.attrs({
                                        senders: "initiator"
                                    });
                                    break;
                                case "sendrecv":
                                    e.attrs({
                                        senders: "both"
                                    });
                                    break;
                                case "inactive":
                                    e.attrs({
                                        senders: "none"
                                    })
                            }
                            e.up()
                        }
                    e.up()
                }
                this.transportToJingle(n, e);
                const f = this.media[n];
                r.a.findLine(f, "a=sendrecv", this.session) ? e.attrs({
                    senders: "both"
                }) : r.a.findLine(f, "a=sendonly", this.session) ? e.attrs({
                    senders: "initiator"
                }) : r.a.findLine(f, "a=recvonly", this.session) ? e.attrs({
                    senders: "responder"
                }) : r.a.findLine(f, "a=inactive", this.session) && e.attrs({
                    senders: "none"
                }), "0" !== c.port || r.a.findLine(f, "a=bundle-only", this.session) || e.attrs({
                    senders: "rejected"
                }), e.up()
            }
            return e.up(), e
        }, s.prototype.transportToJingle = function(e, t) {
            let n;
            const i = this;
            t.c("transport");
            const s = r.a.findLine(this.media[e], "a=sctpmap:", i.session);
            if (s) {
                const e = r.a.parseSCTPMap(s);
                t.c("sctpmap", {
                    xmlns: "urn:xmpp:jingle:transports:dtls-sctp:1",
                    number: e[0],
                    protocol: e[1]
                }), e.length > 2 && t.attrs({
                    streams: e[2]
                }), t.up()
            }
            if (r.a.findLines(this.media[e], "a=fingerprint:", this.session).forEach(s => {
                    (n = r.a.parseFingerprint(s)).xmlns = "urn:xmpp:jingle:apps:dtls:0", t.c("fingerprint").t(n.fingerprint), delete n.fingerprint, (s = r.a.findLine(i.media[e], "a=setup:", i.session)) && (n.setup = s.substr(8)), t.attrs(n), t.up()
                }), n = r.a.iceparams(this.media[e], this.session)) {
                n.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.attrs(n);
                const s = r.a.findLines(this.media[e], "a=candidate:", this.session);
                s.length && s.forEach(e => {
                    const n = r.a.candidateToJingle(e);
                    i.failICE && (n.ip = "1.1.1.1");
                    const s = n && "string" == typeof n.protocol ? n.protocol.toLowerCase() : "";
                    i.removeTcpCandidates && ("tcp" === s || "ssltcp" === s) || i.removeUdpCandidates && "udp" === s || t.c("candidate", n).up()
                })
            }
            t.up()
        }, s.prototype.rtcpFbToJingle = function(e, t, n) {
            r.a.findLines(this.media[e], `a=rtcp-fb:${n}`).forEach(e => {
                const n = r.a.parseRTCPFB(e);
                "trr-int" === n.type ? (t.c("rtcp-fb-trr-int", {
                    xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
                    value: n.params[0]
                }), t.up()) : (t.c("rtcp-fb", {
                    xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
                    type: n.type
                }), n.params.length > 0 && t.attrs({
                    subtype: n.params[0]
                }), t.up())
            })
        }, s.prototype.rtcpFbFromJingle = function(e, t) {
            let n = "",
                i = e.find('>rtcp-fb-trr-int[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
            return i.length && (n += "a=rtcp-fb:* trr-int ", i.attr("value") ? n += i.attr("value") : n += "0", n += "\r\n"), (i = e.find('>rtcp-fb[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]')).each((function() {
                n += `a=rtcp-fb:${t} ${$(this).attr("type")}`, $(this).attr("subtype") && (n += ` ${$(this).attr("subtype")}`), n += "\r\n"
            })), n
        }, s.prototype.fromJingle = function(e) {
            const t = this,
                n = Date.now();
            this.raw = "v=0\r\n" + `o=- ${n} 2 IN IP4 0.0.0.0\r\n` + "s=-\r\nt=0 0\r\n";
            const i = $(e).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]');
            i.length && i.each((e, n) => {
                const i = $(n).find(">content").map((e, t) => t.getAttribute("name")).get();
                i.length > 0 && (t.raw += `a=group:${n.getAttribute("semantics")||n.getAttribute("type")} ${i.join(" ")}\r\n`)
            }), this.session = this.raw, e.find(">content").each((function() {
                const e = t.jingle2media($(this));
                t.media.push(e)
            })), this.raw = this.session + this.media.join("")
        }, s.prototype.jingle2media = function(e) {
            const t = e.find("description");
            let n = "";
            const i = this,
                s = e.find('>transport>sctpmap[xmlns="urn:xmpp:jingle:transports:dtls-sctp:1"]');
            let o = {
                media: t.attr("media"),
                port: "1"
            };
            if ("rejected" === e.attr("senders") && (o.port = "0"), e.find(">transport>fingerprint").length || t.find("encryption").length ? o.proto = s.length ? "DTLS/SCTP" : "RTP/SAVPF" : o.proto = "RTP/AVPF", s.length) {
                n += `m=application ${o.port} DTLS/SCTP ${s.attr("number")}\r\n`, n += `a=sctpmap:${s.attr("number")} ${s.attr("protocol")}`;
                const e = s.attr("streams");
                n += e ? ` ${e}\r\n` : "\r\n"
            } else o.fmt = t.find("payload-type").map((function() {
                return this.getAttribute("id")
            })).get(), n += `${r.a.buildMLine(o)}\r\n`;
            switch (n += "c=IN IP4 0.0.0.0\r\n", s.length || (n += "a=rtcp:1 IN IP4 0.0.0.0\r\n"), (o = e.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]')).length && (o.attr("ufrag") && (n += `${r.a.buildICEUfrag(o.attr("ufrag"))}\r\n`), o.attr("pwd") && (n += `${r.a.buildICEPwd(o.attr("pwd"))}\r\n`), o.find(">fingerprint").each((function() {
                n += `a=fingerprint:${this.getAttribute("hash")}`, n += ` ${$(this).text()}`, n += "\r\n", this.getAttribute("setup") && (n += `a=setup:${this.getAttribute("setup")}\r\n`)
            }))), e.attr("senders")) {
                case "initiator":
                    n += "a=sendonly\r\n";
                    break;
                case "responder":
                    n += "a=recvonly\r\n";
                    break;
                case "none":
                    n += "a=inactive\r\n";
                    break;
                case "both":
                    n += "a=sendrecv\r\n"
            }
            return n += `a=mid:${e.attr("name")}\r\n`, t.find("rtcp-mux").length && (n += "a=rtcp-mux\r\n"), t.find("encryption").length && t.find("encryption>crypto").each((function() {
                n += `a=crypto:${this.getAttribute("tag")}`, n += ` ${this.getAttribute("crypto-suite")}`, n += ` ${this.getAttribute("key-params")}`, this.getAttribute("session-params") && (n += ` ${this.getAttribute("session-params")}`), n += "\r\n"
            })), t.find("payload-type").each((function() {
                n += `${r.a.buildRTPMap(this)}\r\n`, $(this).find(">parameter").length && (n += `a=fmtp:${this.getAttribute("id")} `, n += $(this).find("parameter").map((function() {
                    const e = this.getAttribute("name");
                    return (e ? `${e}=` : "") + this.getAttribute("value")
                })).get().join("; "), n += "\r\n"), n += i.rtcpFbFromJingle($(this), this.getAttribute("id"))
            })), n += i.rtcpFbFromJingle(t, "*"), (o = t.find('>rtp-hdrext[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]')).each((function() {
                n += `a=extmap:${this.getAttribute("id")} ${this.getAttribute("uri")}\r\n`
            })), e.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]>candidate').each((function() {
                let e = this.getAttribute("protocol");
                e = "string" == typeof e ? e.toLowerCase() : "", i.removeTcpCandidates && ("tcp" === e || "ssltcp" === e) || i.removeUdpCandidates && "udp" === e || (i.failICE && this.setAttribute("ip", "1.1.1.1"), n += r.a.candidateFromJingle(this))
            })), e.find('description>ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                const e = this.getAttribute("semantics"),
                    t = $(this).find(">source").map((function() {
                        return this.getAttribute("ssrc")
                    })).get();
                t.length && (n += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
            })), (o = e.find('description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]')).each((function() {
                const e = this.getAttribute("ssrc");
                $(this).find(">parameter").each((function() {
                    const t = this.getAttribute("name");
                    let i = this.getAttribute("value");
                    i = r.a.filterSpecialChars(i), n += `a=ssrc:${e} ${t}`, i && i.length && (n += `:${i}`), n += "\r\n"
                }))
            })), n
        }
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "AUTHENTICATION_REQUIRED", (function() {
            return i
        })), n.d(t, "CHAT_ERROR", (function() {
            return r
        })), n.d(t, "CONFERENCE_DESTROYED", (function() {
            return s
        })), n.d(t, "CONFERENCE_MAX_USERS", (function() {
            return o
        })), n.d(t, "CONNECTION_ERROR", (function() {
            return a
        })), n.d(t, "NOT_ALLOWED_ERROR", (function() {
            return c
        })), n.d(t, "FOCUS_DISCONNECTED", (function() {
            return d
        })), n.d(t, "FOCUS_LEFT", (function() {
            return u
        })), n.d(t, "GRACEFUL_SHUTDOWN", (function() {
            return l
        })), n.d(t, "INCOMPATIBLE_SERVER_VERSIONS", (function() {
            return h
        })), n.d(t, "OFFER_ANSWER_FAILED", (function() {
            return p
        })), n.d(t, "PASSWORD_NOT_SUPPORTED", (function() {
            return f
        })), n.d(t, "PASSWORD_REQUIRED", (function() {
            return m
        })), n.d(t, "RESERVATION_ERROR", (function() {
            return g
        })), n.d(t, "SETUP_FAILED", (function() {
            return _
        })), n.d(t, "VIDEOBRIDGE_NOT_AVAILABLE", (function() {
            return v
        }));
        const i = "conference.authenticationRequired",
            r = "conference.chatError",
            s = "conference.destroyed",
            o = "conference.max_users",
            a = "conference.connectionError",
            c = "conference.connectionError.notAllowed",
            d = "conference.focusDisconnected",
            u = "conference.focusLeft",
            l = "conference.gracefulShutdown",
            h = "conference.incompatible_server_versions",
            p = "conference.offerAnswerFailed",
            f = "conference.passwordNotSupported",
            m = "conference.passwordRequired",
            g = "conference.reservationError",
            _ = "conference.setup_failed",
            v = "conference.videobridgeNotAvailable"
    }, function(e, t, n) {
        "use strict";
        var i, r = "object" == typeof Reflect ? Reflect : null,
            s = r && "function" == typeof r.apply ? r.apply : function(e, t, n) {
                return Function.prototype.apply.call(e, t, n)
            };
        i = r && "function" == typeof r.ownKeys ? r.ownKeys : Object.getOwnPropertySymbols ? function(e) {
            return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
        } : function(e) {
            return Object.getOwnPropertyNames(e)
        };
        var o = Number.isNaN || function(e) {
            return e != e
        };

        function a() {
            a.init.call(this)
        }
        e.exports = a, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0;
        var c = 10;

        function d(e) {
            return void 0 === e._maxListeners ? a.defaultMaxListeners : e._maxListeners
        }

        function u(e, t, n, i) {
            var r, s, o, a;
            if ("function" != typeof n) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n);
            if (void 0 === (s = e._events) ? (s = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== s.newListener && (e.emit("newListener", t, n.listener ? n.listener : n), s = e._events), o = s[t]), void 0 === o) o = s[t] = n, ++e._eventsCount;
            else if ("function" == typeof o ? o = s[t] = i ? [n, o] : [o, n] : i ? o.unshift(n) : o.push(n), (r = d(e)) > 0 && o.length > r && !o.warned) {
                o.warned = !0;
                var c = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                c.name = "MaxListenersExceededWarning", c.emitter = e, c.type = t, c.count = o.length, a = c, console && console.warn && console.warn(a)
            }
            return e
        }

        function l() {
            for (var e = [], t = 0; t < arguments.length; t++) e.push(arguments[t]);
            this.fired || (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, s(this.listener, this.target, e))
        }

        function h(e, t, n) {
            var i = {
                    fired: !1,
                    wrapFn: void 0,
                    target: e,
                    type: t,
                    listener: n
                },
                r = l.bind(i);
            return r.listener = n, i.wrapFn = r, r
        }

        function p(e, t, n) {
            var i = e._events;
            if (void 0 === i) return [];
            var r = i[t];
            return void 0 === r ? [] : "function" == typeof r ? n ? [r.listener || r] : [r] : n ? function(e) {
                for (var t = new Array(e.length), n = 0; n < t.length; ++n) t[n] = e[n].listener || e[n];
                return t
            }(r) : m(r, r.length)
        }

        function f(e) {
            var t = this._events;
            if (void 0 !== t) {
                var n = t[e];
                if ("function" == typeof n) return 1;
                if (void 0 !== n) return n.length
            }
            return 0
        }

        function m(e, t) {
            for (var n = new Array(t), i = 0; i < t; ++i) n[i] = e[i];
            return n
        }
        Object.defineProperty(a, "defaultMaxListeners", {
            enumerable: !0,
            get: function() {
                return c
            },
            set: function(e) {
                if ("number" != typeof e || e < 0 || o(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
                c = e
            }
        }), a.init = function() {
            void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
        }, a.prototype.setMaxListeners = function(e) {
            if ("number" != typeof e || e < 0 || o(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
            return this._maxListeners = e, this
        }, a.prototype.getMaxListeners = function() {
            return d(this)
        }, a.prototype.emit = function(e) {
            for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
            var i = "error" === e,
                r = this._events;
            if (void 0 !== r) i = i && void 0 === r.error;
            else if (!i) return !1;
            if (i) {
                var o;
                if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
                var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
                throw a.context = o, a
            }
            var c = r[e];
            if (void 0 === c) return !1;
            if ("function" == typeof c) s(c, this, t);
            else {
                var d = c.length,
                    u = m(c, d);
                for (n = 0; n < d; ++n) s(u[n], this, t)
            }
            return !0
        }, a.prototype.addListener = function(e, t) {
            return u(this, e, t, !1)
        }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function(e, t) {
            return u(this, e, t, !0)
        }, a.prototype.once = function(e, t) {
            if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
            return this.on(e, h(this, e, t)), this
        }, a.prototype.prependOnceListener = function(e, t) {
            if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
            return this.prependListener(e, h(this, e, t)), this
        }, a.prototype.removeListener = function(e, t) {
            var n, i, r, s, o;
            if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
            if (void 0 === (i = this._events)) return this;
            if (void 0 === (n = i[e])) return this;
            if (n === t || n.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || t));
            else if ("function" != typeof n) {
                for (r = -1, s = n.length - 1; s >= 0; s--)
                    if (n[s] === t || n[s].listener === t) {
                        o = n[s].listener, r = s;
                        break
                    } if (r < 0) return this;
                0 === r ? n.shift() : function(e, t) {
                    for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                    e.pop()
                }(n, r), 1 === n.length && (i[e] = n[0]), void 0 !== i.removeListener && this.emit("removeListener", e, o || t)
            }
            return this
        }, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function(e) {
            var t, n, i;
            if (void 0 === (n = this._events)) return this;
            if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[e]), this;
            if (0 === arguments.length) {
                var r, s = Object.keys(n);
                for (i = 0; i < s.length; ++i) "removeListener" !== (r = s[i]) && this.removeAllListeners(r);
                return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
            }
            if ("function" == typeof(t = n[e])) this.removeListener(e, t);
            else if (void 0 !== t)
                for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
            return this
        }, a.prototype.listeners = function(e) {
            return p(this, e, !0)
        }, a.prototype.rawListeners = function(e) {
            return p(this, e, !1)
        }, a.listenerCount = function(e, t) {
            return "function" == typeof e.listenerCount ? e.listenerCount(t) : f.call(e, t)
        }, a.prototype.listenerCount = f, a.prototype.eventNames = function() {
            return this._eventsCount > 0 ? i(this._events) : []
        }
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "DETECTOR_STATE_CHANGE", (function() {
            return i
        })), n.d(t, "AUDIO_INPUT_STATE_CHANGE", (function() {
            return r
        })), n.d(t, "NO_AUDIO_INPUT", (function() {
            return s
        })), n.d(t, "VAD_NOISY_DEVICE", (function() {
            return o
        })), n.d(t, "VAD_REPORT_PUBLISHED", (function() {
            return a
        })), n.d(t, "VAD_SCORE_PUBLISHED", (function() {
            return c
        })), n.d(t, "VAD_TALK_WHILE_MUTED", (function() {
            return d
        }));
        const i = "detector_state_change",
            r = "audio_input_state_changed",
            s = "no_audio_input_detected",
            o = "detection.vad_noise_device",
            a = "vad-report-published",
            c = "detection.vad_score_published",
            d = "detection.vad_talk_while_muted"
    }, function(e, t, n) {
        var i = n(139),
            r = n(140);
        t.write = r, t.parse = i.parse, t.parseFmtpConfig = i.parseFmtpConfig, t.parseParams = i.parseParams, t.parsePayloads = i.parsePayloads, t.parseRemoteCandidates = i.parseRemoteCandidates, t.parseImageAttributes = i.parseImageAttributes, t.parseSimulcastStreamList = i.parseSimulcastStreamList
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "STATUS_AVAILABLE", (function() {
            return i
        })), n.d(t, "STATUS_UNDEFINED", (function() {
            return r
        })), n.d(t, "STATUS_BUSY", (function() {
            return s
        })), n.d(t, "STATE_ON", (function() {
            return o
        })), n.d(t, "STATE_OFF", (function() {
            return a
        })), n.d(t, "STATE_PENDING", (function() {
            return c
        })), n.d(t, "STATE_RETRYING", (function() {
            return d
        })), n.d(t, "STATE_FAILED", (function() {
            return u
        })), n.d(t, "ERROR_NO_CONNECTION", (function() {
            return l
        })), n.d(t, "ERROR_SESSION_EXISTS", (function() {
            return h
        }));
        const i = "available",
            r = "undefined",
            s = "busy",
            o = "on",
            a = "off",
            c = "pending",
            d = "retrying",
            u = "failed",
            l = "error_no_connection",
            h = "error_session_already_exists"
    }, function(e, t, n) {
        "use strict";
        var i = {};
        n.r(i), n.d(i, "CHROME", (function() {
            return o
        })), n.d(i, "OPERA", (function() {
            return a
        })), n.d(i, "FIREFOX", (function() {
            return c
        })), n.d(i, "INTERNET_EXPLORER", (function() {
            return d
        })), n.d(i, "SAFARI", (function() {
            return u
        })), n.d(i, "NWJS", (function() {
            return l
        })), n.d(i, "ELECTRON", (function() {
            return h
        })), n.d(i, "REACT_NATIVE", (function() {
            return p
        })), n.d(i, "UNKNOWN", (function() {
            return f
        }));
        var r = n(77),
            s = n.n(r);
        const o = "chrome",
            a = "opera",
            c = "firefox",
            d = "iexplorer",
            u = "safari",
            l = "nwjs",
            h = "electron",
            p = "react-native",
            f = "unknown",
            m = {
                Chrome: o,
                Chromium: o,
                Opera: a,
                Firefox: c,
                "Internet Explorer": d,
                Safari: u
            };

        function g() {
            const e = navigator.userAgent;
            if (e.match(/Electron/)) {
                const t = e.match(/Electron\/([\d.]+)/)[1];
                return {
                    name: h,
                    version: t
                }
            }
        }

        function _() {
            const e = navigator.userAgent;
            if (e.match(/JitsiMeetNW/)) {
                const t = e.match(/JitsiMeetNW\/([\d.]+)/)[1];
                return {
                    name: l,
                    version: t
                }
            }
        }

        function v() {
            const e = navigator.userAgent.match(/\b(react[ \t_-]*native)(?:\/(\S+))?/i);
            let t;
            if (e || "ReactNative" === navigator.product) {
                let n;
                return e && e.length > 2 && (n = e[1], t = e[2]), n || (n = "react-native"), t || (t = "unknown"), {
                    name: p,
                    version: t
                }
            }
        }

        function S(e) {
            let t;
            const n = [v, g, _];
            for (let e = 0; e < n.length; e++)
                if (t = n[e]()) return t;
            const i = e.getBrowserName();
            return i in m ? {
                name: m[i],
                version: e.getBrowserVersion()
            } : (t = function() {
                const e = navigator.userAgent,
                    t = {
                        name: f,
                        version: void 0
                    };
                if (e.match(/Chrome/) && !e.match(/Edge/))
                    if (e.match(/Edg(A?)/)) {
                        const n = e.match(/Chrome\/([\d.]+)/)[1];
                        Number.parseInt(n, 10) > 72 && (t.name = o, t.version = n)
                    } else t.name = o, t.version = e.match(/Chrome\/([\d.]+)/)[1];
                return t
            }()) || {
                name: f,
                version: void 0
            }
        }
        class y {
            constructor(e) {
                let t, n;
                if (this._bowser = s.a.getParser(navigator.userAgent), void 0 === e) {
                    const e = S(this._bowser);
                    t = e.name, n = e.version
                } else e.name in m ? (t = m[e.name], n = e.version) : (t = f, n = void 0);
                this._name = t, this._version = n
            }
            getName() {
                return this._name
            }
            isChrome() {
                return this._name === o
            }
            isOpera() {
                return this._name === a
            }
            isFirefox() {
                return this._name === c
            }
            isIExplorer() {
                return this._name === d
            }
            isSafari() {
                return this._name === u
            }
            isNWJS() {
                return this._name === l
            }
            isElectron() {
                return this._name === h
            }
            isReactNative() {
                return this._name === p
            }
            getVersion() {
                return this._version
            }
            _checkCondition(e) {
                if (this._version) return this._bowser.satisfies(e)
            }
            isVersionGreaterThan(e) {
                return this._checkCondition({
                    [this._name]: `>${e}`
                })
            }
            isVersionLessThan(e) {
                return this._checkCondition({
                    [this._name]: `<${e}`
                })
            }
            isVersionEqualTo(e) {
                return this._checkCondition({
                    [this._name]: `~${e}`
                })
            }
        }
        n(64);
        n.d(t, "a", (function() {
            return y
        })), n.d(t, "b", (function() {
            return i
        }))
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return s
        }));
        var i = n(19),
            r = n.n(i);
        class s {
            constructor(e = new r.a) {
                this.eventEmitter = e, this.addEventListener = this.on = this.addListener, this.removeEventListener = this.off = this.removeListener
            }
            addListener(e, t) {
                return this.eventEmitter.addListener(e, t), () => this.removeEventListener(e, t)
            }
            removeListener(e, t) {
                this.eventEmitter.removeListener(e, t)
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "CONNECTION_DISCONNECTED", (function() {
            return i
        })), n.d(t, "CONNECTION_ESTABLISHED", (function() {
            return r
        })), n.d(t, "CONNECTION_FAILED", (function() {
            return s
        })), n.d(t, "WRONG_STATE", (function() {
            return o
        }));
        const i = "connection.connectionDisconnected",
            r = "connection.connectionEstablished",
            s = "connection.connectionFailed",
            o = "connection.wrongState"
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        })), n.d(t, "b", (function() {
            return r
        })), n.d(t, "c", (function() {
            return s
        })), n.d(t, "d", (function() {
            return o
        }));
        const i = "statistics.audioLevel",
            r = "statistics.before_disposed",
            s = "statistics.byte_sent_stats",
            o = "statistics.connectionstats"
    }, function(e, t, n) {
        "use strict";
        n.d(t, "b", (function() {
            return r
        })), n.d(t, "c", (function() {
            return s
        })), n.d(t, "a", (function() {
            return c
        }));
        var i = n(21);

        function r(e) {
            return parseInt(e.ssrcs.split(" ")[0], 10)
        }

        function s(e) {
            return parseInt(e.ssrcs.split(" ")[1], 10)
        }

        function o(e) {
            return e.ssrcs ? e.ssrcs.map(e => e.id).filter((e, t, n) => n.indexOf(e) === t).length : 0
        }
        class a {
            constructor(e) {
                if (!e) throw new Error("mLine is undefined");
                this.mLine = e
            }
            get ssrcs() {
                return this.mLine.ssrcs || (this.mLine.ssrcs = []), this.mLine.ssrcs
            }
            set ssrcs(e) {
                this.mLine.ssrcs = e
            }
            get direction() {
                return this.mLine.direction
            }
            set direction(e) {
                this.mLine.direction = e
            }
            get ssrcGroups() {
                return this.mLine.ssrcGroups || (this.mLine.ssrcGroups = []), this.mLine.ssrcGroups
            }
            set ssrcGroups(e) {
                this.mLine.ssrcGroups = e
            }
            getSSRCAttrValue(e, t) {
                const n = this.ssrcs.find(n => n.id === e && n.attribute === t);
                return n && n.value
            }
            removeSSRC(e) {
                this.mLine.ssrcs && this.mLine.ssrcs.length && (this.mLine.ssrcs = this.mLine.ssrcs.filter(t => t.id !== e))
            }
            addSSRCAttribute(e) {
                this.ssrcs.push(e)
            }
            findGroup(e, t) {
                return this.ssrcGroups.find(n => n.semantics === e && (!t || t === n.ssrcs))
            }
            findGroups(e) {
                return this.ssrcGroups.filter(t => t.semantics === e)
            }
            findGroupByPrimarySSRC(e, t) {
                return this.ssrcGroups.find(n => n.semantics === e && r(n) === t)
            }
            findSSRCByMSID(e) {
                return this.ssrcs.find(t => "msid" === t.attribute && (null === e || t.value === e))
            }
            getSSRCCount() {
                return o(this.mLine)
            }
            containsAnySSRCGroups() {
                return void 0 !== this.mLine.ssrcGroups
            }
            getPrimaryVideoSsrc() {
                const e = this.mLine.type;
                if ("video" !== e) throw new Error(`getPrimarySsrc doesn't work with '${e}'`);
                if (1 === o(this.mLine)) return this.mLine.ssrcs[0].id;
                if (this.mLine.ssrcGroups) {
                    const e = this.findGroup("SIM");
                    if (e) return r(e);
                    const t = this.findGroup("FID");
                    if (t) return r(t);
                    const n = this.findGroup("FEC-FR");
                    if (n) return r(n)
                }
            }
            getRtxSSRC(e) {
                const t = this.findGroupByPrimarySSRC("FID", e);
                return t && s(t)
            }
            getSSRCs() {
                return this.ssrcs.map(e => e.id).filter((e, t, n) => n.indexOf(e) === t)
            }
            getPrimaryVideoSSRCs() {
                const e = this.mLine.type;
                if ("video" !== e) throw new Error(`getPrimaryVideoSSRCs doesn't work with ${e}`);
                const t = this.getSSRCs();
                for (const e of this.ssrcGroups)
                    if ("FID" === e.semantics || "FEC-FR" === e.semantics) {
                        const n = s(e);
                        t.splice(t.indexOf(n), 1)
                    } return t
            }
            dumpSSRCGroups() {
                return JSON.stringify(this.mLine.ssrcGroups)
            }
            removeGroupsWithSSRC(e) {
                this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter(t => -1 === t.ssrcs.indexOf(`${e}`)))
            }
            removeGroupsBySemantics(e) {
                this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter(t => t.semantics !== e))
            }
            replaceSSRC(e, t) {
                this.mLine.ssrcs && this.mLine.ssrcs.forEach(n => {
                    n.id === e && (n.id = t)
                })
            }
            addSSRCGroup(e) {
                this.ssrcGroups.push(e)
            }
        }
        class c {
            constructor(e) {
                this.parsedSDP = i.parse(e)
            }
            selectMedia(e) {
                const t = this.parsedSDP.media.find(t => t.type === e);
                return t ? new a(t) : null
            }
            toRawSDP() {
                return i.write(this.parsedSDP)
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "LOCAL_STATS_UPDATED", (function() {
            return i
        })), n.d(t, "REMOTE_STATS_UPDATED", (function() {
            return r
        }));
        const i = "cq.local_stats_updated",
            r = "cq.remote_stats_updated"
    }, function(e, t, n) {
        "use strict";

        function i(e) {
            let t = e;
            return e >= Number.MAX_SAFE_INTEGER && (t = 0), t + 1
        }

        function r(e) {
            return e.length > 0 ? e.reduce((e, t) => e + t) / e.length : 0
        }

        function s(e) {
            return e.filter(e => e >= 0)
        }
        n.d(t, "c", (function() {
            return i
        })), n.d(t, "a", (function() {
            return r
        })), n.d(t, "b", (function() {
            return s
        }))
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        }));
        const i = {
            ACCEPT: "session-accept",
            CONNECTION_ERROR: "connection-error-encountered",
            INITIATE: "session-initiate",
            TERMINATE: "session-terminate",
            TRANSPORT_INFO: "transport-info",
            UNAVAILABLE: "unavailable"
        }
    }, function(e, t) {
        e.exports = {
            1080: {
                width: 1920,
                height: 1080,
                order: 8
            },
            fullhd: {
                width: 1920,
                height: 1080,
                order: 8
            },
            720: {
                width: 1280,
                height: 720,
                order: 7
            },
            hd: {
                width: 1280,
                height: 720,
                order: 7
            },
            960: {
                width: 960,
                height: 720,
                order: 6
            },
            540: {
                width: 960,
                height: 540,
                order: 5
            },
            qhd: {
                width: 960,
                height: 540,
                order: 5
            },
            360: {
                width: 640,
                height: 360,
                order: 4
            },
            640: {
                width: 640,
                height: 480,
                order: 3
            },
            vga: {
                width: 640,
                height: 480,
                order: 3
            },
            180: {
                width: 320,
                height: 180,
                order: 2
            },
            320: {
                width: 320,
                height: 240,
                order: 1
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "c", (function() {
            return i
        })), n.d(t, "a", (function() {
            return r
        })), n.d(t, "b", (function() {
            return s
        }));
        const i = "pending",
            r = "active",
            s = "ended"
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return h
            }));
            var i = n(3),
                r = n(11),
                s = n.n(r);
            const o = n(4).getLogger(e),
                a = {
                    createOffer: "createOffer",
                    createAnswer: "createAnswer",
                    setLocalDescription: "setLocalDescription",
                    setRemoteDescription: "setRemoteDescription",
                    addIceCandidate: "addIceCandidate",
                    getUserMedia: "getUserMedia",
                    iceConnectionFailure: "iceConnectionFailure",
                    signalingError: "signalingError",
                    applicationLog: "applicationLog"
                },
                c = {
                    fabricHold: "fabricHold",
                    fabricResume: "fabricResume",
                    audioMute: "audioMute",
                    audioUnmute: "audioUnmute",
                    videoPause: "videoPause",
                    videoResume: "videoResume",
                    fabricUsageEvent: "fabricUsageEvent",
                    fabricStats: "fabricStats",
                    fabricTerminated: "fabricTerminated",
                    screenShareStart: "screenShareStart",
                    screenShareStop: "screenShareStop",
                    dominantSpeaker: "dominantSpeaker",
                    activeDeviceList: "activeDeviceList"
                },
                d = "jitsi",
                u = {
                    ERROR: "error",
                    EVENT: "event",
                    MST_WITH_USERID: "mstWithUserID"
                };
            let l;
            class h {
                static _addNewFabricCallback(e, t) {
                    h.backend && "success" !== e && o.error(`Monitoring status: ${e} msg: ${t}`)
                }
                static _initCallback(e, t) {
                    if (o.log(`CallStats Status: err=${e} msg=${t}`), "success" !== e) return;
                    h.backendInitialized = !0;
                    let n = !1,
                        i = null;
                    for (const e of h.fabrics.values()) e.hasFabric || (o.debug("addNewFabric - initCallback"), e._addNewFabric() && (n = !0, i || (i = e)));
                    n && h._emptyReportQueue(i)
                }
                static _emptyReportQueue(e) {
                    const t = e.confID,
                        n = e.peerconnection;
                    for (const i of h.reportsQueue)
                        if (i.type === u.ERROR) {
                            const t = i.data;
                            h._reportError(e, t.type, t.error, t.pc || n)
                        } else if (i.type === u.EVENT) {
                        const e = i.data;
                        h.backend.sendFabricEvent(i.pc || n, e.event, t, e.eventData)
                    } else if (i.type === u.MST_WITH_USERID) {
                        const e = i.data;
                        h.backend.associateMstWithUserID(i.pc || n, e.callStatsId, t, e.ssrc, e.usageLabel, e.containerId)
                    }
                    h.reportsQueue.length = 0
                }
                static _reportError(e, t, n, i) {
                    let r = n;
                    r || (o.warn("No error is passed!"), r = new Error("Unknown error")), h.backendInitialized && e ? h.backend.reportError(i, e.confID, t, r) : h.reportsQueue.push({
                        type: u.ERROR,
                        data: {
                            error: r,
                            pc: i,
                            type: t
                        }
                    })
                }
                static _reportEvent(e, t, n) {
                    const i = e && e.peerconnection,
                        r = e && e.confID;
                    h.backendInitialized && e ? h.backend.sendFabricEvent(i, t, r, n) : h.reportsQueue.push({
                        confID: r,
                        pc: i,
                        type: u.EVENT,
                        data: {
                            event: t,
                            eventData: n
                        }
                    })
                }
                static _traceAndCatchBackendCalls(e) {
                    const t = ["associateMstWithUserID", "sendFabricEvent", "sendUserFeedback"];
                    for (const n of t) {
                        const t = e[n];
                        e[n] = function(...n) {
                            try {
                                return t.apply(e, n)
                            } catch (e) {
                                s.a.callErrorHandler(e)
                            }
                        }
                    }
                    const n = ["associateMstWithUserID", "sendFabricEvent", "sendUserFeedback"];
                    for (const t of n) {
                        const n = e[t];
                        e[t] = function(...i) {
                            o.debug(t, i), n.apply(e, i)
                        }
                    }
                    const r = e.reportError;
                    e.reportError = function(t, n, c, ...d) {
                        c === a.applicationLog ? i.a.isReactNative() || console && console.debug("reportError", t, n, c) : o.debug("reportError", t, n, c, ...d);
                        try {
                            r.call(e, t, n, c, ...d)
                        } catch (e) {
                            c === a.applicationLog ? console && console.error("reportError", e) : s.a.callErrorHandler(e)
                        }
                    }
                }
                static get fabrics() {
                    return l || (l = new Set), l
                }
                static initBackend(e) {
                    if (h.backend) throw new Error("CallStats backend has been initialized already!");
                    try {
                        const t = callstats;
                        let n;
                        if (h.backend = new t, h._traceAndCatchBackendCalls(h.backend), h.userID = {
                                aliasName: e.aliasName,
                                userName: e.userName
                            }, h.callStatsID = e.callStatsID, h.callStatsSecret = e.callStatsSecret, e.applicationName && (n = {
                                applicationVersion: `${e.applicationName} (${i.a.getName()})`
                            }), e.confID) {
                            const t = e.confID.match(/.*\/(.*)\/.*/);
                            n.siteID = t && t[1] || "/"
                        }
                        h.backend.initialize(h.callStatsID, h.callStatsSecret, h.userID, h._initCallback, void 0, n);
                        const r = e.getWiFiStatsMethod;
                        return r && (h.backend.attachWifiStatsHandler(r), r().then(e => {
                            e && o.info("Reported wifi addresses:", JSON.parse(e).addresses)
                        }).catch(() => {})), !0
                    } catch (e) {
                        return s.a.callErrorHandler(e), h.backend = null, o.error(e), !1
                    }
                }
                static isBackendInitialized() {
                    return Boolean(h.backend)
                }
                static sendActiveDeviceListEvent(e, t) {
                    h._reportEvent(t, c.activeDeviceList, e)
                }
                static sendApplicationLog(e, t) {
                    try {
                        h._reportError(t, a.applicationLog, e, t && t.peerconnection)
                    } catch (e) {
                        console && "function" == typeof console.error && console.error("sendApplicationLog failed", e)
                    }
                }
                static sendFeedback(e, t, n) {
                    return new Promise((i, r) => {
                        if (h.backend) h.backend.sendUserFeedback(e, {
                            userID: h.userID,
                            overall: t,
                            comment: n
                        }, (e, t) => {
                            "success" === e ? i(t) : r(t)
                        });
                        else {
                            const e = "Failed to submit feedback to CallStats - no backend";
                            o.error(e), r(e)
                        }
                    })
                }
                static sendGetUserMediaFailed(e, t) {
                    h._reportError(t, a.getUserMedia, e, null)
                }
                static sendMuteEvent(e, t, n) {
                    let i;
                    i = "video" === t ? e ? c.videoPause : c.videoResume : e ? c.audioMute : c.audioUnmute, h._reportEvent(n, i)
                }
                constructor(e, t) {
                    this.confID = t.confID, this.tpc = e, this.peerconnection = e.peerconnection, this.remoteUserID = t.remoteUserID || d, this.hasFabric = !1, h.fabrics.add(this), h.backendInitialized && (this._addNewFabric(), 1 === h.fabrics.size && h._emptyReportQueue(this))
                }
                _addNewFabric() {
                    o.info("addNewFabric", this.remoteUserID);
                    try {
                        const e = {
                                remoteEndpointType: this.tpc.isP2P ? h.backend.endpointType.peer : h.backend.endpointType.server
                            },
                            t = h.backend.addNewFabric(this.peerconnection, this.remoteUserID, h.backend.fabricUsage.multiplex, this.confID, e, h._addNewFabricCallback);
                        this.hasFabric = !0;
                        const n = "success" === t.status;
                        return n || o.error("callstats fabric not initilized", t.message), n
                    } catch (e) {
                        return s.a.callErrorHandler(e), !1
                    }
                }
                associateStreamWithVideoTag(e, t, n, i, r) {
                    if (!h.backend) return;
                    const s = t ? h.userID : n;
                    h.backendInitialized ? h.backend.associateMstWithUserID(this.peerconnection, s, this.confID, e, i, r) : h.reportsQueue.push({
                        type: u.MST_WITH_USERID,
                        pc: this.peerconnection,
                        data: {
                            callStatsId: s,
                            containerId: r,
                            ssrc: e,
                            usageLabel: i
                        }
                    })
                }
                sendDominantSpeakerEvent() {
                    h._reportEvent(this, c.dominantSpeaker)
                }
                sendTerminateEvent() {
                    h.backendInitialized && h.backend.sendFabricEvent(this.peerconnection, h.backend.fabricEvent.fabricTerminated, this.confID), h.fabrics.delete(this)
                }
                sendIceConnectionFailedEvent() {
                    h._reportError(this, a.iceConnectionFailure, null, this.peerconnection)
                }
                sendCreateOfferFailed(e) {
                    h._reportError(this, a.createOffer, e, this.peerconnection)
                }
                sendCreateAnswerFailed(e) {
                    h._reportError(this, a.createAnswer, e, this.peerconnection)
                }
                sendResumeOrHoldEvent(e) {
                    h._reportEvent(this, e ? c.fabricResume : c.fabricHold)
                }
                sendScreenSharingEvent(e, t) {
                    let n;
                    t && (n = {
                        ssrc: t
                    }), h._reportEvent(this, e ? c.screenShareStart : c.screenShareStop, n)
                }
                sendSetLocalDescFailed(e) {
                    h._reportError(this, a.setLocalDescription, e, this.peerconnection)
                }
                sendSetRemoteDescFailed(e) {
                    h._reportError(this, a.setRemoteDescription, e, this.peerconnection)
                }
                sendAddIceCandidateFailed(e) {
                    h._reportError(this, a.addIceCandidate, e, this.peerconnection)
                }
            }
            h.backend = null, h.reportsQueue = [], h.backendInitialized = !1, h.callStatsID = null, h.callStatsSecret = null, h.userID = null
        }).call(this, "modules/statistics/CallStats.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(4),
                r = n(96),
                s = n.n(r);
            const o = Object(i.getLogger)(e);
            let a, c;

            function d() {
                let e;
                try {
                    e = (window || this).localStorage
                } catch (e) {
                    o.error(e)
                }
                return e
            }

            function u() {
                return `${Math.random().toString(16)}000000000`.substr(2, 8)
            }
            t.a = {
                get callStatsUserName() {
                    if (!a) {
                        const e = d();
                        e && (a = e.getItem("callStatsUserName")), a || (a = function() {
                            const e = s.a.generateUsername();
                            return o.log("generated callstats uid", e), e
                        }(), e && e.setItem("callStatsUserName", a))
                    }
                    return a
                },
                get machineId() {
                    if (!c) {
                        const e = d();
                        e && (c = e.getItem("jitsiMeetId")), c || (c = function() {
                            const e = u() + u() + u() + u();
                            return o.log("generated id", e), e
                        }(), e && e.setItem("jitsiMeetId", c))
                    }
                    return c
                },
                get sessionId() {
                    const e = d();
                    return e ? e.getItem("sessionId") : void 0
                },
                set sessionId(e) {
                    const t = d();
                    t && (e ? t.setItem("sessionId", e) : t.removeItem("sessionId"))
                }
            }
        }).call(this, "modules/settings/Settings.js")
    }, function(e, t) {
        const n = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

        function i(e, t) {
            return Math.floor(Math.random() * (t - e + 1)) + e
        }

        function r(e) {
            return e[i(0, e.length - 1)]
        }
        const s = {
            randomHexDigit: () => r("0123456789abcdef"),
            randomHexString(e) {
                let t = "";
                for (; e--;) t += this.randomHexDigit();
                return t
            },
            randomElement: r,
            randomAlphanumStr: function(e) {
                let t = "";
                for (let i = 0; i < e; i += 1) t += r(n);
                return t
            },
            randomInt: i
        };
        e.exports = s
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return s
        }));
        var i = n(24);

        function r(e = class {}) {
            return class extends e {
                constructor(...e) {
                    super(...e), this.connection = null
                }
                init(e) {
                    this.connection = e
                }
            }
        }
        t.b = r();
        const s = r(i.a)
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return C
            })), n.d(t, "b", (function() {
                return R
            })), n.d(t, "c", (function() {
                return A
            }));
            var i = n(4),
                r = n(1),
                s = (n(143), n(35)),
                o = n.n(s),
                a = n(39),
                c = n(25),
                d = n(3),
                u = n(93),
                l = n(99),
                h = n(106),
                p = n(107),
                f = n(108),
                m = n(109),
                g = n(24),
                _ = n(59),
                v = n(11),
                S = n.n(v),
                y = n(0),
                E = n.n(y),
                T = n(40);
            const b = Object(i.getLogger)(e);
            const C = [{
                    urls: "stun:stun.l.google.com:19302"
                }, {
                    urls: "stun:stun1.l.google.com:19302"
                }, {
                    urls: "stun:stun2.l.google.com:19302"
                }],
                R = "type";
            class A extends g.a {
                constructor(e, t) {
                    super(), this.connection = null, this.disconnectInProgress = !1, this.connectionTimes = {}, this.options = e, this.token = t, this.authenticatedUser = !1, Object(h.a)(), Object(m.a)(), this.connection = function({
                        enableWebsocketResume: e,
                        serviceUrl: t = "/http-bind",
                        token: n,
                        websocketKeepAlive: i
                    }) {
                        return n && (t += `${-1===t.indexOf("?")?"?":"&"}token=${n}`), new T.a({
                            enableWebsocketResume: e,
                            serviceUrl: t,
                            websocketKeepAlive: i
                        })
                    }({
                        enableWebsocketResume: e.enableWebsocketResume,
                        serviceUrl: e.serviceUrl || e.bosh,
                        token: t,
                        websocketKeepAlive: e.websocketKeepAlive
                    }), this._initStrophePlugins(), this.caps = new _.b(this.connection, this.options.clientNode), this.initFeaturesList(), $(window).on("beforeunload unload", e => {
                        this.disconnect(e).catch(() => {})
                    })
                }
                initFeaturesList() {
                    this.caps.addFeature("urn:xmpp:jingle:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:1"), this.caps.addFeature("urn:xmpp:jingle:transports:ice-udp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:dtls:0"), this.caps.addFeature("urn:xmpp:jingle:transports:dtls-sctp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:audio"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:video"), !this.options.disableRtx && d.a.supportsRtx() && this.caps.addFeature("urn:ietf:rfc:4588"), this.caps.addFeature("urn:ietf:rfc:5761"), this.caps.addFeature("urn:ietf:rfc:5888"), d.a.isChrome() && !0 === this.options.enableLipSync && (b.info("Lip-sync enabled !"), this.caps.addFeature("http://jitsi.org/meet/lipsync")), this.connection.rayo && this.caps.addFeature("urn:xmpp:rayo:client:1"), d.a.supportsInsertableStreams() && this.caps.addFeature("https://jitsi.org/meet/e2ee")
                }
                isPingSupported() {
                    return !1 !== this._pingSupported
                }
                getConnection() {
                    return this.connection
                }
                connectionHandler(e = {}, t, n) {
                    const i = window.performance.now(),
                        s = r.Strophe.getStatusString(t).toLowerCase();
                    if (this.connectionTimes[s] = i, b.log(`(TIME) Strophe ${s}${n?`[${n}]`:""}:\t`, i), this.eventEmitter.emit(E.a.CONNECTION_STATUS_CHANGED, e, t, n), t === r.Strophe.Status.CONNECTED || t === r.Strophe.Status.ATTACHED) {
                        (this.options.useStunTurn || this.options.p2p && this.options.p2p.useStunTurn) && this.connection.jingle.getStunAndTurnCredentials(), b.info(`My Jabber ID: ${this.connection.jid}`), this._resetState();
                        const t = this.connection.domain;
                        this.caps.getFeaturesAndIdentities(t).then(({
                            features: e,
                            identities: n
                        }) => {
                            e.has(r.Strophe.NS.PING) ? (this._pingSupported = !0, this.connection.ping.startInterval(t)) : b.warn(`Ping NOT supported by ${t}`), n.forEach(e => {
                                "speakerstats" === e.type && (this.speakerStatsComponentAddress = e.name), "conference_duration" === e.type && (this.conferenceDurationComponentAddress = e.name)
                            }), (this.speakerStatsComponentAddress || this.conferenceDurationComponentAddress) && this.connection.addHandler(this._onPrivateMessage.bind(this), null, "message", null, null)
                        }).catch(e => {
                            const t = "Feature discovery error";
                            S.a.callErrorHandler(new Error(`${t}: ${e}`)), b.error(t, e)
                        }), e.password && (this.authenticatedUser = !0), this.connection && this.connection.connected && r.Strophe.getResourceFromJid(this.connection.jid) && this.eventEmitter.emit(c.CONNECTION_ESTABLISHED, r.Strophe.getResourceFromJid(this.connection.jid))
                    } else if (t === r.Strophe.Status.CONNFAIL) "x-strophe-bad-non-anon-jid" === n ? this.anonymousConnectionFailed = !0 : this.connectionFailed = !0, this.lastErrorMsg = n, "giving-up" === n && this.eventEmitter.emit(c.CONNECTION_FAILED, a.OTHER_ERROR, n);
                    else if (t === r.Strophe.Status.ERROR) this.lastErrorMsg = n;
                    else if (t === r.Strophe.Status.DISCONNECTED) {
                        this.connection.ping.stopInterval();
                        const e = Boolean(this.disconnectInProgress),
                            t = n || this.lastErrorMsg;
                        if (this.anonymousConnectionFailed) this.eventEmitter.emit(c.CONNECTION_FAILED, a.PASSWORD_REQUIRED);
                        else if (this.connectionFailed) this.eventEmitter.emit(c.CONNECTION_FAILED, a.OTHER_ERROR, t, void 0, this._getConnectionFailedReasonDetails());
                        else if (e) this.eventEmitter.emit(c.CONNECTION_DISCONNECTED, t);
                        else {
                            b.error("XMPP connection dropped!");
                            const e = r.Strophe.getLastErrorStatus();
                            e >= 500 && e < 600 ? this.eventEmitter.emit(c.CONNECTION_FAILED, a.SERVER_ERROR, t || "server-error", void 0, this._getConnectionFailedReasonDetails()) : this.eventEmitter.emit(c.CONNECTION_FAILED, a.CONNECTION_DROPPED_ERROR, t || "connection-dropped-error", void 0, this._getConnectionFailedReasonDetails())
                        }
                    } else t === r.Strophe.Status.AUTHFAIL && this.eventEmitter.emit(c.CONNECTION_FAILED, a.PASSWORD_REQUIRED, n, e)
                }
                _connect(e, t) {
                    this._resetState(), this.connection.connect(e, t, this.connectionHandler.bind(this, {
                        jid: e,
                        password: t
                    }))
                }
                attach(e) {
                    this._resetState();
                    const t = this.connectionTimes.attaching = window.performance.now();
                    b.log("(TIME) Strophe Attaching:\t", t), this.connection.attach(e.jid, e.sid, parseInt(e.rid, 10) + 1, this.connectionHandler.bind(this, {
                        jid: e.jid,
                        password: e.password
                    }))
                }
                _resetState() {
                    this.anonymousConnectionFailed = !1, this.connectionFailed = !1, this.lastErrorMsg = void 0, this.disconnectInProgress = void 0
                }
                connect(e, t) {
                    if (!e) {
                        const {
                            anonymousdomain: t,
                            domain: n
                        } = this.options.hosts;
                        let i = t || n;
                        const {
                            location: r
                        } = window;
                        if (t) {
                            const e = r && r.search;
                            (e && -1 !== e.indexOf("login=true") || this.token) && (i = n)
                        }
                        e = i || r && r.hostname
                    }
                    return this._connect(e, t)
                }
                createRoom(e, t, n) {
                    let i = `${e}@${this.options.hosts.muc}/`;
                    const r = n ? n(this.connection.jid, this.authenticatedUser) : o.a.randomHexString(8).toLowerCase();
                    return b.info(`JID ${this.connection.jid} using MUC nickname ${r}`), i += r, this.connection.emuc.createRoom(i, null, t)
                }
                getJid() {
                    return this.connection.jid
                }
                getJingleLog() {
                    const e = this.connection.jingle;
                    return e ? e.getLog() : {}
                }
                getXmppLog() {
                    return (this.connection.logger || {}).log || null
                }
                dial(...e) {
                    this.connection.rayo.dial(...e)
                }
                ping(e) {
                    return new Promise((t, n) => {
                        this.isPingSupported() ? this.connection.ping.ping(this.connection.domain, t, n, e) : n("PING operation is not supported by the server")
                    })
                }
                getSessions() {
                    return this.connection.jingle.sessions
                }
                disconnect(e) {
                    return this.disconnectInProgress ? this.disconnectInProgress : this.connection ? (this.disconnectInProgress = new Promise(e => {
                        const t = (n, i) => {
                            i === r.Strophe.Status.DISCONNECTED && (e(), this.eventEmitter.removeListener(E.a.CONNECTION_STATUS_CHANGED, t))
                        };
                        this.eventEmitter.on(E.a.CONNECTION_STATUS_CHANGED, t)
                    }), this._cleanupXmppConnection(e), this.disconnectInProgress) : Promise.resolve()
                }
                _cleanupXmppConnection(e) {
                    if (!this.connection.isUsingWebSocket && this.connection.flush(), !this.connection.isUsingWebSocket && null != e) {
                        const t = e.type;
                        if (("beforeunload" === t || "unload" === t) && (this.connection.options.sync = !0, this.connection.sendUnavailableBeacon())) return
                    }
                    this.connection.disconnect(), !0 !== this.connection.options.sync && this.connection.flush()
                }
                _initStrophePlugins() {
                    const e = {
                            jvb: {
                                iceServers: []
                            },
                            p2p: {
                                iceServers: []
                            }
                        },
                        t = this.options.p2p && this.options.p2p.stunServers || C;
                    Array.isArray(t) && (b.info("P2P STUN servers: ", t), e.p2p.iceServers = t), this.options.p2p && this.options.p2p.iceTransportPolicy && (b.info("P2P ICE transport policy: ", this.options.p2p.iceTransportPolicy), e.p2p.iceTransportPolicy = this.options.p2p.iceTransportPolicy), this.connection.addConnectionPlugin("emuc", new u.a(this)), this.connection.addConnectionPlugin("jingle", new l.a(this, this.eventEmitter, e)), this.connection.addConnectionPlugin("ping", new p.a(this)), this.connection.addConnectionPlugin("rayo", new f.a)
                }
                _getConnectionFailedReasonDetails() {
                    const e = {};
                    if (this.options.deploymentInfo && this.options.deploymentInfo.shard && this.connection.lastResponseHeaders) {
                        const t = this.connection.lastResponseHeaders.trim().split(/[\r\n]+/),
                            n = {};
                        t.forEach(e => {
                            const t = e.split(": "),
                                i = t.shift(),
                                r = t.join(": ");
                            n[i] = r
                        }), e.shard_changed = this.options.deploymentInfo.shard !== n["x-jitsi-shard"]
                    }
                    return e.suspend_time = this.connection.ping.getPingSuspendTime(), e.time_since_last_success = this.connection.getTimeSinceLastSuccess(), e
                }
                sendDominantSpeakerEvent(e) {
                    if (!this.speakerStatsComponentAddress || !e) return;
                    const t = Object(r.$msg)({
                        to: this.speakerStatsComponentAddress
                    });
                    t.c("speakerstats", {
                        xmlns: "http://jitsi.org/jitmeet",
                        room: e
                    }).up(), this.connection.send(t)
                }
                tryParseJSONAndVerify(e) {
                    try {
                        const t = JSON.parse(e);
                        if (t && "object" == typeof t) {
                            const e = t[R];
                            if (void 0 !== e) return t;
                            b.debug("parsing valid json but does not have correct structure", "topic: ", e)
                        }
                    } catch (e) {
                        return !1
                    }
                    return !1
                }
                _onPrivateMessage(e) {
                    const t = e.getAttribute("from");
                    if (t !== this.speakerStatsComponentAddress && t !== this.conferenceDurationComponentAddress) return;
                    const n = $(e).find(">json-message").text(),
                        i = this.tryParseJSONAndVerify(n);
                    return i && "speakerstats" === i[R] && i.users && this.eventEmitter.emit(E.a.SPEAKER_STATS_RECEIVED, i.users), i && "conference_duration" === i[R] && i.created_timestamp && this.eventEmitter.emit(E.a.CONFERENCE_TIMESTAMP_RECEIVED, i.created_timestamp), !0
                }
            }
        }).call(this, "modules/xmpp/xmpp.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        })), n.d(t, "b", (function() {
            return r
        }));
        const i = "signaling.peerMuted",
            r = "signaling.peerVideoType"
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "CONNECTION_DROPPED_ERROR", (function() {
            return i
        })), n.d(t, "OTHER_ERROR", (function() {
            return r
        })), n.d(t, "PASSWORD_REQUIRED", (function() {
            return s
        })), n.d(t, "SERVER_ERROR", (function() {
            return o
        }));
        const i = "connection.droppedError",
            r = "connection.otherError",
            s = "connection.passwordRequired",
            o = "connection.serverError"
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var i = n(4),
                r = n(1),
                s = (n(144), n(24)),
                o = n(97),
                a = n(98);
            const c = Object(i.getLogger)(e);
            class d extends s.a {
                static get Events() {
                    return {
                        CONN_STATUS_CHANGED: "CONN_STATUS_CHANGED"
                    }
                }
                static get Status() {
                    return r.Strophe.Status
                }
                constructor({
                    enableWebsocketResume: e,
                    websocketKeepAlive: t,
                    serviceUrl: n
                }) {
                    super(), this._options = {
                        enableWebsocketResume: void 0 === e || e,
                        websocketKeepAlive: void 0 === t ? 24e4 : Number(t) // BAO
                    }, this.$msg = r.$msg, this.$pres = r.$pres, this.$iq = r.$iq, this.Strophe = r.Strophe, this._resumeRetryN = 0, this._stropheConn = new r.Strophe.Connection(n), this._usesWebsocket = n.startsWith("ws:") || n.startsWith("wss:"), this._stropheConn.maxRetries = 3, this._lastSuccessTracker = new a.a, this._lastSuccessTracker.startTracking(this._stropheConn)
                }
                get connected() {
                    return this._status === r.Strophe.Status.CONNECTED || this._status === r.Strophe.Status.ATTACHED
                }
                get disco() {
                    return this._stropheConn.disco
                }
                get disconnecting() {
                    return !0 === this._stropheConn.disconnecting
                }
                get domain() {
                    return this._stropheConn.domain
                }
                get isUsingWebSocket() {
                    return this._usesWebsocket
                }
                get jid() {
                    return this._stropheConn.jid
                }
                get lastResponseHeaders() {
                    return this._stropheConn._proto && this._stropheConn._proto.lastResponseHeaders
                }
                get logger() {
                    return this._stropheConn.logger
                }
                get options() {
                    return this._stropheConn.options
                }
                get service() {
                    return this._stropheConn.service
                }
                get status() {
                    return this._status
                }
                addConnectionPlugin(e, t) {
                    this[e] = t, t.init(this)
                }
                addHandler(...e) {
                    this._stropheConn.addHandler(...e)
                }
                attach(e, t, n, i, ...r) {
                    this._stropheConn.attach(e, t, n, this._stropheConnectionCb.bind(this, i), ...r)
                }
                connect(e, t, n, ...i) {
                    this._stropheConn.connect(e, t, this._stropheConnectionCb.bind(this, n), ...i)
                }
                _stropheConnectionCb(e, t, ...n) {
                    this._status = t;
                    let i = !1;
                    t === r.Strophe.Status.CONNECTED ? (this._maybeEnableStreamResume(), this._maybeStartWSKeepAlive(), this._resumeRetryN = 0) : t === r.Strophe.Status.DISCONNECTED && ((i = this._tryResumingConnection()) || clearTimeout(this._wsKeepAlive)), i || (e(t, ...n), this.eventEmitter.emit(d.Events.CONN_STATUS_CHANGED, t))
                }
                closeWebsocket() {
                    this._stropheConn._proto && this._stropheConn._proto.socket && this._stropheConn._proto.socket.close()
                }
                disconnect(...e) {
                    clearTimeout(this._resumeTimeout), clearTimeout(this._wsKeepAlive), this._stropheConn.disconnect(...e)
                }
                flush(...e) {
                    this._stropheConn.flush(...e)
                }
                getTimeSinceLastSuccess() {
                    return this._lastSuccessTracker.getTimeSinceLastSuccess()
                }
                _maybeEnableStreamResume() {
                    if (!this._options.enableWebsocketResume) return;
                    const {
                        streamManagement: e
                    } = this._stropheConn;
                    this.isUsingWebSocket ? e ? e.isSupported() ? e.getResumeToken() || (c.info("Enabling XEP-0198 stream management"), e.enable(!0)) : c.warn("Stream resume enabled, but XEP-0198 is not supported by the server") : c.warn("Stream resume enabled, but Strophe streamManagement plugin is not installed") : c.warn("Stream resume enabled, but WebSockets are not enabled")
                }
                _maybeStartWSKeepAlive() {
                    const {
                        websocketKeepAlive: e
                    } = this._options;
                    if (this._usesWebsocket && e > 0) {
                        this._wsKeepAlive || c.info(`WebSocket keep alive interval: ${e}ms`), clearTimeout(this._wsKeepAlive);
                        const t = .2 * e + .8 * Math.random() * e;
                        c.debug(`Scheduling next WebSocket keep-alive in ${t}ms`), this._wsKeepAlive = setTimeout(() => {
                            const e = this.service.replace("wss://", "https://").replace("ws://", "http://");
                            fetch(e).catch(t => {
                                c.error(`Websocket Keep alive failed for url: ${e}`, {
                                    error: t
                                })
                            }).then(() => this._maybeStartWSKeepAlive())
                        }, t)
                    }
                }
                send(e) {
                    if (!this.connected) throw new Error("Not connected");
                    this._stropheConn.send(e)
                }
                sendIQ(e, t, n, i) {
                    if (this.connected) return this._stropheConn.sendIQ(e, t, n, i);
                    n("Not connected")
                }
                sendPresence(e, t, n, i) {
                    this.connected ? this._stropheConn.sendPresence(e, t, n, i) : n("Not connected")
                }
                sendUnavailableBeacon() {
                    if (!navigator.sendBeacon || this._stropheConn.disconnecting || !this._stropheConn.connected) return !1;
                    this._stropheConn._changeConnectStatus(r.Strophe.Status.DISCONNECTING), this._stropheConn.disconnecting = !0;
                    const e = this._stropheConn._proto._buildBody().attrs({
                            type: "terminate"
                        }),
                        t = Object(r.$pres)({
                            xmlns: r.Strophe.NS.CLIENT,
                            type: "unavailable"
                        });
                    e.cnode(t.tree());
                    const n = navigator.sendBeacon(`https:${this.service}`, r.Strophe.serialize(e.tree()));
                    return c.info(`Successfully send unavailable beacon ${n}`), this._stropheConn._proto._abortAllRequests(), this._stropheConn._doDisconnect(), !0
                }
                _tryResumingConnection() {
                    const {
                        streamManagement: e
                    } = this._stropheConn, t = e && e.getResumeToken();
                    if (t) {
                        clearTimeout(this._resumeTimeout), this._resumeRetryN = Math.min(3, this._resumeRetryN + 1);
                        const n = Object(o.a)(this._resumeRetryN, 1500, 3);
                        return c.info(`Will try to resume the XMPP connection in ${n}ms`), this._resumeTimeout = setTimeout(() => {
                            c.info("Trying to resume the XMPP connection");
                            const n = new URL(this._stropheConn.service);
                            let {
                                search: i
                            } = n;
                            i += -1 === i.indexOf("?") ? `?previd=${t}` : `&previd=${t}`, n.search = i, this._stropheConn.service = n.toString(), e.resume()
                        }, n), !0
                    }
                    return !1
                }
            }
        }).call(this, "modules/xmpp/XmppConnection.js")
    }, function(e, t) {
        e.exports = {
            ENVIRONMENT: "environment",
            USER: "user"
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(16),
                r = n(13),
                s = n(3);

            function o(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const a = n(4).getLogger(e),
                c = n(11);
            let d = !1,
                u = !1,
                l = null;
            const h = {
                intChromeExtPromise: null,
                obtainStream: null,
                init(e = {
                    desktopSharingChromeDisabled: !1,
                    desktopSharingChromeExtId: null,
                    desktopSharingFirefoxDisabled: !1
                }, t) {
                    this.options = e, l = t, this.obtainStream = this._createObtainStreamMethod(e), this.obtainStream || a.info("Desktop sharing disabled")
                },
                _createObtainStreamMethod(e) {
                    return s.a.isNWJS() ? (e, t, n) => {
                        window.JitsiMeetNW.obtainDesktopStream(t, (e, t) => {
                            let s;
                            s = e && "InvalidStateError" === e.name ? new i.a(r.CHROME_EXTENSION_USER_CANCELED) : new i.a(e, t, ["desktop"]), "function" == typeof n && n(s)
                        })
                    } : s.a.isElectron() ? this.obtainScreenOnElectron : s.a.isChrome() || s.a.isOpera() ? s.a.supportsGetDisplayMedia() && !e.desktopSharingChromeDisabled ? this.obtainScreenFromGetDisplayMedia : e.desktopSharingChromeDisabled || !e.desktopSharingChromeExtId ? null : (a.info("Using Chrome extension for desktop sharing"), this.intChromeExtPromise = function(e) {
                        return function(e) {
                            0 === $("link[rel=chrome-webstore-item]").length && $("head").append('<link rel="chrome-webstore-item">');
                            $("link[rel=chrome-webstore-item]").attr("href", p(e))
                        }(e), new Promise(t => {
                            f((e, n) => {
                                d = e, u = n, a.info(`Chrome extension installed: ${d} updateRequired: ${u}`), t()
                            }, e)
                        })
                    }(e).then(() => {
                        this.intChromeExtPromise = null
                    }), this.obtainScreenFromExtension) : s.a.isFirefox() ? e.desktopSharingFirefoxDisabled ? null : s.a.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMedia : this.obtainScreenOnFirefox : s.a.isSafari() && s.a.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMedia : (a.log("Screen sharing not supported by the current browser: ", s.a.getName()), null)
                },
                isSupported() {
                    return null !== this.obtainStream
                },
                obtainScreenOnFirefox(e, t, n) {
                    ! function(e, t, n) {
                        l(["screen"], e).then(e => t({
                            stream: e
                        }), n)
                    }(e.gumOptions, t, n)
                },
                obtainScreenOnElectron(e = {}, t, n) {
                    if (window.JitsiMeetScreenObtainer && window.JitsiMeetScreenObtainer.openDesktopPicker) {
                        const {
                            desktopSharingSources: s,
                            gumOptions: o
                        } = e;
                        window.JitsiMeetScreenObtainer.openDesktopPicker({
                            desktopSharingSources: s || this.options.desktopSharingChromeSources
                        }, (e, i, r = !1) => m({
                            response: {
                                streamId: e,
                                streamType: i,
                                screenShareAudio: r
                            },
                            gumOptions: o
                        }, t, n), e => n(new i.a(r.ELECTRON_DESKTOP_PICKER_ERROR, e)))
                    } else n(new i.a(r.ELECTRON_DESKTOP_PICKER_NOT_FOUND))
                },
                obtainScreenFromExtension(e, t, n) {
                    if (null !== this.intChromeExtPromise) return void this.intChromeExtPromise.then(() => {
                        this.obtainScreenFromExtension(e, t, n)
                    });
                    const {
                        desktopSharingChromeExtId: s,
                        desktopSharingChromeSources: o
                    } = this.options, {
                        gumOptions: c
                    } = e, l = {
                        desktopSharingChromeExtId: s,
                        desktopSharingChromeSources: e.desktopSharingSources || o,
                        gumOptions: c
                    };
                    d ? function(e, t, n) {
                        const {
                            desktopSharingChromeSources: s,
                            desktopSharingChromeExtId: o,
                            gumOptions: c
                        } = e;
                        chrome.runtime.sendMessage(o, {
                            getStream: !0,
                            sources: s
                        }, e => {
                            if (e) a.log("Response from extension: ", e), m({
                                response: e,
                                gumOptions: c
                            }, t, n);
                            else {
                                const e = chrome.runtime.lastError;
                                n(e instanceof Error ? e : new i.a(r.CHROME_EXTENSION_GENERIC_ERROR, e))
                            }
                        })
                    }(l, t, n) : (u && alert("Jitsi Desktop Streamer requires update. Changes will take effect after next Chrome restart."), this.handleExternalInstall(e, t, n))
                },
                handleExternalInstall(e, t, n, i) {
                    const r = p(this.options);
                    e.listener("waitingForExtension", r), this.checkForChromeExtensionOnInterval(e, t, n, i)
                },
                checkForChromeExtensionOnInterval(e, t, n) {
                    !1 !== e.checkAgain() ? function(e, t, n) {
                        if (0 === n) return Promise.reject();
                        return new Promise((i, r) => {
                            let s = n;
                            const o = window.setInterval(() => {
                                f(e => {
                                    e ? (window.clearInterval(o), i()) : 0 === --s && (r(), window.clearInterval(o))
                                }, e)
                            }, t)
                        })
                    }(this.options, e.interval, 1).then(() => {
                        d = !0, e.listener("extensionFound"), this.obtainScreenFromExtension(e, t, n)
                    }).catch(() => {
                        this.checkForChromeExtensionOnInterval(e, t, n)
                    }) : n(new i.a(r.CHROME_EXTENSION_INSTALLATION_ERROR))
                },
                obtainScreenFromGetDisplayMedia(e, t, n) {
                    let s;
                    a.info("Using getDisplayMedia for screen sharing"), (s = navigator.getDisplayMedia ? navigator.getDisplayMedia.bind(navigator) : navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices))({
                        video: !0,
                        audio: !0
                    }).then(n => {
                        let i;
                        if (n && n.getTracks() && n.getTracks().length > 0) {
                            const t = n.getVideoTracks()[0];
                            t && (i = t.applyConstraints(e.trackOptions))
                        } else i = Promise.resolve();
                        i.then(() => t({
                            stream: n,
                            sourceId: n.id
                        }))
                    }).catch(() => n(new i.a(r.CHROME_EXTENSION_USER_CANCELED)))
                }
            };

            function p(e) {
                return `https://chrome.google.com/webstore/detail/${e.desktopSharingChromeExtId}`
            }

            function f(e, t) {
                "undefined" != typeof chrome && chrome && chrome.runtime ? chrome.runtime.sendMessage(t.desktopSharingChromeExtId, {
                    getVersion: !0
                }, n => {
                    if (!n || !n.version) return a.warn("Extension not installed?: ", chrome.runtime.lastError), void e(!1, !1);
                    const i = n.version;
                    a.log(`Extension version is: ${i}`);
                    const r = function(e, t) {
                        try {
                            const n = e.split("."),
                                i = t.split("."),
                                r = Math.max(n.length, i.length);
                            for (let e = 0; e < r; e++) {
                                let t = 0,
                                    r = 0;
                                if (e < n.length && (t = parseInt(n[e], 10)), e < i.length && (r = parseInt(i[e], 10)), isNaN(t) || isNaN(r)) return !0;
                                if (t !== r) return t > r
                            }
                            return !1
                        } catch (e) {
                            return c.callErrorHandler(e), a.error("Failed to parse extension version", e), !0
                        }
                    }(t.desktopSharingChromeMinExtVersion, i);
                    e(!r, r)
                }) : e(!1, !1)
            }

            function m(e = {
                response: {},
                gumOptions: {}
            }, t, n) {
                const {
                    streamId: s,
                    streamType: a,
                    screenShareAudio: c,
                    error: d
                } = e.response || {};
                if (s) {
                    const i = function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? arguments[t] : {},
                                i = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), i.forEach((function(t) {
                                o(e, t, n[t])
                            }))
                        }
                        return e
                    }({
                        desktopStream: s,
                        screenShareAudio: c
                    }, e.gumOptions);
                    l(["desktop"], i).then(e => t({
                        stream: e,
                        sourceId: s,
                        sourceType: a
                    }), n)
                } else {
                    if ("" === s) return void n(new i.a(r.CHROME_EXTENSION_USER_CANCELED));
                    n(new i.a(r.CHROME_EXTENSION_GENERIC_ERROR, d))
                }
            }
            t.a = h
        }).call(this, "modules/RTC/ScreenObtainer.js")
    }, function(e, t) {
        var n;
        n = function() {
            return this
        }();
        try {
            n = n || new Function("return this")()
        } catch (e) {
            "object" == typeof window && (n = window)
        }
        e.exports = n
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return v
            })), n.d(t, "b", (function() {
                return S
            }));
            var i = n(4),
                r = n(2),
                s = n(15),
                o = n(9),
                a = n(3),
                c = n(8),
                d = n.n(c),
                u = n(5),
                l = n(7);

            function h(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {},
                        i = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), i.forEach((function(t) {
                        p(e, t, n[t])
                    }))
                }
                return e
            }

            function p(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const f = Object(i.getLogger)(e),
                m = 500,
                g = 1e4,
                _ = 1e4,
                v = {
                    ACTIVE: "active",
                    INACTIVE: "inactive",
                    INTERRUPTED: "interrupted",
                    RESTORING: "restoring"
                };
            class S {
                static _getNewStateForJvbMode(e, t, n, i, r) {
                    return e ? i ? v.ACTIVE : a.a.supportsVideoMuteOnConnInterrupted() ? r ? t ? n ? v.INTERRUPTED : v.RESTORING : v.INACTIVE : v.ACTIVE : t ? v.ACTIVE : v.INACTIVE : v.INTERRUPTED
                }
                static _getNewStateForP2PMode(e, t) {
                    return a.a.supportsVideoMuteOnConnInterrupted() ? e || !t ? v.ACTIVE : v.INTERRUPTED : v.ACTIVE
                }
                constructor(e, t, n) {
                    this.rtc = e, this.conference = t, this.trackTimers = {}, this.connStatusFromJvb = {}, this.outOfLastNTimeout = "number" == typeof n.outOfLastNTimeout ? n.outOfLastNTimeout : m, this.rtcMuteTimeout = "number" == typeof n.rtcMuteTimeout ? n.rtcMuteTimeout : g, this.rtcMutedTimestamp = {}, f.info(`RtcMuteTimeout set to: ${this.rtcMuteTimeout}`), this.enteredLastNTimestamp = new Map, this.restoringTimers = new Map, this.connectionStatusMap = new Map
                }
                _getVideoFrozenTimeout(e) {
                    return this.rtc.isInLastN(e) ? this.rtcMuteTimeout : this.outOfLastNTimeout
                }
                init() {
                    this._onEndpointConnStatusChanged = this.onEndpointConnStatusChanged.bind(this), this.rtc.addListener(d.a.ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged), this._onP2PStatus = this.refreshConnectionStatusForAll.bind(this), this.conference.on(r.P2P_STATUS, this._onP2PStatus), this._onUserLeft = this.onUserLeft.bind(this), this.conference.on(r.USER_LEFT, this._onUserLeft), a.a.supportsVideoMuteOnConnInterrupted() && (this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this), this.rtc.addListener(d.a.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this), this.rtc.addListener(d.a.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this._onRemoteTrackAdded = this.onRemoteTrackAdded.bind(this), this.conference.on(r.TRACK_ADDED, this._onRemoteTrackAdded), this._onRemoteTrackRemoved = this.onRemoteTrackRemoved.bind(this), this.conference.on(r.TRACK_REMOVED, this._onRemoteTrackRemoved), this._onSignallingMuteChanged = this.onSignallingMuteChanged.bind(this), this._onTrackVideoTypeChanged = this.onTrackVideoTypeChanged.bind(this)), this._onLastNChanged = this._onLastNChanged.bind(this), this.conference.on(r.LAST_N_ENDPOINTS_CHANGED, this._onLastNChanged), this._onLastNValueChanged = this.refreshConnectionStatusForAll.bind(this), this.rtc.on(d.a.LASTN_VALUE_CHANGED, this._onLastNValueChanged)
                }
                dispose() {
                    this.rtc.removeListener(d.a.ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged), a.a.supportsVideoMuteOnConnInterrupted() && (this.rtc.removeListener(d.a.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this.rtc.removeListener(d.a.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this.conference.off(r.TRACK_ADDED, this._onRemoteTrackAdded), this.conference.off(r.TRACK_REMOVED, this._onRemoteTrackRemoved)), this.conference.off(r.LAST_N_ENDPOINTS_CHANGED, this._onLastNChanged), this.rtc.removeListener(d.a.LASTN_VALUE_CHANGED, this._onLastNValueChanged), this.conference.off(r.P2P_STATUS, this._onP2PStatus), this.conference.off(r.USER_LEFT, this._onUserLeft);
                    const e = Object.keys(this.trackTimers);
                    for (const t of e) this.clearTimeout(t), this.clearRtcMutedTimestamp(t);
                    for (const e in this.connectionStatusMap) this.connectionStatusMap.hasOwnProperty(e) && this.onUserLeft(e);
                    this.connStatusFromJvb = {}
                }
                onEndpointConnStatusChanged(e, t) {
                    f.debug(`Detector RTCEvents.ENDPOINT_CONN_STATUS_CHANGED(${Date.now()}): ${e}: ${t}`), e !== this.conference.myUserId() && (this.connStatusFromJvb[e] = t, this.figureOutConnectionStatus(e))
                }
                _changeConnectionStatus(e, t) {
                    if (e.getConnectionStatus() !== t) {
                        const n = e.getId();
                        e._setConnectionStatus(t), f.debug(`Emit endpoint conn status(${Date.now()}) ${n}: ${t}`), u.a.sendLog(JSON.stringify({
                            id: "peer.conn.status",
                            participant: n,
                            status: t
                        })), this.conference.eventEmitter.emit(r.PARTICIPANT_CONN_STATUS_CHANGED, n, t)
                    }
                }
                clearTimeout(e) {
                    this.trackTimers[e] && (window.clearTimeout(this.trackTimers[e]), this.trackTimers[e] = null)
                }
                clearRtcMutedTimestamp(e) {
                    this.rtcMutedTimestamp[e] = null
                }
                onRemoteTrackAdded(e) {
                    e.isLocal() || e.getType() !== o.c || (f.debug(`Detector on remote track added for: ${e.getParticipantId()}`), e.on(s.TRACK_MUTE_CHANGED, this._onSignallingMuteChanged), e.on(s.TRACK_VIDEOTYPE_CHANGED, t => this._onTrackVideoTypeChanged(e, t)))
                }
                onRemoteTrackRemoved(e) {
                    if (!e.isLocal() && e.getType() === o.c) {
                        const t = e.getParticipantId();
                        f.debug(`Detector on remote track removed: ${t}`), e.off(s.TRACK_MUTE_CHANGED, this._onSignallingMuteChanged), this.clearTimeout(t), this.clearRtcMutedTimestamp(t), this.figureOutConnectionStatus(t)
                    }
                }
                isVideoTrackFrozen(e) {
                    if (!a.a.supportsVideoMuteOnConnInterrupted()) return !1;
                    const t = e.getId(),
                        n = e.hasAnyVideoTrackWebRTCMuted(),
                        i = this.rtcMutedTimestamp[t],
                        r = this._getVideoFrozenTimeout(t);
                    return n && "number" == typeof i && Date.now() - i >= r
                }
                refreshConnectionStatusForAll() {
                    const e = this.conference.getParticipants();
                    for (const t of e) this.figureOutConnectionStatus(t.getId())
                }
                figureOutConnectionStatus(e) {
                    const t = this.conference.getParticipantById(e);
                    if (!t) return void f.debug(`figure out conn status - no participant for: ${e}`);
                    const n = this.conference.isP2PActive(),
                        i = this._isRestoringTimedout(e),
                        r = 0 === this.rtc.getLastN(),
                        s = t.isVideoMuted() || r,
                        a = this.isVideoTrackFrozen(t),
                        c = this.rtc.isInLastN(e);
                    let d = this.connStatusFromJvb[e];
                    "boolean" != typeof d && (f.debug("Assuming connection active by JVB - no notification"), d = !0);
                    const u = n ? S._getNewStateForP2PMode(s, a) : S._getNewStateForJvbMode(d, c, i, s, a);
                    u !== v.RESTORING && this._clearRestoringTimer(e), f.debug(`Figure out conn status for ${e}, is video muted: ${s} is active(jvb): ${d} video track frozen: ${a} p2p mode: ${n} is in last N: ${c} currentStatus => newStatus: ${t.getConnectionStatus()} => ${u}`);
                    const l = this.connectionStatusMap[e] || {};
                    if (!("p2p" in l && "connectionStatus" in l && l.p2p === n && l.connectionStatus === u)) {
                        const i = Date.now();
                        if (this.maybeSendParticipantConnectionStatusEvent(e, i), this.connectionStatusMap[e] = h({}, l, {
                                connectionStatus: u,
                                p2p: n,
                                startedMs: i
                            }), !("videoType" in this.connectionStatusMap[e])) {
                            const n = t.getTracksByMediaType(o.c);
                            Array.isArray(n) && 0 !== n.length && (this.connectionStatusMap[e].videoType = n[0].videoType)
                        }
                    }
                    this._changeConnectionStatus(t, u)
                }
                maybeSendParticipantConnectionStatusEvent(e, t) {
                    const n = this.connectionStatusMap[e];
                    n && "startedMs" in n && "videoType" in n && "connectionStatus" in n && "p2p" in n && (n.value = t - n.startedMs, u.a.sendAnalytics(Object(l.J)(n)))
                }
                _onLastNChanged(e = [], t = []) {
                    const n = Date.now();
                    f.debug("leaving/entering lastN", e, t, n);
                    for (const t of e) this.enteredLastNTimestamp.delete(t), this._clearRestoringTimer(t), this.figureOutConnectionStatus(t);
                    for (const e of t) this.enteredLastNTimestamp.set(e, n), this.figureOutConnectionStatus(e)
                }
                _clearRestoringTimer(e) {
                    const t = this.restoringTimers.get(e);
                    t && (clearTimeout(t), this.restoringTimers.delete(e))
                }
                _isRestoringTimedout(e) {
                    const t = this.enteredLastNTimestamp.get(e);
                    return !!(t && Date.now() - t >= _) || (this.restoringTimers.get(e) || this.restoringTimers.set(e, setTimeout(() => this.figureOutConnectionStatus(e), _)), !1)
                }
                onUserLeft(e) {
                    this.maybeSendParticipantConnectionStatusEvent(e, Date.now()), delete this.connectionStatusMap[e]
                }
                onTrackRtcMuted(e) {
                    const t = e.getParticipantId(),
                        n = this.conference.getParticipantById(t);
                    if (f.debug(`Detector track RTC muted: ${t}`, Date.now()), n) {
                        if (this.rtcMutedTimestamp[t] = Date.now(), !n.isVideoMuted()) {
                            this.clearTimeout(t);
                            const e = this._getVideoFrozenTimeout(t);
                            this.trackTimers[t] = window.setTimeout(() => {
                                f.debug(`Set RTC mute timeout for: ${t}                     of ${e} ms`), this.clearTimeout(t), this.figureOutConnectionStatus(t)
                            }, e)
                        }
                    } else f.error(`No participant for id: ${t}`)
                }
                onTrackRtcUnmuted(e) {
                    const t = e.getParticipantId();
                    f.debug(`Detector track RTC unmuted: ${t}`, Date.now()), this.clearTimeout(t), this.clearRtcMutedTimestamp(t), this.figureOutConnectionStatus(t)
                }
                onSignallingMuteChanged(e) {
                    const t = e.getParticipantId();
                    f.debug(`Detector on track signalling mute changed: ${t}`, e.isMuted()), this.figureOutConnectionStatus(t)
                }
                onTrackVideoTypeChanged(e, t) {
                    const n = e.getParticipantId(),
                        i = Date.now();
                    this.maybeSendParticipantConnectionStatusEvent(n, i), this.connectionStatusMap[n] = h({}, this.connectionStatusMap[n] || {}, {
                        videoType: t,
                        startedMs: i
                    })
                }
            }
        }).call(this, "modules/connectivity/ParticipantConnectionStatus.js")
    }, function(e, t, n) {
        "use strict";
        var i = {
            generateIdentifier: function() {
                return Math.random().toString(36).substr(2, 10)
            }
        };
        i.localCName = i.generateIdentifier(), i.splitLines = function(e) {
            return e.trim().split("\n").map((function(e) {
                return e.trim()
            }))
        }, i.splitSections = function(e) {
            return e.split("\nm=").map((function(e, t) {
                return (t > 0 ? "m=" + e : e).trim() + "\r\n"
            }))
        }, i.getDescription = function(e) {
            var t = i.splitSections(e);
            return t && t[0]
        }, i.getMediaSections = function(e) {
            var t = i.splitSections(e);
            return t.shift(), t
        }, i.matchPrefix = function(e, t) {
            return i.splitLines(e).filter((function(e) {
                return 0 === e.indexOf(t)
            }))
        }, i.parseCandidate = function(e) {
            for (var t, n = {
                    foundation: (t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" "))[0],
                    component: parseInt(t[1], 10),
                    protocol: t[2].toLowerCase(),
                    priority: parseInt(t[3], 10),
                    ip: t[4],
                    address: t[4],
                    port: parseInt(t[5], 10),
                    type: t[7]
                }, i = 8; i < t.length; i += 2) switch (t[i]) {
                case "raddr":
                    n.relatedAddress = t[i + 1];
                    break;
                case "rport":
                    n.relatedPort = parseInt(t[i + 1], 10);
                    break;
                case "tcptype":
                    n.tcpType = t[i + 1];
                    break;
                case "ufrag":
                    n.ufrag = t[i + 1], n.usernameFragment = t[i + 1];
                    break;
                default:
                    n[t[i]] = t[i + 1]
            }
            return n
        }, i.writeCandidate = function(e) {
            var t = [];
            t.push(e.foundation), t.push(e.component), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port);
            var n = e.type;
            return t.push("typ"), t.push(n), "host" !== n && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ")
        }, i.parseIceOptions = function(e) {
            return e.substr(14).split(" ")
        }, i.parseRtpMap = function(e) {
            var t = e.substr(9).split(" "),
                n = {
                    payloadType: parseInt(t.shift(), 10)
                };
            return t = t[0].split("/"), n.name = t[0], n.clockRate = parseInt(t[1], 10), n.channels = 3 === t.length ? parseInt(t[2], 10) : 1, n.numChannels = n.channels, n
        }, i.writeRtpMap = function(e) {
            var t = e.payloadType;
            void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);
            var n = e.channels || e.numChannels || 1;
            return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== n ? "/" + n : "") + "\r\n"
        }, i.parseExtmap = function(e) {
            var t = e.substr(9).split(" ");
            return {
                id: parseInt(t[0], 10),
                direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv",
                uri: t[1]
            }
        }, i.writeExtmap = function(e) {
            return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n"
        }, i.parseFmtp = function(e) {
            for (var t, n = {}, i = e.substr(e.indexOf(" ") + 1).split(";"), r = 0; r < i.length; r++) n[(t = i[r].trim().split("="))[0].trim()] = t[1];
            return n
        }, i.writeFmtp = function(e) {
            var t = "",
                n = e.payloadType;
            if (void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
                var i = [];
                Object.keys(e.parameters).forEach((function(t) {
                    e.parameters[t] ? i.push(t + "=" + e.parameters[t]) : i.push(t)
                })), t += "a=fmtp:" + n + " " + i.join(";") + "\r\n"
            }
            return t
        }, i.parseRtcpFb = function(e) {
            var t = e.substr(e.indexOf(" ") + 1).split(" ");
            return {
                type: t.shift(),
                parameter: t.join(" ")
            }
        }, i.writeRtcpFb = function(e) {
            var t = "",
                n = e.payloadType;
            return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach((function(e) {
                t += "a=rtcp-fb:" + n + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n"
            })), t
        }, i.parseSsrcMedia = function(e) {
            var t = e.indexOf(" "),
                n = {
                    ssrc: parseInt(e.substr(7, t - 7), 10)
                },
                i = e.indexOf(":", t);
            return i > -1 ? (n.attribute = e.substr(t + 1, i - t - 1), n.value = e.substr(i + 1)) : n.attribute = e.substr(t + 1), n
        }, i.parseSsrcGroup = function(e) {
            var t = e.substr(13).split(" ");
            return {
                semantics: t.shift(),
                ssrcs: t.map((function(e) {
                    return parseInt(e, 10)
                }))
            }
        }, i.getMid = function(e) {
            var t = i.matchPrefix(e, "a=mid:")[0];
            if (t) return t.substr(6)
        }, i.parseFingerprint = function(e) {
            var t = e.substr(14).split(" ");
            return {
                algorithm: t[0].toLowerCase(),
                value: t[1]
            }
        }, i.getDtlsParameters = function(e, t) {
            return {
                role: "auto",
                fingerprints: i.matchPrefix(e + t, "a=fingerprint:").map(i.parseFingerprint)
            }
        }, i.writeDtlsParameters = function(e, t) {
            var n = "a=setup:" + t + "\r\n";
            return e.fingerprints.forEach((function(e) {
                n += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n"
            })), n
        }, i.parseCryptoLine = function(e) {
            var t = e.substr(9).split(" ");
            return {
                tag: parseInt(t[0], 10),
                cryptoSuite: t[1],
                keyParams: t[2],
                sessionParams: t.slice(3)
            }
        }, i.writeCryptoLine = function(e) {
            return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" == typeof e.keyParams ? i.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n"
        }, i.parseCryptoKeyParams = function(e) {
            if (0 !== e.indexOf("inline:")) return null;
            var t = e.substr(7).split("|");
            return {
                keyMethod: "inline",
                keySalt: t[0],
                lifeTime: t[1],
                mkiValue: t[2] ? t[2].split(":")[0] : void 0,
                mkiLength: t[2] ? t[2].split(":")[1] : void 0
            }
        }, i.writeCryptoKeyParams = function(e) {
            return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "")
        }, i.getCryptoParameters = function(e, t) {
            return i.matchPrefix(e + t, "a=crypto:").map(i.parseCryptoLine)
        }, i.getIceParameters = function(e, t) {
            var n = i.matchPrefix(e + t, "a=ice-ufrag:")[0],
                r = i.matchPrefix(e + t, "a=ice-pwd:")[0];
            return n && r ? {
                usernameFragment: n.substr(12),
                password: r.substr(10)
            } : null
        }, i.writeIceParameters = function(e) {
            return "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n"
        }, i.parseRtpParameters = function(e) {
            for (var t = {
                    codecs: [],
                    headerExtensions: [],
                    fecMechanisms: [],
                    rtcp: []
                }, n = i.splitLines(e)[0].split(" "), r = 3; r < n.length; r++) {
                var s = n[r],
                    o = i.matchPrefix(e, "a=rtpmap:" + s + " ")[0];
                if (o) {
                    var a = i.parseRtpMap(o),
                        c = i.matchPrefix(e, "a=fmtp:" + s + " ");
                    switch (a.parameters = c.length ? i.parseFmtp(c[0]) : {}, a.rtcpFeedback = i.matchPrefix(e, "a=rtcp-fb:" + s + " ").map(i.parseRtcpFb), t.codecs.push(a), a.name.toUpperCase()) {
                        case "RED":
                        case "ULPFEC":
                            t.fecMechanisms.push(a.name.toUpperCase())
                    }
                }
            }
            return i.matchPrefix(e, "a=extmap:").forEach((function(e) {
                t.headerExtensions.push(i.parseExtmap(e))
            })), t
        }, i.writeRtpDescription = function(e, t) {
            var n = "";
            n += "m=" + e + " ", n += t.codecs.length > 0 ? "9" : "0", n += " UDP/TLS/RTP/SAVPF ", n += t.codecs.map((function(e) {
                return void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType
            })).join(" ") + "\r\n", n += "c=IN IP4 0.0.0.0\r\n", n += "a=rtcp:9 IN IP4 0.0.0.0\r\n", t.codecs.forEach((function(e) {
                n += i.writeRtpMap(e), n += i.writeFmtp(e), n += i.writeRtcpFb(e)
            }));
            var r = 0;
            return t.codecs.forEach((function(e) {
                e.maxptime > r && (r = e.maxptime)
            })), r > 0 && (n += "a=maxptime:" + r + "\r\n"), n += "a=rtcp-mux\r\n", t.headerExtensions && t.headerExtensions.forEach((function(e) {
                n += i.writeExtmap(e)
            })), n
        }, i.parseRtpEncodingParameters = function(e) {
            var t, n = [],
                r = i.parseRtpParameters(e),
                s = -1 !== r.fecMechanisms.indexOf("RED"),
                o = -1 !== r.fecMechanisms.indexOf("ULPFEC"),
                a = i.matchPrefix(e, "a=ssrc:").map((function(e) {
                    return i.parseSsrcMedia(e)
                })).filter((function(e) {
                    return "cname" === e.attribute
                })),
                c = a.length > 0 && a[0].ssrc,
                d = i.matchPrefix(e, "a=ssrc-group:FID").map((function(e) {
                    return e.substr(17).split(" ").map((function(e) {
                        return parseInt(e, 10)
                    }))
                }));
            d.length > 0 && d[0].length > 1 && d[0][0] === c && (t = d[0][1]), r.codecs.forEach((function(e) {
                if ("RTX" === e.name.toUpperCase() && e.parameters.apt) {
                    var i = {
                        ssrc: c,
                        codecPayloadType: parseInt(e.parameters.apt, 10)
                    };
                    c && t && (i.rtx = {
                        ssrc: t
                    }), n.push(i), s && ((i = JSON.parse(JSON.stringify(i))).fec = {
                        ssrc: c,
                        mechanism: o ? "red+ulpfec" : "red"
                    }, n.push(i))
                }
            })), 0 === n.length && c && n.push({
                ssrc: c
            });
            var u = i.matchPrefix(e, "b=");
            return u.length && (u = 0 === u[0].indexOf("b=TIAS:") ? parseInt(u[0].substr(7), 10) : 0 === u[0].indexOf("b=AS:") ? 1e3 * parseInt(u[0].substr(5), 10) * .95 - 16e3 : void 0, n.forEach((function(e) {
                e.maxBitrate = u
            }))), n
        }, i.parseRtcpParameters = function(e) {
            var t = {},
                n = i.matchPrefix(e, "a=ssrc:").map((function(e) {
                    return i.parseSsrcMedia(e)
                })).filter((function(e) {
                    return "cname" === e.attribute
                }))[0];
            n && (t.cname = n.value, t.ssrc = n.ssrc);
            var r = i.matchPrefix(e, "a=rtcp-rsize");
            t.reducedSize = r.length > 0, t.compound = 0 === r.length;
            var s = i.matchPrefix(e, "a=rtcp-mux");
            return t.mux = s.length > 0, t
        }, i.parseMsid = function(e) {
            var t, n = i.matchPrefix(e, "a=msid:");
            if (1 === n.length) return {
                stream: (t = n[0].substr(7).split(" "))[0],
                track: t[1]
            };
            var r = i.matchPrefix(e, "a=ssrc:").map((function(e) {
                return i.parseSsrcMedia(e)
            })).filter((function(e) {
                return "msid" === e.attribute
            }));
            return r.length > 0 ? {
                stream: (t = r[0].value.split(" "))[0],
                track: t[1]
            } : void 0
        }, i.parseSctpDescription = function(e) {
            var t, n = i.parseMLine(e),
                r = i.matchPrefix(e, "a=max-message-size:");
            r.length > 0 && (t = parseInt(r[0].substr(19), 10)), isNaN(t) && (t = 65536);
            var s = i.matchPrefix(e, "a=sctp-port:");
            if (s.length > 0) return {
                port: parseInt(s[0].substr(12), 10),
                protocol: n.fmt,
                maxMessageSize: t
            };
            if (i.matchPrefix(e, "a=sctpmap:").length > 0) {
                var o = i.matchPrefix(e, "a=sctpmap:")[0].substr(10).split(" ");
                return {
                    port: parseInt(o[0], 10),
                    protocol: o[1],
                    maxMessageSize: t
                }
            }
        }, i.writeSctpDescription = function(e, t) {
            var n = [];
            return n = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && n.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), n.join("")
        }, i.generateSessionId = function() {
            return Math.random().toString().substr(2, 21)
        }, i.writeSessionBoilerplate = function(e, t, n) {
            var r = void 0 !== t ? t : 2;
            return "v=0\r\no=" + (n || "thisisadapterortc") + " " + (e || i.generateSessionId()) + " " + r + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"
        }, i.writeMediaSection = function(e, t, n, r) {
            var s = i.writeRtpDescription(e.kind, t);
            if (s += i.writeIceParameters(e.iceGatherer.getLocalParameters()), s += i.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), "offer" === n ? "actpass" : "active"), s += "a=mid:" + e.mid + "\r\n", e.direction ? s += "a=" + e.direction + "\r\n" : e.rtpSender && e.rtpReceiver ? s += "a=sendrecv\r\n" : e.rtpSender ? s += "a=sendonly\r\n" : e.rtpReceiver ? s += "a=recvonly\r\n" : s += "a=inactive\r\n", e.rtpSender) {
                var o = "msid:" + r.id + " " + e.rtpSender.track.id + "\r\n";
                s += "a=" + o, s += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + o, e.sendEncodingParameters[0].rtx && (s += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + o, s += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + "\r\n")
            }
            return s += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + i.localCName + "\r\n", e.rtpSender && e.sendEncodingParameters[0].rtx && (s += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + i.localCName + "\r\n"), s
        }, i.getDirection = function(e, t) {
            for (var n = i.splitLines(e), r = 0; r < n.length; r++) switch (n[r]) {
                case "a=sendrecv":
                case "a=sendonly":
                case "a=recvonly":
                case "a=inactive":
                    return n[r].substr(2)
            }
            return t ? i.getDirection(t) : "sendrecv"
        }, i.getKind = function(e) {
            return i.splitLines(e)[0].split(" ")[0].substr(2)
        }, i.isRejected = function(e) {
            return "0" === e.split(" ", 2)[1]
        }, i.parseMLine = function(e) {
            var t = i.splitLines(e)[0].substr(2).split(" ");
            return {
                kind: t[0],
                port: parseInt(t[1], 10),
                protocol: t[2],
                fmt: t.slice(3).join(" ")
            }
        }, i.parseOLine = function(e) {
            var t = i.matchPrefix(e, "o=")[0].substr(2).split(" ");
            return {
                username: t[0],
                sessionId: t[1],
                sessionVersion: parseInt(t[2], 10),
                netType: t[3],
                addressType: t[4],
                address: t[5]
            }
        }, i.isValidSDP = function(e) {
            if ("string" != typeof e || 0 === e.length) return !1;
            for (var t = i.splitLines(e), n = 0; n < t.length; n++)
                if (t[n].length < 2 || "=" !== t[n].charAt(1)) return !1;
            return !0
        }, e.exports = i
    }, function(e, t, n) {
        "use strict";
        t.a = {
            getFocusRecordingUpdate(e) {
                const t = e && e.getElementsByTagName("jibri-recording-status")[0];
                if (t) return {
                    error: t.getAttribute("failure_reason"),
                    initiator: t.getAttribute("initiator"),
                    recordingMode: t.getAttribute("recording_mode"),
                    sessionID: t.getAttribute("session_id"),
                    status: t.getAttribute("status")
                }
            },
            getHiddenDomainUpdate(e) {
                const t = e.getElementsByTagName("live-stream-view-url")[0],
                    n = t && t.textContent,
                    i = e.getElementsByTagName("mode")[0],
                    r = i && i.textContent && i.textContent.toLowerCase(),
                    s = e.getElementsByTagName("session_id")[0];
                return {
                    liveStreamViewURL: n,
                    mode: r,
                    sessionID: s && s.textContent
                }
            },
            getSessionIdFromIq(e) {
                const t = e && e.getElementsByTagName("jibri")[0];
                return t && t.getAttribute("session_id")
            },
            getSessionId(e) {
                const t = e.getElementsByTagName("session_id")[0];
                return t && t.textContent
            },
            isFromFocus: e => e.getAttribute("from").includes("focus")
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return A
            }));
            var i = n(7),
                r = n(4),
                s = n(1),
                o = n(100),
                a = n(3),
                c = n(101),
                d = n(32),
                u = n(17),
                l = n(50),
                h = n(6),
                p = n(102),
                f = n(8),
                m = n.n(f),
                g = n(5),
                _ = n(0),
                v = n.n(_),
                S = n(104),
                y = n(11),
                E = n.n(y),
                T = n(40);
            const b = Object(r.getLogger)(e),
                C = 1e4,
                R = 300;
            class A extends c.a {
                static parseVideoSenders(e) {
                    const t = e.find('>content[name="video"]');
                    if (t.length) {
                        const e = t[0].getAttribute("senders");
                        if ("both" === e || "initiator" === e || "responder" === e || "none" === e) return e
                    }
                    return null
                }
                constructor(e, t, n, i, r, s, o, a) {
                    super(e, t, n, i, r, s, a), this._bridgeSessionId = null, this._cachedOldLocalSdp = void 0, this._cachedNewLocalSdp = void 0, this._iceCheckingStartedTimestamp = null, this._gatheringStartedTimestamp = null, this._localVideoActive = !0, this._remoteVideoActive = !0, this._gatheringReported = !1, this.lasticecandidate = !1, this.closed = !1, this.isP2P = o, this.signalingLayer = new p.a, this.modificationQueue = new S.a, this.wasConnected = !1, this.establishmentDuration = void 0, this._xmppListeners = [], this._xmppListeners.push(i.addEventListener(T.a.Events.CONN_STATUS_CHANGED, this.onXmppStatusChanged.bind(this)))
                }
                _assertNotEnded() {
                    return this.state !== d.b
                }
                doInitialize(e) {
                    this.failICE = Boolean(e.failICE), this.lasticecandidate = !1, this.options = e, this.isReconnect = !1, this.wasstable = !1, this.webrtcIceUdpDisable = Boolean(e.webrtcIceUdpDisable), this.webrtcIceTcpDisable = Boolean(e.webrtcIceTcpDisable);
                    const t = {
                        disableRtx: e.disableRtx
                    };
                    if (e.gatherStats && (t.maxstats = R), t.capScreenshareBitrate = !1, this.isP2P) {
                        t.disableSimulcast = !0, t.disableH264 = e.p2p && e.p2p.disableH264, t.preferH264 = e.p2p && e.p2p.preferH264;
                        const n = this._abtestSuspendVideoEnabled(e);
                        void 0 !== n && (t.abtestSuspendVideo = n)
                    } else t.disableSimulcast = e.disableSimulcast || e.preferH264 && !e.disableH264, t.preferH264 = e.preferH264, t.enableLayerSuspension = e.enableLayerSuspension, e.testing && e.testing.capScreenshareBitrate && "number" == typeof e.testing.capScreenshareBitrate && (t.capScreenshareBitrate = Math.random() < e.testing.capScreenshareBitrate, g.a.analytics.addPermanentProperties({
                        capScreenshareBitrate: t.capScreenshareBitrate
                    }));
                    e.startSilent && (t.startSilent = !0), this.peerconnection = this.rtc.createPeerConnection(this.signalingLayer, this.iceConfig, this.isP2P, t), this.peerconnection.onicecandidate = e => {
                        if (!e) return;
                        const t = e.candidate,
                            n = window.performance.now();
                        if (t) {
                            null === this._gatheringStartedTimestamp && (this._gatheringStartedTimestamp = n);
                            let e = t.protocol;
                            if ("string" == typeof e)
                                if ("tcp" === (e = e.toLowerCase()) || "ssltcp" === e) {
                                    if (this.webrtcIceTcpDisable) return
                                } else if ("udp" === e && this.webrtcIceUdpDisable) return
                        } else this._gatheringReported || (g.a.sendAnalytics(i.o, {
                            phase: "gathering",
                            value: n - this._gatheringStartedTimestamp,
                            p2p: this.isP2P,
                            initiator: this.isInitiator
                        }), this._gatheringReported = !0);
                        this.sendIceCandidate(t)
                    }, this.peerconnection.onsignalingstatechange = () => {
                        "stable" === this.peerconnection.signalingState ? this.wasstable = !0 : "closed" !== this.peerconnection.signalingState && "closed" !== this.peerconnection.connectionState || this.room.eventEmitter.emit(v.a.SUSPEND_DETECTED, this)
                    }, this.peerconnection.oniceconnectionstatechange = () => {
                        const e = window.performance.now();
                        switch (this.isP2P || (this.room.connectionTimes[`ice.state.${this.peerconnection.iceConnectionState}`] = e), b.log(`(TIME) ICE ${this.peerconnection.iceConnectionState}` + ` P2P? ${this.isP2P}:\t`, e), g.a.sendAnalytics(i.q, {
                            p2p: this.isP2P,
                            state: this.peerconnection.iceConnectionState,
                            signaling_state: this.peerconnection.signalingState,
                            reconnect: this.isReconnect,
                            value: e
                        }), this.room.eventEmitter.emit(v.a.ICE_CONNECTION_STATE_CHANGED, this, this.peerconnection.iceConnectionState), this.peerconnection.iceConnectionState) {
                            case "checking":
                                this._iceCheckingStartedTimestamp = e;
                                break;
                            case "connected":
                                if ("stable" === this.peerconnection.signalingState && this.isReconnect && this.room.eventEmitter.emit(v.a.CONNECTION_RESTORED, this), !this.wasConnected && this.wasstable) {
                                    g.a.sendAnalytics(i.o, {
                                        phase: "checking",
                                        value: e - this._iceCheckingStartedTimestamp,
                                        p2p: this.isP2P,
                                        initiator: this.isInitiator
                                    });
                                    const t = Math.min(this._iceCheckingStartedTimestamp, this._gatheringStartedTimestamp);
                                    this.establishmentDuration = e - t, g.a.sendAnalytics(i.o, {
                                        phase: "establishment",
                                        value: this.establishmentDuration,
                                        p2p: this.isP2P,
                                        initiator: this.isInitiator
                                    }), this.wasConnected = !0, this.room.eventEmitter.emit(v.a.CONNECTION_ESTABLISHED, this)
                                }
                                this.isReconnect = !1;
                                break;
                            case "disconnected":
                                this.isReconnect = !0, this.wasstable && this.room.eventEmitter.emit(v.a.CONNECTION_INTERRUPTED, this);
                                break;
                            case "failed":
                                this.room.eventEmitter.emit(v.a.CONNECTION_ICE_FAILED, this)
                        }
                    }, this.peerconnection.onnegotiationneeded = () => {
                        const e = this.peerconnection.signalingState,
                            t = this.peerconnection.remoteDescription;
                        if (this.room.eventEmitter.emit(v.a.PEERCONNECTION_READY, this), a.a.usesUnifiedPlan() && "stable" === e && t && "string" == typeof t.sdp) {
                            b.debug(`onnegotiationneeded fired on ${this.peerconnection} in state: ${e}`);
                            const t = e => {
                                const t = new u.a(this.peerconnection.localDescription.sdp);
                                this._renegotiate().then(() => {
                                    const n = new u.a(this.peerconnection.localDescription.sdp);
                                    this.notifyMySSRCUpdate(t, n), e()
                                }, e)
                            };
                            this.modificationQueue.push(t, e => {
                                e ? b.error("onnegotiationneeded error", e) : b.debug("onnegotiationneeded executed - OK")
                            })
                        }
                    }, this.signalingLayer.setChatRoom(this.room), !this.isP2P && e.enableLayerSuspension && this.rtc.addListener(m.a.IS_SELECTED_CHANGED, e => {
                        this.peerconnection.setIsSelected(e), b.info("Doing local O/A due to IS_SELECTED_CHANGED event"), this.modificationQueue.push(e => {
                            this._renegotiate().then(e).catch(e)
                        })
                    })
                }
                sendIceCandidate(e) {
                    const t = new u.a(this.peerconnection.localDescription.sdp);
                    if (e && e.candidate.length && !this.lasticecandidate) {
                        const n = h.a.iceparams(t.media[e.sdpMLineIndex], t.session),
                            i = h.a.candidateToJingle(e.candidate);
                        if (!n || !i) {
                            const e = "failed to get ice && jcand";
                            return E.a.callErrorHandler(new Error(e)), void b.error(e)
                        }
                        n.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", this.usedrip ? (0 === this.dripContainer.length && setTimeout(() => {
                            0 !== this.dripContainer.length && (this.sendIceCandidates(this.dripContainer), this.dripContainer = [])
                        }, 20), this.dripContainer.push(e)) : this.sendIceCandidates([e])
                    } else b.log("sendIceCandidate: last candidate."), this.lasticecandidate = !0
                }
                sendIceCandidates(e) {
                    if (!this._assertNotEnded("sendIceCandidates")) return;
                    b.log("sendIceCandidates", e);
                    const t = Object(s.$iq)({
                            to: this.remoteJid,
                            type: "set"
                        }).c("jingle", {
                            xmlns: "urn:xmpp:jingle:1",
                            action: "transport-info",
                            initiator: this.initiatorJid,
                            sid: this.sid
                        }),
                        n = new u.a(this.peerconnection.localDescription.sdp);
                    for (let i = 0; i < n.media.length; i++) {
                        const r = e.filter(e => e.sdpMLineIndex === i),
                            s = h.a.parseMLine(n.media[i].split("\r\n")[0]);
                        if (r.length > 0) {
                            const e = h.a.iceparams(n.media[i], n.session);
                            e.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.c("content", {
                                creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
                                name: r[0].sdpMid ? r[0].sdpMid : s.media
                            }).c("transport", e);
                            for (let e = 0; e < r.length; e++) {
                                const n = h.a.candidateToJingle(r[e].candidate);
                                this.failICE && (n.ip = "1.1.1.1"), t.c("candidate", n).up()
                            }
                            const o = h.a.findLine(n.media[i], "a=fingerprint:", n.session);
                            if (o) {
                                const e = h.a.parseFingerprint(o);
                                e.required = !0, t.c("fingerprint", {
                                    xmlns: "urn:xmpp:jingle:apps:dtls:0"
                                }).t(e.fingerprint), delete e.fingerprint, t.attrs(e), t.up()
                            }
                            t.up(), t.up()
                        }
                    }
                    this.connection.sendIQ(t, null, this.newJingleErrorHandler(t), C)
                }
                sendIceFailedNotification() {
                    const e = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "session-info",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    }).c("ice-state", {
                        xmlns: "http://jitsi.org/protocol/focus"
                    }).t("failed").up();
                    this._bridgeSessionId && e.c("bridge-session", {
                        xmlns: "http://jitsi.org/protocol/focus",
                        id: this._bridgeSessionId
                    }), this.connection.sendIQ(e, null, this.newJingleErrorHandler(e), 65)
                }
                addIceCandidates(e) {
                    if ("closed" === this.peerconnection.signalingState) return void b.warn("Ignored add ICE candidate when in closed state");
                    const t = [];
                    if (e.find(">content>transport>candidate").each((e, n) => {
                            let i = h.a.candidateFromJingle(n);
                            i = i.replace("\r\n", "").replace("a=", "");
                            const r = new RTCIceCandidate({
                                sdpMLineIndex: 0,
                                sdpMid: "",
                                candidate: i
                            });
                            t.push(r)
                        }), !t.length) return void b.error("No ICE candidates to add ?", e[0] && e[0].outerHTML);
                    b.debug(`Queued add (${t.length}) ICE candidates task...`), this.modificationQueue.push(e => {
                        for (const e of t) this.peerconnection.addIceCandidate(e).then(() => b.debug("addIceCandidate ok!"), e => b.error("addIceCandidate failed!", e));
                        e()
                    })
                }
                readSsrcInfo(e) {
                    $(e).find('>description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((e, t) => {
                        const n = Number(t.getAttribute("ssrc"));
                        this.isP2P ? this.signalingLayer.setSSRCOwner(n, s.Strophe.getResourceFromJid(this.remoteJid)) : $(t).find('>ssrc-info[xmlns="http://jitsi.org/jitmeet"]').each((e, t) => {
                            const i = t.getAttribute("owner");
                            i && i.length && (isNaN(n) || n < 0 ? b.warn(`Invalid SSRC ${n} value received` + ` for ${i}`) : this.signalingLayer.setSSRCOwner(n, s.Strophe.getResourceFromJid(i)))
                        })
                    })
                }
                generateRecvonlySsrc() {
                    this.peerconnection ? this.peerconnection.generateRecvonlySsrc() : b.error("Unable to generate recvonly SSRC - no peerconnection")
                }
                acceptOffer(e, t, n, i) {
                    this.setOfferAnswerCycle(e, () => {
                        this.sendSessionAccept(t, n)
                    }, n, i)
                }
                invite(e) {
                    if (!this.isInitiator) throw new Error("Trying to invite from the responder session");
                    this.modificationQueue.push(t => {
                        for (const t of e) this.peerconnection.addTrack(t, !0);
                        this.peerconnection.createOffer(this.mediaConstraints).then(e => {
                            this.peerconnection.setLocalDescription(e).then(() => {
                                this.sendSessionInitiate(this.peerconnection.localDescription.sdp), t()
                            }, n => {
                                b.error("Failed to set local SDP", n, e), t(n)
                            })
                        }, e => {
                            b.error("Failed to create an offer", e, this.mediaConstraints), t(e)
                        })
                    }, e => {
                        e ? b.error("invite error", e) : b.debug("invite executed - OK")
                    })
                }
                sendSessionInitiate(e) {
                    let t = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "session-initiate",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    });
                    new u.a(e).toJingle(t, this.isInitiator ? "initiator" : "responder"), t = t.tree(), b.info("Session-initiate: ", t), this.connection.sendIQ(t, () => {
                        b.info('Got RESULT for "session-initiate"')
                    }, e => {
                        b.error('"session-initiate" error', e)
                    }, C)
                }
                setAnswer(e) {
                    if (!this.isInitiator) throw new Error("Trying to set an answer on the responder session");
                    this.setOfferAnswerCycle(e, () => {
                        b.info("setAnswer - succeeded")
                    }, e => {
                        b.error("setAnswer failed: ", e)
                    })
                }
                setOfferAnswerCycle(e, t, n, i) {
                    this.modificationQueue.push(t => {
                        if (i)
                            for (const e of i) this.peerconnection.addTrack(e);
                        const n = this._processNewJingleOfferIq(e),
                            r = this.peerconnection.localDescription.sdp,
                            s = $(e).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("id");
                        s !== this._bridgeSessionId && (this._bridgeSessionId = s), this._renegotiate(n.raw).then(() => {
                            if (this.state === d.c && (this.state = d.a, this.isP2P && !this._localVideoActive && this.sendContentModify(this._localVideoActive)), r) {
                                const e = new u.a(this.peerconnection.localDescription.sdp);
                                this.notifyMySSRCUpdate(new u.a(r), e)
                            }
                            t()
                        }, e => {
                            b.error(`Error renegotiating after setting new remote ${this.isInitiator?"answer: ":"offer: "}${e}`, n), t(e)
                        })
                    }, e => {
                        e ? n(e) : t()
                    })
                }
                replaceTransport(e, t, n) {
                    this.room.eventEmitter.emit(v.a.ICE_RESTARTING, this);
                    const i = e.clone();
                    e.find(">content[name='data']").attr("senders", "rejected"), e.find(">content>description>source").remove(), e.find(">content>description>ssrc-group").remove();
                    const r = e.find(">content>transport>fingerprint");
                    r.attr("hash", "sha-1"), r.text("00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00"), this.setOfferAnswerCycle(e, () => {
                        this.setOfferAnswerCycle(i, () => {
                            const e = new u.a(this.peerconnection.localDescription.sdp);
                            this.sendTransportAccept(e, t, n), this.room.eventEmitter.emit(v.a.ICE_RESTART_SUCCESS, this, i)
                        }, n)
                    }, n)
                }
                sendSessionAccept(e, t) {
                    const n = new u.a(this.peerconnection.localDescription.sdp);
                    let i = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "session-accept",
                        initiator: this.initiatorJid,
                        responder: this.responderJid,
                        sid: this.sid
                    });
                    this.webrtcIceTcpDisable && (n.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (n.removeUdpCandidates = !0), this.failICE && (n.failICE = !0), n.toJingle(i, this.initiatorJid === this.localJid ? "initiator" : "responder", null), i = i.tree(), b.info("Sending session-accept", i), this.connection.sendIQ(i, e, this.newJingleErrorHandler(i, e => {
                        t(e), this.room.eventEmitter.emit(v.a.SESSION_ACCEPT_TIMEOUT, this)
                    }), C)
                }
                sendContentModify(e) {
                    const t = e ? "both" : "none",
                        n = Object(s.$iq)({
                            to: this.remoteJid,
                            type: "set"
                        }).c("jingle", {
                            xmlns: "urn:xmpp:jingle:1",
                            action: "content-modify",
                            initiator: this.initiatorJid,
                            sid: this.sid
                        }).c("content", {
                            name: "video",
                            senders: t
                        });
                    b.info(`Sending content-modify, video senders: ${t}`), this.connection.sendIQ(n, null, this.newJingleErrorHandler(n), C)
                }
                sendTransportAccept(e, t, n) {
                    let i = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "transport-accept",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    });
                    e.media.forEach((t, n) => {
                        const r = h.a.parseMLine(t.split("\r\n")[0]);
                        i.c("content", {
                            creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
                            name: r.media
                        }), e.transportToJingle(n, i), i.up()
                    }), i = i.tree(), b.info("Sending transport-accept: ", i), this.connection.sendIQ(i, t, this.newJingleErrorHandler(i, n), C)
                }
                sendTransportReject(e, t) {
                    let n = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "transport-reject",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    });
                    n = n.tree(), b.info("Sending 'transport-reject", n), this.connection.sendIQ(n, e, this.newJingleErrorHandler(n, t), C)
                }
                terminate(e, t, n) {
                    if (this.state !== d.b) {
                        if (!n || Boolean(n.sendSessionTerminate)) {
                            let i = Object(s.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "session-terminate",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            }).c("reason").c(n && n.reason || "success");
                            n && n.reasonDescription && i.up().c("text").t(n.reasonDescription), i = i.tree(), b.info("Sending session-terminate", i), this.connection.sendIQ(i, e, this.newJingleErrorHandler(i, t), C)
                        } else b.info(`Skipped sending session-terminate for ${this}`);
                        this.connection.jingle.terminate(this.sid)
                    }
                }
                onTerminated(e, t) {
                    b.info(`Session terminated ${this}`, e, t), this._xmppListeners.forEach(e => e()), this._xmppListeners = [], this.close()
                }
                onXmppStatusChanged(e) {
                    e === T.a.Status.CONNECTED && this._cachedOldLocalSdp && (b.info("Sending SSRC update on reconnect"), this.notifyMySSRCUpdate(this._cachedOldLocalSdp, this._cachedNewLocalSdp))
                }
                _parseSsrcInfoFromSourceAdd(e, t) {
                    const n = [];
                    return $(e).each((e, i) => {
                        const r = $(i).attr("name");
                        let s = "";
                        $(i).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                            const e = this.getAttribute("semantics"),
                                t = $(this).find(">source").map((function() {
                                    return this.getAttribute("ssrc")
                                })).get();
                            t.length && (s += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
                        })), $(i).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                            const e = $(this).attr("ssrc");
                            t.containsSSRC(e) ? b.warn(`Source-add request for existing SSRC: ${e}`) : $(this).find(">parameter").each((function() {
                                s += `a=ssrc:${e} ${$(this).attr("name")}`, $(this).attr("value") && $(this).attr("value").length && (s += `:${$(this).attr("value")}`), s += "\r\n"
                            }))
                        })), t.media.forEach((e, t) => {
                            h.a.findLine(e, `a=mid:${r}`) && (n[t] || (n[t] = ""), n[t] += s)
                        })
                    }), n
                }
                addRemoteStream(e) {
                    this._addOrRemoveRemoteStream(!0, e)
                }
                removeRemoteStream(e) {
                    this._addOrRemoveRemoteStream(!1, e)
                }
                _addOrRemoveRemoteStream(e, t) {
                    const n = e ? "addRemoteStream" : "removeRemoteStream";
                    e && this.readSsrcInfo(t);
                    this.modificationQueue.push(i => {
                        if (!this.peerconnection.localDescription || !this.peerconnection.localDescription.sdp) {
                            const e = `${n} - localDescription not ready yet`;
                            return b.error(e), void i(e)
                        }
                        b.log(`Processing ${n}`), b.log("ICE connection state: ", this.peerconnection.iceConnectionState);
                        const r = new u.a(this.peerconnection.localDescription.sdp),
                            s = new u.a(this.peerconnection.remoteDescription.sdp),
                            o = e ? this._parseSsrcInfoFromSourceAdd(t, s) : this._parseSsrcInfoFromSourceRemove(t, s),
                            a = e ? this._processRemoteAddSource(o) : this._processRemoteRemoveSource(o);
                        this._renegotiate(a.raw).then(() => {
                            const e = new u.a(this.peerconnection.localDescription.sdp);
                            b.log(`${n} - OK, SDPs: `, r, e), this.notifyMySSRCUpdate(r, e), i()
                        }, e => {
                            b.error(`${n} failed:`, e), i(e)
                        })
                    })
                }
                _processNewJingleOfferIq(e) {
                    const t = new u.a("");
                    return this.webrtcIceTcpDisable && (t.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (t.removeUdpCandidates = !0), this.failICE && (t.failICE = !0), t.fromJingle(e), this.readSsrcInfo($(e).find(">content")), t
                }
                _processRemoteRemoveSource(e) {
                    const t = a.a.usesPlanB() ? new u.a(this.peerconnection.remoteDescription.sdp) : new u.a(this.peerconnection.peerconnection.remoteDescription.sdp);
                    return e.forEach((e, n) => {
                        (e = e.split("\r\n")).pop(), a.a.usesPlanB() ? e.forEach(e => {
                            t.media[n] = t.media[n].replace(`${e}\r\n`, "")
                        }) : e.forEach(e => {
                            const n = t.media.findIndex(t => t.includes(e));
                            n > -1 && (t.media[n] = t.media[n].replace(`${e}\r\n`, ""), t.media[n] = t.media[n].replace("a=sendonly", "a=inactive"))
                        })
                    }), t.raw = t.session + t.media.join(""), t
                }
                _processRemoteAddSource(e) {
                    const t = new u.a(this.peerconnection.remoteDescription.sdp);
                    return e.forEach((e, n) => {
                        t.media[n] += e
                    }), t.raw = t.session + t.media.join(""), t
                }
                _renegotiate(e) {
                    if ("closed" === this.peerconnection.signalingState) {
                        const e = new Error("Attempted to renegotiate in state closed");
                        return this.room.eventEmitter.emit(v.a.RENEGOTIATION_FAILED, e, this), Promise.reject(e)
                    }
                    const t = e || this.peerconnection.remoteDescription.sdp;
                    if (!t) {
                        const e = new Error(`Can not renegotiate without remote description, current state: ${this.state}`);
                        return this.room.eventEmitter.emit(v.a.RENEGOTIATION_FAILED, e, this), Promise.reject(e)
                    }
                    const n = new RTCSessionDescription({
                        type: this.isInitiator ? "answer" : "offer",
                        sdp: t
                    });
                    return this.isInitiator ? this._initiatorRenegotiate(n) : this._responderRenegotiate(n)
                }
                _responderRenegotiate(e) {
                    return b.debug("Renegotiate: setting remote description"), this.peerconnection.setRemoteDescription(e).then(() => (b.debug("Renegotiate: creating answer"), this.peerconnection.createAnswer(this.mediaConstraints).then(e => (b.debug("Renegotiate: setting local description"), this.peerconnection.setLocalDescription(e)))))
                }
                _initiatorRenegotiate(e) {
                    return b.debug("Renegotiate: creating offer"), this.peerconnection.createOffer(this.mediaConstraints).then(t => (b.debug("Renegotiate: setting local description"), this.peerconnection.setLocalDescription(t).then(() => (b.debug("Renegotiate: setting remote description"), this.peerconnection.setRemoteDescription(e)))))
                }
                replaceTrack(e, t) {
                    const n = n => {
                        const i = this.peerconnection.localDescription.sdp;
                        a.a.usesPlanB() && (this.peerconnection.options.capScreenshareBitrate && e && t && t.isVideoTrack() && this.peerconnection.clearRecvonlySsrc(), !e && t && t.isVideoTrack() ? this.peerconnection.clearRecvonlySsrc() : e && e.isVideoTrack() && !t && (this.peerconnection.clearRecvonlySsrc(), this.peerconnection.generateRecvonlySsrc())), this.peerconnection.replaceTrack(e, t).then(r => {
                            let s = Promise.resolve();
                            r && (e || t) && this.state === d.a && (s = this._renegotiate().then(() => {
                                const e = new u.a(this.peerconnection.localDescription.sdp);
                                this.notifyMySSRCUpdate(new u.a(i), e)
                            }, n)), s.then(() => {
                                t && !this.isP2P && this.peerconnection.setMaxBitRate(t), n()
                            }, n)
                        }).catch(e => {
                            n(e)
                        })
                    };
                    return new Promise((e, t) => {
                        this.modificationQueue.push(n, n => {
                            n ? (b.error("Replace track error:", n), t(n)) : (b.info("Replace track done!"), e())
                        })
                    })
                }
                _parseSsrcInfoFromSourceRemove(e, t) {
                    const n = [];
                    return $(e).each((e, i) => {
                        const r = $(i).attr("name");
                        let s = "";
                        $(i).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                            const e = this.getAttribute("semantics"),
                                t = $(this).find(">source").map((function() {
                                    return this.getAttribute("ssrc")
                                })).get();
                            t.length && (s += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
                        }));
                        const o = [];
                        $(i).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                            const e = $(this).attr("ssrc");
                            o.push(e)
                        })), t.media.forEach((e, t) => {
                            h.a.findLine(e, `a=mid:${r}`) && (n[t] || (n[t] = ""), o.forEach(i => {
                                const r = h.a.findLines(e, `a=ssrc:${i}`);
                                r.length && (n[t] += `${r.join("\r\n")}\r\n`)
                            }), n[t] += s)
                        })
                    }), n
                }
                _verifyNoSSRCChanged(e, t) {
                    const n = new u.a(this.peerconnection.localDescription.sdp);
                    let i = new l.a(t, n);
                    const r = i.getNewMedia();
                    if (Object.keys(r).length) return b.error(`${this} - some SSRC were added on ${e}`, r), !1;
                    const s = (i = new l.a(n, t)).getNewMedia();
                    return !Object.keys(s).length || (b.error(`${this} - some SSRCs were removed on ${e}`, s), !1)
                }
                addTrackAsUnmute(e) {
                    return this._addRemoveTrackAsMuteUnmute(!1, e)
                }
                removeTrackAsMute(e) {
                    return this._addRemoveTrackAsMuteUnmute(!0, e)
                }
                _addRemoveTrackAsMuteUnmute(e, t) {
                    if (!t) return Promise.reject('invalid "track" argument value');
                    const n = e ? "removeTrackMute" : "addTrackUnmute",
                        i = i => {
                            const r = this.peerconnection;
                            if (!r) return void i(`Error:  tried ${n} track with no active peer` + "connection");
                            const s = r.localDescription.sdp;
                            (e ? r.removeTrackMute(t) : r.addTrackUnmute(t)).then(e => {
                                e && s && r.remoteDescription.sdp ? this._renegotiate().then(() => {
                                    this._verifyNoSSRCChanged(n, new u.a(s)), i()
                                }) : i()
                            }, i)
                        };
                    return new Promise((e, t) => {
                        this.modificationQueue.push(i, n => {
                            n ? t(n) : e()
                        })
                    })
                }
                setMediaTransferActive(e, t) {
                    if (!this.peerconnection) return Promise.reject('Can not modify transfer active state, before "initialize" is called');
                    const n = e ? "audio active" : "audio inactive",
                        i = t ? "video active" : "video inactive";
                    b.info(`Queued make ${i}, ${n} task...`);
                    const r = n => {
                        const i = this.state === d.a,
                            r = this.peerconnection.setAudioTransferActive(e);
                        this._localVideoActive !== t && (this._localVideoActive = t, this.isP2P && i && this.sendContentModify(t));
                        const s = this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive);
                        i && (r || s) ? this._renegotiate().then(n, n) : n()
                    };
                    return new Promise((e, t) => {
                        this.modificationQueue.push(r, n => {
                            n ? t(n) : e()
                        })
                    })
                }
                modifyContents(e) {
                    const t = A.parseVideoSenders(e);
                    if (null === t) return void b.error(`${this} - failed to parse video "senders" attribute in` + '"content-modify" action');
                    b.debug(`${this} queued "content-modify" task` + `(video senders="${t}")`), this.modificationQueue.push(e => {
                        this._assertNotEnded("content-modify") && this._modifyRemoteVideoActive(t) ? this._renegotiate().then(e, e) : e()
                    }, e => {
                        e && b.error('"content-modify" failed', e)
                    })
                }
                _modifyRemoteVideoActive(e) {
                    const t = "both" === e || "initiator" === e && this.isInitiator || "responder" === e && !this.isInitiator;
                    return t !== this._remoteVideoActive && (b.debug(`${this} new remote video active: ${t}`), this._remoteVideoActive = t), this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive)
                }
                notifyMySSRCUpdate(e, t) {
                    if (this.state !== d.a) return void b.warn(`Skipping SSRC update in '${this.state} ' state.`);
                    if (!this.connection.connected) return this._cachedOldLocalSdp || (this._cachedOldLocalSdp = e), this._cachedNewLocalSdp = t, void b.warn("Not sending SSRC update while the signaling is disconnected");
                    this._cachedOldLocalSdp = void 0, this._cachedNewLocalSdp = void 0;
                    let n = new l.a(t, e);
                    const i = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "source-remove",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    });
                    n.toJingle(i) ? (b.info("Sending source-remove", i.tree()), this.connection.sendIQ(i, null, this.newJingleErrorHandler(i), C)) : b.log("removal not necessary"), n = new l.a(e, t);
                    const r = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "source-add",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    });
                    n.toJingle(r) ? (b.info("Sending source-add", r.tree()), this.connection.sendIQ(r, null, this.newJingleErrorHandler(r), C)) : b.log("addition not necessary")
                }
                newJingleErrorHandler(e, t) {
                    return e => {
                        const n = {},
                            i = $(e).find("error");
                        if (i.length) {
                            n.code = i.attr("code");
                            const t = $(e).find("error :first");
                            t.length && (n.reason = t[0].tagName);
                            const r = i.find(">text");
                            r.length && (n.msg = r.text())
                        }
                        e || (n.reason = "timeout"), n.session = this.toString(), t ? t(n) : this.state === d.b && "item-not-found" === n.reason ? b.debug(`Jingle error: ${JSON.stringify(n)}`) : E.a.callErrorHandler(new Error(`Jingle error: ${JSON.stringify(n)}`))
                    }
                }
                getIceConnectionState() {
                    return this.peerconnection.iceConnectionState
                }
                close() {
                    this.state = d.b, this.establishmentDuration = void 0, this.peerconnection && (this.peerconnection.onicecandidate = null, this.peerconnection.oniceconnectionstatechange = null, this.peerconnection.onnegotiationneeded = null, this.peerconnection.onsignalingstatechange = null), this.modificationQueue.clear(), this.modificationQueue.push(e => {
                        this.signalingLayer.setChatRoom(null), this.peerconnection && this.peerconnection.close(), e()
                    }), this.modificationQueue.shutdown()
                }
                toString() {
                    return `JingleSessionPC[p2p=${this.isP2P},` + `initiator=${this.isInitiator},sid=${this.sid}]`
                }
                _abtestSuspendVideoEnabled({
                    abTesting: e
                }) {
                    if (!e || !e.enableSuspendVideoTest) return;
                    const t = this._getInitiatorJid();
                    return Object(o.integerHash)(t) % 2 == 0
                }
            }
        }).call(this, "modules/xmpp/JingleSessionPC.js")
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "DEVICE_LIST_CHANGED", (function() {
            return i
        })), n.d(t, "PERMISSION_PROMPT_IS_SHOWN", (function() {
            return r
        }));
        const i = "mediaDevices.devicechange",
            r = "mediaDevices.permissionPromptIsShown"
    }, function(e, t, n) {
        (function(e, n) {
            var i = 200,
                r = "__lodash_hash_undefined__",
                s = 9007199254740991,
                o = "[object Arguments]",
                a = "[object Boolean]",
                c = "[object Date]",
                d = "[object Function]",
                u = "[object GeneratorFunction]",
                l = "[object Map]",
                h = "[object Number]",
                p = "[object Object]",
                f = "[object RegExp]",
                m = "[object Set]",
                g = "[object String]",
                _ = "[object Symbol]",
                v = "[object ArrayBuffer]",
                S = "[object DataView]",
                y = "[object Float32Array]",
                E = "[object Float64Array]",
                T = "[object Int8Array]",
                b = "[object Int16Array]",
                C = "[object Int32Array]",
                R = "[object Uint8Array]",
                A = "[object Uint8ClampedArray]",
                w = "[object Uint16Array]",
                I = "[object Uint32Array]",
                P = /\w*$/,
                D = /^\[object .+?Constructor\]$/,
                O = /^(?:0|[1-9]\d*)$/,
                N = {};
            N[o] = N["[object Array]"] = N[v] = N[S] = N[a] = N[c] = N[y] = N[E] = N[T] = N[b] = N[C] = N[l] = N[h] = N[p] = N[f] = N[m] = N[g] = N[_] = N[R] = N[A] = N[w] = N[I] = !0, N["[object Error]"] = N[d] = N["[object WeakMap]"] = !1;
            var M = "object" == typeof e && e && e.Object === Object && e,
                L = "object" == typeof self && self && self.Object === Object && self,
                k = M || L || Function("return this")(),
                x = t && !t.nodeType && t,
                F = x && "object" == typeof n && n && !n.nodeType && n,
                j = F && F.exports === x;

            function U(e, t) {
                return e.set(t[0], t[1]), e
            }

            function H(e, t) {
                return e.add(t), e
            }

            function J(e, t, n, i) {
                var r = -1,
                    s = e ? e.length : 0;
                for (i && s && (n = e[++r]); ++r < s;) n = t(n, e[r], r, e);
                return n
            }

            function B(e) {
                var t = !1;
                if (null != e && "function" != typeof e.toString) try {
                    t = !!(e + "")
                } catch (e) {}
                return t
            }

            function G(e) {
                var t = -1,
                    n = Array(e.size);
                return e.forEach((function(e, i) {
                    n[++t] = [i, e]
                })), n
            }

            function $(e, t) {
                return function(n) {
                    return e(t(n))
                }
            }

            function V(e) {
                var t = -1,
                    n = Array(e.size);
                return e.forEach((function(e) {
                    n[++t] = e
                })), n
            }
            var q, K = Array.prototype,
                W = Function.prototype,
                z = Object.prototype,
                X = k["__core-js_shared__"],
                Q = (q = /[^.]+$/.exec(X && X.keys && X.keys.IE_PROTO || "")) ? "Symbol(src)_1." + q : "",
                Y = W.toString,
                Z = z.hasOwnProperty,
                ee = z.toString,
                te = RegExp("^" + Y.call(Z).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                ne = j ? k.Buffer : void 0,
                ie = k.Symbol,
                re = k.Uint8Array,
                se = $(Object.getPrototypeOf, Object),
                oe = Object.create,
                ae = z.propertyIsEnumerable,
                ce = K.splice,
                de = Object.getOwnPropertySymbols,
                ue = ne ? ne.isBuffer : void 0,
                le = $(Object.keys, Object),
                he = Fe(k, "DataView"),
                pe = Fe(k, "Map"),
                fe = Fe(k, "Promise"),
                me = Fe(k, "Set"),
                ge = Fe(k, "WeakMap"),
                _e = Fe(Object, "create"),
                ve = Be(he),
                Se = Be(pe),
                ye = Be(fe),
                Ee = Be(me),
                Te = Be(ge),
                be = ie ? ie.prototype : void 0,
                Ce = be ? be.valueOf : void 0;

            function Re(e) {
                var t = -1,
                    n = e ? e.length : 0;
                for (this.clear(); ++t < n;) {
                    var i = e[t];
                    this.set(i[0], i[1])
                }
            }

            function Ae(e) {
                var t = -1,
                    n = e ? e.length : 0;
                for (this.clear(); ++t < n;) {
                    var i = e[t];
                    this.set(i[0], i[1])
                }
            }

            function we(e) {
                var t = -1,
                    n = e ? e.length : 0;
                for (this.clear(); ++t < n;) {
                    var i = e[t];
                    this.set(i[0], i[1])
                }
            }

            function Ie(e) {
                this.__data__ = new Ae(e)
            }

            function Pe(e, t) {
                var n = $e(e) || function(e) {
                        return function(e) {
                            return function(e) {
                                return !!e && "object" == typeof e
                            }(e) && Ve(e)
                        }(e) && Z.call(e, "callee") && (!ae.call(e, "callee") || ee.call(e) == o)
                    }(e) ? function(e, t) {
                        for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
                        return i
                    }(e.length, String) : [],
                    i = n.length,
                    r = !!i;
                for (var s in e) !t && !Z.call(e, s) || r && ("length" == s || He(s, i)) || n.push(s);
                return n
            }

            function De(e, t, n) {
                var i = e[t];
                Z.call(e, t) && Ge(i, n) && (void 0 !== n || t in e) || (e[t] = n)
            }

            function Oe(e, t) {
                for (var n = e.length; n--;)
                    if (Ge(e[n][0], t)) return n;
                return -1
            }

            function Ne(e, t, n, i, r, s, D) {
                var O;
                if (i && (O = s ? i(e, r, s, D) : i(e)), void 0 !== O) return O;
                if (!We(e)) return e;
                var M = $e(e);
                if (M) {
                    if (O = function(e) {
                            var t = e.length,
                                n = e.constructor(t);
                            t && "string" == typeof e[0] && Z.call(e, "index") && (n.index = e.index, n.input = e.input);
                            return n
                        }(e), !t) return function(e, t) {
                        var n = -1,
                            i = e.length;
                        t || (t = Array(i));
                        for (; ++n < i;) t[n] = e[n];
                        return t
                    }(e, O)
                } else {
                    var L = Ue(e),
                        k = L == d || L == u;
                    if (qe(e)) return function(e, t) {
                        if (t) return e.slice();
                        var n = new e.constructor(e.length);
                        return e.copy(n), n
                    }(e, t);
                    if (L == p || L == o || k && !s) {
                        if (B(e)) return s ? e : {};
                        if (O = function(e) {
                                return "function" != typeof e.constructor || Je(e) ? {} : (t = se(e), We(t) ? oe(t) : {});
                                var t
                            }(k ? {} : e), !t) return function(e, t) {
                            return ke(e, je(e), t)
                        }(e, function(e, t) {
                            return e && ke(t, ze(t), e)
                        }(O, e))
                    } else {
                        if (!N[L]) return s ? e : {};
                        O = function(e, t, n, i) {
                            var r = e.constructor;
                            switch (t) {
                                case v:
                                    return Le(e);
                                case a:
                                case c:
                                    return new r(+e);
                                case S:
                                    return function(e, t) {
                                        var n = t ? Le(e.buffer) : e.buffer;
                                        return new e.constructor(n, e.byteOffset, e.byteLength)
                                    }(e, i);
                                case y:
                                case E:
                                case T:
                                case b:
                                case C:
                                case R:
                                case A:
                                case w:
                                case I:
                                    return function(e, t) {
                                        var n = t ? Le(e.buffer) : e.buffer;
                                        return new e.constructor(n, e.byteOffset, e.length)
                                    }(e, i);
                                case l:
                                    return function(e, t, n) {
                                        return J(t ? n(G(e), !0) : G(e), U, new e.constructor)
                                    }(e, i, n);
                                case h:
                                case g:
                                    return new r(e);
                                case f:
                                    return (d = new(o = e).constructor(o.source, P.exec(o))).lastIndex = o.lastIndex, d;
                                case m:
                                    return function(e, t, n) {
                                        return J(t ? n(V(e), !0) : V(e), H, new e.constructor)
                                    }(e, i, n);
                                case _:
                                    return s = e, Ce ? Object(Ce.call(s)) : {}
                            }
                            var s;
                            var o, d
                        }(e, L, Ne, t)
                    }
                }
                D || (D = new Ie);
                var x = D.get(e);
                if (x) return x;
                if (D.set(e, O), !M) var F = n ? function(e) {
                    return function(e, t, n) {
                        var i = t(e);
                        return $e(e) ? i : function(e, t) {
                            for (var n = -1, i = t.length, r = e.length; ++n < i;) e[r + n] = t[n];
                            return e
                        }(i, n(e))
                    }(e, ze, je)
                }(e) : ze(e);
                return function(e, t) {
                    for (var n = -1, i = e ? e.length : 0; ++n < i && !1 !== t(e[n], n, e););
                }(F || e, (function(r, s) {
                    F && (r = e[s = r]), De(O, s, Ne(r, t, n, i, s, e, D))
                })), O
            }

            function Me(e) {
                return !(!We(e) || (t = e, Q && Q in t)) && (Ke(e) || B(e) ? te : D).test(Be(e));
                var t
            }

            function Le(e) {
                var t = new e.constructor(e.byteLength);
                return new re(t).set(new re(e)), t
            }

            function ke(e, t, n, i) {
                n || (n = {});
                for (var r = -1, s = t.length; ++r < s;) {
                    var o = t[r],
                        a = i ? i(n[o], e[o], o, n, e) : void 0;
                    De(n, o, void 0 === a ? e[o] : a)
                }
                return n
            }

            function xe(e, t) {
                var n, i, r = e.__data__;
                return ("string" == (i = typeof(n = t)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? r["string" == typeof t ? "string" : "hash"] : r.map
            }

            function Fe(e, t) {
                var n = function(e, t) {
                    return null == e ? void 0 : e[t]
                }(e, t);
                return Me(n) ? n : void 0
            }
            Re.prototype.clear = function() {
                this.__data__ = _e ? _e(null) : {}
            }, Re.prototype.delete = function(e) {
                return this.has(e) && delete this.__data__[e]
            }, Re.prototype.get = function(e) {
                var t = this.__data__;
                if (_e) {
                    var n = t[e];
                    return n === r ? void 0 : n
                }
                return Z.call(t, e) ? t[e] : void 0
            }, Re.prototype.has = function(e) {
                var t = this.__data__;
                return _e ? void 0 !== t[e] : Z.call(t, e)
            }, Re.prototype.set = function(e, t) {
                return this.__data__[e] = _e && void 0 === t ? r : t, this
            }, Ae.prototype.clear = function() {
                this.__data__ = []
            }, Ae.prototype.delete = function(e) {
                var t = this.__data__,
                    n = Oe(t, e);
                return !(n < 0) && (n == t.length - 1 ? t.pop() : ce.call(t, n, 1), !0)
            }, Ae.prototype.get = function(e) {
                var t = this.__data__,
                    n = Oe(t, e);
                return n < 0 ? void 0 : t[n][1]
            }, Ae.prototype.has = function(e) {
                return Oe(this.__data__, e) > -1
            }, Ae.prototype.set = function(e, t) {
                var n = this.__data__,
                    i = Oe(n, e);
                return i < 0 ? n.push([e, t]) : n[i][1] = t, this
            }, we.prototype.clear = function() {
                this.__data__ = {
                    hash: new Re,
                    map: new(pe || Ae),
                    string: new Re
                }
            }, we.prototype.delete = function(e) {
                return xe(this, e).delete(e)
            }, we.prototype.get = function(e) {
                return xe(this, e).get(e)
            }, we.prototype.has = function(e) {
                return xe(this, e).has(e)
            }, we.prototype.set = function(e, t) {
                return xe(this, e).set(e, t), this
            }, Ie.prototype.clear = function() {
                this.__data__ = new Ae
            }, Ie.prototype.delete = function(e) {
                return this.__data__.delete(e)
            }, Ie.prototype.get = function(e) {
                return this.__data__.get(e)
            }, Ie.prototype.has = function(e) {
                return this.__data__.has(e)
            }, Ie.prototype.set = function(e, t) {
                var n = this.__data__;
                if (n instanceof Ae) {
                    var r = n.__data__;
                    if (!pe || r.length < i - 1) return r.push([e, t]), this;
                    n = this.__data__ = new we(r)
                }
                return n.set(e, t), this
            };
            var je = de ? $(de, Object) : function() {
                    return []
                },
                Ue = function(e) {
                    return ee.call(e)
                };

            function He(e, t) {
                return !!(t = null == t ? s : t) && ("number" == typeof e || O.test(e)) && e > -1 && e % 1 == 0 && e < t
            }

            function Je(e) {
                var t = e && e.constructor;
                return e === ("function" == typeof t && t.prototype || z)
            }

            function Be(e) {
                if (null != e) {
                    try {
                        return Y.call(e)
                    } catch (e) {}
                    try {
                        return e + ""
                    } catch (e) {}
                }
                return ""
            }

            function Ge(e, t) {
                return e === t || e != e && t != t
            }(he && Ue(new he(new ArrayBuffer(1))) != S || pe && Ue(new pe) != l || fe && "[object Promise]" != Ue(fe.resolve()) || me && Ue(new me) != m || ge && "[object WeakMap]" != Ue(new ge)) && (Ue = function(e) {
                var t = ee.call(e),
                    n = t == p ? e.constructor : void 0,
                    i = n ? Be(n) : void 0;
                if (i) switch (i) {
                    case ve:
                        return S;
                    case Se:
                        return l;
                    case ye:
                        return "[object Promise]";
                    case Ee:
                        return m;
                    case Te:
                        return "[object WeakMap]"
                }
                return t
            });
            var $e = Array.isArray;

            function Ve(e) {
                return null != e && function(e) {
                    return "number" == typeof e && e > -1 && e % 1 == 0 && e <= s
                }(e.length) && !Ke(e)
            }
            var qe = ue || function() {
                return !1
            };

            function Ke(e) {
                var t = We(e) ? ee.call(e) : "";
                return t == d || t == u
            }

            function We(e) {
                var t = typeof e;
                return !!e && ("object" == t || "function" == t)
            }

            function ze(e) {
                return Ve(e) ? Pe(e) : function(e) {
                    if (!Je(e)) return le(e);
                    var t = [];
                    for (var n in Object(e)) Z.call(e, n) && "constructor" != n && t.push(n);
                    return t
                }(e)
            }
            n.exports = function(e) {
                return Ne(e, !0, !0)
            }
        }).call(this, n(43), n(70)(e))
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return s
        }));
        var i = n(6);

        function r(e, t) {
            if (!t) return !1;
            if (e.length !== t.length) return !1;
            for (let n = 0, i = e.length; n < i; n++)
                if (e[n] instanceof Array && t[n] instanceof Array) {
                    if (!e[n].equals(t[n])) return !1
                } else if (e[n] !== t[n]) return !1;
            return !0
        }

        function s(e, t) {
            if (this.mySDP = e, this.otherSDP = t, !e) throw new Error('"mySDP" is undefined!');
            if (!t) throw new Error('"otherSDP" is undefined!')
        }
        s.prototype.getNewMedia = function() {
            const e = this.mySDP.getMediaSsrcMap(),
                t = this.otherSDP.getMediaSsrcMap(),
                n = {};
            return Object.keys(t).forEach(i => {
                const s = e[i],
                    o = t[i];
                s || !o ? (Object.keys(o.ssrcs).forEach(e => {
                    if (-1 === Object.keys(s.ssrcs).indexOf(e)) n[i] || (n[i] = {
                        mediaindex: o.mediaindex,
                        mid: o.mid,
                        ssrcs: {},
                        ssrcGroups: []
                    }), n[i].ssrcs[e] = o.ssrcs[e];
                    else if (o.ssrcs[e].lines && s.ssrcs[e].lines) {
                        void 0 !== s.ssrcs[e].lines.find(e => -1 !== e.indexOf("msid")) !== (void 0 !== o.ssrcs[e].lines.find(e => -1 !== e.indexOf("msid"))) && (n[i] || (n[i] = {
                            mediaindex: o.mediaindex,
                            mid: o.mid,
                            ssrcs: {},
                            ssrcGroups: []
                        }), n[i].ssrcs[e] = o.ssrcs[e])
                    }
                }), o.ssrcGroups.forEach(e => {
                    let t = !1;
                    for (let n = 0; n < s.ssrcGroups.length; n++) {
                        const i = s.ssrcGroups[n];
                        if (e.semantics === i.semantics && r(e.ssrcs, i.ssrcs)) {
                            t = !0;
                            break
                        }
                    }
                    t || (n[i] || (n[i] = {
                        mediaindex: o.mediaindex,
                        mid: o.mid,
                        ssrcs: {},
                        ssrcGroups: []
                    }), n[i].ssrcGroups.push(e))
                })) : n[i] = o
            }), n
        }, s.prototype.toJingle = function(e) {
            const t = this.getNewMedia();
            let n = !1;
            return Object.keys(t).forEach(r => {
                n = !0;
                const s = t[r];
                e.c("content", {
                    name: s.mid
                }), e.c("description", {
                    xmlns: "urn:xmpp:jingle:apps:rtp:1",
                    media: s.mid
                }), Object.keys(s.ssrcs).forEach(t => {
                    const n = s.ssrcs[t];
                    e.c("source", {
                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                    }), e.attrs({
                        ssrc: n.ssrc
                    }), n.lines.forEach(t => {
                        const n = t.indexOf(" "),
                            r = t.substr(n + 1);
                        if (e.c("parameter"), -1 === r.indexOf(":")) e.attrs({
                            name: r
                        });
                        else {
                            const t = r.split(":", 2),
                                n = t[0],
                                s = i.a.filterSpecialChars(t[1]);
                            e.attrs({
                                name: n
                            }), e.attrs({
                                value: s
                            })
                        }
                        e.up()
                    }), e.up()
                }), s.ssrcGroups.forEach(t => {
                    t.ssrcs.length && (e.c("ssrc-group", {
                        semantics: t.semantics,
                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                    }), t.ssrcs.forEach(t => {
                        e.c("source", {
                            ssrc: t
                        }).up()
                    }), e.up())
                }), e.up(), e.up()
            }), n
        }
    }, function(e, t) {
        var n, i, r = e.exports = {};

        function s() {
            throw new Error("setTimeout has not been defined")
        }

        function o() {
            throw new Error("clearTimeout has not been defined")
        }

        function a(e) {
            if (n === setTimeout) return setTimeout(e, 0);
            if ((n === s || !n) && setTimeout) return n = setTimeout, setTimeout(e, 0);
            try {
                return n(e, 0)
            } catch (t) {
                try {
                    return n.call(null, e, 0)
                } catch (t) {
                    return n.call(this, e, 0)
                }
            }
        }! function() {
            try {
                n = "function" == typeof setTimeout ? setTimeout : s
            } catch (e) {
                n = s
            }
            try {
                i = "function" == typeof clearTimeout ? clearTimeout : o
            } catch (e) {
                i = o
            }
        }();
        var c, d = [],
            u = !1,
            l = -1;

        function h() {
            u && c && (u = !1, c.length ? d = c.concat(d) : l = -1, d.length && p())
        }

        function p() {
            if (!u) {
                var e = a(h);
                u = !0;
                for (var t = d.length; t;) {
                    for (c = d, d = []; ++l < t;) c && c[l].run();
                    l = -1, t = d.length
                }
                c = null, u = !1,
                    function(e) {
                        if (i === clearTimeout) return clearTimeout(e);
                        if ((i === o || !i) && clearTimeout) return i = clearTimeout, clearTimeout(e);
                        try {
                            i(e)
                        } catch (t) {
                            try {
                                return i.call(null, e)
                            } catch (t) {
                                return i.call(this, e)
                            }
                        }
                    }(e)
            }
        }

        function f(e, t) {
            this.fun = e, this.array = t
        }

        function m() {}
        r.nextTick = function(e) {
            var t = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
            d.push(new f(e, t)), 1 !== d.length || u || a(p)
        }, f.prototype.run = function() {
            this.fun.apply(null, this.array)
        }, r.title = "browser", r.browser = !0, r.env = {}, r.argv = [], r.version = "", r.versions = {}, r.on = m, r.addListener = m, r.once = m, r.off = m, r.removeListener = m, r.removeAllListeners = m, r.emit = m, r.prependListener = m, r.prependOnceListener = m, r.listeners = function(e) {
            return []
        }, r.binding = function(e) {
            throw new Error("process.binding is not supported")
        }, r.cwd = function() {
            return "/"
        }, r.chdir = function(e) {
            throw new Error("process.chdir is not supported")
        }, r.umask = function() {
            return 0
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return r
        }));
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        let i = null;

        function r(e, t, n) {
            this.stream = e, this.intervalId = null, this.intervalMilis = t, this.audioLevel = 0, this.callback = n
        }
        window.AudioContext && (i = new AudioContext).suspend && i.suspend(), r.prototype.start = function() {
            if (!r.isLocalStatsSupported()) return;
            i.resume();
            const e = i.createAnalyser();
            e.smoothingTimeConstant = .8, e.fftSize = 2048, i.createMediaStreamSource(this.stream).connect(e);
            const t = this;
            this.intervalId = setInterval(() => {
                const n = new Uint8Array(e.frequencyBinCount);
                e.getByteTimeDomainData(n);
                const i = function(e) {
                    let t = 0;
                    const n = e.length;
                    for (let i = 0; i < n; i++) t < e[i] && (t = e[i]);
                    return parseFloat(((t - 127) / 128).toFixed(3))
                }(n);
                i !== t.audioLevel && (t.audioLevel = function(e, t) {
                    let n = 0;
                    const i = t - e;
                    return n = i > .2 ? t - .2 : i < -.4 ? t + .4 : e, parseFloat(n.toFixed(3))
                }(i, t.audioLevel), t.callback(t.audioLevel))
            }, this.intervalMilis)
        }, r.prototype.stop = function() {
            this.intervalId && (clearInterval(this.intervalId), this.intervalId = null)
        }, r.isLocalStatsSupported = function() {
            return Boolean(i)
        }
    }, function(e, t, n) {
        const i = n(137),
            r = {
                loadScript(e, t, n, r, s, o) {
                    const a = document,
                        c = a.createElement("script"),
                        d = a.getElementsByTagName("script")[0];
                    if (c.async = t, r) {
                        const t = i();
                        if (t) {
                            const n = t.src,
                                i = n.substring(0, n.lastIndexOf("/") + 1);
                            n && i && (e = i + e)
                        }
                    }
                    s && (c.onload = s), o && (c.onerror = o), c.src = e, n ? d.parentNode.insertBefore(c, d) : d.parentNode.appendChild(c)
                }
            };
        e.exports = r
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return h
            }));
            var i = n(19),
                r = n.n(i),
                s = n(4),
                o = n(15),
                a = n(9),
                c = n(10);
            const d = Object(s.getLogger)(e),
                u = {
                    track_mute: "onmute",
                    track_unmute: "onunmute",
                    track_ended: "onended"
                };

            function l(e, t) {
                e.oninactive = t
            }
            class h extends r.a {
                constructor(e, t, n, i, r, s) {
                    super(), this.addEventListener = this.addListener, this.removeEventListener = this.off = this.removeListener, this.containers = [], this.conference = e, this.audioLevel = -1, this.type = r, this.track = n, this.videoType = s, this.handlers = new Map, this.disposed = !1, this._streamInactiveHandler = i, this._setStream(t)
                }
                _setHandler(e, t) {
                    if (u.hasOwnProperty(e)) {
                        if (t ? this.handlers.set(e, t) : this.handlers.delete(e), this.stream)
                            for (const n of this.stream.getTracks()) n[u[e]] = t
                    } else d.error(`Invalid handler type ${e}`)
                }
                _unregisterHandlers() {
                    if (this.stream) {
                        for (const e of this.handlers.keys())
                            for (const t of this.stream.getVideoTracks()) t[u[e]] = void 0;
                        this._streamInactiveHandler && l(this.stream, void 0)
                    } else d.warn(`${this}: unable to unregister handlers - no stream object`)
                }
                _setStream(e) {
                    if (this.stream !== e && (this.stream = e, this.stream)) {
                        for (const e of this.handlers.keys()) this._setHandler(e, this.handlers.get(e));
                        this._streamInactiveHandler && l(this.stream, this._streamInactiveHandler)
                    }
                }
                getType() {
                    return this.type
                }
                isAudioTrack() {
                    return this.getType() === a.a
                }
                isWebRTCTrackMuted() {
                    return this.track && this.track.muted
                }
                isVideoTrack() {
                    return this.getType() === a.c
                }
                isLocal() {
                    throw new Error("Not implemented by subclass")
                }
                isLocalAudioTrack() {
                    return this.isAudioTrack() && this.isLocal()
                }
                getOriginalStream() {
                    return this.stream
                }
                getStreamId() {
                    return this.stream ? this.stream.id : null
                }
                getTrack() {
                    return this.track
                }
                getTrackLabel() {
                    return this.track.label
                }
                getTrackId() {
                    return this.track ? this.track.id : null
                }
                getUsageLabel() {
                    return this.isAudioTrack() ? "mic" : this.videoType ? this.videoType : "default"
                }
                _maybeFireTrackAttached(e) {
                    this.conference && e && this.conference._onTrackAttach(this, e)
                }
                attach(e) {
                    this.stream && (this._onTrackAttach(e), c.a.attachMediaStream(e, this.stream)), this.containers.push(e), this._maybeFireTrackAttached(e), this._attachTTFMTracker(e)
                }
                detach(e) {
                    for (let t = this.containers, n = t.length - 1; n >= 0; --n) {
                        const i = t[n];
                        e || (this._onTrackDetach(i), c.a.attachMediaStream(i, null)), e && i !== e || t.splice(n, 1)
                    }
                    e && (this._onTrackDetach(e), c.a.attachMediaStream(e, null))
                }
                _onTrackAttach(e) {}
                _onTrackDetach(e) {}
                _attachTTFMTracker(e) {}
                dispose() {
                    return this.removeAllListeners(), this.disposed = !0, Promise.resolve()
                }
                isScreenSharing() {}
                getId() {
                    return this.stream ? c.a.getStreamID(this.stream) : null
                }
                isActive() {
                    return void 0 === this.stream.active || this.stream.active
                }
                setAudioLevel(e, t) {
                    this.audioLevel !== e && (this.audioLevel = e, this.emit(o.TRACK_AUDIO_LEVEL_CHANGED, e, t))
                }
                getMSID() {
                    const e = this.getStreamId(),
                        t = this.getTrackId();
                    return e && t ? `${e} ${t}` : null
                }
                setAudioOutput(e) {
                    return c.a.isDeviceChangeAvailable("output") ? this.isVideoTrack() ? Promise.resolve() : Promise.all(this.containers.map(t => t.setSinkId(e).catch(e => {
                        throw d.warn("Failed to change audio output device on element. Default or previously set audio output device will be used.", t, e), e
                    }))).then(() => {
                        this.emit(o.TRACK_AUDIO_OUTPUT_CHANGED, e)
                    }) : Promise.reject(new Error("Audio output device change is not supported"))
                }
            }
        }).call(this, "modules/RTC/JitsiTrack.js")
    }, function(e, t, n) {
        "use strict";

        function i(e) {
            const t = window.AudioContext || window.webkitAudioContext;
            if (t) return new t(e)
        }
        n.d(t, "a", (function() {
            return i
        }))
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return c
        }));
        var i = n(19),
            r = n.n(i),
            s = n(12),
            o = n(55),
            a = n(20);
        class c extends r.a {
            constructor(e, t, n) {
                super(), this._procNodeSampleRate = e, this._vadProcessor = t, this._localTrack = n, this._bufferResidue = new Float32Array([]), this._audioContext = Object(o.a)({
                    sampleRate: t.getRequiredPCMFrequency()
                }), this._vadSampleSize = t.getSampleLength(), this._onAudioProcess = this._onAudioProcess.bind(this), this._initializeAudioContext()
            }
            static create(e, t, n) {
                return s.a.obtainAudioAndVideoPermissions({
                    devices: ["audio"],
                    micDeviceId: e
                }).then(i => {
                    if (!i[0]) throw new Error(`Failed to create jitsi local track for device id: ${e}`);
                    return new c(t, n, i[0])
                })
            }
            _initializeAudioContext() {
                this._audioSource = this._audioContext.createMediaStreamSource(this._localTrack.stream), this._audioProcessingNode = this._audioContext.createScriptProcessor(this._procNodeSampleRate, 1, 1)
            }
            _onAudioProcess(e) {
                const t = e.inputBuffer.getChannelData(0),
                    n = [...this._bufferResidue, ...t],
                    i = Date.now();
                let r = 0;
                for (; r + this._vadSampleSize < n.length; r += this._vadSampleSize) {
                    const e = n.slice(r, r + this._vadSampleSize),
                        t = this._vadProcessor.calculateAudioFrameVAD(e.slice());
                    this.emit(a.VAD_SCORE_PUBLISHED, {
                        timestamp: i,
                        score: t,
                        pcmData: e,
                        deviceId: this._localTrack.getDeviceId()
                    })
                }
                this._bufferResidue = n.slice(r, n.length)
            }
            _connectAudioGraph() {
                this._audioProcessingNode.onaudioprocess = this._onAudioProcess, this._audioSource.connect(this._audioProcessingNode), this._audioProcessingNode.connect(this._audioContext.destination)
            }
            _disconnectAudioGraph() {
                this._audioProcessingNode.onaudioprocess = () => {}, this._audioProcessingNode.disconnect(), this._audioSource.disconnect()
            }
            _cleanupResources() {
                this._disconnectAudioGraph(), this._localTrack.stopStream()
            }
            getDeviceId() {
                return this._localTrack.getDeviceId()
            }
            getTrackLabel() {
                return this._localTrack.getDeviceLabel()
            }
            start() {
                this._connectAudioGraph()
            }
            stop() {
                this._disconnectAudioGraph(), this._bufferResidue = []
            }
            destroy() {
                this._destroyed || (this._cleanupResources(), this._destroyed = !0)
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "E2E_RTT_CHANGED", (function() {
            return i
        }));
        const i = "e2eping.e2e_rtt_changed"
    }, function(e, t, n) {
        (function(e, n) {
            var i = 200,
                r = "__lodash_hash_undefined__",
                s = 1,
                o = 2,
                a = 9007199254740991,
                c = "[object Arguments]",
                d = "[object Array]",
                u = "[object AsyncFunction]",
                l = "[object Boolean]",
                h = "[object Date]",
                p = "[object Error]",
                f = "[object Function]",
                m = "[object GeneratorFunction]",
                g = "[object Map]",
                _ = "[object Number]",
                v = "[object Null]",
                S = "[object Object]",
                y = "[object Proxy]",
                E = "[object RegExp]",
                T = "[object Set]",
                b = "[object String]",
                C = "[object Symbol]",
                R = "[object Undefined]",
                A = "[object ArrayBuffer]",
                w = "[object DataView]",
                I = /^\[object .+?Constructor\]$/,
                P = /^(?:0|[1-9]\d*)$/,
                D = {};
            D["[object Float32Array]"] = D["[object Float64Array]"] = D["[object Int8Array]"] = D["[object Int16Array]"] = D["[object Int32Array]"] = D["[object Uint8Array]"] = D["[object Uint8ClampedArray]"] = D["[object Uint16Array]"] = D["[object Uint32Array]"] = !0, D[c] = D[d] = D[A] = D[l] = D[w] = D[h] = D[p] = D[f] = D[g] = D[_] = D[S] = D[E] = D[T] = D[b] = D["[object WeakMap]"] = !1;
            var O = "object" == typeof e && e && e.Object === Object && e,
                N = "object" == typeof self && self && self.Object === Object && self,
                M = O || N || Function("return this")(),
                L = t && !t.nodeType && t,
                k = L && "object" == typeof n && n && !n.nodeType && n,
                x = k && k.exports === L,
                F = x && O.process,
                j = function() {
                    try {
                        return F && F.binding && F.binding("util")
                    } catch (e) {}
                }(),
                U = j && j.isTypedArray;

            function H(e, t) {
                for (var n = -1, i = null == e ? 0 : e.length; ++n < i;)
                    if (t(e[n], n, e)) return !0;
                return !1
            }

            function J(e) {
                var t = -1,
                    n = Array(e.size);
                return e.forEach((function(e, i) {
                    n[++t] = [i, e]
                })), n
            }

            function B(e) {
                var t = -1,
                    n = Array(e.size);
                return e.forEach((function(e) {
                    n[++t] = e
                })), n
            }
            var G, $, V, q = Array.prototype,
                K = Function.prototype,
                W = Object.prototype,
                z = M["__core-js_shared__"],
                X = K.toString,
                Q = W.hasOwnProperty,
                Y = (G = /[^.]+$/.exec(z && z.keys && z.keys.IE_PROTO || "")) ? "Symbol(src)_1." + G : "",
                Z = W.toString,
                ee = RegExp("^" + X.call(Q).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                te = x ? M.Buffer : void 0,
                ne = M.Symbol,
                ie = M.Uint8Array,
                re = W.propertyIsEnumerable,
                se = q.splice,
                oe = ne ? ne.toStringTag : void 0,
                ae = Object.getOwnPropertySymbols,
                ce = te ? te.isBuffer : void 0,
                de = ($ = Object.keys, V = Object, function(e) {
                    return $(V(e))
                }),
                ue = je(M, "DataView"),
                le = je(M, "Map"),
                he = je(M, "Promise"),
                pe = je(M, "Set"),
                fe = je(M, "WeakMap"),
                me = je(Object, "create"),
                ge = Be(ue),
                _e = Be(le),
                ve = Be(he),
                Se = Be(pe),
                ye = Be(fe),
                Ee = ne ? ne.prototype : void 0,
                Te = Ee ? Ee.valueOf : void 0;

            function be(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var i = e[t];
                    this.set(i[0], i[1])
                }
            }

            function Ce(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var i = e[t];
                    this.set(i[0], i[1])
                }
            }

            function Re(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var i = e[t];
                    this.set(i[0], i[1])
                }
            }

            function Ae(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.__data__ = new Re; ++t < n;) this.add(e[t])
            }

            function we(e) {
                var t = this.__data__ = new Ce(e);
                this.size = t.size
            }

            function Ie(e, t) {
                var n = Ve(e),
                    i = !n && $e(e),
                    r = !n && !i && qe(e),
                    s = !n && !i && !r && Qe(e),
                    o = n || i || r || s,
                    a = o ? function(e, t) {
                        for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
                        return i
                    }(e.length, String) : [],
                    c = a.length;
                for (var d in e) !t && !Q.call(e, d) || o && ("length" == d || r && ("offset" == d || "parent" == d) || s && ("buffer" == d || "byteLength" == d || "byteOffset" == d) || Je(d, c)) || a.push(d);
                return a
            }

            function Pe(e, t) {
                for (var n = e.length; n--;)
                    if (Ge(e[n][0], t)) return n;
                return -1
            }

            function De(e) {
                return null == e ? void 0 === e ? R : v : oe && oe in Object(e) ? function(e) {
                    var t = Q.call(e, oe),
                        n = e[oe];
                    try {
                        e[oe] = void 0;
                        var i = !0
                    } catch (e) {}
                    var r = Z.call(e);
                    i && (t ? e[oe] = n : delete e[oe]);
                    return r
                }(e) : function(e) {
                    return Z.call(e)
                }(e)
            }

            function Oe(e) {
                return Xe(e) && De(e) == c
            }

            function Ne(e, t, n, i, r) {
                return e === t || (null == e || null == t || !Xe(e) && !Xe(t) ? e != e && t != t : function(e, t, n, i, r, a) {
                    var u = Ve(e),
                        f = Ve(t),
                        m = u ? d : He(e),
                        v = f ? d : He(t),
                        y = (m = m == c ? S : m) == S,
                        R = (v = v == c ? S : v) == S,
                        I = m == v;
                    if (I && qe(e)) {
                        if (!qe(t)) return !1;
                        u = !0, y = !1
                    }
                    if (I && !y) return a || (a = new we), u || Qe(e) ? ke(e, t, n, i, r, a) : function(e, t, n, i, r, a, c) {
                        switch (n) {
                            case w:
                                if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
                                e = e.buffer, t = t.buffer;
                            case A:
                                return !(e.byteLength != t.byteLength || !a(new ie(e), new ie(t)));
                            case l:
                            case h:
                            case _:
                                return Ge(+e, +t);
                            case p:
                                return e.name == t.name && e.message == t.message;
                            case E:
                            case b:
                                return e == t + "";
                            case g:
                                var d = J;
                            case T:
                                var u = i & s;
                                if (d || (d = B), e.size != t.size && !u) return !1;
                                var f = c.get(e);
                                if (f) return f == t;
                                i |= o, c.set(e, t);
                                var m = ke(d(e), d(t), i, r, a, c);
                                return c.delete(e), m;
                            case C:
                                if (Te) return Te.call(e) == Te.call(t)
                        }
                        return !1
                    }(e, t, m, n, i, r, a);
                    if (!(n & s)) {
                        var P = y && Q.call(e, "__wrapped__"),
                            D = R && Q.call(t, "__wrapped__");
                        if (P || D) {
                            var O = P ? e.value() : e,
                                N = D ? t.value() : t;
                            return a || (a = new we), r(O, N, n, i, a)
                        }
                    }
                    if (!I) return !1;
                    return a || (a = new we),
                        function(e, t, n, i, r, o) {
                            var a = n & s,
                                c = xe(e),
                                d = c.length,
                                u = xe(t).length;
                            if (d != u && !a) return !1;
                            var l = d;
                            for (; l--;) {
                                var h = c[l];
                                if (!(a ? h in t : Q.call(t, h))) return !1
                            }
                            var p = o.get(e);
                            if (p && o.get(t)) return p == t;
                            var f = !0;
                            o.set(e, t), o.set(t, e);
                            var m = a;
                            for (; ++l < d;) {
                                h = c[l];
                                var g = e[h],
                                    _ = t[h];
                                if (i) var v = a ? i(_, g, h, t, e, o) : i(g, _, h, e, t, o);
                                if (!(void 0 === v ? g === _ || r(g, _, n, i, o) : v)) {
                                    f = !1;
                                    break
                                }
                                m || (m = "constructor" == h)
                            }
                            if (f && !m) {
                                var S = e.constructor,
                                    y = t.constructor;
                                S != y && "constructor" in e && "constructor" in t && !("function" == typeof S && S instanceof S && "function" == typeof y && y instanceof y) && (f = !1)
                            }
                            return o.delete(e), o.delete(t), f
                        }(e, t, n, i, r, a)
                }(e, t, n, i, Ne, r))
            }

            function Me(e) {
                return !(!ze(e) || function(e) {
                    return !!Y && Y in e
                }(e)) && (Ke(e) ? ee : I).test(Be(e))
            }

            function Le(e) {
                if (n = (t = e) && t.constructor, i = "function" == typeof n && n.prototype || W, t !== i) return de(e);
                var t, n, i, r = [];
                for (var s in Object(e)) Q.call(e, s) && "constructor" != s && r.push(s);
                return r
            }

            function ke(e, t, n, i, r, a) {
                var c = n & s,
                    d = e.length,
                    u = t.length;
                if (d != u && !(c && u > d)) return !1;
                var l = a.get(e);
                if (l && a.get(t)) return l == t;
                var h = -1,
                    p = !0,
                    f = n & o ? new Ae : void 0;
                for (a.set(e, t), a.set(t, e); ++h < d;) {
                    var m = e[h],
                        g = t[h];
                    if (i) var _ = c ? i(g, m, h, t, e, a) : i(m, g, h, e, t, a);
                    if (void 0 !== _) {
                        if (_) continue;
                        p = !1;
                        break
                    }
                    if (f) {
                        if (!H(t, (function(e, t) {
                                if (s = t, !f.has(s) && (m === e || r(m, e, n, i, a))) return f.push(t);
                                var s
                            }))) {
                            p = !1;
                            break
                        }
                    } else if (m !== g && !r(m, g, n, i, a)) {
                        p = !1;
                        break
                    }
                }
                return a.delete(e), a.delete(t), p
            }

            function xe(e) {
                return function(e, t, n) {
                    var i = t(e);
                    return Ve(e) ? i : function(e, t) {
                        for (var n = -1, i = t.length, r = e.length; ++n < i;) e[r + n] = t[n];
                        return e
                    }(i, n(e))
                }(e, Ye, Ue)
            }

            function Fe(e, t) {
                var n, i, r = e.__data__;
                return ("string" == (i = typeof(n = t)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? r["string" == typeof t ? "string" : "hash"] : r.map
            }

            function je(e, t) {
                var n = function(e, t) {
                    return null == e ? void 0 : e[t]
                }(e, t);
                return Me(n) ? n : void 0
            }
            be.prototype.clear = function() {
                this.__data__ = me ? me(null) : {}, this.size = 0
            }, be.prototype.delete = function(e) {
                var t = this.has(e) && delete this.__data__[e];
                return this.size -= t ? 1 : 0, t
            }, be.prototype.get = function(e) {
                var t = this.__data__;
                if (me) {
                    var n = t[e];
                    return n === r ? void 0 : n
                }
                return Q.call(t, e) ? t[e] : void 0
            }, be.prototype.has = function(e) {
                var t = this.__data__;
                return me ? void 0 !== t[e] : Q.call(t, e)
            }, be.prototype.set = function(e, t) {
                var n = this.__data__;
                return this.size += this.has(e) ? 0 : 1, n[e] = me && void 0 === t ? r : t, this
            }, Ce.prototype.clear = function() {
                this.__data__ = [], this.size = 0
            }, Ce.prototype.delete = function(e) {
                var t = this.__data__,
                    n = Pe(t, e);
                return !(n < 0) && (n == t.length - 1 ? t.pop() : se.call(t, n, 1), --this.size, !0)
            }, Ce.prototype.get = function(e) {
                var t = this.__data__,
                    n = Pe(t, e);
                return n < 0 ? void 0 : t[n][1]
            }, Ce.prototype.has = function(e) {
                return Pe(this.__data__, e) > -1
            }, Ce.prototype.set = function(e, t) {
                var n = this.__data__,
                    i = Pe(n, e);
                return i < 0 ? (++this.size, n.push([e, t])) : n[i][1] = t, this
            }, Re.prototype.clear = function() {
                this.size = 0, this.__data__ = {
                    hash: new be,
                    map: new(le || Ce),
                    string: new be
                }
            }, Re.prototype.delete = function(e) {
                var t = Fe(this, e).delete(e);
                return this.size -= t ? 1 : 0, t
            }, Re.prototype.get = function(e) {
                return Fe(this, e).get(e)
            }, Re.prototype.has = function(e) {
                return Fe(this, e).has(e)
            }, Re.prototype.set = function(e, t) {
                var n = Fe(this, e),
                    i = n.size;
                return n.set(e, t), this.size += n.size == i ? 0 : 1, this
            }, Ae.prototype.add = Ae.prototype.push = function(e) {
                return this.__data__.set(e, r), this
            }, Ae.prototype.has = function(e) {
                return this.__data__.has(e)
            }, we.prototype.clear = function() {
                this.__data__ = new Ce, this.size = 0
            }, we.prototype.delete = function(e) {
                var t = this.__data__,
                    n = t.delete(e);
                return this.size = t.size, n
            }, we.prototype.get = function(e) {
                return this.__data__.get(e)
            }, we.prototype.has = function(e) {
                return this.__data__.has(e)
            }, we.prototype.set = function(e, t) {
                var n = this.__data__;
                if (n instanceof Ce) {
                    var r = n.__data__;
                    if (!le || r.length < i - 1) return r.push([e, t]), this.size = ++n.size, this;
                    n = this.__data__ = new Re(r)
                }
                return n.set(e, t), this.size = n.size, this
            };
            var Ue = ae ? function(e) {
                    return null == e ? [] : (e = Object(e), function(e, t) {
                        for (var n = -1, i = null == e ? 0 : e.length, r = 0, s = []; ++n < i;) {
                            var o = e[n];
                            t(o, n, e) && (s[r++] = o)
                        }
                        return s
                    }(ae(e), (function(t) {
                        return re.call(e, t)
                    })))
                } : function() {
                    return []
                },
                He = De;

            function Je(e, t) {
                return !!(t = null == t ? a : t) && ("number" == typeof e || P.test(e)) && e > -1 && e % 1 == 0 && e < t
            }

            function Be(e) {
                if (null != e) {
                    try {
                        return X.call(e)
                    } catch (e) {}
                    try {
                        return e + ""
                    } catch (e) {}
                }
                return ""
            }

            function Ge(e, t) {
                return e === t || e != e && t != t
            }(ue && He(new ue(new ArrayBuffer(1))) != w || le && He(new le) != g || he && "[object Promise]" != He(he.resolve()) || pe && He(new pe) != T || fe && "[object WeakMap]" != He(new fe)) && (He = function(e) {
                var t = De(e),
                    n = t == S ? e.constructor : void 0,
                    i = n ? Be(n) : "";
                if (i) switch (i) {
                    case ge:
                        return w;
                    case _e:
                        return g;
                    case ve:
                        return "[object Promise]";
                    case Se:
                        return T;
                    case ye:
                        return "[object WeakMap]"
                }
                return t
            });
            var $e = Oe(function() {
                    return arguments
                }()) ? Oe : function(e) {
                    return Xe(e) && Q.call(e, "callee") && !re.call(e, "callee")
                },
                Ve = Array.isArray;
            var qe = ce || function() {
                return !1
            };

            function Ke(e) {
                if (!ze(e)) return !1;
                var t = De(e);
                return t == f || t == m || t == u || t == y
            }

            function We(e) {
                return "number" == typeof e && e > -1 && e % 1 == 0 && e <= a
            }

            function ze(e) {
                var t = typeof e;
                return null != e && ("object" == t || "function" == t)
            }

            function Xe(e) {
                return null != e && "object" == typeof e
            }
            var Qe = U ? function(e) {
                return function(t) {
                    return e(t)
                }
            }(U) : function(e) {
                return Xe(e) && We(e.length) && !!D[De(e)]
            };

            function Ye(e) {
                return null != (t = e) && We(t.length) && !Ke(t) ? Ie(e) : Le(e);
                var t
            }
            n.exports = function(e, t) {
                return Ne(e, t)
            }
        }).call(this, n(43), n(70)(e))
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return l
            })), n.d(t, "b", (function() {
                return f
            }));
            var i = n(1),
                r = n(0),
                s = n.n(r),
                o = n(24);
            const a = n(4).getLogger(e),
                c = ["category", "type", "lang", "name"],
                d = ["category", "type", "lang"],
                u = "sha-1",
                l = "Feature version mismatch";

            function h(e, t) {
                let n = 0;
                return d.some(i => 0 !== (n = e[i] > t[i] ? 1 : e[i] < t[i] && -1)), n
            }

            function p(e, t) {
                const n = e.sort(h).reduce((e, t) => `${c.reduce((e,n,i)=>e+(0===i?"":"/")+(t[n]?t[n]:""),"")}<`, ""),
                    r = t.sort().reduce((e, t) => `${e+t}<`, "");
                return Object(i.b64_sha1)(n + r)
            }
            class f extends o.a {
                constructor(e = {}, t = "http://jitsi.org/jitsimeet") {
                    if (super(), this.node = t, this.disco = e.disco, !this.disco) throw new Error("Missing strophe-plugins (disco plugin is required)!");
                    this.versionToCapabilities = Object.create(null), this.jidToVersion = Object.create(null), this.version = "", this.rooms = new Set;
                    const n = e.emuc;
                    n.addListener(s.a.EMUC_ROOM_ADDED, e => this._addChatRoom(e)), n.addListener(s.a.EMUC_ROOM_REMOVED, e => this._removeChatRoom(e)), Object.keys(n.rooms).forEach(e => {
                        this._addChatRoom(n.rooms[e])
                    }), i.Strophe.addNamespace("CAPS", "http://jabber.org/protocol/caps"), this.disco.addFeature(i.Strophe.NS.CAPS), e.addHandler(this._handleCaps.bind(this), i.Strophe.NS.CAPS), this._onMucMemberLeft = this._removeJidToVersionEntry.bind(this)
                }
                addFeature(e, t = !1) {
                    this.disco.addFeature(e), this._generateVersion(), t && this.submit()
                }
                removeFeature(e, t = !1) {
                    this.disco.removeFeature(e), this._generateVersion(), t && this.submit()
                }
                submit() {
                    this.rooms.forEach(e => e.sendPresence())
                }
                getFeatures(e, t = 5e3) {
                    const n = e in this.jidToVersion ? this.jidToVersion[e] : null;
                    if (!(n && n.version in this.versionToCapabilities)) {
                        const i = n ? `${n.node}#${n.version}` : null;
                        return this._getDiscoInfo(e, i, t).then(({
                            features: e,
                            identities: t
                        }) => {
                            if (n) {
                                const r = p(Array.from(t), Array.from(e)),
                                    s = `${n.node}#${r}`;
                                return s === i ? (this.versionToCapabilities[s] = e, e) : this.versionToCapabilities[s] ? this.versionToCapabilities[s] : (a.error(`Expected node ${i} but received ${s}`), Promise.reject(l))
                            }
                        })
                    }
                    return Promise.resolve(this.versionToCapabilities[n.version])
                }
                getFeaturesAndIdentities(e, t = 5e3) {
                    return this._getDiscoInfo(e, null, t)
                }
                _getDiscoInfo(e, t, n) {
                    return new Promise((i, r) => this.disco.info(e, t, e => {
                        const t = new Set,
                            n = new Set;
                        $(e).find(">query>feature").each((e, n) => t.add(n.getAttribute("var"))), $(e).find(">query>identity").each((e, t) => n.add({
                            type: t.getAttribute("type"),
                            name: t.getAttribute("name"),
                            category: t.getAttribute("category")
                        })), i({
                            features: t,
                            identities: n
                        })
                    }, r, n))
                }
                _addChatRoom(e) {
                    this.rooms.add(e), e.addListener(s.a.MUC_MEMBER_LEFT, this._onMucMemberLeft), this._fixChatRoomPresenceMap(e)
                }
                _removeChatRoom(e) {
                    this.rooms.delete(e), e.removeListener(s.a.MUC_MEMBER_LEFT, this._onMucMemberLeft)
                }
                _fixChatRoomPresenceMap(e) {
                    e.addToPresence("c", {
                        attributes: {
                            xmlns: i.Strophe.NS.CAPS,
                            hash: u,
                            node: this.node,
                            ver: this.version
                        }
                    })
                }
                _notifyVersionChanged() {
                    this.rooms.forEach(e => this._fixChatRoomPresenceMap(e))
                }
                _generateVersion() {
                    this.version = p(this.disco._identities, this.disco._features), this._notifyVersionChanged()
                }
                _handleCaps(e) {
                    const t = e.getAttribute("from"),
                        n = e.querySelector("c"),
                        i = n.getAttribute("ver"),
                        r = n.getAttribute("node"),
                        o = this.jidToVersion[t];
                    return this.jidToVersion[t] = {
                        version: i,
                        node: r
                    }, o && o.version !== i && this.eventEmitter.emit(s.a.PARTCIPANT_FEATURES_CHANGED, t), !0
                }
                _removeJidToVersionEntry(e) {
                    e in this.jidToVersion && delete this.jidToVersion[e]
                }
            }
        }).call(this, "modules/xmpp/Caps.js")
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "ON", (function() {
            return i
        })), n.d(t, "OFF", (function() {
            return r
        }));
        const i = "on",
            r = "off"
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return f
            })), n.d(t, "b", (function() {
                return m
            }));
            var i = n(4),
                r = n(21),
                s = n.n(r),
                o = n(15),
                a = n(3),
                c = n(8),
                d = n.n(c);
            const u = Object(i.getLogger)(e),
                l = "1",
                h = "2",
                p = "3",
                f = [l, h, p];
            class m {
                constructor(e) {
                    this.pc = e, this.simulcastEncodings = [{
                        active: !0,
                        maxBitrate: a.a.isFirefox() ? 25e5 : 2e5,
                        rid: l,
                        scaleResolutionDownBy: a.a.isFirefox() ? 1 : 4
                    }, {
                        active: !0,
                        maxBitrate: 7e5,
                        rid: h,
                        scaleResolutionDownBy: 2
                    }, {
                        active: !0,
                        maxBitrate: a.a.isFirefox() ? 2e5 : 25e5,
                        rid: p,
                        scaleResolutionDownBy: a.a.isFirefox() ? 4 : 1
                    }]
                }
                _ensureCorrectOrderOfSsrcs(e) {
                    const t = s.a.parse(e.sdp);
                    return t.media.forEach(e => {
                        if ("audio" === e.type) return;
                        if (!e.ssrcGroups || !e.ssrcGroups.length) return;
                        let t = [];
                        e.ssrcGroups[0].ssrcs.split(" ").forEach(n => {
                            const i = e.ssrcs.filter(e => e.id.toString() === n);
                            t = t.concat(i)
                        }), e.ssrcs = t
                    }), new RTCSessionDescription({
                        type: e.type,
                        sdp: s.a.write(t)
                    })
                }
                _getStreamEncodings(e) {
                    return this.pc.isSimulcastOn() && e.isVideoTrack() ? this.simulcastEncodings : [{
                        active: !0
                    }]
                }
                _insertUnifiedPlanSimulcastReceive(e) {
                    if (a.a.usesSdpMungingForSimulcast()) return e;
                    const t = s.a.parse(e.sdp),
                        n = t.media.findIndex(e => "video" === e.type);
                    if (t.media[n].rids && (t.media[n].simulcast_03 || t.media[n].simulcast)) return t.media.forEach((e, i) => {
                        "video" === e.type && i !== n && (t.media[i].rids = void 0, t.media[i].simulcast = void 0, t.media[i].simulcast_03 = void 0)
                    }), new RTCSessionDescription({
                        type: e.type,
                        sdp: s.a.write(t)
                    });
                    t.media[n].rids = [{
                        id: l,
                        direction: "recv"
                    }, {
                        id: h,
                        direction: "recv"
                    }, {
                        id: p,
                        direction: "recv"
                    }];
                    const i = a.a.isFirefox() && a.a.isVersionGreaterThan(71) ? `recv ${f.join(";")}` : `recv rid=${f.join(";")}`;
                    return t.media[n].simulcast_03 = {
                        value: i
                    }, new RTCSessionDescription({
                        type: e.type,
                        sdp: s.a.write(t)
                    })
                }
                addTrack(e, t = !0) {
                    const n = e.getTrack();
                    if (t) {
                        const t = {
                            direction: "sendrecv",
                            streams: [e.getOriginalStream()],
                            sendEncodings: []
                        };
                        a.a.isFirefox() || (t.sendEncodings = this._getStreamEncodings(e)), this.pc.peerconnection.addTransceiver(n, t)
                    } else this.pc.peerconnection.addTrack(n)
                }
                addTrackUnmute(e) {
                    const t = e.getType(),
                        n = e.getTrack(),
                        i = this.pc.peerconnection.getTransceivers().find(e => e.receiver && e.receiver.track && e.receiver.track.kind === t);
                    return i ? (u.debug(`Adding ${e} on ${this.pc}`), "recvonly" === i.direction ? (this.pc.peerconnection.addStream(e.getOriginalStream()), this.setEncodings(e), this.pc.localTracks.set(e.rtcId, e), i.direction = "sendrecv", Promise.resolve(!1)) : i.sender.replaceTrack(n).then(() => (this.pc.localTracks.set(e.rtcId, e), Promise.resolve(!1)))) : Promise.reject(new Error(`RTCRtpTransceiver for ${t} not found`))
                }
                removeTrackMute(e) {
                    const t = e.getType(),
                        n = this.pc.peerconnection.getTransceivers().find(t => t.sender && t.sender.track && t.sender.track.id === e.getTrackId());
                    return n ? (u.debug(`Removing ${e} on ${this.pc}`), n.sender.replaceTrack(null).then(() => (this.pc.localTracks.delete(e.rtcId), Promise.resolve(!1)))) : Promise.reject(new Error(`RTCRtpTransceiver for ${t} not found`))
                }
                replaceTrack(e, t) {
                    if (e && t) {
                        const n = t.getType(),
                            i = t.getOriginalStream(),
                            r = i.getVideoTracks()[0],
                            s = this.pc.peerconnection.getTransceivers().find(e => e.receiver.track.kind === n && !e.stopped);
                        return s ? (u.debug(`Replacing ${e} with ${t} on ${this.pc}`), s.sender.replaceTrack(r).then(() => {
                            const n = this.pc.localSSRCs.get(e.rtcId);
                            this.pc.localTracks.delete(e.rtcId), this.pc.localSSRCs.delete(e.rtcId), this.pc._addedStreams = this.pc._addedStreams.filter(e => e !== i), this.pc.localTracks.set(t.rtcId, t), this.pc._addedStreams.push(i), this.pc.localSSRCs.set(t.rtcId, n), this.pc.eventEmitter.emit(d.a.LOCAL_TRACK_SSRC_UPDATED, t, this.pc._extractPrimarySSRC(n))
                        })) : Promise.reject(new Error("replace track failed"))
                    }
                    if (e && !t) {
                        if (!this.removeTrackMute(e)) return Promise.reject(new Error("replace track failed"));
                        this.pc.localTracks.delete(e.rtcId), this.pc.localSSRCs.delete(e.rtcId)
                    } else if (t && !e) {
                        const e = this.pc.localSSRCs.get(t.rtcId);
                        if (!this.addTrackUnmute(t)) return Promise.reject(new Error("replace track failed"));
                        t.emit(o.TRACK_MUTE_CHANGED, t), this.pc.localTracks.set(t.rtcId, t), this.pc.localSSRCs.set(t.rtcId, e)
                    }
                    return Promise.resolve(!1)
                }
                setAudioTransferActive(e) {
                    return this.setMediaTransferActive("audio", e)
                }
                setEncodings(e) {
                    const t = this.pc.peerconnection.getTransceivers().find(t => t.sender && t.sender.track && t.sender.track.kind === e.getType()),
                        n = t.sender.getParameters();
                    n.encodings = this._getStreamEncodings(e), t.sender.setParameters(n)
                }
                setMediaTransferActive(e, t) {
                    const n = this.pc.peerconnection.getTransceivers().filter(t => t.receiver && t.receiver.track && t.receiver.track.kind === e),
                        i = Array.from(this.pc.localTracks.values()).filter(t => t.getType() === e);
                    return t ? n.forEach(e => {
                        if (i.length) {
                            e.direction = "sendrecv";
                            const t = e.sender.getParameters();
                            t && t.encodings && t.encodings.length && (t.encodings.forEach(e => {
                                e.active = !0
                            }), e.sender.setParameters(t))
                        } else e.direction = "recvonly"
                    }) : n.forEach(e => {
                        e.direction = "inactive"
                    }), !1
                }
                setVideoTransferActive(e) {
                    return this.setMediaTransferActive("video", e)
                }
            }
        }).call(this, "modules/RTC/TPCUtils.js")
    }, function(e, t) {
        e.exports = class {
            constructor(e, t, n) {
                this._userId = e, this.setDisplayName(t), this._isLocalStats = n || !1, this.setDominantSpeaker(!1), this.totalDominantSpeakerTime = 0, this._dominantSpeakerStart = 0, this._hasLeft = !1
            }
            getUserId() {
                return this._userId
            }
            getDisplayName() {
                return this.displayName
            }
            setDisplayName(e) {
                this.displayName = e
            }
            isLocalStats() {
                return this._isLocalStats
            }
            isDominantSpeaker() {
                return this._dominantSpeakerStart > 0
            }
            setDominantSpeaker(e) {
                if (!this.isDominantSpeaker() && e) this._dominantSpeakerStart = Date.now();
                else if (this.isDominantSpeaker() && !e) {
                    const e = Date.now() - this._dominantSpeakerStart;
                    this.totalDominantSpeakerTime += e, this._dominantSpeakerStart = 0
                }
            }
            getTotalDominantSpeakerTime() {
                let e = this.totalDominantSpeakerTime;
                return this.isDominantSpeaker() && (e += Date.now() - this._dominantSpeakerStart), e
            }
            hasLeft() {
                return this._hasLeft
            }
            markAsHasLeft() {
                this._hasLeft = !0, this.setDominantSpeaker(!1)
            }
        }
    }, function(e, t) {
        e.exports = {
            IDENTITY_UPDATED: "authentication.identity_updated"
        }
    }, function(module, exports, __webpack_require__) {
        (function(process, global) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            /**
             * [js-md5]{@link https://github.com/emn178/js-md5}
             *
             * @namespace md5
             * @version 0.7.3
             * @author Chen, Yi-Cyuan [emn178@gmail.com]
             * @copyright Chen, Yi-Cyuan 2014-2017
             * @license MIT
             */
            ! function() {
                "use strict";
                var ERROR = "input is invalid type",
                    WINDOW = "object" == typeof window,
                    root = WINDOW ? window : {};
                root.JS_MD5_NO_WINDOW && (WINDOW = !1);
                var WEB_WORKER = !WINDOW && "object" == typeof self,
                    NODE_JS = !root.JS_MD5_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node;
                NODE_JS ? root = global : WEB_WORKER && (root = self);
                var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && "object" == typeof module && module.exports,
                    AMD = __webpack_require__(136),
                    ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer,
                    HEX_CHARS = "0123456789abcdef".split(""),
                    EXTRA = [128, 32768, 8388608, -2147483648],
                    SHIFT = [0, 8, 16, 24],
                    OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"],
                    BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),
                    blocks = [],
                    buffer8;
                if (ARRAY_BUFFER) {
                    var buffer = new ArrayBuffer(68);
                    buffer8 = new Uint8Array(buffer), blocks = new Uint32Array(buffer)
                }!root.JS_MD5_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
                    return "[object Array]" === Object.prototype.toString.call(e)
                }), !ARRAY_BUFFER || !root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
                    return "object" == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
                });
                var createOutputMethod = function(e) {
                        return function(t) {
                            return new Md5(!0).update(t)[e]()
                        }
                    },
                    createMethod = function() {
                        var e = createOutputMethod("hex");
                        NODE_JS && (e = nodeWrap(e)), e.create = function() {
                            return new Md5
                        }, e.update = function(t) {
                            return e.create().update(t)
                        };
                        for (var t = 0; t < OUTPUT_TYPES.length; ++t) {
                            var n = OUTPUT_TYPES[t];
                            e[n] = createOutputMethod(n)
                        }
                        return e
                    },
                    nodeWrap = function(method) {
                        var crypto = eval("require('crypto')"),
                            Buffer = eval("require('buffer').Buffer"),
                            nodeMethod = function(e) {
                                if ("string" == typeof e) return crypto.createHash("md5").update(e, "utf8").digest("hex");
                                if (null == e) throw ERROR;
                                return e.constructor === ArrayBuffer && (e = new Uint8Array(e)), Array.isArray(e) || ArrayBuffer.isView(e) || e.constructor === Buffer ? crypto.createHash("md5").update(new Buffer(e)).digest("hex") : method(e)
                            };
                        return nodeMethod
                    };

                function Md5(e) {
                    if (e) blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks, this.buffer8 = buffer8;
                    else if (ARRAY_BUFFER) {
                        var t = new ArrayBuffer(68);
                        this.buffer8 = new Uint8Array(t), this.blocks = new Uint32Array(t)
                    } else this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0
                }
                Md5.prototype.update = function(e) {
                    if (!this.finalized) {
                        var t, n = typeof e;
                        if ("string" !== n) {
                            if ("object" !== n) throw ERROR;
                            if (null === e) throw ERROR;
                            if (ARRAY_BUFFER && e.constructor === ArrayBuffer) e = new Uint8Array(e);
                            else if (!(Array.isArray(e) || ARRAY_BUFFER && ArrayBuffer.isView(e))) throw ERROR;
                            t = !0
                        }
                        for (var i, r, s = 0, o = e.length, a = this.blocks, c = this.buffer8; s < o;) {
                            if (this.hashed && (this.hashed = !1, a[0] = a[16], a[16] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = a[9] = a[10] = a[11] = a[12] = a[13] = a[14] = a[15] = 0), t)
                                if (ARRAY_BUFFER)
                                    for (r = this.start; s < o && r < 64; ++s) c[r++] = e[s];
                                else
                                    for (r = this.start; s < o && r < 64; ++s) a[r >> 2] |= e[s] << SHIFT[3 & r++];
                            else if (ARRAY_BUFFER)
                                for (r = this.start; s < o && r < 64; ++s)(i = e.charCodeAt(s)) < 128 ? c[r++] = i : i < 2048 ? (c[r++] = 192 | i >> 6, c[r++] = 128 | 63 & i) : i < 55296 || i >= 57344 ? (c[r++] = 224 | i >> 12, c[r++] = 128 | i >> 6 & 63, c[r++] = 128 | 63 & i) : (i = 65536 + ((1023 & i) << 10 | 1023 & e.charCodeAt(++s)), c[r++] = 240 | i >> 18, c[r++] = 128 | i >> 12 & 63, c[r++] = 128 | i >> 6 & 63, c[r++] = 128 | 63 & i);
                            else
                                for (r = this.start; s < o && r < 64; ++s)(i = e.charCodeAt(s)) < 128 ? a[r >> 2] |= i << SHIFT[3 & r++] : i < 2048 ? (a[r >> 2] |= (192 | i >> 6) << SHIFT[3 & r++], a[r >> 2] |= (128 | 63 & i) << SHIFT[3 & r++]) : i < 55296 || i >= 57344 ? (a[r >> 2] |= (224 | i >> 12) << SHIFT[3 & r++], a[r >> 2] |= (128 | i >> 6 & 63) << SHIFT[3 & r++], a[r >> 2] |= (128 | 63 & i) << SHIFT[3 & r++]) : (i = 65536 + ((1023 & i) << 10 | 1023 & e.charCodeAt(++s)), a[r >> 2] |= (240 | i >> 18) << SHIFT[3 & r++], a[r >> 2] |= (128 | i >> 12 & 63) << SHIFT[3 & r++], a[r >> 2] |= (128 | i >> 6 & 63) << SHIFT[3 & r++], a[r >> 2] |= (128 | 63 & i) << SHIFT[3 & r++]);
                            this.lastByteIndex = r, this.bytes += r - this.start, r >= 64 ? (this.start = r - 64, this.hash(), this.hashed = !0) : this.start = r
                        }
                        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this
                    }
                }, Md5.prototype.finalize = function() {
                    if (!this.finalized) {
                        this.finalized = !0;
                        var e = this.blocks,
                            t = this.lastByteIndex;
                        e[t >> 2] |= EXTRA[3 & t], t >= 56 && (this.hashed || this.hash(), e[0] = e[16], e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0), e[14] = this.bytes << 3, e[15] = this.hBytes << 3 | this.bytes >>> 29, this.hash()
                    }
                }, Md5.prototype.hash = function() {
                    var e, t, n, i, r, s, o = this.blocks;
                    this.first ? t = ((t = ((e = ((e = o[0] - 680876937) << 7 | e >>> 25) - 271733879 << 0) ^ (n = ((n = (-271733879 ^ (i = ((i = (-1732584194 ^ 2004318071 & e) + o[1] - 117830708) << 12 | i >>> 20) + e << 0) & (-271733879 ^ e)) + o[2] - 1126478375) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[3] - 1316259209) << 22 | t >>> 10) + n << 0 : (e = this.h0, t = this.h1, n = this.h2, t = ((t += ((e = ((e += ((i = this.h3) ^ t & (n ^ i)) + o[0] - 680876936) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[1] - 389564586) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[2] + 606105819) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[3] - 1044525330) << 22 | t >>> 10) + n << 0), t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + o[4] - 176418897) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[5] + 1200080426) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[6] - 1473231341) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[7] - 45705983) << 22 | t >>> 10) + n << 0, t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + o[8] + 1770035416) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[9] - 1958414417) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[10] - 42063) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[11] - 1990404162) << 22 | t >>> 10) + n << 0, t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + o[12] + 1804603682) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[13] - 40341101) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[14] - 1502002290) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[15] + 1236535329) << 22 | t >>> 10) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[1] - 165796510) << 5 | e >>> 27) + t << 0) ^ t)) + o[6] - 1069501632) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[11] + 643717713) << 14 | n >>> 18) + i << 0) ^ i)) + o[0] - 373897302) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[5] - 701558691) << 5 | e >>> 27) + t << 0) ^ t)) + o[10] + 38016083) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[15] - 660478335) << 14 | n >>> 18) + i << 0) ^ i)) + o[4] - 405537848) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[9] + 568446438) << 5 | e >>> 27) + t << 0) ^ t)) + o[14] - 1019803690) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[3] - 187363961) << 14 | n >>> 18) + i << 0) ^ i)) + o[8] + 1163531501) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[13] - 1444681467) << 5 | e >>> 27) + t << 0) ^ t)) + o[2] - 51403784) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[7] + 1735328473) << 14 | n >>> 18) + i << 0) ^ i)) + o[12] - 1926607734) << 20 | t >>> 12) + n << 0, t = ((t += ((s = (i = ((i += ((r = t ^ n) ^ (e = ((e += (r ^ i) + o[5] - 378558) << 4 | e >>> 28) + t << 0)) + o[8] - 2022574463) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (s ^ t) + o[11] + 1839030562) << 16 | n >>> 16) + i << 0)) + o[14] - 35309556) << 23 | t >>> 9) + n << 0, t = ((t += ((s = (i = ((i += ((r = t ^ n) ^ (e = ((e += (r ^ i) + o[1] - 1530992060) << 4 | e >>> 28) + t << 0)) + o[4] + 1272893353) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (s ^ t) + o[7] - 155497632) << 16 | n >>> 16) + i << 0)) + o[10] - 1094730640) << 23 | t >>> 9) + n << 0, t = ((t += ((s = (i = ((i += ((r = t ^ n) ^ (e = ((e += (r ^ i) + o[13] + 681279174) << 4 | e >>> 28) + t << 0)) + o[0] - 358537222) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (s ^ t) + o[3] - 722521979) << 16 | n >>> 16) + i << 0)) + o[6] + 76029189) << 23 | t >>> 9) + n << 0, t = ((t += ((s = (i = ((i += ((r = t ^ n) ^ (e = ((e += (r ^ i) + o[9] - 640364487) << 4 | e >>> 28) + t << 0)) + o[12] - 421815835) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (s ^ t) + o[15] + 530742520) << 16 | n >>> 16) + i << 0)) + o[2] - 995338651) << 23 | t >>> 9) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[0] - 198630844) << 6 | e >>> 26) + t << 0) | ~n)) + o[7] + 1126891415) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[14] - 1416354905) << 15 | n >>> 17) + i << 0) | ~e)) + o[5] - 57434055) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[12] + 1700485571) << 6 | e >>> 26) + t << 0) | ~n)) + o[3] - 1894986606) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[10] - 1051523) << 15 | n >>> 17) + i << 0) | ~e)) + o[1] - 2054922799) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[8] + 1873313359) << 6 | e >>> 26) + t << 0) | ~n)) + o[15] - 30611744) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[6] - 1560198380) << 15 | n >>> 17) + i << 0) | ~e)) + o[13] + 1309151649) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[4] - 145523070) << 6 | e >>> 26) + t << 0) | ~n)) + o[11] - 1120210379) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[2] + 718787259) << 15 | n >>> 17) + i << 0) | ~e)) + o[9] - 343485551) << 21 | t >>> 11) + n << 0, this.first ? (this.h0 = e + 1732584193 << 0, this.h1 = t - 271733879 << 0, this.h2 = n - 1732584194 << 0, this.h3 = i + 271733878 << 0, this.first = !1) : (this.h0 = this.h0 + e << 0, this.h1 = this.h1 + t << 0, this.h2 = this.h2 + n << 0, this.h3 = this.h3 + i << 0)
                }, Md5.prototype.hex = function() {
                    this.finalize();
                    var e = this.h0,
                        t = this.h1,
                        n = this.h2,
                        i = this.h3;
                    return HEX_CHARS[e >> 4 & 15] + HEX_CHARS[15 & e] + HEX_CHARS[e >> 12 & 15] + HEX_CHARS[e >> 8 & 15] + HEX_CHARS[e >> 20 & 15] + HEX_CHARS[e >> 16 & 15] + HEX_CHARS[e >> 28 & 15] + HEX_CHARS[e >> 24 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[15 & t] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[15 & n] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[i >> 4 & 15] + HEX_CHARS[15 & i] + HEX_CHARS[i >> 12 & 15] + HEX_CHARS[i >> 8 & 15] + HEX_CHARS[i >> 20 & 15] + HEX_CHARS[i >> 16 & 15] + HEX_CHARS[i >> 28 & 15] + HEX_CHARS[i >> 24 & 15]
                }, Md5.prototype.toString = Md5.prototype.hex, Md5.prototype.digest = function() {
                    this.finalize();
                    var e = this.h0,
                        t = this.h1,
                        n = this.h2,
                        i = this.h3;
                    return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255, 255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255, 255 & n, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255, 255 & i, i >> 8 & 255, i >> 16 & 255, i >> 24 & 255]
                }, Md5.prototype.array = Md5.prototype.digest, Md5.prototype.arrayBuffer = function() {
                    this.finalize();
                    var e = new ArrayBuffer(16),
                        t = new Uint32Array(e);
                    return t[0] = this.h0, t[1] = this.h1, t[2] = this.h2, t[3] = this.h3, e
                }, Md5.prototype.buffer = Md5.prototype.arrayBuffer, Md5.prototype.base64 = function() {
                    for (var e, t, n, i = "", r = this.array(), s = 0; s < 15;) e = r[s++], t = r[s++], n = r[s++], i += BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[63 & (e << 4 | t >>> 4)] + BASE64_ENCODE_CHAR[63 & (t << 2 | n >>> 6)] + BASE64_ENCODE_CHAR[63 & n];
                    return e = r[s], i += BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[e << 4 & 63] + "=="
                };
                var exports = createMethod();
                COMMON_JS ? module.exports = exports : (root.md5 = exports, AMD && (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return exports
                }.call(exports, __webpack_require__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)))
            }()
        }).call(this, __webpack_require__(51), __webpack_require__(43))
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return y
            }));
            var i = n(4),
                r = n(54),
                s = n(16),
                o = n(13),
                a = n(15),
                c = n(3),
                d = n(10),
                u = n(41),
                l = n.n(u),
                h = n(9),
                p = n(8),
                f = n.n(p),
                m = n(14),
                g = n.n(m),
                _ = n(7),
                v = n(5);
            const S = Object(i.getLogger)(e);
            class y extends r.a {
                constructor({
                    deviceId: e,
                    facingMode: t,
                    mediaType: n,
                    resolution: i,
                    rtcId: r,
                    sourceId: s,
                    sourceType: o,
                    stream: u,
                    track: l,
                    videoType: h,
                    effects: p = []
                }) {
                    super(null, u, l, () => this.emit(a.LOCAL_TRACK_STOPPED), n, h), this._setEffectInProgress = !1;
                    const m = p.find(e => e.isEnabled(this));
                    m && this._startStreamEffect(m), this.rtcId = r, this.sourceId = s, this.sourceType = o, c.a.usesNewGumFlow() ? (this.resolution = l.getSettings().height, this._constraints = l.getConstraints(), Object.keys(this._constraints).length || h !== g.a.CAMERA || (this._constraints = {
                        height: l.getSettings().height,
                        width: l.getSettings().width
                    })) : this.resolution = c.a.isFirefox() ? null : i, this.deviceId = e, this._prevSetMuted = Promise.resolve(), this._facingMode = t, this._trackEnded = !1, this._hasSentData = !1, this._testDataSent = !0, this._realDeviceId = "" === this.deviceId ? void 0 : this.deviceId, this._trackMutedTS = 0, this._onDeviceListWillChange = e => {
                        const t = this._realDeviceId;
                        this._setRealDeviceIdFromDeviceList(e), (void 0 === this.getTrack().readyState && void 0 !== this._realDeviceId && !e.find(e => e.deviceId === this._realDeviceId) || void 0 !== t && void 0 === this._realDeviceId) && (this._trackEnded = !0)
                    }, this.isAudioTrack() && d.a.isDeviceChangeAvailable("output") && (this._onAudioOutputDeviceChanged = this.setAudioOutput.bind(this), d.a.addListener(f.a.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged)), d.a.addListener(f.a.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._initNoDataFromSourceHandlers()
                }
                isEnded() {
                    return this.isVideoTrack() && this.isMuted() ? this._trackEnded : "ended" === this.getTrack().readyState || this._trackEnded
                }
                _initNoDataFromSourceHandlers() {
                    this._isNoDataFromSourceEventsEnabled() && (this._setHandler("track_mute", () => {
                        this._trackMutedTS = window.performance.now(), this._fireNoDataFromSourceEvent()
                    }), this._setHandler("track_unmute", () => {
                        this._fireNoDataFromSourceEvent(), v.a.sendAnalyticsAndLog(_.s, {
                            media_type: this.getType(),
                            track_type: "local",
                            value: window.performance.now() - this._trackMutedTS
                        })
                    }), this.isVideoTrack() && this.videoType === g.a.CAMERA && this._setHandler("track_ended", () => {
                        this.isReceivingData() || this._fireNoDataFromSourceEvent()
                    }))
                }
                _isNoDataFromSourceEventsEnabled() {
                    return !this.isVideoTrack() || this.videoType !== g.a.DESKTOP
                }
                _fireNoDataFromSourceEvent() {
                    const e = !this.isReceivingData();
                    this.emit(a.NO_DATA_FROM_SOURCE, e), v.a.sendAnalytics(Object(_.H)(this.getType(), e)), v.a.sendLog(JSON.stringify({
                        name: a.NO_DATA_FROM_SOURCE,
                        log: e
                    }))
                }
                _setRealDeviceIdFromDeviceList(e) {
                    const t = this.getTrack(),
                        n = `${t.kind}input`;
                    let i = e.find(e => e.kind === n && e.label === t.label);
                    if (!i && "default" === this._realDeviceId) {
                        const r = (t.label || "").replace("Default - ", "");
                        i = e.find(e => e.kind === n && e.label === r)
                    }
                    this._realDeviceId = i ? i.deviceId : void 0
                }
                _setStream(e) {
                    super._setStream(e), e ? (this.storedMSID = this.getMSID(), S.debug(`Setting new MSID: ${this.storedMSID} on ${this}`)) : S.debug(`Setting 'null' stream on ${this}`)
                }
                _startStreamEffect(e) {
                    this._streamEffect = e, this._originalStream = this.stream, this._setStream(this._streamEffect.startEffect(this._originalStream))
                }
                _stopStreamEffect() {
                    this._streamEffect && (this._streamEffect.stopEffect(), this._setStream(this._originalStream))
                }
                _switchStreamEffect(e) {
                    this._streamEffect && (this._stopStreamEffect(), this._streamEffect = void 0), e && this._startStreamEffect(e)
                }
                setEffect(e) {
                    if (void 0 === this._streamEffect && void 0 === e) return Promise.resolve();
                    if (void 0 !== e && !e.isEnabled(this)) return Promise.reject(new Error("Incompatible effect instance!"));
                    if (!0 === this._setEffectInProgress) return Promise.reject(new Error("setEffect already in progress!"));
                    if (this.isMuted() && !this.isAudioTrack()) return this._streamEffect = e, Promise.resolve();
                    const t = this.conference;
                    return t ? (this._setEffectInProgress = !0, c.a.usesUnifiedPlan() ? (this._switchStreamEffect(e), this.isVideoTrack() && this.containers.forEach(e => d.a.attachMediaStream(e, this.stream)), t.replaceTrack(this, this).then(() => {
                        this._setEffectInProgress = !1
                    }).catch(e => {
                        throw this._setEffectInProgress = !1, this._switchStreamEffect(), S.error("Failed to switch to the new stream!", e), e
                    })) : t.removeTrack(this).then(() => (this._switchStreamEffect(e), this.isVideoTrack() && this.containers.forEach(e => d.a.attachMediaStream(e, this.stream)), t.addTrack(this))).then(() => {
                        this._setEffectInProgress = !1
                    }).catch(e => {
                        throw this._setEffectInProgress = !1, this._switchStreamEffect(), S.error("Failed to switch to the new stream!", e), e
                    })) : (this._switchStreamEffect(e), Promise.resolve())
                }
                mute() {
                    return this._queueSetMuted(!0)
                }
                unmute() {
                    return this._queueSetMuted(!1)
                }
                _queueSetMuted(e) {
                    const t = this._setMuted.bind(this, e);
                    return this._prevSetMuted = this._prevSetMuted.then(t, t), this._prevSetMuted
                }
                _setMuted(e) {
                    if (this.isMuted() === e) return Promise.resolve();
                    if (this.disposed) return Promise.reject(new s.a(o.TRACK_IS_DISPOSED));
                    let t = Promise.resolve();
                    const n = () => S.info(`Mute ${this}: ${e}`);
                    if (this.isAudioTrack() || this.videoType === g.a.DESKTOP || !c.a.doesVideoMuteByStreamRemove()) n(), this.track && (this.track.enabled = !e);
                    else if (e) t = new Promise((e, t) => {
                        n(), this._removeStreamFromConferenceAsMute(() => {
                            this._streamEffect && this._stopStreamEffect(), this._unregisterHandlers(), this.stopStream(), this._setStream(null), e()
                        }, t)
                    });
                    else {
                        n();
                        const e = {
                            cameraDeviceId: this.getDeviceId(),
                            devices: [h.c],
                            effects: this._streamEffect ? [this._streamEffect] : [],
                            facingMode: this.getCameraFacingMode()
                        };
                        c.a.usesNewGumFlow() ? t = d.a.newObtainAudioAndVideoPermissions(Object.assign({}, e, {
                            constraints: {
                                video: this._constraints
                            }
                        })) : (this.resolution && (e.resolution = this.resolution), t = d.a.obtainAudioAndVideoPermissions(e)), t.then(e => {
                            const t = this.getType() === h.b ? h.c : this.getType(),
                                n = c.a.usesNewGumFlow() ? e.find(e => e.track.kind === t) : e.find(e => e.mediaType === t);
                            if (!n) throw new s.a(o.TRACK_NO_STREAM_FOUND);
                            return this._setStream(n.stream), this.track = n.track, this.videoType !== n.videoType && (S.warn(`${this}: video type has changed after unmute!`, this.videoType, n.videoType), this.videoType = n.videoType), this._streamEffect && this._startStreamEffect(this._streamEffect), this.containers.map(e => d.a.attachMediaStream(e, this.stream)), this._addStreamToConferenceAsUnmute()
                        })
                    }
                    return t.then(() => this._sendMuteStatus(e)).then(() => this.emit(a.TRACK_MUTE_CHANGED, this))
                }
                _addStreamToConferenceAsUnmute() {
                    return this.conference ? new Promise((e, t) => {
                        this.conference._addLocalTrackAsUnmute(this).then(e, e => t(new Error(e)))
                    }) : Promise.resolve()
                }
                _removeStreamFromConferenceAsMute(e, t) {
                    this.conference ? this.conference._removeLocalTrackAsMute(this).then(e, e => t(new Error(e))) : e()
                }
                _sendMuteStatus(e) {
                    return this.conference && this.conference.room ? new Promise(t => {
                        this.conference.room[this.isAudioTrack() ? "setAudioMute" : "setVideoMute"](e, t)
                    }) : Promise.resolve()
                }
                dispose() {
                    this._switchStreamEffect();
                    let e = Promise.resolve();
                    return this.conference && (e = this.conference.removeTrack(this)), this.stream && (this.stopStream(), this.detach()), d.a.removeListener(f.a.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._onAudioOutputDeviceChanged && d.a.removeListener(f.a.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged), e.then(() => super.dispose())
                }
                isMuted() {
                    return !this.stream || (!(!this.isVideoTrack() || this.isActive()) || (!this.track || !this.track.enabled))
                }
                _setConference(e) {
                    this.conference = e;
                    for (let e = 0; e < this.containers.length; e++) this._maybeFireTrackAttached(this.containers[e])
                }
                isLocal() {
                    return !0
                }
                getDeviceId() {
                    return this._realDeviceId || this.deviceId
                }
                getParticipantId() {
                    return this.conference && this.conference.myUserId()
                }
                _onByteSentStatsReceived(e, t) {
                    t > 0 && (this._hasSentData = !0);
                    const n = e.getConnectionState();
                    this._testDataSent && "connected" === n && (setTimeout(() => {
                        this._hasSentData || (S.warn(`${this} 'bytes sent' <= 0:                         ${t}`), v.a.analytics.sendEvent(_.r, {
                            media_type: this.getType()
                        }))
                    }, 3e3), this._testDataSent = !1)
                }
                getCameraFacingMode() {
                    if (this.isVideoTrack() && this.videoType === g.a.CAMERA) {
                        let e;
                        try {
                            e = this.track.getSettings()
                        } catch (e) {}
                        return e && "facingMode" in e ? e.facingMode : void 0 !== this._facingMode ? this._facingMode : l.a.USER
                    }
                }
                stopStream() {
                    this._stopStreamInProgress = !0;
                    try {
                        d.a.stopMediaStream(this.stream)
                    } finally {
                        this._stopStreamInProgress = !1
                    }
                }
                _switchCamera() {
                    this.isVideoTrack() && this.videoType === g.a.CAMERA && "function" == typeof this.track._switchCamera && (this.track._switchCamera(), this._facingMode = this._facingMode === l.a.ENVIRONMENT ? l.a.USER : l.a.ENVIRONMENT)
                }
                isReceivingData() {
                    if (this.isVideoTrack() && (this.isMuted() || this._stopStreamInProgress || this.videoType === g.a.DESKTOP)) return !0;
                    if (!this.stream) return !1;
                    return (this._effectEnabled ? this._originalStream : this.stream).getTracks().some(e => !("readyState" in e && "live" !== e.readyState || "muted" in e && !0 === e.muted))
                }
                toString() {
                    return `LocalTrack[${this.rtcId},${this.getType()}]`
                }
            }
        }).call(this, "modules/RTC/JitsiLocalTrack.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return u
            }));
            var i = n(19),
                r = n(4),
                s = n(2),
                o = n(20),
                a = n(56);
            const c = Object(r.getLogger)(e),
                d = 4096;
            class u extends i.EventEmitter {
                constructor(e, t) {
                    super(), this._createVADProcessor = t, this._vadEmitter = null, this._isVADEmitterRunning = !1, this._detectionServices = [], this._vadInitTracker = Promise.resolve(), this._processVADScore = this._processVADScore.bind(this), e.on(s.TRACK_ADDED, this._trackAdded.bind(this)), e.on(s.TRACK_REMOVED, this._trackRemoved.bind(this)), e.on(s.TRACK_MUTE_CHANGED, this._trackMuteChanged.bind(this))
                }
                addVADDetectionService(e) {
                    this._detectionServices.push(e), e.on(o.DETECTOR_STATE_CHANGE, () => {
                        !this._detectionServices.filter(e => !0 === e.isActive()).length && this._isVADEmitterRunning ? this._stopVADEmitter() : this._isVADEmitterRunning || this._startVADEmitter()
                    })
                }
                _startVADEmitter() {
                    this._vadEmitter.on(o.VAD_SCORE_PUBLISHED, this._processVADScore), this._vadEmitter.start(), this._isVADEmitterRunning = !0
                }
                _stopVADEmitter() {
                    this._vadEmitter.removeListener(o.VAD_SCORE_PUBLISHED, this._processVADScore), this._vadEmitter.stop(), this._isVADEmitterRunning = !1
                }
                _processVADScore(e) {
                    for (const t of this._detectionServices) t.processVADScore(e)
                }
                _changeDetectorsMuteState(e) {
                    for (const t of this._detectionServices) t.changeMuteState(e)
                }
                _trackAdded(e) {
                    e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then(() => this._createVADProcessor()).then(t => a.a.create(e.getDeviceId(), d, t)).then(t => {
                        c.debug("Created VAD emitter for track: ", e.getTrackLabel()), this._vadEmitter = t, this._changeDetectorsMuteState(e.isMuted())
                    }))
                }
                _trackMuteChanged(e) {
                    e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then(() => {
                        this._changeDetectorsMuteState(e.isMuted())
                    }))
                }
                _trackRemoved(e) {
                    e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then(() => {
                        c.debug("Removing track from VAD detection - ", e.getTrackLabel()), this._vadEmitter && (this._stopVADEmitter(), this._vadEmitter.destroy(), this._vadEmitter = null);
                        for (const e of this._detectionServices) e.reset()
                    }))
                }
            }
        }).call(this, "modules/detection/VADAudioAnalyser.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return s
        }));
        var i = n(1),
            r = n(46);
        class s {
            constructor(e = {}) {
                this._connection = e.connection, this._mode = e.mode, this._setSessionID(e.sessionID), this.setStatus(e.status)
            }
            getError() {
                return this._error
            }
            getID() {
                return this._sessionID
            }
            getInitiator() {
                return this._initiator
            }
            getLiveStreamViewURL() {
                return this._liveStreamViewURL
            }
            getStatus() {
                return this._status
            }
            getTerminator() {
                return this._terminator
            }
            getMode() {
                return this._mode
            }
            setError(e) {
                this._error = e
            }
            setLiveStreamViewURL(e) {
                this._liveStreamViewURL = e
            }
            setStatus(e) {
                this._status = e
            }
            setInitiator(e) {
                this._initiator = e
            }
            setTerminator(e) {
                this._terminator = e
            }
            start({
                appData: e,
                broadcastId: t,
                focusMucJid: n,
                streamId: i
            }) {
                return new Promise((s, o) => {
                    this._connection.sendIQ(this._createIQ({
                        action: "start",
                        appData: e,
                        focusMucJid: n,
                        broadcastId: t,
                        streamId: i
                    }), e => {
                        this.setStatus("pending"), this._setSessionID(r.a.getSessionIdFromIq(e)), s()
                    }, e => {
                        this._setErrorFromIq(e), o(e)
                    })
                })
            }
            stop({
                focusMucJid: e
            }) {
                return new Promise((t, n) => {
                    this._connection.sendIQ(this._createIQ({
                        action: "stop",
                        focusMucJid: e
                    }), t, n)
                })
            }
            _createIQ({
                action: e,
                appData: t,
                broadcastId: n,
                focusMucJid: r,
                streamId: s
            }) {
                return Object(i.$iq)({
                    to: r,
                    type: "set"
                }).c("jibri", {
                    xmlns: "http://jitsi.org/protocol/jibri",
                    action: e,
                    app_data: t,
                    recording_mode: this._mode,
                    streamid: s,
                    you_tube_broadcast_id: n
                }).up()
            }
            _setErrorFromIq(e) {
                const t = e.getElementsByTagName("error")[0];
                this.setError(t.children[0].tagName)
            }
            _setSessionID(e) {
                this._sessionID = e
            }
        }
    }, function(e, t, n) {
        "use strict";
        var i = n(19),
            r = n.n(i),
            s = n(9),
            o = n(3),
            a = n(12),
            c = n(8),
            d = n.n(c),
            u = n(5),
            l = n(48);

        function h(e, t, n) {
            return t in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n, e
        }
        const p = "microphone",
            f = "granted",
            m = "camera";
        t.a = new class {
            constructor() {
                this._eventEmitter = new r.a, this._grantedPermissions = {}, a.a.addListener(d.a.DEVICE_LIST_CHANGED, e => this._eventEmitter.emit(l.DEVICE_LIST_CHANGED, e)), a.a.addListener(d.a.DEVICE_LIST_AVAILABLE, e => this._logOutputDevice(this.getAudioOutputDevice(), e)), a.a.addListener(d.a.GRANTED_PERMISSIONS, e => this._handleGrantedPermissions(e)), this._permissionsApiSupported = new Promise(e => {
                    navigator.permissions ? navigator.permissions.query({
                        name: m
                    }).then(() => e(!0), () => e(!1)) : e(!1)
                })
            }
            _handleGrantedPermissions(e) {
                this._grantedPermissions = function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = null != arguments[t] ? arguments[t] : {},
                            i = Object.keys(n);
                        "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                            return Object.getOwnPropertyDescriptor(n, e).enumerable
                        })))), i.forEach((function(t) {
                            h(e, t, n[t])
                        }))
                    }
                    return e
                }({}, this._grantedPermissions, e)
            }
            _logOutputDevice(e, t) {
                const n = t.find(t => "audiooutput" === t.kind && t.deviceId === e);
                n && u.a.sendActiveDeviceListEvent(a.a.getEventDataForActiveDevice(n))
            }
            enumerateDevices(e) {
                a.a.enumerateDevices(e)
            }
            isDeviceListAvailable() {
                return a.a.isDeviceListAvailable()
            }
            isDeviceChangeAvailable(e) {
                return a.a.isDeviceChangeAvailable(e)
            }
            isDevicePermissionGranted(e) {
                return new Promise(t => {
                    e in this._grantedPermissions ? t(this._grantedPermissions[e]) : this._permissionsApiSupported.then(n => {
                        if (!n) return void t(!1);
                        const i = [];
                        switch (e) {
                            case s.c:
                                i.push(navigator.permissions.query({
                                    name: m
                                }));
                                break;
                            case s.a:
                                i.push(navigator.permissions.query({
                                    name: p
                                }));
                                break;
                            default:
                                i.push(navigator.permissions.query({
                                    name: m
                                })), i.push(navigator.permissions.query({
                                    name: p
                                }))
                        }
                        Promise.all(i).then(e => t(e.every(e => {
                            return (e.state || e.status) === f
                        })), () => t(!1))
                    })
                })
            }
            isMultipleAudioInputSupported() {
                return !o.a.isFirefox()
            }
            getAudioOutputDevice() {
                return a.a.getAudioOutputDevice()
            }
            setAudioOutputDevice(e) {
                const t = a.a.getCurrentlyAvailableMediaDevices();
                return t && t.length > 0 && this._logOutputDevice(e, a.a.getCurrentlyAvailableMediaDevices()), a.a.setAudioOutputDevice(e)
            }
            addEventListener(e, t) {
                this._eventEmitter.addListener(e, t)
            }
            removeEventListener(e, t) {
                this._eventEmitter.removeListener(e, t)
            }
            emitEvent(e, ...t) {
                this._eventEmitter.emit(e, ...t)
            }
            supportsVideo() {
                return o.a.supportsVideo()
            }
        }
    }, function(e, t) {
        var n = {
            trace: 0,
            debug: 1,
            info: 2,
            log: 3,
            warn: 4,
            error: 5
        };
        o.consoleTransport = console;
        var i = [o.consoleTransport];
        o.addGlobalTransport = function(e) {
            -1 === i.indexOf(e) && i.push(e)
        }, o.removeGlobalTransport = function(e) {
            var t = i.indexOf(e); - 1 !== t && i.splice(t, 1)
        };
        var r = {};

        function s() {
            var e = arguments[0],
                t = arguments[1],
                s = Array.prototype.slice.call(arguments, 2);
            if (!(n[t] < e.level))
                for (var o = !(e.options.disableCallerInfo || r.disableCallerInfo) && function() {
                        var e = {
                                methodName: "",
                                fileLocation: "",
                                line: null,
                                column: null
                            },
                            t = new Error,
                            n = t.stack ? t.stack.split("\n") : [];
                        if (!n || n.length < 1) return e;
                        var i = null;
                        return n[3] && (i = n[3].match(/\s*at\s*(.+?)\s*\((\S*)\s*:(\d*)\s*:(\d*)\)/)), !i || i.length <= 4 ? (0 === n[2].indexOf("log@") ? e.methodName = n[3].substr(0, n[3].indexOf("@")) : e.methodName = n[2].substr(0, n[2].indexOf("@")), e) : (e.methodName = i[1], e.fileLocation = i[2], e.line = i[3], e.column = i[4], e)
                    }(), a = i.concat(e.transports), c = 0; c < a.length; c++) {
                    var d = a[c],
                        u = d[t];
                    if (u && "function" == typeof u) {
                        var l = [];
                        l.push((new Date).toISOString()), e.id && l.push("[" + e.id + "]"), o && o.methodName.length > 1 && l.push("<" + o.methodName + ">: ");
                        var h = l.concat(s);
                        u.bind(d).apply(d, h)
                    }
                }
        }

        function o(e, t, i, r) {
            this.id = t, this.options = r || {}, this.transports = i, this.transports || (this.transports = []), this.level = n[e];
            for (var o = Object.keys(n), a = 0; a < o.length; a++) this[o[a]] = s.bind(null, this, o[a])
        }
        o.setGlobalOptions = function(e) {
            r = e || {}
        }, o.prototype.setLevel = function(e) {
            this.level = n[e]
        }, e.exports = o, o.levels = {
            TRACE: "trace",
            DEBUG: "debug",
            INFO: "info",
            LOG: "log",
            WARN: "warn",
            ERROR: "error"
        }
    }, function(e, t) {
        e.exports = function(e) {
            return e.webpackPolyfill || (e.deprecate = function() {}, e.paths = [], e.children || (e.children = []), Object.defineProperty(e, "loaded", {
                enumerable: !0,
                get: function() {
                    return e.l
                }
            }), Object.defineProperty(e, "id", {
                enumerable: !0,
                get: function() {
                    return e.i
                }
            }), e.webpackPolyfill = 1), e
        }
    }, function(e, t) {
        var n = e.exports = {
            v: [{
                name: "version",
                reg: /^(\d*)$/
            }],
            o: [{
                name: "origin",
                reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
                names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
                format: "%s %s %d %s IP%d %s"
            }],
            s: [{
                name: "name"
            }],
            i: [{
                name: "description"
            }],
            u: [{
                name: "uri"
            }],
            e: [{
                name: "email"
            }],
            p: [{
                name: "phone"
            }],
            z: [{
                name: "timezones"
            }],
            r: [{
                name: "repeats"
            }],
            t: [{
                name: "timing",
                reg: /^(\d*) (\d*)/,
                names: ["start", "stop"],
                format: "%d %d"
            }],
            c: [{
                name: "connection",
                reg: /^IN IP(\d) (\S*)/,
                names: ["version", "ip"],
                format: "IN IP%d %s"
            }],
            b: [{
                push: "bandwidth",
                reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
                names: ["type", "limit"],
                format: "%s:%s"
            }],
            m: [{
                reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
                names: ["type", "port", "protocol", "payloads"],
                format: "%s %d %s %s"
            }],
            a: [{
                push: "rtp",
                reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
                names: ["payload", "codec", "rate", "encoding"],
                format: function(e) {
                    return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
                }
            }, {
                push: "fmtp",
                reg: /^fmtp:(\d*) ([\S| ]*)/,
                names: ["payload", "config"],
                format: "fmtp:%d %s"
            }, {
                name: "control",
                reg: /^control:(.*)/,
                format: "control:%s"
            }, {
                name: "rtcp",
                reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                names: ["port", "netType", "ipVer", "address"],
                format: function(e) {
                    return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
                }
            }, {
                push: "rtcpFbTrrInt",
                reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                names: ["payload", "value"],
                format: "rtcp-fb:%d trr-int %d"
            }, {
                push: "rtcpFb",
                reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                names: ["payload", "type", "subtype"],
                format: function(e) {
                    return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
                }
            }, {
                push: "ext",
                reg: /^extmap:(\d+)(?:\/(\w+))? (\S*)(?: (\S*))?/,
                names: ["value", "direction", "uri", "config"],
                format: function(e) {
                    return "extmap:%d" + (e.direction ? "/%s" : "%v") + " %s" + (e.config ? " %s" : "")
                }
            }, {
                push: "crypto",
                reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                names: ["id", "suite", "config", "sessionConfig"],
                format: function(e) {
                    return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
                }
            }, {
                name: "setup",
                reg: /^setup:(\w*)/,
                format: "setup:%s"
            }, {
                name: "mid",
                reg: /^mid:([^\s]*)/,
                format: "mid:%s"
            }, {
                name: "msid",
                reg: /^msid:(.*)/,
                format: "msid:%s"
            }, {
                name: "ptime",
                reg: /^ptime:(\d*)/,
                format: "ptime:%d"
            }, {
                name: "maxptime",
                reg: /^maxptime:(\d*)/,
                format: "maxptime:%d"
            }, {
                name: "direction",
                reg: /^(sendrecv|recvonly|sendonly|inactive)/
            }, {
                name: "icelite",
                reg: /^(ice-lite)/
            }, {
                name: "iceUfrag",
                reg: /^ice-ufrag:(\S*)/,
                format: "ice-ufrag:%s"
            }, {
                name: "icePwd",
                reg: /^ice-pwd:(\S*)/,
                format: "ice-pwd:%s"
            }, {
                name: "fingerprint",
                reg: /^fingerprint:(\S*) (\S*)/,
                names: ["type", "hash"],
                format: "fingerprint:%s %s"
            }, {
                push: "candidates",
                reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
                names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
                format: function(e) {
                    var t = "candidate:%s %d %s %d %s %d typ %s";
                    return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), t += null != e["network-id"] ? " network-id %d" : "%v", t += null != e["network-cost"] ? " network-cost %d" : "%v"
                }
            }, {
                name: "endOfCandidates",
                reg: /^(end-of-candidates)/
            }, {
                name: "remoteCandidates",
                reg: /^remote-candidates:(.*)/,
                format: "remote-candidates:%s"
            }, {
                name: "iceOptions",
                reg: /^ice-options:(\S*)/,
                format: "ice-options:%s"
            }, {
                push: "ssrcs",
                reg: /^ssrc:(\d*) ([\w_]*)(?::(.*))?/,
                names: ["id", "attribute", "value"],
                format: function(e) {
                    var t = "ssrc:%d";
                    return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
                }
            }, {
                push: "ssrcGroups",
                reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
                names: ["semantics", "ssrcs"],
                format: "ssrc-group:%s %s"
            }, {
                name: "msidSemantic",
                reg: /^msid-semantic:\s?(\w*) (\S*)/,
                names: ["semantic", "token"],
                format: "msid-semantic: %s %s"
            }, {
                push: "groups",
                reg: /^group:(\w*) (.*)/,
                names: ["type", "mids"],
                format: "group:%s %s"
            }, {
                name: "rtcpMux",
                reg: /^(rtcp-mux)/
            }, {
                name: "rtcpRsize",
                reg: /^(rtcp-rsize)/
            }, {
                name: "sctpmap",
                reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
                names: ["sctpmapNumber", "app", "maxMessageSize"],
                format: function(e) {
                    return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
                }
            }, {
                name: "xGoogleFlag",
                reg: /^x-google-flag:([^\s]*)/,
                format: "x-google-flag:%s"
            }, {
                push: "rids",
                reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
                names: ["id", "direction", "params"],
                format: function(e) {
                    return e.params ? "rid:%s %s %s" : "rid:%s %s"
                }
            }, {
                push: "imageattrs",
                reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
                names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
                format: function(e) {
                    return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
                }
            }, {
                name: "simulcast",
                reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
                names: ["dir1", "list1", "dir2", "list2"],
                format: function(e) {
                    return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
                }
            }, {
                name: "simulcast_03",
                reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
                names: ["value"],
                format: "simulcast: %s"
            }, {
                name: "framerate",
                reg: /^framerate:(\d+(?:$|\.\d+))/,
                format: "framerate:%s"
            }, {
                push: "invalid",
                names: ["value"]
            }]
        };
        Object.keys(n).forEach((function(e) {
            n[e].forEach((function(e) {
                e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
            }))
        }))
    }, function(e, t, n) {
        const i = n(147),
            r = "audio/webm",
            s = "audio/ogg",
            o = function(e) {
                this.track = e, this.recorder = null, this.data = null, this.name = null, this.startTime = null
            };

        function a(e) {
            if (void 0 === e.recorder) throw new Error("Passed an object to startRecorder which is not a TrackRecorder object");
            e.recorder.start(), e.startTime = new Date
        }

        function c(e) {
            if (void 0 === e.recorder) throw new Error("Passed an object to stopRecorder which is not a TrackRecorder object");
            e.recorder.stop()
        }

        function d() {
            if (MediaRecorder.isTypeSupported(r)) return r;
            if (MediaRecorder.isTypeSupported(s)) return s;
            throw new Error("unable to create a MediaRecorder with the right mimetype!")
        }

        function u(e) {
            this.recorders = [], this.fileType = d(), this.isRecording = !1, this.jitsiConference = e
        }
        u.determineCorrectFileType = d, u.prototype.addTrack = function(e) {
            if (e.isAudioTrack()) {
                const t = this.instantiateTrackRecorder(e);
                this.recorders.push(t), this.updateNames(), this.isRecording && a(t)
            }
        }, u.prototype.instantiateTrackRecorder = function(e) {
            const t = new o(e),
                n = t.track.getOriginalStream(),
                i = function() {
                    if ("undefined" != typeof MediaStream) return new MediaStream;
                    throw new Error("cannot create a clean mediaStream")
                }();
            return n.getAudioTracks().forEach(e => i.addTrack(e)), t.recorder = new MediaRecorder(i, {
                mimeType: this.fileType
            }), t.data = [], t.recorder.ondataavailable = function(e) {
                e.data.size > 0 && t.data.push(e.data)
            }, t
        }, u.prototype.removeTrack = function(e) {
            if (e.isVideoTrack()) return;
            const t = this.recorders;
            let n;
            for (n = 0; n < t.length; n++)
                if (t[n].track.getParticipantId() === e.getParticipantId()) {
                    const e = t[n];
                    this.isRecording ? c(e) : t.splice(n, 1)
                } this.updateNames()
        }, u.prototype.updateNames = function() {
            const e = this.jitsiConference;
            this.recorders.forEach(t => {
                if (t.track.isLocal()) t.name = "the transcriber";
                else {
                    const n = t.track.getParticipantId(),
                        i = e.getParticipantById(n).getDisplayName();
                    "undefined" !== i && (t.name = i)
                }
            })
        }, u.prototype.start = function() {
            if (this.isRecording) throw new Error("audiorecorder is already recording");
            this.isRecording = !0, this.recorders.forEach(e => a(e)), console.log(`Started the recording of the audio. There are currently ${this.recorders.length} recorders active.`)
        }, u.prototype.stop = function() {
            this.isRecording = !1, this.recorders.forEach(e => c(e)), console.log("stopped recording")
        }, u.prototype.download = function() {
            this.recorders.forEach(e => {
                const t = new Blob(e.data, {
                        type: this.fileType
                    }),
                    n = URL.createObjectURL(t),
                    i = document.createElement("a");
                document.body.appendChild(i), i.style = "display: none", i.href = n, i.download = `test.${this.fileType.split("/")[1]}`, i.click(), window.URL.revokeObjectURL(n)
            })
        }, u.prototype.getRecordingResults = function() {
            if (this.isRecording) throw new Error("cannot get blobs because the AudioRecorder is still recording!");
            this.updateNames();
            const e = [];
            return this.recorders.forEach(t => e.push(new i(new Blob(t.data, {
                type: this.fileType
            }), t.name, t.startTime))), e
        }, u.prototype.getFileType = function() {
            return this.fileType
        }, e.exports = u
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var i = n(4),
                r = n(15),
                s = n(12),
                o = n(5);
            const a = Object(i.getLogger)(e),
                c = 3e3;

            function d() {
                return new Promise(e => {
                    s.a.enumerateDevices(t => {
                        const n = t.filter(e => "audioinput" === e.kind),
                            i = [];
                        for (const e of n) {
                            const t = s.a.obtainAudioAndVideoPermissions({
                                devices: ["audio"],
                                micDeviceId: e.deviceId
                            }).then(e => {
                                const t = e[0],
                                    n = t.getOriginalStream();
                                return o.a.startLocalStats(n, t.setAudioLevel.bind(t)), t.addEventListener(r.LOCAL_TRACK_STOPPED, () => {
                                    o.a.stopLocalStats(n)
                                }), t
                            });
                            i.push(t)
                        }
                        Promise.allSettled(i).then(t => {
                            const n = t.filter(e => "fulfilled" === e.status),
                                i = t.filter(e => "rejected" === e.status),
                                s = n.map(e => e.value),
                                o = i.map(e => e.value);
                            for (const e of o) a.error("Failed to acquire audio device with error: ", e);
                            for (const t of s) t.on(r.TRACK_AUDIO_LEVEL_CHANGED, n => {
                                n > .008 && (u(s), e({
                                    deviceId: t.deviceId,
                                    deviceLabel: t.track.label
                                }))
                            });
                            setTimeout(() => {
                                u(s), e({
                                    deviceId: "",
                                    deviceLabel: ""
                                })
                            }, c)
                        })
                    })
                })
            }

            function u(e) {
                for (const t of e) t.stopStream()
            }
        }).call(this, "modules/detection/ActiveDeviceDetector.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return l
            }));
            var i = n(4),
                r = n(8),
                s = n.n(r),
                o = n(7),
                a = n(5),
                c = n(11),
                d = n.n(c);
            const u = Object(i.getLogger)(e);
            class l {
                constructor(e, t, n) {
                    if (!e && !t) throw new TypeError("At least peerconnection or wsUrl must be given");
                    if (e && t) throw new TypeError("Just one of peerconnection or wsUrl must be given");
                    if (e ? u.debug("constructor() with peerconnection") : u.debug(`constructor() with wsUrl:"${t}"`), this._channel = null, this._eventEmitter = n, this._mode = null, this._areRetriesEnabled = !1, this._closedFromClient = !1, e) {
                        const t = e.createDataChannel("JVB data channel", {
                            protocol: "http://jitsi.org/protocols/colibri"
                        });
                        this._handleChannel(t), this._mode = "datachannel"
                    } else t && (this._areRetriesEnabled = !0, this._wsUrl = t, this._initWebSocket())
                }
                _initWebSocket() {
                    const e = new WebSocket(this._wsUrl);
                    this._handleChannel(e), this._mode = "websocket"
                }
                _startConnectionRetries() {
                    let e = 1;
                    const t = () => {
                        this.isOpen() || (this._initWebSocket(this._wsUrl), e = Math.min(2 * e, 60), this._retryTimeout = setTimeout(t, 1e3 * e))
                    };
                    this._retryTimeout = setTimeout(t, 1e3 * e)
                }
                _stopConnectionRetries() {
                    this._retryTimeout && (clearTimeout(this._retryTimeout), this._retryTimeout = void 0)
                }
                _retryWebSocketConnection(e) {
                    if (!this._areRetriesEnabled) return;
                    const {
                        code: t,
                        reason: n
                    } = e;
                    a.a.sendAnalytics(Object(o.y)(t, n)), this._areRetriesEnabled = !1, this._eventEmitter.once(s.a.DATA_CHANNEL_OPEN, () => {
                        this._stopConnectionRetries(), this._areRetriesEnabled = !0
                    }), this._startConnectionRetries()
                }
                get mode() {
                    return this._mode
                }
                close() {
                    if (this._closedFromClient = !0, this._stopConnectionRetries(), this._areRetriesEnabled = !1, this._channel) {
                        try {
                            this._channel.close()
                        } catch (e) {}
                        this._channel = null
                    }
                }
                isOpen() {
                    return this._channel && ("open" === this._channel.readyState || this._channel.readyState === WebSocket.OPEN)
                }
                sendMessage(e, t) {
                    this._send({
                        colibriClass: "EndpointMessage",
                        msgPayload: t,
                        to: e
                    })
                }
                sendSetLastNMessage(e) {
                    const t = {
                        colibriClass: "LastNChangedEvent",
                        lastN: e
                    };
                    this._send(t), u.log(`Channel lastN set to: ${e}`)
                }
                sendPinnedEndpointMessage(e) {
                    u.log("sending pinned changed notification to the bridge for endpoint ", e), this._send({
                        colibriClass: "PinnedEndpointChangedEvent",
                        pinnedEndpoint: e || null
                    })
                }
                sendSelectedEndpointsMessage(e) {
                    u.log("sending selected changed notification to the bridge for endpoints", e), this._send({
                        colibriClass: "SelectedEndpointsChangedEvent",
                        selectedEndpoints: e
                    })
                }
                sendReceiverVideoConstraintMessage(e) {
                    u.log("sending a ReceiverVideoConstraint message with " + `a maxFrameHeight of ${e} pixels`), this._send({
                        colibriClass: "ReceiverVideoConstraint",
                        maxFrameHeight: e
                    })
                }
                _handleChannel(e) {
                    const t = this._eventEmitter;
                    e.onopen = () => {
                        u.info(`${this._mode} channel opened`), t.emit(s.a.DATA_CHANNEL_OPEN)
                    }, e.onerror = e => {
                        "websocket" !== this._mode && u.error(`Channel error: ${e.message}`)
                    }, e.onmessage = ({
                        data: e
                    }) => {
                        let n;
                        try {
                            n = JSON.parse(e)
                        } catch (t) {
                            return d.a.callErrorHandler(t), void u.error("Failed to parse channel message as JSON: ", e, t)
                        }
                        const i = n.colibriClass;
                        switch (i) {
                            case "DominantSpeakerEndpointChangeEvent": {
                                const e = n.dominantSpeakerEndpoint;
                                u.info("Channel new dominant speaker event: ", e), t.emit(s.a.DOMINANT_SPEAKER_CHANGED, e);
                                break
                            }
                            case "EndpointConnectivityStatusChangeEvent": {
                                const e = n.endpoint,
                                    i = "true" === n.active;
                                u.info(`Endpoint connection status changed: ${e} active ? ${i}`), t.emit(s.a.ENDPOINT_CONN_STATUS_CHANGED, e, i);
                                break
                            }
                            case "EndpointMessage":
                                t.emit(s.a.ENDPOINT_MESSAGE_RECEIVED, n.from, n.msgPayload);
                                break;
                            case "LastNEndpointsChangeEvent": {
                                const e = n.lastNEndpoints;
                                u.info("Channel new last-n event: ", e, n), t.emit(s.a.LASTN_ENDPOINT_CHANGED, e, n);
                                break
                            }
                            case "SelectedUpdateEvent": {
                                const e = n.isSelected;
                                u.info(`SelectedUpdateEvent isSelected? ${e}`), t.emit(s.a.IS_SELECTED_CHANGED, e);
                                break
                            }
                            default:
                                u.debug("Channel JSON-formatted message: ", n), t.emit(`rtc.datachannel.${i}`, n)
                        }
                    }, e.onclose = e => {
                        u.info(`Channel closed by ${this._closedFromClient?"client":"server"}`), "websocket" === this._mode && (this._closedFromClient || (u.error(`Channel closed: ${e.code} ${e.reason}`), this._retryWebSocketConnection(e))), this._channel = null
                    }, this._channel = e
                }
                _send(e) {
                    const t = this._channel;
                    if (!this.isOpen()) throw u.error("Bridge Channel send: no opened channel."), new Error("No opened channel");
                    t.send(JSON.stringify(e))
                }
            }
        }).call(this, "modules/RTC/BridgeChannel.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(7),
                r = n(4),
                s = n(3);

            function o(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const a = 100,
                c = Object(r.getLogger)(e);
            t.a = new class {
                constructor() {
                    this.reset()
                }
                reset() {
                    this.disposed = !1, this.analyticsHandlers = new Set, this.cache = [], this.permanentProperties = {}, this.conferenceName = "", this.addPermanentProperties({
                        user_agent: navigator.userAgent,
                        browser_name: s.a.getName()
                    })
                }
                dispose() {
                    c.warn("Disposing of analytics adapter."), this.analyticsHandlers && this.analyticsHandlers.size > 0 && this.analyticsHandlers.forEach(e => {
                        "function" == typeof e.dispose && e.dispose()
                    }), this.setAnalyticsHandlers([]), this.disposed = !0
                }
                setAnalyticsHandlers(e) {
                    if (this.disposed) return;
                    this.analyticsHandlers = new Set(e), this._setUserProperties();
                    const t = this.cache;
                    this.cache = null, t && t.forEach(e => this._sendEvent(e))
                }
                _setUserProperties() {
                    this.analyticsHandlers.forEach(e => {
                        try {
                            e.setUserProperties(this.permanentProperties)
                        } catch (e) {
                            c.warn("Error in setUserProperties method of one of the " + `analytics handlers: ${e}`)
                        }
                    })
                }
                addPermanentProperties(e) {
                    this.permanentProperties = function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? arguments[t] : {},
                                i = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), i.forEach((function(t) {
                                o(e, t, n[t])
                            }))
                        }
                        return e
                    }({}, this.permanentProperties, e), this._setUserProperties()
                }
                setConferenceName(e) {
                    this.conferenceName = e, this.addPermanentProperties({
                        conference_name: e
                    })
                }
                sendEvent(e, t = {}) {
                    if (this.disposed) return;
                    let n = null;
                    "string" == typeof e ? n = {
                        type: i.t,
                        action: e,
                        actionSubject: e,
                        source: e,
                        attributes: t
                    } : "object" == typeof e && (n = e), this._verifyRequiredFields(n) ? this._sendEvent(n) : c.error(`Dropping a mis-formatted event: ${JSON.stringify(n)}`)
                }
                _verifyRequiredFields(e) {
                    if (!e) return !1;
                    e.type || (e.type = i.t);
                    const t = e.type;
                    return t !== i.t && t !== i.u && t !== i.w && t !== i.v ? (c.error(`Unknown event type: ${t}`), !1) : t === i.u ? Boolean(e.name) : (e.action = e.action || e.name || e.actionSubject, e.actionSubject = e.actionSubject || e.name || e.action, e.source = e.source || e.name || e.action || e.actionSubject, e.action && e.actionSubject && e.source ? !!(t !== i.v || (e.objectType = e.objectType || "generic-object-type", e.containerType = e.containerType || "conference", "conference" !== e.containerType || e.containerId || (e.containerId = this.conferenceName), e.objectType && e.objectId && e.containerType && e.containerId)) || (c.error("Required field missing (containerId, containerType, objectId or objectType)"), !1) : (c.error("Required field missing (action, actionSubject or source)"), !1))
                }
                _maybeCacheEvent(e) {
                    return !!this.cache && (this.cache.push(e), this.cache.length > a && this.cache.splice(0, 1), !0)
                }
                _sendEvent(e) {
                    this._maybeCacheEvent(e) || this.analyticsHandlers.forEach(t => {
                        try {
                            t.sendEvent(e)
                        } catch (e) {
                            c.warn(`Error sending analytics event: ${e}`)
                        }
                    })
                }
            }
        }).call(this, "modules/statistics/AnalyticsAdapter.js")
    }, function(e, t, n) {
        "use strict";
        (function(e, i) {
            n.d(t, "a", (function() {
                return a
            }));
            var r = n(4),
                s = n(23);
            const o = Object(r.getLogger)(e);
            class a extends s.a {
                constructor() {
                    super(), o.info(`This appears to be ${this.getName()}, ver: ${this.getVersion()}`)
                }
                doesVideoMuteByStreamRemove() {
                    return this.isChromiumBased() || this.isSafari()
                }
                supportsP2P() {
                    return !this.usesUnifiedPlan()
                }
                isChromiumBased() {
                    return this.isChrome() || this.isElectron() || this.isNWJS() || this.isOpera()
                }
                isSupported() {
                    return this.isChromiumBased() || this.isFirefox() || this.isReactNative() || this.isSafari() && !this.isVersionLessThan("12.1")
                }
                isUserInteractionRequiredForUnmute() {
                    return this.isFirefox() && this.isVersionLessThan("68") || this.isSafari()
                }
                supportsVideoMuteOnConnInterrupted() {
                    return this.isChromiumBased() || this.isReactNative() || this.isSafari()
                }
                supportsBandwidthStatistics() {
                    return !this.isFirefox() && !this.isSafari()
                }
                supportsDeviceChangeEvent() {
                    return navigator.mediaDevices && void 0 !== navigator.mediaDevices.ondevicechange && void 0 !== navigator.mediaDevices.addEventListener
                }
                supportsLocalCandidateRttStatistics() {
                    return this.isChromiumBased() || this.isReactNative() || this.isSafari()
                }
                supportsRTTStatistics() {
                    return !this.isFirefox()
                }
                supportsRtpSender() {
                    return this.isFirefox() || this.isSafari()
                }
                supportsRtx() {
                    return !this.isFirefox()
                }
                supportsVideo() {
                    return !0
                }
                usesPlanB() {
                    return !this.usesUnifiedPlan()
                }
                usesSdpMungingForSimulcast() {
                    return this.isChromiumBased() || this.isSafari()
                }
                usesUnifiedPlan() {
                    return !!this.isFirefox() || !(!this.isSafari() || void 0 === window.RTCRtpTransceiver) && Object.keys(RTCRtpTransceiver.prototype).indexOf("currentDirection") > -1
                }
                usesNewGumFlow() {
                    return this.isChrome() ? !this.isVersionLessThan(61) : !(!this.isFirefox() && !this.isSafari()) || !!this.isChromiumBased() && this._getChromiumBasedVersion() >= 61
                }
                usesAdapter() {
                    return this.usesNewGumFlow()
                }
                usesRidsForSimulcast() {
                    return !1
                }
                supportsGetDisplayMedia() {
                    return void 0 !== navigator.getDisplayMedia || void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getDisplayMedia
                }
                supportsInsertableStreams() {
                    return Boolean(void 0 !== window.RTCRtpSender && window.RTCRtpSender.prototype.createEncodedVideoStreams)
                }
                supportsSdpSemantics() {
                    return this.isChromiumBased() && this._getChromiumBasedVersion() >= 65
                }
                _getChromiumBasedVersion() {
                    if (this.isChromiumBased()) {
                        if (this.isNWJS()) return Number.parseInt(i.versions.chromium, 10);
                        const e = navigator.userAgent;
                        if (e.match(/Chrome/)) {
                            return Number.parseInt(e.match(/Chrome\/([\d.]+)/)[1], 10)
                        }
                    }
                    return -1
                }
            }
        }).call(this, "modules/browser/BrowserCapabilities.js", n(51))
    }, function(e, t, n) {
        e.exports = function(e) {
            var t = {};

            function n(i) {
                if (t[i]) return t[i].exports;
                var r = t[i] = {
                    i: i,
                    l: !1,
                    exports: {}
                };
                return e[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports
            }
            return n.m = e, n.c = t, n.d = function(e, t, i) {
                n.o(e, t) || Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: i
                })
            }, n.r = function(e) {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                }), Object.defineProperty(e, "__esModule", {
                    value: !0
                })
            }, n.t = function(e, t) {
                if (1 & t && (e = n(e)), 8 & t) return e;
                if (4 & t && "object" == typeof e && e && e.__esModule) return e;
                var i = Object.create(null);
                if (n.r(i), Object.defineProperty(i, "default", {
                        enumerable: !0,
                        value: e
                    }), 2 & t && "string" != typeof e)
                    for (var r in e) n.d(i, r, function(t) {
                        return e[t]
                    }.bind(null, r));
                return i
            }, n.n = function(e) {
                var t = e && e.__esModule ? function() {
                    return e.default
                } : function() {
                    return e
                };
                return n.d(t, "a", t), t
            }, n.o = function(e, t) {
                return Object.prototype.hasOwnProperty.call(e, t)
            }, n.p = "", n(n.s = 90)
        }({
            17: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i = n(18),
                    r = function() {
                        function e() {}
                        return e.getFirstMatch = function(e, t) {
                            var n = t.match(e);
                            return n && n.length > 0 && n[1] || ""
                        }, e.getSecondMatch = function(e, t) {
                            var n = t.match(e);
                            return n && n.length > 1 && n[2] || ""
                        }, e.matchAndReturnConst = function(e, t, n) {
                            if (e.test(t)) return n
                        }, e.getWindowsVersionName = function(e) {
                            switch (e) {
                                case "NT":
                                    return "NT";
                                case "XP":
                                    return "XP";
                                case "NT 5.0":
                                    return "2000";
                                case "NT 5.1":
                                    return "XP";
                                case "NT 5.2":
                                    return "2003";
                                case "NT 6.0":
                                    return "Vista";
                                case "NT 6.1":
                                    return "7";
                                case "NT 6.2":
                                    return "8";
                                case "NT 6.3":
                                    return "8.1";
                                case "NT 10.0":
                                    return "10";
                                default:
                                    return
                            }
                        }, e.getMacOSVersionName = function(e) {
                            var t = e.split(".").splice(0, 2).map((function(e) {
                                return parseInt(e, 10) || 0
                            }));
                            if (t.push(0), 10 === t[0]) switch (t[1]) {
                                case 5:
                                    return "Leopard";
                                case 6:
                                    return "Snow Leopard";
                                case 7:
                                    return "Lion";
                                case 8:
                                    return "Mountain Lion";
                                case 9:
                                    return "Mavericks";
                                case 10:
                                    return "Yosemite";
                                case 11:
                                    return "El Capitan";
                                case 12:
                                    return "Sierra";
                                case 13:
                                    return "High Sierra";
                                case 14:
                                    return "Mojave";
                                case 15:
                                    return "Catalina";
                                default:
                                    return
                            }
                        }, e.getAndroidVersionName = function(e) {
                            var t = e.split(".").splice(0, 2).map((function(e) {
                                return parseInt(e, 10) || 0
                            }));
                            if (t.push(0), !(1 === t[0] && t[1] < 5)) return 1 === t[0] && t[1] < 6 ? "Cupcake" : 1 === t[0] && t[1] >= 6 ? "Donut" : 2 === t[0] && t[1] < 2 ? "Eclair" : 2 === t[0] && 2 === t[1] ? "Froyo" : 2 === t[0] && t[1] > 2 ? "Gingerbread" : 3 === t[0] ? "Honeycomb" : 4 === t[0] && t[1] < 1 ? "Ice Cream Sandwich" : 4 === t[0] && t[1] < 4 ? "Jelly Bean" : 4 === t[0] && t[1] >= 4 ? "KitKat" : 5 === t[0] ? "Lollipop" : 6 === t[0] ? "Marshmallow" : 7 === t[0] ? "Nougat" : 8 === t[0] ? "Oreo" : 9 === t[0] ? "Pie" : void 0
                        }, e.getVersionPrecision = function(e) {
                            return e.split(".").length
                        }, e.compareVersions = function(t, n, i) {
                            void 0 === i && (i = !1);
                            var r = e.getVersionPrecision(t),
                                s = e.getVersionPrecision(n),
                                o = Math.max(r, s),
                                a = 0,
                                c = e.map([t, n], (function(t) {
                                    var n = o - e.getVersionPrecision(t),
                                        i = t + new Array(n + 1).join(".0");
                                    return e.map(i.split("."), (function(e) {
                                        return new Array(20 - e.length).join("0") + e
                                    })).reverse()
                                }));
                            for (i && (a = o - Math.min(r, s)), o -= 1; o >= a;) {
                                if (c[0][o] > c[1][o]) return 1;
                                if (c[0][o] === c[1][o]) {
                                    if (o === a) return 0;
                                    o -= 1
                                } else if (c[0][o] < c[1][o]) return -1
                            }
                        }, e.map = function(e, t) {
                            var n, i = [];
                            if (Array.prototype.map) return Array.prototype.map.call(e, t);
                            for (n = 0; n < e.length; n += 1) i.push(t(e[n]));
                            return i
                        }, e.getBrowserAlias = function(e) {
                            return i.BROWSER_ALIASES_MAP[e]
                        }, e.getBrowserTypeByAlias = function(e) {
                            return i.BROWSER_MAP[e] || ""
                        }, e
                    }();
                t.default = r, e.exports = t.default
            },
            18: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0, t.BROWSER_ALIASES_MAP = {
                    "Amazon Silk": "amazon_silk",
                    "Android Browser": "android",
                    Bada: "bada",
                    BlackBerry: "blackberry",
                    Chrome: "chrome",
                    Chromium: "chromium",
                    Epiphany: "epiphany",
                    Firefox: "firefox",
                    Focus: "focus",
                    Generic: "generic",
                    "Google Search": "google_search",
                    Googlebot: "googlebot",
                    "Internet Explorer": "ie",
                    "K-Meleon": "k_meleon",
                    Maxthon: "maxthon",
                    "Microsoft Edge": "edge",
                    "MZ Browser": "mz",
                    "NAVER Whale Browser": "naver",
                    Opera: "opera",
                    "Opera Coast": "opera_coast",
                    PhantomJS: "phantomjs",
                    Puffin: "puffin",
                    QupZilla: "qupzilla",
                    QQ: "qq",
                    QQLite: "qqlite",
                    Safari: "safari",
                    Sailfish: "sailfish",
                    "Samsung Internet for Android": "samsung_internet",
                    SeaMonkey: "seamonkey",
                    Sleipnir: "sleipnir",
                    Swing: "swing",
                    Tizen: "tizen",
                    "UC Browser": "uc",
                    Vivaldi: "vivaldi",
                    "WebOS Browser": "webos",
                    WeChat: "wechat",
                    "Yandex Browser": "yandex",
                    Roku: "roku"
                }, t.BROWSER_MAP = {
                    amazon_silk: "Amazon Silk",
                    android: "Android Browser",
                    bada: "Bada",
                    blackberry: "BlackBerry",
                    chrome: "Chrome",
                    chromium: "Chromium",
                    epiphany: "Epiphany",
                    firefox: "Firefox",
                    focus: "Focus",
                    generic: "Generic",
                    googlebot: "Googlebot",
                    google_search: "Google Search",
                    ie: "Internet Explorer",
                    k_meleon: "K-Meleon",
                    maxthon: "Maxthon",
                    edge: "Microsoft Edge",
                    mz: "MZ Browser",
                    naver: "NAVER Whale Browser",
                    opera: "Opera",
                    opera_coast: "Opera Coast",
                    phantomjs: "PhantomJS",
                    puffin: "Puffin",
                    qupzilla: "QupZilla",
                    qq: "QQ Browser",
                    qqlite: "QQ Browser Lite",
                    safari: "Safari",
                    sailfish: "Sailfish",
                    samsung_internet: "Samsung Internet for Android",
                    seamonkey: "SeaMonkey",
                    sleipnir: "Sleipnir",
                    swing: "Swing",
                    tizen: "Tizen",
                    uc: "UC Browser",
                    vivaldi: "Vivaldi",
                    webos: "WebOS Browser",
                    wechat: "WeChat",
                    yandex: "Yandex Browser"
                }, t.PLATFORMS_MAP = {
                    tablet: "tablet",
                    mobile: "mobile",
                    desktop: "desktop",
                    tv: "tv"
                }, t.OS_MAP = {
                    WindowsPhone: "Windows Phone",
                    Windows: "Windows",
                    MacOS: "macOS",
                    iOS: "iOS",
                    Android: "Android",
                    WebOS: "WebOS",
                    BlackBerry: "BlackBerry",
                    Bada: "Bada",
                    Tizen: "Tizen",
                    Linux: "Linux",
                    ChromeOS: "Chrome OS",
                    PlayStation4: "PlayStation 4",
                    Roku: "Roku"
                }, t.ENGINE_MAP = {
                    EdgeHTML: "EdgeHTML",
                    Blink: "Blink",
                    Trident: "Trident",
                    Presto: "Presto",
                    Gecko: "Gecko",
                    WebKit: "WebKit"
                }
            },
            90: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i, r = (i = n(91)) && i.__esModule ? i : {
                        default: i
                    },
                    s = n(18);

                function o(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                var a = function() {
                    function e() {}
                    var t, n;
                    return e.getParser = function(e, t) {
                        if (void 0 === t && (t = !1), "string" != typeof e) throw new Error("UserAgent should be a string");
                        return new r.default(e, t)
                    }, e.parse = function(e) {
                        return new r.default(e).getResult()
                    }, t = e, (n = [{
                        key: "BROWSER_MAP",
                        get: function() {
                            return s.BROWSER_MAP
                        }
                    }, {
                        key: "ENGINE_MAP",
                        get: function() {
                            return s.ENGINE_MAP
                        }
                    }, {
                        key: "OS_MAP",
                        get: function() {
                            return s.OS_MAP
                        }
                    }, {
                        key: "PLATFORMS_MAP",
                        get: function() {
                            return s.PLATFORMS_MAP
                        }
                    }]) && o(t, n), e
                }();
                t.default = a, e.exports = t.default
            },
            91: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i = c(n(92)),
                    r = c(n(93)),
                    s = c(n(94)),
                    o = c(n(95)),
                    a = c(n(17));

                function c(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                var d = function() {
                    function e(e, t) {
                        if (void 0 === t && (t = !1), null == e || "" === e) throw new Error("UserAgent parameter can't be empty");
                        this._ua = e, this.parsedResult = {}, !0 !== t && this.parse()
                    }
                    var t = e.prototype;
                    return t.getUA = function() {
                        return this._ua
                    }, t.test = function(e) {
                        return e.test(this._ua)
                    }, t.parseBrowser = function() {
                        var e = this;
                        this.parsedResult.browser = {};
                        var t = i.default.find((function(t) {
                            if ("function" == typeof t.test) return t.test(e);
                            if (t.test instanceof Array) return t.test.some((function(t) {
                                return e.test(t)
                            }));
                            throw new Error("Browser's test function is not valid")
                        }));
                        return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser
                    }, t.getBrowser = function() {
                        return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser()
                    }, t.getBrowserName = function(e) {
                        return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || ""
                    }, t.getBrowserVersion = function() {
                        return this.getBrowser().version
                    }, t.getOS = function() {
                        return this.parsedResult.os ? this.parsedResult.os : this.parseOS()
                    }, t.parseOS = function() {
                        var e = this;
                        this.parsedResult.os = {};
                        var t = r.default.find((function(t) {
                            if ("function" == typeof t.test) return t.test(e);
                            if (t.test instanceof Array) return t.test.some((function(t) {
                                return e.test(t)
                            }));
                            throw new Error("Browser's test function is not valid")
                        }));
                        return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os
                    }, t.getOSName = function(e) {
                        var t = this.getOS().name;
                        return e ? String(t).toLowerCase() || "" : t || ""
                    }, t.getOSVersion = function() {
                        return this.getOS().version
                    }, t.getPlatform = function() {
                        return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform()
                    }, t.getPlatformType = function(e) {
                        void 0 === e && (e = !1);
                        var t = this.getPlatform().type;
                        return e ? String(t).toLowerCase() || "" : t || ""
                    }, t.parsePlatform = function() {
                        var e = this;
                        this.parsedResult.platform = {};
                        var t = s.default.find((function(t) {
                            if ("function" == typeof t.test) return t.test(e);
                            if (t.test instanceof Array) return t.test.some((function(t) {
                                return e.test(t)
                            }));
                            throw new Error("Browser's test function is not valid")
                        }));
                        return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform
                    }, t.getEngine = function() {
                        return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine()
                    }, t.getEngineName = function(e) {
                        return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || ""
                    }, t.parseEngine = function() {
                        var e = this;
                        this.parsedResult.engine = {};
                        var t = o.default.find((function(t) {
                            if ("function" == typeof t.test) return t.test(e);
                            if (t.test instanceof Array) return t.test.some((function(t) {
                                return e.test(t)
                            }));
                            throw new Error("Browser's test function is not valid")
                        }));
                        return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine
                    }, t.parse = function() {
                        return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this
                    }, t.getResult = function() {
                        return Object.assign({}, this.parsedResult)
                    }, t.satisfies = function(e) {
                        var t = this,
                            n = {},
                            i = 0,
                            r = {},
                            s = 0;
                        if (Object.keys(e).forEach((function(t) {
                                var o = e[t];
                                "string" == typeof o ? (r[t] = o, s += 1) : "object" == typeof o && (n[t] = o, i += 1)
                            })), i > 0) {
                            var o = Object.keys(n),
                                a = o.find((function(e) {
                                    return t.isOS(e)
                                }));
                            if (a) {
                                var c = this.satisfies(n[a]);
                                if (void 0 !== c) return c
                            }
                            var d = o.find((function(e) {
                                return t.isPlatform(e)
                            }));
                            if (d) {
                                var u = this.satisfies(n[d]);
                                if (void 0 !== u) return u
                            }
                        }
                        if (s > 0) {
                            var l = Object.keys(r).find((function(e) {
                                return t.isBrowser(e, !0)
                            }));
                            if (void 0 !== l) return this.compareVersion(r[l])
                        }
                    }, t.isBrowser = function(e, t) {
                        void 0 === t && (t = !1);
                        var n = this.getBrowserName().toLowerCase(),
                            i = e.toLowerCase(),
                            r = a.default.getBrowserTypeByAlias(i);
                        return t && r && (i = r.toLowerCase()), i === n
                    }, t.compareVersion = function(e) {
                        var t = [0],
                            n = e,
                            i = !1,
                            r = this.getBrowserVersion();
                        if ("string" == typeof r) return ">" === e[0] || "<" === e[0] ? (n = e.substr(1), "=" === e[1] ? (i = !0, n = e.substr(2)) : t = [], ">" === e[0] ? t.push(1) : t.push(-1)) : "=" === e[0] ? n = e.substr(1) : "~" === e[0] && (i = !0, n = e.substr(1)), t.indexOf(a.default.compareVersions(r, n, i)) > -1
                    }, t.isOS = function(e) {
                        return this.getOSName(!0) === String(e).toLowerCase()
                    }, t.isPlatform = function(e) {
                        return this.getPlatformType(!0) === String(e).toLowerCase()
                    }, t.isEngine = function(e) {
                        return this.getEngineName(!0) === String(e).toLowerCase()
                    }, t.is = function(e) {
                        return this.isBrowser(e) || this.isOS(e) || this.isPlatform(e)
                    }, t.some = function(e) {
                        var t = this;
                        return void 0 === e && (e = []), e.some((function(e) {
                            return t.is(e)
                        }))
                    }, e
                }();
                t.default = d, e.exports = t.default
            },
            92: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i, r = (i = n(17)) && i.__esModule ? i : {
                        default: i
                    },
                    s = /version\/(\d+(\.?_?\d+)+)/i,
                    o = [{
                        test: [/googlebot/i],
                        describe: function(e) {
                            var t = {
                                    name: "Googlebot"
                                },
                                n = r.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/opera/i],
                        describe: function(e) {
                            var t = {
                                    name: "Opera"
                                },
                                n = r.default.getFirstMatch(s, e) || r.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/opr\/|opios/i],
                        describe: function(e) {
                            var t = {
                                    name: "Opera"
                                },
                                n = r.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/SamsungBrowser/i],
                        describe: function(e) {
                            var t = {
                                    name: "Samsung Internet for Android"
                                },
                                n = r.default.getFirstMatch(s, e) || r.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/Whale/i],
                        describe: function(e) {
                            var t = {
                                    name: "NAVER Whale Browser"
                                },
                                n = r.default.getFirstMatch(s, e) || r.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/MZBrowser/i],
                        describe: function(e) {
                            var t = {
                                    name: "MZ Browser"
                                },
                                n = r.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/focus/i],
                        describe: function(e) {
                            var t = {
                                    name: "Focus"
                                },
                                n = r.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/swing/i],
                        describe: function(e) {
                            var t = {
                                    name: "Swing"
                                },
                                n = r.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/coast/i],
                        describe: function(e) {
                            var t = {
                                    name: "Opera Coast"
                                },
                                n = r.default.getFirstMatch(s, e) || r.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/yabrowser/i],
                        describe: function(e) {
                            var t = {
                                    name: "Yandex Browser"
                                },
                                n = r.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/ucbrowser/i],
                        describe: function(e) {
                            var t = {
                                    name: "UC Browser"
                                },
                                n = r.default.getFirstMatch(s, e) || r.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/Maxthon|mxios/i],
                        describe: function(e) {
                            var t = {
                                    name: "Maxthon"
                                },
                                n = r.default.getFirstMatch(s, e) || r.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/epiphany/i],
                        describe: function(e) {
                            var t = {
                                    name: "Epiphany"
                                },
                                n = r.default.getFirstMatch(s, e) || r.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/puffin/i],
                        describe: function(e) {
                            var t = {
                                    name: "Puffin"
                                },
                                n = r.default.getFirstMatch(s, e) || r.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/sleipnir/i],
                        describe: function(e) {
                            var t = {
                                    name: "Sleipnir"
                                },
                                n = r.default.getFirstMatch(s, e) || r.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/k-meleon/i],
                        describe: function(e) {
                            var t = {
                                    name: "K-Meleon"
                                },
                                n = r.default.getFirstMatch(s, e) || r.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/micromessenger/i],
                        describe: function(e) {
                            var t = {
                                    name: "WeChat"
                                },
                                n = r.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/qqbrowser/i],
                        describe: function(e) {
                            var t = {
                                    name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
                                },
                                n = r.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/msie|trident/i],
                        describe: function(e) {
                            var t = {
                                    name: "Internet Explorer"
                                },
                                n = r.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/\sedg\//i],
                        describe: function(e) {
                            var t = {
                                    name: "Microsoft Edge"
                                },
                                n = r.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/edg([ea]|ios)/i],
                        describe: function(e) {
                            var t = {
                                    name: "Microsoft Edge"
                                },
                                n = r.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/vivaldi/i],
                        describe: function(e) {
                            var t = {
                                    name: "Vivaldi"
                                },
                                n = r.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/seamonkey/i],
                        describe: function(e) {
                            var t = {
                                    name: "SeaMonkey"
                                },
                                n = r.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/sailfish/i],
                        describe: function(e) {
                            var t = {
                                    name: "Sailfish"
                                },
                                n = r.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/silk/i],
                        describe: function(e) {
                            var t = {
                                    name: "Amazon Silk"
                                },
                                n = r.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/phantom/i],
                        describe: function(e) {
                            var t = {
                                    name: "PhantomJS"
                                },
                                n = r.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/slimerjs/i],
                        describe: function(e) {
                            var t = {
                                    name: "SlimerJS"
                                },
                                n = r.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
                        describe: function(e) {
                            var t = {
                                    name: "BlackBerry"
                                },
                                n = r.default.getFirstMatch(s, e) || r.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/(web|hpw)[o0]s/i],
                        describe: function(e) {
                            var t = {
                                    name: "WebOS Browser"
                                },
                                n = r.default.getFirstMatch(s, e) || r.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/bada/i],
                        describe: function(e) {
                            var t = {
                                    name: "Bada"
                                },
                                n = r.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/tizen/i],
                        describe: function(e) {
                            var t = {
                                    name: "Tizen"
                                },
                                n = r.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/qupzilla/i],
                        describe: function(e) {
                            var t = {
                                    name: "QupZilla"
                                },
                                n = r.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/firefox|iceweasel|fxios/i],
                        describe: function(e) {
                            var t = {
                                    name: "Firefox"
                                },
                                n = r.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/chromium/i],
                        describe: function(e) {
                            var t = {
                                    name: "Chromium"
                                },
                                n = r.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/chrome|crios|crmo/i],
                        describe: function(e) {
                            var t = {
                                    name: "Chrome"
                                },
                                n = r.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/GSA/i],
                        describe: function(e) {
                            var t = {
                                    name: "Google Search"
                                },
                                n = r.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: function(e) {
                            var t = !e.test(/like android/i),
                                n = e.test(/android/i);
                            return t && n
                        },
                        describe: function(e) {
                            var t = {
                                    name: "Android Browser"
                                },
                                n = r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/playstation 4/i],
                        describe: function(e) {
                            var t = {
                                    name: "PlayStation 4"
                                },
                                n = r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/safari|applewebkit/i],
                        describe: function(e) {
                            var t = {
                                    name: "Safari"
                                },
                                n = r.default.getFirstMatch(s, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/.*/i],
                        describe: function(e) {
                            var t = -1 !== e.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
                            return {
                                name: r.default.getFirstMatch(t, e),
                                version: r.default.getSecondMatch(t, e)
                            }
                        }
                    }];
                t.default = o, e.exports = t.default
            },
            93: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i, r = (i = n(17)) && i.__esModule ? i : {
                        default: i
                    },
                    s = n(18),
                    o = [{
                        test: [/Roku\/DVP/],
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
                            return {
                                name: s.OS_MAP.Roku,
                                version: t
                            }
                        }
                    }, {
                        test: [/windows phone/i],
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
                            return {
                                name: s.OS_MAP.WindowsPhone,
                                version: t
                            }
                        }
                    }, {
                        test: [/windows/i],
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e),
                                n = r.default.getWindowsVersionName(t);
                            return {
                                name: s.OS_MAP.Windows,
                                version: t,
                                versionName: n
                            }
                        }
                    }, {
                        test: [/macintosh/i],
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."),
                                n = r.default.getMacOSVersionName(t),
                                i = {
                                    name: s.OS_MAP.MacOS,
                                    version: t
                                };
                            return n && (i.versionName = n), i
                        }
                    }, {
                        test: [/(ipod|iphone|ipad)/i],
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
                            return {
                                name: s.OS_MAP.iOS,
                                version: t
                            }
                        }
                    }, {
                        test: function(e) {
                            var t = !e.test(/like android/i),
                                n = e.test(/android/i);
                            return t && n
                        },
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e),
                                n = r.default.getAndroidVersionName(t),
                                i = {
                                    name: s.OS_MAP.Android,
                                    version: t
                                };
                            return n && (i.versionName = n), i
                        }
                    }, {
                        test: [/(web|hpw)[o0]s/i],
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e),
                                n = {
                                    name: s.OS_MAP.WebOS
                                };
                            return t && t.length && (n.version = t), n
                        }
                    }, {
                        test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || r.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || r.default.getFirstMatch(/\bbb(\d+)/i, e);
                            return {
                                name: s.OS_MAP.BlackBerry,
                                version: t
                            }
                        }
                    }, {
                        test: [/bada/i],
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
                            return {
                                name: s.OS_MAP.Bada,
                                version: t
                            }
                        }
                    }, {
                        test: [/tizen/i],
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
                            return {
                                name: s.OS_MAP.Tizen,
                                version: t
                            }
                        }
                    }, {
                        test: [/linux/i],
                        describe: function() {
                            return {
                                name: s.OS_MAP.Linux
                            }
                        }
                    }, {
                        test: [/CrOS/],
                        describe: function() {
                            return {
                                name: s.OS_MAP.ChromeOS
                            }
                        }
                    }, {
                        test: [/PlayStation 4/],
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
                            return {
                                name: s.OS_MAP.PlayStation4,
                                version: t
                            }
                        }
                    }];
                t.default = o, e.exports = t.default
            },
            94: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i, r = (i = n(17)) && i.__esModule ? i : {
                        default: i
                    },
                    s = n(18),
                    o = [{
                        test: [/googlebot/i],
                        describe: function() {
                            return {
                                type: "bot",
                                vendor: "Google"
                            }
                        }
                    }, {
                        test: [/huawei/i],
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/(can-l01)/i, e) && "Nova",
                                n = {
                                    type: s.PLATFORMS_MAP.mobile,
                                    vendor: "Huawei"
                                };
                            return t && (n.model = t), n
                        }
                    }, {
                        test: [/nexus\s*(?:7|8|9|10).*/i],
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.tablet,
                                vendor: "Nexus"
                            }
                        }
                    }, {
                        test: [/ipad/i],
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.tablet,
                                vendor: "Apple",
                                model: "iPad"
                            }
                        }
                    }, {
                        test: [/kftt build/i],
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.tablet,
                                vendor: "Amazon",
                                model: "Kindle Fire HD 7"
                            }
                        }
                    }, {
                        test: [/silk/i],
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.tablet,
                                vendor: "Amazon"
                            }
                        }
                    }, {
                        test: [/tablet(?! pc)/i],
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.tablet
                            }
                        }
                    }, {
                        test: function(e) {
                            var t = e.test(/ipod|iphone/i),
                                n = e.test(/like (ipod|iphone)/i);
                            return t && !n
                        },
                        describe: function(e) {
                            var t = r.default.getFirstMatch(/(ipod|iphone)/i, e);
                            return {
                                type: s.PLATFORMS_MAP.mobile,
                                vendor: "Apple",
                                model: t
                            }
                        }
                    }, {
                        test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.mobile,
                                vendor: "Nexus"
                            }
                        }
                    }, {
                        test: [/[^-]mobi/i],
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.mobile
                            }
                        }
                    }, {
                        test: function(e) {
                            return "blackberry" === e.getBrowserName(!0)
                        },
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.mobile,
                                vendor: "BlackBerry"
                            }
                        }
                    }, {
                        test: function(e) {
                            return "bada" === e.getBrowserName(!0)
                        },
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.mobile
                            }
                        }
                    }, {
                        test: function(e) {
                            return "windows phone" === e.getBrowserName()
                        },
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.mobile,
                                vendor: "Microsoft"
                            }
                        }
                    }, {
                        test: function(e) {
                            var t = Number(String(e.getOSVersion()).split(".")[0]);
                            return "android" === e.getOSName(!0) && t >= 3
                        },
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.tablet
                            }
                        }
                    }, {
                        test: function(e) {
                            return "android" === e.getOSName(!0)
                        },
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.mobile
                            }
                        }
                    }, {
                        test: function(e) {
                            return "macos" === e.getOSName(!0)
                        },
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.desktop,
                                vendor: "Apple"
                            }
                        }
                    }, {
                        test: function(e) {
                            return "windows" === e.getOSName(!0)
                        },
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.desktop
                            }
                        }
                    }, {
                        test: function(e) {
                            return "linux" === e.getOSName(!0)
                        },
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.desktop
                            }
                        }
                    }, {
                        test: function(e) {
                            return "playstation 4" === e.getOSName(!0)
                        },
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.tv
                            }
                        }
                    }, {
                        test: function(e) {
                            return "roku" === e.getOSName(!0)
                        },
                        describe: function() {
                            return {
                                type: s.PLATFORMS_MAP.tv
                            }
                        }
                    }];
                t.default = o, e.exports = t.default
            },
            95: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i, r = (i = n(17)) && i.__esModule ? i : {
                        default: i
                    },
                    s = n(18),
                    o = [{
                        test: function(e) {
                            return "microsoft edge" === e.getBrowserName(!0)
                        },
                        describe: function(e) {
                            if (/\sedg\//i.test(e)) return {
                                name: s.ENGINE_MAP.Blink
                            };
                            var t = r.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
                            return {
                                name: s.ENGINE_MAP.EdgeHTML,
                                version: t
                            }
                        }
                    }, {
                        test: [/trident/i],
                        describe: function(e) {
                            var t = {
                                    name: s.ENGINE_MAP.Trident
                                },
                                n = r.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: function(e) {
                            return e.test(/presto/i)
                        },
                        describe: function(e) {
                            var t = {
                                    name: s.ENGINE_MAP.Presto
                                },
                                n = r.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: function(e) {
                            var t = e.test(/gecko/i),
                                n = e.test(/like gecko/i);
                            return t && !n
                        },
                        describe: function(e) {
                            var t = {
                                    name: s.ENGINE_MAP.Gecko
                                },
                                n = r.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/(apple)?webkit\/537\.36/i],
                        describe: function() {
                            return {
                                name: s.ENGINE_MAP.Blink
                            }
                        }
                    }, {
                        test: [/(apple)?webkit/i],
                        describe: function(e) {
                            var t = {
                                    name: s.ENGINE_MAP.WebKit
                                },
                                n = r.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }];
                t.default = o, e.exports = t.default
            }
        })
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return p
            }));
            var i = n(3),
                r = n(23),
                s = n(26),
                o = n(9);
            const a = n(11),
                c = n(4).getLogger(e),
                d = {};

            function u(e, t) {
                return !t || t <= 0 || !e || e <= 0 ? 0 : Math.round(e / t * 100)
            }

            function l() {
                this.loss = {}, this.bitrate = {
                    download: 0,
                    upload: 0
                }, this.resolution = {}, this.framerate = 0
            }

            function h() {
                this.bandwidth = {}, this.bitrate = {}, this.packetLoss = null, this.transport = []
            }

            function p(e, t, n, r) {
                this._browserType = i.a.getName();
                const s = d[this._browserType];
                if (!s) throw `The browser type '${this._browserType}' isn't supported!`;
                this._usesPromiseGetStats = i.a.isSafari() || i.a.isFirefox(), this._getStatValue = this._usesPromiseGetStats ? this._defineNewGetStatValueMethod(s) : this._defineGetStatValueMethod(s), this.peerconnection = e, this.baselineAudioLevelsReport = null, this.currentAudioLevelsReport = null, this.currentStatsReport = null, this.previousStatsReport = null, this.audioLevelReportHistory = {}, this.audioLevelsIntervalId = null, this.eventEmitter = r, this.conferenceStats = new h, this.audioLevelsIntervalMilis = t, this.statsIntervalId = null, this.statsIntervalMilis = n, this.ssrc2stats = new Map
            }
            d[r.b.FIREFOX] = {
                ssrc: "ssrc",
                packetsReceived: "packetsReceived",
                packetsLost: "packetsLost",
                packetsSent: "packetsSent",
                bytesReceived: "bytesReceived",
                bytesSent: "bytesSent",
                framerateMean: "framerateMean",
                ip: "address",
                port: "port",
                protocol: "protocol"
            }, d[r.b.CHROME] = {
                receiveBandwidth: "googAvailableReceiveBandwidth",
                sendBandwidth: "googAvailableSendBandwidth",
                remoteAddress: "googRemoteAddress",
                transportType: "googTransportType",
                localAddress: "googLocalAddress",
                activeConnection: "googActiveConnection",
                ssrc: "ssrc",
                packetsReceived: "packetsReceived",
                packetsSent: "packetsSent",
                packetsLost: "packetsLost",
                bytesReceived: "bytesReceived",
                bytesSent: "bytesSent",
                googFrameHeightReceived: "googFrameHeightReceived",
                googFrameWidthReceived: "googFrameWidthReceived",
                googFrameHeightSent: "googFrameHeightSent",
                googFrameWidthSent: "googFrameWidthSent",
                googFrameRateReceived: "googFrameRateReceived",
                googFrameRateSent: "googFrameRateSent",
                audioInputLevel: "audioInputLevel",
                audioOutputLevel: "audioOutputLevel",
                currentRoundTripTime: "googRtt",
                remoteCandidateType: "googRemoteCandidateType",
                localCandidateType: "googLocalCandidateType",
                ip: "ip",
                port: "port",
                protocol: "protocol"
            }, d[r.b.OPERA] = d[r.b.CHROME], d[r.b.NWJS] = d[r.b.CHROME], d[r.b.ELECTRON] = d[r.b.CHROME], d[r.b.SAFARI] = d[r.b.CHROME], d[r.b.REACT_NATIVE] = d[r.b.CHROME], l.prototype.setLoss = function(e) {
                this.loss = e || {}
            }, l.prototype.setResolution = function(e) {
                this.resolution = e || {}
            }, l.prototype.addBitrate = function(e) {
                this.bitrate.download += e.download, this.bitrate.upload += e.upload
            }, l.prototype.resetBitrate = function() {
                this.bitrate.download = 0, this.bitrate.upload = 0
            }, l.prototype.setFramerate = function(e) {
                this.framerate = e || 0
            }, p.prototype.stop = function() {
                this.audioLevelsIntervalId && (clearInterval(this.audioLevelsIntervalId), this.audioLevelsIntervalId = null), this.statsIntervalId && (clearInterval(this.statsIntervalId), this.statsIntervalId = null)
            }, p.prototype.errorCallback = function(e) {
                a.callErrorHandler(e), c.error("Get stats error", e), this.stop()
            }, p.prototype.start = function(e) {
                const t = this;
                e && (this.audioLevelsIntervalId = setInterval(() => {
                    t.peerconnection.getStats(e => {
                        let n = null;
                        n = e && e.result && "function" == typeof e.result ? e.result() : e, t.currentAudioLevelsReport = n, this._usesPromiseGetStats ? t.processNewAudioLevelReport() : t.processAudioLevelReport(), t.baselineAudioLevelsReport = t.currentAudioLevelsReport
                    }, e => t.errorCallback(e))
                }, t.audioLevelsIntervalMilis)), this.statsIntervalId = setInterval(() => {
                    t.peerconnection.getStats(e => {
                        let n = null;
                        n = e && e.result && "function" == typeof e.result ? e.result() : e, t.currentStatsReport = n;
                        try {
                            this._usesPromiseGetStats ? t.processNewStatsReport() : t.processStatsReport()
                        } catch (e) {
                            a.callErrorHandler(e), c.error(`Unsupported key:${e}`, e)
                        }
                        t.previousStatsReport = t.currentStatsReport
                    }, e => t.errorCallback(e))
                }, t.statsIntervalMilis)
            }, p.prototype._defineGetStatValueMethod = function(e) {
                let t;
                switch (this._browserType) {
                    case r.b.CHROME:
                    case r.b.OPERA:
                    case r.b.NWJS:
                    case r.b.ELECTRON:
                        t = (e, t) => e.stat(t);
                        break;
                    case r.b.REACT_NATIVE:
                        t = function(e, t) {
                            let n;
                            return e.values.some(e => !!e.hasOwnProperty(t) && (n = e[t], !0)), n
                        };
                        break;
                    default:
                        t = (e, t) => e[t]
                }
                return (n, i) => t(n, function(t) {
                    const n = e[t];
                    if (n) return n;
                    throw `The property '${t}' isn't supported!`
                }(i))
            }, p.prototype.getNonNegativeStat = function(e, t) {
                let n = this._getStatValue(e, t);
                return "number" != typeof n && (n = Number(n)), isNaN(n) ? 0 : Math.max(0, n)
            }, p.prototype.processStatsReport = function() {
                if (!this.previousStatsReport) return;
                const e = this._getStatValue,
                    t = {};
                for (const n in this.currentStatsReport) {
                    if (!this.currentStatsReport.hasOwnProperty(n)) continue;
                    const i = this.currentStatsReport[n];
                    if (!i) continue;
                    try {
                        const t = e(i, "receiveBandwidth"),
                            n = e(i, "sendBandwidth");
                        (t || n) && (this.conferenceStats.bandwidth = {
                            download: Math.round(t / 1e3),
                            upload: Math.round(n / 1e3)
                        })
                    } catch (e) {}
                    if ("googCandidatePair" === i.type) {
                        let t, n, r, s, o, a, c;
                        try {
                            if (!(t = e(i, "activeConnection"))) continue;
                            n = e(i, "remoteAddress"), c = e(i, "transportType"), s = e(i, "localAddress"), r = e(i, "localCandidateType"), o = e(i, "remoteCandidateType"), a = this.getNonNegativeStat(i, "currentRoundTripTime")
                        } catch (e) {}
                        if (!n || !c || !s || "true" !== t) continue;
                        const d = this.conferenceStats.transport;
                        d.some(e => e.ip === n && e.type === c && e.localip === s) || d.push({
                            ip: n,
                            type: c,
                            localip: s,
                            p2p: this.peerconnection.isP2P,
                            localCandidateType: r,
                            remoteCandidateType: o,
                            rtt: a
                        });
                        continue
                    }
                    if ("candidatepair" === i.type) {
                        if ("succeeded" !== i.state || !i.selected) continue;
                        const e = this.currentStatsReport[i.localCandidateId],
                            t = this.currentStatsReport[i.remoteCandidateId];
                        this.conferenceStats.transport.push({
                            ip: `${t.ipAddress}:${t.portNumber}`,
                            type: e.transport,
                            localip: `${e.ipAddress}:${e.portNumber}`,
                            p2p: this.peerconnection.isP2P,
                            localCandidateType: e.candidateType,
                            remoteCandidateType: t.candidateType
                        })
                    }
                    if ("ssrc" !== i.type && "outboundrtp" !== i.type && "inboundrtp" !== i.type && "track" !== i.type) continue;
                    const r = this.previousStatsReport[n];
                    let s = this.getNonNegativeStat(i, "ssrc");
                    if ("track" === i.type && Array.isArray(i.ssrcIds) && (s = Number(i.ssrcIds[0])), !r || !s) continue;
                    if (!0 === i.isRemote || !0 === i.remoteSource) continue;
                    let o = this.ssrc2stats.get(s);
                    o || (o = new l, this.ssrc2stats.set(s, o));
                    let a = !0,
                        d = "packetsReceived",
                        u = e(i, d);
                    null != u && "" !== u || (a = !1, null == (u = e(i, d = "packetsSent")) && c.warn("No packetsReceived nor packetsSent stat found")), (!u || u < 0) && (u = 0);
                    const h = this.getNonNegativeStat(r, d),
                        p = Math.max(0, u - h),
                        f = this.getNonNegativeStat(i, "packetsLost"),
                        m = this.getNonNegativeStat(r, "packetsLost"),
                        g = Math.max(0, f - m);
                    o.setLoss({
                        packetsTotal: p + g,
                        packetsLost: g,
                        isDownloadStream: a
                    });
                    const _ = this.getNonNegativeStat(i, "bytesReceived"),
                        v = this.getNonNegativeStat(r, "bytesReceived"),
                        S = Math.max(0, _ - v);
                    let y = 0,
                        E = e(i, "bytesSent");
                    "number" != typeof E && "string" != typeof E || (E = Number(E), isNaN(E) || (t[s] = E, E > 0 && (y = E - e(r, "bytesSent")))), y = Math.max(0, y);
                    const T = i.timestamp - r.timestamp;
                    let b = 0,
                        C = 0;
                    T > 0 && (b = Math.round(8 * S / T), C = Math.round(8 * y / T)), o.addBitrate({
                        download: b,
                        upload: C
                    });
                    const R = {
                        height: null,
                        width: null
                    };
                    try {
                        let t, n;
                        (t = e(i, "googFrameHeightReceived")) && (n = e(i, "googFrameWidthReceived")) ? (R.height = t, R.width = n) : (t = e(i, "googFrameHeightSent")) && (n = e(i, "googFrameWidthSent")) && (R.height = t, R.width = n)
                    } catch (e) {}
                    let A;
                    try {
                        A = e(i, "googFrameRateReceived") || e(i, "googFrameRateSent") || 0
                    } catch (e) {
                        try {
                            A = this.getNonNegativeStat(i, "framerateMean")
                        } catch (e) {}
                    }
                    o.setFramerate(Math.round(A || 0)), R.height && R.width ? o.setResolution(R) : o.setResolution(null)
                }
                this.eventEmitter.emit(s.c, this.peerconnection, t), this._processAndEmitReport()
            }, p.prototype._processAndEmitReport = function() {
                const e = {
                        download: 0,
                        upload: 0
                    },
                    t = {
                        download: 0,
                        upload: 0
                    };
                let n = 0,
                    i = 0;
                const r = {},
                    o = {};
                let a = 0,
                    d = 0,
                    l = 0,
                    h = 0;
                for (const [s, u] of this.ssrc2stats) {
                    const p = u.loss,
                        f = p.isDownloadStream ? "download" : "upload";
                    e[f] += p.packetsTotal, t[f] += p.packetsLost, n += u.bitrate.download, i += u.bitrate.upload;
                    const m = this.peerconnection.getTrackBySSRC(s);
                    if (m) {
                        m.isAudioTrack() ? (a += u.bitrate.download, d += u.bitrate.upload) : (l += u.bitrate.download, h += u.bitrate.upload);
                        const e = m.getParticipantId();
                        if (e) {
                            const t = u.resolution;
                            if (t.width && t.height && -1 !== t.width && -1 !== t.height) {
                                const n = r[e] || {};
                                n[s] = t, r[e] = n
                            }
                            if (0 !== u.framerate) {
                                const t = o[e] || {};
                                t[s] = u.framerate, o[e] = t
                            }
                        } else c.error(`No participant ID returned by ${m}`)
                    }
                    u.resetBitrate()
                }
                this.conferenceStats.bitrate = {
                    upload: i,
                    download: n
                }, this.conferenceStats.bitrate.audio = {
                    upload: d,
                    download: a
                }, this.conferenceStats.bitrate.video = {
                    upload: h,
                    download: l
                }, this.conferenceStats.packetLoss = {
                    total: u(t.download + t.upload, e.download + e.upload),
                    download: u(t.download, e.download),
                    upload: u(t.upload, e.upload)
                };
                const p = {};
                let f;
                Object.keys(this.audioLevelReportHistory).forEach(e => {
                    const {
                        data: t,
                        isLocal: n
                    } = this.audioLevelReportHistory[e], i = t.reduce((e, t) => e + t) / t.length;
                    if (n) f = i;
                    else {
                        const t = this.peerconnection.getTrackBySSRC(Number(e));
                        if (t) {
                            const e = t.getParticipantId();
                            e && (p[e] = i)
                        }
                    }
                }), this.audioLevelReportHistory = {}, this.eventEmitter.emit(s.d, this.peerconnection, {
                    bandwidth: this.conferenceStats.bandwidth,
                    bitrate: this.conferenceStats.bitrate,
                    packetLoss: this.conferenceStats.packetLoss,
                    resolution: r,
                    framerate: o,
                    transport: this.conferenceStats.transport,
                    localAvgAudioLevels: f,
                    avgAudioLevels: p
                }), this.conferenceStats.transport = []
            }, p.prototype.processAudioLevelReport = function() {
                if (!this.baselineAudioLevelsReport) return;
                const e = this._getStatValue;
                for (const t in this.currentAudioLevelsReport) {
                    if (!this.currentAudioLevelsReport.hasOwnProperty(t)) continue;
                    const n = this.currentAudioLevelsReport[t];
                    if ("ssrc" !== n.type && "track" !== n.type) continue;
                    const i = this.baselineAudioLevelsReport[t];
                    let r, o = this.getNonNegativeStat(n, "ssrc");
                    if (!o && Array.isArray(n.ssrcIds) && (o = Number(n.ssrcIds[0])), i)
                        if (o) {
                            try {
                                r = e(n, "audioInputLevel") || e(n, "audioOutputLevel")
                            } catch (e) {
                                return c.warn("Audio Levels are not available in the statistics."), void clearInterval(this.audioLevelsIntervalId)
                            }
                            if (r) {
                                let t;
                                t = "ssrc" === n.type ? !e(n, "packetsReceived") : !n.remoteSource, r /= 32767, o in this.audioLevelReportHistory || (this.audioLevelReportHistory[o] = {
                                    isLocal: t,
                                    data: []
                                }), this.audioLevelReportHistory[o].data.push(r), this.eventEmitter.emit(s.a, this.peerconnection, o, r, t)
                            }
                        } else Date.now() - n.timestamp < 3e3 && c.warn("No ssrc: ");
                    else c.warn(`${o} not enough data`)
                }
            }, p.prototype._defineNewGetStatValueMethod = function(e) {
                return (t, n) => t[function(t) {
                    const n = e[t];
                    if (n) return n;
                    throw `The property '${t}' isn't supported!`
                }(n)]
            }, p.prototype.getNonNegativeValue = function(e) {
                let t = e;
                return "number" != typeof t && (t = Number(t)), isNaN(t) ? 0 : Math.max(0, t)
            }, p.prototype._calculateBitrate = function(e, t, n) {
                const i = this.getNonNegativeValue(e[n]),
                    r = this.getNonNegativeValue(t[n]),
                    s = Math.max(0, i - r),
                    o = e.timestamp - t.timestamp;
                let a = 0;
                return o > 0 && (a = Math.round(8 * s / o)), a
            }, p.prototype.processNewStatsReport = function() {
                if (!this.previousStatsReport) return;
                const e = this._getStatValue,
                    t = {};
                this.currentStatsReport.forEach(n => {
                    if ("candidate-pair" === n.type && n.nominated && "succeeded" === n.state) {
                        const t = n.availableIncomingBitrate,
                            i = n.availableOutgoingBitrate;
                        (t || i) && (this.conferenceStats.bandwidth = {
                            download: Math.round(t / 1e3),
                            upload: Math.round(i / 1e3)
                        });
                        const r = this.currentStatsReport.get(n.remoteCandidateId),
                            s = this.currentStatsReport.get(n.localCandidateId);
                        if (r && s) {
                            const t = `${e(r,"ip")}:${e(r,"port")}`,
                                i = `${e(s,"ip")}:${e(s,"port")}`,
                                o = e(r, "protocol"),
                                a = this.conferenceStats.transport;
                            a.some(e => e.ip === t && e.type === o && e.localip === i) || a.push({
                                ip: t,
                                type: o,
                                localIp: i,
                                p2p: this.peerconnection.isP2P,
                                localCandidateType: s.candidateType,
                                remoteCandidateType: r.candidateType,
                                networkType: s.networkType,
                                rtt: 1e3 * n.currentRoundTripTime
                            })
                        }
                    } else if ("inbound-rtp" === n.type || "outbound-rtp" === n.type) {
                        const e = this.previousStatsReport.get(n.id),
                            i = this.getNonNegativeValue(n.ssrc);
                        if (!e || !i) return;
                        let r = this.ssrc2stats.get(i);
                        r || (r = new l, this.ssrc2stats.set(i, r));
                        let s = !0,
                            o = "packetsReceived";
                        "outbound-rtp" === n.type && (s = !1, o = "packetsSent");
                        let a = n[o];
                        (!a || a < 0) && (a = 0);
                        const c = this.getNonNegativeValue(e[o]),
                            d = Math.max(0, a - c),
                            u = this.getNonNegativeValue(n.packetsLost),
                            h = this.getNonNegativeValue(e.packetsLost),
                            p = Math.max(0, u - h);
                        r.setLoss({
                            packetsTotal: d + p,
                            packetsLost: p,
                            isDownloadStream: s
                        }), "inbound-rtp" === n.type ? r.addBitrate({
                            download: this._calculateBitrate(n, e, "bytesReceived"),
                            upload: 0
                        }) : (t[i] = this.getNonNegativeValue(n.bytesSent), r.addBitrate({
                            download: 0,
                            upload: this._calculateBitrate(n, e, "bytesSent")
                        }));
                        const f = n.framerateMean;
                        f && r.setFramerate(Math.round(f || 0))
                    } else if ("track" === n.type) {
                        const e = {
                            height: n.frameHeight,
                            width: n.frameWidth
                        };
                        let t = n.framesPerSecond;
                        if (!t) {
                            const e = this.previousStatsReport.get(n.id);
                            if (e) {
                                const i = n.timestamp - e.timestamp;
                                if (i > 0 && n.framesSent) {
                                    t = (n.framesSent - e.framesSent) / i * 1e3
                                }
                            }
                            if (!t) return
                        }
                        const i = n.trackIdentifier,
                            r = this.peerconnection.getSsrcByTrackId(i);
                        if (!r) return;
                        let s = this.ssrc2stats.get(r);
                        s || (s = new l, this.ssrc2stats.set(r, s)), s.setFramerate(Math.round(t || 0)), e.height && e.width ? s.setResolution(e) : s.setResolution(null)
                    }
                }), this.eventEmitter.emit(s.c, this.peerconnection, t), this._processAndEmitReport()
            }, p.prototype.processNewAudioLevelReport = function() {
                this.baselineAudioLevelsReport && this.currentAudioLevelsReport.forEach(e => {
                    if ("track" !== e.type) return;
                    const t = e.audioLevel;
                    if (!t) return;
                    const n = e.trackIdentifier,
                        i = this.peerconnection.getSsrcByTrackId(n);
                    if (i) {
                        const e = i === this.peerconnection.getLocalSSRC(this.peerconnection.getLocalTracks(o.a));
                        this.eventEmitter.emit(s.a, this.peerconnection, i, t, e)
                    }
                })
            }
        }).call(this, "modules/statistics/RTPStatsCollector.js")
    }, function(e, t, n) {
        "use strict";
        var i = n(45);

        function r(e, t, n, r, s) {
            var o = i.writeRtpDescription(e.kind, t);
            if (o += i.writeIceParameters(e.iceGatherer.getLocalParameters()), o += i.writeDtlsParameters(e.dtlsTransport.getLocalParameters(), "offer" === n ? "actpass" : s || "active"), o += "a=mid:" + e.mid + "\r\n", e.rtpSender && e.rtpReceiver ? o += "a=sendrecv\r\n" : e.rtpSender ? o += "a=sendonly\r\n" : e.rtpReceiver ? o += "a=recvonly\r\n" : o += "a=inactive\r\n", e.rtpSender) {
                var a = e.rtpSender._initialTrackId || e.rtpSender.track.id;
                e.rtpSender._initialTrackId = a;
                var c = "msid:" + (r ? r.id : "-") + " " + a + "\r\n";
                o += "a=" + c, o += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " " + c, e.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " " + c, o += "a=ssrc-group:FID " + e.sendEncodingParameters[0].ssrc + " " + e.sendEncodingParameters[0].rtx.ssrc + "\r\n")
            }
            return o += "a=ssrc:" + e.sendEncodingParameters[0].ssrc + " cname:" + i.localCName + "\r\n", e.rtpSender && e.sendEncodingParameters[0].rtx && (o += "a=ssrc:" + e.sendEncodingParameters[0].rtx.ssrc + " cname:" + i.localCName + "\r\n"), o
        }

        function s(e, t) {
            var n = {
                    codecs: [],
                    headerExtensions: [],
                    fecMechanisms: []
                },
                i = function(e, t) {
                    e = parseInt(e, 10);
                    for (var n = 0; n < t.length; n++)
                        if (t[n].payloadType === e || t[n].preferredPayloadType === e) return t[n]
                },
                r = function(e, t, n, r) {
                    var s = i(e.parameters.apt, n),
                        o = i(t.parameters.apt, r);
                    return s && o && s.name.toLowerCase() === o.name.toLowerCase()
                };
            return e.codecs.forEach((function(i) {
                for (var s = 0; s < t.codecs.length; s++) {
                    var o = t.codecs[s];
                    if (i.name.toLowerCase() === o.name.toLowerCase() && i.clockRate === o.clockRate) {
                        if ("rtx" === i.name.toLowerCase() && i.parameters && o.parameters.apt && !r(i, o, e.codecs, t.codecs)) continue;
                        (o = JSON.parse(JSON.stringify(o))).numChannels = Math.min(i.numChannels, o.numChannels), n.codecs.push(o), o.rtcpFeedback = o.rtcpFeedback.filter((function(e) {
                            for (var t = 0; t < i.rtcpFeedback.length; t++)
                                if (i.rtcpFeedback[t].type === e.type && i.rtcpFeedback[t].parameter === e.parameter) return !0;
                            return !1
                        }));
                        break
                    }
                }
            })), e.headerExtensions.forEach((function(e) {
                for (var i = 0; i < t.headerExtensions.length; i++) {
                    var r = t.headerExtensions[i];
                    if (e.uri === r.uri) {
                        n.headerExtensions.push(r);
                        break
                    }
                }
            })), n
        }

        function o(e, t, n) {
            return -1 !== {
                offer: {
                    setLocalDescription: ["stable", "have-local-offer"],
                    setRemoteDescription: ["stable", "have-remote-offer"]
                },
                answer: {
                    setLocalDescription: ["have-remote-offer", "have-local-pranswer"],
                    setRemoteDescription: ["have-local-offer", "have-remote-pranswer"]
                }
            } [t][e].indexOf(n)
        }

        function a(e, t) {
            var n = e.getRemoteCandidates().find((function(e) {
                return t.foundation === e.foundation && t.ip === e.ip && t.port === e.port && t.priority === e.priority && t.protocol === e.protocol && t.type === e.type
            }));
            return n || e.addRemoteCandidate(t), !n
        }

        function c(e, t) {
            var n = new Error(t);
            return n.name = e, n.code = {
                NotSupportedError: 9,
                InvalidStateError: 11,
                InvalidAccessError: 15,
                TypeError: void 0,
                OperationError: void 0
            } [e], n
        }
        e.exports = function(e, t) {
            function n(t, n) {
                n.addTrack(t), n.dispatchEvent(new e.MediaStreamTrackEvent("addtrack", {
                    track: t
                }))
            }

            function d(t, n, i, r) {
                var s = new Event("track");
                s.track = n, s.receiver = i, s.transceiver = {
                    receiver: i
                }, s.streams = r, e.setTimeout((function() {
                    t._dispatchEvent("track", s)
                }))
            }
            var u = function(n) {
                var r = this,
                    s = document.createDocumentFragment();
                if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach((function(e) {
                        r[e] = s[e].bind(s)
                    })), this.canTrickleIceCandidates = null, this.needNegotiation = !1, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", n = JSON.parse(JSON.stringify(n || {})), this.usingBundle = "max-bundle" === n.bundlePolicy, "negotiate" === n.rtcpMuxPolicy) throw c("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported");
                switch (n.rtcpMuxPolicy || (n.rtcpMuxPolicy = "require"), n.iceTransportPolicy) {
                    case "all":
                    case "relay":
                        break;
                    default:
                        n.iceTransportPolicy = "all"
                }
                switch (n.bundlePolicy) {
                    case "balanced":
                    case "max-compat":
                    case "max-bundle":
                        break;
                    default:
                        n.bundlePolicy = "balanced"
                }
                if (n.iceServers = function(e, t) {
                        var n = !1;
                        return (e = JSON.parse(JSON.stringify(e))).filter((function(e) {
                            if (e && (e.urls || e.url)) {
                                var i = e.urls || e.url;
                                e.url && !e.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead.");
                                var r = "string" == typeof i;
                                return r && (i = [i]), i = i.filter((function(e) {
                                    return 0 === e.indexOf("turn:") && -1 !== e.indexOf("transport=udp") && -1 === e.indexOf("turn:[") && !n ? (n = !0, !0) : 0 === e.indexOf("stun:") && t >= 14393 && -1 === e.indexOf("?transport=udp")
                                })), delete e.url, e.urls = r ? i[0] : i, !!i.length
                            }
                        }))
                    }(n.iceServers || [], t), this._iceGatherers = [], n.iceCandidatePoolSize)
                    for (var o = n.iceCandidatePoolSize; o > 0; o--) this._iceGatherers.push(new e.RTCIceGatherer({
                        iceServers: n.iceServers,
                        gatherPolicy: n.iceTransportPolicy
                    }));
                else n.iceCandidatePoolSize = 0;
                this._config = n, this.transceivers = [], this._sdpSessionId = i.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = !1
            };
            Object.defineProperty(u.prototype, "localDescription", {
                configurable: !0,
                get: function() {
                    return this._localDescription
                }
            }), Object.defineProperty(u.prototype, "remoteDescription", {
                configurable: !0,
                get: function() {
                    return this._remoteDescription
                }
            }), u.prototype.onicecandidate = null, u.prototype.onaddstream = null, u.prototype.ontrack = null, u.prototype.onremovestream = null, u.prototype.onsignalingstatechange = null, u.prototype.oniceconnectionstatechange = null, u.prototype.onconnectionstatechange = null, u.prototype.onicegatheringstatechange = null, u.prototype.onnegotiationneeded = null, u.prototype.ondatachannel = null, u.prototype._dispatchEvent = function(e, t) {
                this._isClosed || (this.dispatchEvent(t), "function" == typeof this["on" + e] && this["on" + e](t))
            }, u.prototype._emitGatheringStateChange = function() {
                var e = new Event("icegatheringstatechange");
                this._dispatchEvent("icegatheringstatechange", e)
            }, u.prototype.getConfiguration = function() {
                return this._config
            }, u.prototype.getLocalStreams = function() {
                return this.localStreams
            }, u.prototype.getRemoteStreams = function() {
                return this.remoteStreams
            }, u.prototype._createTransceiver = function(e, t) {
                var n = this.transceivers.length > 0,
                    i = {
                        track: null,
                        iceGatherer: null,
                        iceTransport: null,
                        dtlsTransport: null,
                        localCapabilities: null,
                        remoteCapabilities: null,
                        rtpSender: null,
                        rtpReceiver: null,
                        kind: e,
                        mid: null,
                        sendEncodingParameters: null,
                        recvEncodingParameters: null,
                        stream: null,
                        associatedRemoteMediaStreams: [],
                        wantReceive: !0
                    };
                if (this.usingBundle && n) i.iceTransport = this.transceivers[0].iceTransport, i.dtlsTransport = this.transceivers[0].dtlsTransport;
                else {
                    var r = this._createIceAndDtlsTransports();
                    i.iceTransport = r.iceTransport, i.dtlsTransport = r.dtlsTransport
                }
                return t || this.transceivers.push(i), i
            }, u.prototype.addTrack = function(t, n) {
                if (this._isClosed) throw c("InvalidStateError", "Attempted to call addTrack on a closed peerconnection.");
                var i;
                if (this.transceivers.find((function(e) {
                        return e.track === t
                    }))) throw c("InvalidAccessError", "Track already exists.");
                for (var r = 0; r < this.transceivers.length; r++) this.transceivers[r].track || this.transceivers[r].kind !== t.kind || (i = this.transceivers[r]);
                return i || (i = this._createTransceiver(t.kind)), this._maybeFireNegotiationNeeded(), -1 === this.localStreams.indexOf(n) && this.localStreams.push(n), i.track = t, i.stream = n, i.rtpSender = new e.RTCRtpSender(t, i.dtlsTransport), i.rtpSender
            }, u.prototype.addStream = function(e) {
                var n = this;
                if (t >= 15025) e.getTracks().forEach((function(t) {
                    n.addTrack(t, e)
                }));
                else {
                    var i = e.clone();
                    e.getTracks().forEach((function(e, t) {
                        var n = i.getTracks()[t];
                        e.addEventListener("enabled", (function(e) {
                            n.enabled = e.enabled
                        }))
                    })), i.getTracks().forEach((function(e) {
                        n.addTrack(e, i)
                    }))
                }
            }, u.prototype.removeTrack = function(t) {
                if (this._isClosed) throw c("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection.");
                if (!(t instanceof e.RTCRtpSender)) throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.");
                var n = this.transceivers.find((function(e) {
                    return e.rtpSender === t
                }));
                if (!n) throw c("InvalidAccessError", "Sender was not created by this connection.");
                var i = n.stream;
                n.rtpSender.stop(), n.rtpSender = null, n.track = null, n.stream = null, -1 === this.transceivers.map((function(e) {
                    return e.stream
                })).indexOf(i) && this.localStreams.indexOf(i) > -1 && this.localStreams.splice(this.localStreams.indexOf(i), 1), this._maybeFireNegotiationNeeded()
            }, u.prototype.removeStream = function(e) {
                var t = this;
                e.getTracks().forEach((function(e) {
                    var n = t.getSenders().find((function(t) {
                        return t.track === e
                    }));
                    n && t.removeTrack(n)
                }))
            }, u.prototype.getSenders = function() {
                return this.transceivers.filter((function(e) {
                    return !!e.rtpSender
                })).map((function(e) {
                    return e.rtpSender
                }))
            }, u.prototype.getReceivers = function() {
                return this.transceivers.filter((function(e) {
                    return !!e.rtpReceiver
                })).map((function(e) {
                    return e.rtpReceiver
                }))
            }, u.prototype._createIceGatherer = function(t, n) {
                var i = this;
                if (n && t > 0) return this.transceivers[0].iceGatherer;
                if (this._iceGatherers.length) return this._iceGatherers.shift();
                var r = new e.RTCIceGatherer({
                    iceServers: this._config.iceServers,
                    gatherPolicy: this._config.iceTransportPolicy
                });
                return Object.defineProperty(r, "state", {
                    value: "new",
                    writable: !0
                }), this.transceivers[t].bufferedCandidateEvents = [], this.transceivers[t].bufferCandidates = function(e) {
                    var n = !e.candidate || 0 === Object.keys(e.candidate).length;
                    r.state = n ? "completed" : "gathering", null !== i.transceivers[t].bufferedCandidateEvents && i.transceivers[t].bufferedCandidateEvents.push(e)
                }, r.addEventListener("localcandidate", this.transceivers[t].bufferCandidates), r
            }, u.prototype._gather = function(t, n) {
                var r = this,
                    s = this.transceivers[n].iceGatherer;
                if (!s.onlocalcandidate) {
                    var o = this.transceivers[n].bufferedCandidateEvents;
                    this.transceivers[n].bufferedCandidateEvents = null, s.removeEventListener("localcandidate", this.transceivers[n].bufferCandidates), s.onlocalcandidate = function(e) {
                        if (!(r.usingBundle && n > 0)) {
                            var o = new Event("icecandidate");
                            o.candidate = {
                                sdpMid: t,
                                sdpMLineIndex: n
                            };
                            var a = e.candidate,
                                c = !a || 0 === Object.keys(a).length;
                            if (c) "new" !== s.state && "gathering" !== s.state || (s.state = "completed");
                            else {
                                "new" === s.state && (s.state = "gathering"), a.component = 1, a.ufrag = s.getLocalParameters().usernameFragment;
                                var d = i.writeCandidate(a);
                                o.candidate = Object.assign(o.candidate, i.parseCandidate(d)), o.candidate.candidate = d, o.candidate.toJSON = function() {
                                    return {
                                        candidate: o.candidate.candidate,
                                        sdpMid: o.candidate.sdpMid,
                                        sdpMLineIndex: o.candidate.sdpMLineIndex,
                                        usernameFragment: o.candidate.usernameFragment
                                    }
                                }
                            }
                            var u = i.getMediaSections(r._localDescription.sdp);
                            u[o.candidate.sdpMLineIndex] += c ? "a=end-of-candidates\r\n" : "a=" + o.candidate.candidate + "\r\n", r._localDescription.sdp = i.getDescription(r._localDescription.sdp) + u.join("");
                            var l = r.transceivers.every((function(e) {
                                return e.iceGatherer && "completed" === e.iceGatherer.state
                            }));
                            "gathering" !== r.iceGatheringState && (r.iceGatheringState = "gathering", r._emitGatheringStateChange()), c || r._dispatchEvent("icecandidate", o), l && (r._dispatchEvent("icecandidate", new Event("icecandidate")), r.iceGatheringState = "complete", r._emitGatheringStateChange())
                        }
                    }, e.setTimeout((function() {
                        o.forEach((function(e) {
                            s.onlocalcandidate(e)
                        }))
                    }), 0)
                }
            }, u.prototype._createIceAndDtlsTransports = function() {
                var t = this,
                    n = new e.RTCIceTransport(null);
                n.onicestatechange = function() {
                    t._updateIceConnectionState(), t._updateConnectionState()
                };
                var i = new e.RTCDtlsTransport(n);
                return i.ondtlsstatechange = function() {
                    t._updateConnectionState()
                }, i.onerror = function() {
                    Object.defineProperty(i, "state", {
                        value: "failed",
                        writable: !0
                    }), t._updateConnectionState()
                }, {
                    iceTransport: n,
                    dtlsTransport: i
                }
            }, u.prototype._disposeIceAndDtlsTransports = function(e) {
                var t = this.transceivers[e].iceGatherer;
                t && (delete t.onlocalcandidate, delete this.transceivers[e].iceGatherer);
                var n = this.transceivers[e].iceTransport;
                n && (delete n.onicestatechange, delete this.transceivers[e].iceTransport);
                var i = this.transceivers[e].dtlsTransport;
                i && (delete i.ondtlsstatechange, delete i.onerror, delete this.transceivers[e].dtlsTransport)
            }, u.prototype._transceive = function(e, n, r) {
                var o = s(e.localCapabilities, e.remoteCapabilities);
                n && e.rtpSender && (o.encodings = e.sendEncodingParameters, o.rtcp = {
                    cname: i.localCName,
                    compound: e.rtcpParameters.compound
                }, e.recvEncodingParameters.length && (o.rtcp.ssrc = e.recvEncodingParameters[0].ssrc), e.rtpSender.send(o)), r && e.rtpReceiver && o.codecs.length > 0 && ("video" === e.kind && e.recvEncodingParameters && t < 15019 && e.recvEncodingParameters.forEach((function(e) {
                    delete e.rtx
                })), e.recvEncodingParameters.length ? o.encodings = e.recvEncodingParameters : o.encodings = [{}], o.rtcp = {
                    compound: e.rtcpParameters.compound
                }, e.rtcpParameters.cname && (o.rtcp.cname = e.rtcpParameters.cname), e.sendEncodingParameters.length && (o.rtcp.ssrc = e.sendEncodingParameters[0].ssrc), e.rtpReceiver.receive(o))
            }, u.prototype.setLocalDescription = function(e) {
                var t, n, r = this;
                if (-1 === ["offer", "answer"].indexOf(e.type)) return Promise.reject(c("TypeError", 'Unsupported type "' + e.type + '"'));
                if (!o("setLocalDescription", e.type, r.signalingState) || r._isClosed) return Promise.reject(c("InvalidStateError", "Can not set local " + e.type + " in state " + r.signalingState));
                if ("offer" === e.type) t = i.splitSections(e.sdp), n = t.shift(), t.forEach((function(e, t) {
                    var n = i.parseRtpParameters(e);
                    r.transceivers[t].localCapabilities = n
                })), r.transceivers.forEach((function(e, t) {
                    r._gather(e.mid, t)
                }));
                else if ("answer" === e.type) {
                    t = i.splitSections(r._remoteDescription.sdp), n = t.shift();
                    var a = i.matchPrefix(n, "a=ice-lite").length > 0;
                    t.forEach((function(e, t) {
                        var o = r.transceivers[t],
                            c = o.iceGatherer,
                            d = o.iceTransport,
                            u = o.dtlsTransport,
                            l = o.localCapabilities,
                            h = o.remoteCapabilities;
                        if (!(i.isRejected(e) && 0 === i.matchPrefix(e, "a=bundle-only").length) && !o.rejected) {
                            var p = i.getIceParameters(e, n),
                                f = i.getDtlsParameters(e, n);
                            a && (f.role = "server"), r.usingBundle && 0 !== t || (r._gather(o.mid, t), "new" === d.state && d.start(c, p, a ? "controlling" : "controlled"), "new" === u.state && u.start(f));
                            var m = s(l, h);
                            r._transceive(o, m.codecs.length > 0, !1)
                        }
                    }))
                }
                return r._localDescription = {
                    type: e.type,
                    sdp: e.sdp
                }, "offer" === e.type ? r._updateSignalingState("have-local-offer") : r._updateSignalingState("stable"), Promise.resolve()
            }, u.prototype.setRemoteDescription = function(r) {
                var u = this;
                if (-1 === ["offer", "answer"].indexOf(r.type)) return Promise.reject(c("TypeError", 'Unsupported type "' + r.type + '"'));
                if (!o("setRemoteDescription", r.type, u.signalingState) || u._isClosed) return Promise.reject(c("InvalidStateError", "Can not set remote " + r.type + " in state " + u.signalingState));
                var l = {};
                u.remoteStreams.forEach((function(e) {
                    l[e.id] = e
                }));
                var h = [],
                    p = i.splitSections(r.sdp),
                    f = p.shift(),
                    m = i.matchPrefix(f, "a=ice-lite").length > 0,
                    g = i.matchPrefix(f, "a=group:BUNDLE ").length > 0;
                u.usingBundle = g;
                var _ = i.matchPrefix(f, "a=ice-options:")[0];
                return u.canTrickleIceCandidates = !!_ && _.substr(14).split(" ").indexOf("trickle") >= 0, p.forEach((function(o, c) {
                    var d = i.splitLines(o),
                        p = i.getKind(o),
                        _ = i.isRejected(o) && 0 === i.matchPrefix(o, "a=bundle-only").length,
                        v = d[0].substr(2).split(" ")[2],
                        S = i.getDirection(o, f),
                        y = i.parseMsid(o),
                        E = i.getMid(o) || i.generateIdentifier();
                    if (_ || "application" === p && ("DTLS/SCTP" === v || "UDP/DTLS/SCTP" === v)) u.transceivers[c] = {
                        mid: E,
                        kind: p,
                        protocol: v,
                        rejected: !0
                    };
                    else {
                        var T, b, C, R, A, w, I, P, D;
                        !_ && u.transceivers[c] && u.transceivers[c].rejected && (u.transceivers[c] = u._createTransceiver(p, !0));
                        var O, N, M = i.parseRtpParameters(o);
                        _ || (O = i.getIceParameters(o, f), (N = i.getDtlsParameters(o, f)).role = "client"), I = i.parseRtpEncodingParameters(o);
                        var L = i.parseRtcpParameters(o),
                            k = i.matchPrefix(o, "a=end-of-candidates", f).length > 0,
                            x = i.matchPrefix(o, "a=candidate:").map((function(e) {
                                return i.parseCandidate(e)
                            })).filter((function(e) {
                                return 1 === e.component
                            }));
                        if (("offer" === r.type || "answer" === r.type) && !_ && g && c > 0 && u.transceivers[c] && (u._disposeIceAndDtlsTransports(c), u.transceivers[c].iceGatherer = u.transceivers[0].iceGatherer, u.transceivers[c].iceTransport = u.transceivers[0].iceTransport, u.transceivers[c].dtlsTransport = u.transceivers[0].dtlsTransport, u.transceivers[c].rtpSender && u.transceivers[c].rtpSender.setTransport(u.transceivers[0].dtlsTransport), u.transceivers[c].rtpReceiver && u.transceivers[c].rtpReceiver.setTransport(u.transceivers[0].dtlsTransport)), "offer" !== r.type || _) {
                            if ("answer" === r.type && !_) {
                                b = (T = u.transceivers[c]).iceGatherer, C = T.iceTransport, R = T.dtlsTransport, A = T.rtpReceiver, w = T.sendEncodingParameters, P = T.localCapabilities, u.transceivers[c].recvEncodingParameters = I, u.transceivers[c].remoteCapabilities = M, u.transceivers[c].rtcpParameters = L, x.length && "new" === C.state && (!m && !k || g && 0 !== c ? x.forEach((function(e) {
                                    a(T.iceTransport, e)
                                })) : C.setRemoteCandidates(x)), g && 0 !== c || ("new" === C.state && C.start(b, O, "controlling"), "new" === R.state && R.start(N)), !s(T.localCapabilities, T.remoteCapabilities).codecs.filter((function(e) {
                                    return "rtx" === e.name.toLowerCase()
                                })).length && T.sendEncodingParameters[0].rtx && delete T.sendEncodingParameters[0].rtx, u._transceive(T, "sendrecv" === S || "recvonly" === S, "sendrecv" === S || "sendonly" === S), !A || "sendrecv" !== S && "sendonly" !== S ? delete T.rtpReceiver : (D = A.track, y ? (l[y.stream] || (l[y.stream] = new e.MediaStream), n(D, l[y.stream]), h.push([D, A, l[y.stream]])) : (l.default || (l.default = new e.MediaStream), n(D, l.default), h.push([D, A, l.default])))
                            }
                        } else {
                            (T = u.transceivers[c] || u._createTransceiver(p)).mid = E, T.iceGatherer || (T.iceGatherer = u._createIceGatherer(c, g)), x.length && "new" === T.iceTransport.state && (!k || g && 0 !== c ? x.forEach((function(e) {
                                a(T.iceTransport, e)
                            })) : T.iceTransport.setRemoteCandidates(x)), P = e.RTCRtpReceiver.getCapabilities(p), t < 15019 && (P.codecs = P.codecs.filter((function(e) {
                                return "rtx" !== e.name
                            }))), w = T.sendEncodingParameters || [{
                                ssrc: 1001 * (2 * c + 2)
                            }];
                            var F, j = !1;
                            if ("sendrecv" === S || "sendonly" === S) {
                                if (j = !T.rtpReceiver, A = T.rtpReceiver || new e.RTCRtpReceiver(T.dtlsTransport, p), j) D = A.track, y && "-" === y.stream || (y ? (l[y.stream] || (l[y.stream] = new e.MediaStream, Object.defineProperty(l[y.stream], "id", {
                                    get: function() {
                                        return y.stream
                                    }
                                })), Object.defineProperty(D, "id", {
                                    get: function() {
                                        return y.track
                                    }
                                }), F = l[y.stream]) : (l.default || (l.default = new e.MediaStream), F = l.default)), F && (n(D, F), T.associatedRemoteMediaStreams.push(F)), h.push([D, A, F])
                            } else T.rtpReceiver && T.rtpReceiver.track && (T.associatedRemoteMediaStreams.forEach((function(t) {
                                var n = t.getTracks().find((function(e) {
                                    return e.id === T.rtpReceiver.track.id
                                }));
                                n && function(t, n) {
                                    n.removeTrack(t), n.dispatchEvent(new e.MediaStreamTrackEvent("removetrack", {
                                        track: t
                                    }))
                                }(n, t)
                            })), T.associatedRemoteMediaStreams = []);
                            T.localCapabilities = P, T.remoteCapabilities = M, T.rtpReceiver = A, T.rtcpParameters = L, T.sendEncodingParameters = w, T.recvEncodingParameters = I, u._transceive(u.transceivers[c], !1, j)
                        }
                    }
                })), void 0 === u._dtlsRole && (u._dtlsRole = "offer" === r.type ? "active" : "passive"), u._remoteDescription = {
                    type: r.type,
                    sdp: r.sdp
                }, "offer" === r.type ? u._updateSignalingState("have-remote-offer") : u._updateSignalingState("stable"), Object.keys(l).forEach((function(t) {
                    var n = l[t];
                    if (n.getTracks().length) {
                        if (-1 === u.remoteStreams.indexOf(n)) {
                            u.remoteStreams.push(n);
                            var i = new Event("addstream");
                            i.stream = n, e.setTimeout((function() {
                                u._dispatchEvent("addstream", i)
                            }))
                        }
                        h.forEach((function(e) {
                            var t = e[0],
                                i = e[1];
                            n.id === e[2].id && d(u, t, i, [n])
                        }))
                    }
                })), h.forEach((function(e) {
                    e[2] || d(u, e[0], e[1], [])
                })), e.setTimeout((function() {
                    u && u.transceivers && u.transceivers.forEach((function(e) {
                        e.iceTransport && "new" === e.iceTransport.state && e.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), e.iceTransport.addRemoteCandidate({}))
                    }))
                }), 4e3), Promise.resolve()
            }, u.prototype.close = function() {
                this.transceivers.forEach((function(e) {
                    e.iceTransport && e.iceTransport.stop(), e.dtlsTransport && e.dtlsTransport.stop(), e.rtpSender && e.rtpSender.stop(), e.rtpReceiver && e.rtpReceiver.stop()
                })), this._isClosed = !0, this._updateSignalingState("closed")
            }, u.prototype._updateSignalingState = function(e) {
                this.signalingState = e;
                var t = new Event("signalingstatechange");
                this._dispatchEvent("signalingstatechange", t)
            }, u.prototype._maybeFireNegotiationNeeded = function() {
                var t = this;
                "stable" === this.signalingState && !0 !== this.needNegotiation && (this.needNegotiation = !0, e.setTimeout((function() {
                    if (t.needNegotiation) {
                        t.needNegotiation = !1;
                        var e = new Event("negotiationneeded");
                        t._dispatchEvent("negotiationneeded", e)
                    }
                }), 0))
            }, u.prototype._updateIceConnectionState = function() {
                var e, t = {
                    new: 0,
                    closed: 0,
                    checking: 0,
                    connected: 0,
                    completed: 0,
                    disconnected: 0,
                    failed: 0
                };
                if (this.transceivers.forEach((function(e) {
                        e.iceTransport && !e.rejected && t[e.iceTransport.state]++
                    })), e = "new", t.failed > 0 ? e = "failed" : t.checking > 0 ? e = "checking" : t.disconnected > 0 ? e = "disconnected" : t.new > 0 ? e = "new" : t.connected > 0 ? e = "connected" : t.completed > 0 && (e = "completed"), e !== this.iceConnectionState) {
                    this.iceConnectionState = e;
                    var n = new Event("iceconnectionstatechange");
                    this._dispatchEvent("iceconnectionstatechange", n)
                }
            }, u.prototype._updateConnectionState = function() {
                var e, t = {
                    new: 0,
                    closed: 0,
                    connecting: 0,
                    connected: 0,
                    completed: 0,
                    disconnected: 0,
                    failed: 0
                };
                if (this.transceivers.forEach((function(e) {
                        e.iceTransport && e.dtlsTransport && !e.rejected && (t[e.iceTransport.state]++, t[e.dtlsTransport.state]++)
                    })), t.connected += t.completed, e = "new", t.failed > 0 ? e = "failed" : t.connecting > 0 ? e = "connecting" : t.disconnected > 0 ? e = "disconnected" : t.new > 0 ? e = "new" : t.connected > 0 && (e = "connected"), e !== this.connectionState) {
                    this.connectionState = e;
                    var n = new Event("connectionstatechange");
                    this._dispatchEvent("connectionstatechange", n)
                }
            }, u.prototype.createOffer = function() {
                var n = this;
                if (n._isClosed) return Promise.reject(c("InvalidStateError", "Can not call createOffer after close"));
                var s = n.transceivers.filter((function(e) {
                        return "audio" === e.kind
                    })).length,
                    o = n.transceivers.filter((function(e) {
                        return "video" === e.kind
                    })).length,
                    a = arguments[0];
                if (a) {
                    if (a.mandatory || a.optional) throw new TypeError("Legacy mandatory/optional constraints not supported.");
                    void 0 !== a.offerToReceiveAudio && (s = !0 === a.offerToReceiveAudio ? 1 : !1 === a.offerToReceiveAudio ? 0 : a.offerToReceiveAudio), void 0 !== a.offerToReceiveVideo && (o = !0 === a.offerToReceiveVideo ? 1 : !1 === a.offerToReceiveVideo ? 0 : a.offerToReceiveVideo)
                }
                for (n.transceivers.forEach((function(e) {
                        "audio" === e.kind ? --s < 0 && (e.wantReceive = !1) : "video" === e.kind && --o < 0 && (e.wantReceive = !1)
                    })); s > 0 || o > 0;) s > 0 && (n._createTransceiver("audio"), s--), o > 0 && (n._createTransceiver("video"), o--);
                var d = i.writeSessionBoilerplate(n._sdpSessionId, n._sdpSessionVersion++);
                n.transceivers.forEach((function(r, s) {
                    var o = r.track,
                        a = r.kind,
                        c = r.mid || i.generateIdentifier();
                    r.mid = c, r.iceGatherer || (r.iceGatherer = n._createIceGatherer(s, n.usingBundle));
                    var d = e.RTCRtpSender.getCapabilities(a);
                    t < 15019 && (d.codecs = d.codecs.filter((function(e) {
                        return "rtx" !== e.name
                    }))), d.codecs.forEach((function(e) {
                        "H264" === e.name && void 0 === e.parameters["level-asymmetry-allowed"] && (e.parameters["level-asymmetry-allowed"] = "1"), r.remoteCapabilities && r.remoteCapabilities.codecs && r.remoteCapabilities.codecs.forEach((function(t) {
                            e.name.toLowerCase() === t.name.toLowerCase() && e.clockRate === t.clockRate && (e.preferredPayloadType = t.payloadType)
                        }))
                    })), d.headerExtensions.forEach((function(e) {
                        (r.remoteCapabilities && r.remoteCapabilities.headerExtensions || []).forEach((function(t) {
                            e.uri === t.uri && (e.id = t.id)
                        }))
                    }));
                    var u = r.sendEncodingParameters || [{
                        ssrc: 1001 * (2 * s + 1)
                    }];
                    o && t >= 15019 && "video" === a && !u[0].rtx && (u[0].rtx = {
                        ssrc: u[0].ssrc + 1
                    }), r.wantReceive && (r.rtpReceiver = new e.RTCRtpReceiver(r.dtlsTransport, a)), r.localCapabilities = d, r.sendEncodingParameters = u
                })), "max-compat" !== n._config.bundlePolicy && (d += "a=group:BUNDLE " + n.transceivers.map((function(e) {
                    return e.mid
                })).join(" ") + "\r\n"), d += "a=ice-options:trickle\r\n", n.transceivers.forEach((function(e, t) {
                    d += r(e, e.localCapabilities, "offer", e.stream, n._dtlsRole), d += "a=rtcp-rsize\r\n", !e.iceGatherer || "new" === n.iceGatheringState || 0 !== t && n.usingBundle || (e.iceGatherer.getLocalCandidates().forEach((function(e) {
                        e.component = 1, d += "a=" + i.writeCandidate(e) + "\r\n"
                    })), "completed" === e.iceGatherer.state && (d += "a=end-of-candidates\r\n"))
                }));
                var u = new e.RTCSessionDescription({
                    type: "offer",
                    sdp: d
                });
                return Promise.resolve(u)
            }, u.prototype.createAnswer = function() {
                var n = this;
                if (n._isClosed) return Promise.reject(c("InvalidStateError", "Can not call createAnswer after close"));
                if ("have-remote-offer" !== n.signalingState && "have-local-pranswer" !== n.signalingState) return Promise.reject(c("InvalidStateError", "Can not call createAnswer in signalingState " + n.signalingState));
                var o = i.writeSessionBoilerplate(n._sdpSessionId, n._sdpSessionVersion++);
                n.usingBundle && (o += "a=group:BUNDLE " + n.transceivers.map((function(e) {
                    return e.mid
                })).join(" ") + "\r\n"), o += "a=ice-options:trickle\r\n";
                var a = i.getMediaSections(n._remoteDescription.sdp).length;
                n.transceivers.forEach((function(e, i) {
                    if (!(i + 1 > a)) {
                        if (e.rejected) return "application" === e.kind ? "DTLS/SCTP" === e.protocol ? o += "m=application 0 DTLS/SCTP 5000\r\n" : o += "m=application 0 " + e.protocol + " webrtc-datachannel\r\n" : "audio" === e.kind ? o += "m=audio 0 UDP/TLS/RTP/SAVPF 0\r\na=rtpmap:0 PCMU/8000\r\n" : "video" === e.kind && (o += "m=video 0 UDP/TLS/RTP/SAVPF 120\r\na=rtpmap:120 VP8/90000\r\n"), void(o += "c=IN IP4 0.0.0.0\r\na=inactive\r\na=mid:" + e.mid + "\r\n");
                        var c;
                        if (e.stream) "audio" === e.kind ? c = e.stream.getAudioTracks()[0] : "video" === e.kind && (c = e.stream.getVideoTracks()[0]), c && t >= 15019 && "video" === e.kind && !e.sendEncodingParameters[0].rtx && (e.sendEncodingParameters[0].rtx = {
                            ssrc: e.sendEncodingParameters[0].ssrc + 1
                        });
                        var d = s(e.localCapabilities, e.remoteCapabilities);
                        !d.codecs.filter((function(e) {
                            return "rtx" === e.name.toLowerCase()
                        })).length && e.sendEncodingParameters[0].rtx && delete e.sendEncodingParameters[0].rtx, o += r(e, d, "answer", e.stream, n._dtlsRole), e.rtcpParameters && e.rtcpParameters.reducedSize && (o += "a=rtcp-rsize\r\n")
                    }
                }));
                var d = new e.RTCSessionDescription({
                    type: "answer",
                    sdp: o
                });
                return Promise.resolve(d)
            }, u.prototype.addIceCandidate = function(e) {
                var t, n = this;
                return e && void 0 === e.sdpMLineIndex && !e.sdpMid ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise((function(r, s) {
                    if (!n._remoteDescription) return s(c("InvalidStateError", "Can not add ICE candidate without a remote description"));
                    if (e && "" !== e.candidate) {
                        var o = e.sdpMLineIndex;
                        if (e.sdpMid)
                            for (var d = 0; d < n.transceivers.length; d++)
                                if (n.transceivers[d].mid === e.sdpMid) {
                                    o = d;
                                    break
                                } var u = n.transceivers[o];
                        if (!u) return s(c("OperationError", "Can not add ICE candidate"));
                        if (u.rejected) return r();
                        var l = Object.keys(e.candidate).length > 0 ? i.parseCandidate(e.candidate) : {};
                        if ("tcp" === l.protocol && (0 === l.port || 9 === l.port)) return r();
                        if (l.component && 1 !== l.component) return r();
                        if ((0 === o || o > 0 && u.iceTransport !== n.transceivers[0].iceTransport) && !a(u.iceTransport, l)) return s(c("OperationError", "Can not add ICE candidate"));
                        var h = e.candidate.trim();
                        0 === h.indexOf("a=") && (h = h.substr(2)), (t = i.getMediaSections(n._remoteDescription.sdp))[o] += "a=" + (l.type ? h : "end-of-candidates") + "\r\n", n._remoteDescription.sdp = i.getDescription(n._remoteDescription.sdp) + t.join("")
                    } else
                        for (var p = 0; p < n.transceivers.length && (n.transceivers[p].rejected || (n.transceivers[p].iceTransport.addRemoteCandidate({}), (t = i.getMediaSections(n._remoteDescription.sdp))[p] += "a=end-of-candidates\r\n", n._remoteDescription.sdp = i.getDescription(n._remoteDescription.sdp) + t.join(""), !n.usingBundle)); p++);
                    r()
                }))
            }, u.prototype.getStats = function(t) {
                if (t && t instanceof e.MediaStreamTrack) {
                    var n = null;
                    if (this.transceivers.forEach((function(e) {
                            e.rtpSender && e.rtpSender.track === t ? n = e.rtpSender : e.rtpReceiver && e.rtpReceiver.track === t && (n = e.rtpReceiver)
                        })), !n) throw c("InvalidAccessError", "Invalid selector.");
                    return n.getStats()
                }
                var i = [];
                return this.transceivers.forEach((function(e) {
                    ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach((function(t) {
                        e[t] && i.push(e[t].getStats())
                    }))
                })), Promise.all(i).then((function(e) {
                    var t = new Map;
                    return e.forEach((function(e) {
                        e.forEach((function(e) {
                            t.set(e.id, e)
                        }))
                    })), t
                }))
            };
            ["RTCRtpSender", "RTCRtpReceiver", "RTCIceGatherer", "RTCIceTransport", "RTCDtlsTransport"].forEach((function(t) {
                var n = e[t];
                if (n && n.prototype && n.prototype.getStats) {
                    var i = n.prototype.getStats;
                    n.prototype.getStats = function() {
                        return i.apply(this).then((function(e) {
                            var t = new Map;
                            return Object.keys(e).forEach((function(n) {
                                var i;
                                e[n].type = {
                                    inboundrtp: "inbound-rtp",
                                    outboundrtp: "outbound-rtp",
                                    candidatepair: "candidate-pair",
                                    localcandidate: "local-candidate",
                                    remotecandidate: "remote-candidate"
                                } [(i = e[n]).type] || i.type, t.set(n, e[n])
                            })), t
                        }))
                    }
                }
            }));
            var l = ["createOffer", "createAnswer"];
            return l.forEach((function(e) {
                var t = u.prototype[e];
                u.prototype[e] = function() {
                    var e = arguments;
                    return "function" == typeof e[0] || "function" == typeof e[1] ? t.apply(this, [arguments[2]]).then((function(t) {
                        "function" == typeof e[0] && e[0].apply(null, [t])
                    }), (function(t) {
                        "function" == typeof e[1] && e[1].apply(null, [t])
                    })) : t.apply(this, arguments)
                }
            })), (l = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"]).forEach((function(e) {
                var t = u.prototype[e];
                u.prototype[e] = function() {
                    var e = arguments;
                    return "function" == typeof e[1] || "function" == typeof e[2] ? t.apply(this, arguments).then((function() {
                        "function" == typeof e[1] && e[1].apply(null)
                    }), (function(t) {
                        "function" == typeof e[2] && e[2].apply(null, [t])
                    })) : t.apply(this, arguments)
                }
            })), ["getStats"].forEach((function(e) {
                var t = u.prototype[e];
                u.prototype[e] = function() {
                    var e = arguments;
                    return "function" == typeof e[1] ? t.apply(this, arguments).then((function() {
                        "function" == typeof e[1] && e[1].apply(null)
                    })) : t.apply(this, arguments)
                }
            })), u
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return C
            }));
            var i = n(4),
                r = n(132),
                s = n(21),
                o = n.n(s),
                a = n(11),
                c = n(81),
                d = n(9),
                u = n(82),
                l = n(12),
                h = n(10),
                p = n(3),
                f = n(8),
                m = n.n(f),
                g = n(83),
                _ = n(61),
                v = n(17),
                S = n(84),
                y = n(27),
                E = n(6),
                T = n(38);
            const b = Object(i.getLogger)(e);

            function C(e, t, i, s, o, a, c) {
                this.audioTransferActive = !(!0 === c.startSilent), this._dtmfSender = void 0, this._dtmfTonesQueue = [], this.videoTransferActive = !0, this.rtc = e, this.id = t, this.isP2P = a, this.remoteTracks = new Map, this.localTracks = new Map, this._addedStreams = [], this.localSSRCs = new Map, this.localUfrag = null, this.remoteUfrag = null, this.signalingLayer = i, this._peerVideoTypeChanged = this._peerVideoTypeChanged.bind(this), this.signalingLayer.on(T.b, this._peerVideoTypeChanged), this._peerMutedChanged = this._peerMutedChanged.bind(this), this.signalingLayer.on(T.a, this._peerMutedChanged), this.options = c, this.peerconnection = new h.a.RTCPeerConnectionType(s, o), this.tpcUtils = new _.b(this), this.updateLog = [], this.stats = {}, this.statsinterval = null, this.maxstats = c.maxstats, this.interop = new r.a;
                const d = n(141);
                this.simulcast = new d({
                    numOfLayers: _.a.length,
                    explodeRemoteSimulcast: !1,
                    usesUnifiedPlan: p.a.usesUnifiedPlan()
                }), this.sdpConsistency = new S.a(this.toString()), this.localSdpMunger = new u.a(this), this.eventEmitter = e.eventEmitter, this.rtxModifier = new g.a, this.trace = (e, t) => {
                    b.debug(e, t), this.updateLog.push({
                        time: new Date,
                        type: e,
                        value: t || ""
                    })
                }, this.onicecandidate = null, this.peerconnection.onicecandidate = e => {
                    this.trace("onicecandidate", JSON.stringify(e.candidate, null, " ")), null !== this.onicecandidate && this.onicecandidate(e)
                }, p.a.usesPlanB() ? (this.peerconnection.onaddstream = e => this._remoteStreamAdded(e.stream), this.peerconnection.onremovestream = e => this._remoteStreamRemoved(e.stream)) : this.peerconnection.ontrack = e => {
                    const t = e.streams[0];
                    this._remoteTrackAdded(t, e.track, e.transceiver), t.onremovetrack = e => {
                        this._remoteTrackRemoved(t, e.track)
                    }
                }, this.onsignalingstatechange = null, this.peerconnection.onsignalingstatechange = e => {
                    this.trace("onsignalingstatechange", this.signalingState), null !== this.onsignalingstatechange && this.onsignalingstatechange(e)
                }, this.oniceconnectionstatechange = null, this.peerconnection.oniceconnectionstatechange = e => {
                    this.trace("oniceconnectionstatechange", this.iceConnectionState), null !== this.oniceconnectionstatechange && this.oniceconnectionstatechange(e)
                }, this.onnegotiationneeded = null, this.peerconnection.onnegotiationneeded = e => {
                    this.trace("onnegotiationneeded"), null !== this.onnegotiationneeded && this.onnegotiationneeded(e)
                }, this.ondatachannel = null, this.peerconnection.ondatachannel = e => {
                    this.trace("ondatachannel"), null !== this.ondatachannel && this.ondatachannel(e)
                }, this.maxstats && (this.statsinterval = window.setInterval(() => {
                    this.getStats(e => {
                        if (e.result && "function" == typeof e.result) {
                            const t = e.result();
                            for (let e = 0; e < t.length; ++e) {
                                const n = t[e];
                                n.names().forEach(e => {
                                    this._processStat(n, e, n.stat(e))
                                })
                            }
                        } else e.forEach(e => this._processStat(e, "", e))
                    }, () => {})
                }, 1e3)), b.info(`Create new ${this}`)
            }
            C.prototype._processStat = function(e, t, n) {
                const i = `${e.id}-${t}`;
                let r = this.stats[i];
                const s = new Date;
                r || (this.stats[i] = r = {
                    startTime: s,
                    endTime: s,
                    values: [],
                    times: []
                }), r.values.push(n), r.times.push(s.getTime()), r.values.length > this.maxstats && (r.values.shift(), r.times.shift()), r.endTime = s
            };
            const R = function(e) {
                return null == e ? "" : `type: ${e.type}\r\n${e.sdp}`
            };
            C.prototype.getConnectionState = function() {
                const e = this.peerconnection.iceConnectionState;
                return "completed" === e ? "connected" : e
            }, C.prototype._getDesiredMediaDirection = function(e) {
                let t = !0;
                return e === d.a ? t = this.audioTransferActive : e === d.c && (t = this.videoTransferActive), t ? this.hasAnyTracksOfType(e) ? "sendrecv" : "recvonly" : "inactive"
            }, C.prototype.isSimulcastOn = function() {
                return !this.options.disableSimulcast
            }, C.prototype._peerVideoTypeChanged = function(e, t) {
                if (!e) return void b.error(`No endpointID on peerVideoTypeChanged ${this}`);
                const n = this.getRemoteTracks(e, d.c);
                n.length && n[0]._setVideoType(t)
            }, C.prototype._peerMutedChanged = function(e, t, n) {
                if (!e) return void b.error("On peerMuteChanged - no endpoint ID");
                const i = this.getRemoteTracks(e, t);
                i.length && i[0].setMute(n)
            }, C.prototype.getLocalTracks = function(e) {
                let t = Array.from(this.localTracks.values());
                return void 0 !== e && (t = t.filter(t => t.getType() === e)), t
            }, C.prototype.hasAnyTracksOfType = function(e) {
                if (!e) throw new Error('"mediaType" is required');
                return this.getLocalTracks(e).length > 0
            }, C.prototype.getRemoteTracks = function(e, t) {
                const n = [],
                    i = e ? [e] : this.remoteTracks.keys();
                for (const e of i) {
                    const i = this.remoteTracks.get(e);
                    if (i)
                        for (const e of i.keys())
                            if (!t || t === e) {
                                const t = i.get(e);
                                t && n.push(t)
                            }
                }
                return n
            }, C.prototype.getTrackBySSRC = function(e) {
                if ("number" != typeof e) throw new Error(`SSRC ${e} is not a number`);
                for (const t of this.localTracks.values())
                    if (this.getLocalSSRC(t) === e) return t;
                for (const t of this.getRemoteTracks())
                    if (t.getSSRC() === e) return t;
                return null
            }, C.prototype.getSsrcByTrackId = function(e) {
                const t = t => t.getTrack().id === e,
                    n = this.getLocalTracks().find(t);
                if (n) return this.getLocalSSRC(n);
                const i = this.getRemoteTracks().find(t);
                return i ? i.getSSRC() : null
            }, C.prototype._remoteStreamAdded = function(e) {
                const t = l.a.getStreamID(e);
                if (!l.a.isUserStreamById(t)) return void b.info(`${this} ignored remote 'stream added' event for non-user stream` + `id: ${t}`);
                p.a.isChromiumBased() && (e.onaddtrack = t => {
                    this._remoteTrackAdded(e, t.track)
                }, e.onremovetrack = t => {
                    this._remoteTrackRemoved(e, t.track)
                });
                const n = e.getAudioTracks();
                for (const t of n) this._remoteTrackAdded(e, t);
                const i = e.getVideoTracks();
                for (const t of i) this._remoteTrackAdded(e, t)
            }, C.prototype._remoteTrackAdded = function(e, t, n = null) {
                const i = l.a.getStreamID(e),
                    r = t.kind;
                if (!this.isP2P && !l.a.isUserStreamById(i)) return void b.info(`${this} ignored remote 'stream added' event for non-user stream` + `id: ${i}`);
                if (b.info(`${this} remote track added:`, i, r), !r) return void a.callErrorHandler(new Error(`MediaType undefined for remote track, stream id: ${i}`));
                const s = p.a.usesPlanB() ? new v.a(this.remoteDescription.sdp) : new v.a(this.peerconnection.remoteDescription.sdp);
                let o;
                if (p.a.usesUnifiedPlan())
                    if (n && n.mid) {
                        const e = n.mid;
                        o = s.media.filter(t => E.a.findLine(t, `a=mid:${e}`))
                    } else o = s.media.filter(e => {
                        const t = E.a.findLine(e, "a=msid");
                        return void 0 !== t && i === t.substring(7).split(" ")[0]
                    });
                else o = s.media.filter(e => e.startsWith(`m=${r}`));
                if (!o.length) return void a.callErrorHandler(new Error(`No media lines for type ${r} found in remote SDP for remote track: ${i}`));
                let c = E.a.findLines(o[0], "a=ssrc:");
                if (!(c = c.filter(e => -1 !== e.indexOf(`msid:${i}`))).length) return void a.callErrorHandler(new Error(`No SSRC lines for streamId ${i} for remote track, media type: ${r}`));
                const d = c[0].substring(7).split(" ")[0],
                    u = Number(d),
                    h = this.signalingLayer.getSSRCOwner(u);
                if (isNaN(u) || u < 0) return void a.callErrorHandler(new Error(`Invalid SSRC: ${d} for remote track, msid: ${i} media type: ${r}`));
                if (!h) return void a.callErrorHandler(new Error(`No SSRC owner known for: ${u} for remote track, msid: ${i} media type: ${r}`));
                b.log(`${this} associated ssrc`, h, u);
                const f = this.signalingLayer.getPeerMediaInfo(h, r);
                if (!f) return void a.callErrorHandler(new Error(`${this}: no peer media info available for ${h}`));
                const m = f.muted,
                    g = f.videoType;
                this._createRemoteTrack(h, e, t, r, g, u, m)
            }, C.prototype._createRemoteTrack = function(e, t, n, i, r, s, o) {
                let a = this.remoteTracks.get(e);
                a || (a = new Map, this.remoteTracks.set(e, a));
                const d = a.get(i);
                if (d && d.getTrack() === n) return void b.info(`${this} ignored duplicated remote track added event for: ` + `${e}, ${i}`);
                d && b.error(`${this} overwriting remote track for` + `${e} ${i}`);
                const u = new c.a(this.rtc, this.rtc.conference, e, t, n, i, r, s, o, this.isP2P);
                a.set(i, u), this.eventEmitter.emit(m.a.REMOTE_TRACK_ADDED, u)
            }, C.prototype._remoteStreamRemoved = function(e) {
                if (!l.a.isUserStream(e)) {
                    const t = l.a.getStreamID(e);
                    return void b.info(`Ignored remote 'stream removed' event for non-user stream ${t}`)
                }
                const t = e.getVideoTracks();
                for (const n of t) this._remoteTrackRemoved(e, n);
                const n = e.getAudioTracks();
                for (const t of n) this._remoteTrackRemoved(e, t)
            }, C.prototype._remoteTrackRemoved = function(e, t) {
                const n = l.a.getStreamID(e),
                    i = t && l.a.getTrackID(t);
                b.info(`${this} - remote track removed: ${n}, ${i}`), n ? i ? this._removeRemoteTrackById(n, i) || b.warn(`${this} Removed track not found for msid: ${n},\n             track id: ${i}`) : a.callErrorHandler(new Error(`${this} remote track removal failed - no track ID`)) : a.callErrorHandler(new Error(`${this} remote track removal failed - no stream ID`))
            }, C.prototype._getRemoteTrackById = function(e, t) {
                for (const n of this.remoteTracks.values())
                    for (const i of n.values())
                        if (i.getStreamId() == e && i.getTrackId() == t) return i
            }, C.prototype.removeRemoteTracks = function(e) {
                const t = [],
                    n = this.remoteTracks.get(e);
                if (n) {
                    const i = n.get(d.a),
                        r = n.get(d.c);
                    i && t.push(i), r && t.push(r), this.remoteTracks.delete(e)
                }
                return b.debug(`${this} removed remote tracks for ${e} count: ${t.length}`), t
            }, C.prototype._removeRemoteTrack = function(e) {
                e.dispose();
                const t = e.getParticipantId(),
                    n = this.remoteTracks.get(t);
                n ? n.delete(e.getType()) || b.error(`Failed to remove ${e} - type mapping messed up ?`) : b.error(`removeRemoteTrack: no remote tracks map for ${t}`), this.eventEmitter.emit(m.a.REMOTE_TRACK_REMOVED, e)
            }, C.prototype._removeRemoteTrackById = function(e, t) {
                const n = this._getRemoteTrackById(e, t);
                return n && this._removeRemoteTrack(n), n
            };
            const A = function(e) {
                if ("object" != typeof e || null === e || "string" != typeof e.sdp) return b.warn("An empty description was passed as an argument."), e;
                const t = n(21),
                    i = t.parse(e.sdp);
                void 0 !== i && void 0 !== i.media && Array.isArray(i.media) && i.media.forEach(e => {
                    const t = [],
                        n = [];
                    if (void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach(e => {
                            void 0 !== e.semantics && "FID" === e.semantics && void 0 !== e.ssrcs && t.push(Number(e.ssrcs.split(" ")[0]))
                        }), Array.isArray(e.ssrcs)) {
                        let i;
                        for (i = 0; i < e.ssrcs.length; i++) "object" == typeof e.ssrcs[i] && void 0 !== e.ssrcs[i].id && t.indexOf(e.ssrcs[i].id) >= 0 && (n.push(e.ssrcs[i]), delete e.ssrcs[i]);
                        for (i = 0; i < e.ssrcs.length; i++) void 0 !== e.ssrcs[i] && n.push(e.ssrcs[i]);
                        e.ssrcs = function(e = []) {
                            if (!p.a.isChrome() || !p.a.isVersionGreaterThan(70)) return e;
                            let t = [...e];
                            return e.filter(e => e.attribute === "mslabel" && e.value === "-").map(e => e.id).forEach(e => {
                                const n = t.find(t => t.id === e && "cname" === t.attribute);
                                n.value = `recvonly-${e}`, (t = t.filter(t => t.id !== e)).push(n)
                            }), t
                        }(n)
                    }
                });
                const r = t.write(i);
                return new RTCSessionDescription({
                    type: e.type,
                    sdp: r
                })
            };
            C.prototype.getLocalSSRC = function(e) {
                const t = this._getSSRC(e.rtcId);
                return t && t.ssrcs[0]
            }, C.prototype._injectSsrcGroupForUnifiedSimulcast = function(e) {
                const t = o.a.parse(e.sdp),
                    n = t.media.find(e => "video" === e.type);
                if (n.simulcast || n.simulcast_03) {
                    const t = [];
                    if (n.ssrcs.forEach(e => {
                            "msid" === e.attribute && t.push(e.id)
                        }), n.ssrcGroups = n.ssrcGroups || [], n.ssrcGroups.find(e => "SIM" === e.semantics)) return e;
                    n.ssrcGroups.push({
                        semantics: "SIM",
                        ssrcs: t.join(" ")
                    })
                }
                return new RTCSessionDescription({
                    type: e.type,
                    sdp: o.a.write(t)
                })
            };
            const w = {
                signalingState() {
                    return this.peerconnection.signalingState
                },
                iceConnectionState() {
                    return this.peerconnection.iceConnectionState
                },
                localDescription() {
                    let e = this.peerconnection.localDescription;
                    return e ? (this.trace("getLocalDescription::preTransform", R(e)), p.a.usesUnifiedPlan() ? (e = this.interop.toPlanB(e), this.trace("getLocalDescription::postTransform (Plan B)", R(e)), e = this._injectSsrcGroupForUnifiedSimulcast(e), this.trace("getLocalDescription::postTransform (inject ssrc group)", R(e))) : (p.a.doesVideoMuteByStreamRemove() && (e = this.localSdpMunger.maybeAddMutedLocalVideoTracksToSDP(e), b.debug("getLocalDescription::postTransform (munge local SDP)", e)), e = function(e, t) {
                        if (!e) throw new Error("No local description passed in.");
                        const n = new y.a(e.sdp),
                            i = n.selectMedia("audio");
                        let r = !1;
                        i && "sendrecv" !== i.direction && (t.startSilent ? i.direction = "inactive" : i.direction = "sendrecv", r = !0);
                        const s = n.selectMedia("video");
                        return s && "sendrecv" !== s.direction && (s.direction = "sendrecv", r = !0), r ? new RTCSessionDescription({
                            type: e.type,
                            sdp: n.toRawSDP()
                        }) : e
                    }(e, this.options)), e = this.localSdpMunger.transformStreamIdentifiers(e)) : (b.debug("getLocalDescription no localDescription found"), {})
                },
                remoteDescription() {
                    let e = this.peerconnection.remoteDescription;
                    return e ? (this.trace("getRemoteDescription::preTransform", R(e)), p.a.usesUnifiedPlan() && (e = this.interop.toPlanB(e), this.trace("getRemoteDescription::postTransform (Plan B)", R(e))), e) : (b.debug("getRemoteDescription no remoteDescription found"), {})
                }
            };
            Object.keys(w).forEach(e => {
                Object.defineProperty(C.prototype, e, {
                    get: w[e]
                })
            }), C.prototype._getSSRC = function(e) {
                return this.localSSRCs.get(e)
            }, C.prototype.addTrack = function(e, t = !1) {
                const n = e.rtcId;
                if (b.info(`add ${e} to: ${this}`), this.localTracks.has(n)) return void b.error(`${e} is already in ${this}`);
                if (this.localTracks.set(n, e), p.a.usesUnifiedPlan() && t) return this.tpcUtils.addTrack(e, t);
                const i = e.getOriginalStream();
                if (i ? this._addStream(i) : (!p.a.doesVideoMuteByStreamRemove() || e.isAudioTrack() || e.isVideoTrack() && !e.isMuted()) && b.error(`${this} no WebRTC stream for: ${e}`), p.a.usesPlanB() && p.a.doesVideoMuteByStreamRemove() && e.isVideoTrack() && e.isMuted()) {
                    const t = this.generateNewStreamSSRCInfo(e);
                    this.sdpConsistency.setPrimarySsrc(t.ssrcs[0]);
                    const n = t.groups.find(e => "SIM" === e.semantics);
                    n && this.simulcast.setSsrcCache(n.ssrcs);
                    const i = t.groups.filter(e => "FID" === e.semantics);
                    if (i) {
                        const e = new Map;
                        i.forEach(t => {
                            const n = t.ssrcs[0],
                                i = t.ssrcs[1];
                            e.set(n, i)
                        }), this.rtxModifier.setSsrcCache(e)
                    }
                }
                p.a.usesUnifiedPlan() && !p.a.usesSdpMungingForSimulcast() && this.tpcUtils.setEncodings(e)
            }, C.prototype.addTrackUnmute = function(e) {
                if (p.a.usesUnifiedPlan()) return this.tpcUtils.addTrackUnmute(e);
                if (!this._assertTrackBelongs("addTrackUnmute", e)) return Promise.reject("Track not found on the peerconnection");
                b.info(`Adding ${e} as unmute to ${this}`);
                const t = e.getOriginalStream();
                return t ? (this._addStream(t), Promise.resolve(!0)) : (b.error(`Unable to add ${e} as unmute to ${this} - no WebRTC stream`), Promise.reject("Stream not found"))
            }, C.prototype._addStream = function(e) {
                this.peerconnection.addStream(e), this._addedStreams.push(e)
            }, C.prototype._removeStream = function(e) {
                p.a.supportsRtpSender() ? this._handleSenderRemoveStream(e) : this.peerconnection.removeStream(e), this._addedStreams = this._addedStreams.filter(t => t !== e)
            }, C.prototype._assertTrackBelongs = function(e, t) {
                const n = this.localTracks.has(t.rtcId);
                return n || b.error(`${e}: ${t} does not belong to ${this}`), n
            }, C.prototype.isMediaStreamInPc = function(e) {
                return this._addedStreams.indexOf(e) > -1
            }, C.prototype.removeTrack = function(e) {
                if (p.a.usesUnifiedPlan()) return this.tpcUtils.removeTrack(e);
                const t = e.getOriginalStream();
                this.trace("removeStream", e.rtcId, t ? t.id : void 0), this._assertTrackBelongs("removeStream", e) && (this.localTracks.delete(e.rtcId), this.localSSRCs.delete(e.rtcId), t && (p.a.supportsRtpSender() ? this._handleSenderRemoveStream(t) : this.peerconnection.removeStream(t)))
            }, C.prototype.findSenderByKind = function(e) {
                return this.peerconnection.getSenders().find(t => t.track && t.track.kind === e)
            }, C.prototype.findSenderByStream = function(e) {
                const t = e.getTracks()[0];
                if (t) return this.peerconnection.getSenders().find(e => e.track === t);
                b.error("Cannot find sender: no tracks.")
            }, C.prototype.findReceiverForTrack = function(e) {
                return this.peerconnection.getReceivers().find(t => t.track === e)
            }, C.prototype.findSenderForTrack = function(e) {
                return this.peerconnection.getSenders().find(t => t.track === e)
            }, C.prototype.replaceTrack = function(e, t) {
                return p.a.usesUnifiedPlan() ? this.tpcUtils.replaceTrack(e, t) : (e && this.removeTrack(e), t && this.addTrack(t), Promise.resolve(!0))
            }, C.prototype.removeTrackMute = function(e) {
                if (p.a.usesUnifiedPlan()) return this.tpcUtils.removeTrackMute(e);
                const t = e.getOriginalStream();
                return this.trace("removeStreamMute", e.rtcId, t ? t.id : null), this._assertTrackBelongs("removeStreamMute", e) ? t ? (b.info(`Removing ${e} as mute from ${this}`), this._removeStream(t), Promise.resolve(!0)) : (b.error(`removeStreamMute - no WebRTC stream for ${e}`), Promise.reject("Stream not found")) : Promise.reject("Track not found in the peerconnection")
            }, C.prototype._handleSenderRemoveStream = function(e) {
                if (!e) return;
                const t = this.findSenderByStream(e);
                t ? this.peerconnection.removeTrack(t) : b.log("Cannot remove tracks: no RTPSender.")
            }, C.prototype.createDataChannel = function(e, t) {
                return this.trace("createDataChannel", e, t), this.peerconnection.createDataChannel(e, t)
            }, C.prototype._ensureSimulcastGroupIsLast = function(e) {
                let t = e.sdp;
                const n = t.indexOf("m=video"),
                    i = t.indexOf("a=ssrc-group:SIM", n);
                let r = t.lastIndexOf("a=ssrc-group");
                if (-1 === i || -1 === r || r === i) return e;
                const s = t.indexOf("\r\n", i),
                    o = t.substring(i, s + 2);
                r = (t = t.replace(o, "")).lastIndexOf("a=ssrc-group");
                const a = t.indexOf("\r\n", r),
                    c = t.slice(0, a),
                    d = o.trim(),
                    u = t.slice(a);
                return t = `${c}\r\n${d}${u}`, new RTCSessionDescription({
                    type: e.type,
                    sdp: t
                })
            }, C.prototype._adjustLocalMediaDirection = function(e) {
                const t = new y.a(e.sdp);
                let n = !1;
                const i = t.selectMedia("audio");
                if (i) {
                    const e = this._getDesiredMediaDirection(d.a);
                    i.direction !== e && (i.direction = e, b.info(`Adjusted local audio direction to ${e}`), n = !0)
                } else b.warn('No "audio" media found int the local description');
                const r = t.selectMedia("video");
                if (r) {
                    const e = this._getDesiredMediaDirection(d.c);
                    r.direction !== e && (r.direction = e, b.info(`Adjusted local video direction to ${e}`), n = !0)
                } else b.warn('No "video" media found in the local description');
                return n ? new RTCSessionDescription({
                    type: e.type,
                    sdp: t.toRawSDP()
                }) : e
            }, C.prototype.setLocalDescription = function(e) {
                let t = e;
                if (this.trace("setLocalDescription::preTransform", R(t)), this.options.disableH264 || this.options.preferH264) {
                    const e = o.a.parse(t.sdp),
                        n = e.media.find(e => "video" === e.type);
                    this.options.disableH264 ? E.a.stripVideoCodec(n, "h264") : E.a.preferVideoCodec(n, "h264"), t = new RTCSessionDescription({
                        type: t.type,
                        sdp: o.a.write(e)
                    }), this.trace("setLocalDescription::postTransform (H264)", R(t))
                }
                return p.a.usesPlanB() ? (t = this._adjustLocalMediaDirection(t), t = this._ensureSimulcastGroupIsLast(t)) : (t = this.interop.toUnifiedPlan(t), this.trace("setLocalDescription::postTransform (Unified Plan)", R(t))), new Promise((e, n) => {
                    this.peerconnection.setLocalDescription(t).then(() => {
                        this.trace("setLocalDescriptionOnSuccess");
                        const n = E.a.getUfrag(t.sdp);
                        n !== this.localUfrag && (this.localUfrag = n, this.eventEmitter.emit(m.a.LOCAL_UFRAG_CHANGED, this, n)), e()
                    }, e => {
                        this.trace("setLocalDescriptionOnFailure", e), this.eventEmitter.emit(m.a.SET_LOCAL_DESCRIPTION_FAILED, e, this), n(e)
                    })
                })
            }, C.prototype.setAudioTransferActive = function(e) {
                if (b.debug(`${this} audio transfer active: ${e}`), p.a.usesUnifiedPlan()) return this.tpcUtils.setAudioTransferActive(e);
                const t = this.audioTransferActive !== e;
                return this.audioTransferActive = e, t
            }, C.prototype.setMaxBitRate = function(e) {
                if (e.type === d.a || p.a.usesPlanB() && !this.options.capScreenshareBitrate || p.a.usesPlanB() && "camera" === e.videoType) return;
                if (!this.peerconnection.getSenders) return void b.debug("Browser doesn't support RTCRtpSender");
                const t = e.videoType,
                    n = e.track.id;
                this.peerconnection.getSenders().filter(e => e.track && e.track.id === n).forEach(e => {
                    try {
                        const n = e.getParameters();
                        if (!n.encodings || !n.encodings.length) return;
                        b.debug("Setting max bitrate on video stream");
                        for (const e in n.encodings) n.encodings.hasOwnProperty(e) && (n.encodings[e].maxBitrate = "desktop" === t && p.a.usesPlanB() ? 5e5 : this.isSimulcastOn() ? this.tpcUtils.simulcastEncodings[e].maxBitrate : 25e5);
                        e.setParameters(n)
                    } catch (e) {
                        b.error("Browser does not support getParameters/setParamters or setting max bitrate on the encodings: ", e)
                    }
                })
            }, C.prototype.setRemoteDescription = function(e) {
                if (this.trace("setRemoteDescription::preTransform", R(e)), p.a.usesPlanB()) {
                    if (e = this.simulcast.mungeRemoteDescription(e), this.trace("setRemoteDescription::postTransform (simulcast)", R(e)), this.options.preferH264) {
                        const t = o.a.parse(e.sdp),
                            n = t.media.find(e => "video" === e.type);
                        E.a.preferVideoCodec(n, "h264"), e = new RTCSessionDescription({
                            type: e.type,
                            sdp: o.a.write(t)
                        })
                    }
                    e = A(e)
                } else {
                    const t = this.peerconnection.remoteDescription;
                    e = this.interop.toUnifiedPlan(e, t), this.trace("setRemoteDescription::postTransform (Unified)", R(e)), this.isSimulcastOn() && (e = this.simulcast.mungeRemoteDescription(e), e = this.tpcUtils._insertUnifiedPlanSimulcastReceive(e), this.trace("setRemoteDescription::postTransform (sim receive)", R(e)), e = this.tpcUtils._ensureCorrectOrderOfSsrcs(e))
                }
                return new Promise((t, n) => {
                    this.peerconnection.setRemoteDescription(e).then(() => {
                        this.trace("setRemoteDescriptionOnSuccess");
                        const n = E.a.getUfrag(e.sdp);
                        n !== this.remoteUfrag && (this.remoteUfrag = n, this.eventEmitter.emit(m.a.REMOTE_UFRAG_CHANGED, this, n)), t()
                    }, e => {
                        this.trace("setRemoteDescriptionOnFailure", e), this.eventEmitter.emit(m.a.SET_REMOTE_DESCRIPTION_FAILED, e, this), n(e)
                    })
                })
            }, C.prototype.setVideoTransferActive = function(e) {
                if (b.debug(`${this} video transfer active: ${e}`), p.a.usesUnifiedPlan()) return this.tpcUtils.setVideoTransferActive(e);
                const t = this.videoTransferActive !== e;
                return this.videoTransferActive = e, t
            }, C.prototype.sendTones = function(e, t = 200, n = 200) {
                if (!this._dtmfSender) {
                    if (this.peerconnection.getSenders) {
                        const e = this.peerconnection.getSenders().find(e => e.dtmf);
                        this._dtmfSender = e && e.dtmf, this._dtmfSender && b.info(`${this} initialized DTMFSender using getSenders`)
                    }
                    if (!this._dtmfSender) {
                        const e = Array.from(this.localTracks.values()).find(e => e.isAudioTrack());
                        this.peerconnection.createDTMFSender && e && (this._dtmfSender = this.peerconnection.createDTMFSender(e.getTrack())), this._dtmfSender && b.info(`${this} initialized DTMFSender using deprecated createDTMFSender`)
                    }
                    this._dtmfSender && (this._dtmfSender.ontonechange = this._onToneChange.bind(this))
                }
                if (this._dtmfSender) {
                    if (this._dtmfSender.toneBuffer) return void this._dtmfTonesQueue.push({
                        tones: e,
                        duration: t,
                        interToneGap: n
                    });
                    this._dtmfSender.insertDTMF(e, t, n)
                } else b.warn(`${this} sendTones - failed to select DTMFSender`)
            }, C.prototype._onToneChange = function(e) {
                if (this._dtmfSender && "" === e.tone && this._dtmfTonesQueue.length) {
                    const {
                        tones: e,
                        duration: t,
                        interToneGap: n
                    } = this._dtmfTonesQueue.shift();
                    this._dtmfSender.insertDTMF(e, t, n)
                }
            }, C.prototype.generateRecvonlySsrc = function() {
                const e = E.a.generateSsrc();
                b.info(`${this} generated new recvonly SSRC: ${e}`), this.sdpConsistency.setPrimarySsrc(e)
            }, C.prototype.clearRecvonlySsrc = function() {
                b.info("Clearing primary video SSRC!"), this.sdpConsistency.clearVideoSsrcCache()
            }, C.prototype.close = function() {
                this.trace("stop"), this.signalingLayer.off(T.a, this._peerMutedChanged), this.signalingLayer.off(T.b, this._peerVideoTypeChanged);
                for (const e of this.remoteTracks.values())
                    for (const t of e.values()) this._removeRemoteTrack(t);
                this.remoteTracks.clear(), this._addedStreams = [], this._dtmfSender = null, this._dtmfTonesQueue = [], this.rtc._removePeerConnection(this) || b.error("RTC._removePeerConnection returned false"), null !== this.statsinterval && (window.clearInterval(this.statsinterval), this.statsinterval = null), b.info(`Closing ${this}...`), this.peerconnection.close()
            };

            function I(e) {
                return e.getLocalTracks().some(e => "camera" === e.videoType)
            }
            C.prototype.createAnswer = function(e) {
                return this._createOfferOrAnswer(!1, e)
            }, C.prototype.createOffer = function(e) {
                return this._createOfferOrAnswer(!0, e)
            }, C.prototype._createOfferOrAnswer = function(e, t) {
                const n = e ? "Offer" : "Answer";
                this.trace(`create${n}`, JSON.stringify(t, null, " "));
                const i = (t, i, r) => {
                        try {
                            if (this.trace(`create${n}OnSuccess::preTransform`, R(t)), p.a.usesPlanB() && (this.hasAnyTracksOfType(d.c) || this.sdpConsistency.hasPrimarySsrcCached() || this.generateRecvonlySsrc(), t = new RTCSessionDescription({
                                    type: t.type,
                                    sdp: this.sdpConsistency.makeVideoPrimarySsrcsConsistent(t.sdp)
                                }), this.trace(`create${n}OnSuccess::postTransform ` + "(make primary audio/video ssrcs consistent)", R(t))), this.isSimulcastOn() && p.a.usesSdpMungingForSimulcast() && (!this.options.capScreenshareBitrate || this.options.capScreenshareBitrate && I(this)) && (t = this.simulcast.mungeLocalDescription(t), this.trace(`create${n}` + "OnSuccess::postTransform (simulcast)", R(t))), !this.options.disableRtx && p.a.supportsRtx() && (t = new RTCSessionDescription({
                                    type: t.type,
                                    sdp: this.rtxModifier.modifyRtxSsrcs(t.sdp)
                                }), this.trace(`create${n}` + "OnSuccess::postTransform (rtx modifier)", R(t))), !e) {
                                const e = new v.a(this.remoteDescription.sdp),
                                    n = new v.a(t.sdp);
                                ! function(e, t) {
                                    (p.a.isChromiumBased() || p.a.isReactNative()) && e && t && e.media && t.media && e.media.length === t.media.length && (t.media.forEach((n, i) => {
                                        E.a.findLine(e.media[i], "a=setup:actpass", e.session) && (t.media[i] = n.replace(/a=setup:active/g, "a=setup:passive"))
                                    }), t.raw = t.session + t.media.join(""))
                                }(e, n), t = new RTCSessionDescription({
                                    type: t.type,
                                    sdp: n.raw
                                })
                            }
                            const r = function(e) {
                                const t = new Map,
                                    n = new Map;
                                if ("object" != typeof e || null === e || "string" != typeof e.sdp) return b.warn("An empty description was passed as an argument."), t;
                                const i = o.a.parse(e.sdp);
                                if (!Array.isArray(i.media)) return t;
                                for (const e of i.media)
                                    if (Array.isArray(e.ssrcs)) {
                                        if (Array.isArray(e.ssrcGroups))
                                            for (const t of e.ssrcGroups)
                                                if (void 0 !== t.semantics && void 0 !== t.ssrcs) {
                                                    const e = t.ssrcs.split(" ").map(e => parseInt(e, 10)),
                                                        i = e[0];
                                                    t.ssrcs = e, n.has(i) || n.set(i, []), n.get(i).push(t)
                                                } for (const i of e.ssrcs) {
                                            if ("msid" !== i.attribute) continue;
                                            const e = i.value;
                                            let r = t.get(e);
                                            r || (r = {
                                                ssrcs: [],
                                                groups: [],
                                                msid: e
                                            }, t.set(e, r));
                                            const s = i.id;
                                            if (r.ssrcs.push(s), n.has(s)) {
                                                const e = n.get(s);
                                                for (const t of e) r.groups.push(t)
                                            }
                                        }
                                    } return t
                            }(t);
                            b.debug("Got local SSRCs MAP: ", r), this._processLocalSSRCsMap(r), i(t)
                        } catch (e) {
                            this.trace(`create${n}OnError`, e), this.trace(`create${n}OnError`, R(t)), b.error(`create${n}OnError`, e, R(t)), r(e)
                        }
                    },
                    r = (t, i) => {
                        this.trace(`create${n}OnFailure`, t);
                        const r = e ? m.a.CREATE_OFFER_FAILED : m.a.CREATE_ANSWER_FAILED;
                        this.eventEmitter.emit(r, t, this), i(t)
                    };
                return new Promise((n, s) => {
                    let o;
                    (o = e ? this.peerconnection.createOffer(t) : this.peerconnection.createAnswer(t)).then(e => i(e, n, s), e => r(e, s))
                })
            }, C.prototype._extractPrimarySSRC = function(e) {
                return e && e.groups && e.groups.length ? e.groups[0].ssrcs[0] : e && e.ssrcs && e.ssrcs.length ? e.ssrcs[0] : null
            }, C.prototype._processLocalSSRCsMap = function(e) {
                for (const t of this.localTracks.values()) {
                    const n = t.storedMSID;
                    if (e.has(n)) {
                        const i = e.get(n);
                        if (!i) return void b.error(`No SSRC found for: ${n} in ${this}`);
                        const r = this.localSSRCs.get(t.rtcId),
                            s = this._extractPrimarySSRC(i),
                            o = this._extractPrimarySSRC(r);
                        s !== o ? (null === o ? b.info(`Storing new local SSRC for ${t} in ${this}`, i) : b.error(`Overwriting SSRC for ${t} ${n} in ${this} with: `, i), this.localSSRCs.set(t.rtcId, i), this.eventEmitter.emit(m.a.LOCAL_TRACK_SSRC_UPDATED, t, s)) : b.debug(`The local SSRC(${s}) for ${t} ${n}` + `is still up to date in ${this}`)
                    } else t.isVideoTrack() || t.isMuted() || b.warn(`No SSRCs found in the local SDP for ${t} MSID: ${n} in ${this}`)
                }
            }, C.prototype.addIceCandidate = function(e) {
                return this.trace("addIceCandidate", JSON.stringify({
                    candidate: e.candidate,
                    sdpMid: e.sdpMid,
                    sdpMLineIndex: e.sdpMLineIndex,
                    usernameFragment: e.usernameFragment
                }, null, " ")), this.peerconnection.addIceCandidate(e)
            }, C.prototype.getStats = function(e, t) {
                p.a.isSafari() || p.a.isFirefox() || p.a.isReactNative() ? this.peerconnection.getStats().then(e).catch(t || (() => {})) : this.peerconnection.getStats(e)
            }, C.prototype.generateNewStreamSSRCInfo = function(e) {
                const t = e.rtcId;
                let n = this._getSSRC(t);
                if (n && b.error(`Will overwrite local SSRCs for track ID: ${t}`), this.isSimulcastOn() && (!this.options.capScreenshareBitrate || this.options.capScreenshareBitrate && I(this))) {
                    n = {
                        ssrcs: [],
                        groups: []
                    };
                    for (let e = 0; e < _.a.length; e++) n.ssrcs.push(E.a.generateSsrc());
                    n.groups.push({
                        ssrcs: n.ssrcs.slice(),
                        semantics: "SIM"
                    })
                } else n = {
                    ssrcs: [E.a.generateSsrc()],
                    groups: []
                };
                if (!this.options.disableRtx && p.a.supportsRtx()) {
                    const e = n.ssrcs.length;
                    for (let t = 0; t < e; ++t) {
                        const e = n.ssrcs[t],
                            i = E.a.generateSsrc();
                        n.ssrcs.push(i), n.groups.push({
                            ssrcs: [e, i],
                            semantics: "FID"
                        })
                    }
                }
                return n.msid = e.storedMSID, this.localSSRCs.set(t, n), n
            };
            C.prototype.setIsSelected = function(e) {
                this.options.enableLayerSuspension && (b.debug("Layer suspension enabled," + `currently selected? ${e}`), function(e, t) {
                    if (!e.getSenders) return void b.debug("Browser doesn't support RTPSender");
                    const n = e.getSenders().find(e => "video" === e.track.kind);
                    if (!n) return void b.warn("handleLayerSuspension unable to find video sender");
                    if (!n.getParameters) return void b.debug("Browser doesn't support RTPSender parameters");
                    const i = n.getParameters();
                    t ? (b.debug("Currently selected, enabling all sim layers"), i.encodings.forEach(e => {
                        e.active = !0
                    })) : (b.debug("Not currently selected, disabling upper layers"), [1, 2].forEach(e => {
                        i.encodings[e] && (i.encodings[e].active = !1)
                    })), n.setParameters(i)
                }(this.peerconnection, e))
            }, C.prototype.toString = function() {
                return `TPC[${this.id},p2p:${this.isP2P}]`
            }
        }).call(this, "modules/RTC/TraceablePeerConnection.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return h
            }));
            var i = n(7),
                r = n(54),
                s = n(15),
                o = n(5);
            const a = n(4).getLogger(e),
                c = n(8);
            let d = !1,
                u = !1;
            const l = ["abort", "canplay", "canplaythrough", "emptied", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "ratechange", "stalled", "suspend", "waiting"];
            class h extends r.a {
                constructor(e, t, n, i, r, s, o, c, d, u) {
                    if (super(t, i, r, () => {}, s, o), this.rtc = e, "number" != typeof c) throw new TypeError(`SSRC ${c} is not a number`);
                    this.ssrc = c, this.ownerEndpointId = n, this.muted = d, this.isP2P = u, a.debug(`New remote track added: ${this}`), this.hasBeenMuted = d, this.rtc && this.track && this._bindTrackHandlers(), this._containerHandlers = {}, l.forEach(e => {
                        this._containerHandlers[e] = this._containerEventHandler.bind(this, e)
                    })
                }
                _bindTrackHandlers() {
                    this.track.addEventListener("mute", () => this._onTrackMute()), this.track.addEventListener("unmute", () => this._onTrackUnmute()), this.track.addEventListener("ended", () => {
                        a.debug(`"onended" event(${Date.now()}): ${this}`)
                    })
                }
                _onTrackMute() {
                    a.debug(`"onmute" event(${Date.now()}): ${this}`), this.rtc.eventEmitter.emit(c.REMOTE_TRACK_MUTE, this)
                }
                _onTrackUnmute() {
                    a.debug(`"onunmute" event(${Date.now()}): ${this}`), this.rtc.eventEmitter.emit(c.REMOTE_TRACK_UNMUTE, this)
                }
                setMute(e) {
                    this.muted !== e && (e && (this.hasBeenMuted = !0), this.stream && (this.stream.muted = e), this.muted = e, this.emit(s.TRACK_MUTE_CHANGED, this))
                }
                isMuted() {
                    return this.muted
                }
                getParticipantId() {
                    return this.ownerEndpointId
                }
                isLocal() {
                    return !1
                }
                getSSRC() {
                    return this.ssrc
                }
                _setVideoType(e) {
                    this.videoType !== e && (this.videoType = e, this.emit(s.TRACK_VIDEOTYPE_CHANGED, e))
                }
                _playCallback() {
                    const e = this.isVideoTrack() ? "video" : "audio",
                        t = window.performance.now();
                    console.log(`(TIME) Render ${e}:\t`, t), this.conference.getConnectionTimes()[`${e}.render`] = t;
                    const n = window.connectionTimes["obtainPermissions.start"],
                        r = window.connectionTimes["obtainPermissions.end"],
                        s = isNaN(r) || isNaN(n) ? 0 : r - n,
                        a = t - (this.conference.getConnectionTimes()["session.initiate"] - this.conference.getConnectionTimes()["muc.joined"]) - s;
                    this.conference.getConnectionTimes()[`${e}.ttfm`] = a, console.log(`(TIME) TTFM ${e}:\t`, a), o.a.sendAnalytics(Object(i.O)({
                        media_type: e,
                        muted: this.hasBeenMuted,
                        value: a
                    }))
                }
                _attachTTFMTracker(e) {
                    d && this.isAudioTrack() || u && this.isVideoTrack() || (this.isAudioTrack() && (d = !0), this.isVideoTrack() && (u = !0), e.addEventListener("canplay", this._playCallback.bind(this)))
                }
                _onTrackAttach(e) {
                    a.debug(`Track has been attached to a container: ${this}`), l.forEach(t => {
                        e.addEventListener(t, this._containerHandlers[t])
                    })
                }
                _onTrackDetach(e) {
                    a.debug(`Track has been detached from a container: ${this}`), l.forEach(t => {
                        e.removeEventListener(t, this._containerHandlers[t])
                    })
                }
                _containerEventHandler(e) {
                    a.debug(`${e} handler was called for a container with attached ${this}`)
                }
                _getStatus() {
                    const {
                        enabled: e,
                        muted: t,
                        readyState: n
                    } = this.track;
                    return `readyState: ${n}, muted: ${t}, enabled: ${e}`
                }
                toString() {
                    return `RemoteTrack[userID: ${this.getParticipantId()}, type: ${this.getType()}, ssrc: ${this.getSSRC()}, p2p: ${this.isP2P}, status: ${this._getStatus()}]`
                }
            }
        }).call(this, "modules/RTC/JitsiRemoteTrack.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return a
            }));
            var i = n(4),
                r = n(9),
                s = n(27);
            const o = Object(i.getLogger)(e);
            class a {
                constructor(e) {
                    this.tpc = e
                }
                _addMutedLocalVideoTracksToSDP(e) {
                    const t = this.tpc.getLocalTracks(r.c);
                    if (!t.length) return !1;
                    1 !== t.length && o.error(`${this.tpc} there is more than 1 video track ! ` + "Strange things may happen !", t);
                    const n = e.selectMedia("video");
                    if (!n) return o.debug(`${this.tpc} unable to hack local video track SDP` + '- no "video" media'), !1;
                    let i = !1;
                    for (const e of t) {
                        const t = e.isMuted(),
                            r = e.getOriginalStream(),
                            s = r && this.tpc.isMediaStreamInPc(r),
                            a = t || !s;
                        if (o.debug(`${this.tpc} ${e} muted: ${t}, is in PeerConnection: ${s} => should fake sdp ? : ${a}`), !a) continue;
                        const c = this.tpc.isSimulcastOn() ? this.tpc.simulcast.ssrcCache : [this.tpc.sdpConsistency.cachedPrimarySsrc];
                        if (!c.length) {
                            o.error(`No SSRCs stored for: ${e} in ${this.tpc}`);
                            continue
                        }
                        i = !0, n.direction = "sendrecv";
                        const d = `injected-${c[0]}`;
                        for (const t of c) n.removeSSRC(t), o.debug(`${this.tpc} injecting video SSRC: ${t} for ${e}`), n.addSSRCAttribute({
                            id: t,
                            attribute: "cname",
                            value: d
                        }), n.addSSRCAttribute({
                            id: t,
                            attribute: "msid",
                            value: e.storedMSID
                        });
                        if (c.length > 1) {
                            const t = {
                                ssrcs: c.join(" "),
                                semantics: "SIM"
                            };
                            n.findGroup(t.semantics, t.ssrcs) || (o.debug(`${this.tpc} injecting SIM group for ${e}`, t), n.addSSRCGroup(t))
                        }
                        this.tpc.options.disableRtx || this.tpc.rtxModifier.modifyRtxSsrcs2(n)
                    }
                    return i
                }
                _transformMediaIdentifiers(e) {
                    const t = this.tpc.id;
                    for (const n of e.ssrcs) switch (n.attribute) {
                        case "cname":
                        case "label":
                        case "mslabel":
                            n.value = n.value && `${n.value}-${t}`;
                            break;
                        case "msid":
                            if (n.value) {
                                const e = n.value.split(" ");
                                if (2 === e.length) {
                                    const i = e[0],
                                        r = e[1];
                                    n.value = `${i}-${t} ${r}-${t}`
                                } else o.warn("Unable to munge local MSID" + `- weird format detected: ${n.value}`)
                            }
                    }
                }
                maybeAddMutedLocalVideoTracksToSDP(e) {
                    if (!e) throw new Error("No local description passed in.");
                    const t = new s.a(e.sdp);
                    return this._addMutedLocalVideoTracksToSDP(t) ? new RTCSessionDescription({
                        type: e.type,
                        sdp: t.toRawSDP()
                    }) : e
                }
                transformStreamIdentifiers(e) {
                    if (!e || !e.sdp || !e.type) return e;
                    const t = new s.a(e.sdp),
                        n = t.selectMedia("audio");
                    n && this._transformMediaIdentifiers(n);
                    const i = t.selectMedia("video");
                    return i && this._transformMediaIdentifiers(i), new RTCSessionDescription({
                        type: e.type,
                        sdp: t.toRawSDP()
                    })
                }
            }
        }).call(this, "modules/RTC/LocalSdpMunger.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return c
            }));
            var i = n(4),
                r = n(27),
                s = n(6);
            const o = Object(i.getLogger)(e);

            function a(e, t, n) {
                o.debug(`Updating mline to associate ${n}` + `rtx ssrc with primary stream, ${t.id}`);
                const i = t.id,
                    r = t.msid,
                    s = t.cname,
                    a = e.getRtxSSRC(i);
                a !== n ? (a && (o.debug(`${i} was previously associated with rtx` + `${a}, removing all references to it`), e.removeSSRC(a), o.debug(`groups before filtering for ${a}`), o.debug(e.dumpSSRCGroups()), e.removeGroupsWithSSRC(a)), e.addSSRCAttribute({
                    id: n,
                    attribute: "cname",
                    value: s
                }), e.addSSRCAttribute({
                    id: n,
                    attribute: "msid",
                    value: r
                }), e.addSSRCGroup({
                    semantics: "FID",
                    ssrcs: `${i} ${n}`
                })) : o.debug(`${n} was already associated with ${i}`)
            }
            class c {
                constructor() {
                    this.correspondingRtxSsrcs = new Map
                }
                clearSsrcCache() {
                    this.correspondingRtxSsrcs.clear()
                }
                setSsrcCache(e) {
                    o.debug("Setting ssrc cache to ", e), this.correspondingRtxSsrcs = e
                }
                modifyRtxSsrcs(e) {
                    const t = new r.a(e),
                        n = t.selectMedia("video");
                    return n ? this.modifyRtxSsrcs2(n) ? t.toRawSDP() : e : (o.debug(`No 'video' media found in the sdp: ${e}`), e)
                }
                modifyRtxSsrcs2(e) {
                    if ("recvonly" === e.direction) return o.debug("RtxModifier doing nothing, video m line is recvonly"), !1;
                    if (e.getSSRCCount() < 1) return o.debug("RtxModifier doing nothing, no video ssrcs present"), !1;
                    o.debug("Current ssrc mapping: ", this.correspondingRtxSsrcs);
                    const t = e.getPrimaryVideoSSRCs();
                    o.debug("Parsed primary video ssrcs ", t, " making sure all have rtx streams");
                    for (const n of t) {
                        const t = e.getSSRCAttrValue(n, "msid"),
                            i = e.getSSRCAttrValue(n, "cname");
                        let r = this.correspondingRtxSsrcs.get(n);
                        if (r) o.debug("Already have an associated rtx ssrc for" + `video ssrc ${n}: ${r}`);
                        else {
                            o.debug(`No previously associated rtx ssrc for video ssrc ${n}`);
                            const t = e.getRtxSSRC(n);
                            t ? (o.debug(`Rtx stream ${t} ` + "already existed in the sdp as an rtx stream for " + `${n}`), r = t) : (r = s.a.generateSsrc(), o.debug(`Generated rtx ssrc ${r} ` + `for ssrc ${n}`)), o.debug(`Caching rtx ssrc ${r} ` + `for video ssrc ${n}`), this.correspondingRtxSsrcs.set(n, r)
                        }
                        a(e, {
                            id: n,
                            cname: i,
                            msid: t
                        }, r)
                    }
                    return !0
                }
                stripRtx(e) {
                    const t = new r.a(e),
                        n = t.selectMedia("video");
                    if (!n) return o.debug(`No 'video' media found in the sdp: ${e}`), e;
                    if ("recvonly" === n.direction) return o.debug("RtxModifier doing nothing, video m line is recvonly"), e;
                    if (n.getSSRCCount() < 1) return o.debug("RtxModifier doing nothing, no video ssrcs present"), e;
                    if (!n.containsAnySSRCGroups()) return o.debug("RtxModifier doing nothing, no video ssrcGroups present"), e;
                    const i = n.findGroups("FID");
                    n.removeGroupsBySemantics("FID");
                    for (const e of i) {
                        const t = Object(r.c)(e);
                        n.removeSSRC(t)
                    }
                    return t.toRawSDP()
                }
            }
        }).call(this, "modules/xmpp/RtxModifier.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return o
            }));
            var i = n(4),
                r = n(27);
            const s = Object(i.getLogger)(e);
            class o {
                constructor(e) {
                    this.clearVideoSsrcCache(), this.logPrefix = e
                }
                clearVideoSsrcCache() {
                    this.cachedPrimarySsrc = null, this.injectRecvOnly = !1
                }
                setPrimarySsrc(e) {
                    if ("number" != typeof e) throw new Error("Primary SSRC must be a number!");
                    this.cachedPrimarySsrc = e
                }
                hasPrimarySsrcCached() {
                    return Boolean(this.cachedPrimarySsrc)
                }
                makeVideoPrimarySsrcsConsistent(e) {
                    const t = new r.a(e),
                        n = t.selectMedia("video");
                    if (!n) return s.debug(`${this.logPrefix} no 'video' media found in the sdp: ` + `${e}`), e;
                    if ("recvonly" === n.direction) this.cachedPrimarySsrc && this.injectRecvOnly ? n.addSSRCAttribute({
                        id: this.cachedPrimarySsrc,
                        attribute: "cname",
                        value: `recvonly-${this.cachedPrimarySsrc}`
                    }) : s.info(`${this.logPrefix} no SSRC found for the recvonly video` + "stream!");
                    else {
                        const t = n.getPrimaryVideoSsrc();
                        if (!t) return s.info(`${this.logPrefix} sdp-consistency couldn't` + " parse new primary ssrc"), e;
                        if (this.cachedPrimarySsrc) {
                            s.info(`${this.logPrefix} sdp-consistency replacing new ssrc` + `${t} with cached ` + `${this.cachedPrimarySsrc}`), n.replaceSSRC(t, this.cachedPrimarySsrc);
                            for (const e of n.ssrcGroups)
                                if ("FID" === e.semantics) {
                                    const n = Object(r.b)(e),
                                        i = Object(r.c)(e);
                                    n === t && (e.ssrcs = `${this.cachedPrimarySsrc} ${i}`)
                                }
                        } else this.cachedPrimarySsrc = t, s.info(`${this.logPrefix} sdp-consistency caching primary ssrc` + `${this.cachedPrimarySsrc}`);
                        this.injectRecvOnly = !0
                    }
                    return t.toRawSDP()
                }
            }
        }).call(this, "modules/xmpp/SdpConsistency.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return o
            }));
            var i = n(4),
                r = n(55);
            const s = Object(i.getLogger)(e);
            class o {
                constructor() {
                    this._started = !1, this._streamsToMix = [], this._streamMSSArray = []
                }
                addMediaStream(e) {
                    e.getAudioTracks() || s.warn("Added MediaStream doesn't contain audio tracks."), this._streamsToMix.push(e)
                }
                start() {
                    if (this._started) return this._mixedMSD.stream;
                    if (this._audioContext = Object(r.a)(), !this._streamsToMix.length) return s.warn("No MediaStream's added to AudioMixer, nothing will happen."), null;
                    this._started = !0, this._mixedMSD = this._audioContext.createMediaStreamDestination();
                    for (const e of this._streamsToMix) {
                        const t = this._audioContext.createMediaStreamSource(e);
                        t.connect(this._mixedMSD), this._streamMSSArray.push(t)
                    }
                    return this._mixedMSD.stream
                }
                reset() {
                    this._started = !1, this._streamsToMix = [];
                    for (const e of this._streamMSSArray) e.disconnect();
                    this._streamMSSArray = [], this._audioContext && (this._audioContext = void 0)
                }
            }
        }).call(this, "modules/webaudio/AudioMixer.js")
    }, function(e, t) {
        const n = {
            getTokenAuthUrl: (e, t, n) => "string" != typeof e ? null : e.replace("{room}", t).replace("{roleUpgrade}", !0 === n)
        };
        e.exports = n
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return c
        }));
        var i = n(7),
            r = n(88),
            s = n(25),
            o = n(5),
            a = n(37);

        function c(e, t, n) {
            this.appID = e, this.token = t, this.options = n, this.xmpp = new a.c(n, t), this.addEventListener(s.CONNECTION_FAILED, (e, t, n, r) => {
                o.a.sendAnalyticsAndLog(Object(i.B)(e, t, r))
            }), this.addEventListener(s.CONNECTION_DISCONNECTED, e => {
                e && o.a.sendAnalytics(i.m, {
                    message: e
                }), o.a.sendLog(JSON.stringify({
                    id: i.m,
                    msg: e
                }))
            })
        }
        c.prototype.connect = function(e = {}) {
            this.xmpp.connect(e.id, e.password)
        }, c.prototype.attach = function(e) {
            this.xmpp.attach(e)
        }, c.prototype.disconnect = function(...e) {
            return this.xmpp.disconnect(...e)
        }, c.prototype.getJid = function() {
            return this.xmpp.getJid()
        }, c.prototype.setToken = function(e) {
            this.token = e
        }, c.prototype.initJitsiConference = function(e, t) {
            return new r.a({
                name: e,
                config: t,
                connection: this
            })
        }, c.prototype.addEventListener = function(e, t) {
            this.xmpp.addListener(e, t)
        }, c.prototype.removeEventListener = function(e, t) {
            this.xmpp.removeListener(e, t)
        }, c.prototype.getConnectionTimes = function() {
            return this.xmpp.connectionTimes
        }, c.prototype.addFeature = function(e, t = !1) {
            return this.xmpp.caps.addFeature(e, t)
        }, c.prototype.removeFeature = function(e, t = !1) {
            return this.xmpp.caps.removeFeature(e, t)
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return se
            }));
            var i = n(1),
                r = n(19),
                s = n.n(r),
                o = n(4),
                a = n(58),
                c = n.n(a),
                d = n(18),
                u = n(89),
                l = n(2),
                h = n(91),
                p = n(16),
                f = n(13),
                m = n(15),
                g = n(92),
                _ = n(110),
                v = n(12),
                S = n(111),
                y = n(112),
                E = n(113),
                T = n(66),
                b = n(20),
                C = n(114),
                R = n(3),
                A = n(115),
                w = n(116),
                I = n(44),
                P = n(117),
                D = n(118),
                O = n(119),
                N = n(120),
                M = n(121),
                L = n(34),
                k = n(122),
                x = n(123),
                F = n(124),
                j = n(5),
                U = n(125),
                H = n.n(U),
                J = n(11),
                B = n.n(J),
                G = n(35),
                V = n.n(G),
                q = n(126),
                K = n(127),
                W = n(22),
                z = n(37),
                X = n(9),
                Q = n(8),
                Y = n(14),
                Z = n.n(Y),
                ee = n(7),
                te = n(0);

            function ne(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {},
                        i = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), i.forEach((function(t) {
                        ie(e, t, n[t])
                    }))
                }
                return e
            }

            function ie(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const re = Object(o.getLogger)(e);

            function se(e) {
                if (!e.name || e.name.toLowerCase() !== e.name) {
                    const e = "Invalid conference name (no conference name passed or it contains invalid characters like capital letters)!";
                    throw re.error(e), new Error(e)
                }
                this.eventEmitter = new s.a, this.options = e, this.eventManager = new u.a(this), this.participants = {}, this._init(e), this.componentsVersions = new q.a(this), this.jvbJingleSession = null, this.lastDominantSpeaker = null, this.dtmfManager = null, this.somebodySupportsDTMF = !1, this.authEnabled = !1, this.startAudioMuted = !1, this.startVideoMuted = !1, this.startMutedPolicy = {
                    audio: !1,
                    video: !1
                }, this.isMutedByFocus = !1, this.mutedByFocusActor = null, this.wasStopped = !1, this.properties = {}, this.connectionQuality = new A.a(this, this.eventEmitter, e), this.avgRtpStatsReporter = new k.a(this, e.config.avgRtpStatsN || 15), this._audioOutputProblemDetector = new x.a(this), this.isJvbConnectionInterrupted = !1, this.speakerStatsCollector = new F.a(this), this.deferredStartP2PTask = null;
                const t = parseInt(e.config.p2p && e.config.p2p.backToP2PDelay, 10);
                this.backToP2PDelay = isNaN(t) ? 5 : t, re.info(`backToP2PDelay: ${this.backToP2PDelay}`), this.isP2PConnectionInterrupted = !1, this.p2p = !1, this.p2pJingleSession = null, this.videoSIPGWHandler = new K.a(this.room), this.recordingManager = new N.a(this.room), this._conferenceJoinAnalyticsEventSent = !1, R.a.supportsInsertableStreams() && (this._e2eeCtx = new P.a({
                    salt: this.options.name
                }))
            }
            se.prototype.constructor = se, se.resourceCreator = function(e, t) {
                let n;
                if (t) n = V.a.randomHexString(8).toLowerCase();
                else {
                    n = i.Strophe.getNodeFromJid(e).substr(0, 8).toLowerCase(), /[0-9a-f]{8}/g.test(n) || (n = V.a.randomHexString(8).toLowerCase())
                }
                return n
            }, se.prototype._init = function(e = {}) {
                e.connection && (this.connection = e.connection, this.xmpp = this.connection.xmpp, this.eventManager.setupXMPPListeners());
                const {
                    config: t
                } = this.options;
                if (this._statsCurrentId = t.statisticsId ? t.statisticsId : L.a.callStatsUserName, this.room = this.xmpp.createRoom(this.options.name, ne({}, t, {
                        statsId: this._statsCurrentId
                    }), se.resourceCreator), this._onIceConnectionInterrupted = this._onIceConnectionInterrupted.bind(this), this.room.addListener(te.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), this._onIceConnectionRestored = this._onIceConnectionRestored.bind(this), this.room.addListener(te.CONNECTION_RESTORED, this._onIceConnectionRestored), this._onIceConnectionEstablished = this._onIceConnectionEstablished.bind(this), this.room.addListener(te.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), this._updateProperties = this._updateProperties.bind(this), this.room.addListener(te.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), this._sendConferenceJoinAnalyticsEvent = this._sendConferenceJoinAnalyticsEvent.bind(this), this.room.addListener(te.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent), this.rttMonitor = new M.a(t.rttMonitor || {}), this.e2eping = new D.a(this, t, (e, t) => {
                        try {
                            this.sendMessage(e, t, !0)
                        } catch (e) {
                            re.warn("Failed to send E2E ping request or response.", e && e.msg)
                        }
                    }), this.rtc || (this.rtc = new v.a(this, e), this.eventManager.setupRTCListeners()), this.participantConnectionStatus = new I.b(this.rtc, this, {
                        rtcMuteTimeout: t._peerConnStatusRtcMuteTimeout,
                        outOfLastNTimeout: t._peerConnStatusOutOfLastNTimeout
                    }), this.participantConnectionStatus.init(), this.statistics || (this.statistics = new j.a(this.xmpp, {
                        aliasName: this._statsCurrentId,
                        userName: t.statisticsDisplayName ? t.statisticsDisplayName : this.myUserId(),
                        callStatsConfIDNamespace: this.connection.options.hosts.domain,
                        confID: t.confID || `${this.connection.options.hosts.domain}/${this.options.name}`,
                        customScriptUrl: t.callStatsCustomScriptUrl,
                        callStatsID: t.callStatsID,
                        callStatsSecret: t.callStatsSecret,
                        callStatsApplicationLogsDisabled: t.callStatsApplicationLogsDisabled,
                        roomName: this.options.name,
                        applicationName: t.applicationName,
                        getWiFiStatsMethod: t.getWiFiStatsMethod
                    }), j.a.analytics.addPermanentProperties({
                        callstats_name: this._statsCurrentId
                    })), this.eventManager.setupChatRoomListeners(), this.eventManager.setupStatisticsListeners(), t.enableTalkWhileMuted)
                    if (t.createVADProcessor) {
                        re.info("Using VAD detection for generating talk while muted events"), this._audioAnalyser || (this._audioAnalyser = new T.a(this, t.createVADProcessor));
                        const e = new y.a;
                        e.on(b.VAD_TALK_WHILE_MUTED, () => this.eventEmitter.emit(l.TALK_WHILE_MUTED)), this._audioAnalyser.addVADDetectionService(e)
                    } else re.info("Using audio level based detection for generating talk while muted events"), this._talkWhileMutedDetection = new S.a(this, () => this.eventEmitter.emit(l.TALK_WHILE_MUTED));
                if (t.enableNoisyMicDetection)
                    if (t.createVADProcessor) {
                        this._audioAnalyser || (this._audioAnalyser = new T.a(this, t.createVADProcessor));
                        const e = new E.a;
                        e.on(b.VAD_NOISY_DEVICE, () => this.eventEmitter.emit(l.NOISY_MIC)), this._audioAnalyser.addVADDetectionService(e)
                    } else re.warn("No VAD Processor was provided. Noisy microphone detection service was not initialized!");
                t.enableNoAudioDetection && (this._noAudioSignalDetection = new C.a(this), this._noAudioSignalDetection.on(b.NO_AUDIO_INPUT, () => {
                    this.eventEmitter.emit(l.NO_AUDIO_INPUT)
                }), this._noAudioSignalDetection.on(b.AUDIO_INPUT_STATE_CHANGE, e => {
                    this.eventEmitter.emit(l.AUDIO_INPUT_STATE_CHANGE, e)
                })), "channelLastN" in t && this.setLastN(t.channelLastN), this.jvb121Status = new O.a(this), this.p2pDominantSpeakerDetection = new _.a(this), t && t.deploymentInfo && t.deploymentInfo.userRegion && this.setLocalParticipantProperty("region", t.deploymentInfo.userRegion)
            }, se.prototype.join = function(e) {
                this.room && this.room.join(e).then(() => this._maybeSetSITimeout())
            }, se.prototype.authenticateAndUpgradeRole = function(e) {
                return g.a.call(this, ne({}, e, {
                    onCreateResource: se.resourceCreator
                }))
            }, se.prototype.isJoined = function() {
                return this.room && this.room.joined
            }, se.prototype.isP2PEnabled = function() {
                return Boolean(this.options.config.p2p && this.options.config.p2p.enabled) || void 0 === this.options.config.p2p
            }, se.prototype.isP2PTestModeEnabled = function() {
                return Boolean(this.options.config.testing && this.options.config.testing.p2pTestMode)
            }, se.prototype.leave = function() {
                if (this.participantConnectionStatus && (this.participantConnectionStatus.dispose(), this.participantConnectionStatus = null), this.avgRtpStatsReporter && (this.avgRtpStatsReporter.dispose(), this.avgRtpStatsReporter = null), this._audioOutputProblemDetector && (this._audioOutputProblemDetector.dispose(), this._audioOutputProblemDetector = null), this.rttMonitor && (this.rttMonitor.stop(), this.rttMonitor = null), this.e2eping && (this.e2eping.stop(), this.e2eping = null), this.getLocalTracks().forEach(e => this.onLocalTrackRemoved(e)), this.rtc.closeBridgeChannel(), this.statistics && this.statistics.dispose(), this._delayedIceFailed && this._delayedIceFailed.cancel(), this.jvbJingleSession && (this.jvbJingleSession.close(), this.jvbJingleSession = null), this.p2pJingleSession && (this.p2pJingleSession.close(), this.p2pJingleSession = null), this.room) {
                    const e = this.room;
                    return e.removeListener(te.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), e.removeListener(te.CONNECTION_RESTORED, this._onIceConnectionRestored), e.removeListener(te.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), e.removeListener(te.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), e.removeListener(te.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent), this.eventManager.removeXMPPListeners(), this.room = null, e.leave().then(() => {
                        this.rtc && this.rtc.destroy()
                    }).catch(e => {
                        throw this.getParticipants().forEach(e => this.onMemberLeft(e.getJid())), e
                    })
                }
                return Promise.reject(new Error("The conference is has been already left"))
            }, se.prototype.getName = function() {
                return this.options.name
            }, se.prototype.getConnection = function() {
                return this.connection
            }, se.prototype.isAuthEnabled = function() {
                return this.authEnabled
            }, se.prototype.isLoggedIn = function() {
                return Boolean(this.authIdentity)
            }, se.prototype.getAuthLogin = function() {
                return this.authIdentity
            }, se.prototype.isExternalAuthEnabled = function() {
                return this.room && this.room.moderator.isExternalAuthEnabled()
            }, se.prototype.getExternalAuthUrl = function(e) {
                return new Promise((t, n) => {
                    this.isExternalAuthEnabled() ? e ? this.room.moderator.getPopupLoginUrl(t, n) : this.room.moderator.getLoginUrl(t, n) : n()
                })
            }, se.prototype.getLocalTracks = function(e) {
                let t = [];
                return this.rtc && (t = this.rtc.getLocalTracks(e)), t
            }, se.prototype.getLocalAudioTrack = function() {
                return this.rtc ? this.rtc.getLocalAudioTrack() : null
            }, se.prototype.getLocalVideoTrack = function() {
                return this.rtc ? this.rtc.getLocalVideoTrack() : null
            }, se.prototype.on = function(e, t) {
                this.eventEmitter && this.eventEmitter.on(e, t)
            }, se.prototype.off = function(e, t) {
                this.eventEmitter && this.eventEmitter.removeListener(e, t)
            }, se.prototype.addEventListener = se.prototype.on, se.prototype.removeEventListener = se.prototype.off, se.prototype.addCommandListener = function(e, t) {
                this.room && this.room.addPresenceListener(e, t)
            }, se.prototype.removeCommandListener = function(e, t) {
                this.room && this.room.removePresenceListener(e, t)
            }, se.prototype.sendTextMessage = function(e, t = "body") {
                if (this.room) {
                    const n = (this.room.getFromPresence("nick") || {}).value;
                    this.room.sendMessage(e, t, n)
                }
            }, se.prototype.sendPrivateTextMessage = function(e, t, n = "body") {
                this.room && this.room.sendPrivateMessage(e, t, n)
            }, se.prototype.sendCommand = function(e, t) {
                this.room ? (this.room.addToPresence(e, t), this.room.sendPresence()) : re.warn("Not sending a command, room not initialized.")
            }, se.prototype.sendCommandOnce = function(e, t) {
                this.sendCommand(e, t), this.removeCommand(e)
            }, se.prototype.removeCommand = function(e) {
                this.room && this.room.removeFromPresence(e)
            }, se.prototype.setDisplayName = function(e) {
                this.room && (this.room.removeFromPresence("nick"), this.room.addToPresence("nick", {
                    attributes: {
                        xmlns: "http://jabber.org/protocol/nick"
                    },
                    value: e
                }), this.room.sendPresence())
            }, se.prototype.setSubject = function(e) {
                this.room && this.isModerator() && this.room.setSubject(e)
            }, se.prototype.getTranscriber = function() {
                if (void 0 === this.transcriber) {
                    this.transcriber = new H.a;
                    const e = this.getLocalTracks(X.a);
                    for (const t of e) this.transcriber.addTrack(t);
                    const t = this.rtc.getRemoteTracks(X.a);
                    for (const e of t) this.transcriber.addTrack(e)
                }
                return this.transcriber
            }, se.prototype.getTranscriptionStatus = function() {
                return this.room.transcriptionStatus
            }, se.prototype.addTrack = function(e) {
                if (e.isVideoTrack()) {
                    const t = this.rtc.getLocalVideoTrack();
                    if (t) return e === t ? Promise.resolve(e) : Promise.reject(new Error("cannot add second video track to the conference"))
                }
                return this.replaceTrack(null, e)
            }, se.prototype._fireAudioLevelChangeEvent = function(e, t) {
                const n = this.getActivePeerConnection();
                t && n !== t || this.eventEmitter.emit(l.TRACK_AUDIO_LEVEL_CHANGED, this.myUserId(), e)
            }, se.prototype._fireMuteChangeEvent = function(e) {
                let t;
                if (this.isMutedByFocus && e.isAudioTrack() && !e.isMuted() && (this.isMutedByFocus = !1, this.room.muteParticipant(this.room.myroomjid, !1)), this.mutedByFocusActor) {
                    const e = i.Strophe.getResourceFromJid(this.mutedByFocusActor);
                    t = this.participants[e]
                }
                this.eventEmitter.emit(l.TRACK_MUTE_CHANGED, e, t)
            }, se.prototype.onLocalTrackRemoved = function(e) {
                e._setConference(null), this.rtc.removeLocalTrack(e), e.removeEventListener(m.TRACK_MUTE_CHANGED, e.muteHandler), e.removeEventListener(m.TRACK_AUDIO_LEVEL_CHANGED, e.audioLevelHandler), e.isVideoTrack() && e.videoType === Z.a.DESKTOP && this.statistics.sendScreenSharingEvent(!1), this.eventEmitter.emit(l.TRACK_REMOVED, e)
            }, se.prototype.removeTrack = function(e) {
                return this.replaceTrack(e, null)
            }, se.prototype.replaceTrack = function(e, t) {
                return e && e.disposed ? Promise.reject(new p.a(f.TRACK_IS_DISPOSED)) : t && t.disposed ? Promise.reject(new p.a(f.TRACK_IS_DISPOSED)) : this._doReplaceTrack(e, t).then(() => (e && this.onLocalTrackRemoved(e), t && this._setupNewTrack(t), Promise.resolve()), e => Promise.reject(new Error(e)))
            }, se.prototype._doReplaceTrack = function(e, t) {
                const n = [];
                return this.jvbJingleSession ? n.push(this.jvbJingleSession.replaceTrack(e, t)) : re.info("_doReplaceTrack - no JVB JingleSession"), this.p2pJingleSession ? n.push(this.p2pJingleSession.replaceTrack(e, t)) : re.info("_doReplaceTrack - no P2P JingleSession"), Promise.all(n)
            }, se.prototype._setupNewTrack = function(e) {
                if (e.isAudioTrack() || e.isVideoTrack() && e.videoType !== Z.a.DESKTOP) {
                    const t = v.a.getCurrentlyAvailableMediaDevices().find(t => t.kind === `${e.getTrack().kind}input` && t.label === e.getTrack().label);
                    t && j.a.sendActiveDeviceListEvent(v.a.getEventDataForActiveDevice(t))
                }
                e.isVideoTrack() && (this.removeCommand("videoType"), this.sendCommand("videoType", {
                    value: e.videoType,
                    attributes: {
                        xmlns: "http://jitsi.org/jitmeet/video"
                    }
                })), this.rtc.addLocalTrack(e), e.isAudioTrack() ? this.room.setAudioMute(e.isMuted()) : this.room.setVideoMute(e.isMuted()), e.muteHandler = this._fireMuteChangeEvent.bind(this, e), e.audioLevelHandler = this._fireAudioLevelChangeEvent.bind(this), e.addEventListener(m.TRACK_MUTE_CHANGED, e.muteHandler), e.addEventListener(m.TRACK_AUDIO_LEVEL_CHANGED, e.audioLevelHandler), e._setConference(this), this.eventEmitter.emit(l.TRACK_ADDED, e)
            }, se.prototype._addLocalTrackAsUnmute = function(e) {
                const t = [];
                return this.jvbJingleSession ? t.push(this.jvbJingleSession.addTrackAsUnmute(e)) : re.info("Add local MediaStream as unmute - no JVB Jingle session started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.addTrackAsUnmute(e)) : re.info("Add local MediaStream as unmute - no P2P Jingle session started yet"), Promise.all(t)
            }, se.prototype._removeLocalTrackAsMute = function(e) {
                const t = [];
                return this.jvbJingleSession ? t.push(this.jvbJingleSession.removeTrackAsMute(e)) : re.info("Remove local MediaStream - no JVB JingleSession started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.removeTrackAsMute(e)) : re.info("Remove local MediaStream - no P2P JingleSession started yet"), Promise.all(t)
            }, se.prototype.getRole = function() {
                return this.room.role
            }, se.prototype.isHidden = function() {
                return this.connection ? i.Strophe.getDomainFromJid(this.connection.getJid()) === this.options.config.hiddenDomain : null
            }, se.prototype.isModerator = function() {
                return this.room ? this.room.isModerator() : null
            }, se.prototype.lock = function(e) {
                return this.isModerator() ? new Promise((t, n) => {
                    this.room.lockRoom(e || "", () => t(), e => n(e), () => n(d.PASSWORD_NOT_SUPPORTED))
                }) : Promise.reject(new Error("You are not moderator."))
            }, se.prototype.unlock = function() {
                return this.lock()
            }, se.prototype.selectParticipant = function(e) {
                this.selectParticipants([e])
            }, se.prototype.selectParticipants = function(e) {
                if (!Array.isArray(e)) throw new Error("Invalid argument; participantIds must be an array.");
                this.rtc.selectEndpoints(e)
            }, se.prototype.pinParticipant = function(e) {
                this.rtc.pinEndpoint(e)
            }, se.prototype.getLastN = function() {
                return this.rtc.getLastN()
            }, se.prototype.setLastN = function(e) {
                if (!Number.isInteger(e) && !Number.parseInt(e, 10)) throw new Error(`Invalid value for lastN: ${e}`);
                const t = Number(e);
                if (t < -1) throw new RangeError("lastN cannot be smaller than -1");
                if (this.rtc.setLastN(t), this.p2pJingleSession) {
                    const e = 0 !== t;
                    this.p2pJingleSession.setMediaTransferActive(!0, e).catch(t => {
                        re.error(`Failed to adjust video transfer status (${e})`, t)
                    })
                }
            }, se.prototype.isInLastN = function(e) {
                return this.rtc.isInLastN(e)
            }, se.prototype.getParticipants = function() {
                return Object.keys(this.participants).map((function(e) {
                    return this.participants[e]
                }), this)
            }, se.prototype.getParticipantCount = function(e = !1) {
                let t = this.getParticipants();
                return e || (t = t.filter(e => !e.isHidden())), t.length + 1
            }, se.prototype.getParticipantById = function(e) {
                return this.participants[e]
            }, se.prototype.kickParticipant = function(e) {
                const t = this.getParticipantById(e);
                t && this.room.kick(t.getJid())
            }, se.prototype._maybeClearSITimeout = function() {
                this._sessionInitiateTimeout && (this.jvbJingleSession || this.getParticipantCount() < 2) && (window.clearTimeout(this._sessionInitiateTimeout), this._sessionInitiateTimeout = null)
            }, se.prototype._maybeSetSITimeout = function() {
                !this.jvbJingleSession && this.getParticipantCount() >= 2 && !this._sessionInitiateTimeout && (this._sessionInitiateTimeout = window.setTimeout(() => {
                    this._sessionInitiateTimeout = null, j.a.sendAnalytics(Object(ee.G)(ee.d, {
                        p2p: !1,
                        value: 5e3
                    }))
                }, 5e3))
            }, se.prototype.muteParticipant = function(e) {
                const t = this.getParticipantById(e);
                t && this.room.muteParticipant(t.getJid(), !0)
            }, se.prototype.onMemberJoined = function(e, t, n, r, s, o, a, c) {
                const d = i.Strophe.getResourceFromJid(e);
                if ("focus" === d || this.myUserId() === d) return;
                const u = new h.a(e, this, t, r, s, o, a);
                u._role = n, u._botType = c, this.participants[d] = u, this.eventEmitter.emit(l.USER_JOINED, d, u), this._updateFeatures(u), this._maybeStartOrStopP2P(), this._maybeSetSITimeout()
            }, se.prototype._updateFeatures = function(e) {
                e.getFeatures().then(t => {
                    e._supportsDTMF = t.has("urn:xmpp:jingle:dtmf:0"), this.updateDTMFSupport(), t.has("http://jitsi.org/protocol/jigasi") && e.setProperty("features_jigasi", !0), t.has("https://jitsi.org/meet/e2ee") && e.setProperty("features_e2ee", !0)
                }).catch(() => !1)
            }, se.prototype._onMemberBotTypeChanged = function(e, t) {
                const n = this.getParticipants().find(t => t.getJid() === e);
                if (n) {
                    n._botType = t;
                    const r = i.Strophe.getResourceFromJid(e);
                    this.eventEmitter.emit(l.BOT_TYPE_CHANGED, r, t)
                }
                n._botType || this._maybeStartOrStopP2P()
            }, se.prototype.onMemberLeft = function(e) {
                const t = i.Strophe.getResourceFromJid(e);
                if ("focus" === t || this.myUserId() === t) return;
                const n = this.participants[t];
                delete this.participants[t], this.rtc.removeRemoteTracks(t).forEach(e => this.eventEmitter.emit(l.TRACK_REMOVED, e)), n && this.eventEmitter.emit(l.USER_LEFT, t, n), this._maybeStartOrStopP2P(!0), this._maybeClearSITimeout()
            }, se.prototype.onMemberKicked = function(e, t, n) {
                const i = this.participants[t];
                if (e) return this.eventEmitter.emit(l.KICKED, i), void this.leave();
                const r = this.participants[n];
                this.eventEmitter.emit(l.PARTICIPANT_KICKED, i, r)
            }, se.prototype.onLocalRoleChanged = function(e) {
                this.eventEmitter.emit(l.USER_ROLE_CHANGED, this.myUserId(), e)
            }, se.prototype.onUserRoleChanged = function(e, t) {
                const n = i.Strophe.getResourceFromJid(e),
                    r = this.getParticipantById(n);
                r && (r._role = t, this.eventEmitter.emit(l.USER_ROLE_CHANGED, n, t))
            }, se.prototype.onDisplayNameChanged = function(e, t) {
                const n = i.Strophe.getResourceFromJid(e),
                    r = this.getParticipantById(n);
                r && r._displayName !== t && (r._displayName = t, this.eventEmitter.emit(l.DISPLAY_NAME_CHANGED, n, t))
            }, se.prototype.onRemoteTrackAdded = function(e) {
                if (e.isP2P && !this.isP2PActive()) return void re.info("Trying to add remote P2P track, when not in P2P - IGNORED");
                if (!e.isP2P && this.isP2PActive()) return void re.info("Trying to add remote JVB track, when in P2P - IGNORED");
                this._setupReceiverE2EEForTrack(e);
                const t = e.getParticipantId(),
                    n = this.getParticipantById(t);
                if (!n) return void re.error(`No participant found for id: ${t}`);
                n._tracks.push(e), this.transcriber && this.transcriber.addTrack(e);
                const i = this.eventEmitter;
                e.addEventListener(m.TRACK_MUTE_CHANGED, () => i.emit(l.TRACK_MUTE_CHANGED, e)), e.addEventListener(m.TRACK_AUDIO_LEVEL_CHANGED, (e, n) => {
                    this.getActivePeerConnection() === n && i.emit(l.TRACK_AUDIO_LEVEL_CHANGED, t, e)
                }), i.emit(l.TRACK_ADDED, e)
            }, se.prototype.onCallAccepted = function(e, t) {
                if (this.p2pJingleSession === e) {
                    re.info("P2P setAnswer");
                    const n = this.getLocalTracks();
                    for (const t of n) this._setupSenderE2EEForTrack(e, t);
                    this.p2pJingleSession.setAnswer(t)
                }
            }, se.prototype.onTransportInfo = function(e, t) {
                this.p2pJingleSession === e && (re.info("P2P addIceCandidates"), this.p2pJingleSession.addIceCandidates(t))
            }, se.prototype.onRemoteTrackRemoved = function(e) {
                this.getParticipants().forEach(t => {
                    const n = t.getTracks();
                    for (let i = 0; i < n.length; i++)
                        if (n[i] === e) {
                            t._tracks.splice(i, 1), this.eventEmitter.emit(l.TRACK_REMOVED, e), this.transcriber && this.transcriber.removeTrack(e);
                            break
                        }
                }, this)
            }, se.prototype._onIncomingCallP2P = function(e, t) {
                let n;
                R.a.supportsP2P() ? this.isP2PEnabled() || this.isP2PTestModeEnabled() ? this.p2pJingleSession ? n = {
                    reason: "busy",
                    reasonDescription: "P2P already in progress",
                    errorMsg: 'Duplicated P2P "session-initiate"'
                } : this._shouldBeInP2PMode() || (n = {
                    reason: "decline",
                    reasonDescription: "P2P requirements not met",
                    errorMsg: 'Received P2P "session-initiate" when should not be in P2P mode'
                }, j.a.sendAnalytics(Object(ee.G)(ee.h))) : n = {
                    reason: "decline",
                    reasonDescription: "P2P disabled",
                    errorMsg: "P2P mode disabled in the configuration"
                } : n = {
                    reason: "unsupported-applications",
                    reasonDescription: "P2P not supported",
                    errorMsg: "This client does not support P2P connections"
                }, n ? this._rejectIncomingCall(e, n) : this._acceptP2PIncomingCall(e, t)
            }, se.prototype.onIncomingCall = function(e, t, n) {
                if (e.isP2P) this._onIncomingCallP2P(e, t);
                else {
                    if (!this.room.isFocus(e.remoteJid)) {
                        const t = "Rejecting session-initiate from non-focus.";
                        return void this._rejectIncomingCall(e, {
                            reason: "security-error",
                            reasonDescription: t,
                            errorMsg: t
                        })
                    }
                    this._acceptJvbIncomingCall(e, t, n)
                }
            }, se.prototype._acceptJvbIncomingCall = function(e, t, n) {
                this.jvbJingleSession = e, this.room.connectionTimes["session.initiate"] = n, this._sendConferenceJoinAnalyticsEvent(), this.wasStopped && j.a.sendAnalyticsAndLog(Object(ee.G)(ee.a, {
                    p2p: !1
                }));
                const i = $(t).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("region");
                this.eventEmitter.emit(l.SERVER_REGION_CHANGED, i), this._maybeClearSITimeout(), j.a.sendAnalytics(Object(ee.G)(ee.c, {
                    p2p: !1,
                    value: n
                }));
                try {
                    e.initialize(this.room, this.rtc, this.options.config)
                } catch (e) {
                    B.a.callErrorHandler(e)
                }
                this._setBridgeChannel(t, e.peerconnection);
                const r = this.getLocalTracks();
                try {
                    e.acceptOffer(t, () => {
                        this.isP2PActive() && this.jvbJingleSession && this._suspendMediaTransferForJvbConnection();
                        for (const t of r) this._setupSenderE2EEForTrack(e, t)
                    }, e => {
                        B.a.callErrorHandler(e), re.error("Failed to accept incoming Jingle session", e)
                    }, r), re.info("Starting CallStats for JVB connection..."), this.statistics.startCallStats(this.jvbJingleSession.peerconnection, "jitsi"), this.statistics.startRemoteStats(this.jvbJingleSession.peerconnection)
                } catch (e) {
                    B.a.callErrorHandler(e), re.error(e)
                }
            }, se.prototype._setBridgeChannel = function(e, t) {
                let n = null;
                const i = $(e).find(">content>transport>web-socket").first();
                let r;
                switch (1 === i.length && (n = i[0].getAttribute("url")), this.options.config.openBridgeChannel) {
                    case "datachannel":
                    case !0:
                    case void 0:
                        r = "datachannel";
                        break;
                    case "websocket":
                        r = "websocket"
                }
                "datachannel" === r ? this.rtc.initializeBridgeChannel(t, null) : "websocket" === r && n && this.rtc.initializeBridgeChannel(null, n)
            }, se.prototype._rejectIncomingCall = function(e, t) {
                t && t.errorMsg && B.a.callErrorHandler(new Error(t.errorMsg)), e.terminate(null, e => {
                    re.warn("An error occurred while trying to terminate invalid Jingle session", e)
                }, {
                    reason: t && t.reason,
                    reasonDescription: t && t.reasonDescription,
                    sendSessionTerminate: !0
                })
            }, se.prototype.onCallEnded = function(e, t, n) {
                re.info(`Call ended: ${t} - ${n} P2P ?${e.isP2P}`), e === this.jvbJingleSession ? (this.wasStopped = !0, j.a.sendAnalytics(Object(ee.G)(ee.e, {
                    p2p: !1
                })), this.statistics && (this.statistics.stopRemoteStats(this.jvbJingleSession.peerconnection), re.info("Stopping JVB CallStats"), this.statistics.stopCallStats(this.jvbJingleSession.peerconnection)), this.jvbJingleSession = null, this.rtc.onCallEnded()) : e === this.p2pJingleSession ? ("decline" === t && "force JVB121" === n ? (re.info("In forced JVB 121 mode..."), j.a.analytics.addPermanentProperties({
                    forceJvb121: !0
                })) : "connectivity-error" === t && "ICE FAILED" === n && j.a.analytics.addPermanentProperties({
                    p2pFailed: !0
                }), this._stopP2PSession()) : re.error("Received onCallEnded for invalid session", e.sid, e.remoteJid, t, n)
            }, se.prototype.onSuspendDetected = function(e) {
                e.isP2P || (this.leave(), this.eventEmitter.emit(l.SUSPEND_DETECTED))
            }, se.prototype.updateDTMFSupport = function() {
                let e = !1;
                const t = this.getParticipants();
                for (let n = 0; n < t.length; n += 1)
                    if (t[n].supportsDTMF()) {
                        e = !0;
                        break
                    } e !== this.somebodySupportsDTMF && (this.somebodySupportsDTMF = e, this.eventEmitter.emit(l.DTMF_SUPPORT_CHANGED, e))
            }, se.prototype.isDTMFSupported = function() {
                return this.somebodySupportsDTMF
            }, se.prototype.myUserId = function() {
                return this.room && this.room.myroomjid ? i.Strophe.getResourceFromJid(this.room.myroomjid) : null
            }, se.prototype.sendTones = function(e, t, n) {
                const i = this.getActivePeerConnection();
                i ? i.sendTones(e, t, n) : re.warn("cannot sendTones: no peer connection")
            }, se.prototype.startRecording = function(e) {
                return this.room ? this.recordingManager.startRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
            }, se.prototype.stopRecording = function(e) {
                return this.room ? this.recordingManager.stopRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
            }, se.prototype.isSIPCallingSupported = function() {
                return !!this.room && this.room.isSIPCallingSupported()
            }, se.prototype.dial = function(e) {
                return this.room ? this.room.dial(e) : new Promise((e, t) => {
                    t(new Error("The conference is not created yet!"))
                })
            }, se.prototype.hangup = function() {
                return this.room ? this.room.hangup() : new Promise((e, t) => {
                    t(new Error("The conference is not created yet!"))
                })
            }, se.prototype.startTranscriber = function() {
                return this.dial("jitsi_meet_transcribe")
            }, se.prototype.stopTranscriber = se.prototype.hangup, se.prototype.getPhoneNumber = function() {
                return this.room ? this.room.getPhoneNumber() : null
            }, se.prototype.getPhonePin = function() {
                return this.room ? this.room.getPhonePin() : null
            }, se.prototype.getMeetingUniqueId = function() {
                if (this.room) return this.room.getMeetingId()
            }, se.prototype.getActivePeerConnection = function() {
                return this.isP2PActive() ? this.p2pJingleSession.peerconnection : this.jvbJingleSession ? this.jvbJingleSession.peerconnection : null
            }, se.prototype.getConnectionState = function() {
                const e = this.getActivePeerConnection();
                return e ? e.getConnectionState() : null
            }, se.prototype.setStartMutedPolicy = function(e) {
                this.isModerator() && (this.startMutedPolicy = e, this.room.removeFromPresence("startmuted"), this.room.addToPresence("startmuted", {
                    attributes: {
                        audio: e.audio,
                        video: e.video,
                        xmlns: "http://jitsi.org/jitmeet/start-muted"
                    }
                }), this.room.sendPresence())
            }, se.prototype.getStartMutedPolicy = function() {
                return this.startMutedPolicy
            }, se.prototype.isStartAudioMuted = function() {
                return this.startAudioMuted
            }, se.prototype.isStartVideoMuted = function() {
                return this.startVideoMuted
            }, se.prototype.getLogs = function() {
                const e = this.xmpp.getJingleLog(),
                    t = {};
                t.time = new Date, t.url = window.location.href, t.ua = navigator.userAgent;
                const n = this.xmpp.getXmppLog();
                return n && (t.xmpp = n), e.metadata = t, e
            }, se.prototype.getConnectionTimes = function() {
                return this.room.connectionTimes
            }, se.prototype.setLocalParticipantProperty = function(e, t) {
                this.sendCommand(`jitsi_participant_${e}`, {
                    value: t
                })
            }, se.prototype.removeLocalParticipantProperty = function(e) {
                this.removeCommand(`jitsi_participant_${e}`), this.room.sendPresence()
            }, se.prototype.getLocalParticipantProperty = function(e) {
                const t = this.room.presMap.nodes.find(t => t.tagName === `jitsi_participant_${e}`);
                return t ? t.value : void 0
            }, se.prototype.sendFeedback = function(e, t) {
                return this.statistics.sendFeedback(e, t)
            }, se.prototype.isCallstatsEnabled = function() {
                return this.statistics.isCallstatsEnabled()
            }, se.prototype._onTrackAttach = function(e, t) {
                const n = e.isLocal();
                let i = null;
                const r = e.isP2P,
                    s = r ? e.getParticipantId() : "jitsi",
                    o = r ? this.p2pJingleSession && this.p2pJingleSession.peerconnection : this.jvbJingleSession && this.jvbJingleSession.peerconnection;
                n ? o && (i = o.getLocalSSRC(e)) : i = e.getSSRC(), t.id && i && o && this.statistics.associateStreamWithVideoTag(o, i, n, s, e.getUsageLabel(), t.id)
            }, se.prototype.sendApplicationLog = function(e) {
                j.a.sendLog(e)
            }, se.prototype._isFocus = function(e) {
                return this.room ? this.room.isFocus(e) : null
            }, se.prototype._fireIncompatibleVersionsEvent = function() {
                this.eventEmitter.emit(l.CONFERENCE_FAILED, d.INCOMPATIBLE_SERVER_VERSIONS)
            }, se.prototype.sendEndpointMessage = function(e, t) {
                this.rtc.sendChannelMessage(e, t)
            }, se.prototype.broadcastEndpointMessage = function(e) {
                this.sendEndpointMessage("", e)
            }, se.prototype.sendMessage = function(e, t = "", n = !1) {
                const i = typeof e;
                if ("object" === i || !n && "string" === i)
                    if (n) this.sendEndpointMessage(t, e);
                    else {
                        let n = e,
                            r = "body";
                        if ("object" === i) {
                            r = "json-message", n.hasOwnProperty(z.b) || (n[z.b] = "");
                            try {
                                n = JSON.stringify(n)
                            } catch (e) {
                                return void re.error("Can not send a message, stringify failed: ", e)
                            }
                        }
                        t ? this.sendPrivateTextMessage(t, n, r) : this.sendTextMessage(n, r)
                    }
                else re.error(`Can not send a message of type ${i}`)
            }, se.prototype.isConnectionInterrupted = function() {
                return this.isP2PActive() ? this.isP2PConnectionInterrupted : this.isJvbConnectionInterrupted
            }, se.prototype._onIceConnectionInterrupted = function(e) {
                e.isP2P ? this.isP2PConnectionInterrupted = !0 : this.isJvbConnectionInterrupted = !0, e.isP2P === this.isP2PActive() && this.eventEmitter.emit(l.CONNECTION_INTERRUPTED)
            }, se.prototype._onIceConnectionFailed = function(e) {
                e.isP2P ? (j.a.analytics.addPermanentProperties({
                    p2pFailed: !0
                }), this.p2pJingleSession && j.a.sendAnalyticsAndLog(Object(ee.I)(ee.j, {
                    initiator: this.p2pJingleSession.isInitiator
                })), this._stopP2PSession("connectivity-error", "ICE FAILED")) : e && this.jvbJingleSession === e && (this.xmpp.isPingSupported() ? (this._delayedIceFailed = new w.a(this), this._delayedIceFailed.start(e)) : (re.info("PING not supported - sending ICE failed immediately"), e.sendIceFailedNotification()))
            }, se.prototype._onIceConnectionRestored = function(e) {
                e.isP2P ? this.isP2PConnectionInterrupted = !1 : (this.isJvbConnectionInterrupted = !1, this._delayedIceFailed && this._delayedIceFailed.cancel()), e.isP2P === this.isP2PActive() && this.eventEmitter.emit(l.CONNECTION_RESTORED)
            }, se.prototype._acceptP2PIncomingCall = function(e, t) {
                this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = e, this._sendConferenceJoinAnalyticsEvent(), this.p2pJingleSession.initialize(this.room, this.rtc, this.options.config), re.info("Starting CallStats for P2P connection...");
                let n = i.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);
                const r = this.participants[n];
                r && (n = r.getStatsID() || n), this.statistics.startCallStats(this.p2pJingleSession.peerconnection, n);
                const s = this.getLocalTracks();
                this.p2pJingleSession.acceptOffer(t, () => {
                    re.debug('Got RESULT for P2P "session-accept"');
                    for (const t of s) this._setupSenderE2EEForTrack(e, t)
                }, e => {
                    re.error("Failed to accept incoming P2P Jingle session", e)
                }, s)
            }, se.prototype._addRemoteJVBTracks = function() {
                this._addRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
            }, se.prototype._addRemoteP2PTracks = function() {
                this._addRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
            }, se.prototype._addRemoteTracks = function(e, t) {
                for (const n of t) re.info(`Adding remote ${e} track: ${n}`), this.rtc.eventEmitter.emit(Q.REMOTE_TRACK_ADDED, n)
            }, se.prototype._onIceConnectionEstablished = function(e) {
                null !== this.p2pJingleSession && (this.p2pEstablishmentDuration = this.p2pJingleSession.establishmentDuration), null !== this.jvbJingleSession && (this.jvbEstablishmentDuration = this.jvbJingleSession.establishmentDuration);
                let t = !1;
                const n = this.options.config.forceJVB121Ratio;
                if (e.isP2P ? this.p2pJingleSession !== e ? (re.error("CONNECTION_ESTABLISHED - wrong P2P session instance ?!"), t = !0) : !e.isInitiator && "number" == typeof n && Math.random() < n && (re.info(`Forcing JVB 121 mode (ratio=${n})...`), j.a.analytics.addPermanentProperties({
                        forceJvb121: !0
                    }), this._stopP2PSession("decline", "force JVB121"), t = !0) : t = !0, !isNaN(this.p2pEstablishmentDuration) && !isNaN(this.jvbEstablishmentDuration)) {
                    const e = this.p2pEstablishmentDuration - this.jvbEstablishmentDuration;
                    j.a.sendAnalytics(ee.p, {
                        value: e
                    })
                }
                e.isP2P === this.isP2PActive() && this.eventEmitter.emit(l.CONNECTION_ESTABLISHED), t || (this._setP2PStatus(!0), this.jvbJingleSession ? this._removeRemoteJVBTracks() : re.info("Not removing remote JVB tracks - no session yet"), this._addRemoteP2PTracks(), this.jvbJingleSession && this._suspendMediaTransferForJvbConnection(), re.info("Starting remote stats with p2p connection"), this.statistics.startRemoteStats(this.p2pJingleSession.peerconnection), j.a.sendAnalyticsAndLog(Object(ee.I)(ee.i, {
                    initiator: this.p2pJingleSession.isInitiator
                })))
            }, se.prototype._updateProperties = function(e = {}) {
                const t = !c()(e, this.properties);
                if (this.properties = e, t) {
                    this.eventEmitter.emit(l.PROPERTIES_CHANGED, this.properties), ["bridge-count", "created-ms", "octo-enabled"].forEach(t => {
                        void 0 !== e[t] && j.a.analytics.addPermanentProperties({
                            [t.replace("-", "_")]: e[t]
                        })
                    })
                }
            }, se.prototype.getProperty = function(e) {
                return this.properties[e]
            }, se.prototype._maybeClearDeferredStartP2P = function() {
                this.deferredStartP2PTask && (re.info("Cleared deferred start P2P task"), clearTimeout(this.deferredStartP2PTask), this.deferredStartP2PTask = null)
            }, se.prototype._removeRemoteJVBTracks = function() {
                this._removeRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
            }, se.prototype._removeRemoteP2PTracks = function() {
                this._removeRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
            }, se.prototype._removeRemoteTracks = function(e, t) {
                for (const n of t) re.info(`Removing remote ${e} track: ${n}`), this.rtc.eventEmitter.emit(Q.REMOTE_TRACK_REMOVED, n)
            }, se.prototype._resumeMediaTransferForJvbConnection = function() {
                re.info("Resuming media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!0, !0).then(() => {
                    re.info("Resumed media transfer over the JVB connection!")
                }, e => {
                    re.error("Failed to resume media transfer over the JVB connection:", e)
                })
            }, se.prototype._setP2PStatus = function(e) {
                if (this.p2p !== e) {
                    if (this.p2p = e, e) {
                        re.info("Peer to peer connection established!"), j.a.analytics.addPermanentProperties({
                            p2pFailed: !1,
                            forceJvb121: !1
                        });
                        const e = 0 !== this.rtc.getLastN();
                        this.p2pJingleSession.setMediaTransferActive(!0, e).catch(t => {
                            re.error("Failed to sync up P2P video transfer status" + `(${e})`, t)
                        })
                    } else re.info("Peer to peer connection closed!");
                    this.jvbJingleSession && this.statistics.sendConnectionResumeOrHoldEvent(this.jvbJingleSession.peerconnection, !e), this.dtmfManager = null, this.eventEmitter.emit(l.P2P_STATUS, this, this.p2p), this.eventEmitter.emit(this.isConnectionInterrupted() ? l.CONNECTION_INTERRUPTED : l.CONNECTION_RESTORED)
                } else re.debug(`Called _setP2PStatus with the same status: ${e}`)
            }, se.prototype._startP2PSession = function(e) {
                if (this._maybeClearDeferredStartP2P(), this.p2pJingleSession) return void re.error("P2P session already started!");
                this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = this.xmpp.connection.jingle.newP2PJingleSession(this.room.myroomjid, e), re.info("Created new P2P JingleSession", this.room.myroomjid, e), this._sendConferenceJoinAnalyticsEvent(), this.p2pJingleSession.initialize(this.room, this.rtc, this.options.config), re.info("Starting CallStats for P2P connection...");
                let t = i.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);
                const n = this.participants[t];
                n && (t = n.getStatsID() || t), this.statistics.startCallStats(this.p2pJingleSession.peerconnection, t);
                const r = this.getLocalTracks();
                this.p2pJingleSession.invite(r)
            }, se.prototype._suspendMediaTransferForJvbConnection = function() {
                re.info("Suspending media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!1, !1).then(() => {
                    re.info("Suspended media transfer over the JVB connection !")
                }, e => {
                    re.error("Failed to suspend media transfer over the JVB connection:", e)
                })
            }, se.prototype._maybeStartOrStopP2P = function(e) {
                if (!R.a.supportsP2P() || !this.isP2PEnabled() || this.isP2PTestModeEnabled()) return void re.info("Auto P2P disabled");
                const t = this.getParticipants(),
                    n = t.length,
                    i = this._shouldBeInP2PMode();
                if (!i && this.deferredStartP2PTask && this._maybeClearDeferredStartP2P(), !this.p2pJingleSession && i) {
                    const i = n && t[0],
                        r = this.myUserId(),
                        s = i.getId();
                    if (r > s) return void re.debug("I'm the bigger peersId - the other peer should start P2P", r, s);
                    if (r === s) return void re.error("The same IDs ? ", r, s);
                    const o = i.getJid();
                    if (e) {
                        if (this.deferredStartP2PTask) return void re.error("Deferred start P2P task's been set already!");
                        re.info(`Will start P2P with: ${o} after ${this.backToP2PDelay} seconds...`), this.deferredStartP2PTask = setTimeout(this._startP2PSession.bind(this, o), 1e3 * this.backToP2PDelay)
                    } else re.info(`Will start P2P with: ${o}`), this._startP2PSession(o)
                } else this.p2pJingleSession && !i && (re.info(`Will stop P2P with: ${this.p2pJingleSession.remoteJid}`), this.p2pJingleSession.isInitiator && n > 1 && j.a.sendAnalyticsAndLog(Object(ee.I)(ee.k)), this._stopP2PSession())
            }, se.prototype._shouldBeInP2PMode = function() {
                const e = this.getParticipants(),
                    t = e.length,
                    n = void 0 !== e.find(e => "poltergeist" === e._botType),
                    i = 1 === t && !n;
                return re.debug(`P2P? peerCount: ${t}, hasBotPeer: ${n} => ${i}`), i
            }, se.prototype._stopP2PSession = function(e, t) {
                if (!this.p2pJingleSession) return void re.error("No P2P session to be stopped!");
                const n = this.isP2PActive();
                n && (this.jvbJingleSession && this._resumeMediaTransferForJvbConnection(), this._removeRemoteP2PTracks()), re.info("Stopping remote stats for P2P connection"), this.statistics.stopRemoteStats(this.p2pJingleSession.peerconnection), re.info("Stopping CallStats for P2P connection"), this.statistics.stopCallStats(this.p2pJingleSession.peerconnection), this.p2pJingleSession.terminate(() => {
                    re.info("P2P session terminate RESULT")
                }, t => {
                    e && re.error("An error occurred while trying to terminate P2P Jingle session", t)
                }, {
                    reason: e || "success",
                    reasonDescription: t || "Turing off P2P session",
                    sendSessionTerminate: this.room && this.getParticipantById(i.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid))
                }), this.p2pJingleSession = null, this._setP2PStatus(!1), n && (this.jvbJingleSession ? this._addRemoteJVBTracks() : re.info("Not adding remote JVB tracks - no session yet"))
            }, se.prototype.isP2PActive = function() {
                return this.p2p
            }, se.prototype.getP2PConnectionState = function() {
                return this.isP2PActive() ? this.p2pJingleSession.peerconnection.getConnectionState() : null
            }, se.prototype.startP2PSession = function() {
                const e = this.getParticipants();
                if (1 !== e.length) throw new Error("There must be exactly 1 participant to start the P2P session !"); {
                    const t = e[0].getJid();
                    this._startP2PSession(t)
                }
            }, se.prototype.stopP2PSession = function() {
                this._stopP2PSession()
            }, se.prototype.getSpeakerStats = function() {
                return this.speakerStatsCollector.getStats()
            }, se.prototype.setReceiverVideoConstraint = function(e) {
                this.rtc.setReceiverVideoConstraint(e)
            }, se.prototype.createVideoSIPGWSession = function(e, t) {
                return this.room ? this.videoSIPGWHandler.createVideoSIPGWSession(e, t) : new Error(W.ERROR_NO_CONNECTION)
            }, se.prototype._sendConferenceJoinAnalyticsEvent = function() {
                const e = this.getMeetingUniqueId();
                !this._conferenceJoinAnalyticsEventSent && e && null !== this.getActivePeerConnection() && (j.a.sendAnalytics(Object(ee.A)("joined", {
                    meetingId: e,
                    participantId: `${e}.${this._statsCurrentId}`
                })), this._conferenceJoinAnalyticsEventSent = !0)
            }, se.prototype.isE2EESupported = function() {
                return Boolean(this._e2eeCtx)
            }, se.prototype.setE2EEKey = function(e) {
                this._e2eeCtx ? this._e2eeCtx.setKey(e) : re.warn("Cannot set E2EE key: there is no defined context, platform is likely unsupported.")
            }, se.prototype._setupSenderE2EEForTrack = function(e, t) {
                if (!this._e2eeCtx) return;
                const n = e.peerconnection.findSenderForTrack(t.track);
                n ? this._e2eeCtx.handleSender(n, t.getType()) : re.warn(`Could not handle E2EE for local ${t.getType()} track: sender not found`)
            }, se.prototype._setupReceiverE2EEForTrack = function(e) {
                if (!this._e2eeCtx) return;
                const t = e.isP2P ? this.p2pJingleSession : this.jvbJingleSession,
                    n = t && t.peerconnection;
                if (n) {
                    const t = n.findReceiverForTrack(e.track);
                    t ? this._e2eeCtx.handleReceiver(t, e.getType()) : re.warn(`Could not handle E2EE for remote ${e.getType()} track: receiver not found`)
                }
            }
        }).call(this, "JitsiConference.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return E
            }));
            var i = n(1),
                r = n(7),
                s = n(63),
                o = n.n(s),
                a = n(90),
                c = n.n(a),
                d = n(4),
                u = n(18),
                l = n(2),
                h = n(9),
                p = n(8),
                f = n.n(p),
                m = n(14),
                g = n.n(m),
                _ = n(5),
                v = n(0),
                S = n.n(v);
            const y = Object(d.getLogger)(e);

            function E(e) {
                this.conference = e, this.xmppListeners = {}, e.on(l.TRACK_MUTE_CHANGED, t => {
                    if (!t.isLocal() || !e.statistics) return;
                    const n = t.isP2P ? e.p2pJingleSession : e.jvbJingleSession,
                        i = n && n.peerconnection || null;
                    e.statistics.sendMuteEvent(i, t.isMuted(), t.getType())
                })
            }
            E.prototype.setupChatRoomListeners = function() {
                const e = this.conference,
                    t = e.room;
                this.chatRoomForwarder = new c.a(t, this.conference.eventEmitter), t.addListener(S.a.ICE_RESTARTING, t => {
                    t.isP2P || e.rtc.closeBridgeChannel()
                }), t.addListener(S.a.ICE_RESTART_SUCCESS, (t, n) => {
                    !t.isP2P && e._setBridgeChannel(n, t.peerconnection)
                }), t.addListener(S.a.AUDIO_MUTED_BY_FOCUS, t => {
                    _.a.sendAnalytics(Object(r.K)()), e.mutedByFocusActor = t, e.rtc.setAudioMute(!0).then(() => {
                        e.isMutedByFocus = !0, e.mutedByFocusActor = null
                    }).catch(t => {
                        e.mutedByFocusActor = null, y.warn("Error while audio muting due to focus request", t)
                    })
                }), this.chatRoomForwarder.forward(S.a.SUBJECT_CHANGED, l.SUBJECT_CHANGED), this.chatRoomForwarder.forward(S.a.MUC_JOINED, l.CONFERENCE_JOINED), t.addListener(S.a.MUC_JOINED, () => {
                    this.conference.isJvbConnectionInterrupted = !1, Object.keys(t.connectionTimes).forEach(e => {
                        const n = Object(r.C)(`conference_${e}`, {
                            value: t.connectionTimes[e]
                        });
                        _.a.sendAnalytics(n)
                    }), Object.keys(t.xmpp.connectionTimes).forEach(e => {
                        const n = Object(r.C)(`xmpp_${e}`, {
                            value: t.xmpp.connectionTimes[e]
                        });
                        _.a.sendAnalytics(n)
                    })
                }), t.addListener(S.a.RENEGOTIATION_FAILED, (t, n) => {
                    n.isP2P || e.eventEmitter.emit(l.CONFERENCE_FAILED, u.OFFER_ANSWER_FAILED, t)
                }), this.chatRoomForwarder.forward(S.a.ROOM_JOIN_ERROR, l.CONFERENCE_FAILED, u.CONNECTION_ERROR), this.chatRoomForwarder.forward(S.a.ROOM_CONNECT_ERROR, l.CONFERENCE_FAILED, u.CONNECTION_ERROR), this.chatRoomForwarder.forward(S.a.ROOM_CONNECT_NOT_ALLOWED_ERROR, l.CONFERENCE_FAILED, u.NOT_ALLOWED_ERROR), this.chatRoomForwarder.forward(S.a.ROOM_MAX_USERS_ERROR, l.CONFERENCE_FAILED, u.CONFERENCE_MAX_USERS), this.chatRoomForwarder.forward(S.a.PASSWORD_REQUIRED, l.CONFERENCE_FAILED, u.PASSWORD_REQUIRED), this.chatRoomForwarder.forward(S.a.AUTHENTICATION_REQUIRED, l.CONFERENCE_FAILED, u.AUTHENTICATION_REQUIRED), this.chatRoomForwarder.forward(S.a.BRIDGE_DOWN, l.CONFERENCE_FAILED, u.VIDEOBRIDGE_NOT_AVAILABLE), t.addListener(S.a.BRIDGE_DOWN, () => _.a.sendAnalytics(Object(r.z)())), this.chatRoomForwarder.forward(S.a.RESERVATION_ERROR, l.CONFERENCE_FAILED, u.RESERVATION_ERROR), this.chatRoomForwarder.forward(S.a.GRACEFUL_SHUTDOWN, l.CONFERENCE_FAILED, u.GRACEFUL_SHUTDOWN), t.addListener(S.a.CONNECTION_ICE_FAILED, t => {
                    e._onIceConnectionFailed(t)
                }), this.chatRoomForwarder.forward(S.a.MUC_DESTROYED, l.CONFERENCE_FAILED, u.CONFERENCE_DESTROYED), this.chatRoomForwarder.forward(S.a.CHAT_ERROR_RECEIVED, l.CONFERENCE_ERROR, u.CHAT_ERROR), this.chatRoomForwarder.forward(S.a.FOCUS_DISCONNECTED, l.CONFERENCE_FAILED, u.FOCUS_DISCONNECTED), t.addListener(S.a.FOCUS_LEFT, () => {
                    _.a.sendAnalytics(Object(r.E)()), e.eventEmitter.emit(l.CONFERENCE_FAILED, u.FOCUS_LEFT)
                }), t.addListener(S.a.SESSION_ACCEPT_TIMEOUT, e => {
                    _.a.sendAnalyticsAndLog(Object(r.G)(r.b, {
                        p2p: e.isP2P
                    }))
                }), t.addListener(S.a.RECORDER_STATE_CHANGED, (t, n) => {
                    if (n) {
                        const r = e.getParticipantById(i.Strophe.getResourceFromJid(n));
                        "off" === t.getStatus() ? t.setTerminator(r) : "on" === t.getStatus() && t.setInitiator(r)
                    }
                    e.eventEmitter.emit(l.RECORDER_STATE_CHANGED, t)
                }), this.chatRoomForwarder.forward(S.a.TRANSCRIPTION_STATUS_CHANGED, l.TRANSCRIPTION_STATUS_CHANGED), this.chatRoomForwarder.forward(S.a.VIDEO_SIP_GW_AVAILABILITY_CHANGED, l.VIDEO_SIP_GW_AVAILABILITY_CHANGED), this.chatRoomForwarder.forward(S.a.VIDEO_SIP_GW_SESSION_STATE_CHANGED, l.VIDEO_SIP_GW_SESSION_STATE_CHANGED), this.chatRoomForwarder.forward(S.a.PHONE_NUMBER_CHANGED, l.PHONE_NUMBER_CHANGED), t.setParticipantPropertyListener((t, n) => {
                    const i = e.getParticipantById(n);
                    i && i.setProperty(t.tagName.substring("jitsi_participant_".length), t.value)
                }), t.addListener(S.a.KICKED, e.onMemberKicked.bind(e)), t.addListener(S.a.SUSPEND_DETECTED, e.onSuspendDetected.bind(e)), this.chatRoomForwarder.forward(S.a.MUC_LOCK_CHANGED, l.LOCK_STATE_CHANGED), t.addListener(S.a.MUC_MEMBER_JOINED, e.onMemberJoined.bind(e)), t.addListener(S.a.MUC_MEMBER_BOT_TYPE_CHANGED, e._onMemberBotTypeChanged.bind(e)), t.addListener(S.a.MUC_MEMBER_LEFT, e.onMemberLeft.bind(e)), this.chatRoomForwarder.forward(S.a.MUC_LEFT, l.CONFERENCE_LEFT), t.addListener(S.a.DISPLAY_NAME_CHANGED, e.onDisplayNameChanged.bind(e)), t.addListener(S.a.LOCAL_ROLE_CHANGED, t => {
                    e.onLocalRoleChanged(t), e.statistics && e.isModerator() && e.on(l.RECORDER_STATE_CHANGED, e => {
                        const t = {
                            error: e.getError(),
                            id: "recorder_status",
                            status: e.getStatus()
                        };
                        _.a.sendLog(JSON.stringify(t))
                    })
                }), t.addListener(S.a.MUC_ROLE_CHANGED, e.onUserRoleChanged.bind(e)), t.addListener(o.a.IDENTITY_UPDATED, (t, n) => {
                    e.authEnabled = t, e.authIdentity = n, e.eventEmitter.emit(l.AUTH_STATUS_CHANGED, t, n)
                }), t.addListener(S.a.MESSAGE_RECEIVED, (t, n, r, s, o) => {
                    const a = i.Strophe.getResourceFromJid(t);
                    e.eventEmitter.emit(l.MESSAGE_RECEIVED, a, r, o, n)
                }), t.addListener(S.a.PRIVATE_MESSAGE_RECEIVED, (t, n, r, s, o) => {
                    const a = i.Strophe.getResourceFromJid(t);
                    e.eventEmitter.emit(l.PRIVATE_MESSAGE_RECEIVED, a, r, o)
                }), t.addListener(S.a.PRESENCE_STATUS, (t, n) => {
                    const r = i.Strophe.getResourceFromJid(t),
                        s = e.getParticipantById(r);
                    s && s._status !== n && (s._status = n, e.eventEmitter.emit(l.USER_STATUS_CHANGED, r, n))
                }), t.addListener(S.a.JSON_MESSAGE_RECEIVED, (t, n) => {
                    const r = i.Strophe.getResourceFromJid(t),
                        s = e.getParticipantById(r);
                    s ? e.eventEmitter.emit(l.ENDPOINT_MESSAGE_RECEIVED, s, n) : y.warn("Ignored XMPPEvents.JSON_MESSAGE_RECEIVED for not existing " + `participant: ${t}`, n)
                }), t.addPresenceListener("startmuted", (t, n) => {
                    let i = !1;
                    if (e.myUserId() === n && e.isModerator()) i = !0;
                    else {
                        const t = e.getParticipantById(n);
                        t && t.isModerator() && (i = !0)
                    }
                    if (!i) return;
                    const r = "true" === t.attributes.audio,
                        s = "true" === t.attributes.video;
                    let o = !1;
                    r !== e.startMutedPolicy.audio && (e.startMutedPolicy.audio = r, o = !0), s !== e.startMutedPolicy.video && (e.startMutedPolicy.video = s, o = !0), o && e.eventEmitter.emit(l.START_MUTED_POLICY_CHANGED, e.startMutedPolicy)
                }), e.statistics && (t.addListener(S.a.CONNECTION_ICE_FAILED, t => {
                    e.statistics.sendIceConnectionFailedEvent(t.peerconnection)
                }), t.addListener(S.a.ADD_ICE_CANDIDATE_FAILED, (t, n) => {
                    e.statistics.sendAddIceCandidateFailed(t, n)
                }))
            }, E.prototype.setupRTCListeners = function() {
                const e = this.conference,
                    t = e.rtc;
                t.addListener(f.a.REMOTE_TRACK_ADDED, e.onRemoteTrackAdded.bind(e)), t.addListener(f.a.REMOTE_TRACK_REMOVED, e.onRemoteTrackRemoved.bind(e)), t.addListener(f.a.DOMINANT_SPEAKER_CHANGED, t => {
                    e.lastDominantSpeaker !== t && e.room && (e.lastDominantSpeaker = t, e.eventEmitter.emit(l.DOMINANT_SPEAKER_CHANGED, t), e.statistics && e.myUserId() === t && e.statistics.sendDominantSpeakerEvent(e.room.roomjid))
                }), t.addListener(f.a.DATA_CHANNEL_OPEN, () => {
                    const t = window.performance.now(),
                        n = "data.channel.opened";
                    y.log(`(TIME) ${n}:\t`, t), e.room.connectionTimes[n] = t, _.a.sendAnalytics(Object(r.C)(n, {
                        value: t
                    })), e.eventEmitter.emit(l.DATA_CHANNEL_OPENED)
                }), t.addListener(f.a.ENDPOINT_MESSAGE_RECEIVED, (t, n) => {
                    const i = e.getParticipantById(t);
                    i ? e.eventEmitter.emit(l.ENDPOINT_MESSAGE_RECEIVED, i, n) : y.warn("Ignored ENDPOINT_MESSAGE_RECEIVED for not existing " + `participant: ${t}`, n)
                }), t.addListener(f.a.LOCAL_UFRAG_CHANGED, (e, t) => {
                    e.isP2P || _.a.sendLog(JSON.stringify({
                        id: "local_ufrag",
                        value: t
                    }))
                }), t.addListener(f.a.REMOTE_UFRAG_CHANGED, (e, t) => {
                    e.isP2P || _.a.sendLog(JSON.stringify({
                        id: "remote_ufrag",
                        value: t
                    }))
                }), t.addListener(f.a.CREATE_ANSWER_FAILED, (t, n) => {
                    e.statistics.sendCreateAnswerFailed(t, n), n.isP2P || e.eventEmitter.emit(l.CONFERENCE_FAILED, u.OFFER_ANSWER_FAILED, t)
                }), t.addListener(f.a.CREATE_OFFER_FAILED, (t, n) => {
                    e.statistics.sendCreateOfferFailed(t, n), n.isP2P || e.eventEmitter.emit(l.CONFERENCE_FAILED, u.OFFER_ANSWER_FAILED, t)
                }), t.addListener(f.a.SET_LOCAL_DESCRIPTION_FAILED, (t, n) => {
                    e.statistics.sendSetLocalDescFailed(t, n), n.isP2P || e.eventEmitter.emit(l.CONFERENCE_FAILED, u.OFFER_ANSWER_FAILED, t)
                }), t.addListener(f.a.SET_REMOTE_DESCRIPTION_FAILED, (t, n) => {
                    e.statistics.sendSetRemoteDescFailed(t, n), n.isP2P || e.eventEmitter.emit(l.CONFERENCE_FAILED, u.OFFER_ANSWER_FAILED, t)
                }), t.addListener(f.a.LOCAL_TRACK_SSRC_UPDATED, (t, n) => {
                    t.isVideoTrack() && t.videoType === g.a.DESKTOP && e.statistics.sendScreenSharingEvent(!0, n)
                })
            }, E.prototype.removeXMPPListeners = function() {
                const e = this.conference;
                e.xmpp.caps.removeListener(S.a.PARTCIPANT_FEATURES_CHANGED, this.xmppListeners[S.a.PARTCIPANT_FEATURES_CHANGED]), delete this.xmppListeners[S.a.PARTCIPANT_FEATURES_CHANGED], Object.keys(this.xmppListeners).forEach(t => {
                    e.xmpp.removeListener(t, this.xmppListeners[t])
                }), this.xmppListeners = {}
            }, E.prototype.setupXMPPListeners = function() {
                const e = this.conference,
                    t = t => {
                        const n = e.getParticipantById(i.Strophe.getResourceFromJid(t));
                        n && e.eventEmitter.emit(l.PARTCIPANT_FEATURES_CHANGED, n)
                    };
                e.xmpp.caps.addListener(S.a.PARTCIPANT_FEATURES_CHANGED, t), this.xmppListeners[S.a.PARTCIPANT_FEATURES_CHANGED] = t, this._addConferenceXMPPListener(S.a.CALL_INCOMING, e.onIncomingCall.bind(e)), this._addConferenceXMPPListener(S.a.CALL_ACCEPTED, e.onCallAccepted.bind(e)), this._addConferenceXMPPListener(S.a.TRANSPORT_INFO, e.onTransportInfo.bind(e)), this._addConferenceXMPPListener(S.a.CALL_ENDED, e.onCallEnded.bind(e)), this._addConferenceXMPPListener(S.a.START_MUTED_FROM_FOCUS, (t, n) => {
                    e.options.config.ignoreStartMuted || (e.startAudioMuted = t, e.startVideoMuted = n, e.getLocalTracks().forEach(t => {
                        switch (t.getType()) {
                            case h.a:
                                e.startAudioMuted && t.mute();
                                break;
                            case h.c:
                                e.startVideoMuted && t.mute()
                        }
                    }), e.eventEmitter.emit(l.STARTED_MUTED))
                }), this._addConferenceXMPPListener(S.a.CONFERENCE_TIMESTAMP_RECEIVED, t => {
                    e.eventEmitter.emit(l.CONFERENCE_CREATED_TIMESTAMP, t)
                })
            }, E.prototype._addConferenceXMPPListener = function(e, t) {
                this.xmppListeners[e] = t, this.conference.xmpp.addListener(e, t)
            }, E.prototype.setupStatisticsListeners = function() {
                const e = this.conference;
                e.statistics && (e.statistics.addAudioLevelListener((t, n, i, r) => {
                    e.rtc.setAudioLevel(t, n, i, r)
                }), e.statistics.addBeforeDisposedListener(() => {
                    e.eventEmitter.emit(l.BEFORE_STATISTICS_DISPOSED)
                }), e.options.config.startSilent || e.statistics.addByteSentStatsListener((t, n) => {
                    e.getLocalTracks(h.a).forEach(e => {
                        const i = t.getLocalSSRC(e);
                        i && n.hasOwnProperty(i) && e._onByteSentStatsReceived(t, n[i])
                    })
                }))
            }
        }).call(this, "JitsiConferenceEventManager.js")
    }, function(e, t) {
        function n(e, t) {
            if (!e || !t || "function" != typeof e.addListener || "function" != typeof t.emit) throw new Error("Invalid arguments passed to EventEmitterForwarder");
            this.src = e, this.dest = t
        }
        n.prototype.forward = function(...e) {
            const t = e[0];
            e[0] = this.dest, this.src.addListener(t, Function.prototype.bind.apply(this.dest.emit, e))
        }, e.exports = n
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return u
            }));
            var i = n(1),
                r = n(4),
                s = n(2),
                o = n(44),
                a = n(59),
                c = n(9);
            const d = Object(r.getLogger)(e);
            class u {
                constructor(e, t, n, r, s, a, c) {
                    this._jid = e, this._id = i.Strophe.getResourceFromJid(e), this._conference = t, this._displayName = n, this._supportsDTMF = !1, this._tracks = [], this._role = "none", this._status = a, this._hidden = r, this._statsID = s, this._connectionStatus = o.a.ACTIVE, this._properties = {}, this._identity = c
                }
                getConference() {
                    return this._conference
                }
                getProperty(e) {
                    return this._properties[e]
                }
                hasAnyVideoTrackWebRTCMuted() {
                    return this.getTracks().some(e => e.getType() === c.c && e.isWebRTCTrackMuted())
                }
                _setConnectionStatus(e) {
                    this._connectionStatus = e
                }
                getConnectionStatus() {
                    return this._connectionStatus
                }
                setProperty(e, t) {
                    const n = this._properties[e];
                    t !== n && (this._properties[e] = t, this._conference.eventEmitter.emit(s.PARTICIPANT_PROPERTY_CHANGED, this, e, n, t))
                }
                getTracks() {
                    return this._tracks.slice()
                }
                getTracksByMediaType(e) {
                    return this.getTracks().filter(t => t.getType() === e)
                }
                getId() {
                    return this._id
                }
                getJid() {
                    return this._jid
                }
                getDisplayName() {
                    return this._displayName
                }
                getStatsID() {
                    return this._statsID
                }
                getStatus() {
                    return this._status
                }
                isModerator() {
                    return "moderator" === this._role
                }
                isHidden() {
                    return this._hidden
                }
                isAudioMuted() {
                    return this._isMediaTypeMuted(c.a)
                }
                _isMediaTypeMuted(e) {
                    return this.getTracks().reduce((t, n) => t && (n.getType() !== e || n.isMuted()), !0)
                }
                isVideoMuted() {
                    return this._isMediaTypeMuted(c.c)
                }
                getRole() {
                    return this._role
                }
                supportsDTMF() {
                    return this._supportsDTMF
                }
                getFeatures(e = 5e3) {
                    return this._getFeaturesPromise ? this._getFeaturesPromise : (this._getFeaturesPromise = this._conference.xmpp.caps.getFeatures(this._jid, e).catch(t => t === a.a ? this._conference.xmpp.caps.getFeatures(this._jid, e) : (d.warn(`Failed to discover features of ${this._jid}`, t), Promise.reject(t))), this._getFeaturesPromise.then(e => (this._getFeaturesPromise = void 0, e), e => {
                        throw this._getFeaturesPromise = void 0, e
                    }))
                }
                getBotType() {
                    return this._botType
                }
            }
        }).call(this, "JitsiParticipant.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return s
        }));
        var i = n(25),
            r = n(37);

        function s({
            id: e,
            password: t,
            onCreateResource: n,
            onLoginSuccessful: s,
            roomPassword: o
        }) {
            let a, c = !1,
                d = new r.c(this.connection.options);
            const u = new Promise((r, u) => {
                a = u, d.addListener(i.CONNECTION_DISCONNECTED, () => {
                    d = void 0
                }), d.addListener(i.CONNECTION_ESTABLISHED, () => {
                    if (c) return;
                    s && s(), d.createRoom(this.options.name, this.options.config, n).moderator.authenticate().then(() => {
                        d && d.disconnect(), c || (this.join(o), r())
                    }).catch(({
                        error: e,
                        message: t
                    }) => {
                        d.disconnect(), u({
                            authenticationError: e,
                            message: t
                        })
                    })
                }), d.addListener(i.CONNECTION_FAILED, (e, t, n) => {
                    u({
                        connectionError: e,
                        credentials: n,
                        message: t
                    }), d = void 0
                }), c || d.connect(e, t)
            });
            return u.cancel = () => {
                c = !0, a({}), d && d.disconnect()
            }, u
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return u
            }));
            var i = n(4),
                r = n(1),
                s = n(94),
                o = n(36),
                a = n(0),
                c = n.n(a);
            const d = Object(i.getLogger)(e);
            class u extends o.a {
                constructor(e) {
                    super(), this.xmpp = e, this.rooms = {}
                }
                init(e) {
                    super.init(e), this.connection.addHandler(this.onPresence.bind(this), null, "presence", null, null, null, null), this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, "presence", "unavailable", null), this.connection.addHandler(this.onPresenceError.bind(this), null, "presence", "error", null), this.connection.addHandler(this.onMessage.bind(this), null, "message", null, null), this.connection.addHandler(this.onMute.bind(this), "http://jitsi.org/jitmeet/audio", "iq", "set", null, null)
                }
                createRoom(e, t, n) {
                    const i = r.Strophe.getBareJidFromJid(e);
                    if (this.rooms[i]) {
                        const e = "You are already in the room!";
                        throw d.error(e), new Error(e)
                    }
                    return this.rooms[i] = new s.a(this.connection, e, t, this.xmpp, n), this.eventEmitter.emit(c.a.EMUC_ROOM_ADDED, this.rooms[i]), this.rooms[i]
                }
                doLeave(e) {
                    this.eventEmitter.emit(c.a.EMUC_ROOM_REMOVED, this.rooms[e]), delete this.rooms[e]
                }
                onPresence(e) {
                    const t = e.getAttribute("from");
                    if (e.getAttribute("type")) return !0;
                    const n = this.rooms[r.Strophe.getBareJidFromJid(t)];
                    return !n || ($(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="201"]').length && n.createNonAnonymousRoom(), n.onPresence(e), !0)
                }
                onPresenceUnavailable(e) {
                    const t = e.getAttribute("from"),
                        n = this.rooms[r.Strophe.getBareJidFromJid(t)];
                    return !n || (n.onPresenceUnavailable(e, t), !0)
                }
                onPresenceError(e) {
                    const t = e.getAttribute("from"),
                        n = this.rooms[r.Strophe.getBareJidFromJid(t)];
                    return !n || (n.onPresenceError(e, t), !0)
                }
                onMessage(e) {
                    const t = e.getAttribute("from"),
                        n = this.rooms[r.Strophe.getBareJidFromJid(t)];
                    return !n || (n.onMessage(e, t), !0)
                }
                onMute(e) {
                    const t = e.getAttribute("from"),
                        n = this.rooms[r.Strophe.getBareJidFromJid(t)];
                    return !n || (n.onMute(e), !0)
                }
            }
        }).call(this, "modules/xmpp/strophe.emuc.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return _
            }));
            var i = n(4),
                r = n(1),
                s = n(11),
                o = n.n(s),
                a = n(60),
                c = n(24),
                d = n(9),
                u = n(0),
                l = n.n(u),
                h = n(95),
                p = n(40);
            const f = Object(i.getLogger)(e),
                m = {
                    packet2JSON(e, t) {
                        for (const n of Array.from(e.children)) {
                            const e = {
                                attributes: {},
                                children: [],
                                tagName: n.tagName
                            };
                            for (const t of Array.from(n.attributes)) e.attributes[t.name] = t.value;
                            const i = r.Strophe.getText(n);
                            i && (e.value = r.Strophe.xmlunescape(i)), t.push(e), this.packet2JSON(n, e.children)
                        }
                    },
                    json2packet(e, t) {
                        for (let n = 0; n < e.length; n++) {
                            const i = e[n];
                            i && (t.c(i.tagName, i.attributes), i.value && t.t(i.value), i.children && this.json2packet(i.children, t), t.up())
                        }
                    }
                };

            function g(e, t) {
                const n = [];
                for (let i = 0; i < e.length; i++) e[i].tagName === t && n.push(e[i]);
                return n
            }
            class _ extends c.a {
                constructor(e, t, n, i, s) {
                    super(), this.xmpp = i, this.connection = e, this.roomjid = r.Strophe.getBareJidFromJid(t), this.myroomjid = t, this.password = n, f.info(`Joined MUC as ${this.myroomjid}`), this.members = {}, this.presMap = {}, this.presHandlers = {}, this._removeConnListeners = [], this.joined = !1, this.role = null, this.focusMucJid = null, this.noBridgeAvailable = !1, this.options = s || {}, this.moderator = new h.a(this.roomjid, this.xmpp, this.eventEmitter, {
                        connection: this.xmpp.options,
                        conference: this.options
                    }), this.initPresenceMap(s), this.lastPresences = {}, this.phoneNumber = null, this.phonePin = null, this.connectionTimes = {}, this.participantPropertyListener = null, this.locked = !1, this.transcriptionStatus = a.OFF
                }
                initPresenceMap(e = {}) {
                    this.presMap.to = this.myroomjid, this.presMap.xns = "http://jabber.org/protocol/muc", this.presMap.nodes = [], e.statsId && this.presMap.nodes.push({
                        tagName: "stats-id",
                        value: e.statsId
                    }), this.addVideoInfoToPresence(!1), e.deploymentInfo && e.deploymentInfo.userRegion && this.presMap.nodes.push({
                        tagName: "region",
                        attributes: {
                            id: e.deploymentInfo.userRegion,
                            xmlns: "http://jitsi.org/jitsi-meet"
                        }
                    })
                }
                join(e) {
                    return this.password = e, new Promise(e => {
                        this.options.disableFocus && f.info("Conference focus disabled"), (this.options.disableFocus ? Promise.resolve() : this.moderator.allocateConferenceFocus()).then(() => {
                            this.sendPresence(!0), this._removeConnListeners.push(this.connection.addEventListener(p.a.Events.CONN_STATUS_CHANGED, this.onConnStatusChanged.bind(this))), e()
                        })
                    })
                }
                sendPresence(e) {
                    const t = this.presMap.to;
                    if (!this.connection || !this.connection.connected || !t || !this.joined && !e) return;
                    const n = Object(r.$pres)({
                        to: t
                    });
                    e && (n.c("x", {
                        xmlns: this.presMap.xns
                    }), this.password && n.c("password").t(this.password).up(), n.up()), m.json2packet(this.presMap.nodes, n), this.connection.send(n), e && this.connection.flush()
                }
                doLeave() {
                    f.log("do leave", this.myroomjid);
                    const e = Object(r.$pres)({
                        to: this.myroomjid,
                        type: "unavailable"
                    });
                    this.presMap.length = 0, !this.connection.isUsingWebSocket && this.connection.flush(), this.connection.send(e), this.connection.flush()
                }
                discoRoomInfo() {
                    const e = Object(r.$iq)({
                        type: "get",
                        to: this.roomjid
                    }).c("query", {
                        xmlns: r.Strophe.NS.DISCO_INFO
                    });
                    this.connection.sendIQ(e, e => {
                        const t = 1 === $(e).find('>query>feature[var="muc_passwordprotected"]').length;
                        t !== this.locked && (this.eventEmitter.emit(l.a.MUC_LOCK_CHANGED, t), this.locked = t);
                        const n = $(e).find('>query>x[type="result"]>field[var="muc#roominfo_meetingId"]>value');
                        n.length ? this.setMeetingId(n.text()) : f.trace("No meeting ID from backend")
                    }, e => {
                        o.a.callErrorHandler(e), f.error("Error getting room info: ", e)
                    })
                }
                setMeetingId(e) {
                    this.meetingId !== e && (this.meetingId && f.warn(`Meeting Id changed from:${this.meetingId} to:${e}`), this.meetingId = e, this.eventEmitter.emit(l.a.MEETING_ID_SET, e))
                }
                createNonAnonymousRoom() {
                    const e = Object(r.$iq)({
                            type: "get",
                            to: this.roomjid
                        }).c("query", {
                            xmlns: "http://jabber.org/protocol/muc#owner"
                        }).c("x", {
                            xmlns: "jabber:x:data",
                            type: "submit"
                        }),
                        t = this;
                    this.connection.sendIQ(e, e => {
                        if (!$(e).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_whois"]').length) {
                            const e = "non-anonymous rooms not supported";
                            return o.a.callErrorHandler(new Error(e)), void f.error(e)
                        }
                        const n = Object(r.$iq)({
                            to: t.roomjid,
                            type: "set"
                        }).c("query", {
                            xmlns: "http://jabber.org/protocol/muc#owner"
                        });
                        n.c("x", {
                            xmlns: "jabber:x:data",
                            type: "submit"
                        }), n.c("field", {
                            var: "FORM_TYPE"
                        }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), n.c("field", {
                            var: "muc#roomconfig_whois"
                        }).c("value").t("anyone").up().up(), t.connection.sendIQ(n)
                    }, e => {
                        o.a.callErrorHandler(e), f.error("Error getting room configuration form: ", e)
                    })
                }
                onConnStatusChanged(e) {
                    e === p.a.Status.CONNECTED && this.sendPresence()
                }
                onPresence(e) {
                    const t = e.getAttribute("from"),
                        n = {},
                        i = e.getElementsByTagName("status")[0];
                    i && (n.status = i.textContent || "");
                    let s = !1,
                        o = !1;
                    const a = e.getElementsByTagNameNS("http://jabber.org/protocol/muc#user", "x")[0],
                        c = a && a.getElementsByTagName("item")[0];
                    n.affiliation = c && c.getAttribute("affiliation"), n.role = c && c.getAttribute("role");
                    const d = c && c.getAttribute("jid");
                    n.jid = d, n.isFocus = d && 0 === d.indexOf(`${this.moderator.getFocusUserJid()}/`), n.isHiddenDomain = d && d.indexOf("@") > 0 && this.options.hiddenDomain === d.substring(d.indexOf("@") + 1, d.indexOf("/")), this.eventEmitter.emit(l.a.PRESENCE_RECEIVED, {
                        fromHiddenDomain: n.isHiddenDomain,
                        presence: e
                    });
                    const u = e.querySelector("x");
                    u && u.remove();
                    const h = [];
                    m.packet2JSON(e, h), this.lastPresences[t] = h;
                    const p = e => {
                        const t = {},
                            n = e.children.find(e => "user" === e.tagName);
                        if (n) {
                            t.user = {};
                            for (const e of ["id", "name", "avatar"]) {
                                const i = n.children.find(t => t.tagName === e);
                                i && (t.user[e] = i.value)
                            }
                        }
                        const i = e.children.find(e => "group" === e.tagName);
                        return i && (t.group = i.value), t
                    };
                    for (let e = 0; e < h.length; e++) {
                        const t = h[e];
                        switch (t.tagName) {
                            case "bot": {
                                const {
                                    attributes: e
                                } = t;
                                if (!e) break;
                                const {
                                    type: i
                                } = e;
                                n.botType = i;
                                break
                            }
                            case "nick":
                                n.nick = t.value;
                                break;
                            case "userId":
                                n.id = t.value;
                                break;
                            case "stats-id":
                                n.statsID = t.value;
                                break;
                            case "identity":
                                n.identity = p(t);
                                break;
                            case "stat": {
                                const {
                                    attributes: e
                                } = t;
                                if (!e) break;
                                const {
                                    name: i
                                } = e;
                                "version" === i && (n.version = e.value);
                                break
                            }
                        }
                    }
                    if (t === this.myroomjid) {
                        const e = "owner" === n.affiliation ? n.role : "none";
                        if (this.role !== e && (this.role = e, this.eventEmitter.emit(l.a.LOCAL_ROLE_CHANGED, this.role)), !this.joined) {
                            this.joined = !0;
                            const e = this.connectionTimes["muc.joined"] = window.performance.now();
                            f.log("(TIME) MUC joined:\t", e), this.password && (this.locked = !0), this.sendPresence(), this.eventEmitter.emit(l.a.MUC_JOINED), this.discoRoomInfo()
                        }
                    } else if (void 0 === d) f.info("Ignoring member with undefined JID");
                    else if (void 0 === this.members[t]) this.members[t] = n, f.log("entered", t, n), s = void 0 !== n.status, o = void 0 !== n.version, n.isFocus ? this._initFocus(t, d) : (this.eventEmitter.emit(l.a.MUC_MEMBER_JOINED, t, n.nick, n.role, n.isHiddenDomain, n.statsID, n.status, n.identity, n.botType), s = !1);
                    else {
                        const e = this.members[t];
                        e.role !== n.role && (e.role = n.role, this.eventEmitter.emit(l.a.MUC_ROLE_CHANGED, t, n.role)), e.botType !== n.botType && (e.botType = n.botType, this.eventEmitter.emit(l.a.MUC_MEMBER_BOT_TYPE_CHANGED, t, n.botType)), n.isFocus && (e.isFocus = !0, this._initFocus(t, d)), n.displayName && (e.displayName = n.displayName), e.status !== n.status && (s = !0, e.status = n.status), e.version !== n.version && (o = !0, e.version = n.version)
                    }
                    for (let e = 0; e < h.length; e++) {
                        const i = h[e];
                        switch (i.tagName) {
                            case "nick":
                                if (!n.isFocus) {
                                    const e = this.xmpp.options.displayJids ? r.Strophe.getResourceFromJid(t) : n.nick;
                                    this.eventEmitter.emit(l.a.DISPLAY_NAME_CHANGED, t, e)
                                }
                                break;
                            case "bridgeNotAvailable":
                                n.isFocus && !this.noBridgeAvailable && (this.noBridgeAvailable = !0, this.eventEmitter.emit(l.a.BRIDGE_DOWN));
                                break;
                            case "conference-properties":
                                if (n.isFocus) {
                                    const e = {};
                                    for (let t = 0; t < i.children.length; t++) {
                                        const {
                                            attributes: n
                                        } = i.children[t];
                                        n && n.key && (e[n.key] = n.value)
                                    }
                                    this.eventEmitter.emit(l.a.CONFERENCE_PROPERTIES_CHANGED, e)
                                }
                                break;
                            case "transcription-status": {
                                const {
                                    attributes: e
                                } = i;
                                if (!e) break;
                                const {
                                    status: t
                                } = e;
                                t && t !== this.transcriptionStatus && (this.transcriptionStatus = t, this.eventEmitter.emit(l.a.TRANSCRIPTION_STATUS_CHANGED, t));
                                break
                            }
                            case "call-control": {
                                const e = i.attributes;
                                if (!e) break;
                                this.phoneNumber = e.phone || null, this.phonePin = e.pin || null, this.eventEmitter.emit(l.a.PHONE_NUMBER_CHANGED);
                                break
                            }
                            default:
                                this.processNode(i, t)
                        }
                    }
                    s && this.eventEmitter.emit(l.a.PRESENCE_STATUS, t, n.status), o && f.info(`Received version for ${d}: ${n.version}`)
                }
                _initFocus(e, t) {
                    this.focusMucJid = e, f.info(`Ignore focus: ${e}, real JID: ${t}`)
                }
                setParticipantPropertyListener(e) {
                    this.participantPropertyListener = e
                }
                processNode(e, t) {
                    try {
                        let n = this.presHandlers[e.tagName];
                        e.tagName.startsWith("jitsi_participant_") && (n = [this.participantPropertyListener]), n && n.forEach(n => {
                            n(e, r.Strophe.getResourceFromJid(t), t)
                        })
                    } catch (t) {
                        o.a.callErrorHandler(t), f.error(`Error processing:${e.tagName} node.`, t)
                    }
                }
                sendMessage(e, t, n) {
                    const i = Object(r.$msg)({
                        to: this.roomjid,
                        type: "groupchat"
                    });
                    "body" === t ? i.c(t, e).up() : i.c(t, {
                        xmlns: "http://jitsi.org/jitmeet"
                    }, e).up(), n && i.c("nick", {
                        xmlns: "http://jabber.org/protocol/nick"
                    }).t(n).up().up(), this.connection.send(i), this.eventEmitter.emit(l.a.SENDING_CHAT_MESSAGE, e)
                }
                sendPrivateMessage(e, t, n, i) {
                    const s = Object(r.$msg)({
                        to: `${this.roomjid}/${e}`,
                        type: "chat"
                    });
                    "body" === n ? s.c(n, t).up() : s.c(n, {
                        xmlns: "http://jitsi.org/jitmeet"
                    }, t).up(), i && s.c("nick", {
                        xmlns: "http://jabber.org/protocol/nick"
                    }).t(i).up().up(), this.connection.send(s), this.eventEmitter.emit(l.a.SENDING_PRIVATE_CHAT_MESSAGE, t)
                }
                setSubject(e) {
                    const t = Object(r.$msg)({
                        to: this.roomjid,
                        type: "groupchat"
                    });
                    t.c("subject", e), this.connection.send(t)
                }
                onParticipantLeft(e, t) {
                    delete this.lastPresences[e], t || (this.eventEmitter.emit(l.a.MUC_MEMBER_LEFT, e), this.moderator.onMucMemberLeft(e))
                }
                onPresenceUnavailable(e, t) {
                    if ($(e).find('>ignore[xmlns="http://jitsi.org/jitmeet/"]').length) return !0;
                    if ($(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy').length) {
                        let t;
                        const n = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy>reason');
                        return n.length && (t = n.text()), this.eventEmitter.emit(l.a.MUC_DESTROYED, t), this.connection.emuc.doLeave(this.roomjid), !0
                    }
                    const n = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="110"]').length,
                        i = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="307"]').length,
                        s = Object.keys(this.members);
                    if (i) {
                        const i = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>actor');
                        let o;
                        i.length && (o = i.attr("nick")), s.find(e => r.Strophe.getResourceFromJid(e) === o) && this.eventEmitter.emit(l.a.KICKED, n, o, r.Strophe.getResourceFromJid(t))
                    }
                    n ? s.length > 0 && (s.forEach(e => {
                        const t = this.members[e];
                        delete this.members[e], this.onParticipantLeft(e, t.isFocus)
                    }), this.connection.emuc.doLeave(this.roomjid), i || this.eventEmitter.emit(l.a.MUC_LEFT)) : (delete this.members[t], this.onParticipantLeft(t, !1))
                }
                onMessage(e, t) {
                    const n = $(e).find('>nick[xmlns="http://jabber.org/protocol/nick"]').text() || r.Strophe.getResourceFromJid(t),
                        i = e.getAttribute("type");
                    if ("error" === i) {
                        const t = $(e).find(">error>text").text();
                        return this.eventEmitter.emit(l.a.CHAT_ERROR_RECEIVED, t), !0
                    }
                    const s = $(e).find(">body").text(),
                        o = $(e).find(">subject");
                    if (o.length) {
                        const e = o.text();
                        (e || "" === e) && (this.eventEmitter.emit(l.a.SUBJECT_CHANGED, e), f.log(`Subject is changed to ${e}`))
                    }
                    let a = $(e).find(">delay").attr("stamp");
                    if (!a && (a = $(e).find('>[xmlns="jabber:x:delay"]').attr("stamp"))) {
                        const e = a.match(/(\d{4})(\d{2})(\d{2}T\d{2}:\d{2}:\d{2})/);
                        a = `${e[1]}-${e[2]}-${e[3]}Z`
                    }
                    t === this.roomjid && $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="104"]').length && this.discoRoomInfo();
                    const c = $(e).find(">json-message").text(),
                        d = this.xmpp.tryParseJSONAndVerify(c);
                    d && void 0 === a ? this.eventEmitter.emit(l.a.JSON_MESSAGE_RECEIVED, t, d) : s && ("chat" === i ? this.eventEmitter.emit(l.a.PRIVATE_MESSAGE_RECEIVED, t, n, s, this.myroomjid, a) : "groupchat" === i && this.eventEmitter.emit(l.a.MESSAGE_RECEIVED, t, n, s, this.myroomjid, a))
                }
                onPresenceError(e, t) {
                    if ($(e).find('>error[type="auth"]>not-authorized[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) f.log("on password required", t), this.eventEmitter.emit(l.a.PASSWORD_REQUIRED);
                    else if ($(e).find('>error[type="cancel"]>not-allowed[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
                        r.Strophe.getDomainFromJid(e.getAttribute("to")) === this.xmpp.options.hosts.anonymousdomain ? this.eventEmitter.emit(l.a.ROOM_JOIN_ERROR) : (f.warn("onPresError ", e), this.eventEmitter.emit(l.a.ROOM_CONNECT_NOT_ALLOWED_ERROR))
                    } else $(e).find(">error>service-unavailable").length ? (f.warn("Maximum users limit for the room has been reached", e), this.eventEmitter.emit(l.a.ROOM_MAX_USERS_ERROR)) : (f.warn("onPresError ", e), this.eventEmitter.emit(l.a.ROOM_CONNECT_ERROR))
                }
                kick(e) {
                    const t = Object(r.$iq)({
                        to: this.roomjid,
                        type: "set"
                    }).c("query", {
                        xmlns: "http://jabber.org/protocol/muc#admin"
                    }).c("item", {
                        nick: r.Strophe.getResourceFromJid(e),
                        role: "none"
                    }).c("reason").t("You have been kicked.").up().up().up();
                    this.connection.sendIQ(t, t => f.log("Kick participant with jid: ", e, t), e => f.log("Kick participant error: ", e))
                }
                lockRoom(e, t, n, i) {
                    this.connection.sendIQ(Object(r.$iq)({
                        to: this.roomjid,
                        type: "get"
                    }).c("query", {
                        xmlns: "http://jabber.org/protocol/muc#owner"
                    }), s => {
                        if ($(s).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_roomsecret"]').length) {
                            const i = Object(r.$iq)({
                                to: this.roomjid,
                                type: "set"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#owner"
                            });
                            i.c("x", {
                                xmlns: "jabber:x:data",
                                type: "submit"
                            }), i.c("field", {
                                var: "FORM_TYPE"
                            }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), i.c("field", {
                                var: "muc#roomconfig_roomsecret"
                            }).c("value").t(e).up().up(), i.c("field", {
                                var: "muc#roomconfig_passwordprotectedroom"
                            }).c("value").t(null === e || 0 === e.length ? "0" : "1").up().up(), i.c("field", {
                                var: "muc#roomconfig_whois"
                            }).c("value").t("anyone").up().up(), this.connection.sendIQ(i, t, n)
                        } else i()
                    }, n)
                }
                addToPresence(e, t) {
                    t.tagName = e, this.removeFromPresence(e), this.presMap.nodes.push(t)
                }
                getFromPresence(e) {
                    return this.presMap.nodes.find(t => e === t.tagName)
                }
                removeFromPresence(e) {
                    const t = this.presMap.nodes.filter(t => e !== t.tagName);
                    this.presMap.nodes = t
                }
                addPresenceListener(e, t) {
                    if ("function" != typeof t) throw new Error('"handler" is not a function');
                    let n = this.presHandlers[e];
                    n || (this.presHandlers[e] = n = []), -1 === n.indexOf(t) ? n.push(t) : f.warn(`Trying to add the same handler more than once for: ${e}`)
                }
                removePresenceListener(e, t) {
                    const n = this.presHandlers[e],
                        i = n ? n.indexOf(t) : -1; - 1 !== i ? n.splice(i, 1) : f.warn(`Handler for: ${e} was not registered`)
                }
                isFocus(e) {
                    const t = this.members[e];
                    return t ? t.isFocus : null
                }
                isModerator() {
                    return "moderator" === this.role
                }
                getMemberRole(e) {
                    return this.members[e] ? this.members[e].role : null
                }
                setVideoMute(e, t) {
                    this.sendVideoInfoPresence(e), t && t(e)
                }
                setAudioMute(e, t) {
                    return this.sendAudioInfoPresence(e, t)
                }
                addAudioInfoToPresence(e) {
                    this.removeFromPresence("audiomuted"), this.addToPresence("audiomuted", {
                        attributes: {
                            xmlns: "http://jitsi.org/jitmeet/audio"
                        },
                        value: e.toString()
                    })
                }
                sendAudioInfoPresence(e, t) {
                    this.addAudioInfoToPresence(e), this.sendPresence(), t && t()
                }
                addVideoInfoToPresence(e) {
                    this.removeFromPresence("videomuted"), this.addToPresence("videomuted", {
                        attributes: {
                            xmlns: "http://jitsi.org/jitmeet/video"
                        },
                        value: e.toString()
                    })
                }
                sendVideoInfoPresence(e) {
                    this.addVideoInfoToPresence(e), this.sendPresence()
                }
                getMediaPresenceInfo(e, t) {
                    const n = this.lastPresences[`${this.roomjid}/${e}`];
                    if (!n) return null;
                    const i = {
                        muted: !1,
                        videoType: void 0
                    };
                    let r = null;
                    if (t === d.a) r = g(n, "audiomuted");
                    else {
                        if (t !== d.c) return f.error(`Unsupported media type: ${t}`), null; {
                            r = g(n, "videomuted");
                            const e = g(n, "videoType");
                            e.length > 0 && (i.videoType = e[0].value)
                        }
                    }
                    return i.muted = r.length > 0 && "true" === r[0].value, i
                }
                isSIPCallingSupported() {
                    return !!this.moderator && this.moderator.isSipGatewayEnabled()
                }
                dial(e) {
                    return this.connection.rayo.dial(e, "fromnumber", r.Strophe.getBareJidFromJid(this.myroomjid), this.password, this.focusMucJid)
                }
                hangup() {
                    return this.connection.rayo.hangup()
                }
                getPhoneNumber() {
                    return this.phoneNumber
                }
                getPhonePin() {
                    return this.phonePin
                }
                getMeetingId() {
                    return this.meetingId
                }
                muteParticipant(e, t) {
                    f.info("set mute", t);
                    const n = Object(r.$iq)({
                        to: this.focusMucJid,
                        type: "set"
                    }).c("mute", {
                        xmlns: "http://jitsi.org/jitmeet/audio",
                        jid: e
                    }).t(t.toString()).up();
                    this.connection.sendIQ(n, e => f.log("set mute", e), e => f.log("set mute error", e))
                }
                onMute(e) {
                    if (e.getAttribute("from") !== this.focusMucJid) return void f.warn("Ignored mute from non focus peer");
                    const t = $(e).find("mute");
                    t.length && "true" === t.text() ? this.eventEmitter.emit(l.a.AUDIO_MUTED_BY_FOCUS, t.attr("actor")) : f.warn("Ignoring a mute request which does not explicitly specify a positive mute command.")
                }
                leave() {
                    return new Promise((e, t) => {
                        const n = setTimeout(() => r(!0), 5e3),
                            i = this.eventEmitter;

                        function r(s = !1) {
                            i.removeListener(l.a.MUC_LEFT, r), clearTimeout(n), s ? t(new Error("The timeout for the confirmation about leaving the room expired.")) : e()
                        }
                        this._removeConnListeners.forEach(e => e()), this._removeConnListeners = [], i.on(l.a.MUC_LEFT, r), this.doLeave()
                    })
                }
            }
        }).call(this, "modules/xmpp/ChatRoom.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return u
            }));
            var i = n(1),
                r = n(34);
            const s = n(4).getLogger(e),
                o = n(0),
                a = n(63),
                c = n(11);

            function d(e) {
                let t = 1;
                return function(n) {
                    if (n) return void(t = 1);
                    const i = Math.pow(2, t - 1);
                    return t += 1, i * e
                }
            }

            function u(e, t, n, i) {
                function o(e) {
                    if (e.data && e.data.sessionId) {
                        if (e.origin !== window.location.origin) return void s.warn(`Ignoring sessionId from different origin: ${e.origin}`);
                        r.a.sessionId = e.data.sessionId
                    }
                }
                this.roomName = e, this.xmppService = t, this.getNextTimeout = d(1e3), this.getNextErrorTimeout = d(1e3), this.externalAuthEnabled = !1, this.options = i, this.sipGatewayEnabled = this.options.connection.hosts && void 0 !== this.options.connection.hosts.call_control, this.eventEmitter = n, this.connection = this.xmppService.connection, window.addEventListener ? window.addEventListener("message", o, !1) : window.attachEvent("onmessage", o)
            }
            u.prototype.isExternalAuthEnabled = function() {
                return this.externalAuthEnabled
            }, u.prototype.isSipGatewayEnabled = function() {
                return this.sipGatewayEnabled
            }, u.prototype.onMucMemberLeft = function(e) {
                s.info(`Someone left is it focus ? ${e}`), "focus" === i.Strophe.getResourceFromJid(e) && (s.info("Focus has left the room - leaving conference"), this.eventEmitter.emit(o.FOCUS_LEFT))
            }, u.prototype.setFocusUserJid = function(e) {
                this.focusUserJid || (this.focusUserJid = e, s.info(`Focus jid set to:  ${this.focusUserJid}`))
            }, u.prototype.getFocusUserJid = function() {
                return this.focusUserJid
            }, u.prototype.getFocusComponent = function() {
                let e = this.options.connection.hosts.focus;
                return e || (e = `focus.${this.options.connection.hosts.domain}`), e
            }, u.prototype.createConferenceIq = function() {
                const e = Object(i.$iq)({
                        to: this.getFocusComponent(),
                        type: "set"
                    }),
                    {
                        sessionId: t
                    } = r.a,
                    n = r.a.machineId,
                    o = this.options.conference;
                let a;
                switch (s.info(`Session ID: ${t} machine UID: ${n}`), e.c("conference", {
                    xmlns: "http://jitsi.org/protocol/focus",
                    room: this.roomName,
                    "machine-uid": n
                }), t && e.attrs({
                    "session-id": t
                }), void 0 !== this.options.connection.enforcedBridge && e.c("property", {
                    name: "enforcedBridge",
                    value: this.options.connection.enforcedBridge
                }).up(), void 0 !== this.options.connection.hosts && void 0 !== this.options.connection.hosts.call_control && e.c("property", {
                    name: "call_control",
                    value: this.options.connection.hosts.call_control
                }).up(), void 0 !== o.channelLastN && e.c("property", {
                    name: "channelLastN",
                    value: o.channelLastN
                }).up(), e.c("property", {
                    name: "disableRtx",
                    value: Boolean(o.disableRtx)
                }).up(), void 0 !== o.enableTcc && e.c("property", {
                    name: "enableTcc",
                    value: Boolean(o.enableTcc)
                }).up(), void 0 !== o.enableRemb && e.c("property", {
                    name: "enableRemb",
                    value: Boolean(o.enableRemb)
                }).up(), void 0 !== o.minParticipants && e.c("property", {
                    name: "minParticipants",
                    value: o.minParticipants
                }).up(), e.c("property", {
                    name: "enableLipSync",
                    value: !0 === this.options.connection.enableLipSync
                }).up(), void 0 !== o.audioPacketDelay && e.c("property", {
                    name: "audioPacketDelay",
                    value: o.audioPacketDelay
                }).up(), o.startBitrate && e.c("property", {
                    name: "startBitrate",
                    value: o.startBitrate
                }).up(), o.minBitrate && e.c("property", {
                    name: "minBitrate",
                    value: o.minBitrate
                }).up(), o.testing && o.testing.octo && "number" == typeof o.testing.octo.probability && Math.random() < o.testing.octo.probability && e.c("property", {
                    name: "octo",
                    value: !0
                }).up(), this.options.conference.openBridgeChannel) {
                    case "datachannel":
                    case !0:
                    case void 0:
                        a = !0;
                        break;
                    case "websocket":
                        a = !1
                }
                return e.c("property", {
                    name: "openSctp",
                    value: a
                }).up(), void 0 !== this.options.conference.startAudioMuted && e.c("property", {
                    name: "startAudioMuted",
                    value: this.options.conference.startAudioMuted
                }).up(), void 0 !== this.options.conference.startVideoMuted && e.c("property", {
                    name: "startVideoMuted",
                    value: this.options.conference.startVideoMuted
                }).up(), void 0 !== this.options.conference.stereo && e.c("property", {
                    name: "stereo",
                    value: this.options.conference.stereo
                }).up(), void 0 !== this.options.conference.useRoomAsSharedDocumentName && e.c("property", {
                    name: "useRoomAsSharedDocumentName",
                    value: this.options.conference.useRoomAsSharedDocumentName
                }).up(), e.up(), e
            }, u.prototype.parseSessionId = function(e) {
                const t = $(e).find("conference").attr("session-id");
                t && (s.info(`Received sessionId:  ${t}`), r.a.sessionId = t)
            }, u.prototype.parseConfigOptions = function(e) {
                this.setFocusUserJid($(e).find("conference").attr("focusjid"));
                const t = $(e).find(">conference>property[name='authentication'][value='true']").length > 0;
                s.info(`Authentication enabled: ${t}`), this.externalAuthEnabled = $(e).find(">conference>property[name='externalAuth'][value='true']").length > 0, s.info(`External authentication enabled: ${this.externalAuthEnabled}`), this.externalAuthEnabled || this.parseSessionId(e);
                const n = $(e).find(">conference").attr("identity");
                this.eventEmitter.emit(a.IDENTITY_UPDATED, t, n), $(e).find(">conference>property[name='sipGatewayEnabled'][value='true']").length && (this.sipGatewayEnabled = !0), s.info(`Sip gateway enabled:  ${this.sipGatewayEnabled}`)
            }, u.prototype.allocateConferenceFocus = function() {
                return new Promise(e => {
                    this.setFocusUserJid(this.options.connection.focusUserJid), this.connection.sendIQ(this.createConferenceIq(), t => this._allocateConferenceFocusSuccess(t, e), t => this._allocateConferenceFocusError(t, e)), this.connection.flush()
                })
            }, u.prototype._allocateConferenceFocusError = function(e, t) {
                const n = $(e).find(">error>session-invalid").length || $(e).find(">error>not-acceptable").length;
                if (n && (s.info("Session expired! - removing"), r.a.sessionId = void 0), $(e).find(">error>graceful-shutdown").length) return void this.eventEmitter.emit(o.GRACEFUL_SHUTDOWN);
                const a = $(e).find(">error>reservation-error");
                if (a.length) {
                    const t = a.attr("error-code"),
                        n = $(e).find(">error>text");
                    let i;
                    return n && (i = n.text()), void this.eventEmitter.emit(o.RESERVATION_ERROR, t, i)
                }
                if ($(e).find(">error>not-authorized").length) {
                    return s.warn("Unauthorized to start the conference", e), i.Strophe.getDomainFromJid(e.getAttribute("to")) !== this.options.connection.hosts.anonymousdomain && (this.externalAuthEnabled = !0), void this.eventEmitter.emit(o.AUTHENTICATION_REQUIRED)
                }
                const d = this.getNextErrorTimeout(),
                    u = `Focus error, retry after ${d}`;
                c.callErrorHandler(new Error(u)), s.error(u, e);
                const l = this.getFocusComponent(),
                    h = d / 1e3;
                n || this.eventEmitter.emit(o.FOCUS_DISCONNECTED, l, h), this.getNextTimeout(!0), window.setTimeout(() => this.allocateConferenceFocus().then(t), d)
            }, u.prototype._allocateConferenceFocusSuccess = function(e, t) {
                if (this.parseConfigOptions(e), this.getNextErrorTimeout(!0), "true" === $(e).find("conference").attr("ready")) this.getNextTimeout(!0), t();
                else {
                    const e = this.getNextTimeout();
                    s.info(`Waiting for the focus... ${e}`), window.setTimeout(() => this.allocateConferenceFocus().then(t), e)
                }
            }, u.prototype.authenticate = function() {
                return new Promise((e, t) => {
                    this.connection.sendIQ(this.createConferenceIq(), t => {
                        this.parseSessionId(t), e()
                    }, e => t({
                        error: $(e).find("iq>error :first").prop("tagName"),
                        message: $(e).find("iq>error>text").text()
                    }))
                })
            }, u.prototype.getLoginUrl = function(e, t) {
                this._getLoginUrl(!1, e, t)
            }, u.prototype._getLoginUrl = function(e, t, n) {
                const o = Object(i.$iq)({
                        to: this.getFocusComponent(),
                        type: "get"
                    }),
                    a = {
                        xmlns: "http://jitsi.org/protocol/focus",
                        room: this.roomName,
                        "machine-uid": r.a.machineId
                    };
                let d = "auth url";

                function u(e, t) {
                    c.callErrorHandler(new Error(e)), s.error(e, t), n(t)
                }
                e && (a.popup = !0, d = `POPUP ${d}`), o.c("login-url", a), this.connection.sendIQ(o, e => {
                    let n = $(e).find("login-url").attr("url");
                    (n = decodeURIComponent(n)) ? (s.info(`Got ${d}: ${n}`), t(n)) : u(`Failed to get ${d} from the focus`, e)
                }, u.bind(void 0, `Get ${d} error`))
            }, u.prototype.getPopupLoginUrl = function(e, t) {
                this._getLoginUrl(!0, e, t)
            }, u.prototype.logout = function(e) {
                const t = Object(i.$iq)({
                        to: this.getFocusComponent(),
                        type: "set"
                    }),
                    {
                        sessionId: n
                    } = r.a;
                n ? (t.c("logout", {
                    xmlns: "http://jitsi.org/protocol/focus",
                    "session-id": n
                }), this.connection.sendIQ(t, t => {
                    let n = $(t).find("logout").attr("logout-url");
                    n && (n = decodeURIComponent(n)), s.info(`Log out OK, url: ${n}`, t), r.a.sessionId = void 0, e(n)
                }, e => {
                    c.callErrorHandler(new Error("Logout error")), s.error("Logout error", e)
                })) : e()
            }
        }).call(this, "modules/xmpp/moderator.js")
    }, function(e, t, n) {
        const i = n(35),
            r = ["Aaliyah", "Aaron", "Abagail", "Abbey", "Abbie", "Abbigail", "Abby", "Abdiel", "Abdul", "Abdullah", "Abe", "Abel", "Abelardo", "Abigail", "Abigale", "Abigayle", "Abner", "Abraham", "Ada", "Adah", "Adalberto", "Adaline", "Adam", "Adan", "Addie", "Addison", "Adela", "Adelbert", "Adele", "Adelia", "Adeline", "Adell", "Adella", "Adelle", "Aditya", "Adolf", "Adolfo", "Adolph", "Adolphus", "Adonis", "Adrain", "Adrian", "Adriana", "Adrianna", "Adriel", "Adrien", "Adrienne", "Afton", "Aglae", "Agnes", "Agustin", "Agustina", "Ahmad", "Ahmed", "Aida", "Aidan", "Aiden", "Aileen", "Aisha", "Aiyana", "Akeem", "Al", "Alaina", "Alan", "Alana", "Alanis", "Alanna", "Alayna", "Alba", "Albert", "Alberta", "Albertha", "Alberto", "Albin", "Albina", "Alda", "Alden", "Alec", "Aleen", "Alejandra", "Alejandrin", "Alek", "Alena", "Alene", "Alessandra", "Alessandro", "Alessia", "Aletha", "Alex", "Alexa", "Alexander", "Alexandra", "Alexandre", "Alexandrea", "Alexandria", "Alexandrine", "Alexandro", "Alexane", "Alexanne", "Alexie", "Alexis", "Alexys", "Alexzander", "Alf", "Alfonso", "Alfonzo", "Alford", "Alfred", "Alfreda", "Alfredo", "Ali", "Alia", "Alice", "Alicia", "Alisa", "Alisha", "Alison", "Alivia", "Aliya", "Aliyah", "Aliza", "Alize", "Allan", "Allen", "Allene", "Allie", "Allison", "Ally", "Alphonso", "Alta", "Althea", "Alva", "Alvah", "Alvena", "Alvera", "Alverta", "Alvina", "Alvis", "Alyce", "Alycia", "Alysa", "Alysha", "Alyson", "Alysson", "Amalia", "Amanda", "Amani", "Amara", "Amari", "Amaya", "Amber", "Ambrose", "Amelia", "Amelie", "Amely", "America", "Americo", "Amie", "Amina", "Amir", "Amira", "Amiya", "Amos", "Amparo", "Amy", "Amya", "Ana", "Anabel", "Anabelle", "Anahi", "Anais", "Anastacio", "Anastasia", "Anderson", "Andre", "Andreane", "Andreanne", "Andres", "Andrew", "Andy", "Angel", "Angela", "Angelica", "Angelina", "Angeline", "Angelita", "Angelo", "Angie", "Angus", "Anibal", "Anika", "Anissa", "Anita", "Aniya", "Aniyah", "Anjali", "Anna", "Annabel", "Annabell", "Annabelle", "Annalise", "Annamae", "Annamarie", "Anne", "Annetta", "Annette", "Annie", "Ansel", "Ansley", "Anthony", "Antoinette", "Antone", "Antonetta", "Antonette", "Antonia", "Antonietta", "Antonina", "Antonio", "Antwan", "Antwon", "Anya", "April", "Ara", "Araceli", "Aracely", "Arch", "Archibald", "Ardella", "Arden", "Ardith", "Arely", "Ari", "Ariane", "Arianna", "Aric", "Ariel", "Arielle", "Arjun", "Arlene", "Arlie", "Arlo", "Armand", "Armando", "Armani", "Arnaldo", "Arne", "Arno", "Arnold", "Arnoldo", "Arnulfo", "Aron", "Art", "Arthur", "Arturo", "Arvel", "Arvid", "Arvilla", "Aryanna", "Asa", "Asha", "Ashlee", "Ashleigh", "Ashley", "Ashly", "Ashlynn", "Ashton", "Ashtyn", "Asia", "Assunta", "Astrid", "Athena", "Aubree", "Aubrey", "Audie", "Audra", "Audreanne", "Audrey", "August", "Augusta", "Augustine", "Augustus", "Aurelia", "Aurelie", "Aurelio", "Aurore", "Austen", "Austin", "Austyn", "Autumn", "Ava", "Avery", "Avis", "Axel", "Ayana", "Ayden", "Ayla", "Aylin", "Baby", "Bailee", "Bailey", "Barbara", "Barney", "Baron", "Barrett", "Barry", "Bart", "Bartholome", "Barton", "Baylee", "Beatrice", "Beau", "Beaulah", "Bell", "Bella", "Belle", "Ben", "Benedict", "Benjamin", "Bennett", "Bennie", "Benny", "Benton", "Berenice", "Bernadette", "Bernadine", "Bernard", "Bernardo", "Berneice", "Bernhard", "Bernice", "Bernie", "Berniece", "Bernita", "Berry", "Bert", "Berta", "Bertha", "Bertram", "Bertrand", "Beryl", "Bessie", "Beth", "Bethany", "Bethel", "Betsy", "Bette", "Bettie", "Betty", "Bettye", "Beulah", "Beverly", "Bianka", "Bill", "Billie", "Billy", "Birdie", "Blair", "Blaise", "Blake", "Blanca", "Blanche", "Blaze", "Bo", "Bobbie", "Bobby", "Bonita", "Bonnie", "Boris", "Boyd", "Brad", "Braden", "Bradford", "Bradley", "Bradly", "Brady", "Braeden", "Brain", "Brandi", "Brando", "Brandon", "Brandt", "Brandy", "Brandyn", "Brannon", "Branson", "Brant", "Braulio", "Braxton", "Brayan", "Breana", "Breanna", "Breanne", "Brenda", "Brendan", "Brenden", "Brendon", "Brenna", "Brennan", "Brennon", "Brent", "Bret", "Brett", "Bria", "Brian", "Briana", "Brianne", "Brice", "Bridget", "Bridgette", "Bridie", "Brielle", "Brigitte", "Brionna", "Brisa", "Britney", "Brittany", "Brock", "Broderick", "Brody", "Brook", "Brooke", "Brooklyn", "Brooks", "Brown", "Bruce", "Bryana", "Bryce", "Brycen", "Bryon", "Buck", "Bud", "Buddy", "Buford", "Bulah", "Burdette", "Burley", "Burnice", "Buster", "Cade", "Caden", "Caesar", "Caitlyn", "Cale", "Caleb", "Caleigh", "Cali", "Calista", "Callie", "Camden", "Cameron", "Camila", "Camilla", "Camille", "Camren", "Camron", "Camryn", "Camylle", "Candace", "Candelario", "Candice", "Candida", "Candido", "Cara", "Carey", "Carissa", "Carlee", "Carleton", "Carley", "Carli", "Carlie", "Carlo", "Carlos", "Carlotta", "Carmel", "Carmela", "Carmella", "Carmelo", "Carmen", "Carmine", "Carol", "Carolanne", "Carole", "Carolina", "Caroline", "Carolyn", "Carolyne", "Carrie", "Carroll", "Carson", "Carter", "Cary", "Casandra", "Casey", "Casimer", "Casimir", "Casper", "Cassandra", "Cassandre", "Cassidy", "Cassie", "Catalina", "Caterina", "Catharine", "Catherine", "Cathrine", "Cathryn", "Cathy", "Cayla", "Ceasar", "Cecelia", "Cecil", "Cecile", "Cecilia", "Cedrick", "Celestine", "Celestino", "Celia", "Celine", "Cesar", "Chad", "Chadd", "Chadrick", "Chaim", "Chance", "Chandler", "Chanel", "Chanelle", "Charity", "Charlene", "Charles", "Charley", "Charlie", "Charlotte", "Chase", "Chasity", "Chauncey", "Chaya", "Chaz", "Chelsea", "Chelsey", "Chelsie", "Chesley", "Chester", "Chet", "Cheyanne", "Cheyenne", "Chloe", "Chris", "Christ", "Christa", "Christelle", "Christian", "Christiana", "Christina", "Christine", "Christop", "Christophe", "Christopher", "Christy", "Chyna", "Ciara", "Cicero", "Cielo", "Cierra", "Cindy", "Citlalli", "Clair", "Claire", "Clara", "Clarabelle", "Clare", "Clarissa", "Clark", "Claud", "Claude", "Claudia", "Claudie", "Claudine", "Clay", "Clemens", "Clement", "Clementina", "Clementine", "Clemmie", "Cleo", "Cleora", "Cleta", "Cletus", "Cleve", "Cleveland", "Clifford", "Clifton", "Clint", "Clinton", "Clotilde", "Clovis", "Cloyd", "Clyde", "Coby", "Cody", "Colby", "Cole", "Coleman", "Colin", "Colleen", "Collin", "Colt", "Colten", "Colton", "Columbus", "Concepcion", "Conner", "Connie", "Connor", "Conor", "Conrad", "Constance", "Constantin", "Consuelo", "Cooper", "Cora", "Coralie", "Corbin", "Cordelia", "Cordell", "Cordia", "Cordie", "Corene", "Corine", "Cornelius", "Cornell", "Corrine", "Cortez", "Cortney", "Cory", "Coty", "Courtney", "Coy", "Craig", "Crawford", "Creola", "Cristal", "Cristian", "Cristina", "Cristobal", "Cristopher", "Cruz", "Crystal", "Crystel", "Cullen", "Curt", "Curtis", "Cydney", "Cynthia", "Cyril", "Cyrus", "Dagmar", "Dahlia", "Daija", "Daisha", "Daisy", "Dakota", "Dale", "Dallas", "Dallin", "Dalton", "Damaris", "Dameon", "Damian", "Damien", "Damion", "Damon", "Dan", "Dana", "Dandre", "Dane", "D'angelo", "Dangelo", "Danial", "Daniela", "Daniella", "Danielle", "Danika", "Dannie", "Danny", "Dante", "Danyka", "Daphne", "Daphnee", "Daphney", "Darby", "Daren", "Darian", "Dariana", "Darien", "Dario", "Darion", "Darius", "Darlene", "Daron", "Darrel", "Darrell", "Darren", "Darrick", "Darrin", "Darrion", "Darron", "Darryl", "Darwin", "Daryl", "Dashawn", "Dasia", "Dave", "David", "Davin", "Davion", "Davon", "Davonte", "Dawn", "Dawson", "Dax", "Dayana", "Dayna", "Dayne", "Dayton", "Dean", "Deangelo", "Deanna", "Deborah", "Declan", "Dedric", "Dedrick", "Dee", "Deion", "Deja", "Dejah", "Dejon", "Dejuan", "Delaney", "Delbert", "Delfina", "Delia", "Delilah", "Dell", "Della", "Delmer", "Delores", "Delpha", "Delphia", "Delphine", "Delta", "Demarco", "Demarcus", "Demario", "Demetris", "Demetrius", "Demond", "Dena", "Denis", "Dennis", "Deon", "Deondre", "Deontae", "Deonte", "Dereck", "Derek", "Derick", "Deron", "Derrick", "Deshaun", "Deshawn", "Desiree", "Desmond", "Dessie", "Destany", "Destin", "Destinee", "Destiney", "Destini", "Destiny", "Devan", "Devante", "Deven", "Devin", "Devon", "Devonte", "Devyn", "Dewayne", "Dewitt", "Dexter", "Diamond", "Diana", "Dianna", "Diego", "Dillan", "Dillon", "Dimitri", "Dina", "Dino", "Dion", "Dixie", "Dock", "Dolly", "Dolores", "Domenic", "Domenica", "Domenick", "Domenico", "Domingo", "Dominic", "Dominique", "Don", "Donald", "Donato", "Donavon", "Donna", "Donnell", "Donnie", "Donny", "Dora", "Dorcas", "Dorian", "Doris", "Dorothea", "Dorothy", "Dorris", "Dortha", "Dorthy", "Doug", "Douglas", "Dovie", "Doyle", "Drake", "Drew", "Duane", "Dudley", "Dulce", "Duncan", "Durward", "Dustin", "Dusty", "Dwight", "Dylan", "Earl", "Earlene", "Earline", "Earnest", "Earnestine", "Easter", "Easton", "Ebba", "Ebony", "Ed", "Eda", "Edd", "Eddie", "Eden", "Edgar", "Edgardo", "Edison", "Edmond", "Edmund", "Edna", "Eduardo", "Edward", "Edwardo", "Edwin", "Edwina", "Edyth", "Edythe", "Effie", "Efrain", "Efren", "Eileen", "Einar", "Eino", "Eladio", "Elaina", "Elbert", "Elda", "Eldon", "Eldora", "Eldred", "Eldridge", "Eleanora", "Eleanore", "Eleazar", "Electa", "Elena", "Elenor", "Elenora", "Eleonore", "Elfrieda", "Eli", "Elian", "Eliane", "Elias", "Eliezer", "Elijah", "Elinor", "Elinore", "Elisa", "Elisabeth", "Elise", "Eliseo", "Elisha", "Elissa", "Eliza", "Elizabeth", "Ella", "Ellen", "Ellie", "Elliot", "Elliott", "Ellis", "Ellsworth", "Elmer", "Elmira", "Elmo", "Elmore", "Elna", "Elnora", "Elody", "Eloisa", "Eloise", "Elouise", "Eloy", "Elroy", "Elsa", "Else", "Elsie", "Elta", "Elton", "Elva", "Elvera", "Elvie", "Elvis", "Elwin", "Elwyn", "Elyse", "Elyssa", "Elza", "Emanuel", "Emelia", "Emelie", "Emely", "Emerald", "Emerson", "Emery", "Emie", "Emil", "Emile", "Emilia", "Emiliano", "Emilie", "Emilio", "Emily", "Emma", "Emmalee", "Emmanuel", "Emmanuelle", "Emmet", "Emmett", "Emmie", "Emmitt", "Emmy", "Emory", "Ena", "Enid", "Enoch", "Enola", "Enos", "Enrico", "Enrique", "Ephraim", "Era", "Eriberto", "Eric", "Erica", "Erich", "Erick", "Ericka", "Erik", "Erika", "Erin", "Erling", "Erna", "Ernest", "Ernestina", "Ernestine", "Ernesto", "Ernie", "Ervin", "Erwin", "Eryn", "Esmeralda", "Esperanza", "Esta", "Esteban", "Estefania", "Estel", "Estell", "Estella", "Estelle", "Estevan", "Esther", "Estrella", "Etha", "Ethan", "Ethel", "Ethelyn", "Ethyl", "Ettie", "Eudora", "Eugene", "Eugenia", "Eula", "Eulah", "Eulalia", "Euna", "Eunice", "Eusebio", "Eva", "Evalyn", "Evan", "Evangeline", "Evans", "Eve", "Eveline", "Evelyn", "Everardo", "Everett", "Everette", "Evert", "Evie", "Ewald", "Ewell", "Ezekiel", "Ezequiel", "Ezra", "Fabian", "Fabiola", "Fae", "Fannie", "Fanny", "Fatima", "Faustino", "Fausto", "Favian", "Fay", "Faye", "Federico", "Felicia", "Felicita", "Felicity", "Felipa", "Felipe", "Felix", "Felton", "Fermin", "Fern", "Fernando", "Ferne", "Fidel", "Filiberto", "Filomena", "Finn", "Fiona", "Flavie", "Flavio", "Fleta", "Fletcher", "Flo", "Florence", "Florencio", "Florian", "Florida", "Florine", "Flossie", "Floy", "Floyd", "Ford", "Forest", "Forrest", "Foster", "Frances", "Francesca", "Francesco", "Francis", "Francisca", "Francisco", "Franco", "Frank", "Frankie", "Franz", "Fred", "Freda", "Freddie", "Freddy", "Frederic", "Frederick", "Frederik", "Frederique", "Fredrick", "Fredy", "Freeda", "Freeman", "Freida", "Frida", "Frieda", "Friedrich", "Fritz", "Furman", "Gabe", "Gabriel", "Gabriella", "Gabrielle", "Gaetano", "Gage", "Gail", "Gardner", "Garett", "Garfield", "Garland", "Garnet", "Garnett", "Garret", "Garrett", "Garrick", "Garrison", "Garry", "Garth", "Gaston", "Gavin", "Gay", "Gayle", "Gaylord", "Gene", "General", "Genesis", "Genevieve", "Gennaro", "Genoveva", "Geo", "Geoffrey", "George", "Georgette", "Georgiana", "Georgianna", "Geovanni", "Geovanny", "Geovany", "Gerald", "Geraldine", "Gerard", "Gerardo", "Gerda", "Gerhard", "Germaine", "German", "Gerry", "Gerson", "Gertrude", "Gia", "Gianni", "Gideon", "Gilbert", "Gilberto", "Gilda", "Giles", "Gillian", "Gina", "Gino", "Giovani", "Giovanna", "Giovanni", "Giovanny", "Gisselle", "Giuseppe", "Gladyce", "Gladys", "Glen", "Glenda", "Glenna", "Glennie", "Gloria", "Godfrey", "Golda", "Golden", "Gonzalo", "Gordon", "Grace", "Gracie", "Graciela", "Grady", "Graham", "Grant", "Granville", "Grayce", "Grayson", "Green", "Greg", "Gregg", "Gregoria", "Gregorio", "Gregory", "Greta", "Gretchen", "Greyson", "Griffin", "Grover", "Guadalupe", "Gudrun", "Guido", "Guillermo", "Guiseppe", "Gunnar", "Gunner", "Gus", "Gussie", "Gust", "Gustave", "Guy", "Gwen", "Gwendolyn", "Hadley", "Hailee", "Hailey", "Hailie", "Hal", "Haleigh", "Haley", "Halie", "Halle", "Hallie", "Hank", "Hanna", "Hannah", "Hans", "Hardy", "Harley", "Harmon", "Harmony", "Harold", "Harrison", "Harry", "Harvey", "Haskell", "Hassan", "Hassie", "Hattie", "Haven", "Hayden", "Haylee", "Hayley", "Haylie", "Hazel", "Hazle", "Heath", "Heather", "Heaven", "Heber", "Hector", "Heidi", "Helen", "Helena", "Helene", "Helga", "Hellen", "Helmer", "Heloise", "Henderson", "Henri", "Henriette", "Henry", "Herbert", "Herman", "Hermann", "Hermina", "Herminia", "Herminio", "Hershel", "Herta", "Hertha", "Hester", "Hettie", "Hilario", "Hilbert", "Hilda", "Hildegard", "Hillard", "Hillary", "Hilma", "Hilton", "Hipolito", "Hiram", "Hobart", "Holden", "Hollie", "Hollis", "Holly", "Hope", "Horace", "Horacio", "Hortense", "Hosea", "Houston", "Howard", "Howell", "Hoyt", "Hubert", "Hudson", "Hugh", "Hulda", "Humberto", "Hunter", "Hyman", "Ian", "Ibrahim", "Icie", "Ida", "Idell", "Idella", "Ignacio", "Ignatius", "Ike", "Ila", "Ilene", "Iliana", "Ima", "Imani", "Imelda", "Immanuel", "Imogene", "Ines", "Irma", "Irving", "Irwin", "Isaac", "Isabel", "Isabell", "Isabella", "Isabelle", "Isac", "Isadore", "Isai", "Isaiah", "Isaias", "Isidro", "Ismael", "Isobel", "Isom", "Israel", "Issac", "Itzel", "Iva", "Ivah", "Ivory", "Ivy", "Izabella", "Izaiah", "Jabari", "Jace", "Jacey", "Jacinthe", "Jacinto", "Jack", "Jackeline", "Jackie", "Jacklyn", "Jackson", "Jacky", "Jaclyn", "Jacquelyn", "Jacques", "Jacynthe", "Jada", "Jade", "Jaden", "Jadon", "Jadyn", "Jaeden", "Jaida", "Jaiden", "Jailyn", "Jaime", "Jairo", "Jakayla", "Jake", "Jakob", "Jaleel", "Jalen", "Jalon", "Jalyn", "Jamaal", "Jamal", "Jamar", "Jamarcus", "Jamel", "Jameson", "Jamey", "Jamie", "Jamil", "Jamir", "Jamison", "Jammie", "Jan", "Jana", "Janae", "Jane", "Janelle", "Janessa", "Janet", "Janice", "Janick", "Janie", "Janis", "Janiya", "Jannie", "Jany", "Jaquan", "Jaquelin", "Jaqueline", "Jared", "Jaren", "Jarod", "Jaron", "Jarred", "Jarrell", "Jarret", "Jarrett", "Jarrod", "Jarvis", "Jasen", "Jasmin", "Jason", "Jasper", "Jaunita", "Javier", "Javon", "Javonte", "Jay", "Jayce", "Jaycee", "Jayda", "Jayde", "Jayden", "Jaydon", "Jaylan", "Jaylen", "Jaylin", "Jaylon", "Jayme", "Jayne", "Jayson", "Jazlyn", "Jazmin", "Jazmyn", "Jazmyne", "Jean", "Jeanette", "Jeanie", "Jeanne", "Jed", "Jedediah", "Jedidiah", "Jeff", "Jefferey", "Jeffery", "Jeffrey", "Jeffry", "Jena", "Jenifer", "Jennie", "Jennifer", "Jennings", "Jennyfer", "Jensen", "Jerad", "Jerald", "Jeramie", "Jeramy", "Jerel", "Jeremie", "Jeremy", "Jermain", "Jermaine", "Jermey", "Jerod", "Jerome", "Jeromy", "Jerrell", "Jerrod", "Jerrold", "Jerry", "Jess", "Jesse", "Jessica", "Jessie", "Jessika", "Jessy", "Jessyca", "Jesus", "Jett", "Jettie", "Jevon", "Jewel", "Jewell", "Jillian", "Jimmie", "Jimmy", "Jo", "Joan", "Joana", "Joanie", "Joanne", "Joannie", "Joanny", "Joany", "Joaquin", "Jocelyn", "Jodie", "Jody", "Joe", "Joel", "Joelle", "Joesph", "Joey", "Johan", "Johann", "Johanna", "Johathan", "John", "Johnathan", "Johnathon", "Johnnie", "Johnny", "Johnpaul", "Johnson", "Jolie", "Jon", "Jonas", "Jonatan", "Jonathan", "Jonathon", "Jordan", "Jordane", "Jordi", "Jordon", "Jordy", "Jordyn", "Jorge", "Jose", "Josefa", "Josefina", "Joseph", "Josephine", "Josh", "Joshua", "Joshuah", "Josiah", "Josiane", "Josianne", "Josie", "Josue", "Jovan", "Jovani", "Jovanny", "Jovany", "Joy", "Joyce", "Juana", "Juanita", "Judah", "Judd", "Jude", "Judge", "Judson", "Judy", "Jules", "Julia", "Julian", "Juliana", "Julianne", "Julie", "Julien", "Juliet", "Julio", "Julius", "June", "Junior", "Junius", "Justen", "Justice", "Justina", "Justine", "Juston", "Justus", "Justyn", "Juvenal", "Juwan", "Kacey", "Kaci", "Kacie", "Kade", "Kaden", "Kadin", "Kaela", "Kaelyn", "Kaia", "Kailee", "Kailey", "Kailyn", "Kaitlin", "Kaitlyn", "Kale", "Kaleb", "Kaleigh", "Kaley", "Kali", "Kallie", "Kameron", "Kamille", "Kamren", "Kamron", "Kamryn", "Kane", "Kara", "Kareem", "Karelle", "Karen", "Kari", "Kariane", "Karianne", "Karina", "Karine", "Karl", "Karlee", "Karley", "Karli", "Karlie", "Karolann", "Karson", "Kasandra", "Kasey", "Kassandra", "Katarina", "Katelin", "Katelyn", "Katelynn", "Katharina", "Katherine", "Katheryn", "Kathleen", "Kathlyn", "Kathryn", "Kathryne", "Katlyn", "Katlynn", "Katrina", "Katrine", "Kattie", "Kavon", "Kay", "Kaya", "Kaycee", "Kayden", "Kayla", "Kaylah", "Kaylee", "Kayleigh", "Kayley", "Kayli", "Kaylie", "Kaylin", "Keagan", "Keanu", "Keara", "Keaton", "Keegan", "Keeley", "Keely", "Keenan", "Keira", "Keith", "Kellen", "Kelley", "Kelli", "Kellie", "Kelly", "Kelsi", "Kelsie", "Kelton", "Kelvin", "Ken", "Kendall", "Kendra", "Kendrick", "Kenna", "Kennedi", "Kennedy", "Kenneth", "Kennith", "Kenny", "Kenton", "Kenya", "Kenyatta", "Kenyon", "Keon", "Keshaun", "Keshawn", "Keven", "Kevin", "Kevon", "Keyon", "Keyshawn", "Khalid", "Khalil", "Kian", "Kiana", "Kianna", "Kiara", "Kiarra", "Kiel", "Kiera", "Kieran", "Kiley", "Kim", "Kimberly", "King", "Kip", "Kira", "Kirk", "Kirsten", "Kirstin", "Kitty", "Kobe", "Koby", "Kody", "Kolby", "Kole", "Korbin", "Korey", "Kory", "Kraig", "Kris", "Krista", "Kristian", "Kristin", "Kristina", "Kristofer", "Kristoffer", "Kristopher", "Kristy", "Krystal", "Krystel", "Krystina", "Kurt", "Kurtis", "Kyla", "Kyle", "Kylee", "Kyleigh", "Kyler", "Kylie", "Kyra", "Lacey", "Lacy", "Ladarius", "Lafayette", "Laila", "Laisha", "Lamar", "Lambert", "Lamont", "Lance", "Landen", "Lane", "Laney", "Larissa", "Laron", "Larry", "Larue", "Laura", "Laurel", "Lauren", "Laurence", "Lauretta", "Lauriane", "Laurianne", "Laurie", "Laurine", "Laury", "Lauryn", "Lavada", "Lavern", "Laverna", "Laverne", "Lavina", "Lavinia", "Lavon", "Lavonne", "Lawrence", "Lawson", "Layla", "Layne", "Lazaro", "Lea", "Leann", "Leanna", "Leanne", "Leatha", "Leda", "Lee", "Leif", "Leila", "Leilani", "Lela", "Lelah", "Leland", "Lelia", "Lempi", "Lemuel", "Lenna", "Lennie", "Lenny", "Lenora", "Lenore", "Leo", "Leola", "Leon", "Leonard", "Leonardo", "Leone", "Leonel", "Leonie", "Leonor", "Leonora", "Leopold", "Leopoldo", "Leora", "Lera", "Lesley", "Leslie", "Lesly", "Lessie", "Lester", "Leta", "Letha", "Letitia", "Levi", "Lew", "Lewis", "Lexi", "Lexie", "Lexus", "Lia", "Liam", "Liana", "Libbie", "Libby", "Lila", "Lilian", "Liliana", "Liliane", "Lilla", "Lillian", "Lilliana", "Lillie", "Lilly", "Lily", "Lilyan", "Lina", "Lincoln", "Linda", "Lindsay", "Lindsey", "Linnea", "Linnie", "Linwood", "Lionel", "Lisa", "Lisandro", "Lisette", "Litzy", "Liza", "Lizeth", "Lizzie", "Llewellyn", "Lloyd", "Logan", "Lois", "Lola", "Lolita", "Loma", "Lon", "London", "Lonie", "Lonnie", "Lonny", "Lonzo", "Lora", "Loraine", "Loren", "Lorena", "Lorenz", "Lorenza", "Lorenzo", "Lori", "Lorine", "Lorna", "Lottie", "Lou", "Louie", "Louisa", "Lourdes", "Louvenia", "Lowell", "Loy", "Loyal", "Loyce", "Lucas", "Luciano", "Lucie", "Lucienne", "Lucile", "Lucinda", "Lucio", "Lucious", "Lucius", "Lucy", "Ludie", "Ludwig", "Lue", "Luella", "Luigi", "Luis", "Luisa", "Lukas", "Lula", "Lulu", "Luna", "Lupe", "Lura", "Lurline", "Luther", "Luz", "Lyda", "Lydia", "Lyla", "Lynn", "Lyric", "Lysanne", "Mabel", "Mabelle", "Mable", "Mac", "Macey", "Maci", "Macie", "Mack", "Mackenzie", "Macy", "Madaline", "Madalyn", "Maddison", "Madeline", "Madelyn", "Madelynn", "Madge", "Madie", "Madilyn", "Madisen", "Madison", "Madisyn", "Madonna", "Madyson", "Mae", "Maegan", "Maeve", "Mafalda", "Magali", "Magdalen", "Magdalena", "Maggie", "Magnolia", "Magnus", "Maia", "Maida", "Maiya", "Major", "Makayla", "Makenna", "Makenzie", "Malachi", "Malcolm", "Malika", "Malinda", "Mallie", "Mallory", "Malvina", "Mandy", "Manley", "Manuel", "Manuela", "Mara", "Marc", "Marcel", "Marcelina", "Marcelino", "Marcella", "Marcelle", "Marcellus", "Marcelo", "Marcia", "Marco", "Marcos", "Marcus", "Margaret", "Margarete", "Margarett", "Margaretta", "Margarette", "Margarita", "Marge", "Margie", "Margot", "Margret", "Marguerite", "Maria", "Mariah", "Mariam", "Marian", "Mariana", "Mariane", "Marianna", "Marianne", "Mariano", "Maribel", "Marie", "Mariela", "Marielle", "Marietta", "Marilie", "Marilou", "Marilyne", "Marina", "Mario", "Marion", "Marisa", "Marisol", "Maritza", "Marjolaine", "Marjorie", "Marjory", "Mark", "Markus", "Marlee", "Marlen", "Marlene", "Marley", "Marlin", "Marlon", "Marques", "Marquis", "Marquise", "Marshall", "Marta", "Martin", "Martina", "Martine", "Marty", "Marvin", "Mary", "Maryam", "Maryjane", "Maryse", "Mason", "Mateo", "Mathew", "Mathias", "Mathilde", "Matilda", "Matilde", "Matt", "Matteo", "Mattie", "Maud", "Maude", "Maudie", "Maureen", "Maurice", "Mauricio", "Maurine", "Maverick", "Mavis", "Max", "Maxie", "Maxime", "Maximilian", "Maximillia", "Maximillian", "Maximo", "Maximus", "Maxine", "Maxwell", "May", "Maya", "Maybell", "Maybelle", "Maye", "Maymie", "Maynard", "Mayra", "Mazie", "Mckayla", "Mckenna", "Mckenzie", "Meagan", "Meaghan", "Meda", "Megane", "Meggie", "Meghan", "Mekhi", "Melany", "Melba", "Melisa", "Melissa", "Mellie", "Melody", "Melvin", "Melvina", "Melyna", "Melyssa", "Mercedes", "Meredith", "Merl", "Merle", "Merlin", "Merritt", "Mertie", "Mervin", "Meta", "Mia", "Micaela", "Micah", "Michael", "Michaela", "Michale", "Micheal", "Michel", "Michele", "Michelle", "Miguel", "Mikayla", "Mike", "Mikel", "Milan", "Miles", "Milford", "Miller", "Millie", "Milo", "Milton", "Mina", "Minerva", "Minnie", "Miracle", "Mireille", "Mireya", "Misael", "Missouri", "Misty", "Mitchel", "Mitchell", "Mittie", "Modesta", "Modesto", "Mohamed", "Mohammad", "Mohammed", "Moises", "Mollie", "Molly", "Mona", "Monica", "Monique", "Monroe", "Monserrat", "Monserrate", "Montana", "Monte", "Monty", "Morgan", "Moriah", "Morris", "Mortimer", "Morton", "Mose", "Moses", "Moshe", "Mossie", "Mozell", "Mozelle", "Muhammad", "Muriel", "Murl", "Murphy", "Murray", "Mustafa", "Mya", "Myah", "Mylene", "Myles", "Myra", "Myriam", "Myrl", "Myrna", "Myron", "Myrtice", "Myrtie", "Myrtis", "Myrtle", "Nadia", "Nakia", "Name", "Nannie", "Naomi", "Naomie", "Napoleon", "Narciso", "Nash", "Nasir", "Nat", "Natalia", "Natalie", "Natasha", "Nathan", "Nathanael", "Nathanial", "Nathaniel", "Nathen", "Nayeli", "Neal", "Ned", "Nedra", "Neha", "Neil", "Nelda", "Nella", "Nelle", "Nellie", "Nels", "Nelson", "Neoma", "Nestor", "Nettie", "Neva", "Newell", "Newton", "Nia", "Nicholas", "Nicholaus", "Nichole", "Nick", "Nicklaus", "Nickolas", "Nico", "Nicola", "Nicolas", "Nicole", "Nicolette", "Nigel", "Nikita", "Nikki", "Nikko", "Niko", "Nikolas", "Nils", "Nina", "Noah", "Noble", "Noe", "Noel", "Noelia", "Noemi", "Noemie", "Noemy", "Nola", "Nolan", "Nona", "Nora", "Norbert", "Norberto", "Norene", "Norma", "Norris", "Norval", "Norwood", "Nova", "Novella", "Nya", "Nyah", "Nyasia", "Obie", "Oceane", "Ocie", "Octavia", "Oda", "Odell", "Odessa", "Odie", "Ofelia", "Okey", "Ola", "Olaf", "Ole", "Olen", "Oleta", "Olga", "Olin", "Oliver", "Ollie", "Oma", "Omari", "Omer", "Ona", "Onie", "Opal", "Ophelia", "Ora", "Oral", "Oran", "Oren", "Orie", "Orin", "Orion", "Orland", "Orlando", "Orlo", "Orpha", "Orrin", "Orval", "Orville", "Osbaldo", "Osborne", "Oscar", "Osvaldo", "Oswald", "Oswaldo", "Otha", "Otho", "Otilia", "Otis", "Ottilie", "Ottis", "Otto", "Ova", "Owen", "Ozella", "Pablo", "Paige", "Palma", "Pamela", "Pansy", "Paolo", "Paris", "Parker", "Pascale", "Pasquale", "Pat", "Patience", "Patricia", "Patrick", "Patsy", "Pattie", "Paul", "Paula", "Pauline", "Paxton", "Payton", "Pearl", "Pearlie", "Pearline", "Pedro", "Peggie", "Penelope", "Percival", "Percy", "Perry", "Pete", "Peter", "Petra", "Peyton", "Philip", "Phoebe", "Phyllis", "Pierce", "Pierre", "Pietro", "Pink", "Pinkie", "Piper", "Polly", "Porter", "Precious", "Presley", "Preston", "Price", "Prince", "Princess", "Priscilla", "Providenci", "Prudence", "Queen", "Queenie", "Quentin", "Quincy", "Quinn", "Quinten", "Quinton", "Rachael", "Rachel", "Rachelle", "Rae", "Raegan", "Rafael", "Rafaela", "Raheem", "Rahsaan", "Rahul", "Raina", "Raleigh", "Ralph", "Ramiro", "Ramon", "Ramona", "Randal", "Randall", "Randi", "Randy", "Ransom", "Raoul", "Raphael", "Raphaelle", "Raquel", "Rashad", "Rashawn", "Rasheed", "Raul", "Raven", "Ray", "Raymond", "Raymundo", "Reagan", "Reanna", "Reba", "Rebeca", "Rebecca", "Rebeka", "Rebekah", "Reece", "Reed", "Reese", "Regan", "Reggie", "Reginald", "Reid", "Reilly", "Reina", "Reinhold", "Remington", "Rene", "Renee", "Ressie", "Reta", "Retha", "Retta", "Reuben", "Reva", "Rex", "Rey", "Reyes", "Reymundo", "Reyna", "Reynold", "Rhea", "Rhett", "Rhianna", "Rhiannon", "Rhoda", "Ricardo", "Richard", "Richie", "Richmond", "Rick", "Rickey", "Rickie", "Ricky", "Rico", "Rigoberto", "Riley", "Rita", "River", "Robb", "Robbie", "Robert", "Roberta", "Roberto", "Robin", "Robyn", "Rocio", "Rocky", "Rod", "Roderick", "Rodger", "Rodolfo", "Rodrick", "Rodrigo", "Roel", "Rogelio", "Roger", "Rogers", "Rolando", "Rollin", "Roma", "Romaine", "Roman", "Ron", "Ronaldo", "Ronny", "Roosevelt", "Rory", "Rosa", "Rosalee", "Rosalia", "Rosalind", "Rosalinda", "Rosalyn", "Rosamond", "Rosanna", "Rosario", "Roscoe", "Rose", "Rosella", "Roselyn", "Rosemarie", "Rosemary", "Rosendo", "Rosetta", "Rosie", "Rosina", "Roslyn", "Ross", "Rossie", "Rowan", "Rowena", "Rowland", "Roxane", "Roxanne", "Roy", "Royal", "Royce", "Rozella", "Ruben", "Rubie", "Ruby", "Rubye", "Rudolph", "Rudy", "Rupert", "Russ", "Russel", "Russell", "Rusty", "Ruth", "Ruthe", "Ruthie", "Ryan", "Ryann", "Ryder", "Rylan", "Rylee", "Ryleigh", "Ryley", "Sabina", "Sabrina", "Sabryna", "Sadie", "Sadye", "Sage", "Saige", "Sallie", "Sally", "Salma", "Salvador", "Salvatore", "Sam", "Samanta", "Samantha", "Samara", "Samir", "Sammie", "Sammy", "Samson", "Sandra", "Sandrine", "Sandy", "Sanford", "Santa", "Santiago", "Santina", "Santino", "Santos", "Sarah", "Sarai", "Sarina", "Sasha", "Saul", "Savanah", "Savanna", "Savannah", "Savion", "Scarlett", "Schuyler", "Scot", "Scottie", "Scotty", "Seamus", "Sean", "Sebastian", "Sedrick", "Selena", "Selina", "Selmer", "Serena", "Serenity", "Seth", "Shad", "Shaina", "Shakira", "Shana", "Shane", "Shanel", "Shanelle", "Shania", "Shanie", "Shaniya", "Shanna", "Shannon", "Shanny", "Shanon", "Shany", "Sharon", "Shaun", "Shawn", "Shawna", "Shaylee", "Shayna", "Shayne", "Shea", "Sheila", "Sheldon", "Shemar", "Sheridan", "Sherman", "Sherwood", "Shirley", "Shyann", "Shyanne", "Sibyl", "Sid", "Sidney", "Sienna", "Sierra", "Sigmund", "Sigrid", "Sigurd", "Silas", "Sim", "Simeon", "Simone", "Sincere", "Sister", "Skye", "Skyla", "Skylar", "Sofia", "Soledad", "Solon", "Sonia", "Sonny", "Sonya", "Sophia", "Sophie", "Spencer", "Stacey", "Stacy", "Stan", "Stanford", "Stanley", "Stanton", "Stefan", "Stefanie", "Stella", "Stephan", "Stephania", "Stephanie", "Stephany", "Stephen", "Stephon", "Sterling", "Steve", "Stevie", "Stewart", "Stone", "Stuart", "Summer", "Sunny", "Susan", "Susana", "Susanna", "Susie", "Suzanne", "Sven", "Syble", "Sydnee", "Sydney", "Sydni", "Sydnie", "Sylvan", "Sylvester", "Sylvia", "Tabitha", "Tad", "Talia", "Talon", "Tamara", "Tamia", "Tania", "Tanner", "Tanya", "Tara", "Taryn", "Tate", "Tatum", "Tatyana", "Taurean", "Tavares", "Taya", "Taylor", "Teagan", "Ted", "Telly", "Terence", "Teresa", "Terrance", "Terrell", "Terrence", "Terrill", "Terry", "Tess", "Tessie", "Tevin", "Thad", "Thaddeus", "Thalia", "Thea", "Thelma", "Theo", "Theodora", "Theodore", "Theresa", "Therese", "Theresia", "Theron", "Thomas", "Thora", "Thurman", "Tia", "Tiana", "Tianna", "Tiara", "Tierra", "Tiffany", "Tillman", "Timmothy", "Timmy", "Timothy", "Tina", "Tito", "Titus", "Tobin", "Toby", "Tod", "Tom", "Tomas", "Tomasa", "Tommie", "Toney", "Toni", "Tony", "Torey", "Torrance", "Torrey", "Toy", "Trace", "Tracey", "Tracy", "Travis", "Travon", "Tre", "Tremaine", "Tremayne", "Trent", "Trenton", "Tressa", "Tressie", "Treva", "Trever", "Trevion", "Trevor", "Trey", "Trinity", "Trisha", "Tristian", "Tristin", "Triston", "Troy", "Trudie", "Trycia", "Trystan", "Turner", "Twila", "Tyler", "Tyra", "Tyree", "Tyreek", "Tyrel", "Tyrell", "Tyrese", "Tyrique", "Tyshawn", "Tyson", "Ubaldo", "Ulices", "Ulises", "Una", "Unique", "Urban", "Uriah", "Uriel", "Ursula", "Vada", "Valentin", "Valentina", "Valentine", "Valerie", "Vallie", "Van", "Vance", "Vanessa", "Vaughn", "Veda", "Velda", "Vella", "Velma", "Velva", "Vena", "Verda", "Verdie", "Vergie", "Verla", "Verlie", "Vern", "Verna", "Verner", "Vernice", "Vernie", "Vernon", "Verona", "Veronica", "Vesta", "Vicenta", "Vicente", "Vickie", "Vicky", "Victor", "Victoria", "Vida", "Vidal", "Vilma", "Vince", "Vincent", "Vincenza", "Vincenzo", "Vinnie", "Viola", "Violet", "Violette", "Virgie", "Virgil", "Virginia", "Virginie", "Vita", "Vito", "Viva", "Vivian", "Viviane", "Vivianne", "Vivien", "Vivienne", "Vladimir", "Wade", "Waino", "Waldo", "Walker", "Wallace", "Walter", "Walton", "Wanda", "Ward", "Warren", "Watson", "Wava", "Waylon", "Wayne", "Webster", "Weldon", "Wellington", "Wendell", "Wendy", "Werner", "Westley", "Weston", "Whitney", "Wilber", "Wilbert", "Wilburn", "Wiley", "Wilford", "Wilfred", "Wilfredo", "Wilfrid", "Wilhelm", "Wilhelmine", "Will", "Willa", "Willard", "William", "Willie", "Willis", "Willow", "Willy", "Wilma", "Wilmer", "Wilson", "Wilton", "Winfield", "Winifred", "Winnifred", "Winona", "Winston", "Woodrow", "Wyatt", "Wyman", "Xander", "Xavier", "Xzavier", "Yadira", "Yasmeen", "Yasmin", "Yasmine", "Yazmin", "Yesenia", "Yessenia", "Yolanda", "Yoshiko", "Yvette", "Yvonne", "Zachariah", "Zachary", "Zachery", "Zack", "Zackary", "Zackery", "Zakary", "Zander", "Zane", "Zaria", "Zechariah", "Zelda", "Zella", "Zelma", "Zena", "Zetta", "Zion", "Zita", "Zoe", "Zoey", "Zoie", "Zoila", "Zola", "Zora", "Zula"];
        e.exports = {
            generateUsername: function() {
                return `${i.randomElement(r)}-${i.randomAlphanumStr(3)}`
            }
        }
    }, function(e, t, n) {
        "use strict";

        function i(e, t = 500, n = 2) {
            return Math.floor(Math.random() * (1e3 * Math.pow(n, e) - t) + t)
        }
        n.d(t, "a", (function() {
            return i
        }))
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        }));
        class i {
            constructor() {
                this._lastSuccess = null
            }
            startTracking(e) {
                const t = e.rawInput;
                e.rawInput = function(...n) {
                    this._lastSuccess = Date.now(), t.apply(e, n)
                }
            }
            getTimeSinceLastSuccess() {
                return this._lastSuccess ? Date.now() - this._lastSuccess : null
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return g
            }));
            var i = n(7),
                r = n(4),
                s = n(1),
                o = n(0),
                a = n.n(o),
                c = n(11),
                d = n.n(c),
                u = n(35),
                l = n.n(u),
                h = n(5),
                p = n(47),
                f = n(36);
            const m = Object(r.getLogger)(e);
            class g extends f.b {
                constructor(e, t, n) {
                    super(), this.xmpp = e, this.eventEmitter = t, this.sessions = {}, this.jvbIceConfig = n.jvb, this.p2pIceConfig = n.p2p, this.mediaConstraints = {
                        offerToReceiveAudio: !0,
                        offerToReceiveVideo: !0
                    }
                }
                init(e) {
                    super.init(e), this.connection.addHandler(this.onJingle.bind(this), "urn:xmpp:jingle:1", "iq", "set", null, null)
                }
                onJingle(e) {
                    const t = $(e).find("jingle").attr("sid"),
                        n = $(e).find("jingle").attr("action"),
                        r = e.getAttribute("from"),
                        o = Object(s.$iq)({
                            type: "result",
                            to: r,
                            id: e.getAttribute("id")
                        });
                    m.log(`on jingle ${n} from ${r}`, e);
                    let c = this.sessions[t];
                    if ("session-initiate" !== n) {
                        if (!c) return o.attrs({
                            type: "error"
                        }), o.c("error", {
                            type: "cancel"
                        }).c("item-not-found", {
                            xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                        }).up().c("unknown-session", {
                            xmlns: "urn:xmpp:jingle:errors:1"
                        }), m.warn("invalid session id", e), this.connection.send(o), !0;
                        if (r !== c.remoteJid) return m.warn("jid mismatch for session id", t, c.remoteJid, e), o.attrs({
                            type: "error"
                        }), o.c("error", {
                            type: "cancel"
                        }).c("item-not-found", {
                            xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                        }).up().c("unknown-session", {
                            xmlns: "urn:xmpp:jingle:errors:1"
                        }), this.connection.send(o), !0
                    } else if (void 0 !== c) return o.attrs({
                        type: "error"
                    }), o.c("error", {
                        type: "cancel"
                    }).c("service-unavailable", {
                        xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                    }).up(), m.warn("duplicate session id", t, e), this.connection.send(o), !0;
                    const u = window.performance.now(),
                        l = "focus" !== s.Strophe.getResourceFromJid(r);
                    switch (n) {
                        case "session-initiate": {
                            m.log("(TIME) received session-initiate:\t", u);
                            const t = $(e).find("jingle>startmuted");
                            if (t && t.length > 0) {
                                const e = t.attr("audio"),
                                    n = t.attr("video");
                                this.eventEmitter.emit(a.a.START_MUTED_FROM_FOCUS, "true" === e, "true" === n)
                            }
                            m.info(`Marking session from ${r} as ${l?"":"*not*"} P2P`);
                            const n = l ? this.p2pIceConfig : this.jvbIceConfig;
                            c = new p.a($(e).find("jingle").attr("sid"), $(e).attr("to"), r, this.connection, this.mediaConstraints, JSON.parse(JSON.stringify(n)), l, !1), this.sessions[c.sid] = c, this.eventEmitter.emit(a.a.CALL_INCOMING, c, $(e).find(">jingle"), u);
                            break
                        }
                        case "session-accept":
                            this.eventEmitter.emit(a.a.CALL_ACCEPTED, c, $(e).find(">jingle"));
                            break;
                        case "content-modify":
                            c.modifyContents($(e).find(">jingle"));
                            break;
                        case "transport-info":
                            this.eventEmitter.emit(a.a.TRANSPORT_INFO, c, $(e).find(">jingle"));
                            break;
                        case "session-terminate": {
                            m.log("terminating...", c.sid);
                            let t = null,
                                n = null;
                            $(e).find(">jingle>reason").length && (t = $(e).find(">jingle>reason>:first")[0].tagName, n = $(e).find(">jingle>reason>text").text()), this.terminate(c.sid, t, n), this.eventEmitter.emit(a.a.CALL_ENDED, c, t, n);
                            break
                        }
                        case "transport-replace":
                            m.info("(TIME) Start transport replace:\t", u), h.a.sendAnalytics(Object(i.G)(i.f, {
                                p2p: l,
                                value: u
                            })), c.replaceTransport($(e).find(">jingle"), () => {
                                const e = window.performance.now();
                                m.info("(TIME) Transport replace success:\t", e), h.a.sendAnalytics(Object(i.G)(i.g, {
                                    p2p: l,
                                    value: e
                                }))
                            }, e => {
                                d.a.callErrorHandler(e), m.error("Transport replace failed", e), c.sendTransportReject()
                            });
                            break;
                        case "addsource":
                        case "source-add":
                            c.addRemoteStream($(e).find(">jingle>content"));
                            break;
                        case "removesource":
                        case "source-remove":
                            c.removeRemoteStream($(e).find(">jingle>content"));
                            break;
                        default:
                            m.warn("jingle action not implemented", n), o.attrs({
                                type: "error"
                            }), o.c("error", {
                                type: "cancel"
                            }).c("bad-request", {
                                xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                            }).up()
                    }
                    return this.connection.send(o), !0
                }
                newP2PJingleSession(e, t) {
                    const n = new p.a(l.a.randomHexString(12), e, t, this.connection, this.mediaConstraints, this.p2pIceConfig, !0, !0);
                    return this.sessions[n.sid] = n, n
                }
                terminate(e, t, n) {
                    this.sessions.hasOwnProperty(e) && ("ended" !== this.sessions[e].state && this.sessions[e].onTerminated(t, n), delete this.sessions[e])
                }
                getStunAndTurnCredentials() {
                    this.connection.sendIQ(Object(s.$iq)({
                        type: "get",
                        to: this.connection.domain
                    }).c("services", {
                        xmlns: "urn:xmpp:extdisco:1"
                    }), e => {
                        const t = [];
                        $(e).find(">services>service").each((e, n) => {
                            const i = {},
                                r = (n = $(n)).attr("type");
                            switch (r) {
                                case "stun":
                                    i.urls = `stun:${n.attr("host")}`, n.attr("port") && (i.urls += `:${n.attr("port")}`), t.push(i);
                                    break;
                                case "turn":
                                case "turns": {
                                    i.urls = `${r}:`;
                                    const e = n.attr("username");
                                    if (e) {
                                        const t = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
                                        t && parseInt(t[2], 10) < 28 ? i.urls += `${e}@` : i.username = e
                                    }
                                    i.urls += n.attr("host"), n.attr("port") && (i.urls += `:${n.attr("port")}`);
                                    const s = n.attr("transport");
                                    s && "udp" !== s && (i.urls += `?transport=${s}`), i.credential = n.attr("password") || i.credential, t.push(i);
                                    break
                                }
                            }
                        });
                        const n = this.xmpp.options;
                        n.useStunTurn && (this.jvbIceConfig.iceServers = t.filter(e => e.urls.startsWith("turns"))), n.p2p && n.p2p.useStunTurn && (this.p2pIceConfig.iceServers = t)
                    }, e => {
                        m.warn("getting turn credentials failed", e), m.warn("is mod_turncredentials or similar installed?")
                    })
                }
                getLog() {
                    const e = {};
                    return Object.keys(this.sessions).forEach(t => {
                        const n = this.sessions[t].peerconnection;
                        n && n.updateLog && (e[`jingle_${t}`] = {
                            updateLog: n.updateLog,
                            stats: n.stats,
                            url: window.location.href
                        })
                    }), e
                }
            }
        }).call(this, "modules/xmpp/strophe.jingle.js")
    }, function(e, t) {
        e.exports = {
            integerHash: function(e) {
                if (!e) return 0;
                let t, n, i = 0;
                for (n = 0; n < e.length; n++) i += (t = e.charCodeAt(n)) * Math.pow(31, e.length - 1 - n), i = Math.abs(0 | i);
                return i
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return o
            }));
            var i = n(4),
                r = n(32);
            const s = Object(i.getLogger)(e);
            class o {
                constructor(e, t, n, i, r, s, o) {
                    this.sid = e, this.localJid = t, this.remoteJid = n, this.connection = i, this.mediaConstraints = r, this.iceConfig = s, this.isInitiator = o, this.usedrip = !0, this.dripContainer = [], this.room = null, this.state = null, this.rtc = null
                }
                get initiatorJid() {
                    return this.isInitiator ? this.localJid : this.remoteJid
                }
                get responderJid() {
                    return this.isInitiator ? this.remoteJid : this.localJid
                }
                initialize(e, t, n) {
                    if (null !== this.state) {
                        const e = `attempt to initiate on session ${this.sid}\n                   in state ${this.state}`;
                        throw s.error(e), new Error(e)
                    }
                    this.room = e, this.rtc = t, this.state = r.c, this.doInitialize(n)
                }
                doInitialize(e) {}
                addIceCandidates(e) {}
                getState() {
                    return this.state
                }
                addSources(e) {}
                removeSources(e) {}
                terminate(e, t, n) {}
                acceptOffer(e, t, n) {}
                _getInitiatorJid() {
                    return this.isInitiator ? this.localJid : this.remoteJid
                }
            }
        }).call(this, "modules/xmpp/JingleSession.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return c
            }));
            var i = n(4),
                r = n(9),
                s = n(38),
                o = n(103);
            const a = Object(i.getLogger)(e);
            class c extends o.a {
                constructor() {
                    super(), this.ssrcOwners = new Map, this.chatRoom = null
                }
                setChatRoom(e) {
                    const t = this.chatRoom;
                    this.chatRoom = e, t && (t.removePresenceListener("audiomuted", this._audioMuteHandler), t.removePresenceListener("videomuted", this._videoMuteHandler), t.removePresenceListener("videoType", this._videoTypeHandler)), e && (this._audioMuteHandler = (e, t) => {
                        this.eventEmitter.emit(s.a, t, r.a, "true" === e.value)
                    }, e.addPresenceListener("audiomuted", this._audioMuteHandler), this._videoMuteHandler = (e, t) => {
                        this.eventEmitter.emit(s.a, t, r.c, "true" === e.value)
                    }, e.addPresenceListener("videomuted", this._videoMuteHandler), this._videoTypeHandler = (e, t) => {
                        this.eventEmitter.emit(s.b, t, e.value)
                    }, e.addPresenceListener("videoType", this._videoTypeHandler))
                }
                getPeerMediaInfo(e, t) {
                    if (this.chatRoom) return this.chatRoom.getMediaPresenceInfo(e, t);
                    a.error("Requested peer media info, before room was set")
                }
                getSSRCOwner(e) {
                    return this.ssrcOwners.get(e)
                }
                setSSRCOwner(e, t) {
                    if ("number" != typeof e) throw new TypeError(`SSRC(${e}) must be a number`);
                    this.ssrcOwners.set(e, t)
                }
            }
        }).call(this, "modules/xmpp/SignalingLayerImpl.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return r
        }));
        var i = n(24);
        class r extends i.a {
            getSSRCOwner(e) {
                throw new Error("not implemented")
            }
            getPeerMediaInfo(e, t) {
                throw new Error("not implemented")
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return s
        }));
        var i = n(105),
            r = n.n(i);
        class s {
            constructor() {
                this._queue = r.a.queue(this._processQueueTasks.bind(this), 1), this._stopped = !1
            }
            clear() {
                this._queue.kill()
            }
            _processQueueTasks(e, t) {
                e(t)
            }
            push(e, t) {
                this._stopped ? t && t(new Error("The queue has been stopped")) : this._queue.push(e, t)
            }
            shutdown() {
                this._stopped = !0
            }
        }
    }, function(e, t, n) {
        (function(n, i) {
            var r;
            /*!
             * async
             * https://github.com/caolan/async
             *
             * Copyright 2010-2014 Caolan McMahon
             * Released under the MIT license
             */
            ! function() {
                var s, o, a = {};

                function c(e) {
                    var t = !1;
                    return function() {
                        if (t) throw new Error("Callback was already called.");
                        t = !0, e.apply(s, arguments)
                    }
                }
                null != (s = this) && (o = s.async), a.noConflict = function() {
                    return s.async = o, a
                };
                var d = Object.prototype.toString,
                    u = Array.isArray || function(e) {
                        return "[object Array]" === d.call(e)
                    },
                    l = function(e, t) {
                        if (e.forEach) return e.forEach(t);
                        for (var n = 0; n < e.length; n += 1) t(e[n], n, e)
                    },
                    h = function(e, t) {
                        if (e.map) return e.map(t);
                        var n = [];
                        return l(e, (function(e, i, r) {
                            n.push(t(e, i, r))
                        })), n
                    },
                    p = function(e) {
                        if (Object.keys) return Object.keys(e);
                        var t = [];
                        for (var n in e) e.hasOwnProperty(n) && t.push(n);
                        return t
                    };
                void 0 !== n && n.nextTick ? (a.nextTick = n.nextTick, a.setImmediate = void 0 !== i ? function(e) {
                    i(e)
                } : a.nextTick) : "function" == typeof i ? (a.nextTick = function(e) {
                    i(e)
                }, a.setImmediate = a.nextTick) : (a.nextTick = function(e) {
                    setTimeout(e, 0)
                }, a.setImmediate = a.nextTick), a.each = function(e, t, n) {
                    if (n = n || function() {}, !e.length) return n();
                    var i = 0;

                    function r(t) {
                        t ? (n(t), n = function() {}) : (i += 1) >= e.length && n()
                    }
                    l(e, (function(e) {
                        t(e, c(r))
                    }))
                }, a.forEach = a.each, a.eachSeries = function(e, t, n) {
                    if (n = n || function() {}, !e.length) return n();
                    var i = 0,
                        r = function() {
                            t(e[i], (function(t) {
                                t ? (n(t), n = function() {}) : (i += 1) >= e.length ? n() : r()
                            }))
                        };
                    r()
                }, a.forEachSeries = a.eachSeries, a.eachLimit = function(e, t, n, i) {
                    f(t).apply(null, [e, n, i])
                }, a.forEachLimit = a.eachLimit;
                var f = function(e) {
                        return function(t, n, i) {
                            if (i = i || function() {}, !t.length || e <= 0) return i();
                            var r = 0,
                                s = 0,
                                o = 0;
                            ! function a() {
                                if (r >= t.length) return i();
                                for (; o < e && s < t.length;) o += 1, n(t[(s += 1) - 1], (function(e) {
                                    e ? (i(e), i = function() {}) : (o -= 1, (r += 1) >= t.length ? i() : a())
                                }))
                            }()
                        }
                    },
                    m = function(e) {
                        return function() {
                            var t = Array.prototype.slice.call(arguments);
                            return e.apply(null, [a.each].concat(t))
                        }
                    },
                    g = function(e) {
                        return function() {
                            var t = Array.prototype.slice.call(arguments);
                            return e.apply(null, [a.eachSeries].concat(t))
                        }
                    },
                    _ = function(e, t, n, i) {
                        if (t = h(t, (function(e, t) {
                                return {
                                    index: t,
                                    value: e
                                }
                            })), i) {
                            var r = [];
                            e(t, (function(e, t) {
                                n(e.value, (function(n, i) {
                                    r[e.index] = i, t(n)
                                }))
                            }), (function(e) {
                                i(e, r)
                            }))
                        } else e(t, (function(e, t) {
                            n(e.value, (function(e) {
                                t(e)
                            }))
                        }))
                    };
                a.map = m(_), a.mapSeries = g(_), a.mapLimit = function(e, t, n, i) {
                    return v(t)(e, n, i)
                };
                var v = function(e) {
                    return function(e, t) {
                        return function() {
                            var n = Array.prototype.slice.call(arguments);
                            return t.apply(null, [f(e)].concat(n))
                        }
                    }(e, _)
                };
                a.reduce = function(e, t, n, i) {
                    a.eachSeries(e, (function(e, i) {
                        n(t, e, (function(e, n) {
                            t = n, i(e)
                        }))
                    }), (function(e) {
                        i(e, t)
                    }))
                }, a.inject = a.reduce, a.foldl = a.reduce, a.reduceRight = function(e, t, n, i) {
                    var r = h(e, (function(e) {
                        return e
                    })).reverse();
                    a.reduce(r, t, n, i)
                }, a.foldr = a.reduceRight;
                var S = function(e, t, n, i) {
                    var r = [];
                    e(t = h(t, (function(e, t) {
                        return {
                            index: t,
                            value: e
                        }
                    })), (function(e, t) {
                        n(e.value, (function(n) {
                            n && r.push(e), t()
                        }))
                    }), (function(e) {
                        i(h(r.sort((function(e, t) {
                            return e.index - t.index
                        })), (function(e) {
                            return e.value
                        })))
                    }))
                };
                a.filter = m(S), a.filterSeries = g(S), a.select = a.filter, a.selectSeries = a.filterSeries;
                var y = function(e, t, n, i) {
                    var r = [];
                    e(t = h(t, (function(e, t) {
                        return {
                            index: t,
                            value: e
                        }
                    })), (function(e, t) {
                        n(e.value, (function(n) {
                            n || r.push(e), t()
                        }))
                    }), (function(e) {
                        i(h(r.sort((function(e, t) {
                            return e.index - t.index
                        })), (function(e) {
                            return e.value
                        })))
                    }))
                };
                a.reject = m(y), a.rejectSeries = g(y);
                var E = function(e, t, n, i) {
                    e(t, (function(e, t) {
                        n(e, (function(n) {
                            n ? (i(e), i = function() {}) : t()
                        }))
                    }), (function(e) {
                        i()
                    }))
                };
                a.detect = m(E), a.detectSeries = g(E), a.some = function(e, t, n) {
                    a.each(e, (function(e, i) {
                        t(e, (function(e) {
                            e && (n(!0), n = function() {}), i()
                        }))
                    }), (function(e) {
                        n(!1)
                    }))
                }, a.any = a.some, a.every = function(e, t, n) {
                    a.each(e, (function(e, i) {
                        t(e, (function(e) {
                            e || (n(!1), n = function() {}), i()
                        }))
                    }), (function(e) {
                        n(!0)
                    }))
                }, a.all = a.every, a.sortBy = function(e, t, n) {
                    a.map(e, (function(e, n) {
                        t(e, (function(t, i) {
                            t ? n(t) : n(null, {
                                value: e,
                                criteria: i
                            })
                        }))
                    }), (function(e, t) {
                        if (e) return n(e);
                        n(null, h(t.sort((function(e, t) {
                            var n = e.criteria,
                                i = t.criteria;
                            return n < i ? -1 : n > i ? 1 : 0
                        })), (function(e) {
                            return e.value
                        })))
                    }))
                }, a.auto = function(e, t) {
                    t = t || function() {};
                    var n = p(e),
                        i = n.length;
                    if (!i) return t();
                    var r = {},
                        s = [],
                        o = function(e) {
                            s.unshift(e)
                        },
                        c = function() {
                            i--, l(s.slice(0), (function(e) {
                                e()
                            }))
                        };
                    o((function() {
                        if (!i) {
                            var e = t;
                            t = function() {}, e(null, r)
                        }
                    })), l(n, (function(n) {
                        var i = u(e[n]) ? e[n] : [e[n]],
                            d = function(e) {
                                var i = Array.prototype.slice.call(arguments, 1);
                                if (i.length <= 1 && (i = i[0]), e) {
                                    var s = {};
                                    l(p(r), (function(e) {
                                        s[e] = r[e]
                                    })), s[n] = i, t(e, s), t = function() {}
                                } else r[n] = i, a.setImmediate(c)
                            },
                            h = i.slice(0, Math.abs(i.length - 1)) || [],
                            f = function() {
                                return t = function(e, t) {
                                    return e && r.hasOwnProperty(t)
                                }, i = !0, ((e = h).reduce ? e.reduce(t, i) : (l(e, (function(e, n, r) {
                                    i = t(i, e, n, r)
                                })), i)) && !r.hasOwnProperty(n);
                                var e, t, i
                            };
                        if (f()) i[i.length - 1](d, r);
                        else {
                            var m = function() {
                                f() && (! function(e) {
                                    for (var t = 0; t < s.length; t += 1)
                                        if (s[t] === e) return void s.splice(t, 1)
                                }(m), i[i.length - 1](d, r))
                            };
                            o(m)
                        }
                    }))
                }, a.retry = function(e, t, n) {
                    var i = [];
                    "function" == typeof e && (n = t, t = e, e = 5), e = parseInt(e, 10) || 5;
                    var r = function(r, s) {
                        for (var o = function(e, t) {
                                return function(n) {
                                    e((function(e, i) {
                                        n(!e || t, {
                                            err: e,
                                            result: i
                                        })
                                    }), s)
                                }
                            }; e;) i.push(o(t, !(e -= 1)));
                        a.series(i, (function(e, t) {
                            t = t[t.length - 1], (r || n)(t.err, t.result)
                        }))
                    };
                    return n ? r() : r
                }, a.waterfall = function(e, t) {
                    if (t = t || function() {}, !u(e)) {
                        var n = new Error("First argument to waterfall must be an array of functions");
                        return t(n)
                    }
                    if (!e.length) return t();
                    var i = function(e) {
                        return function(n) {
                            if (n) t.apply(null, arguments), t = function() {};
                            else {
                                var r = Array.prototype.slice.call(arguments, 1),
                                    s = e.next();
                                s ? r.push(i(s)) : r.push(t), a.setImmediate((function() {
                                    e.apply(null, r)
                                }))
                            }
                        }
                    };
                    i(a.iterator(e))()
                };
                var T = function(e, t, n) {
                    if (n = n || function() {}, u(t)) e.map(t, (function(e, t) {
                        e && e((function(e) {
                            var n = Array.prototype.slice.call(arguments, 1);
                            n.length <= 1 && (n = n[0]), t.call(null, e, n)
                        }))
                    }), n);
                    else {
                        var i = {};
                        e.each(p(t), (function(e, n) {
                            t[e]((function(t) {
                                var r = Array.prototype.slice.call(arguments, 1);
                                r.length <= 1 && (r = r[0]), i[e] = r, n(t)
                            }))
                        }), (function(e) {
                            n(e, i)
                        }))
                    }
                };
                a.parallel = function(e, t) {
                    T({
                        map: a.map,
                        each: a.each
                    }, e, t)
                }, a.parallelLimit = function(e, t, n) {
                    T({
                        map: v(t),
                        each: f(t)
                    }, e, n)
                }, a.series = function(e, t) {
                    if (t = t || function() {}, u(e)) a.mapSeries(e, (function(e, t) {
                        e && e((function(e) {
                            var n = Array.prototype.slice.call(arguments, 1);
                            n.length <= 1 && (n = n[0]), t.call(null, e, n)
                        }))
                    }), t);
                    else {
                        var n = {};
                        a.eachSeries(p(e), (function(t, i) {
                            e[t]((function(e) {
                                var r = Array.prototype.slice.call(arguments, 1);
                                r.length <= 1 && (r = r[0]), n[t] = r, i(e)
                            }))
                        }), (function(e) {
                            t(e, n)
                        }))
                    }
                }, a.iterator = function(e) {
                    var t = function(n) {
                        var i = function() {
                            return e.length && e[n].apply(null, arguments), i.next()
                        };
                        return i.next = function() {
                            return n < e.length - 1 ? t(n + 1) : null
                        }, i
                    };
                    return t(0)
                }, a.apply = function(e) {
                    var t = Array.prototype.slice.call(arguments, 1);
                    return function() {
                        return e.apply(null, t.concat(Array.prototype.slice.call(arguments)))
                    }
                };
                var b = function(e, t, n, i) {
                    var r = [];
                    e(t, (function(e, t) {
                        n(e, (function(e, n) {
                            r = r.concat(n || []), t(e)
                        }))
                    }), (function(e) {
                        i(e, r)
                    }))
                };
                a.concat = m(b), a.concatSeries = g(b), a.whilst = function(e, t, n) {
                    e() ? t((function(i) {
                        if (i) return n(i);
                        a.whilst(e, t, n)
                    })) : n()
                }, a.doWhilst = function(e, t, n) {
                    e((function(i) {
                        if (i) return n(i);
                        var r = Array.prototype.slice.call(arguments, 1);
                        t.apply(null, r) ? a.doWhilst(e, t, n) : n()
                    }))
                }, a.until = function(e, t, n) {
                    e() ? n() : t((function(i) {
                        if (i) return n(i);
                        a.until(e, t, n)
                    }))
                }, a.doUntil = function(e, t, n) {
                    e((function(i) {
                        if (i) return n(i);
                        var r = Array.prototype.slice.call(arguments, 1);
                        t.apply(null, r) ? n() : a.doUntil(e, t, n)
                    }))
                }, a.queue = function(e, t) {
                    function n(e, t, n, i) {
                        if (e.started || (e.started = !0), u(t) || (t = [t]), 0 == t.length) return a.setImmediate((function() {
                            e.drain && e.drain()
                        }));
                        l(t, (function(t) {
                            var r = {
                                data: t,
                                callback: "function" == typeof i ? i : null
                            };
                            n ? e.tasks.unshift(r) : e.tasks.push(r), e.saturated && e.tasks.length === e.concurrency && e.saturated(), a.setImmediate(e.process)
                        }))
                    }
                    void 0 === t && (t = 1);
                    var i = 0,
                        r = {
                            tasks: [],
                            concurrency: t,
                            saturated: null,
                            empty: null,
                            drain: null,
                            started: !1,
                            paused: !1,
                            push: function(e, t) {
                                n(r, e, !1, t)
                            },
                            kill: function() {
                                r.drain = null, r.tasks = []
                            },
                            unshift: function(e, t) {
                                n(r, e, !0, t)
                            },
                            process: function() {
                                if (!r.paused && i < r.concurrency && r.tasks.length) {
                                    var t = r.tasks.shift();
                                    r.empty && 0 === r.tasks.length && r.empty(), i += 1;
                                    var n = c((function() {
                                        i -= 1, t.callback && t.callback.apply(t, arguments), r.drain && r.tasks.length + i === 0 && r.drain(), r.process()
                                    }));
                                    e(t.data, n)
                                }
                            },
                            length: function() {
                                return r.tasks.length
                            },
                            running: function() {
                                return i
                            },
                            idle: function() {
                                return r.tasks.length + i === 0
                            },
                            pause: function() {
                                !0 !== r.paused && (r.paused = !0, r.process())
                            },
                            resume: function() {
                                !1 !== r.paused && (r.paused = !1, r.process())
                            }
                        };
                    return r
                }, a.priorityQueue = function(e, t) {
                    function n(e, t) {
                        return e.priority - t.priority
                    }
                    var i = a.queue(e, t);
                    return i.push = function(e, t, r) {
                        ! function(e, t, i, r) {
                            if (e.started || (e.started = !0), u(t) || (t = [t]), 0 == t.length) return a.setImmediate((function() {
                                e.drain && e.drain()
                            }));
                            l(t, (function(t) {
                                var s = {
                                    data: t,
                                    priority: i,
                                    callback: "function" == typeof r ? r : null
                                };
                                e.tasks.splice(function(e, t, n) {
                                    for (var i = -1, r = e.length - 1; i < r;) {
                                        var s = i + (r - i + 1 >>> 1);
                                        n(t, e[s]) >= 0 ? i = s : r = s - 1
                                    }
                                    return i
                                }(e.tasks, s, n) + 1, 0, s), e.saturated && e.tasks.length === e.concurrency && e.saturated(), a.setImmediate(e.process)
                            }))
                        }(i, e, t, r)
                    }, delete i.unshift, i
                }, a.cargo = function(e, t) {
                    var n = !1,
                        i = [],
                        r = {
                            tasks: i,
                            payload: t,
                            saturated: null,
                            empty: null,
                            drain: null,
                            drained: !0,
                            push: function(e, n) {
                                u(e) || (e = [e]), l(e, (function(e) {
                                    i.push({
                                        data: e,
                                        callback: "function" == typeof n ? n : null
                                    }), r.drained = !1, r.saturated && i.length === t && r.saturated()
                                })), a.setImmediate(r.process)
                            },
                            process: function s() {
                                if (!n) {
                                    if (0 === i.length) return r.drain && !r.drained && r.drain(), void(r.drained = !0);
                                    var o = "number" == typeof t ? i.splice(0, t) : i.splice(0, i.length),
                                        a = h(o, (function(e) {
                                            return e.data
                                        }));
                                    r.empty && r.empty(), n = !0, e(a, (function() {
                                        n = !1;
                                        var e = arguments;
                                        l(o, (function(t) {
                                            t.callback && t.callback.apply(null, e)
                                        })), s()
                                    }))
                                }
                            },
                            length: function() {
                                return i.length
                            },
                            running: function() {
                                return n
                            }
                        };
                    return r
                };
                var C = function(e) {
                    return function(t) {
                        var n = Array.prototype.slice.call(arguments, 1);
                        t.apply(null, n.concat([function(t) {
                            var n = Array.prototype.slice.call(arguments, 1);
                            "undefined" != typeof console && (t ? console.error && console.error(t) : console[e] && l(n, (function(t) {
                                console[e](t)
                            })))
                        }]))
                    }
                };
                a.log = C("log"), a.dir = C("dir"), a.memoize = function(e, t) {
                    var n = {},
                        i = {};
                    t = t || function(e) {
                        return e
                    };
                    var r = function() {
                        var r = Array.prototype.slice.call(arguments),
                            s = r.pop(),
                            o = t.apply(null, r);
                        o in n ? a.nextTick((function() {
                            s.apply(null, n[o])
                        })) : o in i ? i[o].push(s) : (i[o] = [s], e.apply(null, r.concat([function() {
                            n[o] = arguments;
                            var e = i[o];
                            delete i[o];
                            for (var t = 0, r = e.length; t < r; t++) e[t].apply(null, arguments)
                        }])))
                    };
                    return r.memo = n, r.unmemoized = e, r
                }, a.unmemoize = function(e) {
                    return function() {
                        return (e.unmemoized || e).apply(null, arguments)
                    }
                }, a.times = function(e, t, n) {
                    for (var i = [], r = 0; r < e; r++) i.push(r);
                    return a.map(i, t, n)
                }, a.timesSeries = function(e, t, n) {
                    for (var i = [], r = 0; r < e; r++) i.push(r);
                    return a.mapSeries(i, t, n)
                }, a.seq = function() {
                    var e = arguments;
                    return function() {
                        var t = this,
                            n = Array.prototype.slice.call(arguments),
                            i = n.pop();
                        a.reduce(e, n, (function(e, n, i) {
                            n.apply(t, e.concat([function() {
                                var e = arguments[0],
                                    t = Array.prototype.slice.call(arguments, 1);
                                i(e, t)
                            }]))
                        }), (function(e, n) {
                            i.apply(t, [e].concat(n))
                        }))
                    }
                }, a.compose = function() {
                    return a.seq.apply(null, Array.prototype.reverse.call(arguments))
                };
                var R = function(e, t) {
                    var n = function() {
                        var n = this,
                            i = Array.prototype.slice.call(arguments),
                            r = i.pop();
                        return e(t, (function(e, t) {
                            e.apply(n, i.concat([t]))
                        }), r)
                    };
                    if (arguments.length > 2) {
                        var i = Array.prototype.slice.call(arguments, 2);
                        return n.apply(this, i)
                    }
                    return n
                };
                a.applyEach = m(R), a.applyEachSeries = g(R), a.forever = function(e, t) {
                    ! function n(i) {
                        if (i) {
                            if (t) return t(i);
                            throw i
                        }
                        e(n)
                    }()
                }, e.exports ? e.exports = a : void 0 === (r = function() {
                    return a
                }.apply(t, [])) || (e.exports = r)
            }()
        }).call(this, n(51), n(145).setImmediate)
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(4),
                r = n(1),
                s = n(11),
                o = n.n(s);
            const a = Object(i.getLogger)(e);
            let c = -1;
            const d = /request id \d+.\d+ got 200/,
                u = /request errored, status: (\d+), number of errors: \d+/;
            t.a = function() {
                r.Strophe.log = function(e, t) {
                    switch (a.trace("Strophe", e, t), "string" == typeof t && -1 !== t.indexOf("Request ") && -1 !== t.indexOf("timed out (secondary), restarting") && (e = r.Strophe.LogLevel.WARN), e) {
                        case r.Strophe.LogLevel.DEBUG:
                            -1 !== c && d.test(t) && (a.debug("Reset lastErrorStatus"), c = -1);
                            break;
                        case r.Strophe.LogLevel.WARN:
                            a.warn(`Strophe: ${t}`);
                            const e = u.exec(t);
                            e && 2 === e.length && (c = parseInt(e[1], 10), a.debug(`lastErrorStatus set to: ${c}`));
                            break;
                        case r.Strophe.LogLevel.ERROR:
                        case r.Strophe.LogLevel.FATAL:
                            t = `Strophe: ${t}`, o.a.callErrorHandler(new Error(t)), a.error(t)
                    }
                }, r.Strophe.getLastErrorStatus = function() {
                    return c
                }, r.Strophe.getStatusString = function(e) {
                    switch (e) {
                        case r.Strophe.Status.BINDREQUIRED:
                            return "BINDREQUIRED";
                        case r.Strophe.Status.ERROR:
                            return "ERROR";
                        case r.Strophe.Status.CONNECTING:
                            return "CONNECTING";
                        case r.Strophe.Status.CONNFAIL:
                            return "CONNFAIL";
                        case r.Strophe.Status.AUTHENTICATING:
                            return "AUTHENTICATING";
                        case r.Strophe.Status.AUTHFAIL:
                            return "AUTHFAIL";
                        case r.Strophe.Status.CONNECTED:
                            return "CONNECTED";
                        case r.Strophe.Status.DISCONNECTED:
                            return "DISCONNECTED";
                        case r.Strophe.Status.DISCONNECTING:
                            return "DISCONNECTING";
                        case r.Strophe.Status.ATTACHED:
                            return "ATTACHED";
                        default:
                            return "unknown"
                    }
                }
            }
        }).call(this, "modules/xmpp/strophe.util.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return p
            }));
            var i = n(4),
                r = n(1),
                s = n(11),
                o = n.n(s),
                a = n(36);
            const c = Object(i.getLogger)(e),
                d = 1e4,
                u = 15e3,
                l = 3,
                h = 12e4 / d;
            class p extends a.b {
                constructor(e) {
                    super(), this.failedPings = 0, this.xmpp = e, this.pingExecIntervals = new Array(h)
                }
                init(e) {
                    super.init(e), r.Strophe.addNamespace("PING", "urn:xmpp:ping")
                }
                ping(e, t, n, i) {
                    this._addPingExecutionTimestamp();
                    const s = Object(r.$iq)({
                        type: "get",
                        to: e
                    });
                    s.c("ping", {
                        xmlns: r.Strophe.NS.PING
                    }), this.connection.sendIQ(s, t, n, i)
                }
                startInterval(e, t = d) {
                    clearInterval(this.intervalId), this.intervalId = window.setInterval(() => {
                        this.ping(e, () => {
                            this.failedPings = 0
                        }, e => {
                            this.failedPings += 1;
                            const t = `Ping ${e?"error":"timeout"}`;
                            this.failedPings >= l ? (o.a.callErrorHandler(new Error(t)), c.error(t, e)) : c.warn(t, e)
                        }, u)
                    }, t), c.info(`XMPP pings will be sent every ${t} ms`)
                }
                stopInterval() {
                    this.intervalId && (window.clearInterval(this.intervalId), this.intervalId = null, this.failedPings = 0, c.info("Ping interval cleared"))
                }
                _addPingExecutionTimestamp() {
                    this.pingExecIntervals.push((new Date).getTime()), this.pingExecIntervals.length > h && this.pingExecIntervals.shift()
                }
                getPingSuspendTime() {
                    const e = this.pingExecIntervals.slice();
                    e.push((new Date).getTime());
                    let t = 0,
                        n = e[0];
                    return e.forEach(e => {
                        const i = e - n;
                        i > t && (t = i), n = e
                    }), t -= d, Math.max(t, 0)
                }
            }
        }).call(this, "modules/xmpp/strophe.ping.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return c
            }));
            var i = n(4),
                r = n(1),
                s = n(36);
            const o = Object(i.getLogger)(e),
                a = "urn:xmpp:rayo:1";
            class c extends s.b {
                init(e) {
                    super.init(e), this.connection.addHandler(this.onRayo.bind(this), a, "iq", "set", null, null)
                }
                onRayo(e) {
                    o.info("Rayo IQ", e)
                }
                dial(e, t, n, i, s) {
                    return new Promise((c, d) => {
                        if (!s) return void d(new Error("Internal error!"));
                        const u = Object(r.$iq)({
                            type: "set",
                            to: s
                        });
                        u.c("dial", {
                            xmlns: a,
                            to: e,
                            from: t
                        }), u.c("header", {
                            name: "JvbRoomName",
                            value: n
                        }).up(), i && i.length && u.c("header", {
                            name: "JvbRoomPassword",
                            value: i
                        }).up(), this.connection.sendIQ(u, e => {
                            o.info("Dial result ", e);
                            const t = $(e).find("ref").attr("uri");
                            this.callResource = t.substr("xmpp:".length), o.info(`Received call resource: ${this.callResource}`), c()
                        }, e => {
                            o.info("Dial error ", e), d(e)
                        })
                    })
                }
                hangup() {
                    return new Promise((e, t) => {
                        if (!this.callResource) return t(new Error("No call in progress")), void o.warn("No call in progress");
                        const n = Object(r.$iq)({
                            type: "set",
                            to: this.callResource
                        });
                        n.c("hangup", {
                            xmlns: a
                        }), this.connection.sendIQ(n, t => {
                            o.info("Hangup result ", t), this.callResource = null, e()
                        }, e => {
                            o.info("Hangup error ", e), this.callResource = null, t(new Error("Hangup error "))
                        })
                    })
                }
            }
        }).call(this, "modules/xmpp/strophe.rayo.js")
    }, function(e, t, n) {
        "use strict";
        var i = n(1),
            r = n(36);
        class s extends r.b {
            constructor() {
                super(), this.log = []
            }
            init(e) {
                super.init(e), this.connection.rawInput = this.logIncoming.bind(this), this.connection.rawOutput = this.logOutgoing.bind(this)
            }
            logIncoming(e) {
                this.log.push([(new Date).getTime(), "incoming", e])
            }
            logOutgoing(e) {
                this.log.push([(new Date).getTime(), "outgoing", e])
            }
        }
        t.a = function() {
            i.Strophe.addConnectionPlugin("logger", new s)
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return a
        }));
        var i = n(2),
            r = n(8),
            s = n.n(r);
        const o = .6;
        class a {
            constructor(e) {
                this.conference = e, e.addEventListener(i.TRACK_AUDIO_LEVEL_CHANGED, this._audioLevel.bind(this)), this.myUserID = this.conference.myUserId()
            }
            _audioLevel(e, t) {
                !this.conference.isP2PActive() || t <= o || e === this.myUserID && this.conference.getLocalAudioTrack().isMuted() || this.conference.rtc.eventEmitter.emit(s.a.DOMINANT_SPEAKER_CHANGED, e)
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return s
        }));
        var i = n(2);
        const r = .6;
        class s {
            constructor(e, t) {
                this._callback = t, this._eventFired = !1, e.statistics.addAudioLevelListener(this._audioLevel.bind(this)), e.on(i.TRACK_MUTE_CHANGED, this._trackMuteChanged.bind(this)), e.on(i.TRACK_ADDED, this._trackAdded.bind(this))
            }
            _audioLevel(e, t, n, i) {
                i && this.audioTrack && !this._eventFired && this.audioTrack.isMuted() && n > r && (this._eventFired = !0, this._callback())
            }
            _isLocalAudioTrack(e) {
                return e.isAudioTrack() && e.isLocal()
            }
            _trackAdded(e) {
                this._isLocalAudioTrack(e) && (this.audioTrack = e)
            }
            _trackMuteChanged(e) {
                this._isLocalAudioTrack(e) && e.isMuted() && (this._eventFired = !1)
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return d
        }));
        var i = n(19),
            r = n(29),
            s = n(20);
        const o = .6,
            a = .9,
            c = 700;
        class d extends i.EventEmitter {
            constructor() {
                super(), this._processing = !1, this._scoreArray = [], this._active = !1, this._calculateVADScore = this._calculateVADScore.bind(this)
            }
            _calculateVADScore() {
                Object(r.a)(this._scoreArray) > o && (this.emit(s.VAD_TALK_WHILE_MUTED), this._setActiveState(!1)), this.reset()
            }
            _setActiveState(e) {
                this._active = e, this.emit(s.DETECTOR_STATE_CHANGE, this._active)
            }
            changeMuteState(e) {
                this._setActiveState(e), this.reset()
            }
            isActive() {
                return this._active
            }
            processVADScore(e) {
                this._active && (this._processing ? this._scoreArray.push(e.score) : e.score > a && (this._processing = !0, this._scoreArray.push(e.score), this._processTimeout = setTimeout(this._calculateVADScore, c)))
            }
            reset() {
                this._processing = !1, this._scoreArray = [], clearTimeout(this._processTimeout)
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return l
        }));
        var i = n(19),
            r = n(29),
            s = n(20);
        const o = .2,
            a = .04,
            c = .2,
            d = .02,
            u = 1500;
        class l extends i.EventEmitter {
            constructor() {
                super(), this._processing = !1, this._scoreArray = [], this._audioLvlArray = [], this._active = !1, this._calculateNoisyScore = this._calculateNoisyScore.bind(this)
            }
            _calculateNoisyScore() {
                const e = Object(r.a)(this._scoreArray),
                    t = Object(r.a)(this._audioLvlArray);
                e < o && t > a && (this.emit(s.VAD_NOISY_DEVICE), this._setActiveState(!1)), this.reset()
            }
            _recordValues(e, t) {
                this._scoreArray.push(e), this._audioLvlArray.push(t)
            }
            _setActiveState(e) {
                this._active = e, this.emit(s.DETECTOR_STATE_CHANGE, this._active)
            }
            changeMuteState(e) {
                this._setActiveState(!e), this.reset()
            }
            isActive() {
                return this._active
            }
            reset() {
                this._processing = !1, this._scoreArray = [], this._audioLvlArray = [], clearTimeout(this._processTimeout)
            }
            processVADScore(e) {
                if (this._active)
                    if (this._processing) {
                        const t = Object(r.b)(e.pcmData);
                        this._recordValues(e.score, Object(r.a)(t))
                    } else if (e.score < c) {
                    const t = Object(r.b)(e.pcmData),
                        n = Object(r.a)(t);
                    n > d && (this._processing = !0, this._recordValues(e.score, n), this._processTimeout = setTimeout(this._calculateNoisyScore, u))
                }
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return c
        }));
        var i = n(19),
            r = n.n(i),
            s = n(2),
            o = n(20);
        const a = 4e3;
        class c extends r.a {
            constructor(e) {
                super(), this._conference = e, this._timeoutTrigger = null, this._hasAudioInput = null, e.statistics.addAudioLevelListener(this._audioLevel.bind(this)), e.on(s.TRACK_ADDED, this._trackAdded.bind(this))
            }
            _clearTriggerTimeout() {
                clearTimeout(this._timeoutTrigger), this._timeoutTrigger = null
            }
            _handleAudioInputStateChange(e) {
                const t = 0 !== e;
                null !== this._hasAudioInput && this._hasAudioInput === t || (this._hasAudioInput = t, this.emit(o.AUDIO_INPUT_STATE_CHANGE, this._hasAudioInput))
            }
            _handleNoAudioInputDetection(e) {
                this._eventFired || (0 !== e || this._timeoutTrigger ? 0 !== e && this._timeoutTrigger && this._clearTriggerTimeout() : this._timeoutTrigger = setTimeout(() => {
                    this._eventFired = !0, this.emit(o.NO_AUDIO_INPUT)
                }, a))
            }
            _audioLevel(e, t, n, i) {
                if (!i || !this._audioTrack) return;
                const r = e.localSSRCs.get(this._audioTrack.rtcId);
                r && r.ssrcs.includes(t) && (this._handleAudioInputStateChange(n), this._handleNoAudioInputDetection(n))
            }
            _trackAdded(e) {
                e.isLocalAudioTrack() && (this._audioTrack = e, this._eventFired = !1, this._clearTriggerTimeout())
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return g
            }));
            var i = n(28),
                r = n(2),
                s = n(4);
            const o = n(0),
                a = n(14),
                c = n(31),
                d = Object(s.getLogger)(e),
                u = "stats",
                l = [{
                    width: 1920,
                    height: 1080,
                    layers: 3,
                    max: 5e3,
                    target: 4e3,
                    min: 800
                }, {
                    width: 1280,
                    height: 720,
                    layers: 3,
                    max: 2500,
                    target: 2500,
                    min: 600
                }, {
                    width: 960,
                    height: 540,
                    layers: 3,
                    max: 900,
                    target: 900,
                    min: 450
                }, {
                    width: 640,
                    height: 360,
                    layers: 2,
                    max: 700,
                    target: 500,
                    min: 150
                }, {
                    width: 480,
                    height: 270,
                    layers: 2,
                    max: 450,
                    target: 350,
                    min: 150
                }, {
                    width: 320,
                    height: 180,
                    layers: 1,
                    max: 200,
                    target: 150,
                    min: 30
                }],
                h = 2500;
            let p = 800,
                f = null;

            function m(e, t, n) {
                if (n < 15e3) return 1;
                let i = 0,
                    r = Math.min(t.height, t.width);
                if (e) {
                    let e = l.find(e => e.height <= r);
                    if (e)
                        for (r = e.height; r >= 180; r /= 2) {
                            const t = r;
                            if (!(e = l.find(e => e.height === t))) break;
                            i += e.target
                        }
                } else {
                    const e = t.width * t.height;
                    i = e <= 76800 ? 600 : e <= 307200 ? 1700 : e <= 518400 ? 2e3 : 2500
                }
                return Math.min(i, function(e) {
                    if (e > 6e4) return Number.MAX_SAFE_INTEGER;
                    return p * Math.pow(1.08, e / 1e3)
                }(Math.max(0, n - 1e3)))
            }
            class g {
                constructor(e, t, n) {
                    this.eventEmitter = t, this._conference = e, this._localStats = {
                        connectionQuality: 100,
                        jvbRTT: void 0
                    }, this._lastConnectionQualityUpdate = -1, this._remoteStats = {}, this._timeIceConnected = -1, this._timeVideoUnmuted = -1, this._timeLastBwCapRemoved = -1, n.config.startBitrate && n.config.startBitrate > 0 && (p = n.config.startBitrate), e.on(r.CONNECTION_INTERRUPTED, () => {
                        this._updateLocalConnectionQuality(0), this.eventEmitter.emit(i.LOCAL_STATS_UPDATED, this._localStats), this._broadcastLocalStats()
                    }), e.room.addListener(o.ICE_CONNECTION_STATE_CHANGED, (e, t) => {
                        e.isP2P || "connected" !== t || (this._timeIceConnected = window.performance.now())
                    }), e.on(r.ENDPOINT_MESSAGE_RECEIVED, (e, t) => {
                        t.type === u && this._updateRemoteStats(e.getId(), t.values)
                    }), e.statistics.addConnectionStatsListener(this._updateLocalStats.bind(this)), e.on(r.TRACK_MUTE_CHANGED, e => {
                        e.isVideoTrack() && (e.isMuted() ? this._timeVideoUnmuted = -1 : this._maybeUpdateUnmuteTime())
                    }), e.on(r.TRACK_ADDED, e => {
                        e.isVideoTrack() && !e.isMuted() && this._maybeUpdateUnmuteTime()
                    }), e.on(r.SERVER_REGION_CHANGED, e => {
                        this._localStats.serverRegion = e
                    }), e.on(r.PROPERTIES_CHANGED, e => {
                        this._localStats.bridgeCount = Number((e || {})["bridge-count"])
                    })
                }
                _maybeUpdateUnmuteTime() {
                    this._timeVideoUnmuted < 0 && (this._timeVideoUnmuted = window.performance.now())
                }
                _calculateConnectionQuality(e, t, n) {
                    const i = c[n];
                    let r, s = 100;
                    if (this._localStats.packetLoss && (r = this._localStats.packetLoss.upload, t && (r *= .5)), t || !i || e === a.DESKTOP || this._timeIceConnected < 0 || this._timeVideoUnmuted < 0) void 0 === r ? (d.error("Cannot calculate connection quality, unknown packet loss."), s = 100) : s = r <= 2 ? 100 : r <= 4 ? 70 : r <= 6 ? 50 : r <= 8 ? 30 : r <= 12 ? 10 : 0;
                    else {
                        const e = this._conference.getActivePeerConnection(),
                            t = Boolean(e && e.isSimulcastOn()),
                            n = e && e.bandwidthLimiter && e.bandwidthLimiter.getBandwidthLimit("video");
                        !n && f && (this._timeLastBwCapRemoved = window.performance.now(), p = f), f = n;
                        let o = m(t, i, window.performance.now() - Math.max(this._timeVideoUnmuted, this._timeIceConnected, this._timeLastBwCapRemoved));
                        o = Math.min(.9 * o, h), f && (o = Math.min(o, f)), s = 100 * this._localStats.bitrate.upload / o, r && r >= 10 && (s = Math.min(s, 30))
                    }
                    if (this._lastConnectionQualityUpdate > 0) {
                        const e = 2,
                            t = this._localStats.connectionQuality,
                            n = (window.performance.now() - this._lastConnectionQualityUpdate) / 1e3;
                        s = Math.min(s, t + n * e)
                    }
                    return Math.min(100, s)
                }
                _updateLocalConnectionQuality(e) {
                    this._localStats.connectionQuality = e, this._lastConnectionQualityUpdate = window.performance.now()
                }
                _broadcastLocalStats() {
                    const e = {
                        bitrate: this._localStats.bitrate,
                        packetLoss: this._localStats.packetLoss,
                        connectionQuality: this._localStats.connectionQuality,
                        jvbRTT: this._localStats.jvbRTT,
                        serverRegion: this._localStats.serverRegion,
                        avgAudioLevels: this._localStats.localAvgAudioLevels
                    };
                    try {
                        this._conference.broadcastEndpointMessage({
                            type: u,
                            values: e
                        })
                    } catch (e) {}
                }
                _updateLocalStats(e, t) {
                    if (!e.isP2P) {
                        const e = t.transport && t.transport.length && t.transport[0].rtt;
                        this._localStats.jvbRTT = e || void 0
                    }
                    if (e !== this._conference.getActivePeerConnection()) return;
                    let n;
                    const r = !this._conference.isConnectionInterrupted(),
                        s = this._conference.getLocalVideoTrack(),
                        o = s ? s.videoType : void 0,
                        a = !s || s.isMuted(),
                        c = s ? s.resolution : null;
                    for (n in a || this._maybeUpdateUnmuteTime(), t) t.hasOwnProperty(n) && (this._localStats[n] = t[n]);
                    r && this._updateLocalConnectionQuality(this._calculateConnectionQuality(o, a, c)), this.eventEmitter.emit(i.LOCAL_STATS_UPDATED, this._localStats), this._broadcastLocalStats()
                }
                _updateRemoteStats(e, t) {
                    this._remoteStats[e] = {
                        bitrate: t.bitrate,
                        packetLoss: t.packetLoss,
                        connectionQuality: t.connectionQuality,
                        jvbRTT: t.jvbRTT,
                        serverRegion: t.serverRegion,
                        avgAudioLevels: t.avgAudioLevels
                    }, this.eventEmitter.emit(i.REMOTE_STATS_UPDATED, e, this._remoteStats[e])
                }
                getStats() {
                    return this._localStats
                }
            }
        }).call(this, "modules/connectivity/ConnectionQuality.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return s
            }));
            var i = n(4);
            const r = Object(i.getLogger)(e);
            class s {
                constructor(e) {
                    this._conference = e
                }
                start(e) {
                    this._conference.xmpp.ping(65e3).then(() => {
                        this._canceled || (this._conference.isJvbConnectionInterrupted ? this._iceFailedTimeout = window.setTimeout(() => {
                            r.info("Sending ICE failed - the connection has not recovered"), this._iceFailedTimeout = void 0, e.sendIceFailedNotification()
                        }, 2e3) : r.info("ICE connection restored - not sending ICE failed"))
                    }, e => {
                        r.error("PING error/timeout - not sending ICE failed", e)
                    })
                }
                cancel() {
                    this._canceled = !0, this._iceFailedTimeout && window.clearTimeout(this._iceFailedTimeout)
                }
            }
        }).call(this, "modules/connectivity/IceFailedNotification.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var i = n(4);
            const r = Object(i.getLogger)(e),
                s = 1,
                o = 12,
                a = {
                    key: 10,
                    delta: 3,
                    undefined: 1
                },
                c = Symbol("kJitsiE2EE");
            class d {
                constructor(e) {
                    this._options = e, this._cryptoKeyRing = new Array(s), this._currentKeyIndex = -1, this._sendCounts = new Map;
                    const t = new TextEncoder;
                    this._salt = t.encode(e.salt)
                }
                handleReceiver(e, t) {
                    if (e[c]) return;
                    const n = "video" === t ? e.createEncodedVideoStreams() : e.createEncodedAudioStreams(),
                        i = new TransformStream({
                            transform: this._decodeFunction.bind(this)
                        });
                    n.readableStream.pipeThrough(i).pipeTo(n.writableStream), e[c] = !0
                }
                handleSender(e, t) {
                    if (e[c]) return;
                    const n = "video" === t ? e.createEncodedVideoStreams() : e.createEncodedAudioStreams(),
                        i = new TransformStream({
                            transform: this._encodeFunction.bind(this)
                        });
                    n.readableStream.pipeThrough(i).pipeTo(n.writableStream), e[c] = !0
                }
                async setKey(e) {
                    let t;
                    if (e) {
                        const n = new TextEncoder;
                        t = await this._deriveKey(n.encode(e))
                    } else t = !1;
                    this._currentKeyIndex++, this._cryptoKeyRing[this._currentKeyIndex % this._cryptoKeyRing.length] = t
                }
                async _deriveKey(e) {
                    const t = await crypto.subtle.importKey("raw", e, "PBKDF2", !1, ["deriveBits", "deriveKey"]);
                    return crypto.subtle.deriveKey({
                        name: "PBKDF2",
                        salt: this._salt,
                        iterations: 1e5,
                        hash: "SHA-256"
                    }, t, {
                        name: "AES-GCM",
                        length: 128
                    }, !1, ["encrypt", "decrypt"])
                }
                _makeIV(e, t) {
                    const n = new ArrayBuffer(o),
                        i = new DataView(n);
                    this._sendCounts.has(e) || this._sendCounts.set(e, Math.floor(65535 * Math.random()));
                    const r = this._sendCounts.get(e);
                    return i.setUint32(0, e), i.setUint32(4, t), i.setUint32(8, r % 65535), this._sendCounts.set(e, r + 1), n
                }
                _encodeFunction(e, t) {
                    const n = this._currentKeyIndex % this._cryptoKeyRing.length;
                    if (this._cryptoKeyRing[n]) {
                        const i = this._makeIV(e.synchronizationSource, e.timestamp);
                        return crypto.subtle.encrypt({
                            name: "AES-GCM",
                            iv: i,
                            additionalData: new Uint8Array(e.data, 0, a[e.type])
                        }, this._cryptoKeyRing[n], new Uint8Array(e.data, a[e.type])).then(r => {
                            const s = new ArrayBuffer(a[e.type] + r.byteLength + i.byteLength + 1),
                                c = new Uint8Array(s);
                            return c.set(new Uint8Array(e.data, 0, a[e.type])), c.set(new Uint8Array(r), a[e.type]), c.set(new Uint8Array(i), a[e.type] + r.byteLength), c[a[e.type] + r.byteLength + o] = n, e.data = s, t.enqueue(e)
                        }, e => {
                            r.error(e)
                        })
                    }
                    t.enqueue(e)
                }
                _decodeFunction(e, t) {
                    const n = new Uint8Array(e.data)[e.data.byteLength - 1];
                    if (this._cryptoKeyRing[n]) {
                        const i = new Uint8Array(e.data, e.data.byteLength - o - 1, o),
                            s = a[e.type],
                            c = e.data.byteLength - (a[e.type] + o + 1);
                        return crypto.subtle.decrypt({
                            name: "AES-GCM",
                            iv: i,
                            additionalData: new Uint8Array(e.data, 0, a[e.type])
                        }, this._cryptoKeyRing[n], new Uint8Array(e.data, s, c)).then(n => {
                            const i = new ArrayBuffer(a[e.type] + n.byteLength),
                                r = new Uint8Array(i);
                            return r.set(new Uint8Array(e.data, 0, a[e.type])), r.set(new Uint8Array(n), a[e.type]), e.data = i, t.enqueue(e)
                        }, n => {
                            if (r.error(n, e.type), void 0 === e.type) {
                                const t = new ArrayBuffer(3);
                                new Uint8Array(t).set([216, 255, 254]), e.data = t
                            } else {
                                const t = new ArrayBuffer(60);
                                new Uint8Array(t).set([176, 5, 0, 157, 1, 42, 160, 0, 90, 0, 57, 3, 0, 0, 28, 34, 22, 22, 34, 102, 18, 32, 4, 144, 64, 0, 197, 1, 224, 124, 77, 47, 250, 221, 77, 165, 127, 137, 165, 255, 91, 169, 180, 175, 241, 52, 191, 235, 117, 54, 149, 254, 38, 150, 96, 254, 255, 186, 255, 64]), e.data = t
                            }
                            t.enqueue(e)
                        })
                    }
                    t.enqueue(e)
                }
            }
        }).call(this, "modules/e2ee/E2EEContext.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return h
            }));
            var i = n(4),
                r = n(7),
                s = n(57),
                o = n(2),
                a = n(5);
            const c = Object(i.getLogger)(e),
                d = "e2e-ping-request",
                u = "e2e-ping-response";
            class l {
                constructor(e, t) {
                    this.participant = e, this.e2eping = t, this.id = e.getId(), this.requests = {}, this.lastRequestId = 1, this.clearIntervals = this.clearIntervals.bind(this), this.sendRequest = this.sendRequest.bind(this), this.handleResponse = this.handleResponse.bind(this), this.maybeSendAnalytics = this.maybeSendAnalytics.bind(this), this.sendAnalytics = this.sendAnalytics.bind(this), t.isDataChannelOpen && this.sendRequest(), this.pingInterval = window.setInterval(this.sendRequest, t.pingIntervalMs), this.analyticsInterval = window.setTimeout(this.maybeSendAnalytics, this.e2eping.analyticsIntervalMs)
                }
                clearIntervals() {
                    this.pingInterval && window.clearInterval(this.pingInterval), this.analyticsInterval && window.clearInterval(this.analyticsInterval)
                }
                sendRequest() {
                    const e = this.lastRequestId++,
                        t = {
                            type: d,
                            id: e
                        };
                    this.e2eping.sendMessage(t, this.id), this.requests[e] = {
                        id: e,
                        timeSent: window.performance.now()
                    }
                }
                handleResponse(e) {
                    const t = this.requests[e.id];
                    t && (t.rtt = window.performance.now() - t.timeSent, this.e2eping.eventEmitter.emit(s.E2E_RTT_CHANGED, this.participant, t.rtt)), this.maybeSendAnalytics()
                }
                maybeSendAnalytics() {
                    const e = window.performance.now();
                    let t, n, i = 1 / 0;
                    for (n in this.requests) this.requests.hasOwnProperty(n) && ((t = this.requests[n]).timeSent < e - this.e2eping.analyticsIntervalMs ? delete this.requests[n] : t.rtt && (i = Math.min(i, t.rtt)));
                    i < 1 / 0 && this.sendAnalytics(i)
                }
                sendAnalytics(e) {
                    a.a.sendAnalytics(Object(r.D)(this.id, this.participant.getProperty("region"), e))
                }
            }
            class h {
                constructor(e, t, n) {
                    this.conference = e, this.eventEmitter = e.eventEmitter, this.sendMessage = n, this.pingIntervalMs = 1e4, this.analyticsIntervalMs = 6e4, this.participants = {}, this.isDataChannelOpen = !1, t && t.e2eping && ("number" == typeof t.e2eping.pingInterval && (this.pingIntervalMs = t.e2eping.pingInterval), "number" == typeof t.e2eping.analyticsInterval && (this.analyticsIntervalMs = t.e2eping.analyticsInterval), this.analyticsIntervalMs > 0 && this.analyticsIntervalMs < this.pingIntervalMs && (this.analyticsIntervalMs = this.pingIntervalMs)), c.info(`Initializing e2e ping; pingInterval=${this.pingIntervalMs}, analyticsInterval=${this.analyticsIntervalMs}.`), this.participantJoined = this.participantJoined.bind(this), e.on(o.USER_JOINED, this.participantJoined), this.participantLeft = this.participantLeft.bind(this), e.on(o.USER_LEFT, this.participantLeft), this.messageReceived = this.messageReceived.bind(this), e.on(o.ENDPOINT_MESSAGE_RECEIVED, this.messageReceived), this.dataChannelOpened = this.dataChannelOpened.bind(this), e.on(o.DATA_CHANNEL_OPENED, this.dataChannelOpened)
                }
                dataChannelOpened() {
                    this.isDataChannelOpen = !0;
                    for (const e in this.participants)
                        if (this.participants.hasOwnProperty(e)) {
                            const t = this.participants[e];
                            window.setTimeout(t.sendRequest, 200)
                        }
                }
                messageReceived(e, t) {
                    t.type === d ? this.handleRequest(e.getId(), t) : t.type === u && this.handleResponse(e.getId(), t)
                }
                participantJoined(e, t) {
                    this.pingIntervalMs <= 0 || (this.participants[e] && (c.info(`Participant wrapper already exists for ${e}. Clearing.`), this.participants[e].clearIntervals(), delete this.participants[e]), this.participants[e] = new l(t, this))
                }
                participantLeft(e) {
                    this.pingIntervalMs <= 0 || this.participants[e] && (this.participants[e].clearIntervals(), delete this.participants[e])
                }
                handleRequest(e, t) {
                    if (t && t.id) {
                        const n = {
                            type: u,
                            id: t.id
                        };
                        this.sendMessage(n, e)
                    } else c.info(`Received an invalid e2e ping request from ${e}.`)
                }
                handleResponse(e, t) {
                    const n = this.participants[e];
                    n && n.handleResponse(t)
                }
                stop() {
                    c.info("Stopping e2eping"), this.conference.off(o.USER_JOINED, this.participantJoined), this.conference.off(o.USER_LEFT, this.participantLeft), this.conference.off(o.ENDPOINT_MESSAGE_RECEIVED, this.messageReceived), this.conference.off(o.DATA_CHANNEL_OPENED, this.dataChannelOpened);
                    for (const e in this.participants) this.participants.hasOwnProperty(e) && this.participants[e].clearIntervals();
                    this.participants = {}
                }
            }
        }).call(this, "modules/e2eping/e2eping.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return o
            }));
            var i = n(4),
                r = n(2);
            const s = Object(i.getLogger)(e);
            class o {
                constructor(e) {
                    this._conference = e, this._jvb121 = !0, this._conference.addEventListener(r.USER_JOINED, () => this.evaluateStatus()), this._conference.addEventListener(r.USER_LEFT, () => this.evaluateStatus()), this._conference.addEventListener(r.P2P_STATUS, () => this.evaluateStatus())
                }
                evaluateStatus() {
                    const e = this._jvb121,
                        t = !this._conference.isP2PActive() && this._conference.getParticipantCount() <= 2;
                    e !== t && (this._jvb121 = t, s.debug(`JVB121 status ${e} => ${t}`), this._conference.eventEmitter.emit(r.JVB121_STATUS, e, t))
                }
            }
        }).call(this, "modules/event/Jvb121EventGenerator.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(4),
                r = n(0),
                s = n.n(r),
                o = n(67),
                a = n(46);

            function c(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const d = Object(i.getLogger)(e);
            t.a = class {
                constructor(e) {
                    this._sessions = {}, this._chatRoom = e, this.onPresence = this.onPresence.bind(this), this._chatRoom.eventEmitter.addListener(s.a.PRESENCE_RECEIVED, this.onPresence)
                }
                getSession(e) {
                    return this._sessions[e]
                }
                onPresence({
                    fromHiddenDomain: e,
                    presence: t
                }) {
                    a.a.isFromFocus(t) ? this._handleFocusPresence(t) : e && this._handleJibriPresence(t)
                }
                startRecording(e) {
                    const t = new o.a(function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? arguments[t] : {},
                                i = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), i.forEach((function(t) {
                                c(e, t, n[t])
                            }))
                        }
                        return e
                    }({}, e, {
                        connection: this._chatRoom.connection
                    }));
                    return t.start({
                        appData: e.appData,
                        broadcastId: e.broadcastId,
                        focusMucJid: this._chatRoom.focusMucJid,
                        streamId: e.streamId
                    }).then(() => (this.getSession(t.getID()) || (this._addSession(t), this._emitSessionUpdate(t)), t)).catch(e => (this._emitSessionUpdate(t), Promise.reject(e)))
                }
                stopRecording(e) {
                    const t = this.getSession(e);
                    return t ? t.stop({
                        focusMucJid: this._chatRoom.focusMucJid
                    }) : Promise.reject(new Error("Could not find session"))
                }
                _addSession(e) {
                    this._sessions[e.getID()] = e
                }
                _createSession(e, t, n) {
                    const i = new o.a({
                        connection: this._chatRoom.connection,
                        focusMucJid: this._chatRoom.focusMucJid,
                        mode: n,
                        sessionID: e,
                        status: t
                    });
                    return this._addSession(i), i
                }
                _emitSessionUpdate(e, t) {
                    this._chatRoom.eventEmitter.emit(s.a.RECORDER_STATE_CHANGED, e, t)
                }
                _handleFocusPresence(e) {
                    const t = a.a.getFocusRecordingUpdate(e);
                    if (!t) return;
                    const {
                        error: n,
                        initiator: i,
                        recordingMode: r,
                        sessionID: s,
                        status: o
                    } = t;
                    let c = this.getSession(s);
                    c || "off" !== o ? c && c.getStatus() === o && c.getError() === n ? d.warn("Ignoring duplicate presence update: ", JSON.stringify(t)) : (c || (c = this._createSession(s, o, r)), c.setStatus(o), n && c.setError(n), this._emitSessionUpdate(c, i)) : d.warn("Ignoring recording presence update", "Received a new session with status off.")
                }
                _handleJibriPresence(e) {
                    const {
                        liveStreamViewURL: t,
                        mode: n,
                        sessionID: i
                    } = a.a.getHiddenDomainUpdate(e);
                    if (!i) return void d.warn("Ignoring potential jibri presence due to no session id.");
                    let r = this.getSession(i);
                    r || (r = this._createSession(i, "", n)), r.setLiveStreamViewURL(t), this._emitSessionUpdate(r)
                }
            }
        }).call(this, "modules/recording/RecordingManager.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return h
            }));
            var i = n(3),
                r = n(7),
                s = n(4),
                o = n(10),
                a = n(5);
            const c = Object(s.getLogger)(e),
                d = {
                    offerToReceiveAudio: 1,
                    offerToReceiveVideo: 0
                },
                u = 1e4;
            class l {
                constructor(e, t, n, i) {
                    this.region = e, this.getStatsIntervalMs = n, this.getStatsInterval = null, this.rtt = 1 / 0, this.rtts = [];
                    const r = [{
                        url: `stun:${t}`
                    }];
                    this.pc = new o.a.RTCPeerConnectionType({
                        iceServers: r
                    }), this.candidates = {}, this.stopped = !1, this.start = this.start.bind(this), this.stop = this.stop.bind(this), this.startStatsInterval = this.startStatsInterval.bind(this), this.handleCandidateRtt = this.handleCandidateRtt.bind(this), window.setTimeout(this.start, i)
                }
                start() {
                    this.stopped || this.pc.createOffer(d).then(e => {
                        this.pc.setLocalDescription(e, () => {
                            c.info(`setLocalDescription success for ${this.region}`), this.startStatsInterval()
                        }, e => {
                            c.warn(`setLocalDescription failed for ${this.region}: ${e}`)
                        })
                    })
                }
                startStatsInterval() {
                    this.getStatsInterval = window.setInterval(() => {
                        this.pc.getStats(e => {
                            const t = e.result();
                            for (let e = 0; e < t.length; ++e) {
                                const n = t[e],
                                    i = Number(n.stat("stunKeepaliveRttTotal"));
                                if (i > 0) {
                                    const e = `${n.stat("ipAddress")}_${n.stat("portNumber")}_${n.stat("priority")}`;
                                    this.handleCandidateRtt(e, i, Number(n.stat("stunKeepaliveResponsesReceived")), Number(n.stat("stunKeepaliveRequestsSent")))
                                }
                            }
                            let n = 1 / 0;
                            for (const e in this.candidates) this.candidates.hasOwnProperty(e) && this.candidates[e].rtt > 0 && (n = Math.min(n, this.candidates[e].rtt));
                            this.rtts.push(n), this.rtts.length > 6 && (this.rtts = this.rtts.splice(1, 7)), this.rtt = Math.min(...this.rtts)
                        })
                    }, this.getStatsIntervalMs)
                }
                handleCandidateRtt(e, t, n, i) {
                    this.candidates[e] || (this.candidates[e] = {
                        rttTotal: 0,
                        responsesReceived: 0,
                        requestsSent: 0,
                        rtt: NaN
                    });
                    const r = t - this.candidates[e].rttTotal,
                        s = n - this.candidates[e].responsesReceived,
                        o = i - n - (this.candidates[e].requestsSent - this.candidates[e].responsesReceived);
                    let a = NaN;
                    s > 0 && 0 === o && (a = r / s), this.candidates[e].rttTotal = t, this.candidates[e].responsesReceived = n, this.candidates[e].requestsSent = i, this.candidates[e].rtt = a
                }
                stop() {
                    this.getStatsInterval && window.clearInterval(this.getStatsInterval), this.pc.close(), this.stopped = !0
                }
            }
            class h {
                constructor(e) {
                    if (!e || !e.enabled || !i.a.supportsLocalCandidateRttStatistics()) return;
                    this.pcMonitors = {}, this.startPCMonitors = this.startPCMonitors.bind(this), this.sendAnalytics = this.sendAnalytics.bind(this), this.stop = this.stop.bind(this), this.analyticsInterval = null, this.stopped = !1;
                    const t = e.initialDelay || 6e4;
                    c.info(`Starting RTT monitor with an initial delay of ${t}`), window.setTimeout(() => this.startPCMonitors(e), t)
                }
                startPCMonitors(e) {
                    if (!e.stunServers) return void c.warn("No stun servers configured.");
                    if (this.stopped) return;
                    const t = e.getStatsInterval || u,
                        n = e.analyticsInterval || t,
                        i = t / Object.keys(e.stunServers).length;
                    let r = 0;
                    for (const n in e.stunServers)
                        if (e.stunServers.hasOwnProperty(n)) {
                            const s = e.stunServers[n];
                            this.pcMonitors[n] = new l(n, s, t, i * r), r++
                        } window.setTimeout(() => {
                        this.stopped || (this.analyticsInterval = window.setInterval(this.sendAnalytics, n))
                    }, 1e3)
                }
                sendAnalytics() {
                    const e = {};
                    for (const t in this.pcMonitors)
                        if (this.pcMonitors.hasOwnProperty(t)) {
                            const n = this.pcMonitors[t].rtt;
                            isNaN(n) || n === 1 / 0 || (e[t.replace("-", "_")] = n)
                        } e && a.a.sendAnalytics(Object(r.M)(e))
                }
                stop() {
                    c.info("Stopping RttMonitor."), this.stopped = !0;
                    for (const e in this.pcMonitors) this.pcMonitors.hasOwnProperty(e) && this.pcMonitors[e].stop();
                    this.pcMonitors = {}, this.analyticsInterval && window.clearInterval(this.analyticsInterval)
                }
            }
        }).call(this, "modules/rttmonitor/rttmonitor.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return g
            }));
            var i = n(58),
                r = n.n(i),
                s = n(7),
                o = n(4),
                a = n(28),
                c = n(2),
                d = n(9),
                u = n(3),
                l = n(5),
                h = n(14);
            const p = Object(o.getLogger)(e);
            class f {
                constructor(e) {
                    this.name = e, this.count = 0, this.sum = 0, this.samples = []
                }
                addNext(e) {
                    "number" != typeof e ? p.error(`${this.name} - invalid value for idx: ${this.count}`, e) : isNaN(e) || (this.sum += e, this.samples.push(e), this.count += 1)
                }
                calculate() {
                    return this.sum / this.count
                }
                appendReport(e) {
                    e[`${this.name}_avg`] = this.calculate(), e[`${this.name}_samples`] = JSON.stringify(this.samples)
                }
                reset() {
                    this.samples = [], this.sum = 0, this.count = 0
                }
            }
            class m {
                constructor(e, t, n) {
                    this.isP2P = t, this._n = n, this._sampleIdx = 0, this._avgRTT = new f("rtt"), this._avgRemoteRTTMap = new Map, this._avgRtpStatsReporter = e, this._avgEnd2EndRTT = void 0, this._onConnectionStats = (e, t) => {
                        this.isP2P === e.isP2P && this._calculateAvgStats(t)
                    };
                    const i = e._conference;
                    i.statistics.addConnectionStatsListener(this._onConnectionStats), this.isP2P || (this._onUserLeft = e => this._avgRemoteRTTMap.delete(e), i.on(c.USER_LEFT, this._onUserLeft), this._onRemoteStatsUpdated = (e, t) => this._processRemoteStats(e, t), i.on(a.REMOTE_STATS_UPDATED, this._onRemoteStatsUpdated))
                }
                _calculateAvgStats(e) {
                    if (e) {
                        if (u.a.supportsRTTStatistics() && e.transport && e.transport.length && this._avgRTT.addNext(e.transport[0].rtt), this._sampleIdx += 1, this._sampleIdx >= this._n) {
                            if (u.a.supportsRTTStatistics()) {
                                const t = this._avgRtpStatsReporter._conference,
                                    n = {
                                        p2p: this.isP2P,
                                        conference_size: t.getParticipantCount()
                                    };
                                if (e.transport && e.transport.length && Object.assign(n, {
                                        local_candidate_type: e.transport[0].localCandidateType,
                                        remote_candidate_type: e.transport[0].remoteCandidateType,
                                        transport_type: e.transport[0].type
                                    }), this._avgRTT.appendReport(n), this.isP2P) {
                                    const e = this._avgRtpStatsReporter.jvbStatsMonitor._avgEnd2EndRTT;
                                    isNaN(e) || (n.rtt_diff = this._avgRTT.calculate() - e)
                                } else {
                                    const e = this._calculateAvgRemoteRTT(),
                                        t = this._avgRTT.calculate();
                                    this._avgEnd2EndRTT = t + e, isNaN(t) || isNaN(e) || (n.end2end_rtt_avg = this._avgEnd2EndRTT)
                                }
                                l.a.sendAnalytics(Object(s.L)(n))
                            }
                            this._resetAvgStats()
                        }
                    } else p.error("No stats")
                }
                _calculateAvgRemoteRTT() {
                    let e = 0,
                        t = 0;
                    for (const n of this._avgRemoteRTTMap.values()) {
                        const i = n.calculate();
                        isNaN(i) || (t += i, e += 1, n.reset())
                    }
                    return t / e
                }
                _processRemoteStats(e, t) {
                    const n = "number" == typeof t.jvbRTT;
                    let i = this._avgRemoteRTTMap.get(e);
                    !i && n && (i = new f(`${e}_stat_rtt`), this._avgRemoteRTTMap.set(e, i)), n ? i.addNext(t.jvbRTT) : i && this._avgRemoteRTTMap.delete(e)
                }
                _resetAvgStats() {
                    this._avgRTT.reset(), this._avgRemoteRTTMap && this._avgRemoteRTTMap.clear(), this._sampleIdx = 0
                }
                dispose() {
                    const e = this._avgRtpStatsReporter._conference;
                    e.statistics.removeConnectionStatsListener(this._onConnectionStats), this.isP2P || (e.off(a.REMOTE_STATS_UPDATED, this._onRemoteStatsUpdated), e.off(c.USER_LEFT, this._onUserLeft))
                }
            }
            class g {
                constructor(e, t) {
                    this._n = t, t > 0 ? (p.info(`Avg RTP stats will be calculated every ${t} samples`), this._sampleIdx = 0, this._conference = e, this._avgAudioBitrateUp = new f("bitrate_audio_upload"), this._avgAudioBitrateDown = new f("bitrate_audio_download"), this._avgVideoBitrateUp = new f("bitrate_video_upload"), this._avgVideoBitrateDown = new f("bitrate_video_download"), this._avgBandwidthUp = new f("bandwidth_upload"), this._avgBandwidthDown = new f("bandwidth_download"), this._avgPacketLossTotal = new f("packet_loss_total"), this._avgPacketLossUp = new f("packet_loss_upload"), this._avgPacketLossDown = new f("packet_loss_download"), this._avgRemoteFPS = new f("framerate_remote"), this._avgRemoteScreenFPS = new f("framerate_screen_remote"), this._avgLocalFPS = new f("framerate_local"), this._avgLocalScreenFPS = new f("framerate_screen_local"), this._avgRemoteCameraPixels = new f("pixels_remote"), this._avgRemoteScreenPixels = new f("pixels_screen_remote"), this._avgLocalCameraPixels = new f("pixels_local"), this._avgLocalScreenPixels = new f("pixels_screen_local"), this._avgCQ = new f("connection_quality"), this._cachedTransportStats = void 0, this._onLocalStatsUpdated = e => {
                        this._calculateAvgStats(e), this._maybeSendTransportAnalyticsEvent(e)
                    }, e.on(a.LOCAL_STATS_UPDATED, this._onLocalStatsUpdated), this._onP2PStatusChanged = () => {
                        p.debug("Resetting average stats calculation"), this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats(), this.p2pStatsMonitor._resetAvgStats()
                    }, e.on(c.P2P_STATUS, this._onP2PStatusChanged), this._onJvb121StatusChanged = (e, t) => {
                        !0 === t && (p.info("Resetting JVB avg RTP stats"), this._resetAvgJvbStats())
                    }, e.on(c.JVB121_STATUS, this._onJvb121StatusChanged), this.jvbStatsMonitor = new m(this, !1, t), this.p2pStatsMonitor = new m(this, !0, t)) : p.info("Avg RTP stats reports are disabled.")
                }
                _calculateAvgStats(e) {
                    if (!e) return void p.error("No stats");
                    const t = this._conference.isP2PActive(),
                        n = this._conference.getParticipantCount();
                    if (!t && n < 2) return;
                    const i = e.bitrate,
                        r = e.bandwidth,
                        o = e.packetLoss,
                        a = e.framerate,
                        c = e.resolution;
                    if (i)
                        if (r)
                            if (o)
                                if (a)
                                    if (c) {
                                        if (this._avgAudioBitrateUp.addNext(i.audio.upload), this._avgAudioBitrateDown.addNext(i.audio.download), this._avgVideoBitrateUp.addNext(i.video.upload), this._avgVideoBitrateDown.addNext(i.video.download), u.a.supportsBandwidthStatistics() && (this._avgBandwidthUp.addNext(r.upload), this._avgBandwidthDown.addNext(r.download)), this._avgPacketLossUp.addNext(o.upload), this._avgPacketLossDown.addNext(o.download), this._avgPacketLossTotal.addNext(o.total), this._avgCQ.addNext(e.connectionQuality), a && (this._avgRemoteFPS.addNext(this._calculateAvgVideoFps(a, !1, h.CAMERA)), this._avgRemoteScreenFPS.addNext(this._calculateAvgVideoFps(a, !1, h.DESKTOP)), this._avgLocalFPS.addNext(this._calculateAvgVideoFps(a, !0, h.CAMERA)), this._avgLocalScreenFPS.addNext(this._calculateAvgVideoFps(a, !0, h.DESKTOP))), c && (this._avgRemoteCameraPixels.addNext(this._calculateAvgVideoPixels(c, !1, h.CAMERA)), this._avgRemoteScreenPixels.addNext(this._calculateAvgVideoPixels(c, !1, h.DESKTOP)), this._avgLocalCameraPixels.addNext(this._calculateAvgVideoPixels(c, !0, h.CAMERA)), this._avgLocalScreenPixels.addNext(this._calculateAvgVideoPixels(c, !0, h.DESKTOP))), this._sampleIdx += 1, this._sampleIdx >= this._n) {
                                            const i = {
                                                p2p: t,
                                                conference_size: n
                                            };
                                            e.transport && e.transport.length && Object.assign(i, {
                                                local_candidate_type: e.transport[0].localCandidateType,
                                                remote_candidate_type: e.transport[0].remoteCandidateType,
                                                transport_type: e.transport[0].type
                                            }), this._avgAudioBitrateUp.appendReport(i), this._avgAudioBitrateDown.appendReport(i), this._avgVideoBitrateUp.appendReport(i), this._avgVideoBitrateDown.appendReport(i), u.a.supportsBandwidthStatistics() && (this._avgBandwidthUp.appendReport(i), this._avgBandwidthDown.appendReport(i)), this._avgPacketLossUp.appendReport(i), this._avgPacketLossDown.appendReport(i), this._avgPacketLossTotal.appendReport(i), this._avgRemoteFPS.appendReport(i), isNaN(this._avgRemoteScreenFPS.calculate()) || this._avgRemoteScreenFPS.appendReport(i), this._avgLocalFPS.appendReport(i), isNaN(this._avgLocalScreenFPS.calculate()) || this._avgLocalScreenFPS.appendReport(i), this._avgRemoteCameraPixels.appendReport(i), isNaN(this._avgRemoteScreenPixels.calculate()) || this._avgRemoteScreenPixels.appendReport(i), this._avgLocalCameraPixels.appendReport(i), isNaN(this._avgLocalScreenPixels.calculate()) || this._avgLocalScreenPixels.appendReport(i), this._avgCQ.appendReport(i), l.a.sendAnalytics(Object(s.L)(i)), this._resetAvgStats()
                                        }
                                    } else p.error("No resolution");
                    else p.error('No "framerate"');
                    else p.error('No "packetloss"');
                    else p.error('No "bandwidth"');
                    else p.error('No "bitrate"')
                }
                _calculateAvgVideoPixels(e, t, n) {
                    let i = 0,
                        r = 0;
                    const s = this._conference.myUserId();
                    for (const o of Object.keys(e))
                        if (t ? o === s : o !== s) {
                            const s = t ? null : this._conference.getParticipantById(o),
                                a = e[o];
                            if ((t || s) && a) {
                                const e = this._calculatePeerAvgVideoPixels(a, s, n);
                                isNaN(e) || (i += e, r += 1)
                            }
                        } return i / r
                }
                _calculatePeerAvgVideoPixels(e, t, n) {
                    let i = Object.keys(e).map(e => Number(e)),
                        r = null;
                    const s = this._conference.getActivePeerConnection();
                    t ? (r = t.getTracksByMediaType(d.c)) && (i = i.filter(e => r.find(t => !t.isMuted() && t.getSSRC() === e && t.videoType === n))) : (r = this._conference.getLocalTracks(d.c), i = i.filter(e => r.find(t => !t.isMuted() && s.getLocalSSRC(t) === e && t.videoType === n)));
                    let o = 0,
                        a = 0;
                    for (const t of i) {
                        const n = Number(e[t].height) * Number(e[t].width);
                        !isNaN(n) && n > 0 && (o += n, a += 1)
                    }
                    return o / a
                }
                _calculateAvgVideoFps(e, t, n) {
                    let i = 0,
                        r = 0;
                    const s = this._conference.myUserId();
                    for (const o of Object.keys(e))
                        if (t ? o === s : o !== s) {
                            const s = t ? null : this._conference.getParticipantById(o),
                                a = e[o];
                            if ((t || s) && a) {
                                const e = this._calculatePeerAvgVideoFps(a, s, n);
                                isNaN(e) || (i += e, r += 1)
                            }
                        } return i / r
                }
                _calculatePeerAvgVideoFps(e, t, n) {
                    let i = Object.keys(e).map(e => Number(e)),
                        r = null;
                    const s = this._conference.getActivePeerConnection();
                    t ? (r = t.getTracksByMediaType(d.c)) && (i = i.filter(e => r.find(t => !t.isMuted() && t.getSSRC() === e && t.videoType === n))) : (r = this._conference.getLocalTracks(d.c), i = i.filter(e => r.find(t => !t.isMuted() && s.getLocalSSRC(t) === e && t.videoType === n)));
                    let o = 0,
                        a = 0;
                    for (const t of i) {
                        const n = Number(e[t]);
                        !isNaN(n) && n > 0 && (o += n, a += 1)
                    }
                    return o / a
                }
                _maybeSendTransportAnalyticsEvent(e) {
                    if (!e || !e.transport || !e.transport.length) return;
                    const t = {
                        p2p: e.transport[0].p2p,
                        local_candidate_type: e.transport[0].localCandidateType,
                        remote_candidate_type: e.transport[0].remoteCandidateType,
                        transport_type: e.transport[0].type
                    };
                    this._cachedTransportStats && r()(t, this._cachedTransportStats) || (this._cachedTransportStats = t, l.a.sendAnalytics(Object(s.N)(t)))
                }
                _resetAvgJvbStats() {
                    this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats()
                }
                _resetAvgStats() {
                    this._avgAudioBitrateUp.reset(), this._avgAudioBitrateDown.reset(), this._avgVideoBitrateUp.reset(), this._avgVideoBitrateDown.reset(), this._avgBandwidthUp.reset(), this._avgBandwidthDown.reset(), this._avgPacketLossUp.reset(), this._avgPacketLossDown.reset(), this._avgPacketLossTotal.reset(), this._avgRemoteFPS.reset(), this._avgRemoteScreenFPS.reset(), this._avgLocalFPS.reset(), this._avgLocalScreenFPS.reset(), this._avgRemoteCameraPixels.reset(), this._avgRemoteScreenPixels.reset(), this._avgLocalCameraPixels.reset(), this._avgLocalScreenPixels.reset(), this._avgCQ.reset(), this._sampleIdx = 0
                }
                dispose() {
                    this._conference.off(c.P2P_STATUS, this._onP2PStatusChanged), this._conference.off(a.LOCAL_STATS_UPDATED, this._onLocalStatsUpdated), this._conference.off(c.JVB121_STATUS, this._onJvb121StatusChanged), this.jvbStatsMonitor.dispose(), this.p2pStatsMonitor.dispose()
                }
            }
        }).call(this, "modules/statistics/AvgRTPStatsReporter.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return l
            }));
            var i = n(4),
                r = n(2),
                s = n(28),
                o = n(9),
                a = n(7),
                c = n(5);
            const d = Object(i.getLogger)(e),
                u = 2;
            class l {
                constructor(e) {
                    this._conference = e, this._localAudioLevelCache = {}, this._reportedParticipants = [], this._audioProblemCandidates = {}, this._numberOfRemoteAudioLevelsReceived = {}, this._onLocalAudioLevelsReport = this._onLocalAudioLevelsReport.bind(this), this._onRemoteAudioLevelReceived = this._onRemoteAudioLevelReceived.bind(this), this._clearUserData = this._clearUserData.bind(this), this._conference.on(s.REMOTE_STATS_UPDATED, this._onRemoteAudioLevelReceived), this._conference.statistics.addConnectionStatsListener(this._onLocalAudioLevelsReport), this._conference.on(r.USER_LEFT, this._clearUserData)
                }
                _onRemoteAudioLevelReceived(e, {
                    avgAudioLevels: t
                }) {
                    const n = this._numberOfRemoteAudioLevelsReceived[e] + 1 || 0;
                    if (this._numberOfRemoteAudioLevelsReceived[e] = n, -1 !== this._reportedParticipants.indexOf(e) || e in this._audioProblemCandidates || t <= 0 || n < 3) return;
                    const i = this._conference.getParticipantById(e);
                    if (i) {
                        if (i.getTracksByMediaType(o.a).length > 0 && i.isAudioMuted()) return
                    }
                    const r = this._localAudioLevelCache[e];
                    Array.isArray(r) && !r.every(e => 0 === e) || (this._audioProblemCandidates[e] = {
                        remoteAudioLevels: t,
                        localAudioLevels: []
                    })
                }
                _onLocalAudioLevelsReport(e, {
                    avgAudioLevels: t
                }) {
                    e === this._conference.getActivePeerConnection() && (Object.keys(t).forEach(e => {
                        if (-1 !== this._reportedParticipants.indexOf(e)) return;
                        const n = this._localAudioLevelCache[e];
                        Array.isArray(n) ? n.length >= u && n.shift() : this._localAudioLevelCache[e] = [], this._localAudioLevelCache[e].push(t[e])
                    }), Object.keys(this._audioProblemCandidates).forEach(e => {
                        const {
                            localAudioLevels: n,
                            remoteAudioLevels: i
                        } = this._audioProblemCandidates[e];
                        if (n.push(t[e]), n.length === u) {
                            if (n.every(e => void 0 === e || 0 === e)) {
                                const t = JSON.stringify(n);
                                c.a.sendAnalytics(Object(a.x)(e, t, i)), d.warn(`A potential problem is detected with the audio output for participant ${e}, local audio levels: ${t}, remote audio levels: ${i}`), this._reportedParticipants.push(e), this._clearUserData(e)
                            }
                            delete this._audioProblemCandidates[e]
                        }
                    }))
                }
                _clearUserData(e) {
                    delete this._localAudioLevelCache[e]
                }
                dispose() {
                    this._conference.off(s.REMOTE_STATS_UPDATED, this._onRemoteAudioLevelReceived), this._conference.off(r.USER_LEFT, this._clearUserData), this._conference.statistics.removeConnectionStatsListener(this._onLocalAudioLevelsReport), this._localAudioLevelCache = void 0, this._audioProblemCandidates = void 0, this._reportedParticipants = void 0, this._numberOfRemoteAudioLevelsReceived = void 0, this._conference = void 0
                }
            }
        }).call(this, "modules/statistics/AudioOutputProblemDetector.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return c
        }));
        var i = n(2),
            r = n(62),
            s = n.n(r),
            o = n(0),
            a = n.n(o);
        class c {
            constructor(e) {
                this.stats = {
                    users: {},
                    dominantSpeakerId: null
                };
                const t = e.myUserId();
                this.stats.users[t] = new s.a(t, null, !0), this.conference = e, e.addEventListener(i.DOMINANT_SPEAKER_CHANGED, this._onDominantSpeaker.bind(this)), e.addEventListener(i.USER_JOINED, this._onUserJoin.bind(this)), e.addEventListener(i.USER_LEFT, this._onUserLeave.bind(this)), e.addEventListener(i.DISPLAY_NAME_CHANGED, this._onDisplayNameChange.bind(this)), e.xmpp && e.xmpp.addListener(a.a.SPEAKER_STATS_RECEIVED, this._updateStats.bind(this))
            }
            _onDominantSpeaker(e) {
                const t = this.stats.users[this.stats.dominantSpeakerId],
                    n = this.stats.users[e];
                t && t.setDominantSpeaker(!1), n && n.setDominantSpeaker(!0), this.stats.dominantSpeakerId = e
            }
            _onUserJoin(e, t) {
                t.isHidden() || this.stats.users[e] || (this.stats.users[e] = new s.a(e, t.getDisplayName()))
            }
            _onUserLeave(e) {
                const t = this.stats.users[e];
                t && t.markAsHasLeft()
            }
            _onDisplayNameChange(e, t) {
                const n = this.stats.users[e];
                n && n.setDisplayName(t)
            }
            getStats() {
                return this.stats.users
            }
            _updateStats(e) {
                for (const t in e) {
                    let n;
                    const i = this.conference.getParticipantById(t);
                    i && i.isHidden() || (this.stats.users[t] ? (n = this.stats.users[t]).getDisplayName() || n.setDisplayName(e[t].displayName) : (n = new s.a(t, e[t].displayName), this.stats.users[t] = n, n.markAsHasLeft())), n.totalDominantSpeakerTime = e[t].totalDominantSpeakerTime
                }
            }
        }
    }, function(e, t, n) {
        const i = n(72),
            r = n(148),
            s = "before";

        function o() {
            this.audioRecorder = new i, this.transcriptionService = new r, this.counter = null, this.startTime = null, this.transcription = null, this.callback = null, this.results = [], this.state = s, this.lineLength = 0
        }

        function a(e, t) {
            if (console.log("retrieved an answer from the transcription service. The answer has an" + ` array of length: ${t.wordArray.length}`), t.wordArray.length > 0) {
                let n = t.startTime.getUTCMilliseconds() - e.startTime.getUTCMilliseconds();
                n < 0 && (n = 0);
                let i = "[";
                t.wordArray.forEach(e => {
                    e.begin += n, e.end += n, i += `${e.word},`
                }), i += "]", console.log(i), t.wordArray.name = t.name
            }
            e.results.push(t.wordArray), e.counter--, console.log(`current counter: ${e.counter}`), e.maybeMerge()
        }

        function c(e) {
            for (let t = 0; t < e.length; t++) 0 === e[t].length && e.splice(t, 1);
            return e.length > 0
        }
        o.prototype.start = function() {
            if (this.state !== s) throw new Error(`The transcription can only start when it's in the "${s}" state. It's currently in the "${this.state}" state`);
            this.state = "recording", this.audioRecorder.start(), this.startTime = new Date
        }, o.prototype.stop = function(e) {
            if ("recording" !== this.state) throw new Error(`The transcription can only stop when it's in the "recording" state. It's currently in the "${this.state}" state`);
            console.log("stopping recording and sending audio files"), this.audioRecorder.stop();
            const t = a.bind(null, this);
            this.audioRecorder.getRecordingResults().forEach(e => {
                this.transcriptionService.send(e, t), this.counter++
            }), this.state = "transcribing", this.callback = e
        }, o.prototype.maybeMerge = function() {
            "transcribing" === this.state && 0 === this.counter && this.merge()
        }, o.prototype.merge = function() {
            console.log(`starting merge process!\n The length of the array: ${this.results.length}`), this.transcription = "";
            const e = this.results,
                t = [];
            for (c(e), e.forEach(e => (function(e, t) {
                    if (0 === e.length) e.push(t);
                    else {
                        if (e[e.length - 1].begin <= t.begin) return void e.push(t);
                        for (let n = 0; n < e.length; n++)
                            if (t.begin < e[n].begin) return void e.splice(n, 0, t);
                        e.push(t)
                    }
                })(t, e)); c(e);) {
                let t = e[0];
                e.forEach(e => {
                    e[0].begin < t[0].begin && (t = e)
                });
                let n = t.shift();
                for (this.updateTranscription(n, t.name); t.length > 0;) {
                    let i = !1;
                    const r = t[0].begin;
                    if (e.forEach(e => {
                            e[0].begin < r && (i = !0)
                        }), i) break;
                    n = t.shift(), this.updateTranscription(n, null)
                }
            }
            this.state = "finished", this.callback && this.callback(this.transcription)
        }, o.prototype.updateTranscription = function(e, t) {
            null != t && (this.transcription += `\n${t}:`, this.lineLength = t.length + 1), this.lineLength + e.word.length > 80 && (this.transcription += "\n    ", this.lineLength = 4), this.transcription += ` ${e.word}`, this.lineLength += e.word.length + 1
        }, o.prototype.addTrack = function(e) {
            this.audioRecorder.addTrack(e)
        }, o.prototype.removeTrack = function(e) {
            this.audioRecorder.removeTrack(e)
        }, o.prototype.getTranscription = function() {
            if ("finished" !== this.state) throw new Error(`The transcription can only be retrieved when it's in the "finished" state. It's currently in the "${this.state}" state`);
            return this.transcription
        }, o.prototype.getState = function() {
            return this.state
        }, o.prototype.reset = function() {
            this.state = s, this.counter = null, this.transcription = null, this.startTime = null, this.callback = null, this.results = [], this.lineLength = 0
        }, e.exports = o
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return s
            }));
            var i = n(5);
            const r = n(4).getLogger(e);

            function s(e) {
                this.versions = {}, this.conference = e, this.conference.addCommandListener("versions", this.processVersions.bind(this))
            }
            s.prototype.processVersions = function(e, t, n) {
                if (!this.conference._isFocus(n)) return void r.warn(`Received versions not from the focus user: ${e}`, n);
                const s = [];
                e.children.forEach(e => {
                    const t = e.attributes.name,
                        n = e.value;
                    this.versions[t] !== n && (this.versions[t] = n, r.info(`Got ${t} version: ${n}`), s.push({
                        id: "component_version",
                        component: t,
                        version: n
                    }))
                }), s.length > 0 && i.a.sendLog(JSON.stringify(s))
            }, s.prototype.getComponentVersion = function(e) {
                return this.versions[e]
            }
        }).call(this, "modules/version/ComponentsVersions.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var i = n(4),
                r = n(128),
                s = n(22),
                o = n(0),
                a = n.n(o);
            const c = Object(i.getLogger)(e);
            class d {
                constructor(e) {
                    this.chatRoom = e, this.eventEmitter = e.eventEmitter, c.debug("creating VideoSIPGW"), this.sessions = {}, this.sessionStateChangeListener = this.sessionStateChanged.bind(this), e.addPresenceListener("jibri-sip-call-state", this.handleJibriSIPState.bind(this))
                }
                handleJibriSIPState(e) {
                    const t = e.attributes;
                    if (!t) return;
                    c.debug("Handle video sip gw state : ", t);
                    const n = t.state;
                    if (n !== this.state) switch (n) {
                        case s.STATE_ON:
                        case s.STATE_OFF:
                        case s.STATE_PENDING:
                        case s.STATE_RETRYING:
                        case s.STATE_FAILED: {
                            const e = t.sipaddress;
                            if (!e) return;
                            const i = this.sessions[e];
                            i ? i.setState(n, t.failure_reason) : c.warn("Video SIP GW session not found:", e)
                        }
                    }
                }
                createVideoSIPGWSession(e, t) {
                    if (this.sessions[e]) return c.warn("There was already a Video SIP GW session for address", e), new Error(s.ERROR_SESSION_EXISTS);
                    const n = new r.a(e, t, this.chatRoom);
                    return n.addStateListener(this.sessionStateChangeListener), this.sessions[e] = n, n
                }
                sessionStateChanged(e) {
                    const t = e.address;
                    if (e.newState === s.STATE_OFF || e.newState === s.STATE_FAILED) {
                        const e = this.sessions[t];
                        if (!e) return void c.error("Missing Video SIP GW session with address:", t);
                        e.removeStateListener(this.sessionStateChangeListener), delete this.sessions[t]
                    }
                    this.eventEmitter.emit(a.a.VIDEO_SIP_GW_SESSION_STATE_CHANGED, e)
                }
            }
        }).call(this, "modules/videosipgw/VideoSIPGW.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var i = n(4),
                r = n(1),
                s = n(24),
                o = n(22);
            const a = Object(i.getLogger)(e),
                c = "STATE_CHANGED";
            class d extends s.a {
                constructor(e, t, n) {
                    super(), this.sipAddress = e, this.displayName = t, this.chatRoom = n, this.state = void 0
                }
                stop() {
                    this.state !== o.STATE_OFF && this.state !== o.STATE_FAILED ? this._sendJibriIQ("stop") : a.warn("Video SIP GW session already stopped or failed!")
                }
                start() {
                    this.state !== o.STATE_ON && this.state !== o.STATE_OFF && this.state !== o.STATE_PENDING && this.state !== o.STATE_RETRYING ? this._sendJibriIQ("start") : a.warn("Video SIP GW session already started!")
                }
                setState(e, t) {
                    if (e === this.state) return;
                    const n = this.state;
                    this.state = e, this.eventEmitter.emit(c, {
                        address: this.sipAddress,
                        failureReason: t,
                        oldState: n,
                        newState: this.state,
                        displayName: this.displayName
                    })
                }
                addStateListener(e) {
                    this.addListener(c, e)
                }
                removeStateListener(e) {
                    this.removeListener(c, e)
                }
                _sendJibriIQ(e) {
                    const t = {
                        xmlns: "http://jitsi.org/protocol/jibri",
                        action: e,
                        sipaddress: this.sipAddress
                    };
                    t.displayname = this.displayName;
                    const n = Object(r.$iq)({
                        to: this.chatRoom.focusMucJid,
                        type: "set"
                    }).c("jibri", t).up();
                    a.debug(`${e} video SIP GW session`, n.nodeTree), this.chatRoom.connection.sendIQ(n, () => {}, t => {
                        a.error(`Failed to ${e} video SIP GW session, error: `, t), this.setState(o.STATE_FAILED)
                    })
                }
            }
        }).call(this, "modules/videosipgw/JitsiVideoSIPGWSession.js")
    }, function(e, t, n) {
        "use strict";
        t.a = {
            error: {
                BUSY: "busy",
                ERROR: "error",
                RESOURCE_CONSTRAINT: "resource-constraint",
                SERVICE_UNAVAILABLE: "service-unavailable"
            },
            mode: {
                FILE: "file",
                STREAM: "stream"
            },
            status: {
                OFF: "off",
                ON: "on",
                PENDING: "pending"
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return m
            }));
            var i = n(4),
                r = n(1),
                s = n(9),
                o = n(14),
                a = n.n(o),
                c = n(12),
                d = n(131),
                u = n(30);

            function l(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {},
                        i = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), i.forEach((function(t) {
                        h(e, t, n[t])
                    }))
                }
                return e
            }

            function h(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function p(e, t) {
                if (null == e) return {};
                var n, i, r = function(e, t) {
                    if (null == e) return {};
                    var n, i, r = {},
                        s = Object.keys(e);
                    for (i = 0; i < s.length; i++) n = s[i], t.indexOf(n) >= 0 || (r[n] = e[n]);
                    return r
                }(e, t);
                if (Object.getOwnPropertySymbols) {
                    var s = Object.getOwnPropertySymbols(e);
                    for (i = 0; i < s.length; i++) n = s[i], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n])
                }
                return r
            }
            const f = Object(i.getLogger)(e);
            class m {
                constructor(e = {}) {
                    const {
                        jitsiConnection: t
                    } = e, n = p(e, ["jitsiConnection"]);
                    this._options = l({
                        iceConfig: t && t.xmpp.connection.jingle.p2pIceConfig
                    }, n), this._peerConnection = null, this._onFatalError = this._onFatalError.bind(this), this._onSendMessage = this._onSendMessage.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this)
                }
                processMessage(e) {
                    const t = e.from;
                    if (!t) return;
                    if (this._peerConnection && this._peerConnection.getPeerJid() !== t) return void this._onFatalError(t, u.a.CONNECTION_ERROR, "rejected");
                    const n = this._convertStringToXML(e.data.iq),
                        i = n && n.find("jingle"),
                        r = i && i.attr("action");
                    r === u.a.INITIATE && (this._peerConnection = this._createPeerConnection(t, {
                        isInitiator: !1,
                        receiveVideo: !0
                    })), this._peerConnection && this._peerConnection.processMessage(i), r !== u.a.CONNECTION_ERROR && r !== u.a.UNAVAILABLE && r !== u.a.TERMINATE || this._selfCloseConnection()
                }
                start(e, t = []) {
                    this._peerConnection = this._createPeerConnection(e, {
                        isInitiator: !0,
                        receiveVideo: !1
                    }), this._peerConnection.start(t)
                }
                stop() {
                    this._peerConnection && this._peerConnection.stop(), this._peerConnection = null
                }
                _convertStringToXML(e) {
                    try {
                        const t = (new DOMParser).parseFromString(e, "text/xml");
                        return $(t)
                    } catch (e) {
                        return f.error("Attempted to convert incorrectly formatted xml"), null
                    }
                }
                _createPeerConnection(e, t = {}) {
                    if (!e) throw new Error("Cannot create ProxyConnectionPC without a peer.");
                    const n = l({
                        iceConfig: this._options.iceConfig,
                        onError: this._onFatalError,
                        onRemoteStream: this._onRemoteStream,
                        onSendMessage: this._onSendMessage,
                        peerJid: e
                    }, t);
                    return new d.a(n)
                }
                _onFatalError(e, t, n = "") {
                    f.error("Received a proxy connection error", e, t, n);
                    const i = Object(r.$iq)({
                        to: e,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: t
                    }).c("details").t(n).up();
                    this._onSendMessage(e, i), this._peerConnection && this._peerConnection.getPeerJid() === e && this._selfCloseConnection()
                }
                _onRemoteStream(e) {
                    if (!this._options.onRemoteStream) return f.error("Remote track received without callback."), void e.dispose();
                    const t = e.isVideoTrack();
                    let n;
                    t && (n = this._options.convertVideoToDesktop ? a.a.DESKTOP : a.a.CAMERA);
                    const i = e.getOriginalStream(),
                        r = c.a.newCreateLocalTracks([{
                            deviceId: `proxy:${this._peerConnection.getPeerJid()}`,
                            mediaType: t ? s.c : s.a,
                            sourceType: "proxy",
                            stream: i,
                            track: i.getVideoTracks()[0],
                            videoType: n
                        }]);
                    this._options.onRemoteStream(r[0])
                }
                _onSendMessage(e, t) {
                    if (this._options.onSendMessage) try {
                        const n = (new XMLSerializer).serializeToString(t.nodeTree || t);
                        this._options.onSendMessage(e, {
                            iq: n
                        })
                    } catch (e) {
                        f.error("Attempted to send an incorrectly formatted iq.")
                    }
                }
                _selfCloseConnection() {
                    this.stop(), this._options.onConnectionClosed && this._options.onConnectionClosed()
                }
            }
        }).call(this, "modules/proxyconnection/ProxyConnectionService.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return m
            }));
            var i = n(4),
                r = n(12),
                s = n(8),
                o = n.n(s),
                a = n(0),
                c = n.n(a),
                d = n(47),
                u = n(37),
                l = n(30);

            function h(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {},
                        i = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), i.forEach((function(t) {
                        p(e, t, n[t])
                    }))
                }
                return e
            }

            function p(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const f = Object(i.getLogger)(e);
            class m {
                constructor(e = {}) {
                    this._options = h({
                        iceConfig: {},
                        isInitiator: !1,
                        receiveAudio: !1,
                        receiveVideo: !1
                    }, e), this._tracks = [], this._peerConnection = null, this._onError = this._onError.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this), this._onSendMessage = this._onSendMessage.bind(this)
                }
                getPeerJid() {
                    return this._options.peerJid
                }
                processMessage(e) {
                    switch (e.attr("action")) {
                        case l.a.ACCEPT:
                            this._onSessionAccept(e);
                            break;
                        case l.a.INITIATE:
                            this._onSessionInitiate(e);
                            break;
                        case l.a.TERMINATE:
                            this._onSessionTerminate(e);
                            break;
                        case l.a.TRANSPORT_INFO:
                            this._onTransportInfo(e)
                    }
                }
                start(e = []) {
                    this._peerConnection || (this._tracks = this._tracks.concat(e), this._peerConnection = this._createPeerConnection(), this._peerConnection.invite(e))
                }
                stop() {
                    this._peerConnection && this._peerConnection.terminate(), this._onSessionTerminate()
                }
                _createPeerConnection() {
                    const e = {
                            connected: !0,
                            jingle: {
                                terminate: () => {}
                            },
                            sendIQ: this._onSendMessage,
                            addEventListener: () => () => {}
                        },
                        t = h({
                            iceServers: u.a
                        }, this._options.iceConfig),
                        n = {
                            addPresenceListener: () => {},
                            connectionTimes: [],
                            eventEmitter: {
                                emit: e => {
                                    switch (e) {
                                        case c.a.CONNECTION_ICE_FAILED:
                                        case c.a.CONNECTION_FAILED:
                                            this._onError(l.a.CONNECTION_ERROR, e)
                                    }
                                }
                            },
                            getMediaPresenceInfo: () => ({}),
                            removePresenceListener: () => {}
                        };
                    this._rtc = new r.a(this, {}), this._rtc.addListener(o.a.REMOTE_TRACK_ADDED, this._onRemoteStream);
                    const i = new d.a(void 0, void 0, this._options.peerJid, e, {
                        offerToReceiveAudio: this._options.receiveAudio,
                        offerToReceiveVideo: this._options.receiveVideo
                    }, t, !0, this._options.isInitiator);
                    return i.initialize(n, this._rtc, {}), i
                }
                _onError(e, t = "") {
                    this._options.onError(this._options.peerJid, e, t)
                }
                _onRemoteStream(e) {
                    this._tracks.push(e), this._options.onRemoteStream(e)
                }
                _onSendMessage(e) {
                    this._options.onSendMessage(this._options.peerJid, e)
                }
                _onSessionAccept(e) {
                    this._peerConnection ? this._peerConnection.setAnswer(e) : f.error("Received an answer when no peer connection exists.")
                }
                _onSessionInitiate(e) {
                    this._peerConnection ? f.error("Received an offer when an offer was already sent.") : (this._peerConnection = this._createPeerConnection(), this._peerConnection.acceptOffer(e, () => {}, () => this._onError(this._options.peerJid, l.a.CONNECTION_ERROR, "session initiate error")))
                }
                _onSessionTerminate() {
                    this._tracks.forEach(e => e.dispose()), this._tracks = [], this._peerConnection && this._peerConnection.onTerminated(), this._rtc && (this._rtc.removeListener(o.a.REMOTE_TRACK_ADDED, this._onRemoteStream), this._rtc.destroy())
                }
                _onTransportInfo(e) {
                    this._peerConnection.addIceCandidates(e)
                }
            }
        }).call(this, "modules/proxyconnection/ProxyConnectionPC.js")
    }, function(e, t, n) {
        "use strict";
        var i = n(49),
            r = n.n(i),
            s = n(21),
            o = n.n(s);
        var a = {
            write: function(e, t) {
                return void 0 !== e && void 0 !== e.media && Array.isArray(e.media) && e.media.forEach(e => {
                    e.sources && e.sources.length && (e.ssrcs = [], e.sources.forEach(t => {
                        Object.keys(t).forEach(n => {
                            "id" !== n && e.ssrcs.push({
                                id: t.id,
                                attribute: n,
                                value: t[n]
                            })
                        })
                    }), delete e.sources), e.ssrcGroups && e.ssrcGroups.length && e.ssrcGroups.forEach(e => {
                        void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.ssrcs = e.ssrcs.join(" "))
                    })
                }), o.a.write(e, t)
            },
            parse: function(e) {
                const t = o.a.parse(e);
                return void 0 !== t && void 0 !== t.media && Array.isArray(t.media) && t.media.forEach(e => {
                    void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.sources = [], e.ssrcs.forEach(t => {
                        const n = e.sources.findIndex(e => e.id === t.id);
                        if (n > -1) e.sources[n][t.attribute] = t.value;
                        else {
                            const n = {
                                id: t.id
                            };
                            n[t.attribute] = t.value, e.sources.push(n)
                        }
                    }), delete e.ssrcs), void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach(e => {
                        "string" == typeof e.ssrcs && (e.ssrcs = e.ssrcs.split(" "))
                    })
                }), t
            }
        };
        const c = ["audio", "video", "data"],
            d = e => e.find(e => "SIM" === e.semantics),
            u = e => e.find(e => "FID" === e.semantics);

        function l(e, t, n, i) {
            if (!e || !t) return;
            const r = e => i.find(t => t.id.toString() === e);
            t.ssrcs.forEach(t => {
                e.sources.push(r(t));
                const i = n[parseInt(t, 10)].find(e => "FID" === e.semantics);
                if (i) {
                    const n = i.ssrcs.find(e => e !== t);
                    e.sources.push(r(n)), e.ssrcGroups.push(i)
                }
            }), e.ssrcGroups.push(t)
        }

        function h(e, t, n, i) {
            if (!e || !t) return;
            if (e.sources = [], e.ssrcGroups = [], !n[t.id]) return e.sources.push(t), void(e.msid = t.msid);
            const r = d(n[t.id]),
                s = u(n[t.id]);
            if (r) l(e, r, n, i);
            else if (s) {
                const r = s.ssrcs.find(e => e !== t),
                    o = d(n[r]);
                o ? l(e, o, n, i) : (s.ssrcs.forEach(t => {
                    e.sources.push((e => i.find(t => t.id.toString() === e))(t))
                }), e.ssrcGroups.push(s))
            }
            e.msid = e.sources[0].msid
        }

        function p(e, t, n) {
            if (!n.find(t => !!t.sources && t.sources.some(t => t.id === e.id))) {
                if (!t[e.id]) return !1;
                const i = d(t[e.id]),
                    r = u(t[e.id]);
                if (i) return n.some(e => e.sources && e.sources.some(e => e.id.toString() === i.ssrcs[0]));
                if (r && e.id.toString() !== r.ssrcs[0]) {
                    return p({
                        id: r.ssrcs[0]
                    }, t, n)
                }
                return !1
            }
            return !0
        }
        class f {
            toPlanB(e) {
                if (!e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
                const t = a.parse(e.sdp);
                if (!t.media || !t.media.length) return console.warn("The description has no media."), e;
                if (t.media.every(e => -1 !== c.indexOf(e.mid))) return console.warn("The description does not look like unified plan sdp"), e;
                const n = {},
                    i = t.media;
                t.media = [], i.forEach(e => {
                    const t = e.type;
                    if ("application" === t) return e.mid = "data", void(n[e.mid] = e);
                    if (void 0 === n[t]) {
                        const i = r()(e);
                        i.sources && Array.isArray(i.sources) && i.sources.forEach(t => {
                            e.msid ? t.msid = e.msid : delete t.msid
                        }), i.ssrcGroups || (i.ssrcGroups = []), delete i.msid, i.mid = t, n[t] = i
                    } else e.msid && (e.sources && Array.isArray(e.sources) && (n[t].sources = n[t].sources.concat(e.sources)), void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && (n[t].ssrcGroups = n[t].ssrcGroups.concat(e.ssrcGroups)))
                }), t.media = Object.values(n);
                const s = [];
                Object.values(n).forEach(e => {
                    "inactive" !== e.direction && s.push(e.mid)
                }), t.groups.forEach(e => {
                    "BUNDLE" === e.type && (e.mids = s.join(" "))
                }), t.msidSemantic = {
                    semantic: "WMS",
                    token: "*"
                };
                const o = a.write(t);
                return new RTCSessionDescription({
                    type: e.type,
                    sdp: o
                })
            }
            toUnifiedPlan(e, t = null) {
                if (!e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
                const n = a.parse(e.sdp);
                if (!n.media || !n.media.length) return console.warn("The description has no media."), e;
                if (n.media.length > 3 || n.media.every(e => -1 === c.indexOf(e.mid))) return console.warn("The description does not look like plan-b"), e;
                const i = t ? a.parse(t.sdp) : null,
                    s = {};
                n.media.forEach(e => {
                    const t = e.type;
                    if ("application" === t) {
                        if (!i || !i.media) {
                            const t = r()(e);
                            return t.mid = Object.keys(s).length.toString(), void(s[e.mid] = t)
                        }
                        const n = i.media.findIndex(e => e.type === t);
                        return void(n && (i.media[n] = e, i.media[n].mid = n))
                    }
                    const n = function(e) {
                        const t = {};
                        return e && Array.isArray(e) ? (e.forEach(e => {
                            e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach(n => {
                                void 0 === t[n] && (t[n] = []), t[n].push(e)
                            })
                        }), t) : t
                    }(e.ssrcGroups);
                    e.sources && e.sources.forEach((o, a) => {
                        if (!o.msid) return;
                        if (!i || !i.media) {
                            if (p(o, n, Object.values(s))) return;
                            const t = r()(e);
                            return t.mid = Object.keys(s).length.toString(), t.direction = a ? "sendonly" : "sendonly" === e.direction ? "sendonly" : "sendrecv", t.bundleOnly = void 0, h(t, o, n, e.sources), void(s[t.mid] = t)
                        }
                        if (p(o, n, i.media)) return;
                        const c = i.media.findIndex(e => e.direction && "inactive" === e.direction && e.type === t);
                        if (c > -1) i.media[c].direction = "sendonly", h(i.media[c], o, n, e.sources);
                        else {
                            const t = r()(e);
                            t.mid = i.media.length.toString(), t.direction = "sendonly", h(t, o, n, e.sources), i.media.push(t)
                        }
                    })
                }), n.media = i ? i.media : Object.values(s);
                const o = [];
                n.media.forEach(e => {
                    o.push(e.mid)
                }), n.groups.forEach(e => {
                    "BUNDLE" === e.type && (e.mids = o.join(" "))
                }), n.msidSemantic = {
                    semantic: "WMS",
                    token: "*"
                }, n.origin.sessionVersion++;
                const d = a.write(n);
                return new RTCSessionDescription({
                    type: e.type,
                    sdp: d
                })
            }
        }
        n.d(t, "a", (function() {
            return f
        }))
    }, function(e, t, n) {
        e.exports = n(134).default
    }, function(e, t, n) {
        "use strict";
        n.r(t),
            function(e) {
                var i = n(73),
                    r = n(85),
                    s = n(20),
                    o = n(56),
                    a = n(7),
                    c = n(86),
                    d = n.n(c),
                    u = n(28),
                    l = n(57),
                    h = n(11),
                    p = n.n(h),
                    f = n(18),
                    m = n(2),
                    g = n(87),
                    _ = n(39),
                    v = n(25),
                    S = n(68),
                    y = n(48),
                    E = n(16),
                    T = n(13),
                    b = n(15),
                    C = n(60),
                    R = n(52),
                    A = n(4),
                    w = n.n(A),
                    I = n(9),
                    P = n(31),
                    D = n.n(P),
                    O = n(44),
                    N = n(12),
                    M = n(3),
                    L = n(53),
                    k = n.n(L),
                    x = n(129),
                    F = n(130),
                    j = n(5),
                    U = n(22);
                const H = w.a.getLogger(e);

                function J(e) {
                    const t = {
                        audio_requested: e.devices.includes("audio"),
                        video_requested: e.devices.includes("video"),
                        screen_sharing_requested: e.devices.includes("desktop")
                    };
                    return t.video_requested && (t.resolution = e.resolution), t
                }
                t.default = function(e) {
                    return "object" == typeof window.JitsiMeetJS ? Object.assign({}, window.JitsiMeetJS, e) : e
                }({
                    version: "f97c37d014",
                    JitsiConnection: g.a,
                    ProxyConnectionService: F.a,
                    constants: {
                        participantConnectionStatus: O.a,
                        recording: x.a,
                        sipVideoGW: U,
                        transcriptionStatus: C
                    },
                    events: {
                        conference: m,
                        connection: v,
                        detection: s,
                        track: b,
                        mediaDevices: y,
                        connectionQuality: u,
                        e2eping: l
                    },
                    errors: {
                        conference: f,
                        connection: _,
                        track: T
                    },
                    errorTypes: {
                        JitsiTrackError: E.a
                    },
                    logLevels: w.a.levels,
                    mediaDevices: S.a,
                    analytics: j.a.analytics,
                    init(e = {}) {
                        j.a.init(e), window.connectionTimes || (window.connectionTimes = {}), !0 !== e.enableAnalyticsLogging && (H.warn("Analytics disabled, disposing."), this.analytics.dispose()), e.enableWindowOnErrorHandler && p.a.addHandler(this.getGlobalOnErrorHandler.bind(this));
                        const t = e.deploymentInfo;
                        if (t && Object.keys(t).length > 0) {
                            const e = {};
                            for (const n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
                            e.id = "deployment_info", j.a.sendLog(JSON.stringify(e))
                        }
                        if (this.version) {
                            const e = {
                                id: "component_version",
                                component: "lib-jitsi-meet",
                                version: this.version
                            };
                            j.a.sendLog(JSON.stringify(e))
                        }
                        return N.a.init(e)
                    },
                    isDesktopSharingEnabled: () => N.a.isDesktopSharingEnabled(),
                    isWebRtcSupported: () => N.a.isWebRtcSupported(),
                    setLogLevel(e) {
                        w.a.setLogLevel(e)
                    },
                    setLogLevelById(e, t) {
                        w.a.setLogLevelById(e, t)
                    },
                    addGlobalLogTransport(e) {
                        w.a.addGlobalTransport(e)
                    },
                    removeGlobalLogTransport(e) {
                        w.a.removeGlobalTransport(e)
                    },
                    setGlobalLogOptions(e) {
                        w.a.setGlobalOptions(e)
                    },
                    createLocalTracks(e = {}, t, n) {
                        let i = !1;
                        return !0 === t && window.setTimeout(() => {
                            i || S.a.emitEvent(y.PERMISSION_PROMPT_IS_SHOWN, M.a.getName())
                        }, 1e3), window.connectionTimes || (window.connectionTimes = {}), window.connectionTimes["obtainPermissions.start"] = window.performance.now(), N.a.obtainAudioAndVideoPermissions(e).then(t => {
                            if (i = !0, window.connectionTimes["obtainPermissions.end"] = window.performance.now(), j.a.sendAnalytics(Object(a.F)("success", J(e))), !N.a.options.disableAudioLevels)
                                for (let e = 0; e < t.length; e++) {
                                    const n = t[e],
                                        i = n.getOriginalStream();
                                    n.getType() === I.a && (j.a.startLocalStats(i, n.setAudioLevel.bind(n)), n.addEventListener(b.LOCAL_TRACK_STOPPED, () => {
                                        j.a.stopLocalStats(i)
                                    }))
                                }
                            const n = N.a.getCurrentlyAvailableMediaDevices();
                            if (n)
                                for (let e = 0; e < t.length; e++) {
                                    t[e]._setRealDeviceIdFromDeviceList(n)
                                }
                            for (const e of t) e.type === I.c && "desktop" === e.videoType && this.setVideoTrackContentHints(e.track, "detail");
                            return t
                        }).catch(t => {
                            if (i = !0, t.name === T.UNSUPPORTED_RESOLUTION && !M.a.usesNewGumFlow()) {
                                const i = e.resolution || "720",
                                    r = function(e) {
                                        if (!D.a[e]) return null;
                                        const t = D.a[e].order;
                                        let n = null,
                                            i = null;
                                        return Object.keys(D.a).forEach(e => {
                                            const r = D.a[e];
                                            (!n || n.order < r.order && r.order < t) && (i = e, n = r)
                                        }), i === e && (i = null), i
                                    }(i);
                                if (null !== r) return e.resolution = r, H.debug("Retry createLocalTracks with resolution", r), j.a.sendAnalytics(Object(a.F)("warning", {
                                    old_resolution: i,
                                    new_resolution: r,
                                    reason: "unsupported resolution"
                                })), this.createLocalTracks(e, void 0, n || Object.assign({}, e));
                                if (n && t.gum.constraints && t.gum.constraints.video && t.gum.constraints.video.mandatory && t.gum.constraints.video.mandatory.sourceId) return n.cameraDeviceId = void 0, this.createLocalTracks(n)
                            }
                            if (t.name === T.CHROME_EXTENSION_USER_CANCELED) {
                                const e = {
                                    id: "chrome_extension_user_canceled",
                                    message: t.message
                                };
                                j.a.sendLog(JSON.stringify(e)), j.a.sendAnalytics(Object(a.F)("warning", {
                                    reason: "extension install user canceled"
                                }))
                            } else if (t.name === T.NOT_FOUND) {
                                const n = {
                                    id: "usermedia_missing_device",
                                    status: t.gum.devices
                                };
                                j.a.sendLog(JSON.stringify(n));
                                const i = J(e);
                                i.reason = "device not found", i.devices = t.gum.devices.join("."), j.a.sendAnalytics(Object(a.F)("error", i))
                            } else {
                                j.a.sendGetUserMediaFailed(t);
                                const n = J(e);
                                n.reason = t.name, j.a.sendAnalytics(Object(a.F)("error", n))
                            }
                            return window.connectionTimes["obtainPermissions.end"] = window.performance.now(), Promise.reject(t)
                        })
                    },
                    createTrackVADEmitter: (e, t, n) => o.a.create(e, t, n),
                    createAudioMixer: () => new r.a,
                    getActiveAudioDevice: () => Object(i.a)(),
                    isDeviceListAvailable() {
                        return H.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceListAvailable instead"), this.mediaDevices.isDeviceListAvailable()
                    },
                    isDeviceChangeAvailable(e) {
                        return H.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead"), this.mediaDevices.isDeviceChangeAvailable(e)
                    },
                    isMultipleAudioInputSupported() {
                        return this.mediaDevices.isMultipleAudioInputSupported()
                    },
                    isCollectingLocalStats: () => j.a.audioLevelsEnabled && R.a.isLocalStatsSupported(),
                    enumerateDevices(e) {
                        H.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.enumerateDevices instead"), this.mediaDevices.enumerateDevices(e)
                    },
                    getGlobalOnErrorHandler(e, t, n, i, r) {
                        H.error(`UnhandledError: ${e}`, `Script: ${t}`, `Line: ${n}`, `Column: ${i}`, "StackTrace: ", r), j.a.reportGlobalError(r)
                    },
                    setVideoTrackContentHints(e, t) {
                        "contentHint" in e ? (e.contentHint = t, e.contentHint !== t && H.debug("Invalid video track contentHint")) : H.debug("MediaStreamTrack contentHint attribute not supported")
                    },
                    util: {
                        AuthUtil: d(),
                        ScriptUtil: k(),
                        browser: M.a
                    }
                })
            }.call(this, "JitsiMeetJS.js")
    }, function(e, t, n) {
        var i = n(69);

        function r(e, t) {
            this.logStorage = e, this.stringifyObjects = !(!t || !t.stringifyObjects) && t.stringifyObjects, this.storeInterval = t && t.storeInterval ? t.storeInterval : 3e4, this.maxEntryLength = t && t.maxEntryLength ? t.maxEntryLength : 1e4, Object.keys(i.levels).forEach(function(e) {
                this[i.levels[e]] = function() {
                    this._log.apply(this, arguments)
                }.bind(this, e)
            }.bind(this)), this.storeLogsIntervalID = null, this.queue = [], this.totalLen = 0, this.outputCache = []
        }
        r.prototype.stringify = function(e) {
            try {
                return JSON.stringify(e)
            } catch (e) {
                return "[object with circular refs?]"
            }
        }, r.prototype.formatLogMessage = function(e) {
            for (var t = "", n = 1, r = arguments.length; n < r; n++) {
                var s = arguments[n];
                !this.stringifyObjects && e !== i.levels.ERROR || "object" != typeof s || (s = this.stringify(s)), t += s, n !== r - 1 && (t += " ")
            }
            return t.length ? t : null
        }, r.prototype._log = function() {
            var e = arguments[1],
                t = this.formatLogMessage.apply(this, arguments);
            if (t) {
                var n = this.queue[this.queue.length - 1],
                    i = n && n.text;
                i === t ? n.count += 1 : (this.queue.push({
                    text: t,
                    timestamp: e,
                    count: 1
                }), this.totalLen += t.length)
            }
            this.totalLen >= this.maxEntryLength && this._flush(!0, !0)
        }, r.prototype.start = function() {
            this._reschedulePublishInterval()
        }, r.prototype._reschedulePublishInterval = function() {
            this.storeLogsIntervalID && (window.clearTimeout(this.storeLogsIntervalID), this.storeLogsIntervalID = null), this.storeLogsIntervalID = window.setTimeout(this._flush.bind(this, !1, !0), this.storeInterval)
        }, r.prototype.flush = function() {
            this._flush(!1, !0)
        }, r.prototype._flush = function(e, t) {
            this.totalLen > 0 && (this.logStorage.isReady() || e) && (this.logStorage.isReady() ? (this.outputCache.length && (this.outputCache.forEach(function(e) {
                this.logStorage.storeLogs(e)
            }.bind(this)), this.outputCache = []), this.logStorage.storeLogs(this.queue)) : this.outputCache.push(this.queue), this.queue = [], this.totalLen = 0), t && this._reschedulePublishInterval()
        }, r.prototype.stop = function() {
            this._flush(!1, !1)
        }, e.exports = r
    }, function(e, t) {
        (function(t) {
            e.exports = t
        }).call(this, {})
    }, function(e, t, n) {
        var i, r, s;
        /*!
         * currentExecutingScript
         * Get the currently executing script, regardless of its source/trigger/synchronicity. Similar to HTML5's `document.currentScript` but arguably much more useful!
         * Copyright (c) 2015 James M. Greene
         * Licensed MIT
         * https://github.com/JamesMGreene/currentExecutingScript
         * v0.1.3
         */
        this || window, r = [], void 0 === (s = "function" == typeof(i = function() {
            var e = /^(interactive|loaded|complete)$/,
                t = window.location ? window.location.href : null,
                n = t && t.replace(/#.*$/, "").replace(/\?.*$/, "") || null,
                i = document.getElementsByTagName("script"),
                r = "readyState" in (i[0] || document.createElement("script")),
                s = !window.opera || "[object Opera]" !== window.opera.toString(),
                o = "currentScript" in document;
            "stackTraceLimit" in Error && Error.stackTraceLimit !== 1 / 0 && (Error.stackTraceLimit, Error.stackTraceLimit = 1 / 0);
            var a = !1,
                c = !1;

            function d() {
                if (0 === i.length) return null;
                var t, u, l, h, p, f = [],
                    m = d.skipStackDepth || 1;
                for (t = 0; t < i.length; t++) s && r ? e.test(i[t].readyState) && f.push(i[t]) : f.push(i[t]);
                if (u = new Error, a && (l = u.stack), !l && c) try {
                    throw u
                } catch (e) {
                    l = e.stack
                }
                if (l && !(p = function(e, t) {
                        var n, r = null;
                        if (t = t || i, "string" == typeof e && e)
                            for (n = t.length; n--;)
                                if (t[n].src === e) {
                                    r = t[n];
                                    break
                                } return r
                    }(h = function e(t, n) {
                        var i, r = null,
                            s = "number" == typeof n;
                        return n = s ? Math.round(n) : 0, "string" == typeof t && t && (s ? i = t.match(/(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/) : (i = t.match(/^(?:|[^:@]*@|.+\)@(?=data:text\/javascript|blob|http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)) && i[1] || (i = t.match(/\)@(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)), i && i[1] && (r = n > 0 ? e(t.slice(t.indexOf(i[0]) + i[0].length), n - 1) : i[1])), r
                    }(l, m), f)) && n && h === n && (p = function(e) {
                        var t, n, r = null;
                        for (t = 0, n = (e = e || i).length; t < n; t++)
                            if (!e[t].hasAttribute("src")) {
                                if (r) {
                                    r = null;
                                    break
                                }
                                r = e[t]
                            } return r
                    }(f)), p || 1 === f.length && (p = f[0]), p || o && (p = document.currentScript), !p && s && r)
                    for (t = f.length; t--;)
                        if ("interactive" === f[t].readyState) {
                            p = f[t];
                            break
                        } return p || (p = f[f.length - 1] || null), p
            }(function() {
                try {
                    var e = new Error;
                    throw a = "string" == typeof e.stack && !!e.stack, e
                } catch (e) {
                    c = "string" == typeof e.stack && !!e.stack
                }
            })(), d.skipStackDepth = 1;
            var u = d;
            return u.near = d, u.far = function() {
                return null
            }, u.origin = function() {
                return null
            }, u
        }) ? i.apply(t, r) : i) || (e.exports = s)
    }, function(e, t) {
        e.exports = {
            LOCAL_JID: "local"
        }
    }, function(e, t, n) {
        var i = function(e) {
                return String(Number(e)) === e ? Number(e) : e
            },
            r = function(e, t, n) {
                var r = e.name && e.names;
                e.push && !t[e.push] ? t[e.push] = [] : r && !t[e.name] && (t[e.name] = {});
                var s = e.push ? {} : r ? t[e.name] : t;
                ! function(e, t, n, r) {
                    if (r && !n) t[r] = i(e[1]);
                    else
                        for (var s = 0; s < n.length; s += 1) null != e[s + 1] && (t[n[s]] = i(e[s + 1]))
                }(n.match(e.reg), s, e.names, e.name), e.push && t[e.push].push(s)
            },
            s = n(71),
            o = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
        t.parse = function(e) {
            var t = {},
                n = [],
                i = t;
            return e.split(/(\r\n|\r|\n)/).filter(o).forEach((function(e) {
                var t = e[0],
                    o = e.slice(2);
                "m" === t && (n.push({
                    rtp: [],
                    fmtp: []
                }), i = n[n.length - 1]);
                for (var a = 0; a < (s[t] || []).length; a += 1) {
                    var c = s[t][a];
                    if (c.reg.test(o)) return r(c, i, o)
                }
            })), t.media = n, t
        };
        var a = function(e, t) {
            var n = t.split(/=(.+)/, 2);
            return 2 === n.length && (e[n[0]] = i(n[1])), e
        };
        t.parseParams = function(e) {
            return e.split(/\;\s?/).reduce(a, {})
        }, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e) {
            return e.split(" ").map(Number)
        }, t.parseRemoteCandidates = function(e) {
            for (var t = [], n = e.split(" ").map(i), r = 0; r < n.length; r += 3) t.push({
                component: n[r],
                ip: n[r + 1],
                port: n[r + 2]
            });
            return t
        }, t.parseImageAttributes = function(e) {
            return e.split(" ").map((function(e) {
                return e.substring(1, e.length - 1).split(",").reduce(a, {})
            }))
        }, t.parseSimulcastStreamList = function(e) {
            return e.split(";").map((function(e) {
                return e.split(",").map((function(e) {
                    var t, n = !1;
                    return "~" !== e[0] ? t = i(e) : (t = i(e.substring(1, e.length)), n = !0), {
                        scid: t,
                        paused: n
                    }
                }))
            }))
        }
    }, function(e, t, n) {
        var i = n(71),
            r = /%[sdv%]/g,
            s = function(e) {
                var t = 1,
                    n = arguments,
                    i = n.length;
                return e.replace(r, (function(e) {
                    if (t >= i) return e;
                    var r = n[t];
                    switch (t += 1, e) {
                        case "%%":
                            return "%";
                        case "%s":
                            return String(r);
                        case "%d":
                            return Number(r);
                        case "%v":
                            return ""
                    }
                }))
            },
            o = function(e, t, n) {
                var i = [e + "=" + (t.format instanceof Function ? t.format(t.push ? n : n[t.name]) : t.format)];
                if (t.names)
                    for (var r = 0; r < t.names.length; r += 1) {
                        var o = t.names[r];
                        t.name ? i.push(n[t.name][o]) : i.push(n[t.names[r]])
                    } else i.push(n[t.name]);
                return s.apply(null, i)
            },
            a = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
            c = ["i", "c", "b", "a"];
        e.exports = function(e, t) {
            t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
                null == e.payloads && (e.payloads = "")
            }));
            var n = t.outerOrder || a,
                r = t.innerOrder || c,
                s = [];
            return n.forEach((function(t) {
                i[t].forEach((function(n) {
                    n.name in e && null != e[n.name] ? s.push(o(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                        s.push(o(t, n, e))
                    }))
                }))
            })), e.media.forEach((function(e) {
                s.push(o("m", i.m[0], e)), r.forEach((function(t) {
                    i[t].forEach((function(n) {
                        n.name in e && null != e[n.name] ? s.push(o(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                            s.push(o(t, n, e))
                        }))
                    }))
                }))
            })), s.join("\r\n") + "\r\n"
        }
    }, function(e, t, n) {
        var i = n(21),
            r = n(142),
            s = r.parseSsrcs,
            o = r.writeSsrcs,
            a = 3;

        function c(e, t, n) {
            return e.ssrcs.filter((function(e) {
                return e.id === t
            })).filter((function(e) {
                return e.attribute === n
            })).map((function(e) {
                return e.value
            }))[0]
        }

        function d(e) {
            this.options = e || {}, this.options.numOfLayers || (this.options.numOfLayers = a), console.log("SdpSimulcast: using " + this.options.numOfLayers + " layers"), this.ssrcCache = []
        }

        function u(e, t) {
            null != e && Array.isArray(e.media) && e.media.forEach((function(e) {
                "video" === e.type && t(e)
            }))
        }

        function l(e) {
            return e && null != e && e.type && "" != e.type && e.sdp && "" != e.sdp
        }
        d.prototype.clearSsrcCache = function() {
            this.ssrcCache = []
        }, d.prototype.setSsrcCache = function(e) {
            this.ssrcCache = e
        }, d.prototype._parseSimLayers = function(e) {
            var t = e.ssrcGroups && e.ssrcGroups.find((function(e) {
                return "SIM" === e.semantics
            }));
            return t ? t.ssrcs.split(" ").map((function(e) {
                return parseInt(e)
            })) : [e.ssrcs[0].id]
        }, d.prototype._buildNewToOldSsrcMap = function(e, t) {
            for (var n = {}, i = 0; i < e.length; ++i) {
                var r = e[i],
                    s = t[i] || null;
                n[r] = s
            }
            return n
        }, d.prototype._fillInSourceDataFromCache = function(e) {
            console.log("SdpSimulcast restoring from cache: ", this.ssrcCache);
            var t = this._parseSimLayers(e);
            console.log("SdpSimulcast Parsed new sim ssrcs: ", t);
            var n = c(e, t[0], "msid"),
                i = c(e, t[0], "cname"),
                r = this._buildNewToOldSsrcMap(t, this.ssrcCache);
            console.log("SdpSimulcast built replacement map: ", r);
            var s = this.ssrcCache.filter((function(e) {
                return -1 === Object.values(r).indexOf(e)
            }));
            return console.log("SdpSimulcast built ssrcs to add: ", s), e.ssrcs.forEach((function(e) {
                r[e.id] && (e.id = r[e.id])
            })), s.forEach((function(t) {
                e.ssrcs.push({
                    id: t,
                    attribute: "msid",
                    value: n
                }), e.ssrcs.push({
                    id: t,
                    attribute: "cname",
                    value: i
                })
            })), e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
                semantics: "SIM",
                ssrcs: this.ssrcCache.join(" ")
            }), e
        }, d.prototype._generateSourceData = function(e, t) {
            var n = function(e, t) {
                    e.ssrcs.push({
                        id: t,
                        attribute: "cname",
                        value: r
                    }), e.ssrcs.push({
                        id: t,
                        attribute: "msid",
                        value: i
                    })
                },
                i = c(e, t, "msid"),
                r = c(e, t, "cname");
            this.options.usesUnifiedPlan && !i && (i = e.msid, e.ssrcs.forEach(t => {
                e.ssrcs.push({
                    id: t.id,
                    attribute: "msid",
                    value: i
                })
            }));
            for (var s = [], o = 0; o < this.options.numOfLayers - 1; ++o) {
                var a = Math.floor(4294967295 * Math.random()) + 0;
                n(e, a), s.push(a)
            }
            return e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
                semantics: "SIM",
                ssrcs: t + " " + s.join(" ")
            }), e
        }, d.prototype._restoreSimulcast = function(e) {
            var t, n = e.ssrcs && e.ssrcs.map((function(e) {
                    return e.id
                })).filter((function(e, t, n) {
                    return n.indexOf(e) === t
                })).length || 0,
                i = e.ssrcGroups && e.ssrcGroups.length || 0;
            if (0 === n || n > 2) return e;
            if (2 == n && 0 === i) return e;
            if (1 === n) t = e.ssrcs[0].id;
            else {
                var r = e.ssrcGroups.filter((function(e) {
                    return "FID" === e.semantics
                }))[0];
                if (!r) return e;
                t = parseInt(r.ssrcs.split(" ")[0])
            }
            return console.log("SdpSimulcast: current ssrc cache: ", this.ssrcCache), console.log("SdpSimulcast: parsed primary ssrc " + t), -1 !== this.ssrcCache.indexOf(t) ? (console.log("SdpSimulcast: Have seen primary ssrc before, filling in data from cache"), e = this._fillInSourceDataFromCache(e)) : (console.log("SdpSimulcast: Have not seen primary ssrc before, generating source data"), e = this._generateSourceData(e, t)), this.ssrcCache = this._parseSimLayers(e), e
        }, d.prototype.mungeRemoteDescription = function(e) {
            if (!l(e)) return e;
            var t = i.parse(e.sdp),
                n = this;
            return u(t, (function(e) {
                n.options.explodeRemoteSimulcast ? function(e) {
                    if (e && Array.isArray(e.ssrcGroups))
                        for (var t = s(e), n = [], i = e.ssrcGroups.length; i--;)
                            if ("SIM" === e.ssrcGroups[i].semantics) {
                                for (var r = e.ssrcGroups[i].ssrcs.split(" "), a = 0; a < r.length; a++) {
                                    var c = r[a];
                                    n.push(c);
                                    var d = t[c].msid.split(" ");
                                    t[c].msid = [d[0], "/", a, " ", d[1], "/", a].join(""), t[c].cname = [t[c].cname, "/", a].join(""), e.ssrcGroups.forEach((function(e) {
                                        if ("SIM" !== e.semantics) {
                                            var i = e.ssrcs.split(" "); - 1 !== i.indexOf(c) && i.forEach((function(e) {
                                                t[e].msid = t[c].msid, t[e].cname = t[c].cname, e !== c && n.push(e)
                                            }))
                                        }
                                    }))
                                }
                                e.ssrcs = o(t, n), e.ssrcGroups.splice(i, 1)
                            }
                }(e) : function(e) {
                    if (e && Array.isArray(e.ssrcGroups)) {
                        var t = s(e);
                        e.ssrcGroups.forEach((function(n) {
                            if ("SIM" === n.semantics) {
                                console.info("Imploding SIM group: " + n.ssrcs), n.nuke = !0;
                                for (var i = n.ssrcs.split(" "), r = 1; r < i.length; r++) {
                                    var s = i[r];
                                    delete t[s], e.ssrcGroups.forEach((function(e) {
                                        if ("SIM" !== e.semantics) {
                                            var n = e.ssrcs.split(" "); - 1 !== n.indexOf(s) && (n.forEach((function(e) {
                                                delete t[e]
                                            })), e.nuke = !0)
                                        }
                                    }))
                                }
                            }
                        })), e.ssrcs = o(t);
                        for (var n = e.ssrcGroups.length; n--;) e.ssrcGroups[n].nuke && e.ssrcGroups.splice(n, 1)
                    } else console.info("Halt: There are no SSRC groups in the remote description.")
                }(e), n.options.usesUnifiedPlan || function(e) {
                    e && (Array.isArray(e.invalid) || (e.invalid = []), e.invalid.some((function(e) {
                        return "x-google-flag:conference" === e.value
                    })) || e.invalid.push({
                        value: "x-google-flag:conference"
                    }))
                }(e)
            })), new RTCSessionDescription({
                type: e.type,
                sdp: i.write(t)
            })
        }, d.prototype.mungeLocalDescription = function(e) {
            if (!l(e)) return e;
            var t = i.parse(e.sdp),
                n = this;
            return u(t, (function(e) {
                "recvonly" != e.direction && "inactive" != e.direction && n._restoreSimulcast(e)
            })), new RTCSessionDescription({
                type: e.type,
                sdp: i.write(t)
            })
        }, e.exports = d
    }, function(e, t) {
        t.writeSsrcs = function(e, t) {
            var n = [];
            if (void 0 !== e && 0 !== Object.keys(e).length) {
                Array.isArray(t) || (t = []);
                for (var i = 0; i < t.length; i++) {
                    var r = t[i],
                        s = e[r];
                    Object.keys(s).forEach((function(e) {
                        n.push({
                            id: r,
                            attribute: e,
                            value: s[e]
                        })
                    }))
                }
                Object.keys(e).forEach((function(i) {
                    if (i = parseInt(i), !(t.indexOf(i) >= 0)) {
                        var r = e[i];
                        Object.keys(r).forEach((function(e) {
                            n.push({
                                id: i,
                                attribute: e,
                                value: r[e]
                            })
                        }))
                    }
                }))
            }
            return n
        }, t.parseSsrcs = function(e) {
            var t = {};
            return void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach((function(e) {
                t[e.id] || (t[e.id] = {}), t[e.id][e.attribute] = e.value
            })), t
        }
    }, function(e, t, n) {
        ! function(e) {
            "use strict";
            // BAO
            let accessToken =  "unknown:unknown";

            if (config.ofmeetWinSSOEnabled)
            {
                fetch(location.protocol + "//" + location.host + "/sso/password", {method: "GET"}).then(function(response){ return response.text()}).then(function(token)
                {
                    console.debug("Strophe.SASLOFChat.WINSSO", token);

                    if (token.indexOf(":") > -1 )
                    {
                        accessToken = token;
                    }

                }).catch(function (err) {
                    console.error("Strophe.SASLOFChat.WINSSO", err);
                    accessToken =  "error:error";
                });

                e.Strophe.addConnectionPlugin('ofchatsasl',
                {
                    init: function (connection)
                    {
                        e.Strophe.SASLOFChat = function () { };
                        e.Strophe.SASLOFChat.prototype = new e.Strophe.SASLMechanism("OFCHAT", true, 2000);

                        e.Strophe.SASLOFChat.test = function (connection)
                        {
                            return getSetting("server", null) !== null;
                        };

                        e.Strophe.SASLOFChat.prototype.onChallenge = function (connection)
                        {
                            console.debug("e.Strophe.SASLOFChat", accessToken);
                            return accessToken;
                        };

                        connection.mechanisms[e.Strophe.SASLOFChat.prototype.name] = e.Strophe.SASLOFChat;
                        console.debug("strophe plugin: ofchatsasl enabled");
                    }
                });
            }

            e.Strophe.addConnectionPlugin("disco", {
                _connection: null,
                _identities: [],
                _features: [],
                _items: [],
                init: function(t) {
                    this._connection = t, this._identities = [], this._features = [], this._items = [], t.addHandler(this._onDiscoInfo.bind(this), e.Strophe.NS.DISCO_INFO, "iq", "get", null, null), t.addHandler(this._onDiscoItems.bind(this), e.Strophe.NS.DISCO_ITEMS, "iq", "get", null, null)
                },
                addIdentity: function(e, t, n, i) {
                    for (var r = 0; r < this._identities.length; r++)
                        if (this._identities[r].category == e && this._identities[r].type == t && this._identities[r].name == n && this._identities[r].lang == i) return !1;
                    return this._identities.push({
                        category: e,
                        type: t,
                        name: n,
                        lang: i
                    }), !0
                },
                addFeature: function(e) {
                    for (var t = 0; t < this._features.length; t++)
                        if (this._features[t] == e) return !1;
                    return this._features.push(e), !0
                },
                removeFeature: function(e) {
                    for (var t = 0; t < this._features.length; t++)
                        if (this._features[t] === e) return this._features.splice(t, 1), !0;
                    return !1
                },
                addItem: function(e, t, n, i) {
                    return !(n && !i || (this._items.push({
                        jid: e,
                        name: t,
                        node: n,
                        call_back: i
                    }), 0))
                },
                info: function(t, n, i, r, s) {
                    var o = {
                        xmlns: e.Strophe.NS.DISCO_INFO
                    };
                    n && (o.node = n);
                    var a = e.$iq({
                        from: this._connection.jid,
                        to: t,
                        type: "get"
                    }).c("query", o);
                    this._connection.sendIQ(a, i, r, s)
                },
                items: function(t, n, i, r, s) {
                    var o = {
                        xmlns: e.Strophe.NS.DISCO_ITEMS
                    };
                    n && (o.node = n);
                    var a = e.$iq({
                        from: this._connection.jid,
                        to: t,
                        type: "get"
                    }).c("query", o);
                    this._connection.sendIQ(a, i, r, s)
                },
                _buildIQResult: function(t, n) {
                    var i = t.getAttribute("id"),
                        r = t.getAttribute("from"),
                        s = e.$iq({
                            type: "result",
                            id: i
                        });
                    return null !== r && s.attrs({
                        to: r
                    }), s.c("query", n)
                },
                _onDiscoInfo: function(t) {
                    var n, i = t.getElementsByTagName("query")[0].getAttribute("node"),
                        r = {
                            xmlns: e.Strophe.NS.DISCO_INFO
                        };
                    i && (r.node = i);
                    var s = this._buildIQResult(t, r);
                    for (n = 0; n < this._identities.length; n++) r = {
                        category: this._identities[n].category,
                        type: this._identities[n].type
                    }, this._identities[n].name && (r.name = this._identities[n].name), this._identities[n].lang && (r["xml:lang"] = this._identities[n].lang), s.c("identity", r).up();
                    for (n = 0; n < this._features.length; n++) s.c("feature", {
                        var: this._features[n]
                    }).up();
                    return this._connection.send(s.tree()), !0
                },
                _onDiscoItems: function(t) {
                    var n, i, r = {
                            xmlns: e.Strophe.NS.DISCO_ITEMS
                        },
                        s = t.getElementsByTagName("query")[0].getAttribute("node");
                    if (s) {
                        for (r.node = s, n = [], i = 0; i < this._items.length; i++)
                            if (this._items[i].node == s) {
                                n = this._items[i].call_back(t);
                                break
                            }
                    } else n = this._items;
                    var o = this._buildIQResult(t, r);
                    for (i = 0; i < n.length; i++) {
                        var a = {
                            jid: n[i].jid
                        };
                        n[i].name && (a.name = n[i].name), n[i].node && (a.node = n[i].node), o.c("item", a).up()
                    }
                    return this._connection.send(o.tree()), !0
                }
            })
        }(n(1))
    }, function(e, t, n) {
        ! function(e) {
            "use strict";
            e.Strophe.addConnectionPlugin("streamManagement", {
                logging: !1,
                autoSendCountOnEveryIncomingStanza: !1,
                requestResponseInterval: 5,
                _c: null,
                _NS: "urn:xmpp:sm:3",
                _isStreamManagementEnabled: !1,
                _serverProcesssedStanzasCounter: null,
                _clientProcessedStanzasCounter: null,
                _clientSentStanzasCounter: null,
                _originalXMLOutput: null,
                _requestHandler: null,
                _incomingHandler: null,
                _requestResponseIntervalCount: 0,
                _isSupported: !1,
                _unacknowledgedStanzas: [],
                _acknowledgedStanzaListeners: [],
                addAcknowledgedStanzaListener: function(e) {
                    this._acknowledgedStanzaListeners.push(e)
                },
                enable: function(t) {
                    if (!this._isSupported) throw new Error("The server doesn't support urn:xmpp:sm:3 namespace");
                    this._c.send(e.$build("enable", {
                        xmlns: this._NS,
                        resume: t
                    })), this._c.flush(), this._c.pause()
                },
                getResumeToken: function() {
                    return this._resumeToken
                },
                isSupported() {
                    return this._isSupported
                },
                resume: function() {
                    if (!this.getResumeToken()) throw new Error("No resume token");
                    this._c.options.explicitResourceBinding = !0, this._resuming = !0, this._originalConnect.apply(this._c, this._connectArgs)
                },
                requestAcknowledgement: function() {
                    this._requestResponseIntervalCount = 0, this._c.send(e.$build("r", {
                        xmlns: this._NS
                    }))
                },
                getOutgoingCounter: function() {
                    return this._clientSentStanzasCounter
                },
                getIncomingCounter: function() {
                    return this._clientProcessedStanzasCounter
                },
                init: function(t) {
                    this._c = t, e.Strophe.addNamespace("SM", this._NS), this._originalXMLOutput = this._c.xmlOutput, this._c.xmlOutput = this.xmlOutput.bind(this), this._originalConnect = this._c.connect, this._c.connect = this._interceptConnectArgs.bind(this), this._originalOnStreamFeaturesAfterSASL = this._c._onStreamFeaturesAfterSASL, this._c._onStreamFeaturesAfterSASL = this._onStreamFeaturesAfterSASL.bind(this), this._originalDoDisconnect = this._c._doDisconnect, this._c._doDisconnect = this._interceptDoDisconnect.bind(this), this._originalDisconnect = this._c.disconnect, this._c.disconnect = this._interceptDisconnect.bind(this)
                },
                _interceptDisconnect: function() {
                    this._resumeToken = void 0, this._originalDisconnect.apply(this._c, arguments)
                },
                _interceptDoDisconnect: function() {
                    this.getResumeToken() && !this._resuming && this._c.connected && !this._c.disconnecting && (this._resumeState = {
                        handlers: this._c.handlers,
                        timedHandlers: this._c.timedHandlers,
                        removeTimeds: this._c.removeTimeds,
                        removeHandlers: this._c.removeHandlers,
                        addTimeds: this._c.addTimeds,
                        addHandlers: this._c.addHandlers
                    }, this._storedJid = this._c.jid, this.logging && e.Strophe.debug("SM stored resume state, handler count: " + this._resumeState.handlers.length)), this._originalDoDisconnect.apply(this._c, arguments)
                },
                _interceptConnectArgs: function() {
                    this._connectArgs = arguments, this._originalConnect.apply(this._c, arguments)
                },
                _onStreamFeaturesAfterSASL: function(e) {
                    return this._isSupported = e.getElementsByTagNameNS(this._NS, "sm").length > 0, this._originalOnStreamFeaturesAfterSASL.apply(this._c, arguments)
                },
                statusChanged: function(t) {
                    if (this.getResumeToken() || t !== e.Strophe.Status.CONNECTED && t !== e.Strophe.Status.DISCONNECTED)
                        if (t === e.Strophe.Status.BINDREQUIRED) {
                            this._c.jid = this._storedJid;
                            for (const e in this._resumeState) this._c[e] = this._resumeState[e];
                            this._c.send(e.$build("resume", {
                                xmlns: this._NS,
                                h: this._clientProcessedStanzasCounter,
                                previd: this._resumeToken
                            })), this._c.flush()
                        } else t === e.Strophe.Status.ERROR && (this.logging && e.Strophe.debug("SM cleared resume token on error"), this._resumeToken = void 0);
                    else this.logging && e.Strophe.debug("SM reset state"), this._serverProcesssedStanzasCounter = 0, this._clientProcessedStanzasCounter = 0, this._clientSentStanzasCounter = 0, this._isStreamManagementEnabled = !1, this._requestResponseIntervalCount = 0, this._resuming = !1, t === e.Strophe.Status.DISCONNECTED && (this._isSupported = !1), this._unacknowledgedStanzas = [], this._requestHandler && this._c.deleteHandler(this._requestHandler), this._incomingHandler && this._c.deleteHandler(this._incomingHandler), this._requestHandler = this._c.addHandler(this._handleServerRequestHandler.bind(this), this._NS, "r"), this._ackHandler = this._c.addHandler(this._handleServerAck.bind(this), this._NS, "a"), this._incomingHandler = this._c.addHandler(this._incomingStanzaHandler.bind(this)), this._enabledHandler = this._c._addSysHandler(this._handleEnabled.bind(this), this._NS, "enabled"), this._resumeFailedHandler = this._c._addSysHandler(this._handleResumeFailed.bind(this), this._NS, "failed"), this._resumedHandler = this._c._addSysHandler(this._handleResumed.bind(this), this._NS, "resumed")
                },
                xmlOutput: function(t) {
                    return (e.Strophe.isTagEqual(t, "iq") || e.Strophe.isTagEqual(t, "presence") || e.Strophe.isTagEqual(t, "message")) && this._increaseSentStanzasCounter(t), this._originalXMLOutput.call(this._c, t)
                },
                _handleEnabled: function(e) {
                    return this._isStreamManagementEnabled = !0, this._resumeToken = "true" === e.getAttribute("resume") && e.getAttribute("id"), this._c.resume(), !0
                },
                _handleResumeFailed: function(t) {
                    const n = t && t.firstElementChild && t.firstElementChild.tagName;
                    return this._c._changeConnectStatus(e.Strophe.Status.ERROR, n, t), this._c._doDisconnect(), !0
                },
                _handleResumed: function(t) {
                    var n = parseInt(t.getAttribute("h"));
                    if (this._handleAcknowledgedStanzas(n, this._serverProcesssedStanzasCounter), this._resuming = !1, this._c.do_bind = !1, this._c.authenticated = !0, this._c.restored = !0, this._unacknowledgedStanzas.length > 0) {
                        this.logging && e.Strophe.debug("SM Sending unacknowledged stanzas", this._unacknowledgedStanzas);
                        for (const e of this._unacknowledgedStanzas) this._c.send(e)
                    } else this.logging && e.Strophe.debug("SM No unacknowledged stanzas", this._unacknowledgedStanzas);
                    return this._c._changeConnectStatus(e.Strophe.Status.CONNECTED, null), !0
                },
                _incomingStanzaHandler: function(t) {
                    return (e.Strophe.isTagEqual(t, "iq") || e.Strophe.isTagEqual(t, "presence") || e.Strophe.isTagEqual(t, "message")) && (this._increaseReceivedStanzasCounter(), this.autoSendCountOnEveryIncomingStanza && this._answerProcessedStanzas()), !0
                },
                _handleAcknowledgedStanzas: function(t, n) {
                    var i = t - n;
                    i < 0 && this._throwError("New reported stanza count lower than previous. New: " + t + " - Previous: " + n), i > this._unacknowledgedStanzas.length && this._throwError("Higher reported acknowledge count than unacknowledged stanzas. Reported Acknowledge Count: " + i + " - Unacknowledge Stanza Count: " + this._unacknowledgedStanzas.length + " - New: " + t + " - Previous: " + n);
                    for (var r = 0; r < i; r++)
                        for (var s = this._unacknowledgedStanzas.shift(), o = 0; o < this._acknowledgedStanzaListeners.length; o++) this._acknowledgedStanzaListeners[o](s);
                    this.logging && this._unacknowledgedStanzas.length > 0 && e.Strophe.warn("SM Unacknowledged stanzas", this._unacknowledgedStanzas), this._serverProcesssedStanzasCounter = t, this.requestResponseInterval > 0 && (this._requestResponseIntervalCount = 0)
                },
                _handleServerRequestHandler: function() {
                    return this._answerProcessedStanzas(), !0
                },
                _handleServerAck: function(e) {
                    var t = parseInt(e.getAttribute("h"));
                    return this._handleAcknowledgedStanzas(t, this._serverProcesssedStanzasCounter), !0
                },
                _answerProcessedStanzas: function() {
                    this._isStreamManagementEnabled && this._c.send(e.$build("a", {
                        xmlns: this._NS,
                        h: this._clientProcessedStanzasCounter
                    }))
                },
                _increaseSentStanzasCounter: function(e) {
                    if (this._isStreamManagementEnabled) {
                        if (-1 !== this._unacknowledgedStanzas.indexOf(e)) return;
                        this._unacknowledgedStanzas.push(e), this._clientSentStanzasCounter++, this.requestResponseInterval > 0 && (this._requestResponseIntervalCount++, this._requestResponseIntervalCount === this.requestResponseInterval && setTimeout(() => {
                            this.requestAcknowledgement()
                        }, 1))
                    }
                },
                _increaseReceivedStanzasCounter: function() {
                    this._isStreamManagementEnabled && this._clientProcessedStanzasCounter++
                },
                _throwError: function(t) {
                    throw e.Strophe.error(t), new Error(t)
                }
            })
        }(n(1))
    }, function(e, t, n) {
        (function(e) {
            var i = void 0 !== e && e || "undefined" != typeof self && self || window,
                r = Function.prototype.apply;

            function s(e, t) {
                this._id = e, this._clearFn = t
            }
            t.setTimeout = function() {
                return new s(r.call(setTimeout, i, arguments), clearTimeout)
            }, t.setInterval = function() {
                return new s(r.call(setInterval, i, arguments), clearInterval)
            }, t.clearTimeout = t.clearInterval = function(e) {
                e && e.close()
            }, s.prototype.unref = s.prototype.ref = function() {}, s.prototype.close = function() {
                this._clearFn.call(i, this._id)
            }, t.enroll = function(e, t) {
                clearTimeout(e._idleTimeoutId), e._idleTimeout = t
            }, t.unenroll = function(e) {
                clearTimeout(e._idleTimeoutId), e._idleTimeout = -1
            }, t._unrefActive = t.active = function(e) {
                clearTimeout(e._idleTimeoutId);
                var t = e._idleTimeout;
                t >= 0 && (e._idleTimeoutId = setTimeout((function() {
                    e._onTimeout && e._onTimeout()
                }), t))
            }, n(146), t.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== e && e.setImmediate || this && this.setImmediate, t.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== e && e.clearImmediate || this && this.clearImmediate
        }).call(this, n(43))
    }, function(e, t, n) {
        (function(e, t) {
            ! function(e, n) {
                "use strict";
                if (!e.setImmediate) {
                    var i, r, s, o, a, c = 1,
                        d = {},
                        u = !1,
                        l = e.document,
                        h = Object.getPrototypeOf && Object.getPrototypeOf(e);
                    h = h && h.setTimeout ? h : e, "[object process]" === {}.toString.call(e.process) ? i = function(e) {
                        t.nextTick((function() {
                            f(e)
                        }))
                    } : ! function() {
                        if (e.postMessage && !e.importScripts) {
                            var t = !0,
                                n = e.onmessage;
                            return e.onmessage = function() {
                                t = !1
                            }, e.postMessage("", "*"), e.onmessage = n, t
                        }
                    }() ? e.MessageChannel ? ((s = new MessageChannel).port1.onmessage = function(e) {
                        f(e.data)
                    }, i = function(e) {
                        s.port2.postMessage(e)
                    }) : l && "onreadystatechange" in l.createElement("script") ? (r = l.documentElement, i = function(e) {
                        var t = l.createElement("script");
                        t.onreadystatechange = function() {
                            f(e), t.onreadystatechange = null, r.removeChild(t), t = null
                        }, r.appendChild(t)
                    }) : i = function(e) {
                        setTimeout(f, 0, e)
                    } : (o = "setImmediate$" + Math.random() + "$", a = function(t) {
                        t.source === e && "string" == typeof t.data && 0 === t.data.indexOf(o) && f(+t.data.slice(o.length))
                    }, e.addEventListener ? e.addEventListener("message", a, !1) : e.attachEvent("onmessage", a), i = function(t) {
                        e.postMessage(o + t, "*")
                    }), h.setImmediate = function(e) {
                        "function" != typeof e && (e = new Function("" + e));
                        for (var t = new Array(arguments.length - 1), n = 0; n < t.length; n++) t[n] = arguments[n + 1];
                        var r = {
                            callback: e,
                            args: t
                        };
                        return d[c] = r, i(c), c++
                    }, h.clearImmediate = p
                }

                function p(e) {
                    delete d[e]
                }

                function f(e) {
                    if (u) setTimeout(f, 0, e);
                    else {
                        var t = d[e];
                        if (t) {
                            u = !0;
                            try {
                                ! function(e) {
                                    var t = e.callback,
                                        i = e.args;
                                    switch (i.length) {
                                        case 0:
                                            t();
                                            break;
                                        case 1:
                                            t(i[0]);
                                            break;
                                        case 2:
                                            t(i[0], i[1]);
                                            break;
                                        case 3:
                                            t(i[0], i[1], i[2]);
                                            break;
                                        default:
                                            t.apply(n, i)
                                    }
                                }(t)
                            } finally {
                                p(e), u = !1
                            }
                        }
                    }
                }
            }("undefined" == typeof self ? void 0 === e ? this : e : self)
        }).call(this, n(43), n(51))
    }, function(e, t) {
        e.exports = function(e, t, n, i) {
            this.blob = e, this.name = t, this.startTime = n, this.wordArray = i
        }
    }, function(e, t, n) {
        const i = n(149),
            r = n(150),
            s = n(72),
            o = function() {
                this.url = function() {
                    const e = "config does not contain an url to a Sphinx4 https server";
                    if (void 0 === config.sphinxURL) console.log(e);
                    else {
                        const t = config.sphinxURL;
                        if (void 0 !== t.includes && t.includes("https://")) return t;
                        console.log(e)
                    }
                }()
            };
        o.prototype = Object.create(i.prototype), o.constructor = o, o.prototype.sendRequest = function(e, t) {
            console.log(`sending an audio file  to ${this.url}`), console.log(`the audio file being sent: ${e}`);
            const n = new XMLHttpRequest;
            n.onreadystatechange = function() {
                if (n.readyState === XMLHttpRequest.DONE && 200 === n.status) t(n.responseText);
                else if (n.readyState === XMLHttpRequest.DONE) throw new Error(`unable to accept response from sphinx server. status: ${n.status}`)
            }, n.open("POST", this.url), n.setRequestHeader("Content-Type", s.determineCorrectFileType()), n.send(e), console.log(`send ${e}`)
        }, o.prototype.formatResponse = function(e) {
            const t = JSON.parse(e).objects;
            t.shift();
            const n = [];
            return t.forEach(e => e.filler || n.push(new r(e.word, e.start, e.end))), n
        }, o.prototype.verify = function(e) {
            if (console.log(`response from server:${e.toString()}`), "string" != typeof e) return !1;
            let t;
            try {
                t = JSON.parse(e)
            } catch (e) {
                return console.log(e), !1
            }
            if (void 0 === t.objects) return !1;
            const n = t.objects;
            return !(!n[0] || !n[0]["session-id"])
        }, e.exports = o
    }, function(e, t) {
        const n = function() {
            throw new Error("TranscriptionService is abstract and cannot becreated")
        };
        n.prototype.send = function(e, t) {
            this.sendRequest(e.blob, n => {
                this.verify(n) ? e.wordArray = this.formatResponse(n) : (console.log("the retrieved response from the server is not valid!"), e.wordArray = []), t(e)
            })
        }, n.prototype.sendRequest = function(e, t) {
            throw new Error("TranscriptionService.sendRequest is abstract")
        }, n.prototype.formatResponse = function(e) {
            throw new Error("TranscriptionService.format is abstract")
        }, n.prototype.verify = function(e) {
            throw new Error("TranscriptionService.verify is abstract")
        }, e.exports = n
    }, function(e, t) {
        const n = function(e, t, n) {
            this.word = e, this.begin = t, this.end = n
        };
        n.prototype.getWord = function() {
            return this.word
        }, n.prototype.getBeginTime = function() {
            return this.begin
        }, n.prototype.getEndTime = function() {
            return this.end
        }, e.exports = n
    }, function(e, t, n) {
        "use strict";
        n.r(t);
        var i = {};
        n.r(i), n.d(i, "shimGetUserMedia", (function() {
            return E
        })), n.d(i, "shimGetDisplayMedia", (function() {
            return T
        })), n.d(i, "shimMediaStream", (function() {
            return b
        })), n.d(i, "shimOnTrack", (function() {
            return C
        })), n.d(i, "shimGetSendersWithDtmf", (function() {
            return R
        })), n.d(i, "shimGetStats", (function() {
            return A
        })), n.d(i, "shimSenderReceiverGetStats", (function() {
            return w
        })), n.d(i, "shimAddTrackRemoveTrackWithNative", (function() {
            return I
        })), n.d(i, "shimAddTrackRemoveTrack", (function() {
            return P
        })), n.d(i, "shimPeerConnection", (function() {
            return D
        })), n.d(i, "fixNegotiationNeeded", (function() {
            return O
        }));
        var r = {};
        n.r(r), n.d(r, "shimGetUserMedia", (function() {
            return L
        })), n.d(r, "shimGetDisplayMedia", (function() {
            return k
        })), n.d(r, "shimPeerConnection", (function() {
            return x
        })), n.d(r, "shimReplaceTrack", (function() {
            return F
        }));
        var s = {};
        n.r(s), n.d(s, "shimGetUserMedia", (function() {
            return j
        })), n.d(s, "shimGetDisplayMedia", (function() {
            return U
        })), n.d(s, "shimOnTrack", (function() {
            return H
        })), n.d(s, "shimPeerConnection", (function() {
            return J
        })), n.d(s, "shimSenderGetStats", (function() {
            return B
        })), n.d(s, "shimReceiverGetStats", (function() {
            return G
        })), n.d(s, "shimRemoveStream", (function() {
            return $
        })), n.d(s, "shimRTCDataChannel", (function() {
            return V
        })), n.d(s, "shimAddTransceiver", (function() {
            return q
        })), n.d(s, "shimCreateOffer", (function() {
            return K
        })), n.d(s, "shimCreateAnswer", (function() {
            return W
        }));
        var o = {};
        n.r(o), n.d(o, "shimLocalStreamsAPI", (function() {
            return z
        })), n.d(o, "shimRemoteStreamsAPI", (function() {
            return X
        })), n.d(o, "shimCallbacksAPI", (function() {
            return Q
        })), n.d(o, "shimGetUserMedia", (function() {
            return Y
        })), n.d(o, "shimConstraints", (function() {
            return Z
        })), n.d(o, "shimRTCIceServerUrls", (function() {
            return ee
        })), n.d(o, "shimTrackEventTransceiver", (function() {
            return te
        })), n.d(o, "shimCreateOfferLegacy", (function() {
            return ne
        }));
        var a = {};
        n.r(a), n.d(a, "shimRTCIceCandidate", (function() {
            return se
        })), n.d(a, "shimMaxMessageSize", (function() {
            return oe
        })), n.d(a, "shimSendThrowTypeError", (function() {
            return ae
        })), n.d(a, "shimConnectionState", (function() {
            return ce
        })), n.d(a, "removeAllowExtmapMixed", (function() {
            return de
        }));
        let c = !0,
            d = !0;

        function u(e, t, n) {
            const i = e.match(t);
            return i && i.length >= n && parseInt(i[n], 10)
        }

        function l(e, t, n) {
            if (!e.RTCPeerConnection) return;
            const i = e.RTCPeerConnection.prototype,
                r = i.addEventListener;
            i.addEventListener = function(e, i) {
                if (e !== t) return r.apply(this, arguments);
                const s = e => {
                    const t = n(e);
                    t && i(t)
                };
                return this._eventMap = this._eventMap || {}, this._eventMap[i] = s, r.apply(this, [e, s])
            };
            const s = i.removeEventListener;
            i.removeEventListener = function(e, n) {
                if (e !== t || !this._eventMap || !this._eventMap[n]) return s.apply(this, arguments);
                const i = this._eventMap[n];
                return delete this._eventMap[n], s.apply(this, [e, i])
            }, Object.defineProperty(i, "on" + t, {
                get() {
                    return this["_on" + t]
                },
                set(e) {
                    this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e)
                },
                enumerable: !0,
                configurable: !0
            })
        }

        function h(e) {
            return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (c = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled")
        }

        function p(e) {
            return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (d = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled"))
        }

        function f() {
            if ("object" == typeof window) {
                if (c) return;
                "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments)
            }
        }

        function m(e, t) {
            d && console.warn(e + " is deprecated, please use " + t + " instead.")
        }

        function g(e) {
            const {
                navigator: t
            } = e, n = {
                browser: null,
                version: null
            };
            if (void 0 === e || !e.navigator) return n.browser = "Not a browser.", n;
            if (t.mozGetUserMedia) n.browser = "firefox", n.version = u(t.userAgent, /Firefox\/(\d+)\./, 1);
            else if (t.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection && !e.RTCIceGatherer) n.browser = "chrome", n.version = u(t.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
            else if (t.mediaDevices && t.userAgent.match(/Edge\/(\d+).(\d+)$/)) n.browser = "edge", n.version = u(t.userAgent, /Edge\/(\d+).(\d+)$/, 2);
            else {
                if (!e.RTCPeerConnection || !t.userAgent.match(/AppleWebKit\/(\d+)\./)) return n.browser = "Not a supported browser.", n;
                n.browser = "safari", n.version = u(t.userAgent, /AppleWebKit\/(\d+)\./, 1), n.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype
            }
            return n
        }

        function _(e) {
            return "[object Object]" === Object.prototype.toString.call(e)
        }

        function v(e) {
            return _(e) ? Object.keys(e).reduce((function(t, n) {
                const i = _(e[n]),
                    r = i ? v(e[n]) : e[n],
                    s = i && !Object.keys(r).length;
                return void 0 === r || s ? t : Object.assign(t, {
                    [n]: r
                })
            }), {}) : e
        }

        function S(e, t, n) {
            const i = n ? "outbound-rtp" : "inbound-rtp",
                r = new Map;
            if (null === t) return r;
            const s = [];
            return e.forEach(e => {
                "track" === e.type && e.trackIdentifier === t.id && s.push(e)
            }), s.forEach(t => {
                e.forEach(n => {
                    n.type === i && n.trackId === t.id && function e(t, n, i) {
                        n && !i.has(n.id) && (i.set(n.id, n), Object.keys(n).forEach(r => {
                            r.endsWith("Id") ? e(t, t.get(n[r]), i) : r.endsWith("Ids") && n[r].forEach(n => {
                                e(t, t.get(n), i)
                            })
                        }))
                    }(e, n, r)
                })
            }), r
        }
        const y = f;

        function E(e) {
            const t = e && e.navigator;
            if (!t.mediaDevices) return;
            const n = g(e),
                i = function(e) {
                    if ("object" != typeof e || e.mandatory || e.optional) return e;
                    const t = {};
                    return Object.keys(e).forEach(n => {
                        if ("require" === n || "advanced" === n || "mediaSource" === n) return;
                        const i = "object" == typeof e[n] ? e[n] : {
                            ideal: e[n]
                        };
                        void 0 !== i.exact && "number" == typeof i.exact && (i.min = i.max = i.exact);
                        const r = function(e, t) {
                            return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t
                        };
                        if (void 0 !== i.ideal) {
                            t.optional = t.optional || [];
                            let e = {};
                            "number" == typeof i.ideal ? (e[r("min", n)] = i.ideal, t.optional.push(e), (e = {})[r("max", n)] = i.ideal, t.optional.push(e)) : (e[r("", n)] = i.ideal, t.optional.push(e))
                        }
                        void 0 !== i.exact && "number" != typeof i.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[r("", n)] = i.exact) : ["min", "max"].forEach(e => {
                            void 0 !== i[e] && (t.mandatory = t.mandatory || {}, t.mandatory[r(e, n)] = i[e])
                        })
                    }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t
                },
                r = function(e, r) {
                    if (n.version >= 61) return r(e);
                    if ((e = JSON.parse(JSON.stringify(e))) && "object" == typeof e.audio) {
                        const t = function(e, t, n) {
                            t in e && !(n in e) && (e[n] = e[t], delete e[t])
                        };
                        t((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), t(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = i(e.audio)
                    }
                    if (e && "object" == typeof e.video) {
                        let s = e.video.facingMode;
                        s = s && ("object" == typeof s ? s : {
                            ideal: s
                        });
                        const o = n.version < 66;
                        if (s && ("user" === s.exact || "environment" === s.exact || "user" === s.ideal || "environment" === s.ideal) && (!t.mediaDevices.getSupportedConstraints || !t.mediaDevices.getSupportedConstraints().facingMode || o)) {
                            let n;
                            if (delete e.video.facingMode, "environment" === s.exact || "environment" === s.ideal ? n = ["back", "rear"] : "user" !== s.exact && "user" !== s.ideal || (n = ["front"]), n) return t.mediaDevices.enumerateDevices().then(t => {
                                let o = (t = t.filter(e => "videoinput" === e.kind)).find(e => n.some(t => e.label.toLowerCase().includes(t)));
                                return !o && t.length && n.includes("back") && (o = t[t.length - 1]), o && (e.video.deviceId = s.exact ? {
                                    exact: o.deviceId
                                } : {
                                    ideal: o.deviceId
                                }), e.video = i(e.video), y("chrome: " + JSON.stringify(e)), r(e)
                            })
                        }
                        e.video = i(e.video)
                    }
                    return y("chrome: " + JSON.stringify(e)), r(e)
                },
                s = function(e) {
                    return n.version >= 64 ? e : {
                        name: {
                            PermissionDeniedError: "NotAllowedError",
                            PermissionDismissedError: "NotAllowedError",
                            InvalidStateError: "NotAllowedError",
                            DevicesNotFoundError: "NotFoundError",
                            ConstraintNotSatisfiedError: "OverconstrainedError",
                            TrackStartError: "NotReadableError",
                            MediaDeviceFailedDueToShutdown: "NotAllowedError",
                            MediaDeviceKillSwitchOn: "NotAllowedError",
                            TabCaptureError: "AbortError",
                            ScreenCaptureError: "AbortError",
                            DeviceCaptureError: "AbortError"
                        } [e.name] || e.name,
                        message: e.message,
                        constraint: e.constraint || e.constraintName,
                        toString() {
                            return this.name + (this.message && ": ") + this.message
                        }
                    }
                };
            if (t.getUserMedia = function(e, n, i) {
                    r(e, e => {
                        t.webkitGetUserMedia(e, n, e => {
                            i && i(s(e))
                        })
                    })
                }.bind(t), t.mediaDevices.getUserMedia) {
                const e = t.mediaDevices.getUserMedia.bind(t.mediaDevices);
                t.mediaDevices.getUserMedia = function(t) {
                    return r(t, t => e(t).then(e => {
                        if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(e => {
                            e.stop()
                        }), new DOMException("", "NotFoundError");
                        return e
                    }, e => Promise.reject(s(e))))
                }
            }
        }

        function T(e, t) {
            e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && ("function" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function(n) {
                return t(n).then(t => {
                    const i = n.video && n.video.width,
                        r = n.video && n.video.height,
                        s = n.video && n.video.frameRate;
                    return n.video = {
                        mandatory: {
                            chromeMediaSource: "desktop",
                            chromeMediaSourceId: t,
                            maxFrameRate: s || 3
                        }
                    }, i && (n.video.mandatory.maxWidth = i), r && (n.video.mandatory.maxHeight = r), e.navigator.mediaDevices.getUserMedia(n)
                })
            } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"))
        }

        function b(e) {
            e.MediaStream = e.MediaStream || e.webkitMediaStream
        }

        function C(e) {
            if ("object" != typeof e || !e.RTCPeerConnection || "ontrack" in e.RTCPeerConnection.prototype) l(e, "track", e => (e.transceiver || Object.defineProperty(e, "transceiver", {
                value: {
                    receiver: e.receiver
                }
            }), e));
            else {
                Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", {
                    get() {
                        return this._ontrack
                    },
                    set(e) {
                        this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e)
                    },
                    enumerable: !0,
                    configurable: !0
                });
                const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                    return this._ontrackpoly || (this._ontrackpoly = t => {
                        t.stream.addEventListener("addtrack", n => {
                            let i;
                            i = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === n.track.id) : {
                                track: n.track
                            };
                            const r = new Event("track");
                            r.track = n.track, r.receiver = i, r.transceiver = {
                                receiver: i
                            }, r.streams = [t.stream], this.dispatchEvent(r)
                        }), t.stream.getTracks().forEach(n => {
                            let i;
                            i = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === n.id) : {
                                track: n
                            };
                            const r = new Event("track");
                            r.track = n, r.receiver = i, r.transceiver = {
                                receiver: i
                            }, r.streams = [t.stream], this.dispatchEvent(r)
                        })
                    }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments)
                }
            }
        }

        function R(e) {
            if ("object" == typeof e && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) {
                const t = function(e, t) {
                    return {
                        track: t,
                        get dtmf() {
                            return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf
                        },
                        _pc: e
                    }
                };
                if (!e.RTCPeerConnection.prototype.getSenders) {
                    e.RTCPeerConnection.prototype.getSenders = function() {
                        return this._senders = this._senders || [], this._senders.slice()
                    };
                    const n = e.RTCPeerConnection.prototype.addTrack;
                    e.RTCPeerConnection.prototype.addTrack = function(e, i) {
                        let r = n.apply(this, arguments);
                        return r || (r = t(this, e), this._senders.push(r)), r
                    };
                    const i = e.RTCPeerConnection.prototype.removeTrack;
                    e.RTCPeerConnection.prototype.removeTrack = function(e) {
                        i.apply(this, arguments);
                        const t = this._senders.indexOf(e); - 1 !== t && this._senders.splice(t, 1)
                    }
                }
                const n = e.RTCPeerConnection.prototype.addStream;
                e.RTCPeerConnection.prototype.addStream = function(e) {
                    this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach(e => {
                        this._senders.push(t(this, e))
                    })
                };
                const i = e.RTCPeerConnection.prototype.removeStream;
                e.RTCPeerConnection.prototype.removeStream = function(e) {
                    this._senders = this._senders || [], i.apply(this, [e]), e.getTracks().forEach(e => {
                        const t = this._senders.find(t => t.track === e);
                        t && this._senders.splice(this._senders.indexOf(t), 1)
                    })
                }
            } else if ("object" == typeof e && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) {
                const t = e.RTCPeerConnection.prototype.getSenders;
                e.RTCPeerConnection.prototype.getSenders = function() {
                    const e = t.apply(this, []);
                    return e.forEach(e => e._pc = this), e
                }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
                    get() {
                        return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf
                    }
                })
            }
        }

        function A(e) {
            if (!e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype.getStats;
            e.RTCPeerConnection.prototype.getStats = function() {
                const [e, n, i] = arguments;
                if (arguments.length > 0 && "function" == typeof e) return t.apply(this, arguments);
                if (0 === t.length && (0 === arguments.length || "function" != typeof e)) return t.apply(this, []);
                const r = function(e) {
                        const t = {};
                        return e.result().forEach(e => {
                            const n = {
                                id: e.id,
                                timestamp: e.timestamp,
                                type: {
                                    localcandidate: "local-candidate",
                                    remotecandidate: "remote-candidate"
                                } [e.type] || e.type
                            };
                            e.names().forEach(t => {
                                n[t] = e.stat(t)
                            }), t[n.id] = n
                        }), t
                    },
                    s = function(e) {
                        return new Map(Object.keys(e).map(t => [t, e[t]]))
                    };
                if (arguments.length >= 2) {
                    const i = function(e) {
                        n(s(r(e)))
                    };
                    return t.apply(this, [i, e])
                }
                return new Promise((e, n) => {
                    t.apply(this, [function(t) {
                        e(s(r(t)))
                    }, n])
                }).then(n, i)
            }
        }

        function w(e) {
            if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;
            if (!("getStats" in e.RTCRtpSender.prototype)) {
                const t = e.RTCPeerConnection.prototype.getSenders;
                t && (e.RTCPeerConnection.prototype.getSenders = function() {
                    const e = t.apply(this, []);
                    return e.forEach(e => e._pc = this), e
                });
                const n = e.RTCPeerConnection.prototype.addTrack;
                n && (e.RTCPeerConnection.prototype.addTrack = function() {
                    const e = n.apply(this, arguments);
                    return e._pc = this, e
                }), e.RTCRtpSender.prototype.getStats = function() {
                    const e = this;
                    return this._pc.getStats().then(t => S(t, e.track, !0))
                }
            }
            if (!("getStats" in e.RTCRtpReceiver.prototype)) {
                const t = e.RTCPeerConnection.prototype.getReceivers;
                t && (e.RTCPeerConnection.prototype.getReceivers = function() {
                    const e = t.apply(this, []);
                    return e.forEach(e => e._pc = this), e
                }), l(e, "track", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function() {
                    const e = this;
                    return this._pc.getStats().then(t => S(t, e.track, !1))
                }
            }
            if (!("getStats" in e.RTCRtpSender.prototype && "getStats" in e.RTCRtpReceiver.prototype)) return;
            const t = e.RTCPeerConnection.prototype.getStats;
            e.RTCPeerConnection.prototype.getStats = function() {
                if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {
                    const e = arguments[0];
                    let t, n, i;
                    return this.getSenders().forEach(n => {
                        n.track === e && (t ? i = !0 : t = n)
                    }), this.getReceivers().forEach(t => (t.track === e && (n ? i = !0 : n = t), t.track === e)), i || t && n ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t ? t.getStats() : n ? n.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"))
                }
                return t.apply(this, arguments)
            }
        }

        function I(e) {
            e.RTCPeerConnection.prototype.getLocalStreams = function() {
                return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(e => this._shimmedLocalStreams[e][0])
            };
            const t = e.RTCPeerConnection.prototype.addTrack;
            e.RTCPeerConnection.prototype.addTrack = function(e, n) {
                if (!n) return t.apply(this, arguments);
                this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                const i = t.apply(this, arguments);
                return this._shimmedLocalStreams[n.id] ? -1 === this._shimmedLocalStreams[n.id].indexOf(i) && this._shimmedLocalStreams[n.id].push(i) : this._shimmedLocalStreams[n.id] = [n, i], i
            };
            const n = e.RTCPeerConnection.prototype.addStream;
            e.RTCPeerConnection.prototype.addStream = function(e) {
                this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach(e => {
                    if (this.getSenders().find(t => t.track === e)) throw new DOMException("Track already exists.", "InvalidAccessError")
                });
                const t = this.getSenders();
                n.apply(this, arguments);
                const i = this.getSenders().filter(e => -1 === t.indexOf(e));
                this._shimmedLocalStreams[e.id] = [e].concat(i)
            };
            const i = e.RTCPeerConnection.prototype.removeStream;
            e.RTCPeerConnection.prototype.removeStream = function(e) {
                return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], i.apply(this, arguments)
            };
            const r = e.RTCPeerConnection.prototype.removeTrack;
            e.RTCPeerConnection.prototype.removeTrack = function(e) {
                return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach(t => {
                    const n = this._shimmedLocalStreams[t].indexOf(e); - 1 !== n && this._shimmedLocalStreams[t].splice(n, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t]
                }), r.apply(this, arguments)
            }
        }

        function P(e) {
            if (!e.RTCPeerConnection) return;
            const t = g(e);
            if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return I(e);
            const n = e.RTCPeerConnection.prototype.getLocalStreams;
            e.RTCPeerConnection.prototype.getLocalStreams = function() {
                const e = n.apply(this);
                return this._reverseStreams = this._reverseStreams || {}, e.map(e => this._reverseStreams[e.id])
            };
            const i = e.RTCPeerConnection.prototype.addStream;
            e.RTCPeerConnection.prototype.addStream = function(t) {
                if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach(e => {
                        if (this.getSenders().find(t => t.track === e)) throw new DOMException("Track already exists.", "InvalidAccessError")
                    }), !this._reverseStreams[t.id]) {
                    const n = new e.MediaStream(t.getTracks());
                    this._streams[t.id] = n, this._reverseStreams[n.id] = t, t = n
                }
                i.apply(this, [t])
            };
            const r = e.RTCPeerConnection.prototype.removeStream;

            function s(e, t) {
                let n = t.sdp;
                return Object.keys(e._reverseStreams || []).forEach(t => {
                    const i = e._reverseStreams[t],
                        r = e._streams[i.id];
                    n = n.replace(new RegExp(r.id, "g"), i.id)
                }), new RTCSessionDescription({
                    type: t.type,
                    sdp: n
                })
            }

            function o(e, t) {
                let n = t.sdp;
                return Object.keys(e._reverseStreams || []).forEach(t => {
                    const i = e._reverseStreams[t],
                        r = e._streams[i.id];
                    n = n.replace(new RegExp(i.id, "g"), r.id)
                }), new RTCSessionDescription({
                    type: t.type,
                    sdp: n
                })
            }
            e.RTCPeerConnection.prototype.removeStream = function(e) {
                this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id]
            }, e.RTCPeerConnection.prototype.addTrack = function(t, n) {
                if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                const i = [].slice.call(arguments, 1);
                if (1 !== i.length || !i[0].getTracks().find(e => e === t)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
                const r = this.getSenders().find(e => e.track === t);
                if (r) throw new DOMException("Track already exists.", "InvalidAccessError");
                this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
                const s = this._streams[n.id];
                if (s) s.addTrack(t), Promise.resolve().then(() => {
                    this.dispatchEvent(new Event("negotiationneeded"))
                });
                else {
                    const i = new e.MediaStream([t]);
                    this._streams[n.id] = i, this._reverseStreams[i.id] = n, this.addStream(i)
                }
                return this.getSenders().find(e => e.track === t)
            }, ["createOffer", "createAnswer"].forEach((function(t) {
                const n = e.RTCPeerConnection.prototype[t],
                    i = {
                        [t]() {
                            const e = arguments;
                            return arguments.length && "function" == typeof arguments[0] ? n.apply(this, [t => {
                                const n = s(this, t);
                                e[0].apply(null, [n])
                            }, t => {
                                e[1] && e[1].apply(null, t)
                            }, arguments[2]]) : n.apply(this, arguments).then(e => s(this, e))
                        }
                    };
                e.RTCPeerConnection.prototype[t] = i[t]
            }));
            const a = e.RTCPeerConnection.prototype.setLocalDescription;
            e.RTCPeerConnection.prototype.setLocalDescription = function() {
                return arguments.length && arguments[0].type ? (arguments[0] = o(this, arguments[0]), a.apply(this, arguments)) : a.apply(this, arguments)
            };
            const c = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription");
            Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", {
                get() {
                    const e = c.get.apply(this);
                    return "" === e.type ? e : s(this, e)
                }
            }), e.RTCPeerConnection.prototype.removeTrack = function(e) {
                if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
                if (!(e._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
                let t;
                this._streams = this._streams || {}, Object.keys(this._streams).forEach(n => {
                    this._streams[n].getTracks().find(t => e.track === t) && (t = this._streams[n])
                }), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded")))
            }
        }

        function D(e) {
            const t = g(e);
            if (!e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), !e.RTCPeerConnection) return;
            const n = 0 === e.RTCPeerConnection.prototype.addIceCandidate.length;
            t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                const n = e.RTCPeerConnection.prototype[t],
                    i = {
                        [t]() {
                            return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments)
                        }
                    };
                e.RTCPeerConnection.prototype[t] = i[t]
            }));
            const i = e.RTCPeerConnection.prototype.addIceCandidate;
            e.RTCPeerConnection.prototype.addIceCandidate = function() {
                return n || arguments[0] ? t.version < 78 && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : i.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
            }
        }

        function O(e) {
            l(e, "negotiationneeded", e => {
                if ("stable" === e.target.signalingState) return e
            })
        }
        var N = n(79),
            M = n.n(N);

        function L(e) {
            const t = e && e.navigator,
                n = t.mediaDevices.getUserMedia.bind(t.mediaDevices);
            t.mediaDevices.getUserMedia = function(e) {
                return n(e).catch(e => Promise.reject(function(e) {
                    return {
                        name: {
                            PermissionDeniedError: "NotAllowedError"
                        } [e.name] || e.name,
                        message: e.message,
                        constraint: e.constraint,
                        toString() {
                            return this.name
                        }
                    }
                }(e)))
            }
        }

        function k(e) {
            "getDisplayMedia" in e.navigator && e.navigator.mediaDevices && (e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || (e.navigator.mediaDevices.getDisplayMedia = e.navigator.getDisplayMedia.bind(e.navigator)))
        }

        function x(e) {
            const t = g(e);
            if (e.RTCIceGatherer && (e.RTCIceCandidate || (e.RTCIceCandidate = function(e) {
                    return e
                }), e.RTCSessionDescription || (e.RTCSessionDescription = function(e) {
                    return e
                }), t.version < 15025)) {
                const t = Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype, "enabled");
                Object.defineProperty(e.MediaStreamTrack.prototype, "enabled", {
                    set(e) {
                        t.set.call(this, e);
                        const n = new Event("enabled");
                        n.enabled = e, this.dispatchEvent(n)
                    }
                })
            }!e.RTCRtpSender || "dtmf" in e.RTCRtpSender.prototype || Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
                get() {
                    return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = new e.RTCDtmfSender(this) : "video" === this.track.kind && (this._dtmf = null)), this._dtmf
                }
            }), e.RTCDtmfSender && !e.RTCDTMFSender && (e.RTCDTMFSender = e.RTCDtmfSender);
            const n = M()(e, t.version);
            e.RTCPeerConnection = function(e) {
                return e && e.iceServers && (e.iceServers = function(e, t) {
                    let n = !1;
                    return (e = JSON.parse(JSON.stringify(e))).filter(e => {
                        if (e && (e.urls || e.url)) {
                            var t = e.urls || e.url;
                            e.url && !e.urls && m("RTCIceServer.url", "RTCIceServer.urls");
                            const i = "string" == typeof t;
                            return i && (t = [t]), t = t.filter(e => {
                                if (0 === e.indexOf("stun:")) return !1;
                                const t = e.startsWith("turn") && !e.startsWith("turn:[") && e.includes("transport=udp");
                                return t && !n ? (n = !0, !0) : t && !n
                            }), delete e.url, e.urls = i ? t[0] : t, !!t.length
                        }
                    })
                }(e.iceServers, t.version), f("ICE servers after filtering:", e.iceServers)), new n(e)
            }, e.RTCPeerConnection.prototype = n.prototype
        }

        function F(e) {
            !e.RTCRtpSender || "replaceTrack" in e.RTCRtpSender.prototype || (e.RTCRtpSender.prototype.replaceTrack = e.RTCRtpSender.prototype.setTrack)
        }

        function j(e) {
            const t = g(e),
                n = e && e.navigator,
                i = e && e.MediaStreamTrack;
            if (n.getUserMedia = function(e, t, i) {
                    m("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), n.mediaDevices.getUserMedia(e).then(t, i)
                }, !(t.version > 55 && "autoGainControl" in n.mediaDevices.getSupportedConstraints())) {
                const e = function(e, t, n) {
                        t in e && !(n in e) && (e[n] = e[t], delete e[t])
                    },
                    t = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
                if (n.mediaDevices.getUserMedia = function(n) {
                        return "object" == typeof n && "object" == typeof n.audio && (n = JSON.parse(JSON.stringify(n)), e(n.audio, "autoGainControl", "mozAutoGainControl"), e(n.audio, "noiseSuppression", "mozNoiseSuppression")), t(n)
                    }, i && i.prototype.getSettings) {
                    const t = i.prototype.getSettings;
                    i.prototype.getSettings = function() {
                        const n = t.apply(this, arguments);
                        return e(n, "mozAutoGainControl", "autoGainControl"), e(n, "mozNoiseSuppression", "noiseSuppression"), n
                    }
                }
                if (i && i.prototype.applyConstraints) {
                    const t = i.prototype.applyConstraints;
                    i.prototype.applyConstraints = function(n) {
                        return "audio" === this.kind && "object" == typeof n && (n = JSON.parse(JSON.stringify(n)), e(n, "autoGainControl", "mozAutoGainControl"), e(n, "noiseSuppression", "mozNoiseSuppression")), t.apply(this, [n])
                    }
                }
            }
        }

        function U(e, t) {
            e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function(n) {
                if (!n || !n.video) {
                    const e = new DOMException("getDisplayMedia without video constraints is undefined");
                    return e.name = "NotFoundError", e.code = 8, Promise.reject(e)
                }
                return !0 === n.video ? n.video = {
                    mediaSource: t
                } : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n)
            })
        }

        function H(e) {
            "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                get() {
                    return {
                        receiver: this.receiver
                    }
                }
            })
        }

        function J(e) {
            const t = g(e);
            if ("object" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return;
            if (!e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                    const n = e.RTCPeerConnection.prototype[t],
                        i = {
                            [t]() {
                                return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments)
                            }
                        };
                    e.RTCPeerConnection.prototype[t] = i[t]
                })), t.version < 68) {
                const t = e.RTCPeerConnection.prototype.addIceCandidate;
                e.RTCPeerConnection.prototype.addIceCandidate = function() {
                    return arguments[0] ? arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : t.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
                }
            }
            const n = {
                    inboundrtp: "inbound-rtp",
                    outboundrtp: "outbound-rtp",
                    candidatepair: "candidate-pair",
                    localcandidate: "local-candidate",
                    remotecandidate: "remote-candidate"
                },
                i = e.RTCPeerConnection.prototype.getStats;
            e.RTCPeerConnection.prototype.getStats = function() {
                const [e, r, s] = arguments;
                return i.apply(this, [e || null]).then(e => {
                    if (t.version < 53 && !r) try {
                        e.forEach(e => {
                            e.type = n[e.type] || e.type
                        })
                    } catch (t) {
                        if ("TypeError" !== t.name) throw t;
                        e.forEach((t, i) => {
                            e.set(i, Object.assign({}, t, {
                                type: n[t.type] || t.type
                            }))
                        })
                    }
                    return e
                }).then(r, s)
            }
        }

        function B(e) {
            if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
            if (e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return;
            const t = e.RTCPeerConnection.prototype.getSenders;
            t && (e.RTCPeerConnection.prototype.getSenders = function() {
                const e = t.apply(this, []);
                return e.forEach(e => e._pc = this), e
            });
            const n = e.RTCPeerConnection.prototype.addTrack;
            n && (e.RTCPeerConnection.prototype.addTrack = function() {
                const e = n.apply(this, arguments);
                return e._pc = this, e
            }), e.RTCRtpSender.prototype.getStats = function() {
                return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map)
            }
        }

        function G(e) {
            if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
            if (e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return;
            const t = e.RTCPeerConnection.prototype.getReceivers;
            t && (e.RTCPeerConnection.prototype.getReceivers = function() {
                const e = t.apply(this, []);
                return e.forEach(e => e._pc = this), e
            }), l(e, "track", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function() {
                return this._pc.getStats(this.track)
            }
        }

        function $(e) {
            !e.RTCPeerConnection || "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(e) {
                m("removeStream", "removeTrack"), this.getSenders().forEach(t => {
                    t.track && e.getTracks().includes(t.track) && this.removeTrack(t)
                })
            })
        }

        function V(e) {
            e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel)
        }

        function q(e) {
            if ("object" != typeof e || !e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype.addTransceiver;
            t && (e.RTCPeerConnection.prototype.addTransceiver = function() {
                this.setParametersPromises = [];
                const e = arguments[1],
                    n = e && "sendEncodings" in e;
                n && e.sendEncodings.forEach(e => {
                    if ("rid" in e) {
                        if (!/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError("Invalid RID value provided.")
                    }
                    if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
                    if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0")
                });
                const i = t.apply(this, arguments);
                if (n) {
                    const {
                        sender: t
                    } = i, n = t.getParameters();
                    "encodings" in n || (n.encodings = e.sendEncodings, this.setParametersPromises.push(t.setParameters(n).catch(() => {})))
                }
                return i
            })
        }

        function K(e) {
            if ("object" != typeof e || !e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype.createOffer;
            e.RTCPeerConnection.prototype.createOffer = function() {
                return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
                    this.setParametersPromises = []
                }) : t.apply(this, arguments)
            }
        }

        function W(e) {
            if ("object" != typeof e || !e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype.createAnswer;
            e.RTCPeerConnection.prototype.createAnswer = function() {
                return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
                    this.setParametersPromises = []
                }) : t.apply(this, arguments)
            }
        }

        function z(e) {
            if ("object" == typeof e && e.RTCPeerConnection) {
                if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function() {
                        return this._localStreams || (this._localStreams = []), this._localStreams
                    }), !("addStream" in e.RTCPeerConnection.prototype)) {
                    const t = e.RTCPeerConnection.prototype.addTrack;
                    e.RTCPeerConnection.prototype.addStream = function(e) {
                        this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach(n => t.call(this, n, e)), e.getVideoTracks().forEach(n => t.call(this, n, e))
                    }, e.RTCPeerConnection.prototype.addTrack = function(e) {
                        const n = arguments[1];
                        return n && (this._localStreams ? this._localStreams.includes(n) || this._localStreams.push(n) : this._localStreams = [n]), t.apply(this, arguments)
                    }
                }
                "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(e) {
                    this._localStreams || (this._localStreams = []);
                    const t = this._localStreams.indexOf(e);
                    if (-1 === t) return;
                    this._localStreams.splice(t, 1);
                    const n = e.getTracks();
                    this.getSenders().forEach(e => {
                        n.includes(e.track) && this.removeTrack(e)
                    })
                })
            }
        }

        function X(e) {
            if ("object" == typeof e && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function() {
                    return this._remoteStreams ? this._remoteStreams : []
                }), !("onaddstream" in e.RTCPeerConnection.prototype))) {
                Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", {
                    get() {
                        return this._onaddstream
                    },
                    set(e) {
                        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = e => {
                            e.streams.forEach(e => {
                                if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e)) return;
                                this._remoteStreams.push(e);
                                const t = new Event("addstream");
                                t.stream = e, this.dispatchEvent(t)
                            })
                        })
                    }
                });
                const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                    const e = this;
                    return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t) {
                        t.streams.forEach(t => {
                            if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return;
                            e._remoteStreams.push(t);
                            const n = new Event("addstream");
                            n.stream = t, e.dispatchEvent(n)
                        })
                    }), t.apply(e, arguments)
                }
            }
        }

        function Q(e) {
            if ("object" != typeof e || !e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype,
                n = t.createOffer,
                i = t.createAnswer,
                r = t.setLocalDescription,
                s = t.setRemoteDescription,
                o = t.addIceCandidate;
            t.createOffer = function(e, t) {
                const i = arguments.length >= 2 ? arguments[2] : arguments[0],
                    r = n.apply(this, [i]);
                return t ? (r.then(e, t), Promise.resolve()) : r
            }, t.createAnswer = function(e, t) {
                const n = arguments.length >= 2 ? arguments[2] : arguments[0],
                    r = i.apply(this, [n]);
                return t ? (r.then(e, t), Promise.resolve()) : r
            };
            let a = function(e, t, n) {
                const i = r.apply(this, [e]);
                return n ? (i.then(t, n), Promise.resolve()) : i
            };
            t.setLocalDescription = a, a = function(e, t, n) {
                const i = s.apply(this, [e]);
                return n ? (i.then(t, n), Promise.resolve()) : i
            }, t.setRemoteDescription = a, a = function(e, t, n) {
                const i = o.apply(this, [e]);
                return n ? (i.then(t, n), Promise.resolve()) : i
            }, t.addIceCandidate = a
        }

        function Y(e) {
            const t = e && e.navigator;
            if (t.mediaDevices && t.mediaDevices.getUserMedia) {
                const e = t.mediaDevices,
                    n = e.getUserMedia.bind(e);
                t.mediaDevices.getUserMedia = e => n(Z(e))
            }!t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function(e, n, i) {
                t.mediaDevices.getUserMedia(e).then(n, i)
            }.bind(t))
        }

        function Z(e) {
            return e && void 0 !== e.video ? Object.assign({}, e, {
                video: v(e.video)
            }) : e
        }

        function ee(e) {
            const t = e.RTCPeerConnection;
            e.RTCPeerConnection = function(e, n) {
                if (e && e.iceServers) {
                    const t = [];
                    for (let n = 0; n < e.iceServers.length; n++) {
                        let i = e.iceServers[n];
                        !i.hasOwnProperty("urls") && i.hasOwnProperty("url") ? (m("RTCIceServer.url", "RTCIceServer.urls"), (i = JSON.parse(JSON.stringify(i))).urls = i.url, delete i.url, t.push(i)) : t.push(e.iceServers[n])
                    }
                    e.iceServers = t
                }
                return new t(e, n)
            }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in e.RTCPeerConnection && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
                get: () => t.generateCertificate
            })
        }

        function te(e) {
            "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                get() {
                    return {
                        receiver: this.receiver
                    }
                }
            })
        }

        function ne(e) {
            const t = e.RTCPeerConnection.prototype.createOffer;
            e.RTCPeerConnection.prototype.createOffer = function(e) {
                if (e) {
                    void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio);
                    const t = this.getTransceivers().find(e => "audio" === e.receiver.track.kind);
                    !1 === e.offerToReceiveAudio && t ? "sendrecv" === t.direction ? t.setDirection ? t.setDirection("sendonly") : t.direction = "sendonly" : "recvonly" === t.direction && (t.setDirection ? t.setDirection("inactive") : t.direction = "inactive") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver("audio"), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo);
                    const n = this.getTransceivers().find(e => "video" === e.receiver.track.kind);
                    !1 === e.offerToReceiveVideo && n ? "sendrecv" === n.direction ? n.setDirection ? n.setDirection("sendonly") : n.direction = "sendonly" : "recvonly" === n.direction && (n.setDirection ? n.setDirection("inactive") : n.direction = "inactive") : !0 !== e.offerToReceiveVideo || n || this.addTransceiver("video")
                }
                return t.apply(this, arguments)
            }
        }
        var ie = n(45),
            re = n.n(ie);

        function se(e) {
            if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return;
            const t = e.RTCIceCandidate;
            e.RTCIceCandidate = function(e) {
                if ("object" == typeof e && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) {
                    const n = new t(e),
                        i = re.a.parseCandidate(e.candidate),
                        r = Object.assign(n, i);
                    return r.toJSON = function() {
                        return {
                            candidate: r.candidate,
                            sdpMid: r.sdpMid,
                            sdpMLineIndex: r.sdpMLineIndex,
                            usernameFragment: r.usernameFragment
                        }
                    }, r
                }
                return new t(e)
            }, e.RTCIceCandidate.prototype = t.prototype, l(e, "icecandidate", t => (t.candidate && Object.defineProperty(t, "candidate", {
                value: new e.RTCIceCandidate(t.candidate),
                writable: "false"
            }), t))
        }

        function oe(e) {
            if (!e.RTCPeerConnection) return;
            const t = g(e);
            "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", {
                get() {
                    return void 0 === this._sctp ? null : this._sctp
                }
            });
            const n = function(e) {
                    if (!e || !e.sdp) return !1;
                    const t = re.a.splitSections(e.sdp);
                    return t.shift(), t.some(e => {
                        const t = re.a.parseMLine(e);
                        return t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP")
                    })
                },
                i = function(e) {
                    const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
                    if (null === t || t.length < 2) return -1;
                    const n = parseInt(t[1], 10);
                    return n != n ? -1 : n
                },
                r = function(e) {
                    let n = 65536;
                    return "firefox" === t.browser && (n = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), n
                },
                s = function(e, n) {
                    let i = 65536;
                    "firefox" === t.browser && 57 === t.version && (i = 65535);
                    const r = re.a.matchPrefix(e.sdp, "a=max-message-size:");
                    return r.length > 0 ? i = parseInt(r[0].substr(19), 10) : "firefox" === t.browser && -1 !== n && (i = 2147483637), i
                },
                o = e.RTCPeerConnection.prototype.setRemoteDescription;
            e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                if (this._sctp = null, "chrome" === t.browser && t.version >= 76) {
                    const {
                        sdpSemantics: e
                    } = this.getConfiguration();
                    "plan-b" === e && Object.defineProperty(this, "sctp", {
                        get() {
                            return void 0 === this._sctp ? null : this._sctp
                        },
                        enumerable: !0,
                        configurable: !0
                    })
                }
                if (n(arguments[0])) {
                    const e = i(arguments[0]),
                        t = r(e),
                        n = s(arguments[0], e);
                    let o;
                    o = 0 === t && 0 === n ? Number.POSITIVE_INFINITY : 0 === t || 0 === n ? Math.max(t, n) : Math.min(t, n);
                    const a = {};
                    Object.defineProperty(a, "maxMessageSize", {
                        get: () => o
                    }), this._sctp = a
                }
                return o.apply(this, arguments)
            }
        }

        function ae(e) {
            if (!(e.RTCPeerConnection && "createDataChannel" in e.RTCPeerConnection.prototype)) return;

            function t(e, t) {
                const n = e.send;
                e.send = function() {
                    const i = arguments[0],
                        r = i.length || i.size || i.byteLength;
                    if ("open" === e.readyState && t.sctp && r > t.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)");
                    return n.apply(e, arguments)
                }
            }
            const n = e.RTCPeerConnection.prototype.createDataChannel;
            e.RTCPeerConnection.prototype.createDataChannel = function() {
                const e = n.apply(this, arguments);
                return t(e, this), e
            }, l(e, "datachannel", e => (t(e.channel, e.target), e))
        }

        function ce(e) {
            if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return;
            const t = e.RTCPeerConnection.prototype;
            Object.defineProperty(t, "connectionState", {
                get() {
                    return {
                        completed: "connected",
                        checking: "connecting"
                    } [this.iceConnectionState] || this.iceConnectionState
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t, "onconnectionstatechange", {
                get() {
                    return this._onconnectionstatechange || null
                },
                set(e) {
                    this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e)
                },
                enumerable: !0,
                configurable: !0
            }), ["setLocalDescription", "setRemoteDescription"].forEach(e => {
                const n = t[e];
                t[e] = function() {
                    return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => {
                        const t = e.target;
                        if (t._lastConnectionState !== t.connectionState) {
                            t._lastConnectionState = t.connectionState;
                            const n = new Event("connectionstatechange", e);
                            t.dispatchEvent(n)
                        }
                        return e
                    }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments)
                }
            })
        }

        function de(e) {
            if (!e.RTCPeerConnection) return;
            const t = g(e);
            if ("chrome" === t.browser && t.version >= 71) return;
            const n = e.RTCPeerConnection.prototype.setRemoteDescription;
            e.RTCPeerConnection.prototype.setRemoteDescription = function(e) {
                return e && e.sdp && -1 !== e.sdp.indexOf("\na=extmap-allow-mixed") && (e.sdp = e.sdp.split("\n").filter(e => "a=extmap-allow-mixed" !== e.trim()).join("\n")), n.apply(this, arguments)
            }
        }
        const ue = function({
            window: e
        } = {}, t = {
            shimChrome: !0,
            shimFirefox: !0,
            shimEdge: !0,
            shimSafari: !0
        }) {
            const n = f,
                c = g(e),
                d = {
                    browserDetails: c,
                    commonShim: a,
                    extractVersion: u,
                    disableLog: h,
                    disableWarnings: p
                };
            switch (c.browser) {
                case "chrome":
                    if (!i || !D || !t.shimChrome) return n("Chrome shim is not included in this adapter release."), d;
                    n("adapter.js shimming chrome."), d.browserShim = i, E(e), b(e), D(e), C(e), P(e), R(e), A(e), w(e), O(e), se(e), ce(e), oe(e), ae(e), de(e);
                    break;
                case "firefox":
                    if (!s || !J || !t.shimFirefox) return n("Firefox shim is not included in this adapter release."), d;
                    n("adapter.js shimming firefox."), d.browserShim = s, j(e), J(e), H(e), $(e), B(e), G(e), V(e), q(e), K(e), W(e), se(e), ce(e), oe(e), ae(e);
                    break;
                case "edge":
                    if (!r || !x || !t.shimEdge) return n("MS edge shim is not included in this adapter release."), d;
                    n("adapter.js shimming edge."), d.browserShim = r, L(e), k(e), x(e), F(e), oe(e), ae(e);
                    break;
                case "safari":
                    if (!o || !t.shimSafari) return n("Safari shim is not included in this adapter release."), d;
                    n("adapter.js shimming safari."), d.browserShim = o, ee(e), ne(e), Q(e), z(e), X(e), te(e), Y(e), se(e), oe(e), ae(e), de(e);
                    break;
                default:
                    n("Unsupported browser!")
            }
            return d
        }({
            window: window
        });
        t.default = ue
    }])
}));
