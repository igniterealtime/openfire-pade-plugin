/*! For license information please see lib-jitsi-meet.min.js.LICENSE.txt */ ! function(e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.JitsiMeetJS = t() : e.JitsiMeetJS = t()
}(self, (function() {
    return (() => {
        var __webpack_modules__ = {
                4449: (e, t, i) => {
                    e.exports = i(79).default
                },
                2444: e => {
                    e.exports = class {
                        constructor(e, t, i) {
                            this._userId = e, this.setDisplayName(t), this._isLocalStats = i || !1, this.setDominantSpeaker(!1), this.totalDominantSpeakerTime = 0, this._dominantSpeakerStart = 0, this._hasLeft = !1, this._faceExpressions = {
                                happy: 0,
                                neutral: 0,
                                surprised: 0,
                                angry: 0,
                                fearful: 0,
                                disgusted: 0,
                                sad: 0
                            }
                        }
                        getUserId() {
                            return this._userId
                        }
                        getDisplayName() {
                            return this.displayName
                        }
                        setDisplayName(e) {
                            this.displayName = e
                        }
                        isLocalStats() {
                            return this._isLocalStats
                        }
                        isDominantSpeaker() {
                            return this._dominantSpeakerStart > 0
                        }
                        setDominantSpeaker(e) {
                            if (!this.isDominantSpeaker() && e) this._dominantSpeakerStart = Date.now();
                            else if (this.isDominantSpeaker() && !e) {
                                const e = Date.now() - this._dominantSpeakerStart;
                                this.totalDominantSpeakerTime += e, this._dominantSpeakerStart = 0
                            }
                        }
                        getTotalDominantSpeakerTime() {
                            let e = this.totalDominantSpeakerTime;
                            return this.isDominantSpeaker() && (e += Date.now() - this._dominantSpeakerStart), e
                        }
                        hasLeft() {
                            return this._hasLeft
                        }
                        markAsHasLeft() {
                            this._hasLeft = !0, this.setDominantSpeaker(!1)
                        }
                        getFaceExpressions() {
                            return this._faceExpressions
                        }
                        setFaceExpressions(e) {
                            this._faceExpressions = e
                        }
                        addFaceExpression(e, t) {
                            this._faceExpressions[e] += t
                        }
                    }
                },
                4424: e => {
                    e.exports = {
                        getTokenAuthUrl: (e, t, i) => "string" != typeof e ? null : e.replace("{room}", t).replace("{roleUpgrade}", !0 === i)
                    }
                },
                4832: e => {
                    function t(e, t) {
                        if (!e || !t || "function" != typeof e.addListener || "function" != typeof t.emit) throw new Error("Invalid arguments passed to EventEmitterForwarder");
                        this.src = e, this.dest = t
                    }
                    t.prototype.forward = function() {
                        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                        const n = t[0];
                        t[0] = this.dest, this.src.addListener(n, Function.prototype.bind.apply(this.dest.emit, t))
                    }, e.exports = t
                },
                1023: e => {
                    const t = [],
                        i = window.onerror,
                        n = window.onunhandledrejection;
                    window.onerror = function() {
                        for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++) n[s] = arguments[s];
                        t.forEach((e => e(...n))), i && i(...n)
                    }, window.onunhandledrejection = function(e) {
                        t.forEach((t => t(null, null, null, null, e.reason))), n && n(e)
                    };
                    const s = {
                        addHandler(e) {
                            t.push(e)
                        },
                        callErrorHandler(e) {
                            const t = window.onerror;
                            t && t(null, null, null, null, e)
                        },
                        callUnhandledRejectionHandler(e) {
                            const t = window.onunhandledrejection;
                            t && t(e)
                        }
                    };
                    e.exports = s
                },
                5399: e => {
                    function t(e, t) {
                        return Math.floor(Math.random() * (t - e + 1)) + e
                    }

                    function i(e) {
                        return e[t(0, e.length - 1)]
                    }
                    const n = {
                        randomHexDigit: () => i("0123456789abcdef"),
                        randomHexString(e) {
                            let t = "";
                            for (; e--;) t += this.randomHexDigit();
                            return t
                        },
                        randomElement: i,
                        randomAlphanumStr: function(e) {
                            let t = "";
                            for (let n = 0; n < e; n += 1) t += i("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
                            return t
                        },
                        randomInt: t
                    };
                    e.exports = n
                },
                549: (e, t, i) => {
                    const n = i(6799),
                        s = {
                            loadScript(e, t, i, s, r, o) {
                                const a = document,
                                    c = "script",
                                    d = a.createElement(c),
                                    l = a.getElementsByTagName(c)[0];
                                if (d.async = t, s) {
                                    const t = n();
                                    if (t) {
                                        const i = t.src,
                                            n = i.substring(0, i.lastIndexOf("/") + 1);
                                        i && n && (e = n + e)
                                    }
                                }
                                r && (d.onload = r), o && (d.onerror = o), d.src = e, i ? l.parentNode.insertBefore(d, l) : l.parentNode.appendChild(d)
                            }
                        };
                    e.exports = s
                },
                2593: e => {
                    e.exports = {
                        integerHash: function(e) {
                            if (!e) return 0;
                            let t, i, n = 0;
                            for (i = 0; i < e.length; i++) t = e.charCodeAt(i), n += t * Math.pow(31, e.length - 1 - i), n = Math.abs(0 | n);
                            return n
                        }
                    }
                },
                6667: (e, t, i) => {
                    const n = i(5399),
                        s = ["Aaliyah", "Aaron", "Abagail", "Abbey", "Abbie", "Abbigail", "Abby", "Abdiel", "Abdul", "Abdullah", "Abe", "Abel", "Abelardo", "Abigail", "Abigale", "Abigayle", "Abner", "Abraham", "Ada", "Adah", "Adalberto", "Adaline", "Adam", "Adan", "Addie", "Addison", "Adela", "Adelbert", "Adele", "Adelia", "Adeline", "Adell", "Adella", "Adelle", "Aditya", "Adolf", "Adolfo", "Adolph", "Adolphus", "Adonis", "Adrain", "Adrian", "Adriana", "Adrianna", "Adriel", "Adrien", "Adrienne", "Afton", "Aglae", "Agnes", "Agustin", "Agustina", "Ahmad", "Ahmed", "Aida", "Aidan", "Aiden", "Aileen", "Aisha", "Aiyana", "Akeem", "Al", "Alaina", "Alan", "Alana", "Alanis", "Alanna", "Alayna", "Alba", "Albert", "Alberta", "Albertha", "Alberto", "Albin", "Albina", "Alda", "Alden", "Alec", "Aleen", "Alejandra", "Alejandrin", "Alek", "Alena", "Alene", "Alessandra", "Alessandro", "Alessia", "Aletha", "Alex", "Alexa", "Alexander", "Alexandra", "Alexandre", "Alexandrea", "Alexandria", "Alexandrine", "Alexandro", "Alexane", "Alexanne", "Alexie", "Alexis", "Alexys", "Alexzander", "Alf", "Alfonso", "Alfonzo", "Alford", "Alfred", "Alfreda", "Alfredo", "Ali", "Alia", "Alice", "Alicia", "Alisa", "Alisha", "Alison", "Alivia", "Aliya", "Aliyah", "Aliza", "Alize", "Allan", "Allen", "Allene", "Allie", "Allison", "Ally", "Alphonso", "Alta", "Althea", "Alva", "Alvah", "Alvena", "Alvera", "Alverta", "Alvina", "Alvis", "Alyce", "Alycia", "Alysa", "Alysha", "Alyson", "Alysson", "Amalia", "Amanda", "Amani", "Amara", "Amari", "Amaya", "Amber", "Ambrose", "Amelia", "Amelie", "Amely", "America", "Americo", "Amie", "Amina", "Amir", "Amira", "Amiya", "Amos", "Amparo", "Amy", "Amya", "Ana", "Anabel", "Anabelle", "Anahi", "Anais", "Anastacio", "Anastasia", "Anderson", "Andre", "Andreane", "Andreanne", "Andres", "Andrew", "Andy", "Angel", "Angela", "Angelica", "Angelina", "Angeline", "Angelita", "Angelo", "Angie", "Angus", "Anibal", "Anika", "Anissa", "Anita", "Aniya", "Aniyah", "Anjali", "Anna", "Annabel", "Annabell", "Annabelle", "Annalise", "Annamae", "Annamarie", "Anne", "Annetta", "Annette", "Annie", "Ansel", "Ansley", "Anthony", "Antoinette", "Antone", "Antonetta", "Antonette", "Antonia", "Antonietta", "Antonina", "Antonio", "Antwan", "Antwon", "Anya", "April", "Ara", "Araceli", "Aracely", "Arch", "Archibald", "Ardella", "Arden", "Ardith", "Arely", "Ari", "Ariane", "Arianna", "Aric", "Ariel", "Arielle", "Arjun", "Arlene", "Arlie", "Arlo", "Armand", "Armando", "Armani", "Arnaldo", "Arne", "Arno", "Arnold", "Arnoldo", "Arnulfo", "Aron", "Art", "Arthur", "Arturo", "Arvel", "Arvid", "Arvilla", "Aryanna", "Asa", "Asha", "Ashlee", "Ashleigh", "Ashley", "Ashly", "Ashlynn", "Ashton", "Ashtyn", "Asia", "Assunta", "Astrid", "Athena", "Aubree", "Aubrey", "Audie", "Audra", "Audreanne", "Audrey", "August", "Augusta", "Augustine", "Augustus", "Aurelia", "Aurelie", "Aurelio", "Aurore", "Austen", "Austin", "Austyn", "Autumn", "Ava", "Avery", "Avis", "Axel", "Ayana", "Ayden", "Ayla", "Aylin", "Baby", "Bailee", "Bailey", "Barbara", "Barney", "Baron", "Barrett", "Barry", "Bart", "Bartholome", "Barton", "Baylee", "Beatrice", "Beau", "Beaulah", "Bell", "Bella", "Belle", "Ben", "Benedict", "Benjamin", "Bennett", "Bennie", "Benny", "Benton", "Berenice", "Bernadette", "Bernadine", "Bernard", "Bernardo", "Berneice", "Bernhard", "Bernice", "Bernie", "Berniece", "Bernita", "Berry", "Bert", "Berta", "Bertha", "Bertram", "Bertrand", "Beryl", "Bessie", "Beth", "Bethany", "Bethel", "Betsy", "Bette", "Bettie", "Betty", "Bettye", "Beulah", "Beverly", "Bianka", "Bill", "Billie", "Billy", "Birdie", "Blair", "Blaise", "Blake", "Blanca", "Blanche", "Blaze", "Bo", "Bobbie", "Bobby", "Bonita", "Bonnie", "Boris", "Boyd", "Brad", "Braden", "Bradford", "Bradley", "Bradly", "Brady", "Braeden", "Brain", "Brandi", "Brando", "Brandon", "Brandt", "Brandy", "Brandyn", "Brannon", "Branson", "Brant", "Braulio", "Braxton", "Brayan", "Breana", "Breanna", "Breanne", "Brenda", "Brendan", "Brenden", "Brendon", "Brenna", "Brennan", "Brennon", "Brent", "Bret", "Brett", "Bria", "Brian", "Briana", "Brianne", "Brice", "Bridget", "Bridgette", "Bridie", "Brielle", "Brigitte", "Brionna", "Brisa", "Britney", "Brittany", "Brock", "Broderick", "Brody", "Brook", "Brooke", "Brooklyn", "Brooks", "Brown", "Bruce", "Bryana", "Bryce", "Brycen", "Bryon", "Buck", "Bud", "Buddy", "Buford", "Bulah", "Burdette", "Burley", "Burnice", "Buster", "Cade", "Caden", "Caesar", "Caitlyn", "Cale", "Caleb", "Caleigh", "Cali", "Calista", "Callie", "Camden", "Cameron", "Camila", "Camilla", "Camille", "Camren", "Camron", "Camryn", "Camylle", "Candace", "Candelario", "Candice", "Candida", "Candido", "Cara", "Carey", "Carissa", "Carlee", "Carleton", "Carley", "Carli", "Carlie", "Carlo", "Carlos", "Carlotta", "Carmel", "Carmela", "Carmella", "Carmelo", "Carmen", "Carmine", "Carol", "Carolanne", "Carole", "Carolina", "Caroline", "Carolyn", "Carolyne", "Carrie", "Carroll", "Carson", "Carter", "Cary", "Casandra", "Casey", "Casimer", "Casimir", "Casper", "Cassandra", "Cassandre", "Cassidy", "Cassie", "Catalina", "Caterina", "Catharine", "Catherine", "Cathrine", "Cathryn", "Cathy", "Cayla", "Ceasar", "Cecelia", "Cecil", "Cecile", "Cecilia", "Cedrick", "Celestine", "Celestino", "Celia", "Celine", "Cesar", "Chad", "Chadd", "Chadrick", "Chaim", "Chance", "Chandler", "Chanel", "Chanelle", "Charity", "Charlene", "Charles", "Charley", "Charlie", "Charlotte", "Chase", "Chasity", "Chauncey", "Chaya", "Chaz", "Chelsea", "Chelsey", "Chelsie", "Chesley", "Chester", "Chet", "Cheyanne", "Cheyenne", "Chloe", "Chris", "Christ", "Christa", "Christelle", "Christian", "Christiana", "Christina", "Christine", "Christop", "Christophe", "Christopher", "Christy", "Chyna", "Ciara", "Cicero", "Cielo", "Cierra", "Cindy", "Citlalli", "Clair", "Claire", "Clara", "Clarabelle", "Clare", "Clarissa", "Clark", "Claud", "Claude", "Claudia", "Claudie", "Claudine", "Clay", "Clemens", "Clement", "Clementina", "Clementine", "Clemmie", "Cleo", "Cleora", "Cleta", "Cletus", "Cleve", "Cleveland", "Clifford", "Clifton", "Clint", "Clinton", "Clotilde", "Clovis", "Cloyd", "Clyde", "Coby", "Cody", "Colby", "Cole", "Coleman", "Colin", "Colleen", "Collin", "Colt", "Colten", "Colton", "Columbus", "Concepcion", "Conner", "Connie", "Connor", "Conor", "Conrad", "Constance", "Constantin", "Consuelo", "Cooper", "Cora", "Coralie", "Corbin", "Cordelia", "Cordell", "Cordia", "Cordie", "Corene", "Corine", "Cornelius", "Cornell", "Corrine", "Cortez", "Cortney", "Cory", "Coty", "Courtney", "Coy", "Craig", "Crawford", "Creola", "Cristal", "Cristian", "Cristina", "Cristobal", "Cristopher", "Cruz", "Crystal", "Crystel", "Cullen", "Curt", "Curtis", "Cydney", "Cynthia", "Cyril", "Cyrus", "Dagmar", "Dahlia", "Daija", "Daisha", "Daisy", "Dakota", "Dale", "Dallas", "Dallin", "Dalton", "Damaris", "Dameon", "Damian", "Damien", "Damion", "Damon", "Dan", "Dana", "Dandre", "Dane", "D'angelo", "Dangelo", "Danial", "Daniela", "Daniella", "Danielle", "Danika", "Dannie", "Danny", "Dante", "Danyka", "Daphne", "Daphnee", "Daphney", "Darby", "Daren", "Darian", "Dariana", "Darien", "Dario", "Darion", "Darius", "Darlene", "Daron", "Darrel", "Darrell", "Darren", "Darrick", "Darrin", "Darrion", "Darron", "Darryl", "Darwin", "Daryl", "Dashawn", "Dasia", "Dave", "David", "Davin", "Davion", "Davon", "Davonte", "Dawn", "Dawson", "Dax", "Dayana", "Dayna", "Dayne", "Dayton", "Dean", "Deangelo", "Deanna", "Deborah", "Declan", "Dedric", "Dedrick", "Dee", "Deion", "Deja", "Dejah", "Dejon", "Dejuan", "Delaney", "Delbert", "Delfina", "Delia", "Delilah", "Dell", "Della", "Delmer", "Delores", "Delpha", "Delphia", "Delphine", "Delta", "Demarco", "Demarcus", "Demario", "Demetris", "Demetrius", "Demond", "Dena", "Denis", "Dennis", "Deon", "Deondre", "Deontae", "Deonte", "Dereck", "Derek", "Derick", "Deron", "Derrick", "Deshaun", "Deshawn", "Desiree", "Desmond", "Dessie", "Destany", "Destin", "Destinee", "Destiney", "Destini", "Destiny", "Devan", "Devante", "Deven", "Devin", "Devon", "Devonte", "Devyn", "Dewayne", "Dewitt", "Dexter", "Diamond", "Diana", "Dianna", "Diego", "Dillan", "Dillon", "Dimitri", "Dina", "Dino", "Dion", "Dixie", "Dock", "Dolly", "Dolores", "Domenic", "Domenica", "Domenick", "Domenico", "Domingo", "Dominic", "Dominique", "Don", "Donald", "Donato", "Donavon", "Donna", "Donnell", "Donnie", "Donny", "Dora", "Dorcas", "Dorian", "Doris", "Dorothea", "Dorothy", "Dorris", "Dortha", "Dorthy", "Doug", "Douglas", "Dovie", "Doyle", "Drake", "Drew", "Duane", "Dudley", "Dulce", "Duncan", "Durward", "Dustin", "Dusty", "Dwight", "Dylan", "Earl", "Earlene", "Earline", "Earnest", "Earnestine", "Easter", "Easton", "Ebba", "Ebony", "Ed", "Eda", "Edd", "Eddie", "Eden", "Edgar", "Edgardo", "Edison", "Edmond", "Edmund", "Edna", "Eduardo", "Edward", "Edwardo", "Edwin", "Edwina", "Edyth", "Edythe", "Effie", "Efrain", "Efren", "Eileen", "Einar", "Eino", "Eladio", "Elaina", "Elbert", "Elda", "Eldon", "Eldora", "Eldred", "Eldridge", "Eleanora", "Eleanore", "Eleazar", "Electa", "Elena", "Elenor", "Elenora", "Eleonore", "Elfrieda", "Eli", "Elian", "Eliane", "Elias", "Eliezer", "Elijah", "Elinor", "Elinore", "Elisa", "Elisabeth", "Elise", "Eliseo", "Elisha", "Elissa", "Eliza", "Elizabeth", "Ella", "Ellen", "Ellie", "Elliot", "Elliott", "Ellis", "Ellsworth", "Elmer", "Elmira", "Elmo", "Elmore", "Elna", "Elnora", "Elody", "Eloisa", "Eloise", "Elouise", "Eloy", "Elroy", "Elsa", "Else", "Elsie", "Elta", "Elton", "Elva", "Elvera", "Elvie", "Elvis", "Elwin", "Elwyn", "Elyse", "Elyssa", "Elza", "Emanuel", "Emelia", "Emelie", "Emely", "Emerald", "Emerson", "Emery", "Emie", "Emil", "Emile", "Emilia", "Emiliano", "Emilie", "Emilio", "Emily", "Emma", "Emmalee", "Emmanuel", "Emmanuelle", "Emmet", "Emmett", "Emmie", "Emmitt", "Emmy", "Emory", "Ena", "Enid", "Enoch", "Enola", "Enos", "Enrico", "Enrique", "Ephraim", "Era", "Eriberto", "Eric", "Erica", "Erich", "Erick", "Ericka", "Erik", "Erika", "Erin", "Erling", "Erna", "Ernest", "Ernestina", "Ernestine", "Ernesto", "Ernie", "Ervin", "Erwin", "Eryn", "Esmeralda", "Esperanza", "Esta", "Esteban", "Estefania", "Estel", "Estell", "Estella", "Estelle", "Estevan", "Esther", "Estrella", "Etha", "Ethan", "Ethel", "Ethelyn", "Ethyl", "Ettie", "Eudora", "Eugene", "Eugenia", "Eula", "Eulah", "Eulalia", "Euna", "Eunice", "Eusebio", "Eva", "Evalyn", "Evan", "Evangeline", "Evans", "Eve", "Eveline", "Evelyn", "Everardo", "Everett", "Everette", "Evert", "Evie", "Ewald", "Ewell", "Ezekiel", "Ezequiel", "Ezra", "Fabian", "Fabiola", "Fae", "Fannie", "Fanny", "Fatima", "Faustino", "Fausto", "Favian", "Fay", "Faye", "Federico", "Felicia", "Felicita", "Felicity", "Felipa", "Felipe", "Felix", "Felton", "Fermin", "Fern", "Fernando", "Ferne", "Fidel", "Filiberto", "Filomena", "Finn", "Fiona", "Flavie", "Flavio", "Fleta", "Fletcher", "Flo", "Florence", "Florencio", "Florian", "Florida", "Florine", "Flossie", "Floy", "Floyd", "Ford", "Forest", "Forrest", "Foster", "Frances", "Francesca", "Francesco", "Francis", "Francisca", "Francisco", "Franco", "Frank", "Frankie", "Franz", "Fred", "Freda", "Freddie", "Freddy", "Frederic", "Frederick", "Frederik", "Frederique", "Fredrick", "Fredy", "Freeda", "Freeman", "Freida", "Frida", "Frieda", "Friedrich", "Fritz", "Furman", "Gabe", "Gabriel", "Gabriella", "Gabrielle", "Gaetano", "Gage", "Gail", "Gardner", "Garett", "Garfield", "Garland", "Garnet", "Garnett", "Garret", "Garrett", "Garrick", "Garrison", "Garry", "Garth", "Gaston", "Gavin", "Gay", "Gayle", "Gaylord", "Gene", "General", "Genesis", "Genevieve", "Gennaro", "Genoveva", "Geo", "Geoffrey", "George", "Georgette", "Georgiana", "Georgianna", "Geovanni", "Geovanny", "Geovany", "Gerald", "Geraldine", "Gerard", "Gerardo", "Gerda", "Gerhard", "Germaine", "German", "Gerry", "Gerson", "Gertrude", "Gia", "Gianni", "Gideon", "Gilbert", "Gilberto", "Gilda", "Giles", "Gillian", "Gina", "Gino", "Giovani", "Giovanna", "Giovanni", "Giovanny", "Gisselle", "Giuseppe", "Gladyce", "Gladys", "Glen", "Glenda", "Glenna", "Glennie", "Gloria", "Godfrey", "Golda", "Golden", "Gonzalo", "Gordon", "Grace", "Gracie", "Graciela", "Grady", "Graham", "Grant", "Granville", "Grayce", "Grayson", "Green", "Greg", "Gregg", "Gregoria", "Gregorio", "Gregory", "Greta", "Gretchen", "Greyson", "Griffin", "Grover", "Guadalupe", "Gudrun", "Guido", "Guillermo", "Guiseppe", "Gunnar", "Gunner", "Gus", "Gussie", "Gust", "Gustave", "Guy", "Gwen", "Gwendolyn", "Hadley", "Hailee", "Hailey", "Hailie", "Hal", "Haleigh", "Haley", "Halie", "Halle", "Hallie", "Hank", "Hanna", "Hannah", "Hans", "Hardy", "Harley", "Harmon", "Harmony", "Harold", "Harrison", "Harry", "Harvey", "Haskell", "Hassan", "Hassie", "Hattie", "Haven", "Hayden", "Haylee", "Hayley", "Haylie", "Hazel", "Hazle", "Heath", "Heather", "Heaven", "Heber", "Hector", "Heidi", "Helen", "Helena", "Helene", "Helga", "Hellen", "Helmer", "Heloise", "Henderson", "Henri", "Henriette", "Henry", "Herbert", "Herman", "Hermann", "Hermina", "Herminia", "Herminio", "Hershel", "Herta", "Hertha", "Hester", "Hettie", "Hilario", "Hilbert", "Hilda", "Hildegard", "Hillard", "Hillary", "Hilma", "Hilton", "Hipolito", "Hiram", "Hobart", "Holden", "Hollie", "Hollis", "Holly", "Hope", "Horace", "Horacio", "Hortense", "Hosea", "Houston", "Howard", "Howell", "Hoyt", "Hubert", "Hudson", "Hugh", "Hulda", "Humberto", "Hunter", "Hyman", "Ian", "Ibrahim", "Icie", "Ida", "Idell", "Idella", "Ignacio", "Ignatius", "Ike", "Ila", "Ilene", "Iliana", "Ima", "Imani", "Imelda", "Immanuel", "Imogene", "Ines", "Irma", "Irving", "Irwin", "Isaac", "Isabel", "Isabell", "Isabella", "Isabelle", "Isac", "Isadore", "Isai", "Isaiah", "Isaias", "Isidro", "Ismael", "Isobel", "Isom", "Israel", "Issac", "Itzel", "Iva", "Ivah", "Ivory", "Ivy", "Izabella", "Izaiah", "Jabari", "Jace", "Jacey", "Jacinthe", "Jacinto", "Jack", "Jackeline", "Jackie", "Jacklyn", "Jackson", "Jacky", "Jaclyn", "Jacquelyn", "Jacques", "Jacynthe", "Jada", "Jade", "Jaden", "Jadon", "Jadyn", "Jaeden", "Jaida", "Jaiden", "Jailyn", "Jaime", "Jairo", "Jakayla", "Jake", "Jakob", "Jaleel", "Jalen", "Jalon", "Jalyn", "Jamaal", "Jamal", "Jamar", "Jamarcus", "Jamel", "Jameson", "Jamey", "Jamie", "Jamil", "Jamir", "Jamison", "Jammie", "Jan", "Jana", "Janae", "Jane", "Janelle", "Janessa", "Janet", "Janice", "Janick", "Janie", "Janis", "Janiya", "Jannie", "Jany", "Jaquan", "Jaquelin", "Jaqueline", "Jared", "Jaren", "Jarod", "Jaron", "Jarred", "Jarrell", "Jarret", "Jarrett", "Jarrod", "Jarvis", "Jasen", "Jasmin", "Jason", "Jasper", "Jaunita", "Javier", "Javon", "Javonte", "Jay", "Jayce", "Jaycee", "Jayda", "Jayde", "Jayden", "Jaydon", "Jaylan", "Jaylen", "Jaylin", "Jaylon", "Jayme", "Jayne", "Jayson", "Jazlyn", "Jazmin", "Jazmyn", "Jazmyne", "Jean", "Jeanette", "Jeanie", "Jeanne", "Jed", "Jedediah", "Jedidiah", "Jeff", "Jefferey", "Jeffery", "Jeffrey", "Jeffry", "Jena", "Jenifer", "Jennie", "Jennifer", "Jennings", "Jennyfer", "Jensen", "Jerad", "Jerald", "Jeramie", "Jeramy", "Jerel", "Jeremie", "Jeremy", "Jermain", "Jermaine", "Jermey", "Jerod", "Jerome", "Jeromy", "Jerrell", "Jerrod", "Jerrold", "Jerry", "Jess", "Jesse", "Jessica", "Jessie", "Jessika", "Jessy", "Jessyca", "Jesus", "Jett", "Jettie", "Jevon", "Jewel", "Jewell", "Jillian", "Jimmie", "Jimmy", "Jo", "Joan", "Joana", "Joanie", "Joanne", "Joannie", "Joanny", "Joany", "Joaquin", "Jocelyn", "Jodie", "Jody", "Joe", "Joel", "Joelle", "Joesph", "Joey", "Johan", "Johann", "Johanna", "Johathan", "John", "Johnathan", "Johnathon", "Johnnie", "Johnny", "Johnpaul", "Johnson", "Jolie", "Jon", "Jonas", "Jonatan", "Jonathan", "Jonathon", "Jordan", "Jordane", "Jordi", "Jordon", "Jordy", "Jordyn", "Jorge", "Jose", "Josefa", "Josefina", "Joseph", "Josephine", "Josh", "Joshua", "Joshuah", "Josiah", "Josiane", "Josianne", "Josie", "Josue", "Jovan", "Jovani", "Jovanny", "Jovany", "Joy", "Joyce", "Juana", "Juanita", "Judah", "Judd", "Jude", "Judge", "Judson", "Judy", "Jules", "Julia", "Julian", "Juliana", "Julianne", "Julie", "Julien", "Juliet", "Julio", "Julius", "June", "Junior", "Junius", "Justen", "Justice", "Justina", "Justine", "Juston", "Justus", "Justyn", "Juvenal", "Juwan", "Kacey", "Kaci", "Kacie", "Kade", "Kaden", "Kadin", "Kaela", "Kaelyn", "Kaia", "Kailee", "Kailey", "Kailyn", "Kaitlin", "Kaitlyn", "Kale", "Kaleb", "Kaleigh", "Kaley", "Kali", "Kallie", "Kameron", "Kamille", "Kamren", "Kamron", "Kamryn", "Kane", "Kara", "Kareem", "Karelle", "Karen", "Kari", "Kariane", "Karianne", "Karina", "Karine", "Karl", "Karlee", "Karley", "Karli", "Karlie", "Karolann", "Karson", "Kasandra", "Kasey", "Kassandra", "Katarina", "Katelin", "Katelyn", "Katelynn", "Katharina", "Katherine", "Katheryn", "Kathleen", "Kathlyn", "Kathryn", "Kathryne", "Katlyn", "Katlynn", "Katrina", "Katrine", "Kattie", "Kavon", "Kay", "Kaya", "Kaycee", "Kayden", "Kayla", "Kaylah", "Kaylee", "Kayleigh", "Kayley", "Kayli", "Kaylie", "Kaylin", "Keagan", "Keanu", "Keara", "Keaton", "Keegan", "Keeley", "Keely", "Keenan", "Keira", "Keith", "Kellen", "Kelley", "Kelli", "Kellie", "Kelly", "Kelsi", "Kelsie", "Kelton", "Kelvin", "Ken", "Kendall", "Kendra", "Kendrick", "Kenna", "Kennedi", "Kennedy", "Kenneth", "Kennith", "Kenny", "Kenton", "Kenya", "Kenyatta", "Kenyon", "Keon", "Keshaun", "Keshawn", "Keven", "Kevin", "Kevon", "Keyon", "Keyshawn", "Khalid", "Khalil", "Kian", "Kiana", "Kianna", "Kiara", "Kiarra", "Kiel", "Kiera", "Kieran", "Kiley", "Kim", "Kimberly", "King", "Kip", "Kira", "Kirk", "Kirsten", "Kirstin", "Kitty", "Kobe", "Koby", "Kody", "Kolby", "Kole", "Korbin", "Korey", "Kory", "Kraig", "Kris", "Krista", "Kristian", "Kristin", "Kristina", "Kristofer", "Kristoffer", "Kristopher", "Kristy", "Krystal", "Krystel", "Krystina", "Kurt", "Kurtis", "Kyla", "Kyle", "Kylee", "Kyleigh", "Kyler", "Kylie", "Kyra", "Lacey", "Lacy", "Ladarius", "Lafayette", "Laila", "Laisha", "Lamar", "Lambert", "Lamont", "Lance", "Landen", "Lane", "Laney", "Larissa", "Laron", "Larry", "Larue", "Laura", "Laurel", "Lauren", "Laurence", "Lauretta", "Lauriane", "Laurianne", "Laurie", "Laurine", "Laury", "Lauryn", "Lavada", "Lavern", "Laverna", "Laverne", "Lavina", "Lavinia", "Lavon", "Lavonne", "Lawrence", "Lawson", "Layla", "Layne", "Lazaro", "Lea", "Leann", "Leanna", "Leanne", "Leatha", "Leda", "Lee", "Leif", "Leila", "Leilani", "Lela", "Lelah", "Leland", "Lelia", "Lempi", "Lemuel", "Lenna", "Lennie", "Lenny", "Lenora", "Lenore", "Leo", "Leola", "Leon", "Leonard", "Leonardo", "Leone", "Leonel", "Leonie", "Leonor", "Leonora", "Leopold", "Leopoldo", "Leora", "Lera", "Lesley", "Leslie", "Lesly", "Lessie", "Lester", "Leta", "Letha", "Letitia", "Levi", "Lew", "Lewis", "Lexi", "Lexie", "Lexus", "Lia", "Liam", "Liana", "Libbie", "Libby", "Lila", "Lilian", "Liliana", "Liliane", "Lilla", "Lillian", "Lilliana", "Lillie", "Lilly", "Lily", "Lilyan", "Lina", "Lincoln", "Linda", "Lindsay", "Lindsey", "Linnea", "Linnie", "Linwood", "Lionel", "Lisa", "Lisandro", "Lisette", "Litzy", "Liza", "Lizeth", "Lizzie", "Llewellyn", "Lloyd", "Logan", "Lois", "Lola", "Lolita", "Loma", "Lon", "London", "Lonie", "Lonnie", "Lonny", "Lonzo", "Lora", "Loraine", "Loren", "Lorena", "Lorenz", "Lorenza", "Lorenzo", "Lori", "Lorine", "Lorna", "Lottie", "Lou", "Louie", "Louisa", "Lourdes", "Louvenia", "Lowell", "Loy", "Loyal", "Loyce", "Lucas", "Luciano", "Lucie", "Lucienne", "Lucile", "Lucinda", "Lucio", "Lucious", "Lucius", "Lucy", "Ludie", "Ludwig", "Lue", "Luella", "Luigi", "Luis", "Luisa", "Lukas", "Lula", "Lulu", "Luna", "Lupe", "Lura", "Lurline", "Luther", "Luz", "Lyda", "Lydia", "Lyla", "Lynn", "Lyric", "Lysanne", "Mabel", "Mabelle", "Mable", "Mac", "Macey", "Maci", "Macie", "Mack", "Mackenzie", "Macy", "Madaline", "Madalyn", "Maddison", "Madeline", "Madelyn", "Madelynn", "Madge", "Madie", "Madilyn", "Madisen", "Madison", "Madisyn", "Madonna", "Madyson", "Mae", "Maegan", "Maeve", "Mafalda", "Magali", "Magdalen", "Magdalena", "Maggie", "Magnolia", "Magnus", "Maia", "Maida", "Maiya", "Major", "Makayla", "Makenna", "Makenzie", "Malachi", "Malcolm", "Malika", "Malinda", "Mallie", "Mallory", "Malvina", "Mandy", "Manley", "Manuel", "Manuela", "Mara", "Marc", "Marcel", "Marcelina", "Marcelino", "Marcella", "Marcelle", "Marcellus", "Marcelo", "Marcia", "Marco", "Marcos", "Marcus", "Margaret", "Margarete", "Margarett", "Margaretta", "Margarette", "Margarita", "Marge", "Margie", "Margot", "Margret", "Marguerite", "Maria", "Mariah", "Mariam", "Marian", "Mariana", "Mariane", "Marianna", "Marianne", "Mariano", "Maribel", "Marie", "Mariela", "Marielle", "Marietta", "Marilie", "Marilou", "Marilyne", "Marina", "Mario", "Marion", "Marisa", "Marisol", "Maritza", "Marjolaine", "Marjorie", "Marjory", "Mark", "Markus", "Marlee", "Marlen", "Marlene", "Marley", "Marlin", "Marlon", "Marques", "Marquis", "Marquise", "Marshall", "Marta", "Martin", "Martina", "Martine", "Marty", "Marvin", "Mary", "Maryam", "Maryjane", "Maryse", "Mason", "Mateo", "Mathew", "Mathias", "Mathilde", "Matilda", "Matilde", "Matt", "Matteo", "Mattie", "Maud", "Maude", "Maudie", "Maureen", "Maurice", "Mauricio", "Maurine", "Maverick", "Mavis", "Max", "Maxie", "Maxime", "Maximilian", "Maximillia", "Maximillian", "Maximo", "Maximus", "Maxine", "Maxwell", "May", "Maya", "Maybell", "Maybelle", "Maye", "Maymie", "Maynard", "Mayra", "Mazie", "Mckayla", "Mckenna", "Mckenzie", "Meagan", "Meaghan", "Meda", "Megane", "Meggie", "Meghan", "Mekhi", "Melany", "Melba", "Melisa", "Melissa", "Mellie", "Melody", "Melvin", "Melvina", "Melyna", "Melyssa", "Mercedes", "Meredith", "Merl", "Merle", "Merlin", "Merritt", "Mertie", "Mervin", "Meta", "Mia", "Micaela", "Micah", "Michael", "Michaela", "Michale", "Micheal", "Michel", "Michele", "Michelle", "Miguel", "Mikayla", "Mike", "Mikel", "Milan", "Miles", "Milford", "Miller", "Millie", "Milo", "Milton", "Mina", "Minerva", "Minnie", "Miracle", "Mireille", "Mireya", "Misael", "Missouri", "Misty", "Mitchel", "Mitchell", "Mittie", "Modesta", "Modesto", "Mohamed", "Mohammad", "Mohammed", "Moises", "Mollie", "Molly", "Mona", "Monica", "Monique", "Monroe", "Monserrat", "Monserrate", "Montana", "Monte", "Monty", "Morgan", "Moriah", "Morris", "Mortimer", "Morton", "Mose", "Moses", "Moshe", "Mossie", "Mozell", "Mozelle", "Muhammad", "Muriel", "Murl", "Murphy", "Murray", "Mustafa", "Mya", "Myah", "Mylene", "Myles", "Myra", "Myriam", "Myrl", "Myrna", "Myron", "Myrtice", "Myrtie", "Myrtis", "Myrtle", "Nadia", "Nakia", "Name", "Nannie", "Naomi", "Naomie", "Napoleon", "Narciso", "Nash", "Nasir", "Nat", "Natalia", "Natalie", "Natasha", "Nathan", "Nathanael", "Nathanial", "Nathaniel", "Nathen", "Nayeli", "Neal", "Ned", "Nedra", "Neha", "Neil", "Nelda", "Nella", "Nelle", "Nellie", "Nels", "Nelson", "Neoma", "Nestor", "Nettie", "Neva", "Newell", "Newton", "Nia", "Nicholas", "Nicholaus", "Nichole", "Nick", "Nicklaus", "Nickolas", "Nico", "Nicola", "Nicolas", "Nicole", "Nicolette", "Nigel", "Nikita", "Nikki", "Nikko", "Niko", "Nikolas", "Nils", "Nina", "Noah", "Noble", "Noe", "Noel", "Noelia", "Noemi", "Noemie", "Noemy", "Nola", "Nolan", "Nona", "Nora", "Norbert", "Norberto", "Norene", "Norma", "Norris", "Norval", "Norwood", "Nova", "Novella", "Nya", "Nyah", "Nyasia", "Obie", "Oceane", "Ocie", "Octavia", "Oda", "Odell", "Odessa", "Odie", "Ofelia", "Okey", "Ola", "Olaf", "Ole", "Olen", "Oleta", "Olga", "Olin", "Oliver", "Ollie", "Oma", "Omari", "Omer", "Ona", "Onie", "Opal", "Ophelia", "Ora", "Oral", "Oran", "Oren", "Orie", "Orin", "Orion", "Orland", "Orlando", "Orlo", "Orpha", "Orrin", "Orval", "Orville", "Osbaldo", "Osborne", "Oscar", "Osvaldo", "Oswald", "Oswaldo", "Otha", "Otho", "Otilia", "Otis", "Ottilie", "Ottis", "Otto", "Ova", "Owen", "Ozella", "Pablo", "Paige", "Palma", "Pamela", "Pansy", "Paolo", "Paris", "Parker", "Pascale", "Pasquale", "Pat", "Patience", "Patricia", "Patrick", "Patsy", "Pattie", "Paul", "Paula", "Pauline", "Paxton", "Payton", "Pearl", "Pearlie", "Pearline", "Pedro", "Peggie", "Penelope", "Percival", "Percy", "Perry", "Pete", "Peter", "Petra", "Peyton", "Philip", "Phoebe", "Phyllis", "Pierce", "Pierre", "Pietro", "Pink", "Pinkie", "Piper", "Polly", "Porter", "Precious", "Presley", "Preston", "Price", "Prince", "Princess", "Priscilla", "Providenci", "Prudence", "Queen", "Queenie", "Quentin", "Quincy", "Quinn", "Quinten", "Quinton", "Rachael", "Rachel", "Rachelle", "Rae", "Raegan", "Rafael", "Rafaela", "Raheem", "Rahsaan", "Rahul", "Raina", "Raleigh", "Ralph", "Ramiro", "Ramon", "Ramona", "Randal", "Randall", "Randi", "Randy", "Ransom", "Raoul", "Raphael", "Raphaelle", "Raquel", "Rashad", "Rashawn", "Rasheed", "Raul", "Raven", "Ray", "Raymond", "Raymundo", "Reagan", "Reanna", "Reba", "Rebeca", "Rebecca", "Rebeka", "Rebekah", "Reece", "Reed", "Reese", "Regan", "Reggie", "Reginald", "Reid", "Reilly", "Reina", "Reinhold", "Remington", "Rene", "Renee", "Ressie", "Reta", "Retha", "Retta", "Reuben", "Reva", "Rex", "Rey", "Reyes", "Reymundo", "Reyna", "Reynold", "Rhea", "Rhett", "Rhianna", "Rhiannon", "Rhoda", "Ricardo", "Richard", "Richie", "Richmond", "Rick", "Rickey", "Rickie", "Ricky", "Rico", "Rigoberto", "Riley", "Rita", "River", "Robb", "Robbie", "Robert", "Roberta", "Roberto", "Robin", "Robyn", "Rocio", "Rocky", "Rod", "Roderick", "Rodger", "Rodolfo", "Rodrick", "Rodrigo", "Roel", "Rogelio", "Roger", "Rogers", "Rolando", "Rollin", "Roma", "Romaine", "Roman", "Ron", "Ronaldo", "Ronny", "Roosevelt", "Rory", "Rosa", "Rosalee", "Rosalia", "Rosalind", "Rosalinda", "Rosalyn", "Rosamond", "Rosanna", "Rosario", "Roscoe", "Rose", "Rosella", "Roselyn", "Rosemarie", "Rosemary", "Rosendo", "Rosetta", "Rosie", "Rosina", "Roslyn", "Ross", "Rossie", "Rowan", "Rowena", "Rowland", "Roxane", "Roxanne", "Roy", "Royal", "Royce", "Rozella", "Ruben", "Rubie", "Ruby", "Rubye", "Rudolph", "Rudy", "Rupert", "Russ", "Russel", "Russell", "Rusty", "Ruth", "Ruthe", "Ruthie", "Ryan", "Ryann", "Ryder", "Rylan", "Rylee", "Ryleigh", "Ryley", "Sabina", "Sabrina", "Sabryna", "Sadie", "Sadye", "Sage", "Saige", "Sallie", "Sally", "Salma", "Salvador", "Salvatore", "Sam", "Samanta", "Samantha", "Samara", "Samir", "Sammie", "Sammy", "Samson", "Sandra", "Sandrine", "Sandy", "Sanford", "Santa", "Santiago", "Santina", "Santino", "Santos", "Sarah", "Sarai", "Sarina", "Sasha", "Saul", "Savanah", "Savanna", "Savannah", "Savion", "Scarlett", "Schuyler", "Scot", "Scottie", "Scotty", "Seamus", "Sean", "Sebastian", "Sedrick", "Selena", "Selina", "Selmer", "Serena", "Serenity", "Seth", "Shad", "Shaina", "Shakira", "Shana", "Shane", "Shanel", "Shanelle", "Shania", "Shanie", "Shaniya", "Shanna", "Shannon", "Shanny", "Shanon", "Shany", "Sharon", "Shaun", "Shawn", "Shawna", "Shaylee", "Shayna", "Shayne", "Shea", "Sheila", "Sheldon", "Shemar", "Sheridan", "Sherman", "Sherwood", "Shirley", "Shyann", "Shyanne", "Sibyl", "Sid", "Sidney", "Sienna", "Sierra", "Sigmund", "Sigrid", "Sigurd", "Silas", "Sim", "Simeon", "Simone", "Sincere", "Sister", "Skye", "Skyla", "Skylar", "Sofia", "Soledad", "Solon", "Sonia", "Sonny", "Sonya", "Sophia", "Sophie", "Spencer", "Stacey", "Stacy", "Stan", "Stanford", "Stanley", "Stanton", "Stefan", "Stefanie", "Stella", "Stephan", "Stephania", "Stephanie", "Stephany", "Stephen", "Stephon", "Sterling", "Steve", "Stevie", "Stewart", "Stone", "Stuart", "Summer", "Sunny", "Susan", "Susana", "Susanna", "Susie", "Suzanne", "Sven", "Syble", "Sydnee", "Sydney", "Sydni", "Sydnie", "Sylvan", "Sylvester", "Sylvia", "Tabitha", "Tad", "Talia", "Talon", "Tamara", "Tamia", "Tania", "Tanner", "Tanya", "Tara", "Taryn", "Tate", "Tatum", "Tatyana", "Taurean", "Tavares", "Taya", "Taylor", "Teagan", "Ted", "Telly", "Terence", "Teresa", "Terrance", "Terrell", "Terrence", "Terrill", "Terry", "Tess", "Tessie", "Tevin", "Thad", "Thaddeus", "Thalia", "Thea", "Thelma", "Theo", "Theodora", "Theodore", "Theresa", "Therese", "Theresia", "Theron", "Thomas", "Thora", "Thurman", "Tia", "Tiana", "Tianna", "Tiara", "Tierra", "Tiffany", "Tillman", "Timmothy", "Timmy", "Timothy", "Tina", "Tito", "Titus", "Tobin", "Toby", "Tod", "Tom", "Tomas", "Tomasa", "Tommie", "Toney", "Toni", "Tony", "Torey", "Torrance", "Torrey", "Toy", "Trace", "Tracey", "Tracy", "Travis", "Travon", "Tre", "Tremaine", "Tremayne", "Trent", "Trenton", "Tressa", "Tressie", "Treva", "Trever", "Trevion", "Trevor", "Trey", "Trinity", "Trisha", "Tristian", "Tristin", "Triston", "Troy", "Trudie", "Trycia", "Trystan", "Turner", "Twila", "Tyler", "Tyra", "Tyree", "Tyreek", "Tyrel", "Tyrell", "Tyrese", "Tyrique", "Tyshawn", "Tyson", "Ubaldo", "Ulices", "Ulises", "Una", "Unique", "Urban", "Uriah", "Uriel", "Ursula", "Vada", "Valentin", "Valentina", "Valentine", "Valerie", "Vallie", "Van", "Vance", "Vanessa", "Vaughn", "Veda", "Velda", "Vella", "Velma", "Velva", "Vena", "Verda", "Verdie", "Vergie", "Verla", "Verlie", "Vern", "Verna", "Verner", "Vernice", "Vernie", "Vernon", "Verona", "Veronica", "Vesta", "Vicenta", "Vicente", "Vickie", "Vicky", "Victor", "Victoria", "Vida", "Vidal", "Vilma", "Vince", "Vincent", "Vincenza", "Vincenzo", "Vinnie", "Viola", "Violet", "Violette", "Virgie", "Virgil", "Virginia", "Virginie", "Vita", "Vito", "Viva", "Vivian", "Viviane", "Vivianne", "Vivien", "Vivienne", "Vladimir", "Wade", "Waino", "Waldo", "Walker", "Wallace", "Walter", "Walton", "Wanda", "Ward", "Warren", "Watson", "Wava", "Waylon", "Wayne", "Webster", "Weldon", "Wellington", "Wendell", "Wendy", "Werner", "Westley", "Weston", "Whitney", "Wilber", "Wilbert", "Wilburn", "Wiley", "Wilford", "Wilfred", "Wilfredo", "Wilfrid", "Wilhelm", "Wilhelmine", "Will", "Willa", "Willard", "William", "Willie", "Willis", "Willow", "Willy", "Wilma", "Wilmer", "Wilson", "Wilton", "Winfield", "Winifred", "Winnifred", "Winona", "Winston", "Woodrow", "Wyatt", "Wyman", "Xander", "Xavier", "Xzavier", "Yadira", "Yasmeen", "Yasmin", "Yasmine", "Yazmin", "Yesenia", "Yessenia", "Yolanda", "Yoshiko", "Yvette", "Yvonne", "Zachariah", "Zachary", "Zachery", "Zack", "Zackary", "Zackery", "Zakary", "Zander", "Zane", "Zaria", "Zechariah", "Zelda", "Zella", "Zelma", "Zena", "Zetta", "Zion", "Zita", "Zoe", "Zoey", "Zoie", "Zoila", "Zola", "Zora", "Zula"];
                    e.exports = {
                        generateUsername: function() {
                            return `${n.randomElement(s)}-${n.randomAlphanumStr(3)}`
                        }
                    }
                },
                2505: (e, t, i) => {
                    var n = i(8350);

                    function s(e, t) {
                        this.logStorage = e, this.stringifyObjects = !(!t || !t.stringifyObjects) && t.stringifyObjects, this.storeInterval = t && t.storeInterval ? t.storeInterval : 3e4, this.maxEntryLength = t && t.maxEntryLength ? t.maxEntryLength : 1e4, Object.keys(n.levels).forEach(function(e) {
                            this[n.levels[e]] = function() {
                                this._log.apply(this, arguments)
                            }.bind(this, e)
                        }.bind(this)), this.storeLogsIntervalID = null, this.queue = [], this.totalLen = 0, this.outputCache = []
                    }
                    s.prototype.stringify = function(e) {
                        try {
                            return JSON.stringify(e)
                        } catch (e) {
                            return "[object with circular refs?]"
                        }
                    }, s.prototype.formatLogMessage = function(e) {
                        for (var t = "", i = 1, s = arguments.length; i < s; i++) {
                            var r = arguments[i];
                            !this.stringifyObjects && e !== n.levels.ERROR || "object" != typeof r || (r = this.stringify(r)), t += r, i !== s - 1 && (t += " ")
                        }
                        return t.length ? t : null
                    }, s.prototype._log = function() {
                        var e = arguments[1],
                            t = this.formatLogMessage.apply(this, arguments);
                        if (t) {
                            var i = this.queue[this.queue.length - 1],
                                n = i && i.text;
                            n === t ? i.count += 1 : (this.queue.push({
                                text: t,
                                timestamp: e,
                                count: 1
                            }), this.totalLen += t.length)
                        }
                        this.totalLen >= this.maxEntryLength && this._flush(!0, !0)
                    }, s.prototype.start = function() {
                        this._reschedulePublishInterval()
                    }, s.prototype._reschedulePublishInterval = function() {
                        this.storeLogsIntervalID && (window.clearTimeout(this.storeLogsIntervalID), this.storeLogsIntervalID = null), this.storeLogsIntervalID = window.setTimeout(this._flush.bind(this, !1, !0), this.storeInterval)
                    }, s.prototype.flush = function() {
                        this._flush(!1, !0)
                    }, s.prototype._flush = function(e, t) {
                        this.totalLen > 0 && (this.logStorage.isReady() || e) && (this.logStorage.isReady() ? (this.outputCache.length && (this.outputCache.forEach(function(e) {
                            this.logStorage.storeLogs(e)
                        }.bind(this)), this.outputCache = []), this.logStorage.storeLogs(this.queue)) : this.outputCache.push(this.queue), this.queue = [], this.totalLen = 0), t && this._reschedulePublishInterval()
                    }, s.prototype.stop = function() {
                        this._flush(!1, !1)
                    }, e.exports = s
                },
                8350: e => {
                    var t = {
                        trace: 0,
                        debug: 1,
                        info: 2,
                        log: 3,
                        warn: 4,
                        error: 5
                    };
                    o.consoleTransport = console;
                    var i = [o.consoleTransport];
                    o.addGlobalTransport = function(e) {
                        -1 === i.indexOf(e) && i.push(e)
                    }, o.removeGlobalTransport = function(e) {
                        var t = i.indexOf(e); - 1 !== t && i.splice(t, 1)
                    };
                    var n = {};

                    function s() {
                        var e = {
                                methodName: "",
                                fileLocation: "",
                                line: null,
                                column: null
                            },
                            t = new Error,
                            i = t.stack ? t.stack.split("\n") : [];
                        if (!i || i.length < 3) return e;
                        var n = null;
                        return i[3] && (n = i[3].match(/\s*at\s*(.+?)\s*\((\S*)\s*:(\d*)\s*:(\d*)\)/)), !n || n.length <= 4 ? (0 === i[2].indexOf("log@") ? e.methodName = i[3].substr(0, i[3].indexOf("@")) : e.methodName = i[2].substr(0, i[2].indexOf("@")), e) : (e.methodName = n[1], e.fileLocation = n[2], e.line = n[3], e.column = n[4], e)
                    }

                    function r() {
                        var e = arguments[0],
                            r = arguments[1],
                            o = Array.prototype.slice.call(arguments, 2);
                        if (!(t[r] < e.level))
                            for (var a = !(e.options.disableCallerInfo || n.disableCallerInfo) && s(), c = i.concat(e.transports), d = 0; d < c.length; d++) {
                                var l = c[d],
                                    h = l[r];
                                if (h && "function" == typeof h) {
                                    var u = [];
                                    u.push((new Date).toISOString()), e.id && u.push("[" + e.id + "]"), a && a.methodName.length > 1 && u.push("<" + a.methodName + ">: ");
                                    var p = u.concat(o);
                                    h.bind(l).apply(l, p)
                                }
                            }
                    }

                    function o(e, i, n, s) {
                        this.id = i, this.options = s || {}, this.transports = n, this.transports || (this.transports = []), this.level = t[e];
                        for (var o = Object.keys(t), a = 0; a < o.length; a++) this[o[a]] = r.bind(null, this, o[a])
                    }
                    o.setGlobalOptions = function(e) {
                        n = e || {}
                    }, o.prototype.setLevel = function(e) {
                        this.level = t[e]
                    }, e.exports = o, o.levels = {
                        TRACE: "trace",
                        DEBUG: "debug",
                        INFO: "info",
                        LOG: "log",
                        WARN: "warn",
                        ERROR: "error"
                    }
                },
                5810: (e, t, i) => {
                    var n = i(8350),
                        s = i(2505),
                        r = {},
                        o = [],
                        a = n.levels.TRACE;
                    e.exports = {
                        addGlobalTransport: function(e) {
                            n.addGlobalTransport(e)
                        },
                        removeGlobalTransport: function(e) {
                            n.removeGlobalTransport(e)
                        },
                        setGlobalOptions: function(e) {
                            n.setGlobalOptions(e)
                        },
                        getLogger: function(e, t, i) {
                            var s = new n(a, e, t, i);
                            return e ? (r[e] = r[e] || [], r[e].push(s)) : o.push(s), s
                        },
                        setLogLevelById: function(e, t) {
                            for (var i = t ? r[t] || [] : o, n = 0; n < i.length; n++) i[n].setLevel(e)
                        },
                        setLogLevel: function(e) {
                            a = e;
                            for (var t = 0; t < o.length; t++) o[t].setLevel(e);
                            for (var i in r) {
                                var n = r[i] || [];
                                for (t = 0; t < n.length; t++) n[t].setLevel(e)
                            }
                        },
                        levels: n.levels,
                        LogCollector: s
                    }
                },
                8022: e => {
                    var t = e.exports = {
                        v: [{
                            name: "version",
                            reg: /^(\d*)$/
                        }],
                        o: [{
                            name: "origin",
                            reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
                            names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
                            format: "%s %s %d %s IP%d %s"
                        }],
                        s: [{
                            name: "name"
                        }],
                        i: [{
                            name: "description"
                        }],
                        u: [{
                            name: "uri"
                        }],
                        e: [{
                            name: "email"
                        }],
                        p: [{
                            name: "phone"
                        }],
                        z: [{
                            name: "timezones"
                        }],
                        r: [{
                            name: "repeats"
                        }],
                        t: [{
                            name: "timing",
                            reg: /^(\d*) (\d*)/,
                            names: ["start", "stop"],
                            format: "%d %d"
                        }],
                        c: [{
                            name: "connection",
                            reg: /^IN IP(\d) (\S*)/,
                            names: ["version", "ip"],
                            format: "IN IP%d %s"
                        }],
                        b: [{
                            push: "bandwidth",
                            reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
                            names: ["type", "limit"],
                            format: "%s:%s"
                        }],
                        m: [{
                            reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
                            names: ["type", "port", "protocol", "payloads"],
                            format: "%s %d %s %s"
                        }],
                        a: [{
                            push: "rtp",
                            reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
                            names: ["payload", "codec", "rate", "encoding"],
                            format: function(e) {
                                return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
                            }
                        }, {
                            push: "fmtp",
                            reg: /^fmtp:(\d*) ([\S| ]*)/,
                            names: ["payload", "config"],
                            format: "fmtp:%d %s"
                        }, {
                            name: "control",
                            reg: /^control:(.*)/,
                            format: "control:%s"
                        }, {
                            name: "rtcp",
                            reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                            names: ["port", "netType", "ipVer", "address"],
                            format: function(e) {
                                return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
                            }
                        }, {
                            push: "rtcpFbTrrInt",
                            reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                            names: ["payload", "value"],
                            format: "rtcp-fb:%s trr-int %d"
                        }, {
                            push: "rtcpFb",
                            reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                            names: ["payload", "type", "subtype"],
                            format: function(e) {
                                return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
                            }
                        }, {
                            push: "ext",
                            reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
                            names: ["value", "direction", "encrypt-uri", "uri", "config"],
                            format: function(e) {
                                return "extmap:%d" + (e.direction ? "/%s" : "%v") + (e["encrypt-uri"] ? " %s" : "%v") + " %s" + (e.config ? " %s" : "")
                            }
                        }, {
                            name: "extmapAllowMixed",
                            reg: /^(extmap-allow-mixed)/
                        }, {
                            push: "crypto",
                            reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                            names: ["id", "suite", "config", "sessionConfig"],
                            format: function(e) {
                                return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
                            }
                        }, {
                            name: "setup",
                            reg: /^setup:(\w*)/,
                            format: "setup:%s"
                        }, {
                            name: "connectionType",
                            reg: /^connection:(new|existing)/,
                            format: "connection:%s"
                        }, {
                            name: "mid",
                            reg: /^mid:([^\s]*)/,
                            format: "mid:%s"
                        }, {
                            name: "msid",
                            reg: /^msid:(.*)/,
                            format: "msid:%s"
                        }, {
                            name: "ptime",
                            reg: /^ptime:(\d*(?:\.\d*)*)/,
                            format: "ptime:%d"
                        }, {
                            name: "maxptime",
                            reg: /^maxptime:(\d*(?:\.\d*)*)/,
                            format: "maxptime:%d"
                        }, {
                            name: "direction",
                            reg: /^(sendrecv|recvonly|sendonly|inactive)/
                        }, {
                            name: "icelite",
                            reg: /^(ice-lite)/
                        }, {
                            name: "iceUfrag",
                            reg: /^ice-ufrag:(\S*)/,
                            format: "ice-ufrag:%s"
                        }, {
                            name: "icePwd",
                            reg: /^ice-pwd:(\S*)/,
                            format: "ice-pwd:%s"
                        }, {
                            name: "fingerprint",
                            reg: /^fingerprint:(\S*) (\S*)/,
                            names: ["type", "hash"],
                            format: "fingerprint:%s %s"
                        }, {
                            push: "candidates",
                            reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
                            names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
                            format: function(e) {
                                var t = "candidate:%s %d %s %d %s %d typ %s";
                                return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), (t += null != e["network-id"] ? " network-id %d" : "%v") + (null != e["network-cost"] ? " network-cost %d" : "%v")
                            }
                        }, {
                            name: "endOfCandidates",
                            reg: /^(end-of-candidates)/
                        }, {
                            name: "remoteCandidates",
                            reg: /^remote-candidates:(.*)/,
                            format: "remote-candidates:%s"
                        }, {
                            name: "iceOptions",
                            reg: /^ice-options:(\S*)/,
                            format: "ice-options:%s"
                        }, {
                            push: "ssrcs",
                            reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
                            names: ["id", "attribute", "value"],
                            format: function(e) {
                                var t = "ssrc:%d";
                                return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
                            }
                        }, {
                            push: "ssrcGroups",
                            reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
                            names: ["semantics", "ssrcs"],
                            format: "ssrc-group:%s %s"
                        }, {
                            name: "msidSemantic",
                            reg: /^msid-semantic:\s?(\w*) (\S*)/,
                            names: ["semantic", "token"],
                            format: "msid-semantic: %s %s"
                        }, {
                            push: "groups",
                            reg: /^group:(\w*) (.*)/,
                            names: ["type", "mids"],
                            format: "group:%s %s"
                        }, {
                            name: "rtcpMux",
                            reg: /^(rtcp-mux)/
                        }, {
                            name: "rtcpRsize",
                            reg: /^(rtcp-rsize)/
                        }, {
                            name: "sctpmap",
                            reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
                            names: ["sctpmapNumber", "app", "maxMessageSize"],
                            format: function(e) {
                                return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
                            }
                        }, {
                            name: "xGoogleFlag",
                            reg: /^x-google-flag:([^\s]*)/,
                            format: "x-google-flag:%s"
                        }, {
                            push: "rids",
                            reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
                            names: ["id", "direction", "params"],
                            format: function(e) {
                                return e.params ? "rid:%s %s %s" : "rid:%s %s"
                            }
                        }, {
                            push: "imageattrs",
                            reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
                            names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
                            format: function(e) {
                                return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
                            }
                        }, {
                            name: "simulcast",
                            reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
                            names: ["dir1", "list1", "dir2", "list2"],
                            format: function(e) {
                                return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
                            }
                        }, {
                            name: "simulcast_03",
                            reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
                            names: ["value"],
                            format: "simulcast: %s"
                        }, {
                            name: "framerate",
                            reg: /^framerate:(\d+(?:$|\.\d+))/,
                            format: "framerate:%s"
                        }, {
                            name: "sourceFilter",
                            reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
                            names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
                            format: "source-filter: %s %s %s %s %s"
                        }, {
                            name: "bundleOnly",
                            reg: /^(bundle-only)/
                        }, {
                            name: "label",
                            reg: /^label:(.+)/,
                            format: "label:%s"
                        }, {
                            name: "sctpPort",
                            reg: /^sctp-port:(\d+)$/,
                            format: "sctp-port:%s"
                        }, {
                            name: "maxMessageSize",
                            reg: /^max-message-size:(\d+)$/,
                            format: "max-message-size:%s"
                        }, {
                            push: "tsRefClocks",
                            reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
                            names: ["clksrc", "clksrcExt"],
                            format: function(e) {
                                return "ts-refclk:%s" + (null != e.clksrcExt ? "=%s" : "")
                            }
                        }, {
                            name: "mediaClk",
                            reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
                            names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
                            format: function(e) {
                                var t = "mediaclk:";
                                return t += null != e.id ? "id=%s %s" : "%v%s", t += null != e.mediaClockValue ? "=%s" : "", (t += null != e.rateNumerator ? " rate=%s" : "") + (null != e.rateDenominator ? "/%s" : "")
                            }
                        }, {
                            name: "keywords",
                            reg: /^keywds:(.+)$/,
                            format: "keywds:%s"
                        }, {
                            name: "content",
                            reg: /^content:(.+)/,
                            format: "content:%s"
                        }, {
                            name: "bfcpFloorCtrl",
                            reg: /^floorctrl:(c-only|s-only|c-s)/,
                            format: "floorctrl:%s"
                        }, {
                            name: "bfcpConfId",
                            reg: /^confid:(\d+)/,
                            format: "confid:%s"
                        }, {
                            name: "bfcpUserId",
                            reg: /^userid:(\d+)/,
                            format: "userid:%s"
                        }, {
                            name: "bfcpFloorId",
                            reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
                            names: ["id", "mStream"],
                            format: "floorid:%s mstrm:%s"
                        }, {
                            push: "invalid",
                            names: ["value"]
                        }]
                    };
                    Object.keys(t).forEach((function(e) {
                        t[e].forEach((function(e) {
                            e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
                        }))
                    }))
                },
                6561: (e, t, i) => {
                    var n = i(2408),
                        s = i(2508);
                    t.write = s, t.parse = n.parse, t.parseParams = n.parseParams, t.parseFmtpConfig = n.parseFmtpConfig, t.parsePayloads = n.parsePayloads, t.parseRemoteCandidates = n.parseRemoteCandidates, t.parseImageAttributes = n.parseImageAttributes, t.parseSimulcastStreamList = n.parseSimulcastStreamList
                },
                2408: (e, t, i) => {
                    var n = function(e) {
                            return String(Number(e)) === e ? Number(e) : e
                        },
                        s = function(e, t, i) {
                            var s = e.name && e.names;
                            e.push && !t[e.push] ? t[e.push] = [] : s && !t[e.name] && (t[e.name] = {});
                            var r = e.push ? {} : s ? t[e.name] : t;
                            ! function(e, t, i, s) {
                                if (s && !i) t[s] = n(e[1]);
                                else
                                    for (var r = 0; r < i.length; r += 1) null != e[r + 1] && (t[i[r]] = n(e[r + 1]))
                            }(i.match(e.reg), r, e.names, e.name), e.push && t[e.push].push(r)
                        },
                        r = i(8022),
                        o = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
                    t.parse = function(e) {
                        var t = {},
                            i = [],
                            n = t;
                        return e.split(/(\r\n|\r|\n)/).filter(o).forEach((function(e) {
                            var t = e[0],
                                o = e.slice(2);
                            "m" === t && (i.push({
                                rtp: [],
                                fmtp: []
                            }), n = i[i.length - 1]);
                            for (var a = 0; a < (r[t] || []).length; a += 1) {
                                var c = r[t][a];
                                if (c.reg.test(o)) return s(c, n, o)
                            }
                        })), t.media = i, t
                    };
                    var a = function(e, t) {
                        var i = t.split(/=(.+)/, 2);
                        return 2 === i.length ? e[i[0]] = n(i[1]) : 1 === i.length && t.length > 1 && (e[i[0]] = void 0), e
                    };
                    t.parseParams = function(e) {
                        return e.split(/;\s?/).reduce(a, {})
                    }, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e) {
                        return e.toString().split(" ").map(Number)
                    }, t.parseRemoteCandidates = function(e) {
                        for (var t = [], i = e.split(" ").map(n), s = 0; s < i.length; s += 3) t.push({
                            component: i[s],
                            ip: i[s + 1],
                            port: i[s + 2]
                        });
                        return t
                    }, t.parseImageAttributes = function(e) {
                        return e.split(" ").map((function(e) {
                            return e.substring(1, e.length - 1).split(",").reduce(a, {})
                        }))
                    }, t.parseSimulcastStreamList = function(e) {
                        return e.split(";").map((function(e) {
                            return e.split(",").map((function(e) {
                                var t, i = !1;
                                return "~" !== e[0] ? t = n(e) : (t = n(e.substring(1, e.length)), i = !0), {
                                    scid: t,
                                    paused: i
                                }
                            }))
                        }))
                    }
                },
                2508: (e, t, i) => {
                    var n = i(8022),
                        s = /%[sdv%]/g,
                        r = function(e) {
                            var t = 1,
                                i = arguments,
                                n = i.length;
                            return e.replace(s, (function(e) {
                                if (t >= n) return e;
                                var s = i[t];
                                switch (t += 1, e) {
                                    case "%%":
                                        return "%";
                                    case "%s":
                                        return String(s);
                                    case "%d":
                                        return Number(s);
                                    case "%v":
                                        return ""
                                }
                            }))
                        },
                        o = function(e, t, i) {
                            var n = [e + "=" + (t.format instanceof Function ? t.format(t.push ? i : i[t.name]) : t.format)];
                            if (t.names)
                                for (var s = 0; s < t.names.length; s += 1) {
                                    var o = t.names[s];
                                    t.name ? n.push(i[t.name][o]) : n.push(i[t.names[s]])
                                } else n.push(i[t.name]);
                            return r.apply(null, n)
                        },
                        a = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
                        c = ["i", "c", "b", "a"];
                    e.exports = function(e, t) {
                        t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
                            null == e.payloads && (e.payloads = "")
                        }));
                        var i = t.outerOrder || a,
                            s = t.innerOrder || c,
                            r = [];
                        return i.forEach((function(t) {
                            n[t].forEach((function(i) {
                                i.name in e && null != e[i.name] ? r.push(o(t, i, e)) : i.push in e && null != e[i.push] && e[i.push].forEach((function(e) {
                                    r.push(o(t, i, e))
                                }))
                            }))
                        })), e.media.forEach((function(e) {
                            r.push(o("m", n.m[0], e)), s.forEach((function(t) {
                                n[t].forEach((function(i) {
                                    i.name in e && null != e[i.name] ? r.push(o(t, i, e)) : i.push in e && null != e[i.push] && e[i.push].forEach((function(e) {
                                        r.push(o(t, i, e))
                                    }))
                                }))
                            }))
                        })), r.join("\r\n") + "\r\n"
                    }
                },
                6234: (e, t, i) => {
                    var n = i(8310),
                        s = i(6298),
                        r = s.parseSsrcs,
                        o = s.writeSsrcs;

                    function a(e, t, i) {
                        return e.ssrcs.filter((function(e) {
                            return e.id === t
                        })).filter((function(e) {
                            return e.attribute === i
                        })).map((function(e) {
                            return e.value
                        }))[0]
                    }

                    function c(e) {
                        this.options = e || {}, this.options.numOfLayers || (this.options.numOfLayers = 3), console.log("SdpSimulcast: using " + this.options.numOfLayers + " layers"), this.ssrcCache = []
                    }

                    function d(e, t) {
                        null != e && Array.isArray(e.media) && e.media.forEach((function(e) {
                            "video" === e.type && t(e)
                        }))
                    }

                    function l(e) {
                        return e && null != e && e.type && "" != e.type && e.sdp && "" != e.sdp
                    }
                    c.prototype.clearSsrcCache = function() {
                        this.ssrcCache = []
                    }, c.prototype.setSsrcCache = function(e) {
                        this.ssrcCache = e
                    }, c.prototype._parseSimLayers = function(e) {
                        var t = e.ssrcGroups && e.ssrcGroups.find((function(e) {
                            return "SIM" === e.semantics
                        }));
                        return t ? t.ssrcs.split(" ").map((function(e) {
                            return parseInt(e)
                        })) : [e.ssrcs[0].id]
                    }, c.prototype._buildNewToOldSsrcMap = function(e, t) {
                        for (var i = {}, n = 0; n < e.length; ++n) {
                            var s = e[n],
                                r = t[n] || null;
                            i[s] = r
                        }
                        return i
                    }, c.prototype._fillInSourceDataFromCache = function(e) {
                        console.log("SdpSimulcast restoring from cache: ", this.ssrcCache);
                        var t = this._parseSimLayers(e);
                        console.log("SdpSimulcast Parsed new sim ssrcs: ", t);
                        var i = a(e, t[0], "msid"),
                            n = a(e, t[0], "cname"),
                            s = this._buildNewToOldSsrcMap(t, this.ssrcCache);
                        console.log("SdpSimulcast built replacement map: ", s);
                        var r = this.ssrcCache.filter((function(e) {
                            return -1 === Object.values(s).indexOf(e)
                        }));
                        return console.log("SdpSimulcast built ssrcs to add: ", r), e.ssrcs.forEach((function(e) {
                            s[e.id] && (e.id = s[e.id])
                        })), r.forEach((function(t) {
                            e.ssrcs.push({
                                id: t,
                                attribute: "msid",
                                value: i
                            }), e.ssrcs.push({
                                id: t,
                                attribute: "cname",
                                value: n
                            })
                        })), e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
                            semantics: "SIM",
                            ssrcs: this.ssrcCache.join(" ")
                        }), e
                    }, c.prototype._generateSourceData = function(e, t) {
                        var i = function(e, t) {
                                e.ssrcs.push({
                                    id: t,
                                    attribute: "cname",
                                    value: s
                                }), e.ssrcs.push({
                                    id: t,
                                    attribute: "msid",
                                    value: n
                                })
                            },
                            n = a(e, t, "msid"),
                            s = a(e, t, "cname");
                        this.options.usesUnifiedPlan && !n && (n = e.msid, e.ssrcs.forEach((t => {
                            e.ssrcs.push({
                                id: t.id,
                                attribute: "msid",
                                value: n
                            })
                        })));
                        for (var r = [], o = 0; o < this.options.numOfLayers - 1; ++o) {
                            var c = Math.floor(4294967295 * Math.random()) + 0;
                            i(e, c), r.push(c)
                        }
                        return e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
                            semantics: "SIM",
                            ssrcs: t + " " + r.join(" ")
                        }), e
                    }, c.prototype._restoreSimulcast = function(e) {
                        var t, i = e.ssrcs && e.ssrcs.map((function(e) {
                                return e.id
                            })).filter((function(e, t, i) {
                                return i.indexOf(e) === t
                            })).length || 0,
                            n = e.ssrcGroups && e.ssrcGroups.length || 0;
                        if (0 === i || i > 2) return e;
                        if (2 == i && 0 === n) return e;
                        if (1 === i) t = e.ssrcs[0].id;
                        else {
                            var s = e.ssrcGroups.filter((function(e) {
                                return "FID" === e.semantics
                            }))[0];
                            if (!s) return e;
                            t = parseInt(s.ssrcs.split(" ")[0])
                        }
                        return console.log("SdpSimulcast: current ssrc cache: ", this.ssrcCache), console.log("SdpSimulcast: parsed primary ssrc " + t), -1 !== this.ssrcCache.indexOf(t) ? (console.log("SdpSimulcast: Have seen primary ssrc before, filling in data from cache"), e = this._fillInSourceDataFromCache(e)) : (console.log("SdpSimulcast: Have not seen primary ssrc before, generating source data"), e = this._generateSourceData(e, t)), this.ssrcCache = this._parseSimLayers(e), e
                    }, c.prototype.mungeRemoteDescription = function(e, t) {
                        if (!l(e)) return e;
                        var i = n.parse(e.sdp),
                            s = this;
                        return d(i, (function(e) {
                            s.options.explodeRemoteSimulcast ? function(e) {
                                if (e && Array.isArray(e.ssrcGroups))
                                    for (var t = r(e), i = [], n = e.ssrcGroups.length; n--;)
                                        if ("SIM" === e.ssrcGroups[n].semantics) {
                                            for (var s = e.ssrcGroups[n].ssrcs.split(" "), a = 0; a < s.length; a++) {
                                                var c = s[a];
                                                i.push(c);
                                                var d = t[c].msid.split(" ");
                                                t[c].msid = [d[0], "/", a, " ", d[1], "/", a].join(""), t[c].cname = [t[c].cname, "/", a].join(""), e.ssrcGroups.forEach((function(e) {
                                                    if ("SIM" !== e.semantics) {
                                                        var n = e.ssrcs.split(" "); - 1 !== n.indexOf(c) && n.forEach((function(e) {
                                                            t[e].msid = t[c].msid, t[e].cname = t[c].cname, e !== c && i.push(e)
                                                        }))
                                                    }
                                                }))
                                            }
                                            e.ssrcs = o(t, i), e.ssrcGroups.splice(n, 1)
                                        }
                            }(e) : function(e) {
                                if (e && Array.isArray(e.ssrcGroups)) {
                                    var t = r(e);
                                    e.ssrcGroups.forEach((function(i) {
                                        if ("SIM" === i.semantics) {
                                            console.info("Imploding SIM group: " + i.ssrcs), i.nuke = !0;
                                            for (var n = i.ssrcs.split(" "), s = 1; s < n.length; s++) {
                                                var r = n[s];
                                                delete t[r], e.ssrcGroups.forEach((function(e) {
                                                    if ("SIM" !== e.semantics) {
                                                        var i = e.ssrcs.split(" "); - 1 !== i.indexOf(r) && (i.forEach((function(e) {
                                                            delete t[e]
                                                        })), e.nuke = !0)
                                                    }
                                                }))
                                            }
                                        }
                                    })), e.ssrcs = o(t);
                                    for (var i = e.ssrcGroups.length; i--;) e.ssrcGroups[i].nuke && e.ssrcGroups.splice(i, 1)
                                } else console.info("Halt: There are no SSRC groups in the remote description.")
                            }(e), !s.options.usesUnifiedPlan && t ? function(e) {
                                e && (Array.isArray(e.invalid) || (e.invalid = []), e.invalid.some((function(e) {
                                    return "x-google-flag:conference" === e.value
                                })) || e.invalid.push({
                                    value: "x-google-flag:conference"
                                }))
                            }(e) : function(e) {
                                e && void 0 !== e.xGoogleFlag && (e.xGoogleFlag = void 0)
                            }(e)
                        })), new RTCSessionDescription({
                            type: e.type,
                            sdp: n.write(i)
                        })
                    }, c.prototype.mungeLocalDescription = function(e) {
                        if (!l(e)) return e;
                        var t = n.parse(e.sdp),
                            i = this;
                        return d(t, (function(e) {
                            "recvonly" != e.direction && "inactive" != e.direction && i._restoreSimulcast(e)
                        })), new RTCSessionDescription({
                            type: e.type,
                            sdp: n.write(t)
                        })
                    }, e.exports = c
                },
                6298: (e, t) => {
                    t.writeSsrcs = function(e, t) {
                        var i = [];
                        if (void 0 !== e && 0 !== Object.keys(e).length) {
                            Array.isArray(t) || (t = []);
                            for (var n = 0; n < t.length; n++) {
                                var s = t[n],
                                    r = e[s];
                                Object.keys(r).forEach((function(e) {
                                    i.push({
                                        id: s,
                                        attribute: e,
                                        value: r[e]
                                    })
                                }))
                            }
                            Object.keys(e).forEach((function(n) {
                                if (n = parseInt(n), !(t.indexOf(n) >= 0)) {
                                    var s = e[n];
                                    Object.keys(s).forEach((function(e) {
                                        i.push({
                                            id: n,
                                            attribute: e,
                                            value: s[e]
                                        })
                                    }))
                                }
                            }))
                        }
                        return i
                    }, t.parseSsrcs = function(e) {
                        var t = {};
                        return void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach((function(e) {
                            t[e.id] || (t[e.id] = {}), t[e.id][e.attribute] = e.value
                        })), t
                    }
                },
                3577: (e, t) => {
                    "use strict";
                    t.byteLength = function(e) {
                        var t = c(e),
                            i = t[0],
                            n = t[1];
                        return 3 * (i + n) / 4 - n
                    }, t.toByteArray = function(e) {
                        var t, i, r = c(e),
                            o = r[0],
                            a = r[1],
                            d = new s(function(e, t, i) {
                                return 3 * (t + i) / 4 - i
                            }(0, o, a)),
                            l = 0,
                            h = a > 0 ? o - 4 : o;
                        for (i = 0; i < h; i += 4) t = n[e.charCodeAt(i)] << 18 | n[e.charCodeAt(i + 1)] << 12 | n[e.charCodeAt(i + 2)] << 6 | n[e.charCodeAt(i + 3)], d[l++] = t >> 16 & 255, d[l++] = t >> 8 & 255, d[l++] = 255 & t;
                        return 2 === a && (t = n[e.charCodeAt(i)] << 2 | n[e.charCodeAt(i + 1)] >> 4, d[l++] = 255 & t), 1 === a && (t = n[e.charCodeAt(i)] << 10 | n[e.charCodeAt(i + 1)] << 4 | n[e.charCodeAt(i + 2)] >> 2, d[l++] = t >> 8 & 255, d[l++] = 255 & t), d
                    }, t.fromByteArray = function(e) {
                        for (var t, n = e.length, s = n % 3, r = [], o = 16383, a = 0, c = n - s; a < c; a += o) r.push(d(e, a, a + o > c ? c : a + o));
                        return 1 === s ? (t = e[n - 1], r.push(i[t >> 2] + i[t << 4 & 63] + "==")) : 2 === s && (t = (e[n - 2] << 8) + e[n - 1], r.push(i[t >> 10] + i[t >> 4 & 63] + i[t << 2 & 63] + "=")), r.join("")
                    };
                    for (var i = [], n = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, a = r.length; o < a; ++o) i[o] = r[o], n[r.charCodeAt(o)] = o;

                    function c(e) {
                        var t = e.length;
                        if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                        var i = e.indexOf("=");
                        return -1 === i && (i = t), [i, i === t ? 0 : 4 - i % 4]
                    }

                    function d(e, t, n) {
                        for (var s, r, o = [], a = t; a < n; a += 3) s = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), o.push(i[(r = s) >> 18 & 63] + i[r >> 12 & 63] + i[r >> 6 & 63] + i[63 & r]);
                        return o.join("")
                    }
                    n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63
                },
                7032: function(e) {
                    e.exports = function(e) {
                        var t = {};

                        function i(n) {
                            if (t[n]) return t[n].exports;
                            var s = t[n] = {
                                i: n,
                                l: !1,
                                exports: {}
                            };
                            return e[n].call(s.exports, s, s.exports, i), s.l = !0, s.exports
                        }
                        return i.m = e, i.c = t, i.d = function(e, t, n) {
                            i.o(e, t) || Object.defineProperty(e, t, {
                                enumerable: !0,
                                get: n
                            })
                        }, i.r = function(e) {
                            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                                value: "Module"
                            }), Object.defineProperty(e, "__esModule", {
                                value: !0
                            })
                        }, i.t = function(e, t) {
                            if (1 & t && (e = i(e)), 8 & t) return e;
                            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
                            var n = Object.create(null);
                            if (i.r(n), Object.defineProperty(n, "default", {
                                    enumerable: !0,
                                    value: e
                                }), 2 & t && "string" != typeof e)
                                for (var s in e) i.d(n, s, function(t) {
                                    return e[t]
                                }.bind(null, s));
                            return n
                        }, i.n = function(e) {
                            var t = e && e.__esModule ? function() {
                                return e.default
                            } : function() {
                                return e
                            };
                            return i.d(t, "a", t), t
                        }, i.o = function(e, t) {
                            return Object.prototype.hasOwnProperty.call(e, t)
                        }, i.p = "", i(i.s = 90)
                    }({
                        17: function(e, t, i) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var n = i(18),
                                s = function() {
                                    function e() {}
                                    return e.getFirstMatch = function(e, t) {
                                        var i = t.match(e);
                                        return i && i.length > 0 && i[1] || ""
                                    }, e.getSecondMatch = function(e, t) {
                                        var i = t.match(e);
                                        return i && i.length > 1 && i[2] || ""
                                    }, e.matchAndReturnConst = function(e, t, i) {
                                        if (e.test(t)) return i
                                    }, e.getWindowsVersionName = function(e) {
                                        switch (e) {
                                            case "NT":
                                                return "NT";
                                            case "XP":
                                            case "NT 5.1":
                                                return "XP";
                                            case "NT 5.0":
                                                return "2000";
                                            case "NT 5.2":
                                                return "2003";
                                            case "NT 6.0":
                                                return "Vista";
                                            case "NT 6.1":
                                                return "7";
                                            case "NT 6.2":
                                                return "8";
                                            case "NT 6.3":
                                                return "8.1";
                                            case "NT 10.0":
                                                return "10";
                                            default:
                                                return
                                        }
                                    }, e.getMacOSVersionName = function(e) {
                                        var t = e.split(".").splice(0, 2).map((function(e) {
                                            return parseInt(e, 10) || 0
                                        }));
                                        if (t.push(0), 10 === t[0]) switch (t[1]) {
                                            case 5:
                                                return "Leopard";
                                            case 6:
                                                return "Snow Leopard";
                                            case 7:
                                                return "Lion";
                                            case 8:
                                                return "Mountain Lion";
                                            case 9:
                                                return "Mavericks";
                                            case 10:
                                                return "Yosemite";
                                            case 11:
                                                return "El Capitan";
                                            case 12:
                                                return "Sierra";
                                            case 13:
                                                return "High Sierra";
                                            case 14:
                                                return "Mojave";
                                            case 15:
                                                return "Catalina";
                                            default:
                                                return
                                        }
                                    }, e.getAndroidVersionName = function(e) {
                                        var t = e.split(".").splice(0, 2).map((function(e) {
                                            return parseInt(e, 10) || 0
                                        }));
                                        if (t.push(0), !(1 === t[0] && t[1] < 5)) return 1 === t[0] && t[1] < 6 ? "Cupcake" : 1 === t[0] && t[1] >= 6 ? "Donut" : 2 === t[0] && t[1] < 2 ? "Eclair" : 2 === t[0] && 2 === t[1] ? "Froyo" : 2 === t[0] && t[1] > 2 ? "Gingerbread" : 3 === t[0] ? "Honeycomb" : 4 === t[0] && t[1] < 1 ? "Ice Cream Sandwich" : 4 === t[0] && t[1] < 4 ? "Jelly Bean" : 4 === t[0] && t[1] >= 4 ? "KitKat" : 5 === t[0] ? "Lollipop" : 6 === t[0] ? "Marshmallow" : 7 === t[0] ? "Nougat" : 8 === t[0] ? "Oreo" : 9 === t[0] ? "Pie" : void 0
                                    }, e.getVersionPrecision = function(e) {
                                        return e.split(".").length
                                    }, e.compareVersions = function(t, i, n) {
                                        void 0 === n && (n = !1);
                                        var s = e.getVersionPrecision(t),
                                            r = e.getVersionPrecision(i),
                                            o = Math.max(s, r),
                                            a = 0,
                                            c = e.map([t, i], (function(t) {
                                                var i = o - e.getVersionPrecision(t),
                                                    n = t + new Array(i + 1).join(".0");
                                                return e.map(n.split("."), (function(e) {
                                                    return new Array(20 - e.length).join("0") + e
                                                })).reverse()
                                            }));
                                        for (n && (a = o - Math.min(s, r)), o -= 1; o >= a;) {
                                            if (c[0][o] > c[1][o]) return 1;
                                            if (c[0][o] === c[1][o]) {
                                                if (o === a) return 0;
                                                o -= 1
                                            } else if (c[0][o] < c[1][o]) return -1
                                        }
                                    }, e.map = function(e, t) {
                                        var i, n = [];
                                        if (Array.prototype.map) return Array.prototype.map.call(e, t);
                                        for (i = 0; i < e.length; i += 1) n.push(t(e[i]));
                                        return n
                                    }, e.getBrowserAlias = function(e) {
                                        return n.BROWSER_ALIASES_MAP[e]
                                    }, e.getBrowserTypeByAlias = function(e) {
                                        return n.BROWSER_MAP[e] || ""
                                    }, e
                                }();
                            t.default = s, e.exports = t.default
                        },
                        18: function(e, t, i) {
                            "use strict";
                            t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0, t.BROWSER_ALIASES_MAP = {
                                "Amazon Silk": "amazon_silk",
                                "Android Browser": "android",
                                Bada: "bada",
                                BlackBerry: "blackberry",
                                Chrome: "chrome",
                                Chromium: "chromium",
                                Epiphany: "epiphany",
                                Firefox: "firefox",
                                Focus: "focus",
                                Generic: "generic",
                                "Google Search": "google_search",
                                Googlebot: "googlebot",
                                "Internet Explorer": "ie",
                                "K-Meleon": "k_meleon",
                                Maxthon: "maxthon",
                                "Microsoft Edge": "edge",
                                "MZ Browser": "mz",
                                "NAVER Whale Browser": "naver",
                                Opera: "opera",
                                "Opera Coast": "opera_coast",
                                PhantomJS: "phantomjs",
                                Puffin: "puffin",
                                QupZilla: "qupzilla",
                                QQ: "qq",
                                QQLite: "qqlite",
                                Safari: "safari",
                                Sailfish: "sailfish",
                                "Samsung Internet for Android": "samsung_internet",
                                SeaMonkey: "seamonkey",
                                Sleipnir: "sleipnir",
                                Swing: "swing",
                                Tizen: "tizen",
                                "UC Browser": "uc",
                                Vivaldi: "vivaldi",
                                "WebOS Browser": "webos",
                                WeChat: "wechat",
                                "Yandex Browser": "yandex",
                                Roku: "roku"
                            }, t.BROWSER_MAP = {
                                amazon_silk: "Amazon Silk",
                                android: "Android Browser",
                                bada: "Bada",
                                blackberry: "BlackBerry",
                                chrome: "Chrome",
                                chromium: "Chromium",
                                epiphany: "Epiphany",
                                firefox: "Firefox",
                                focus: "Focus",
                                generic: "Generic",
                                googlebot: "Googlebot",
                                google_search: "Google Search",
                                ie: "Internet Explorer",
                                k_meleon: "K-Meleon",
                                maxthon: "Maxthon",
                                edge: "Microsoft Edge",
                                mz: "MZ Browser",
                                naver: "NAVER Whale Browser",
                                opera: "Opera",
                                opera_coast: "Opera Coast",
                                phantomjs: "PhantomJS",
                                puffin: "Puffin",
                                qupzilla: "QupZilla",
                                qq: "QQ Browser",
                                qqlite: "QQ Browser Lite",
                                safari: "Safari",
                                sailfish: "Sailfish",
                                samsung_internet: "Samsung Internet for Android",
                                seamonkey: "SeaMonkey",
                                sleipnir: "Sleipnir",
                                swing: "Swing",
                                tizen: "Tizen",
                                uc: "UC Browser",
                                vivaldi: "Vivaldi",
                                webos: "WebOS Browser",
                                wechat: "WeChat",
                                yandex: "Yandex Browser"
                            }, t.PLATFORMS_MAP = {
                                tablet: "tablet",
                                mobile: "mobile",
                                desktop: "desktop",
                                tv: "tv"
                            }, t.OS_MAP = {
                                WindowsPhone: "Windows Phone",
                                Windows: "Windows",
                                MacOS: "macOS",
                                iOS: "iOS",
                                Android: "Android",
                                WebOS: "WebOS",
                                BlackBerry: "BlackBerry",
                                Bada: "Bada",
                                Tizen: "Tizen",
                                Linux: "Linux",
                                ChromeOS: "Chrome OS",
                                PlayStation4: "PlayStation 4",
                                Roku: "Roku"
                            }, t.ENGINE_MAP = {
                                EdgeHTML: "EdgeHTML",
                                Blink: "Blink",
                                Trident: "Trident",
                                Presto: "Presto",
                                Gecko: "Gecko",
                                WebKit: "WebKit"
                            }
                        },
                        90: function(e, t, i) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var n, s = (n = i(91)) && n.__esModule ? n : {
                                    default: n
                                },
                                r = i(18);

                            function o(e, t) {
                                for (var i = 0; i < t.length; i++) {
                                    var n = t[i];
                                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
                                }
                            }
                            var a = function() {
                                function e() {}
                                var t, i;
                                return e.getParser = function(e, t) {
                                    if (void 0 === t && (t = !1), "string" != typeof e) throw new Error("UserAgent should be a string");
                                    return new s.default(e, t)
                                }, e.parse = function(e) {
                                    return new s.default(e).getResult()
                                }, t = e, i = [{
                                    key: "BROWSER_MAP",
                                    get: function() {
                                        return r.BROWSER_MAP
                                    }
                                }, {
                                    key: "ENGINE_MAP",
                                    get: function() {
                                        return r.ENGINE_MAP
                                    }
                                }, {
                                    key: "OS_MAP",
                                    get: function() {
                                        return r.OS_MAP
                                    }
                                }, {
                                    key: "PLATFORMS_MAP",
                                    get: function() {
                                        return r.PLATFORMS_MAP
                                    }
                                }], null && o(t.prototype, null), i && o(t, i), e
                            }();
                            t.default = a, e.exports = t.default
                        },
                        91: function(e, t, i) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var n = c(i(92)),
                                s = c(i(93)),
                                r = c(i(94)),
                                o = c(i(95)),
                                a = c(i(17));

                            function c(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                }
                            }
                            var d = function() {
                                function e(e, t) {
                                    if (void 0 === t && (t = !1), null == e || "" === e) throw new Error("UserAgent parameter can't be empty");
                                    this._ua = e, this.parsedResult = {}, !0 !== t && this.parse()
                                }
                                var t = e.prototype;
                                return t.getUA = function() {
                                    return this._ua
                                }, t.test = function(e) {
                                    return e.test(this._ua)
                                }, t.parseBrowser = function() {
                                    var e = this;
                                    this.parsedResult.browser = {};
                                    var t = n.default.find((function(t) {
                                        if ("function" == typeof t.test) return t.test(e);
                                        if (t.test instanceof Array) return t.test.some((function(t) {
                                            return e.test(t)
                                        }));
                                        throw new Error("Browser's test function is not valid")
                                    }));
                                    return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser
                                }, t.getBrowser = function() {
                                    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser()
                                }, t.getBrowserName = function(e) {
                                    return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || ""
                                }, t.getBrowserVersion = function() {
                                    return this.getBrowser().version
                                }, t.getOS = function() {
                                    return this.parsedResult.os ? this.parsedResult.os : this.parseOS()
                                }, t.parseOS = function() {
                                    var e = this;
                                    this.parsedResult.os = {};
                                    var t = s.default.find((function(t) {
                                        if ("function" == typeof t.test) return t.test(e);
                                        if (t.test instanceof Array) return t.test.some((function(t) {
                                            return e.test(t)
                                        }));
                                        throw new Error("Browser's test function is not valid")
                                    }));
                                    return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os
                                }, t.getOSName = function(e) {
                                    var t = this.getOS().name;
                                    return e ? String(t).toLowerCase() || "" : t || ""
                                }, t.getOSVersion = function() {
                                    return this.getOS().version
                                }, t.getPlatform = function() {
                                    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform()
                                }, t.getPlatformType = function(e) {
                                    void 0 === e && (e = !1);
                                    var t = this.getPlatform().type;
                                    return e ? String(t).toLowerCase() || "" : t || ""
                                }, t.parsePlatform = function() {
                                    var e = this;
                                    this.parsedResult.platform = {};
                                    var t = r.default.find((function(t) {
                                        if ("function" == typeof t.test) return t.test(e);
                                        if (t.test instanceof Array) return t.test.some((function(t) {
                                            return e.test(t)
                                        }));
                                        throw new Error("Browser's test function is not valid")
                                    }));
                                    return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform
                                }, t.getEngine = function() {
                                    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine()
                                }, t.getEngineName = function(e) {
                                    return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || ""
                                }, t.parseEngine = function() {
                                    var e = this;
                                    this.parsedResult.engine = {};
                                    var t = o.default.find((function(t) {
                                        if ("function" == typeof t.test) return t.test(e);
                                        if (t.test instanceof Array) return t.test.some((function(t) {
                                            return e.test(t)
                                        }));
                                        throw new Error("Browser's test function is not valid")
                                    }));
                                    return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine
                                }, t.parse = function() {
                                    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this
                                }, t.getResult = function() {
                                    return Object.assign({}, this.parsedResult)
                                }, t.satisfies = function(e) {
                                    var t = this,
                                        i = {},
                                        n = 0,
                                        s = {},
                                        r = 0;
                                    if (Object.keys(e).forEach((function(t) {
                                            var o = e[t];
                                            "string" == typeof o ? (s[t] = o, r += 1) : "object" == typeof o && (i[t] = o, n += 1)
                                        })), n > 0) {
                                        var o = Object.keys(i),
                                            a = o.find((function(e) {
                                                return t.isOS(e)
                                            }));
                                        if (a) {
                                            var c = this.satisfies(i[a]);
                                            if (void 0 !== c) return c
                                        }
                                        var d = o.find((function(e) {
                                            return t.isPlatform(e)
                                        }));
                                        if (d) {
                                            var l = this.satisfies(i[d]);
                                            if (void 0 !== l) return l
                                        }
                                    }
                                    if (r > 0) {
                                        var h = Object.keys(s).find((function(e) {
                                            return t.isBrowser(e, !0)
                                        }));
                                        if (void 0 !== h) return this.compareVersion(s[h])
                                    }
                                }, t.isBrowser = function(e, t) {
                                    void 0 === t && (t = !1);
                                    var i = this.getBrowserName().toLowerCase(),
                                        n = e.toLowerCase(),
                                        s = a.default.getBrowserTypeByAlias(n);
                                    return t && s && (n = s.toLowerCase()), n === i
                                }, t.compareVersion = function(e) {
                                    var t = [0],
                                        i = e,
                                        n = !1,
                                        s = this.getBrowserVersion();
                                    if ("string" == typeof s) return ">" === e[0] || "<" === e[0] ? (i = e.substr(1), "=" === e[1] ? (n = !0, i = e.substr(2)) : t = [], ">" === e[0] ? t.push(1) : t.push(-1)) : "=" === e[0] ? i = e.substr(1) : "~" === e[0] && (n = !0, i = e.substr(1)), t.indexOf(a.default.compareVersions(s, i, n)) > -1
                                }, t.isOS = function(e) {
                                    return this.getOSName(!0) === String(e).toLowerCase()
                                }, t.isPlatform = function(e) {
                                    return this.getPlatformType(!0) === String(e).toLowerCase()
                                }, t.isEngine = function(e) {
                                    return this.getEngineName(!0) === String(e).toLowerCase()
                                }, t.is = function(e) {
                                    return this.isBrowser(e) || this.isOS(e) || this.isPlatform(e)
                                }, t.some = function(e) {
                                    var t = this;
                                    return void 0 === e && (e = []), e.some((function(e) {
                                        return t.is(e)
                                    }))
                                }, e
                            }();
                            t.default = d, e.exports = t.default
                        },
                        92: function(e, t, i) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var n, s = (n = i(17)) && n.__esModule ? n : {
                                    default: n
                                },
                                r = /version\/(\d+(\.?_?\d+)+)/i,
                                o = [{
                                    test: [/googlebot/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Googlebot"
                                            },
                                            i = s.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/opera/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Opera"
                                            },
                                            i = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/opr\/|opios/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Opera"
                                            },
                                            i = s.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/SamsungBrowser/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Samsung Internet for Android"
                                            },
                                            i = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/Whale/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "NAVER Whale Browser"
                                            },
                                            i = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/MZBrowser/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "MZ Browser"
                                            },
                                            i = s.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/focus/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Focus"
                                            },
                                            i = s.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/swing/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Swing"
                                            },
                                            i = s.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/coast/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Opera Coast"
                                            },
                                            i = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/yabrowser/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Yandex Browser"
                                            },
                                            i = s.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/ucbrowser/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "UC Browser"
                                            },
                                            i = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/Maxthon|mxios/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Maxthon"
                                            },
                                            i = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/epiphany/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Epiphany"
                                            },
                                            i = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/puffin/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Puffin"
                                            },
                                            i = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/sleipnir/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Sleipnir"
                                            },
                                            i = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/k-meleon/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "K-Meleon"
                                            },
                                            i = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/micromessenger/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "WeChat"
                                            },
                                            i = s.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/qqbrowser/i],
                                    describe: function(e) {
                                        var t = {
                                                name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
                                            },
                                            i = s.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/msie|trident/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Internet Explorer"
                                            },
                                            i = s.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/\sedg\//i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Microsoft Edge"
                                            },
                                            i = s.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/edg([ea]|ios)/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Microsoft Edge"
                                            },
                                            i = s.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/vivaldi/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Vivaldi"
                                            },
                                            i = s.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/seamonkey/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "SeaMonkey"
                                            },
                                            i = s.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/sailfish/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Sailfish"
                                            },
                                            i = s.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/silk/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Amazon Silk"
                                            },
                                            i = s.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/phantom/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "PhantomJS"
                                            },
                                            i = s.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/slimerjs/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "SlimerJS"
                                            },
                                            i = s.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "BlackBerry"
                                            },
                                            i = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/(web|hpw)[o0]s/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "WebOS Browser"
                                            },
                                            i = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/bada/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Bada"
                                            },
                                            i = s.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/tizen/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Tizen"
                                            },
                                            i = s.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/qupzilla/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "QupZilla"
                                            },
                                            i = s.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/firefox|iceweasel|fxios/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Firefox"
                                            },
                                            i = s.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/chromium/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Chromium"
                                            },
                                            i = s.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/chrome|crios|crmo/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Chrome"
                                            },
                                            i = s.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/GSA/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Google Search"
                                            },
                                            i = s.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: function(e) {
                                        var t = !e.test(/like android/i),
                                            i = e.test(/android/i);
                                        return t && i
                                    },
                                    describe: function(e) {
                                        var t = {
                                                name: "Android Browser"
                                            },
                                            i = s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/playstation 4/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "PlayStation 4"
                                            },
                                            i = s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/safari|applewebkit/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Safari"
                                            },
                                            i = s.default.getFirstMatch(r, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/.*/i],
                                    describe: function(e) {
                                        var t = -1 !== e.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
                                        return {
                                            name: s.default.getFirstMatch(t, e),
                                            version: s.default.getSecondMatch(t, e)
                                        }
                                    }
                                }];
                            t.default = o, e.exports = t.default
                        },
                        93: function(e, t, i) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var n, s = (n = i(17)) && n.__esModule ? n : {
                                    default: n
                                },
                                r = i(18),
                                o = [{
                                    test: [/Roku\/DVP/],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
                                        return {
                                            name: r.OS_MAP.Roku,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: [/windows phone/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
                                        return {
                                            name: r.OS_MAP.WindowsPhone,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: [/windows/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e),
                                            i = s.default.getWindowsVersionName(t);
                                        return {
                                            name: r.OS_MAP.Windows,
                                            version: t,
                                            versionName: i
                                        }
                                    }
                                }, {
                                    test: [/macintosh/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."),
                                            i = s.default.getMacOSVersionName(t),
                                            n = {
                                                name: r.OS_MAP.MacOS,
                                                version: t
                                            };
                                        return i && (n.versionName = i), n
                                    }
                                }, {
                                    test: [/(ipod|iphone|ipad)/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
                                        return {
                                            name: r.OS_MAP.iOS,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        var t = !e.test(/like android/i),
                                            i = e.test(/android/i);
                                        return t && i
                                    },
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e),
                                            i = s.default.getAndroidVersionName(t),
                                            n = {
                                                name: r.OS_MAP.Android,
                                                version: t
                                            };
                                        return i && (n.versionName = i), n
                                    }
                                }, {
                                    test: [/(web|hpw)[o0]s/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e),
                                            i = {
                                                name: r.OS_MAP.WebOS
                                            };
                                        return t && t.length && (i.version = t), i
                                    }
                                }, {
                                    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || s.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || s.default.getFirstMatch(/\bbb(\d+)/i, e);
                                        return {
                                            name: r.OS_MAP.BlackBerry,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: [/bada/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
                                        return {
                                            name: r.OS_MAP.Bada,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: [/tizen/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
                                        return {
                                            name: r.OS_MAP.Tizen,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: [/linux/i],
                                    describe: function() {
                                        return {
                                            name: r.OS_MAP.Linux
                                        }
                                    }
                                }, {
                                    test: [/CrOS/],
                                    describe: function() {
                                        return {
                                            name: r.OS_MAP.ChromeOS
                                        }
                                    }
                                }, {
                                    test: [/PlayStation 4/],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
                                        return {
                                            name: r.OS_MAP.PlayStation4,
                                            version: t
                                        }
                                    }
                                }];
                            t.default = o, e.exports = t.default
                        },
                        94: function(e, t, i) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var n, s = (n = i(17)) && n.__esModule ? n : {
                                    default: n
                                },
                                r = i(18),
                                o = [{
                                    test: [/googlebot/i],
                                    describe: function() {
                                        return {
                                            type: "bot",
                                            vendor: "Google"
                                        }
                                    }
                                }, {
                                    test: [/huawei/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/(can-l01)/i, e) && "Nova",
                                            i = {
                                                type: r.PLATFORMS_MAP.mobile,
                                                vendor: "Huawei"
                                            };
                                        return t && (i.model = t), i
                                    }
                                }, {
                                    test: [/nexus\s*(?:7|8|9|10).*/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tablet,
                                            vendor: "Nexus"
                                        }
                                    }
                                }, {
                                    test: [/ipad/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tablet,
                                            vendor: "Apple",
                                            model: "iPad"
                                        }
                                    }
                                }, {
                                    test: [/kftt build/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tablet,
                                            vendor: "Amazon",
                                            model: "Kindle Fire HD 7"
                                        }
                                    }
                                }, {
                                    test: [/silk/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tablet,
                                            vendor: "Amazon"
                                        }
                                    }
                                }, {
                                    test: [/tablet(?! pc)/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tablet
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        var t = e.test(/ipod|iphone/i),
                                            i = e.test(/like (ipod|iphone)/i);
                                        return t && !i
                                    },
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/(ipod|iphone)/i, e);
                                        return {
                                            type: r.PLATFORMS_MAP.mobile,
                                            vendor: "Apple",
                                            model: t
                                        }
                                    }
                                }, {
                                    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.mobile,
                                            vendor: "Nexus"
                                        }
                                    }
                                }, {
                                    test: [/[^-]mobi/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.mobile
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "blackberry" === e.getBrowserName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.mobile,
                                            vendor: "BlackBerry"
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "bada" === e.getBrowserName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.mobile
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "windows phone" === e.getBrowserName()
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.mobile,
                                            vendor: "Microsoft"
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        var t = Number(String(e.getOSVersion()).split(".")[0]);
                                        return "android" === e.getOSName(!0) && t >= 3
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tablet
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "android" === e.getOSName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.mobile
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "macos" === e.getOSName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.desktop,
                                            vendor: "Apple"
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "windows" === e.getOSName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.desktop
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "linux" === e.getOSName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.desktop
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "playstation 4" === e.getOSName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tv
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "roku" === e.getOSName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tv
                                        }
                                    }
                                }];
                            t.default = o, e.exports = t.default
                        },
                        95: function(e, t, i) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var n, s = (n = i(17)) && n.__esModule ? n : {
                                    default: n
                                },
                                r = i(18),
                                o = [{
                                    test: function(e) {
                                        return "microsoft edge" === e.getBrowserName(!0)
                                    },
                                    describe: function(e) {
                                        if (/\sedg\//i.test(e)) return {
                                            name: r.ENGINE_MAP.Blink
                                        };
                                        var t = s.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
                                        return {
                                            name: r.ENGINE_MAP.EdgeHTML,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: [/trident/i],
                                    describe: function(e) {
                                        var t = {
                                                name: r.ENGINE_MAP.Trident
                                            },
                                            i = s.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: function(e) {
                                        return e.test(/presto/i)
                                    },
                                    describe: function(e) {
                                        var t = {
                                                name: r.ENGINE_MAP.Presto
                                            },
                                            i = s.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: function(e) {
                                        var t = e.test(/gecko/i),
                                            i = e.test(/like gecko/i);
                                        return t && !i
                                    },
                                    describe: function(e) {
                                        var t = {
                                                name: r.ENGINE_MAP.Gecko
                                            },
                                            i = s.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }, {
                                    test: [/(apple)?webkit\/537\.36/i],
                                    describe: function() {
                                        return {
                                            name: r.ENGINE_MAP.Blink
                                        }
                                    }
                                }, {
                                    test: [/(apple)?webkit/i],
                                    describe: function(e) {
                                        var t = {
                                                name: r.ENGINE_MAP.WebKit
                                            },
                                            i = s.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
                                        return i && (t.version = i), t
                                    }
                                }];
                            t.default = o, e.exports = t.default
                        }
                    })
                },
                6799: function(e, t) {
                    var i, n;
                    this || window, void 0 === (n = "function" == typeof(i = function() {
                        var e = /^(interactive|loaded|complete)$/,
                            t = window.location ? window.location.href : null,
                            i = t && t.replace(/#.*$/, "").replace(/\?.*$/, "") || null,
                            n = document.getElementsByTagName("script"),
                            s = "readyState" in (n[0] || document.createElement("script")),
                            r = !window.opera || "[object Opera]" !== window.opera.toString(),
                            o = "currentScript" in document;
                        "stackTraceLimit" in Error && Error.stackTraceLimit !== 1 / 0 && (Error.stackTraceLimit, Error.stackTraceLimit = 1 / 0);
                        var a = !1,
                            c = !1;

                        function d(e, t) {
                            var i, n = null,
                                s = "number" == typeof t;
                            return t = s ? Math.round(t) : 0, "string" == typeof e && e && (s ? i = e.match(/(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/) : (i = e.match(/^(?:|[^:@]*@|.+\)@(?=data:text\/javascript|blob|http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)) && i[1] || (i = e.match(/\)@(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)), i && i[1] && (n = t > 0 ? d(e.slice(e.indexOf(i[0]) + i[0].length), t - 1) : i[1])), n
                        }

                        function l() {
                            if (0 === n.length) return null;
                            var t, h, u, p, m, f = [],
                                g = l.skipStackDepth || 1;
                            for (t = 0; t < n.length; t++) r && s ? e.test(n[t].readyState) && f.push(n[t]) : f.push(n[t]);
                            if (h = new Error, a && (u = h.stack), !u && c) try {
                                throw h
                            } catch (e) {
                                u = e.stack
                            }
                            if (u && !(m = function(e, t) {
                                    var i, s = null;
                                    if (t = t || n, "string" == typeof e && e)
                                        for (i = t.length; i--;)
                                            if (t[i].src === e) {
                                                s = t[i];
                                                break
                                            } return s
                                }(p = d(u, g), f)) && i && p === i && (m = function(e) {
                                    var t, i, s = null;
                                    for (t = 0, i = (e = e || n).length; t < i; t++)
                                        if (!e[t].hasAttribute("src")) {
                                            if (s) {
                                                s = null;
                                                break
                                            }
                                            s = e[t]
                                        } return s
                                }(f)), m || 1 === f.length && (m = f[0]), m || o && (m = document.currentScript), !m && r && s)
                                for (t = f.length; t--;)
                                    if ("interactive" === f[t].readyState) {
                                        m = f[t];
                                        break
                                    } return m || (m = f[f.length - 1] || null), m
                        }(function() {
                            try {
                                var e = new Error;
                                throw a = "string" == typeof e.stack && !!e.stack, e
                            } catch (e) {
                                c = "string" == typeof e.stack && !!e.stack
                            }
                        })(), l.skipStackDepth = 1;
                        var h = l;
                        return h.near = l, h.far = function() {
                            return null
                        }, h.origin = function() {
                            return null
                        }, h
                    }) ? i.apply(t, []) : i) || (e.exports = n)
                },
                6857: e => {
                    "use strict";
                    var t, i = "object" == typeof Reflect ? Reflect : null,
                        n = i && "function" == typeof i.apply ? i.apply : function(e, t, i) {
                            return Function.prototype.apply.call(e, t, i)
                        };
                    t = i && "function" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function(e) {
                        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
                    } : function(e) {
                        return Object.getOwnPropertyNames(e)
                    };
                    var s = Number.isNaN || function(e) {
                        return e != e
                    };

                    function r() {
                        r.init.call(this)
                    }
                    e.exports = r, e.exports.once = function(e, t) {
                        return new Promise((function(i, n) {
                            function s(i) {
                                e.removeListener(t, r), n(i)
                            }

                            function r() {
                                "function" == typeof e.removeListener && e.removeListener("error", s), i([].slice.call(arguments))
                            }
                            f(e, t, r, {
                                once: !0
                            }), "error" !== t && function(e, t, i) {
                                "function" == typeof e.on && f(e, "error", t, {
                                    once: !0
                                })
                            }(e, s)
                        }))
                    }, r.EventEmitter = r, r.prototype._events = void 0, r.prototype._eventsCount = 0, r.prototype._maxListeners = void 0;
                    var o = 10;

                    function a(e) {
                        if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
                    }

                    function c(e) {
                        return void 0 === e._maxListeners ? r.defaultMaxListeners : e._maxListeners
                    }

                    function d(e, t, i, n) {
                        var s, r, o, d;
                        if (a(i), void 0 === (r = e._events) ? (r = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== r.newListener && (e.emit("newListener", t, i.listener ? i.listener : i), r = e._events), o = r[t]), void 0 === o) o = r[t] = i, ++e._eventsCount;
                        else if ("function" == typeof o ? o = r[t] = n ? [i, o] : [o, i] : n ? o.unshift(i) : o.push(i), (s = c(e)) > 0 && o.length > s && !o.warned) {
                            o.warned = !0;
                            var l = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                            l.name = "MaxListenersExceededWarning", l.emitter = e, l.type = t, l.count = o.length, d = l, console && console.warn && console.warn(d)
                        }
                        return e
                    }

                    function l() {
                        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
                    }

                    function h(e, t, i) {
                        var n = {
                                fired: !1,
                                wrapFn: void 0,
                                target: e,
                                type: t,
                                listener: i
                            },
                            s = l.bind(n);
                        return s.listener = i, n.wrapFn = s, s
                    }

                    function u(e, t, i) {
                        var n = e._events;
                        if (void 0 === n) return [];
                        var s = n[t];
                        return void 0 === s ? [] : "function" == typeof s ? i ? [s.listener || s] : [s] : i ? function(e) {
                            for (var t = new Array(e.length), i = 0; i < t.length; ++i) t[i] = e[i].listener || e[i];
                            return t
                        }(s) : m(s, s.length)
                    }

                    function p(e) {
                        var t = this._events;
                        if (void 0 !== t) {
                            var i = t[e];
                            if ("function" == typeof i) return 1;
                            if (void 0 !== i) return i.length
                        }
                        return 0
                    }

                    function m(e, t) {
                        for (var i = new Array(t), n = 0; n < t; ++n) i[n] = e[n];
                        return i
                    }

                    function f(e, t, i, n) {
                        if ("function" == typeof e.on) n.once ? e.once(t, i) : e.on(t, i);
                        else {
                            if ("function" != typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
                            e.addEventListener(t, (function s(r) {
                                n.once && e.removeEventListener(t, s), i(r)
                            }))
                        }
                    }
                    Object.defineProperty(r, "defaultMaxListeners", {
                        enumerable: !0,
                        get: function() {
                            return o
                        },
                        set: function(e) {
                            if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
                            o = e
                        }
                    }), r.init = function() {
                        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
                    }, r.prototype.setMaxListeners = function(e) {
                        if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
                        return this._maxListeners = e, this
                    }, r.prototype.getMaxListeners = function() {
                        return c(this)
                    }, r.prototype.emit = function(e) {
                        for (var t = [], i = 1; i < arguments.length; i++) t.push(arguments[i]);
                        var s = "error" === e,
                            r = this._events;
                        if (void 0 !== r) s = s && void 0 === r.error;
                        else if (!s) return !1;
                        if (s) {
                            var o;
                            if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
                            var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
                            throw a.context = o, a
                        }
                        var c = r[e];
                        if (void 0 === c) return !1;
                        if ("function" == typeof c) n(c, this, t);
                        else {
                            var d = c.length,
                                l = m(c, d);
                            for (i = 0; i < d; ++i) n(l[i], this, t)
                        }
                        return !0
                    }, r.prototype.addListener = function(e, t) {
                        return d(this, e, t, !1)
                    }, r.prototype.on = r.prototype.addListener, r.prototype.prependListener = function(e, t) {
                        return d(this, e, t, !0)
                    }, r.prototype.once = function(e, t) {
                        return a(t), this.on(e, h(this, e, t)), this
                    }, r.prototype.prependOnceListener = function(e, t) {
                        return a(t), this.prependListener(e, h(this, e, t)), this
                    }, r.prototype.removeListener = function(e, t) {
                        var i, n, s, r, o;
                        if (a(t), void 0 === (n = this._events)) return this;
                        if (void 0 === (i = n[e])) return this;
                        if (i === t || i.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, i.listener || t));
                        else if ("function" != typeof i) {
                            for (s = -1, r = i.length - 1; r >= 0; r--)
                                if (i[r] === t || i[r].listener === t) {
                                    o = i[r].listener, s = r;
                                    break
                                } if (s < 0) return this;
                            0 === s ? i.shift() : function(e, t) {
                                for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                                e.pop()
                            }(i, s), 1 === i.length && (n[e] = i[0]), void 0 !== n.removeListener && this.emit("removeListener", e, o || t)
                        }
                        return this
                    }, r.prototype.off = r.prototype.removeListener, r.prototype.removeAllListeners = function(e) {
                        var t, i, n;
                        if (void 0 === (i = this._events)) return this;
                        if (void 0 === i.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== i[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete i[e]), this;
                        if (0 === arguments.length) {
                            var s, r = Object.keys(i);
                            for (n = 0; n < r.length; ++n) "removeListener" !== (s = r[n]) && this.removeAllListeners(s);
                            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
                        }
                        if ("function" == typeof(t = i[e])) this.removeListener(e, t);
                        else if (void 0 !== t)
                            for (n = t.length - 1; n >= 0; n--) this.removeListener(e, t[n]);
                        return this
                    }, r.prototype.listeners = function(e) {
                        return u(this, e, !0)
                    }, r.prototype.rawListeners = function(e) {
                        return u(this, e, !1)
                    }, r.listenerCount = function(e, t) {
                        return "function" == typeof e.listenerCount ? e.listenerCount(t) : p.call(e, t)
                    }, r.prototype.listenerCount = p, r.prototype.eventNames = function() {
                        return this._eventsCount > 0 ? t(this._events) : []
                    }
                },
                3478: (module, exports, __webpack_require__) => {
                    var __WEBPACK_AMD_DEFINE_RESULT__;
                    (function() {
                        "use strict";
                        var ERROR = "input is invalid type",
                            WINDOW = "object" == typeof window,
                            root = WINDOW ? window : {};
                        root.JS_MD5_NO_WINDOW && (WINDOW = !1);
                        var WEB_WORKER = !WINDOW && "object" == typeof self,
                            NODE_JS = !root.JS_MD5_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node;
                        NODE_JS ? root = __webpack_require__.g : WEB_WORKER && (root = self);
                        var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && module.exports,
                            AMD = __webpack_require__.amdO,
                            ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer,
                            HEX_CHARS = "0123456789abcdef".split(""),
                            EXTRA = [128, 32768, 8388608, -2147483648],
                            SHIFT = [0, 8, 16, 24],
                            OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"],
                            BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),
                            blocks = [],
                            buffer8;
                        if (ARRAY_BUFFER) {
                            var buffer = new ArrayBuffer(68);
                            buffer8 = new Uint8Array(buffer), blocks = new Uint32Array(buffer)
                        }!root.JS_MD5_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
                            return "[object Array]" === Object.prototype.toString.call(e)
                        }), !ARRAY_BUFFER || !root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
                            return "object" == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
                        });
                        var createOutputMethod = function(e) {
                                return function(t) {
                                    return new Md5(!0).update(t)[e]()
                                }
                            },
                            createMethod = function() {
                                var e = createOutputMethod("hex");
                                NODE_JS && (e = nodeWrap(e)), e.create = function() {
                                    return new Md5
                                }, e.update = function(t) {
                                    return e.create().update(t)
                                };
                                for (var t = 0; t < OUTPUT_TYPES.length; ++t) {
                                    var i = OUTPUT_TYPES[t];
                                    e[i] = createOutputMethod(i)
                                }
                                return e
                            },
                            nodeWrap = function(method) {
                                var crypto = eval("require('crypto')"),
                                    Buffer = eval("require('buffer').Buffer"),
                                    nodeMethod = function(e) {
                                        if ("string" == typeof e) return crypto.createHash("md5").update(e, "utf8").digest("hex");
                                        if (null == e) throw ERROR;
                                        return e.constructor === ArrayBuffer && (e = new Uint8Array(e)), Array.isArray(e) || ArrayBuffer.isView(e) || e.constructor === Buffer ? crypto.createHash("md5").update(new Buffer(e)).digest("hex") : method(e)
                                    };
                                return nodeMethod
                            };

                        function Md5(e) {
                            if (e) blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks, this.buffer8 = buffer8;
                            else if (ARRAY_BUFFER) {
                                var t = new ArrayBuffer(68);
                                this.buffer8 = new Uint8Array(t), this.blocks = new Uint32Array(t)
                            } else this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                            this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0
                        }
                        Md5.prototype.update = function(e) {
                            if (!this.finalized) {
                                var t, i = typeof e;
                                if ("string" !== i) {
                                    if ("object" !== i) throw ERROR;
                                    if (null === e) throw ERROR;
                                    if (ARRAY_BUFFER && e.constructor === ArrayBuffer) e = new Uint8Array(e);
                                    else if (!(Array.isArray(e) || ARRAY_BUFFER && ArrayBuffer.isView(e))) throw ERROR;
                                    t = !0
                                }
                                for (var n, s, r = 0, o = e.length, a = this.blocks, c = this.buffer8; r < o;) {
                                    if (this.hashed && (this.hashed = !1, a[0] = a[16], a[16] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = a[9] = a[10] = a[11] = a[12] = a[13] = a[14] = a[15] = 0), t)
                                        if (ARRAY_BUFFER)
                                            for (s = this.start; r < o && s < 64; ++r) c[s++] = e[r];
                                        else
                                            for (s = this.start; r < o && s < 64; ++r) a[s >> 2] |= e[r] << SHIFT[3 & s++];
                                    else if (ARRAY_BUFFER)
                                        for (s = this.start; r < o && s < 64; ++r)(n = e.charCodeAt(r)) < 128 ? c[s++] = n : n < 2048 ? (c[s++] = 192 | n >> 6, c[s++] = 128 | 63 & n) : n < 55296 || n >= 57344 ? (c[s++] = 224 | n >> 12, c[s++] = 128 | n >> 6 & 63, c[s++] = 128 | 63 & n) : (n = 65536 + ((1023 & n) << 10 | 1023 & e.charCodeAt(++r)), c[s++] = 240 | n >> 18, c[s++] = 128 | n >> 12 & 63, c[s++] = 128 | n >> 6 & 63, c[s++] = 128 | 63 & n);
                                    else
                                        for (s = this.start; r < o && s < 64; ++r)(n = e.charCodeAt(r)) < 128 ? a[s >> 2] |= n << SHIFT[3 & s++] : n < 2048 ? (a[s >> 2] |= (192 | n >> 6) << SHIFT[3 & s++], a[s >> 2] |= (128 | 63 & n) << SHIFT[3 & s++]) : n < 55296 || n >= 57344 ? (a[s >> 2] |= (224 | n >> 12) << SHIFT[3 & s++], a[s >> 2] |= (128 | n >> 6 & 63) << SHIFT[3 & s++], a[s >> 2] |= (128 | 63 & n) << SHIFT[3 & s++]) : (n = 65536 + ((1023 & n) << 10 | 1023 & e.charCodeAt(++r)), a[s >> 2] |= (240 | n >> 18) << SHIFT[3 & s++], a[s >> 2] |= (128 | n >> 12 & 63) << SHIFT[3 & s++], a[s >> 2] |= (128 | n >> 6 & 63) << SHIFT[3 & s++], a[s >> 2] |= (128 | 63 & n) << SHIFT[3 & s++]);
                                    this.lastByteIndex = s, this.bytes += s - this.start, s >= 64 ? (this.start = s - 64, this.hash(), this.hashed = !0) : this.start = s
                                }
                                return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this
                            }
                        }, Md5.prototype.finalize = function() {
                            if (!this.finalized) {
                                this.finalized = !0;
                                var e = this.blocks,
                                    t = this.lastByteIndex;
                                e[t >> 2] |= EXTRA[3 & t], t >= 56 && (this.hashed || this.hash(), e[0] = e[16], e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0), e[14] = this.bytes << 3, e[15] = this.hBytes << 3 | this.bytes >>> 29, this.hash()
                            }
                        }, Md5.prototype.hash = function() {
                            var e, t, i, n, s, r, o = this.blocks;
                            this.first ? t = ((t = ((e = ((e = o[0] - 680876937) << 7 | e >>> 25) - 271733879 << 0) ^ (i = ((i = (-271733879 ^ (n = ((n = (-1732584194 ^ 2004318071 & e) + o[1] - 117830708) << 12 | n >>> 20) + e << 0) & (-271733879 ^ e)) + o[2] - 1126478375) << 17 | i >>> 15) + n << 0) & (n ^ e)) + o[3] - 1316259209) << 22 | t >>> 10) + i << 0 : (e = this.h0, t = this.h1, i = this.h2, t = ((t += ((e = ((e += ((n = this.h3) ^ t & (i ^ n)) + o[0] - 680876936) << 7 | e >>> 25) + t << 0) ^ (i = ((i += (t ^ (n = ((n += (i ^ e & (t ^ i)) + o[1] - 389564586) << 12 | n >>> 20) + e << 0) & (e ^ t)) + o[2] + 606105819) << 17 | i >>> 15) + n << 0) & (n ^ e)) + o[3] - 1044525330) << 22 | t >>> 10) + i << 0), t = ((t += ((e = ((e += (n ^ t & (i ^ n)) + o[4] - 176418897) << 7 | e >>> 25) + t << 0) ^ (i = ((i += (t ^ (n = ((n += (i ^ e & (t ^ i)) + o[5] + 1200080426) << 12 | n >>> 20) + e << 0) & (e ^ t)) + o[6] - 1473231341) << 17 | i >>> 15) + n << 0) & (n ^ e)) + o[7] - 45705983) << 22 | t >>> 10) + i << 0, t = ((t += ((e = ((e += (n ^ t & (i ^ n)) + o[8] + 1770035416) << 7 | e >>> 25) + t << 0) ^ (i = ((i += (t ^ (n = ((n += (i ^ e & (t ^ i)) + o[9] - 1958414417) << 12 | n >>> 20) + e << 0) & (e ^ t)) + o[10] - 42063) << 17 | i >>> 15) + n << 0) & (n ^ e)) + o[11] - 1990404162) << 22 | t >>> 10) + i << 0, t = ((t += ((e = ((e += (n ^ t & (i ^ n)) + o[12] + 1804603682) << 7 | e >>> 25) + t << 0) ^ (i = ((i += (t ^ (n = ((n += (i ^ e & (t ^ i)) + o[13] - 40341101) << 12 | n >>> 20) + e << 0) & (e ^ t)) + o[14] - 1502002290) << 17 | i >>> 15) + n << 0) & (n ^ e)) + o[15] + 1236535329) << 22 | t >>> 10) + i << 0, t = ((t += ((n = ((n += (t ^ i & ((e = ((e += (i ^ n & (t ^ i)) + o[1] - 165796510) << 5 | e >>> 27) + t << 0) ^ t)) + o[6] - 1069501632) << 9 | n >>> 23) + e << 0) ^ e & ((i = ((i += (e ^ t & (n ^ e)) + o[11] + 643717713) << 14 | i >>> 18) + n << 0) ^ n)) + o[0] - 373897302) << 20 | t >>> 12) + i << 0, t = ((t += ((n = ((n += (t ^ i & ((e = ((e += (i ^ n & (t ^ i)) + o[5] - 701558691) << 5 | e >>> 27) + t << 0) ^ t)) + o[10] + 38016083) << 9 | n >>> 23) + e << 0) ^ e & ((i = ((i += (e ^ t & (n ^ e)) + o[15] - 660478335) << 14 | i >>> 18) + n << 0) ^ n)) + o[4] - 405537848) << 20 | t >>> 12) + i << 0, t = ((t += ((n = ((n += (t ^ i & ((e = ((e += (i ^ n & (t ^ i)) + o[9] + 568446438) << 5 | e >>> 27) + t << 0) ^ t)) + o[14] - 1019803690) << 9 | n >>> 23) + e << 0) ^ e & ((i = ((i += (e ^ t & (n ^ e)) + o[3] - 187363961) << 14 | i >>> 18) + n << 0) ^ n)) + o[8] + 1163531501) << 20 | t >>> 12) + i << 0, t = ((t += ((n = ((n += (t ^ i & ((e = ((e += (i ^ n & (t ^ i)) + o[13] - 1444681467) << 5 | e >>> 27) + t << 0) ^ t)) + o[2] - 51403784) << 9 | n >>> 23) + e << 0) ^ e & ((i = ((i += (e ^ t & (n ^ e)) + o[7] + 1735328473) << 14 | i >>> 18) + n << 0) ^ n)) + o[12] - 1926607734) << 20 | t >>> 12) + i << 0, t = ((t += ((r = (n = ((n += ((s = t ^ i) ^ (e = ((e += (s ^ n) + o[5] - 378558) << 4 | e >>> 28) + t << 0)) + o[8] - 2022574463) << 11 | n >>> 21) + e << 0) ^ e) ^ (i = ((i += (r ^ t) + o[11] + 1839030562) << 16 | i >>> 16) + n << 0)) + o[14] - 35309556) << 23 | t >>> 9) + i << 0, t = ((t += ((r = (n = ((n += ((s = t ^ i) ^ (e = ((e += (s ^ n) + o[1] - 1530992060) << 4 | e >>> 28) + t << 0)) + o[4] + 1272893353) << 11 | n >>> 21) + e << 0) ^ e) ^ (i = ((i += (r ^ t) + o[7] - 155497632) << 16 | i >>> 16) + n << 0)) + o[10] - 1094730640) << 23 | t >>> 9) + i << 0, t = ((t += ((r = (n = ((n += ((s = t ^ i) ^ (e = ((e += (s ^ n) + o[13] + 681279174) << 4 | e >>> 28) + t << 0)) + o[0] - 358537222) << 11 | n >>> 21) + e << 0) ^ e) ^ (i = ((i += (r ^ t) + o[3] - 722521979) << 16 | i >>> 16) + n << 0)) + o[6] + 76029189) << 23 | t >>> 9) + i << 0, t = ((t += ((r = (n = ((n += ((s = t ^ i) ^ (e = ((e += (s ^ n) + o[9] - 640364487) << 4 | e >>> 28) + t << 0)) + o[12] - 421815835) << 11 | n >>> 21) + e << 0) ^ e) ^ (i = ((i += (r ^ t) + o[15] + 530742520) << 16 | i >>> 16) + n << 0)) + o[2] - 995338651) << 23 | t >>> 9) + i << 0, t = ((t += ((n = ((n += (t ^ ((e = ((e += (i ^ (t | ~n)) + o[0] - 198630844) << 6 | e >>> 26) + t << 0) | ~i)) + o[7] + 1126891415) << 10 | n >>> 22) + e << 0) ^ ((i = ((i += (e ^ (n | ~t)) + o[14] - 1416354905) << 15 | i >>> 17) + n << 0) | ~e)) + o[5] - 57434055) << 21 | t >>> 11) + i << 0, t = ((t += ((n = ((n += (t ^ ((e = ((e += (i ^ (t | ~n)) + o[12] + 1700485571) << 6 | e >>> 26) + t << 0) | ~i)) + o[3] - 1894986606) << 10 | n >>> 22) + e << 0) ^ ((i = ((i += (e ^ (n | ~t)) + o[10] - 1051523) << 15 | i >>> 17) + n << 0) | ~e)) + o[1] - 2054922799) << 21 | t >>> 11) + i << 0, t = ((t += ((n = ((n += (t ^ ((e = ((e += (i ^ (t | ~n)) + o[8] + 1873313359) << 6 | e >>> 26) + t << 0) | ~i)) + o[15] - 30611744) << 10 | n >>> 22) + e << 0) ^ ((i = ((i += (e ^ (n | ~t)) + o[6] - 1560198380) << 15 | i >>> 17) + n << 0) | ~e)) + o[13] + 1309151649) << 21 | t >>> 11) + i << 0, t = ((t += ((n = ((n += (t ^ ((e = ((e += (i ^ (t | ~n)) + o[4] - 145523070) << 6 | e >>> 26) + t << 0) | ~i)) + o[11] - 1120210379) << 10 | n >>> 22) + e << 0) ^ ((i = ((i += (e ^ (n | ~t)) + o[2] + 718787259) << 15 | i >>> 17) + n << 0) | ~e)) + o[9] - 343485551) << 21 | t >>> 11) + i << 0, this.first ? (this.h0 = e + 1732584193 << 0, this.h1 = t - 271733879 << 0, this.h2 = i - 1732584194 << 0, this.h3 = n + 271733878 << 0, this.first = !1) : (this.h0 = this.h0 + e << 0, this.h1 = this.h1 + t << 0, this.h2 = this.h2 + i << 0, this.h3 = this.h3 + n << 0)
                        }, Md5.prototype.hex = function() {
                            this.finalize();
                            var e = this.h0,
                                t = this.h1,
                                i = this.h2,
                                n = this.h3;
                            return HEX_CHARS[e >> 4 & 15] + HEX_CHARS[15 & e] + HEX_CHARS[e >> 12 & 15] + HEX_CHARS[e >> 8 & 15] + HEX_CHARS[e >> 20 & 15] + HEX_CHARS[e >> 16 & 15] + HEX_CHARS[e >> 28 & 15] + HEX_CHARS[e >> 24 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[15 & t] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[i >> 4 & 15] + HEX_CHARS[15 & i] + HEX_CHARS[i >> 12 & 15] + HEX_CHARS[i >> 8 & 15] + HEX_CHARS[i >> 20 & 15] + HEX_CHARS[i >> 16 & 15] + HEX_CHARS[i >> 28 & 15] + HEX_CHARS[i >> 24 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[15 & n] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15]
                        }, Md5.prototype.toString = Md5.prototype.hex, Md5.prototype.digest = function() {
                            this.finalize();
                            var e = this.h0,
                                t = this.h1,
                                i = this.h2,
                                n = this.h3;
                            return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255, 255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255, 255 & i, i >> 8 & 255, i >> 16 & 255, i >> 24 & 255, 255 & n, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255]
                        }, Md5.prototype.array = Md5.prototype.digest, Md5.prototype.arrayBuffer = function() {
                            this.finalize();
                            var e = new ArrayBuffer(16),
                                t = new Uint32Array(e);
                            return t[0] = this.h0, t[1] = this.h1, t[2] = this.h2, t[3] = this.h3, e
                        }, Md5.prototype.buffer = Md5.prototype.arrayBuffer, Md5.prototype.base64 = function() {
                            for (var e, t, i, n = "", s = this.array(), r = 0; r < 15;) e = s[r++], t = s[r++], i = s[r++], n += BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[63 & (e << 4 | t >>> 4)] + BASE64_ENCODE_CHAR[63 & (t << 2 | i >>> 6)] + BASE64_ENCODE_CHAR[63 & i];
                            return e = s[r], n + (BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[e << 4 & 63] + "==")
                        };
                        var exports = createMethod();
                        COMMON_JS ? module.exports = exports : (root.md5 = exports, AMD && (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                            return exports
                        }.call(exports, __webpack_require__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)))
                    })()
                },
                2138: (e, t, i) => {
                    e = i.nmd(e);
                    var n = "__lodash_hash_undefined__",
                        s = 9007199254740991,
                        r = "[object Arguments]",
                        o = "[object Boolean]",
                        a = "[object Date]",
                        c = "[object Function]",
                        d = "[object GeneratorFunction]",
                        l = "[object Map]",
                        h = "[object Number]",
                        u = "[object Object]",
                        p = "[object Promise]",
                        m = "[object RegExp]",
                        f = "[object Set]",
                        g = "[object String]",
                        _ = "[object Symbol]",
                        S = "[object WeakMap]",
                        v = "[object ArrayBuffer]",
                        E = "[object DataView]",
                        y = "[object Float32Array]",
                        T = "[object Float64Array]",
                        C = "[object Int8Array]",
                        b = "[object Int16Array]",
                        R = "[object Int32Array]",
                        A = "[object Uint8Array]",
                        P = "[object Uint8ClampedArray]",
                        I = "[object Uint16Array]",
                        N = "[object Uint32Array]",
                        D = /\w*$/,
                        M = /^\[object .+?Constructor\]$/,
                        O = /^(?:0|[1-9]\d*)$/,
                        w = {};
                    w[r] = w["[object Array]"] = w[v] = w[E] = w[o] = w[a] = w[y] = w[T] = w[C] = w[b] = w[R] = w[l] = w[h] = w[u] = w[m] = w[f] = w[g] = w[_] = w[A] = w[P] = w[I] = w[N] = !0, w["[object Error]"] = w[c] = w[S] = !1;
                    var L = "object" == typeof i.g && i.g && i.g.Object === Object && i.g,
                        k = "object" == typeof self && self && self.Object === Object && self,
                        x = L || k || Function("return this")(),
                        F = t && !t.nodeType && t,
                        V = F && e && !e.nodeType && e,
                        U = V && V.exports === F;

                    function j(e, t) {
                        return e.set(t[0], t[1]), e
                    }

                    function $(e, t) {
                        return e.add(t), e
                    }

                    function H(e, t, i, n) {
                        var s = -1,
                            r = e ? e.length : 0;
                        for (n && r && (i = e[++s]); ++s < r;) i = t(i, e[s], s, e);
                        return i
                    }

                    function B(e) {
                        var t = !1;
                        if (null != e && "function" != typeof e.toString) try {
                            t = !!(e + "")
                        } catch (e) {}
                        return t
                    }

                    function J(e) {
                        var t = -1,
                            i = Array(e.size);
                        return e.forEach((function(e, n) {
                            i[++t] = [n, e]
                        })), i
                    }

                    function G(e, t) {
                        return function(i) {
                            return e(t(i))
                        }
                    }

                    function K(e) {
                        var t = -1,
                            i = Array(e.size);
                        return e.forEach((function(e) {
                            i[++t] = e
                        })), i
                    }
                    var q, W = Array.prototype,
                        X = Function.prototype,
                        z = Object.prototype,
                        Q = x["__core-js_shared__"],
                        Y = (q = /[^.]+$/.exec(Q && Q.keys && Q.keys.IE_PROTO || "")) ? "Symbol(src)_1." + q : "",
                        Z = X.toString,
                        ee = z.hasOwnProperty,
                        te = z.toString,
                        ie = RegExp("^" + Z.call(ee).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                        ne = U ? x.Buffer : void 0,
                        se = x.Symbol,
                        re = x.Uint8Array,
                        oe = G(Object.getPrototypeOf, Object),
                        ae = Object.create,
                        ce = z.propertyIsEnumerable,
                        de = W.splice,
                        le = Object.getOwnPropertySymbols,
                        he = ne ? ne.isBuffer : void 0,
                        ue = G(Object.keys, Object),
                        pe = xe(x, "DataView"),
                        me = xe(x, "Map"),
                        fe = xe(x, "Promise"),
                        ge = xe(x, "Set"),
                        _e = xe(x, "WeakMap"),
                        Se = xe(Object, "create"),
                        ve = $e(pe),
                        Ee = $e(me),
                        ye = $e(fe),
                        Te = $e(ge),
                        Ce = $e(_e),
                        be = se ? se.prototype : void 0,
                        Re = be ? be.valueOf : void 0;

                    function Ae(e) {
                        var t = -1,
                            i = e ? e.length : 0;
                        for (this.clear(); ++t < i;) {
                            var n = e[t];
                            this.set(n[0], n[1])
                        }
                    }

                    function Pe(e) {
                        var t = -1,
                            i = e ? e.length : 0;
                        for (this.clear(); ++t < i;) {
                            var n = e[t];
                            this.set(n[0], n[1])
                        }
                    }

                    function Ie(e) {
                        var t = -1,
                            i = e ? e.length : 0;
                        for (this.clear(); ++t < i;) {
                            var n = e[t];
                            this.set(n[0], n[1])
                        }
                    }

                    function Ne(e) {
                        this.__data__ = new Pe(e)
                    }

                    function De(e, t, i) {
                        var n = e[t];
                        ee.call(e, t) && He(n, i) && (void 0 !== i || t in e) || (e[t] = i)
                    }

                    function Me(e, t) {
                        for (var i = e.length; i--;)
                            if (He(e[i][0], t)) return i;
                        return -1
                    }

                    function Oe(e, t, i, n, s, p, S) {
                        var M;
                        if (n && (M = p ? n(e, s, p, S) : n(e)), void 0 !== M) return M;
                        if (!qe(e)) return e;
                        var O = Be(e);
                        if (O) {
                            if (M = function(e) {
                                    var t = e.length,
                                        i = e.constructor(t);
                                    return t && "string" == typeof e[0] && ee.call(e, "index") && (i.index = e.index, i.input = e.input), i
                                }(e), !t) return function(e, t) {
                                var i = -1,
                                    n = e.length;
                                for (t || (t = Array(n)); ++i < n;) t[i] = e[i];
                                return t
                            }(e, M)
                        } else {
                            var L = Ve(e),
                                k = L == c || L == d;
                            if (Ge(e)) return function(e, t) {
                                if (t) return e.slice();
                                var i = new e.constructor(e.length);
                                return e.copy(i), i
                            }(e, t);
                            if (L == u || L == r || k && !p) {
                                if (B(e)) return p ? e : {};
                                if (M = function(e) {
                                        return "function" != typeof e.constructor || je(e) ? {} : qe(t = oe(e)) ? ae(t) : {};
                                        var t
                                    }(k ? {} : e), !t) return function(e, t) {
                                    return Le(e, Fe(e), t)
                                }(e, function(e, t) {
                                    return e && Le(t, We(t), e)
                                }(M, e))
                            } else {
                                if (!w[L]) return p ? e : {};
                                M = function(e, t, i, n) {
                                    var s, r = e.constructor;
                                    switch (t) {
                                        case v:
                                            return we(e);
                                        case o:
                                        case a:
                                            return new r(+e);
                                        case E:
                                            return function(e, t) {
                                                var i = t ? we(e.buffer) : e.buffer;
                                                return new e.constructor(i, e.byteOffset, e.byteLength)
                                            }(e, n);
                                        case y:
                                        case T:
                                        case C:
                                        case b:
                                        case R:
                                        case A:
                                        case P:
                                        case I:
                                        case N:
                                            return function(e, t) {
                                                var i = t ? we(e.buffer) : e.buffer;
                                                return new e.constructor(i, e.byteOffset, e.length)
                                            }(e, n);
                                        case l:
                                            return function(e, t, i) {
                                                return H(t ? i(J(e), !0) : J(e), j, new e.constructor)
                                            }(e, n, i);
                                        case h:
                                        case g:
                                            return new r(e);
                                        case m:
                                            return function(e) {
                                                var t = new e.constructor(e.source, D.exec(e));
                                                return t.lastIndex = e.lastIndex, t
                                            }(e);
                                        case f:
                                            return function(e, t, i) {
                                                return H(t ? i(K(e), !0) : K(e), $, new e.constructor)
                                            }(e, n, i);
                                        case _:
                                            return s = e, Re ? Object(Re.call(s)) : {}
                                    }
                                }(e, L, Oe, t)
                            }
                        }
                        S || (S = new Ne);
                        var x = S.get(e);
                        if (x) return x;
                        if (S.set(e, M), !O) var F = i ? function(e) {
                            return function(e, t, i) {
                                var n = t(e);
                                return Be(e) ? n : function(e, t) {
                                    for (var i = -1, n = t.length, s = e.length; ++i < n;) e[s + i] = t[i];
                                    return e
                                }(n, i(e))
                            }(e, We, Fe)
                        }(e) : We(e);
                        return function(e, t) {
                            for (var i = -1, n = e ? e.length : 0; ++i < n && !1 !== t(e[i], i););
                        }(F || e, (function(s, r) {
                            F && (s = e[r = s]), De(M, r, Oe(s, t, i, n, r, e, S))
                        })), M
                    }

                    function we(e) {
                        var t = new e.constructor(e.byteLength);
                        return new re(t).set(new re(e)), t
                    }

                    function Le(e, t, i, n) {
                        i || (i = {});
                        for (var s = -1, r = t.length; ++s < r;) {
                            var o = t[s],
                                a = n ? n(i[o], e[o], o, i, e) : void 0;
                            De(i, o, void 0 === a ? e[o] : a)
                        }
                        return i
                    }

                    function ke(e, t) {
                        var i, n, s = e.__data__;
                        return ("string" == (n = typeof(i = t)) || "number" == n || "symbol" == n || "boolean" == n ? "__proto__" !== i : null === i) ? s["string" == typeof t ? "string" : "hash"] : s.map
                    }

                    function xe(e, t) {
                        var i = function(e, t) {
                            return null == e ? void 0 : e[t]
                        }(e, t);
                        return function(e) {
                            return !(!qe(e) || (t = e, Y && Y in t)) && (Ke(e) || B(e) ? ie : M).test($e(e));
                            var t
                        }(i) ? i : void 0
                    }
                    Ae.prototype.clear = function() {
                        this.__data__ = Se ? Se(null) : {}
                    }, Ae.prototype.delete = function(e) {
                        return this.has(e) && delete this.__data__[e]
                    }, Ae.prototype.get = function(e) {
                        var t = this.__data__;
                        if (Se) {
                            var i = t[e];
                            return i === n ? void 0 : i
                        }
                        return ee.call(t, e) ? t[e] : void 0
                    }, Ae.prototype.has = function(e) {
                        var t = this.__data__;
                        return Se ? void 0 !== t[e] : ee.call(t, e)
                    }, Ae.prototype.set = function(e, t) {
                        return this.__data__[e] = Se && void 0 === t ? n : t, this
                    }, Pe.prototype.clear = function() {
                        this.__data__ = []
                    }, Pe.prototype.delete = function(e) {
                        var t = this.__data__,
                            i = Me(t, e);
                        return !(i < 0 || (i == t.length - 1 ? t.pop() : de.call(t, i, 1), 0))
                    }, Pe.prototype.get = function(e) {
                        var t = this.__data__,
                            i = Me(t, e);
                        return i < 0 ? void 0 : t[i][1]
                    }, Pe.prototype.has = function(e) {
                        return Me(this.__data__, e) > -1
                    }, Pe.prototype.set = function(e, t) {
                        var i = this.__data__,
                            n = Me(i, e);
                        return n < 0 ? i.push([e, t]) : i[n][1] = t, this
                    }, Ie.prototype.clear = function() {
                        this.__data__ = {
                            hash: new Ae,
                            map: new(me || Pe),
                            string: new Ae
                        }
                    }, Ie.prototype.delete = function(e) {
                        return ke(this, e).delete(e)
                    }, Ie.prototype.get = function(e) {
                        return ke(this, e).get(e)
                    }, Ie.prototype.has = function(e) {
                        return ke(this, e).has(e)
                    }, Ie.prototype.set = function(e, t) {
                        return ke(this, e).set(e, t), this
                    }, Ne.prototype.clear = function() {
                        this.__data__ = new Pe
                    }, Ne.prototype.delete = function(e) {
                        return this.__data__.delete(e)
                    }, Ne.prototype.get = function(e) {
                        return this.__data__.get(e)
                    }, Ne.prototype.has = function(e) {
                        return this.__data__.has(e)
                    }, Ne.prototype.set = function(e, t) {
                        var i = this.__data__;
                        if (i instanceof Pe) {
                            var n = i.__data__;
                            if (!me || n.length < 199) return n.push([e, t]), this;
                            i = this.__data__ = new Ie(n)
                        }
                        return i.set(e, t), this
                    };
                    var Fe = le ? G(le, Object) : function() {
                            return []
                        },
                        Ve = function(e) {
                            return te.call(e)
                        };

                    function Ue(e, t) {
                        return !!(t = null == t ? s : t) && ("number" == typeof e || O.test(e)) && e > -1 && e % 1 == 0 && e < t
                    }

                    function je(e) {
                        var t = e && e.constructor;
                        return e === ("function" == typeof t && t.prototype || z)
                    }

                    function $e(e) {
                        if (null != e) {
                            try {
                                return Z.call(e)
                            } catch (e) {}
                            try {
                                return e + ""
                            } catch (e) {}
                        }
                        return ""
                    }

                    function He(e, t) {
                        return e === t || e != e && t != t
                    }(pe && Ve(new pe(new ArrayBuffer(1))) != E || me && Ve(new me) != l || fe && Ve(fe.resolve()) != p || ge && Ve(new ge) != f || _e && Ve(new _e) != S) && (Ve = function(e) {
                        var t = te.call(e),
                            i = t == u ? e.constructor : void 0,
                            n = i ? $e(i) : void 0;
                        if (n) switch (n) {
                            case ve:
                                return E;
                            case Ee:
                                return l;
                            case ye:
                                return p;
                            case Te:
                                return f;
                            case Ce:
                                return S
                        }
                        return t
                    });
                    var Be = Array.isArray;

                    function Je(e) {
                        return null != e && function(e) {
                            return "number" == typeof e && e > -1 && e % 1 == 0 && e <= s
                        }(e.length) && !Ke(e)
                    }
                    var Ge = he || function() {
                        return !1
                    };

                    function Ke(e) {
                        var t = qe(e) ? te.call(e) : "";
                        return t == c || t == d
                    }

                    function qe(e) {
                        var t = typeof e;
                        return !!e && ("object" == t || "function" == t)
                    }

                    function We(e) {
                        return Je(e) ? function(e, t) {
                            var i = Be(e) || function(e) {
                                    return function(e) {
                                        return function(e) {
                                            return !!e && "object" == typeof e
                                        }(e) && Je(e)
                                    }(e) && ee.call(e, "callee") && (!ce.call(e, "callee") || te.call(e) == r)
                                }(e) ? function(e, t) {
                                    for (var i = -1, n = Array(e); ++i < e;) n[i] = t(i);
                                    return n
                                }(e.length, String) : [],
                                n = i.length,
                                s = !!n;
                            for (var o in e) !t && !ee.call(e, o) || s && ("length" == o || Ue(o, n)) || i.push(o);
                            return i
                        }(e) : function(e) {
                            if (!je(e)) return ue(e);
                            var t = [];
                            for (var i in Object(e)) ee.call(e, i) && "constructor" != i && t.push(i);
                            return t
                        }(e)
                    }
                    e.exports = function(e) {
                        return Oe(e, !0, !0)
                    }
                },
                9509: (e, t, i) => {
                    var n = /^\s+|\s+$/g,
                        s = /^[-+]0x[0-9a-f]+$/i,
                        r = /^0b[01]+$/i,
                        o = /^0o[0-7]+$/i,
                        a = parseInt,
                        c = "object" == typeof i.g && i.g && i.g.Object === Object && i.g,
                        d = "object" == typeof self && self && self.Object === Object && self,
                        l = c || d || Function("return this")(),
                        h = Object.prototype.toString,
                        u = Math.max,
                        p = Math.min,
                        m = function() {
                            return l.Date.now()
                        };

                    function f(e) {
                        var t = typeof e;
                        return !!e && ("object" == t || "function" == t)
                    }

                    function g(e) {
                        if ("number" == typeof e) return e;
                        if (function(e) {
                                return "symbol" == typeof e || function(e) {
                                    return !!e && "object" == typeof e
                                }(e) && "[object Symbol]" == h.call(e)
                            }(e)) return NaN;
                        if (f(e)) {
                            var t = "function" == typeof e.valueOf ? e.valueOf() : e;
                            e = f(t) ? t + "" : t
                        }
                        if ("string" != typeof e) return 0 === e ? e : +e;
                        e = e.replace(n, "");
                        var i = r.test(e);
                        return i || o.test(e) ? a(e.slice(2), i ? 2 : 8) : s.test(e) ? NaN : +e
                    }
                    e.exports = function(e, t, i) {
                        var n, s, r, o, a, c, d = 0,
                            l = !1,
                            h = !1,
                            _ = !0;
                        if ("function" != typeof e) throw new TypeError("Expected a function");

                        function S(t) {
                            var i = n,
                                r = s;
                            return n = s = void 0, d = t, o = e.apply(r, i)
                        }

                        function v(e) {
                            return d = e, a = setTimeout(y, t), l ? S(e) : o
                        }

                        function E(e) {
                            var i = e - c;
                            return void 0 === c || i >= t || i < 0 || h && e - d >= r
                        }

                        function y() {
                            var e = m();
                            if (E(e)) return T(e);
                            a = setTimeout(y, function(e) {
                                var i = t - (e - c);
                                return h ? p(i, r - (e - d)) : i
                            }(e))
                        }

                        function T(e) {
                            return a = void 0, _ && n ? S(e) : (n = s = void 0, o)
                        }

                        function C() {
                            var e = m(),
                                i = E(e);
                            if (n = arguments, s = this, c = e, i) {
                                if (void 0 === a) return v(c);
                                if (h) return a = setTimeout(y, t), S(c)
                            }
                            return void 0 === a && (a = setTimeout(y, t)), o
                        }
                        return t = g(t) || 0, f(i) && (l = !!i.leading, r = (h = "maxWait" in i) ? u(g(i.maxWait) || 0, t) : r, _ = "trailing" in i ? !!i.trailing : _), C.cancel = function() {
                            void 0 !== a && clearTimeout(a), d = 0, n = c = s = a = void 0
                        }, C.flush = function() {
                            return void 0 === a ? o : T(m())
                        }, C
                    }
                },
                7047: (e, t, i) => {
                    e = i.nmd(e);
                    var n = "__lodash_hash_undefined__",
                        s = 9007199254740991,
                        r = "[object Arguments]",
                        o = "[object Array]",
                        a = "[object Boolean]",
                        c = "[object Date]",
                        d = "[object Error]",
                        l = "[object Function]",
                        h = "[object Map]",
                        u = "[object Number]",
                        p = "[object Object]",
                        m = "[object Promise]",
                        f = "[object RegExp]",
                        g = "[object Set]",
                        _ = "[object String]",
                        S = "[object WeakMap]",
                        v = "[object ArrayBuffer]",
                        E = "[object DataView]",
                        y = /^\[object .+?Constructor\]$/,
                        T = /^(?:0|[1-9]\d*)$/,
                        C = {};
                    C["[object Float32Array]"] = C["[object Float64Array]"] = C["[object Int8Array]"] = C["[object Int16Array]"] = C["[object Int32Array]"] = C["[object Uint8Array]"] = C["[object Uint8ClampedArray]"] = C["[object Uint16Array]"] = C["[object Uint32Array]"] = !0, C[r] = C[o] = C[v] = C[a] = C[E] = C[c] = C[d] = C[l] = C[h] = C[u] = C[p] = C[f] = C[g] = C[_] = C[S] = !1;
                    var b = "object" == typeof i.g && i.g && i.g.Object === Object && i.g,
                        R = "object" == typeof self && self && self.Object === Object && self,
                        A = b || R || Function("return this")(),
                        P = t && !t.nodeType && t,
                        I = P && e && !e.nodeType && e,
                        N = I && I.exports === P,
                        D = N && b.process,
                        M = function() {
                            try {
                                return D && D.binding && D.binding("util")
                            } catch (e) {}
                        }(),
                        O = M && M.isTypedArray;

                    function w(e, t) {
                        for (var i = -1, n = null == e ? 0 : e.length; ++i < n;)
                            if (t(e[i], i, e)) return !0;
                        return !1
                    }

                    function L(e) {
                        var t = -1,
                            i = Array(e.size);
                        return e.forEach((function(e, n) {
                            i[++t] = [n, e]
                        })), i
                    }

                    function k(e) {
                        var t = -1,
                            i = Array(e.size);
                        return e.forEach((function(e) {
                            i[++t] = e
                        })), i
                    }
                    var x, F, V, U = Array.prototype,
                        j = Function.prototype,
                        $ = Object.prototype,
                        H = A["__core-js_shared__"],
                        B = j.toString,
                        J = $.hasOwnProperty,
                        G = (x = /[^.]+$/.exec(H && H.keys && H.keys.IE_PROTO || "")) ? "Symbol(src)_1." + x : "",
                        K = $.toString,
                        q = RegExp("^" + B.call(J).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                        W = N ? A.Buffer : void 0,
                        X = A.Symbol,
                        z = A.Uint8Array,
                        Q = $.propertyIsEnumerable,
                        Y = U.splice,
                        Z = X ? X.toStringTag : void 0,
                        ee = Object.getOwnPropertySymbols,
                        te = W ? W.isBuffer : void 0,
                        ie = (F = Object.keys, V = Object, function(e) {
                            return F(V(e))
                        }),
                        ne = Ie(A, "DataView"),
                        se = Ie(A, "Map"),
                        re = Ie(A, "Promise"),
                        oe = Ie(A, "Set"),
                        ae = Ie(A, "WeakMap"),
                        ce = Ie(Object, "create"),
                        de = Oe(ne),
                        le = Oe(se),
                        he = Oe(re),
                        ue = Oe(oe),
                        pe = Oe(ae),
                        me = X ? X.prototype : void 0,
                        fe = me ? me.valueOf : void 0;

                    function ge(e) {
                        var t = -1,
                            i = null == e ? 0 : e.length;
                        for (this.clear(); ++t < i;) {
                            var n = e[t];
                            this.set(n[0], n[1])
                        }
                    }

                    function _e(e) {
                        var t = -1,
                            i = null == e ? 0 : e.length;
                        for (this.clear(); ++t < i;) {
                            var n = e[t];
                            this.set(n[0], n[1])
                        }
                    }

                    function Se(e) {
                        var t = -1,
                            i = null == e ? 0 : e.length;
                        for (this.clear(); ++t < i;) {
                            var n = e[t];
                            this.set(n[0], n[1])
                        }
                    }

                    function ve(e) {
                        var t = -1,
                            i = null == e ? 0 : e.length;
                        for (this.__data__ = new Se; ++t < i;) this.add(e[t])
                    }

                    function Ee(e) {
                        var t = this.__data__ = new _e(e);
                        this.size = t.size
                    }

                    function ye(e, t) {
                        for (var i = e.length; i--;)
                            if (we(e[i][0], t)) return i;
                        return -1
                    }

                    function Te(e) {
                        return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Z && Z in Object(e) ? function(e) {
                            var t = J.call(e, Z),
                                i = e[Z];
                            try {
                                e[Z] = void 0;
                                var n = !0
                            } catch (e) {}
                            var s = K.call(e);
                            return n && (t ? e[Z] = i : delete e[Z]), s
                        }(e) : function(e) {
                            return K.call(e)
                        }(e)
                    }

                    function Ce(e) {
                        return je(e) && Te(e) == r
                    }

                    function be(e, t, i, n, s) {
                        return e === t || (null == e || null == t || !je(e) && !je(t) ? e != e && t != t : function(e, t, i, n, s, l) {
                            var m = ke(e),
                                S = ke(t),
                                y = m ? o : De(e),
                                T = S ? o : De(t),
                                C = (y = y == r ? p : y) == p,
                                b = (T = T == r ? p : T) == p,
                                R = y == T;
                            if (R && xe(e)) {
                                if (!xe(t)) return !1;
                                m = !0, C = !1
                            }
                            if (R && !C) return l || (l = new Ee), m || $e(e) ? Re(e, t, i, n, s, l) : function(e, t, i, n, s, r, o) {
                                switch (i) {
                                    case E:
                                        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
                                        e = e.buffer, t = t.buffer;
                                    case v:
                                        return !(e.byteLength != t.byteLength || !r(new z(e), new z(t)));
                                    case a:
                                    case c:
                                    case u:
                                        return we(+e, +t);
                                    case d:
                                        return e.name == t.name && e.message == t.message;
                                    case f:
                                    case _:
                                        return e == t + "";
                                    case h:
                                        var l = L;
                                    case g:
                                        var p = 1 & n;
                                        if (l || (l = k), e.size != t.size && !p) return !1;
                                        var m = o.get(e);
                                        if (m) return m == t;
                                        n |= 2, o.set(e, t);
                                        var S = Re(l(e), l(t), n, s, r, o);
                                        return o.delete(e), S;
                                    case "[object Symbol]":
                                        if (fe) return fe.call(e) == fe.call(t)
                                }
                                return !1
                            }(e, t, y, i, n, s, l);
                            if (!(1 & i)) {
                                var A = C && J.call(e, "__wrapped__"),
                                    P = b && J.call(t, "__wrapped__");
                                if (A || P) {
                                    var I = A ? e.value() : e,
                                        N = P ? t.value() : t;
                                    return l || (l = new Ee), s(I, N, i, n, l)
                                }
                            }
                            return !!R && (l || (l = new Ee), function(e, t, i, n, s, r) {
                                var o = 1 & i,
                                    a = Ae(e),
                                    c = a.length;
                                if (c != Ae(t).length && !o) return !1;
                                for (var d = c; d--;) {
                                    var l = a[d];
                                    if (!(o ? l in t : J.call(t, l))) return !1
                                }
                                var h = r.get(e);
                                if (h && r.get(t)) return h == t;
                                var u = !0;
                                r.set(e, t), r.set(t, e);
                                for (var p = o; ++d < c;) {
                                    var m = e[l = a[d]],
                                        f = t[l];
                                    if (n) var g = o ? n(f, m, l, t, e, r) : n(m, f, l, e, t, r);
                                    if (!(void 0 === g ? m === f || s(m, f, i, n, r) : g)) {
                                        u = !1;
                                        break
                                    }
                                    p || (p = "constructor" == l)
                                }
                                if (u && !p) {
                                    var _ = e.constructor,
                                        S = t.constructor;
                                    _ == S || !("constructor" in e) || !("constructor" in t) || "function" == typeof _ && _ instanceof _ && "function" == typeof S && S instanceof S || (u = !1)
                                }
                                return r.delete(e), r.delete(t), u
                            }(e, t, i, n, s, l))
                        }(e, t, i, n, be, s))
                    }

                    function Re(e, t, i, n, s, r) {
                        var o = 1 & i,
                            a = e.length,
                            c = t.length;
                        if (a != c && !(o && c > a)) return !1;
                        var d = r.get(e);
                        if (d && r.get(t)) return d == t;
                        var l = -1,
                            h = !0,
                            u = 2 & i ? new ve : void 0;
                        for (r.set(e, t), r.set(t, e); ++l < a;) {
                            var p = e[l],
                                m = t[l];
                            if (n) var f = o ? n(m, p, l, t, e, r) : n(p, m, l, e, t, r);
                            if (void 0 !== f) {
                                if (f) continue;
                                h = !1;
                                break
                            }
                            if (u) {
                                if (!w(t, (function(e, t) {
                                        if (o = t, !u.has(o) && (p === e || s(p, e, i, n, r))) return u.push(t);
                                        var o
                                    }))) {
                                    h = !1;
                                    break
                                }
                            } else if (p !== m && !s(p, m, i, n, r)) {
                                h = !1;
                                break
                            }
                        }
                        return r.delete(e), r.delete(t), h
                    }

                    function Ae(e) {
                        return function(e, t, i) {
                            var n = t(e);
                            return ke(e) ? n : function(e, t) {
                                for (var i = -1, n = t.length, s = e.length; ++i < n;) e[s + i] = t[i];
                                return e
                            }(n, i(e))
                        }(e, He, Ne)
                    }

                    function Pe(e, t) {
                        var i, n, s = e.__data__;
                        return ("string" == (n = typeof(i = t)) || "number" == n || "symbol" == n || "boolean" == n ? "__proto__" !== i : null === i) ? s["string" == typeof t ? "string" : "hash"] : s.map
                    }

                    function Ie(e, t) {
                        var i = function(e, t) {
                            return null == e ? void 0 : e[t]
                        }(e, t);
                        return function(e) {
                            return !(!Ue(e) || function(e) {
                                return !!G && G in e
                            }(e)) && (Fe(e) ? q : y).test(Oe(e))
                        }(i) ? i : void 0
                    }
                    ge.prototype.clear = function() {
                        this.__data__ = ce ? ce(null) : {}, this.size = 0
                    }, ge.prototype.delete = function(e) {
                        var t = this.has(e) && delete this.__data__[e];
                        return this.size -= t ? 1 : 0, t
                    }, ge.prototype.get = function(e) {
                        var t = this.__data__;
                        if (ce) {
                            var i = t[e];
                            return i === n ? void 0 : i
                        }
                        return J.call(t, e) ? t[e] : void 0
                    }, ge.prototype.has = function(e) {
                        var t = this.__data__;
                        return ce ? void 0 !== t[e] : J.call(t, e)
                    }, ge.prototype.set = function(e, t) {
                        var i = this.__data__;
                        return this.size += this.has(e) ? 0 : 1, i[e] = ce && void 0 === t ? n : t, this
                    }, _e.prototype.clear = function() {
                        this.__data__ = [], this.size = 0
                    }, _e.prototype.delete = function(e) {
                        var t = this.__data__,
                            i = ye(t, e);
                        return !(i < 0 || (i == t.length - 1 ? t.pop() : Y.call(t, i, 1), --this.size, 0))
                    }, _e.prototype.get = function(e) {
                        var t = this.__data__,
                            i = ye(t, e);
                        return i < 0 ? void 0 : t[i][1]
                    }, _e.prototype.has = function(e) {
                        return ye(this.__data__, e) > -1
                    }, _e.prototype.set = function(e, t) {
                        var i = this.__data__,
                            n = ye(i, e);
                        return n < 0 ? (++this.size, i.push([e, t])) : i[n][1] = t, this
                    }, Se.prototype.clear = function() {
                        this.size = 0, this.__data__ = {
                            hash: new ge,
                            map: new(se || _e),
                            string: new ge
                        }
                    }, Se.prototype.delete = function(e) {
                        var t = Pe(this, e).delete(e);
                        return this.size -= t ? 1 : 0, t
                    }, Se.prototype.get = function(e) {
                        return Pe(this, e).get(e)
                    }, Se.prototype.has = function(e) {
                        return Pe(this, e).has(e)
                    }, Se.prototype.set = function(e, t) {
                        var i = Pe(this, e),
                            n = i.size;
                        return i.set(e, t), this.size += i.size == n ? 0 : 1, this
                    }, ve.prototype.add = ve.prototype.push = function(e) {
                        return this.__data__.set(e, n), this
                    }, ve.prototype.has = function(e) {
                        return this.__data__.has(e)
                    }, Ee.prototype.clear = function() {
                        this.__data__ = new _e, this.size = 0
                    }, Ee.prototype.delete = function(e) {
                        var t = this.__data__,
                            i = t.delete(e);
                        return this.size = t.size, i
                    }, Ee.prototype.get = function(e) {
                        return this.__data__.get(e)
                    }, Ee.prototype.has = function(e) {
                        return this.__data__.has(e)
                    }, Ee.prototype.set = function(e, t) {
                        var i = this.__data__;
                        if (i instanceof _e) {
                            var n = i.__data__;
                            if (!se || n.length < 199) return n.push([e, t]), this.size = ++i.size, this;
                            i = this.__data__ = new Se(n)
                        }
                        return i.set(e, t), this.size = i.size, this
                    };
                    var Ne = ee ? function(e) {
                            return null == e ? [] : (e = Object(e), function(t, i) {
                                for (var n = -1, s = null == t ? 0 : t.length, r = 0, o = []; ++n < s;) {
                                    var a = t[n];
                                    c = a, Q.call(e, c) && (o[r++] = a)
                                }
                                var c;
                                return o
                            }(ee(e)))
                        } : function() {
                            return []
                        },
                        De = Te;

                    function Me(e, t) {
                        return !!(t = null == t ? s : t) && ("number" == typeof e || T.test(e)) && e > -1 && e % 1 == 0 && e < t
                    }

                    function Oe(e) {
                        if (null != e) {
                            try {
                                return B.call(e)
                            } catch (e) {}
                            try {
                                return e + ""
                            } catch (e) {}
                        }
                        return ""
                    }

                    function we(e, t) {
                        return e === t || e != e && t != t
                    }(ne && De(new ne(new ArrayBuffer(1))) != E || se && De(new se) != h || re && De(re.resolve()) != m || oe && De(new oe) != g || ae && De(new ae) != S) && (De = function(e) {
                        var t = Te(e),
                            i = t == p ? e.constructor : void 0,
                            n = i ? Oe(i) : "";
                        if (n) switch (n) {
                            case de:
                                return E;
                            case le:
                                return h;
                            case he:
                                return m;
                            case ue:
                                return g;
                            case pe:
                                return S
                        }
                        return t
                    });
                    var Le = Ce(function() {
                            return arguments
                        }()) ? Ce : function(e) {
                            return je(e) && J.call(e, "callee") && !Q.call(e, "callee")
                        },
                        ke = Array.isArray,
                        xe = te || function() {
                            return !1
                        };

                    function Fe(e) {
                        if (!Ue(e)) return !1;
                        var t = Te(e);
                        return t == l || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t
                    }

                    function Ve(e) {
                        return "number" == typeof e && e > -1 && e % 1 == 0 && e <= s
                    }

                    function Ue(e) {
                        var t = typeof e;
                        return null != e && ("object" == t || "function" == t)
                    }

                    function je(e) {
                        return null != e && "object" == typeof e
                    }
                    var $e = O ? function(e) {
                        return function(t) {
                            return e(t)
                        }
                    }(O) : function(e) {
                        return je(e) && Ve(e.length) && !!C[Te(e)]
                    };

                    function He(e) {
                        return null != (t = e) && Ve(t.length) && !Fe(t) ? function(e, t) {
                            var i = ke(e),
                                n = !i && Le(e),
                                s = !i && !n && xe(e),
                                r = !i && !n && !s && $e(e),
                                o = i || n || s || r,
                                a = o ? function(e, t) {
                                    for (var i = -1, n = Array(e); ++i < e;) n[i] = t(i);
                                    return n
                                }(e.length, String) : [],
                                c = a.length;
                            for (var d in e) !t && !J.call(e, d) || o && ("length" == d || s && ("offset" == d || "parent" == d) || r && ("buffer" == d || "byteLength" == d || "byteOffset" == d) || Me(d, c)) || a.push(d);
                            return a
                        }(e) : function(e) {
                            if (i = (t = e) && t.constructor, t !== ("function" == typeof i && i.prototype || $)) return ie(e);
                            var t, i, n = [];
                            for (var s in Object(e)) J.call(e, s) && "constructor" != s && n.push(s);
                            return n
                        }(e);
                        var t
                    }
                    e.exports = function(e, t) {
                        return be(e, t)
                    }
                },
                5296: e => {
                    var t = e.exports = {
                        v: [{
                            name: "version",
                            reg: /^(\d*)$/
                        }],
                        o: [{
                            name: "origin",
                            reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
                            names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
                            format: "%s %s %d %s IP%d %s"
                        }],
                        s: [{
                            name: "name"
                        }],
                        i: [{
                            name: "description"
                        }],
                        u: [{
                            name: "uri"
                        }],
                        e: [{
                            name: "email"
                        }],
                        p: [{
                            name: "phone"
                        }],
                        z: [{
                            name: "timezones"
                        }],
                        r: [{
                            name: "repeats"
                        }],
                        t: [{
                            name: "timing",
                            reg: /^(\d*) (\d*)/,
                            names: ["start", "stop"],
                            format: "%d %d"
                        }],
                        c: [{
                            name: "connection",
                            reg: /^IN IP(\d) (\S*)/,
                            names: ["version", "ip"],
                            format: "IN IP%d %s"
                        }],
                        b: [{
                            push: "bandwidth",
                            reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
                            names: ["type", "limit"],
                            format: "%s:%s"
                        }],
                        m: [{
                            reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
                            names: ["type", "port", "protocol", "payloads"],
                            format: "%s %d %s %s"
                        }],
                        a: [{
                            push: "rtp",
                            reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
                            names: ["payload", "codec", "rate", "encoding"],
                            format: function(e) {
                                return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
                            }
                        }, {
                            push: "fmtp",
                            reg: /^fmtp:(\d*) ([\S| ]*)/,
                            names: ["payload", "config"],
                            format: "fmtp:%d %s"
                        }, {
                            name: "control",
                            reg: /^control:(.*)/,
                            format: "control:%s"
                        }, {
                            name: "rtcp",
                            reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                            names: ["port", "netType", "ipVer", "address"],
                            format: function(e) {
                                return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
                            }
                        }, {
                            push: "rtcpFbTrrInt",
                            reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                            names: ["payload", "value"],
                            format: "rtcp-fb:%d trr-int %d"
                        }, {
                            push: "rtcpFb",
                            reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                            names: ["payload", "type", "subtype"],
                            format: function(e) {
                                return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
                            }
                        }, {
                            push: "ext",
                            reg: /^extmap:(\d+)(?:\/(\w+))? (\S*)(?: (\S*))?/,
                            names: ["value", "direction", "uri", "config"],
                            format: function(e) {
                                return "extmap:%d" + (e.direction ? "/%s" : "%v") + " %s" + (e.config ? " %s" : "")
                            }
                        }, {
                            push: "crypto",
                            reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                            names: ["id", "suite", "config", "sessionConfig"],
                            format: function(e) {
                                return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
                            }
                        }, {
                            name: "setup",
                            reg: /^setup:(\w*)/,
                            format: "setup:%s"
                        }, {
                            name: "mid",
                            reg: /^mid:([^\s]*)/,
                            format: "mid:%s"
                        }, {
                            name: "msid",
                            reg: /^msid:(.*)/,
                            format: "msid:%s"
                        }, {
                            name: "ptime",
                            reg: /^ptime:(\d*)/,
                            format: "ptime:%d"
                        }, {
                            name: "maxptime",
                            reg: /^maxptime:(\d*)/,
                            format: "maxptime:%d"
                        }, {
                            name: "direction",
                            reg: /^(sendrecv|recvonly|sendonly|inactive)/
                        }, {
                            name: "icelite",
                            reg: /^(ice-lite)/
                        }, {
                            name: "iceUfrag",
                            reg: /^ice-ufrag:(\S*)/,
                            format: "ice-ufrag:%s"
                        }, {
                            name: "icePwd",
                            reg: /^ice-pwd:(\S*)/,
                            format: "ice-pwd:%s"
                        }, {
                            name: "fingerprint",
                            reg: /^fingerprint:(\S*) (\S*)/,
                            names: ["type", "hash"],
                            format: "fingerprint:%s %s"
                        }, {
                            push: "candidates",
                            reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
                            names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
                            format: function(e) {
                                var t = "candidate:%s %d %s %d %s %d typ %s";
                                return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), (t += null != e["network-id"] ? " network-id %d" : "%v") + (null != e["network-cost"] ? " network-cost %d" : "%v")
                            }
                        }, {
                            name: "endOfCandidates",
                            reg: /^(end-of-candidates)/
                        }, {
                            name: "remoteCandidates",
                            reg: /^remote-candidates:(.*)/,
                            format: "remote-candidates:%s"
                        }, {
                            name: "iceOptions",
                            reg: /^ice-options:(\S*)/,
                            format: "ice-options:%s"
                        }, {
                            push: "ssrcs",
                            reg: /^ssrc:(\d*) ([\w_]*)(?::(.*))?/,
                            names: ["id", "attribute", "value"],
                            format: function(e) {
                                var t = "ssrc:%d";
                                return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
                            }
                        }, {
                            push: "ssrcGroups",
                            reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
                            names: ["semantics", "ssrcs"],
                            format: "ssrc-group:%s %s"
                        }, {
                            name: "msidSemantic",
                            reg: /^msid-semantic:\s?(\w*) (\S*)/,
                            names: ["semantic", "token"],
                            format: "msid-semantic: %s %s"
                        }, {
                            push: "groups",
                            reg: /^group:(\w*) (.*)/,
                            names: ["type", "mids"],
                            format: "group:%s %s"
                        }, {
                            name: "rtcpMux",
                            reg: /^(rtcp-mux)/
                        }, {
                            name: "rtcpRsize",
                            reg: /^(rtcp-rsize)/
                        }, {
                            name: "sctpmap",
                            reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
                            names: ["sctpmapNumber", "app", "maxMessageSize"],
                            format: function(e) {
                                return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
                            }
                        }, {
                            name: "xGoogleFlag",
                            reg: /^x-google-flag:([^\s]*)/,
                            format: "x-google-flag:%s"
                        }, {
                            push: "rids",
                            reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
                            names: ["id", "direction", "params"],
                            format: function(e) {
                                return e.params ? "rid:%s %s %s" : "rid:%s %s"
                            }
                        }, {
                            push: "imageattrs",
                            reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
                            names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
                            format: function(e) {
                                return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
                            }
                        }, {
                            name: "simulcast",
                            reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
                            names: ["dir1", "list1", "dir2", "list2"],
                            format: function(e) {
                                return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
                            }
                        }, {
                            name: "simulcast_03",
                            reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
                            names: ["value"],
                            format: "simulcast: %s"
                        }, {
                            name: "framerate",
                            reg: /^framerate:(\d+(?:$|\.\d+))/,
                            format: "framerate:%s"
                        }, {
                            push: "invalid",
                            names: ["value"]
                        }]
                    };
                    Object.keys(t).forEach((function(e) {
                        t[e].forEach((function(e) {
                            e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
                        }))
                    }))
                },
                8310: (e, t, i) => {
                    var n = i(1415),
                        s = i(9159);
                    t.write = s, t.parse = n.parse, t.parseFmtpConfig = n.parseFmtpConfig, t.parseParams = n.parseParams, t.parsePayloads = n.parsePayloads, t.parseRemoteCandidates = n.parseRemoteCandidates, t.parseImageAttributes = n.parseImageAttributes, t.parseSimulcastStreamList = n.parseSimulcastStreamList
                },
                1415: (e, t, i) => {
                    var n = function(e) {
                            return String(Number(e)) === e ? Number(e) : e
                        },
                        s = function(e, t, i) {
                            var s = e.name && e.names;
                            e.push && !t[e.push] ? t[e.push] = [] : s && !t[e.name] && (t[e.name] = {});
                            var r = e.push ? {} : s ? t[e.name] : t;
                            ! function(e, t, i, s) {
                                if (s && !i) t[s] = n(e[1]);
                                else
                                    for (var r = 0; r < i.length; r += 1) null != e[r + 1] && (t[i[r]] = n(e[r + 1]))
                            }(i.match(e.reg), r, e.names, e.name), e.push && t[e.push].push(r)
                        },
                        r = i(5296),
                        o = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
                    t.parse = function(e) {
                        var t = {},
                            i = [],
                            n = t;
                        return e.split(/(\r\n|\r|\n)/).filter(o).forEach((function(e) {
                            var t = e[0],
                                o = e.slice(2);
                            "m" === t && (i.push({
                                rtp: [],
                                fmtp: []
                            }), n = i[i.length - 1]);
                            for (var a = 0; a < (r[t] || []).length; a += 1) {
                                var c = r[t][a];
                                if (c.reg.test(o)) return s(c, n, o)
                            }
                        })), t.media = i, t
                    };
                    var a = function(e, t) {
                        var i = t.split(/=(.+)/, 2);
                        return 2 === i.length && (e[i[0]] = n(i[1])), e
                    };
                    t.parseParams = function(e) {
                        return e.split(/\;\s?/).reduce(a, {})
                    }, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e) {
                        return e.split(" ").map(Number)
                    }, t.parseRemoteCandidates = function(e) {
                        for (var t = [], i = e.split(" ").map(n), s = 0; s < i.length; s += 3) t.push({
                            component: i[s],
                            ip: i[s + 1],
                            port: i[s + 2]
                        });
                        return t
                    }, t.parseImageAttributes = function(e) {
                        return e.split(" ").map((function(e) {
                            return e.substring(1, e.length - 1).split(",").reduce(a, {})
                        }))
                    }, t.parseSimulcastStreamList = function(e) {
                        return e.split(";").map((function(e) {
                            return e.split(",").map((function(e) {
                                var t, i = !1;
                                return "~" !== e[0] ? t = n(e) : (t = n(e.substring(1, e.length)), i = !0), {
                                    scid: t,
                                    paused: i
                                }
                            }))
                        }))
                    }
                },
                9159: (e, t, i) => {
                    var n = i(5296),
                        s = /%[sdv%]/g,
                        r = function(e) {
                            var t = 1,
                                i = arguments,
                                n = i.length;
                            return e.replace(s, (function(e) {
                                if (t >= n) return e;
                                var s = i[t];
                                switch (t += 1, e) {
                                    case "%%":
                                        return "%";
                                    case "%s":
                                        return String(s);
                                    case "%d":
                                        return Number(s);
                                    case "%v":
                                        return ""
                                }
                            }))
                        },
                        o = function(e, t, i) {
                            var n = [e + "=" + (t.format instanceof Function ? t.format(t.push ? i : i[t.name]) : t.format)];
                            if (t.names)
                                for (var s = 0; s < t.names.length; s += 1) {
                                    var o = t.names[s];
                                    t.name ? n.push(i[t.name][o]) : n.push(i[t.names[s]])
                                } else n.push(i[t.name]);
                            return r.apply(null, n)
                        },
                        a = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
                        c = ["i", "c", "b", "a"];
                    e.exports = function(e, t) {
                        t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
                            null == e.payloads && (e.payloads = "")
                        }));
                        var i = t.outerOrder || a,
                            s = t.innerOrder || c,
                            r = [];
                        return i.forEach((function(t) {
                            n[t].forEach((function(i) {
                                i.name in e && null != e[i.name] ? r.push(o(t, i, e)) : i.push in e && null != e[i.push] && e[i.push].forEach((function(e) {
                                    r.push(o(t, i, e))
                                }))
                            }))
                        })), e.media.forEach((function(e) {
                            r.push(o("m", n.m[0], e)), s.forEach((function(t) {
                                n[t].forEach((function(i) {
                                    i.name in e && null != e[i.name] ? r.push(o(t, i, e)) : i.push in e && null != e[i.push] && e[i.push].forEach((function(e) {
                                        r.push(o(t, i, e))
                                    }))
                                }))
                            }))
                        })), r.join("\r\n") + "\r\n"
                    }
                },
                5483: e => {
                    "use strict";
                    const t = {
                        generateIdentifier: function() {
                            return Math.random().toString(36).substr(2, 10)
                        }
                    };
                    t.localCName = t.generateIdentifier(), t.splitLines = function(e) {
                        return e.trim().split("\n").map((e => e.trim()))
                    }, t.splitSections = function(e) {
                        return e.split("\nm=").map(((e, t) => (t > 0 ? "m=" + e : e).trim() + "\r\n"))
                    }, t.getDescription = function(e) {
                        const i = t.splitSections(e);
                        return i && i[0]
                    }, t.getMediaSections = function(e) {
                        const i = t.splitSections(e);
                        return i.shift(), i
                    }, t.matchPrefix = function(e, i) {
                        return t.splitLines(e).filter((e => 0 === e.indexOf(i)))
                    }, t.parseCandidate = function(e) {
                        let t;
                        t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" ");
                        const i = {
                            foundation: t[0],
                            component: {
                                1: "rtp",
                                2: "rtcp"
                            } [t[1]] || t[1],
                            protocol: t[2].toLowerCase(),
                            priority: parseInt(t[3], 10),
                            ip: t[4],
                            address: t[4],
                            port: parseInt(t[5], 10),
                            type: t[7]
                        };
                        for (let e = 8; e < t.length; e += 2) switch (t[e]) {
                            case "raddr":
                                i.relatedAddress = t[e + 1];
                                break;
                            case "rport":
                                i.relatedPort = parseInt(t[e + 1], 10);
                                break;
                            case "tcptype":
                                i.tcpType = t[e + 1];
                                break;
                            case "ufrag":
                                i.ufrag = t[e + 1], i.usernameFragment = t[e + 1];
                                break;
                            default:
                                void 0 === i[t[e]] && (i[t[e]] = t[e + 1])
                        }
                        return i
                    }, t.writeCandidate = function(e) {
                        const t = [];
                        t.push(e.foundation);
                        const i = e.component;
                        "rtp" === i ? t.push(1) : "rtcp" === i ? t.push(2) : t.push(i), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port);
                        const n = e.type;
                        return t.push("typ"), t.push(n), "host" !== n && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ")
                    }, t.parseIceOptions = function(e) {
                        return e.substr(14).split(" ")
                    }, t.parseRtpMap = function(e) {
                        let t = e.substr(9).split(" ");
                        const i = {
                            payloadType: parseInt(t.shift(), 10)
                        };
                        return t = t[0].split("/"), i.name = t[0], i.clockRate = parseInt(t[1], 10), i.channels = 3 === t.length ? parseInt(t[2], 10) : 1, i.numChannels = i.channels, i
                    }, t.writeRtpMap = function(e) {
                        let t = e.payloadType;
                        void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);
                        const i = e.channels || e.numChannels || 1;
                        return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== i ? "/" + i : "") + "\r\n"
                    }, t.parseExtmap = function(e) {
                        const t = e.substr(9).split(" ");
                        return {
                            id: parseInt(t[0], 10),
                            direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv",
                            uri: t[1]
                        }
                    }, t.writeExtmap = function(e) {
                        return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n"
                    }, t.parseFmtp = function(e) {
                        const t = {};
                        let i;
                        const n = e.substr(e.indexOf(" ") + 1).split(";");
                        for (let e = 0; e < n.length; e++) i = n[e].trim().split("="), t[i[0].trim()] = i[1];
                        return t
                    }, t.writeFmtp = function(e) {
                        let t = "",
                            i = e.payloadType;
                        if (void 0 !== e.preferredPayloadType && (i = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
                            const n = [];
                            Object.keys(e.parameters).forEach((t => {
                                void 0 !== e.parameters[t] ? n.push(t + "=" + e.parameters[t]) : n.push(t)
                            })), t += "a=fmtp:" + i + " " + n.join(";") + "\r\n"
                        }
                        return t
                    }, t.parseRtcpFb = function(e) {
                        const t = e.substr(e.indexOf(" ") + 1).split(" ");
                        return {
                            type: t.shift(),
                            parameter: t.join(" ")
                        }
                    }, t.writeRtcpFb = function(e) {
                        let t = "",
                            i = e.payloadType;
                        return void 0 !== e.preferredPayloadType && (i = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach((e => {
                            t += "a=rtcp-fb:" + i + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n"
                        })), t
                    }, t.parseSsrcMedia = function(e) {
                        const t = e.indexOf(" "),
                            i = {
                                ssrc: parseInt(e.substr(7, t - 7), 10)
                            },
                            n = e.indexOf(":", t);
                        return n > -1 ? (i.attribute = e.substr(t + 1, n - t - 1), i.value = e.substr(n + 1)) : i.attribute = e.substr(t + 1), i
                    }, t.parseSsrcGroup = function(e) {
                        const t = e.substr(13).split(" ");
                        return {
                            semantics: t.shift(),
                            ssrcs: t.map((e => parseInt(e, 10)))
                        }
                    }, t.getMid = function(e) {
                        const i = t.matchPrefix(e, "a=mid:")[0];
                        if (i) return i.substr(6)
                    }, t.parseFingerprint = function(e) {
                        const t = e.substr(14).split(" ");
                        return {
                            algorithm: t[0].toLowerCase(),
                            value: t[1].toUpperCase()
                        }
                    }, t.getDtlsParameters = function(e, i) {
                        return {
                            role: "auto",
                            fingerprints: t.matchPrefix(e + i, "a=fingerprint:").map(t.parseFingerprint)
                        }
                    }, t.writeDtlsParameters = function(e, t) {
                        let i = "a=setup:" + t + "\r\n";
                        return e.fingerprints.forEach((e => {
                            i += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n"
                        })), i
                    }, t.parseCryptoLine = function(e) {
                        const t = e.substr(9).split(" ");
                        return {
                            tag: parseInt(t[0], 10),
                            cryptoSuite: t[1],
                            keyParams: t[2],
                            sessionParams: t.slice(3)
                        }
                    }, t.writeCryptoLine = function(e) {
                        return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" == typeof e.keyParams ? t.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n"
                    }, t.parseCryptoKeyParams = function(e) {
                        if (0 !== e.indexOf("inline:")) return null;
                        const t = e.substr(7).split("|");
                        return {
                            keyMethod: "inline",
                            keySalt: t[0],
                            lifeTime: t[1],
                            mkiValue: t[2] ? t[2].split(":")[0] : void 0,
                            mkiLength: t[2] ? t[2].split(":")[1] : void 0
                        }
                    }, t.writeCryptoKeyParams = function(e) {
                        return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "")
                    }, t.getCryptoParameters = function(e, i) {
                        return t.matchPrefix(e + i, "a=crypto:").map(t.parseCryptoLine)
                    }, t.getIceParameters = function(e, i) {
                        const n = t.matchPrefix(e + i, "a=ice-ufrag:")[0],
                            s = t.matchPrefix(e + i, "a=ice-pwd:")[0];
                        return n && s ? {
                            usernameFragment: n.substr(12),
                            password: s.substr(10)
                        } : null
                    }, t.writeIceParameters = function(e) {
                        let t = "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n";
                        return e.iceLite && (t += "a=ice-lite\r\n"), t
                    }, t.parseRtpParameters = function(e) {
                        const i = {
                                codecs: [],
                                headerExtensions: [],
                                fecMechanisms: [],
                                rtcp: []
                            },
                            n = t.splitLines(e)[0].split(" ");
                        for (let s = 3; s < n.length; s++) {
                            const r = n[s],
                                o = t.matchPrefix(e, "a=rtpmap:" + r + " ")[0];
                            if (o) {
                                const n = t.parseRtpMap(o),
                                    s = t.matchPrefix(e, "a=fmtp:" + r + " ");
                                switch (n.parameters = s.length ? t.parseFmtp(s[0]) : {}, n.rtcpFeedback = t.matchPrefix(e, "a=rtcp-fb:" + r + " ").map(t.parseRtcpFb), i.codecs.push(n), n.name.toUpperCase()) {
                                    case "RED":
                                    case "ULPFEC":
                                        i.fecMechanisms.push(n.name.toUpperCase())
                                }
                            }
                        }
                        return t.matchPrefix(e, "a=extmap:").forEach((e => {
                            i.headerExtensions.push(t.parseExtmap(e))
                        })), i
                    }, t.writeRtpDescription = function(e, i) {
                        let n = "";
                        n += "m=" + e + " ", n += i.codecs.length > 0 ? "9" : "0", n += " UDP/TLS/RTP/SAVPF ", n += i.codecs.map((e => void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType)).join(" ") + "\r\n", n += "c=IN IP4 0.0.0.0\r\n", n += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i.codecs.forEach((e => {
                            n += t.writeRtpMap(e), n += t.writeFmtp(e), n += t.writeRtcpFb(e)
                        }));
                        let s = 0;
                        return i.codecs.forEach((e => {
                            e.maxptime > s && (s = e.maxptime)
                        })), s > 0 && (n += "a=maxptime:" + s + "\r\n"), i.headerExtensions && i.headerExtensions.forEach((e => {
                            n += t.writeExtmap(e)
                        })), n
                    }, t.parseRtpEncodingParameters = function(e) {
                        const i = [],
                            n = t.parseRtpParameters(e),
                            s = -1 !== n.fecMechanisms.indexOf("RED"),
                            r = -1 !== n.fecMechanisms.indexOf("ULPFEC"),
                            o = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "cname" === e.attribute)),
                            a = o.length > 0 && o[0].ssrc;
                        let c;
                        const d = t.matchPrefix(e, "a=ssrc-group:FID").map((e => e.substr(17).split(" ").map((e => parseInt(e, 10)))));
                        d.length > 0 && d[0].length > 1 && d[0][0] === a && (c = d[0][1]), n.codecs.forEach((e => {
                            if ("RTX" === e.name.toUpperCase() && e.parameters.apt) {
                                let t = {
                                    ssrc: a,
                                    codecPayloadType: parseInt(e.parameters.apt, 10)
                                };
                                a && c && (t.rtx = {
                                    ssrc: c
                                }), i.push(t), s && (t = JSON.parse(JSON.stringify(t)), t.fec = {
                                    ssrc: a,
                                    mechanism: r ? "red+ulpfec" : "red"
                                }, i.push(t))
                            }
                        })), 0 === i.length && a && i.push({
                            ssrc: a
                        });
                        let l = t.matchPrefix(e, "b=");
                        return l.length && (l = 0 === l[0].indexOf("b=TIAS:") ? parseInt(l[0].substr(7), 10) : 0 === l[0].indexOf("b=AS:") ? 1e3 * parseInt(l[0].substr(5), 10) * .95 - 16e3 : void 0, i.forEach((e => {
                            e.maxBitrate = l
                        }))), i
                    }, t.parseRtcpParameters = function(e) {
                        const i = {},
                            n = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "cname" === e.attribute))[0];
                        n && (i.cname = n.value, i.ssrc = n.ssrc);
                        const s = t.matchPrefix(e, "a=rtcp-rsize");
                        i.reducedSize = s.length > 0, i.compound = 0 === s.length;
                        const r = t.matchPrefix(e, "a=rtcp-mux");
                        return i.mux = r.length > 0, i
                    }, t.writeRtcpParameters = function(e) {
                        let t = "";
                        return e.reducedSize && (t += "a=rtcp-rsize\r\n"), e.mux && (t += "a=rtcp-mux\r\n"), void 0 !== e.ssrc && e.cname && (t += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"), t
                    }, t.parseMsid = function(e) {
                        let i;
                        const n = t.matchPrefix(e, "a=msid:");
                        if (1 === n.length) return i = n[0].substr(7).split(" "), {
                            stream: i[0],
                            track: i[1]
                        };
                        const s = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "msid" === e.attribute));
                        return s.length > 0 ? (i = s[0].value.split(" "), {
                            stream: i[0],
                            track: i[1]
                        }) : void 0
                    }, t.parseSctpDescription = function(e) {
                        const i = t.parseMLine(e),
                            n = t.matchPrefix(e, "a=max-message-size:");
                        let s;
                        n.length > 0 && (s = parseInt(n[0].substr(19), 10)), isNaN(s) && (s = 65536);
                        const r = t.matchPrefix(e, "a=sctp-port:");
                        if (r.length > 0) return {
                            port: parseInt(r[0].substr(12), 10),
                            protocol: i.fmt,
                            maxMessageSize: s
                        };
                        const o = t.matchPrefix(e, "a=sctpmap:");
                        if (o.length > 0) {
                            const e = o[0].substr(10).split(" ");
                            return {
                                port: parseInt(e[0], 10),
                                protocol: e[1],
                                maxMessageSize: s
                            }
                        }
                    }, t.writeSctpDescription = function(e, t) {
                        let i = [];
                        return i = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && i.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), i.join("")
                    }, t.generateSessionId = function() {
                        return Math.random().toString().substr(2, 21)
                    }, t.writeSessionBoilerplate = function(e, i, n) {
                        let s;
                        const r = void 0 !== i ? i : 2;
                        return s = e || t.generateSessionId(), "v=0\r\no=" + (n || "thisisadapterortc") + " " + s + " " + r + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"
                    }, t.getDirection = function(e, i) {
                        const n = t.splitLines(e);
                        for (let e = 0; e < n.length; e++) switch (n[e]) {
                            case "a=sendrecv":
                            case "a=sendonly":
                            case "a=recvonly":
                            case "a=inactive":
                                return n[e].substr(2)
                        }
                        return i ? t.getDirection(i) : "sendrecv"
                    }, t.getKind = function(e) {
                        return t.splitLines(e)[0].split(" ")[0].substr(2)
                    }, t.isRejected = function(e) {
                        return "0" === e.split(" ", 2)[1]
                    }, t.parseMLine = function(e) {
                        const i = t.splitLines(e)[0].substr(2).split(" ");
                        return {
                            kind: i[0],
                            port: parseInt(i[1], 10),
                            protocol: i[2],
                            fmt: i.slice(3).join(" ")
                        }
                    }, t.parseOLine = function(e) {
                        const i = t.matchPrefix(e, "o=")[0].substr(2).split(" ");
                        return {
                            username: i[0],
                            sessionId: i[1],
                            sessionVersion: parseInt(i[2], 10),
                            netType: i[3],
                            addressType: i[4],
                            address: i[5]
                        }
                    }, t.isValidSDP = function(e) {
                        if ("string" != typeof e || 0 === e.length) return !1;
                        const i = t.splitLines(e);
                        for (let e = 0; e < i.length; e++)
                            if (i[e].length < 2 || "=" !== i[e].charAt(1)) return !1;
                        return !0
                    }, e.exports = t
                },
                6033: function(e, t, i) {
                    e.exports = function() {
                        "use strict";
                        var e = void 0 !== i.g ? i.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};

                        function t(e) {
                            return t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                return typeof e
                            } : function(e) {
                                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                            }, t(e)
                        }

                        function n(e) {
                            return function(e) {
                                if (Array.isArray(e)) {
                                    for (var t = 0, i = new Array(e.length); t < e.length; t++) i[t] = e[t];
                                    return i
                                }
                            }(e) || function(e) {
                                if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
                            }(e) || function() {
                                throw new TypeError("Invalid attempt to spread non-iterable instance")
                            }()
                        }
                        var s = function(e, t) {
                                var i = (65535 & e) + (65535 & t);
                                return (e >> 16) + (t >> 16) + (i >> 16) << 16 | 65535 & i
                            },
                            r = function(e) {
                                if ("string" != typeof e) throw new Error("str2binl was passed a non-string");
                                for (var t = [], i = 0; i < 8 * e.length; i += 8) t[i >> 5] |= (255 & e.charCodeAt(i / 8)) << i % 32;
                                return t
                            },
                            o = function(e, t, i, n, r, o) {
                                return s((a = s(s(t, e), s(n, o))) << (c = r) | a >>> 32 - c, i);
                                var a, c
                            },
                            a = function(e, t, i, n, s, r, a) {
                                return o(t & i | ~t & n, e, t, s, r, a)
                            },
                            c = function(e, t, i, n, s, r, a) {
                                return o(t & n | i & ~n, e, t, s, r, a)
                            },
                            d = function(e, t, i, n, s, r, a) {
                                return o(t ^ i ^ n, e, t, s, r, a)
                            },
                            l = function(e, t, i, n, s, r, a) {
                                return o(i ^ (t | ~n), e, t, s, r, a)
                            },
                            h = function(e, t) {
                                e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
                                for (var i, n, r, o, h = 1732584193, u = -271733879, p = -1732584194, m = 271733878, f = 0; f < e.length; f += 16) i = h, n = u, r = p, o = m, h = a(h, u, p, m, e[f + 0], 7, -680876936), m = a(m, h, u, p, e[f + 1], 12, -389564586), p = a(p, m, h, u, e[f + 2], 17, 606105819), u = a(u, p, m, h, e[f + 3], 22, -1044525330), h = a(h, u, p, m, e[f + 4], 7, -176418897), m = a(m, h, u, p, e[f + 5], 12, 1200080426), p = a(p, m, h, u, e[f + 6], 17, -1473231341), u = a(u, p, m, h, e[f + 7], 22, -45705983), h = a(h, u, p, m, e[f + 8], 7, 1770035416), m = a(m, h, u, p, e[f + 9], 12, -1958414417), p = a(p, m, h, u, e[f + 10], 17, -42063), u = a(u, p, m, h, e[f + 11], 22, -1990404162), h = a(h, u, p, m, e[f + 12], 7, 1804603682), m = a(m, h, u, p, e[f + 13], 12, -40341101), p = a(p, m, h, u, e[f + 14], 17, -1502002290), u = a(u, p, m, h, e[f + 15], 22, 1236535329), h = c(h, u, p, m, e[f + 1], 5, -165796510), m = c(m, h, u, p, e[f + 6], 9, -1069501632), p = c(p, m, h, u, e[f + 11], 14, 643717713), u = c(u, p, m, h, e[f + 0], 20, -373897302), h = c(h, u, p, m, e[f + 5], 5, -701558691), m = c(m, h, u, p, e[f + 10], 9, 38016083), p = c(p, m, h, u, e[f + 15], 14, -660478335), u = c(u, p, m, h, e[f + 4], 20, -405537848), h = c(h, u, p, m, e[f + 9], 5, 568446438), m = c(m, h, u, p, e[f + 14], 9, -1019803690), p = c(p, m, h, u, e[f + 3], 14, -187363961), u = c(u, p, m, h, e[f + 8], 20, 1163531501), h = c(h, u, p, m, e[f + 13], 5, -1444681467), m = c(m, h, u, p, e[f + 2], 9, -51403784), p = c(p, m, h, u, e[f + 7], 14, 1735328473), u = c(u, p, m, h, e[f + 12], 20, -1926607734), h = d(h, u, p, m, e[f + 5], 4, -378558), m = d(m, h, u, p, e[f + 8], 11, -2022574463), p = d(p, m, h, u, e[f + 11], 16, 1839030562), u = d(u, p, m, h, e[f + 14], 23, -35309556), h = d(h, u, p, m, e[f + 1], 4, -1530992060), m = d(m, h, u, p, e[f + 4], 11, 1272893353), p = d(p, m, h, u, e[f + 7], 16, -155497632), u = d(u, p, m, h, e[f + 10], 23, -1094730640), h = d(h, u, p, m, e[f + 13], 4, 681279174), m = d(m, h, u, p, e[f + 0], 11, -358537222), p = d(p, m, h, u, e[f + 3], 16, -722521979), u = d(u, p, m, h, e[f + 6], 23, 76029189), h = d(h, u, p, m, e[f + 9], 4, -640364487), m = d(m, h, u, p, e[f + 12], 11, -421815835), p = d(p, m, h, u, e[f + 15], 16, 530742520), u = d(u, p, m, h, e[f + 2], 23, -995338651), h = l(h, u, p, m, e[f + 0], 6, -198630844), m = l(m, h, u, p, e[f + 7], 10, 1126891415), p = l(p, m, h, u, e[f + 14], 15, -1416354905), u = l(u, p, m, h, e[f + 5], 21, -57434055), h = l(h, u, p, m, e[f + 12], 6, 1700485571), m = l(m, h, u, p, e[f + 3], 10, -1894986606), p = l(p, m, h, u, e[f + 10], 15, -1051523), u = l(u, p, m, h, e[f + 1], 21, -2054922799), h = l(h, u, p, m, e[f + 8], 6, 1873313359), m = l(m, h, u, p, e[f + 15], 10, -30611744), p = l(p, m, h, u, e[f + 6], 15, -1560198380), u = l(u, p, m, h, e[f + 13], 21, 1309151649), h = l(h, u, p, m, e[f + 4], 6, -145523070), m = l(m, h, u, p, e[f + 11], 10, -1120210379), p = l(p, m, h, u, e[f + 2], 15, 718787259), u = l(u, p, m, h, e[f + 9], 21, -343485551), h = s(h, i), u = s(u, n), p = s(p, r), m = s(m, o);
                                return [h, u, p, m]
                            },
                            u = {
                                hexdigest: function(e) {
                                    return function(e) {
                                        for (var t = "0123456789abcdef", i = "", n = 0; n < 4 * e.length; n++) i += t.charAt(e[n >> 2] >> n % 4 * 8 + 4 & 15) + t.charAt(e[n >> 2] >> n % 4 * 8 & 15);
                                        return i
                                    }(h(r(e), 8 * e.length))
                                },
                                hash: function(e) {
                                    return function(e) {
                                        for (var t = "", i = 0; i < 32 * e.length; i += 8) t += String.fromCharCode(e[i >> 5] >>> i % 32 & 255);
                                        return t
                                    }(h(r(e), 8 * e.length))
                                }
                            };

                        function p(e, t) {
                            e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;
                            var i, n, s, r, o, a, c, d, l = new Array(80),
                                h = 1732584193,
                                u = -271733879,
                                p = -1732584194,
                                g = 271733878,
                                v = -1009589776;
                            for (i = 0; i < e.length; i += 16) {
                                for (r = h, o = u, a = p, c = g, d = v, n = 0; n < 80; n++) l[n] = n < 16 ? e[i + n] : S(l[n - 3] ^ l[n - 8] ^ l[n - 14] ^ l[n - 16], 1), s = _(_(S(h, 5), m(n, u, p, g)), _(_(v, l[n]), f(n))), v = g, g = p, p = S(u, 30), u = h, h = s;
                                h = _(h, r), u = _(u, o), p = _(p, a), g = _(g, c), v = _(v, d)
                            }
                            return [h, u, p, g, v]
                        }

                        function m(e, t, i, n) {
                            return e < 20 ? t & i | ~t & n : e < 40 ? t ^ i ^ n : e < 60 ? t & i | t & n | i & n : t ^ i ^ n
                        }

                        function f(e) {
                            return e < 20 ? 1518500249 : e < 40 ? 1859775393 : e < 60 ? -1894007588 : -899497514
                        }

                        function g(e, t) {
                            var i = v(e);
                            i.length > 16 && (i = p(i, 8 * e.length));
                            for (var n = new Array(16), s = new Array(16), r = 0; r < 16; r++) n[r] = 909522486 ^ i[r], s[r] = 1549556828 ^ i[r];
                            var o = p(n.concat(v(t)), 512 + 8 * t.length);
                            return p(s.concat(o), 672)
                        }

                        function _(e, t) {
                            var i = (65535 & e) + (65535 & t);
                            return (e >> 16) + (t >> 16) + (i >> 16) << 16 | 65535 & i
                        }

                        function S(e, t) {
                            return e << t | e >>> 32 - t
                        }

                        function v(e) {
                            for (var t = [], i = 0; i < 8 * e.length; i += 8) t[i >> 5] |= (255 & e.charCodeAt(i / 8)) << 24 - i % 32;
                            return t
                        }

                        function E(e) {
                            for (var t, i, n = "", s = 0; s < 4 * e.length; s += 3)
                                for (t = (e[s >> 2] >> 8 * (3 - s % 4) & 255) << 16 | (e[s + 1 >> 2] >> 8 * (3 - (s + 1) % 4) & 255) << 8 | e[s + 2 >> 2] >> 8 * (3 - (s + 2) % 4) & 255, i = 0; i < 4; i++) 8 * s + 6 * i > 32 * e.length ? n += "=" : n += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(t >> 6 * (3 - i) & 63);
                            return n
                        }

                        function y(e) {
                            for (var t = "", i = 0; i < 32 * e.length; i += 8) t += String.fromCharCode(e[i >> 5] >>> 24 - i % 32 & 255);
                            return t
                        }
                        var T = {
                                b64_hmac_sha1: function(e, t) {
                                    return E(g(e, t))
                                },
                                b64_sha1: function(e) {
                                    return E(p(v(e), 8 * e.length))
                                },
                                binb2str: y,
                                core_hmac_sha1: g,
                                str_hmac_sha1: function(e, t) {
                                    return y(g(e, t))
                                },
                                str_sha1: function(e) {
                                    return y(p(v(e), 8 * e.length))
                                }
                            },
                            C = function(e) {
                                var t, i, n = "",
                                    s = e.length;
                                for (t = 0; t < s; t++)(i = e.charCodeAt(t)) >= 0 && i <= 127 ? n += e.charAt(t) : i > 2047 ? (n += String.fromCharCode(224 | i >> 12 & 15), n += String.fromCharCode(128 | i >> 6 & 63), n += String.fromCharCode(128 | i >> 0 & 63)) : (n += String.fromCharCode(192 | i >> 6 & 31), n += String.fromCharCode(128 | i >> 0 & 63));
                                return n
                            },
                            b = function(e) {
                                for (var i in e = e || {})
                                    if (Object.prototype.hasOwnProperty.call(e, i)) {
                                        var n = "",
                                            s = "",
                                            r = "",
                                            o = e[i],
                                            a = "object" === t(o),
                                            c = escape(unescape(a ? o.value : o));
                                        a && (n = o.expires ? ";expires=" + o.expires : "", s = o.domain ? ";domain=" + o.domain : "", r = o.path ? ";path=" + o.path : ""), document.cookie = i + "=" + c + n + s + r
                                    }
                            };

                        function R(e, t) {
                            return new I.Builder(e, t)
                        }

                        function A(e) {
                            return new I.Builder("iq", e)
                        }

                        function P(e) {
                            return new I.Builder("presence", e)
                        }
                        var I = {
                            VERSION: "@VERSION@",
                            NS: {
                                HTTPBIND: "http://jabber.org/protocol/httpbind",
                                BOSH: "urn:xmpp:xbosh",
                                CLIENT: "jabber:client",
                                AUTH: "jabber:iq:auth",
                                ROSTER: "jabber:iq:roster",
                                PROFILE: "jabber:iq:profile",
                                DISCO_INFO: "http://jabber.org/protocol/disco#info",
                                DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
                                MUC: "http://jabber.org/protocol/muc",
                                SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
                                STREAM: "http://etherx.jabber.org/streams",
                                FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
                                BIND: "urn:ietf:params:xml:ns:xmpp-bind",
                                SESSION: "urn:ietf:params:xml:ns:xmpp-session",
                                VERSION: "jabber:iq:version",
                                STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
                                XHTML_IM: "http://jabber.org/protocol/xhtml-im",
                                XHTML: "http://www.w3.org/1999/xhtml"
                            },
                            XHTML: {
                                tags: ["a", "blockquote", "br", "cite", "em", "img", "li", "ol", "p", "span", "strong", "ul", "body"],
                                attributes: {
                                    a: ["href"],
                                    blockquote: ["style"],
                                    br: [],
                                    cite: ["style"],
                                    em: [],
                                    img: ["src", "alt", "style", "height", "width"],
                                    li: ["style"],
                                    ol: ["style"],
                                    p: ["style"],
                                    span: ["style"],
                                    strong: [],
                                    ul: ["style"],
                                    body: []
                                },
                                css: ["background-color", "color", "font-family", "font-size", "font-style", "font-weight", "margin-left", "margin-right", "text-align", "text-decoration"],
                                validTag: function(e) {
                                    for (var t = 0; t < I.XHTML.tags.length; t++)
                                        if (e === I.XHTML.tags[t]) return !0;
                                    return !1
                                },
                                validAttribute: function(e, t) {
                                    if (void 0 !== I.XHTML.attributes[e] && I.XHTML.attributes[e].length > 0)
                                        for (var i = 0; i < I.XHTML.attributes[e].length; i++)
                                            if (t === I.XHTML.attributes[e][i]) return !0;
                                    return !1
                                },
                                validCSS: function(e) {
                                    for (var t = 0; t < I.XHTML.css.length; t++)
                                        if (e === I.XHTML.css[t]) return !0;
                                    return !1
                                }
                            },
                            Status: {
                                ERROR: 0,
                                CONNECTING: 1,
                                CONNFAIL: 2,
                                AUTHENTICATING: 3,
                                AUTHFAIL: 4,
                                CONNECTED: 5,
                                DISCONNECTED: 6,
                                DISCONNECTING: 7,
                                ATTACHED: 8,
                                REDIRECT: 9,
                                CONNTIMEOUT: 10,
                                BINDREQUIRED: 11
                            },
                            ErrorCondition: {
                                BAD_FORMAT: "bad-format",
                                CONFLICT: "conflict",
                                MISSING_JID_NODE: "x-strophe-bad-non-anon-jid",
                                NO_AUTH_MECH: "no-auth-mech",
                                UNKNOWN_REASON: "unknown"
                            },
                            LogLevel: {
                                DEBUG: 0,
                                INFO: 1,
                                WARN: 2,
                                ERROR: 3,
                                FATAL: 4
                            },
                            ElementType: {
                                NORMAL: 1,
                                TEXT: 3,
                                CDATA: 4,
                                FRAGMENT: 11
                            },
                            TIMEOUT: 1.1,
                            SECONDARY_TIMEOUT: .1,
                            addNamespace: function(e, t) {
                                I.NS[e] = t
                            },
                            forEachChild: function(e, t, i) {
                                for (var n = 0; n < e.childNodes.length; n++) {
                                    var s = e.childNodes[n];
                                    s.nodeType !== I.ElementType.NORMAL || t && !this.isTagEqual(s, t) || i(s)
                                }
                            },
                            isTagEqual: function(e, t) {
                                return e.tagName === t
                            },
                            _xmlGenerator: null,
                            _makeGenerator: function() {
                                var e;
                                return void 0 === document.implementation.createDocument || document.implementation.createDocument && document.documentMode && document.documentMode < 10 ? (e = this._getIEXmlDom()).appendChild(e.createElement("strophe")) : e = document.implementation.createDocument("jabber:client", "strophe", null), e
                            },
                            xmlGenerator: function() {
                                return I._xmlGenerator || (I._xmlGenerator = I._makeGenerator()), I._xmlGenerator
                            },
                            _getIEXmlDom: function() {
                                for (var e = null, t = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"], i = 0; i < t.length && null === e; i++) try {
                                    e = new ActiveXObject(t[i])
                                } catch (t) {
                                    e = null
                                }
                                return e
                            },
                            xmlElement: function(e) {
                                if (!e) return null;
                                for (var i = I.xmlGenerator().createElement(e), n = 1; n < arguments.length; n++) {
                                    var s = arguments[n];
                                    if (s)
                                        if ("string" == typeof s || "number" == typeof s) i.appendChild(I.xmlTextNode(s));
                                        else if ("object" === t(s) && "function" == typeof s.sort)
                                        for (var r = 0; r < s.length; r++) {
                                            var o = s[r];
                                            "object" === t(o) && "function" == typeof o.sort && void 0 !== o[1] && null !== o[1] && i.setAttribute(o[0], o[1])
                                        } else if ("object" === t(s))
                                            for (var a in s) Object.prototype.hasOwnProperty.call(s, a) && void 0 !== s[a] && null !== s[a] && i.setAttribute(a, s[a])
                                }
                                return i
                            },
                            xmlescape: function(e) {
                                return (e = (e = (e = (e = e.replace(/\&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/'/g, "&apos;")).replace(/"/g, "&quot;")
                            },
                            xmlunescape: function(e) {
                                return (e = (e = (e = (e = e.replace(/\&amp;/g, "&")).replace(/&lt;/g, "<")).replace(/&gt;/g, ">")).replace(/&apos;/g, "'")).replace(/&quot;/g, '"')
                            },
                            xmlTextNode: function(e) {
                                return I.xmlGenerator().createTextNode(e)
                            },
                            xmlHtmlNode: function(e) {
                                var t;
                                return DOMParser ? t = (new DOMParser).parseFromString(e, "text/xml") : ((t = new ActiveXObject("Microsoft.XMLDOM")).async = "false", t.loadXML(e)), t
                            },
                            getText: function(e) {
                                if (!e) return null;
                                var t = "";
                                0 === e.childNodes.length && e.nodeType === I.ElementType.TEXT && (t += e.nodeValue);
                                for (var i = 0; i < e.childNodes.length; i++) e.childNodes[i].nodeType === I.ElementType.TEXT && (t += e.childNodes[i].nodeValue);
                                return I.xmlescape(t)
                            },
                            copyElement: function(e) {
                                var t;
                                if (e.nodeType === I.ElementType.NORMAL) {
                                    t = I.xmlElement(e.tagName);
                                    for (var i = 0; i < e.attributes.length; i++) t.setAttribute(e.attributes[i].nodeName, e.attributes[i].value);
                                    for (var n = 0; n < e.childNodes.length; n++) t.appendChild(I.copyElement(e.childNodes[n]))
                                } else e.nodeType === I.ElementType.TEXT && (t = I.xmlGenerator().createTextNode(e.nodeValue));
                                return t
                            },
                            createHtml: function(e) {
                                var i;
                                if (e.nodeType === I.ElementType.NORMAL) {
                                    var n = e.nodeName.toLowerCase();
                                    if (I.XHTML.validTag(n)) try {
                                        i = I.xmlElement(n);
                                        for (var s = 0; s < I.XHTML.attributes[n].length; s++) {
                                            var r = I.XHTML.attributes[n][s],
                                                o = e.getAttribute(r);
                                            if (null != o && "" !== o && !1 !== o && 0 !== o)
                                                if ("style" === r && "object" === t(o) && void 0 !== o.cssText && (o = o.cssText), "style" === r) {
                                                    for (var a = [], c = o.split(";"), d = 0; d < c.length; d++) {
                                                        var l = c[d].split(":"),
                                                            h = l[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                                        if (I.XHTML.validCSS(h)) {
                                                            var u = l[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                                            a.push(h + ": " + u)
                                                        }
                                                    }
                                                    a.length > 0 && (o = a.join("; "), i.setAttribute(r, o))
                                                } else i.setAttribute(r, o)
                                        }
                                        for (var p = 0; p < e.childNodes.length; p++) i.appendChild(I.createHtml(e.childNodes[p]))
                                    } catch (e) {
                                        i = I.xmlTextNode("")
                                    } else {
                                        i = I.xmlGenerator().createDocumentFragment();
                                        for (var m = 0; m < e.childNodes.length; m++) i.appendChild(I.createHtml(e.childNodes[m]))
                                    }
                                } else if (e.nodeType === I.ElementType.FRAGMENT) {
                                    i = I.xmlGenerator().createDocumentFragment();
                                    for (var f = 0; f < e.childNodes.length; f++) i.appendChild(I.createHtml(e.childNodes[f]))
                                } else e.nodeType === I.ElementType.TEXT && (i = I.xmlTextNode(e.nodeValue));
                                return i
                            },
                            escapeNode: function(e) {
                                return "string" != typeof e ? e : e.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40")
                            },
                            unescapeNode: function(e) {
                                return "string" != typeof e ? e : e.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\")
                            },
                            getNodeFromJid: function(e) {
                                return e.indexOf("@") < 0 ? null : e.split("@")[0]
                            },
                            getDomainFromJid: function(e) {
                                var t = I.getBareJidFromJid(e);
                                if (t.indexOf("@") < 0) return t;
                                var i = t.split("@");
                                return i.splice(0, 1), i.join("@")
                            },
                            getResourceFromJid: function(e) {
                                if (!e) return null;
                                var t = e.split("/");
                                return t.length < 2 ? null : (t.splice(0, 1), t.join("/"))
                            },
                            getBareJidFromJid: function(e) {
                                return e ? e.split("/")[0] : null
                            },
                            _handleError: function(e) {
                                void 0 !== e.stack && I.fatal(e.stack), e.sourceURL ? I.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message) : e.fileName ? I.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message) : I.fatal("error: " + e.message)
                            },
                            log: function(e, i) {
                                e === this.LogLevel.FATAL && "object" === t(window.console) && "function" == typeof window.console.error && window.console.error(i)
                            },
                            debug: function(e) {
                                this.log(this.LogLevel.DEBUG, e)
                            },
                            info: function(e) {
                                this.log(this.LogLevel.INFO, e)
                            },
                            warn: function(e) {
                                this.log(this.LogLevel.WARN, e)
                            },
                            error: function(e) {
                                this.log(this.LogLevel.ERROR, e)
                            },
                            fatal: function(e) {
                                this.log(this.LogLevel.FATAL, e)
                            },
                            serialize: function(e) {
                                if (!e) return null;
                                "function" == typeof e.tree && (e = e.tree());
                                var t = n(Array(e.attributes.length).keys()).map((function(t) {
                                    return e.attributes[t].nodeName
                                }));
                                t.sort();
                                var i = t.reduce((function(t, i) {
                                    return "".concat(t, " ").concat(i, '="').concat(I.xmlescape(e.attributes.getNamedItem(i).value), '"')
                                }), "<".concat(e.nodeName));
                                if (e.childNodes.length > 0) {
                                    i += ">";
                                    for (var s = 0; s < e.childNodes.length; s++) {
                                        var r = e.childNodes[s];
                                        switch (r.nodeType) {
                                            case I.ElementType.NORMAL:
                                                i += I.serialize(r);
                                                break;
                                            case I.ElementType.TEXT:
                                                i += I.xmlescape(r.nodeValue);
                                                break;
                                            case I.ElementType.CDATA:
                                                i += "<![CDATA[" + r.nodeValue + "]]>"
                                        }
                                    }
                                    i += "</" + e.nodeName + ">"
                                } else i += "/>";
                                return i
                            },
                            _requestId: 0,
                            _connectionPlugins: {},
                            addConnectionPlugin: function(e, t) {
                                I._connectionPlugins[e] = t
                            },
                            Builder: function(e, t) {
                                "presence" !== e && "message" !== e && "iq" !== e || (t && !t.xmlns ? t.xmlns = I.NS.CLIENT : t || (t = {
                                    xmlns: I.NS.CLIENT
                                })), this.nodeTree = I.xmlElement(e, t), this.node = this.nodeTree
                            }
                        };
                        I.Builder.prototype = {
                            tree: function() {
                                return this.nodeTree
                            },
                            toString: function() {
                                return I.serialize(this.nodeTree)
                            },
                            up: function() {
                                return this.node = this.node.parentNode, this
                            },
                            root: function() {
                                return this.node = this.nodeTree, this
                            },
                            attrs: function(e) {
                                for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (void 0 === e[t] ? this.node.removeAttribute(t) : this.node.setAttribute(t, e[t]));
                                return this
                            },
                            c: function(e, t, i) {
                                var n = I.xmlElement(e, t, i);
                                return this.node.appendChild(n), "string" != typeof i && "number" != typeof i && (this.node = n), this
                            },
                            cnode: function(e) {
                                var t, i = I.xmlGenerator();
                                try {
                                    t = void 0 !== i.importNode
                                } catch (e) {
                                    t = !1
                                }
                                var n = t ? i.importNode(e, !0) : I.copyElement(e);
                                return this.node.appendChild(n), this.node = n, this
                            },
                            t: function(e) {
                                var t = I.xmlTextNode(e);
                                return this.node.appendChild(t), this
                            },
                            h: function(e) {
                                var t = document.createElement("body");
                                t.innerHTML = e;
                                for (var i = I.createHtml(t); i.childNodes.length > 0;) this.node.appendChild(i.childNodes[0]);
                                return this
                            }
                        }, I.Handler = function(e, t, i, n, s, r, o) {
                            this.handler = e, this.ns = t, this.name = i, this.type = n, this.id = s, this.options = o || {
                                matchBareFromJid: !1,
                                ignoreNamespaceFragment: !1
                            }, this.options.matchBare && (I.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.'), this.options.matchBareFromJid = this.options.matchBare, delete this.options.matchBare), this.options.matchBareFromJid ? this.from = r ? I.getBareJidFromJid(r) : null : this.from = r, this.user = !0
                        }, I.Handler.prototype = {
                            getNamespace: function(e) {
                                var t = e.getAttribute("xmlns");
                                return t && this.options.ignoreNamespaceFragment && (t = t.split("#")[0]), t
                            },
                            namespaceMatch: function(e) {
                                var t = this,
                                    i = !1;
                                return !this.ns || (I.forEachChild(e, null, (function(e) {
                                    t.getNamespace(e) === t.ns && (i = !0)
                                })), i || this.getNamespace(e) === this.ns)
                            },
                            isMatch: function(e) {
                                var t = e.getAttribute("from");
                                this.options.matchBareFromJid && (t = I.getBareJidFromJid(t));
                                var i = e.getAttribute("type");
                                return !(!this.namespaceMatch(e) || this.name && !I.isTagEqual(e, this.name) || this.type && (Array.isArray(this.type) ? -1 === this.type.indexOf(i) : i !== this.type) || this.id && e.getAttribute("id") !== this.id || this.from && t !== this.from)
                            },
                            run: function(e) {
                                var t = null;
                                try {
                                    t = this.handler(e)
                                } catch (e) {
                                    throw I._handleError(e), e
                                }
                                return t
                            },
                            toString: function() {
                                return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}"
                            }
                        }, I.TimedHandler = function(e, t) {
                            this.period = e, this.handler = t, this.lastCalled = (new Date).getTime(), this.user = !0
                        }, I.TimedHandler.prototype = {
                            run: function() {
                                return this.lastCalled = (new Date).getTime(), this.handler()
                            },
                            reset: function() {
                                this.lastCalled = (new Date).getTime()
                            },
                            toString: function() {
                                return "{TimedHandler: " + this.handler + "(" + this.period + ")}"
                            }
                        }, I.Connection = function(e, t) {
                            var i = this;
                            this.service = e, this.options = t || {};
                            var n = this.options.protocol || "";
                            for (var s in 0 === e.indexOf("ws:") || 0 === e.indexOf("wss:") || 0 === n.indexOf("ws") ? this._proto = new I.Websocket(this) : this._proto = new I.Bosh(this), this.jid = "", this.domain = null, this.features = null, this._sasl_data = {}, this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.protocolErrorHandlers = {
                                    HTTP: {},
                                    websocket: {}
                                }, this._idleTimeout = null, this._disconnectTimeout = null, this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.do_authentication = !0, this.paused = !1, this.restored = !1, this._data = [], this._uniqueId = 0, this._sasl_success_handler = null, this._sasl_failure_handler = null, this._sasl_challenge_handler = null, this.maxRetries = 5, this._idleTimeout = setTimeout((function() {
                                    return i._onIdle()
                                }), 100), b(this.options.cookies), this.registerSASLMechanisms(this.options.mechanisms), I._connectionPlugins)
                                if (Object.prototype.hasOwnProperty.call(I._connectionPlugins, s)) {
                                    var r = function() {};
                                    r.prototype = I._connectionPlugins[s], this[s] = new r, this[s].init(this)
                                }
                        }, I.Connection.prototype = {
                            reset: function() {
                                this._proto._reset(), this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.restored = !1, this._data = [], this._requests = [], this._uniqueId = 0
                            },
                            pause: function() {
                                this.paused = !0
                            },
                            resume: function() {
                                this.paused = !1
                            },
                            getUniqueId: function(e) {
                                var t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
                                    var t = 16 * Math.random() | 0;
                                    return ("x" === e ? t : 3 & t | 8).toString(16)
                                }));
                                return "string" == typeof e || "number" == typeof e ? t + ":" + e : t + ""
                            },
                            addProtocolErrorHandler: function(e, t, i) {
                                this.protocolErrorHandlers[e][t] = i
                            },
                            connect: function(e, t, i, n, s, r, o) {
                                this.jid = e, this.authzid = I.getBareJidFromJid(this.jid), this.authcid = o || I.getNodeFromJid(this.jid), this.pass = t, this.servtype = "xmpp", this.connect_callback = i, this.disconnecting = !1, this.connected = !1, this.authenticated = !1, this.restored = !1, this.domain = I.getDomainFromJid(this.jid), this._changeConnectStatus(I.Status.CONNECTING, null), this._proto._connect(n, s, r)
                            },
                            attach: function(e, t, i, n, s, r, o) {
                                if (!(this._proto instanceof I.Bosh)) {
                                    var a = new Error('The "attach" method can only be used with a BOSH connection.');
                                    throw a.name = "StropheSessionError", a
                                }
                                this._proto._attach(e, t, i, n, s, r, o)
                            },
                            restore: function(e, t, i, n, s) {
                                if (!this._sessionCachingSupported()) {
                                    var r = new Error('The "restore" method can only be used with a BOSH connection.');
                                    throw r.name = "StropheSessionError", r
                                }
                                this._proto._restore(e, t, i, n, s)
                            },
                            _sessionCachingSupported: function() {
                                if (this._proto instanceof I.Bosh) {
                                    if (!JSON) return !1;
                                    try {
                                        sessionStorage.setItem("_strophe_", "_strophe_"), sessionStorage.removeItem("_strophe_")
                                    } catch (e) {
                                        return !1
                                    }
                                    return !0
                                }
                                return !1
                            },
                            xmlInput: function(e) {},
                            xmlOutput: function(e) {},
                            rawInput: function(e) {},
                            rawOutput: function(e) {},
                            nextValidRid: function(e) {},
                            send: function(e) {
                                if (null !== e) {
                                    if ("function" == typeof e.sort)
                                        for (var t = 0; t < e.length; t++) this._queueData(e[t]);
                                    else "function" == typeof e.tree ? this._queueData(e.tree()) : this._queueData(e);
                                    this._proto._send()
                                }
                            },
                            flush: function() {
                                clearTimeout(this._idleTimeout), this._onIdle()
                            },
                            sendPresence: function(e, t, i, n) {
                                var s = this,
                                    r = null;
                                "function" == typeof e.tree && (e = e.tree());
                                var o = e.getAttribute("id");
                                if (o || (o = this.getUniqueId("sendPresence"), e.setAttribute("id", o)), "function" == typeof t || "function" == typeof i) {
                                    var a = this.addHandler((function(e) {
                                        r && s.deleteTimedHandler(r), "error" === e.getAttribute("type") ? i && i(e) : t && t(e)
                                    }), null, "presence", null, o);
                                    n && (r = this.addTimedHandler(n, (function() {
                                        return s.deleteHandler(a), i && i(null), !1
                                    })))
                                }
                                return this.send(e), o
                            },
                            sendIQ: function(e, t, i, n) {
                                var s = this,
                                    r = null;
                                "function" == typeof e.tree && (e = e.tree());
                                var o = e.getAttribute("id");
                                if (o || (o = this.getUniqueId("sendIQ"), e.setAttribute("id", o)), "function" == typeof t || "function" == typeof i) {
                                    var a = this.addHandler((function(e) {
                                        r && s.deleteTimedHandler(r);
                                        var n = e.getAttribute("type");
                                        if ("result" === n) t && t(e);
                                        else {
                                            if ("error" !== n) {
                                                var o = new Error("Got bad IQ type of ".concat(n));
                                                throw o.name = "StropheError", o
                                            }
                                            i && i(e)
                                        }
                                    }), null, "iq", ["error", "result"], o);
                                    n && (r = this.addTimedHandler(n, (function() {
                                        return s.deleteHandler(a), i && i(null), !1
                                    })))
                                }
                                return this.send(e), o
                            },
                            _queueData: function(e) {
                                if (null === e || !e.tagName || !e.childNodes) {
                                    var t = new Error("Cannot queue non-DOMElement.");
                                    throw t.name = "StropheError", t
                                }
                                this._data.push(e)
                            },
                            _sendRestart: function() {
                                var e = this;
                                this._data.push("restart"), this._proto._sendRestart(), this._idleTimeout = setTimeout((function() {
                                    return e._onIdle()
                                }), 100)
                            },
                            addTimedHandler: function(e, t) {
                                var i = new I.TimedHandler(e, t);
                                return this.addTimeds.push(i), i
                            },
                            deleteTimedHandler: function(e) {
                                this.removeTimeds.push(e)
                            },
                            addHandler: function(e, t, i, n, s, r, o) {
                                var a = new I.Handler(e, t, i, n, s, r, o);
                                return this.addHandlers.push(a), a
                            },
                            deleteHandler: function(e) {
                                this.removeHandlers.push(e);
                                var t = this.addHandlers.indexOf(e);
                                t >= 0 && this.addHandlers.splice(t, 1)
                            },
                            registerSASLMechanisms: function(e) {
                                this.mechanisms = {}, (e = e || [I.SASLAnonymous, I.SASLExternal, I.SASLMD5, I.SASLOAuthBearer, I.SASLXOAuth2, I.SASLPlain, I.SASLSHA1]).forEach(this.registerSASLMechanism.bind(this))
                            },
                            registerSASLMechanism: function(e) {
                                this.mechanisms[e.prototype.name] = e
                            },
                            disconnect: function(e) {
                                if (this._changeConnectStatus(I.Status.DISCONNECTING, e), I.warn("Disconnect was called because: " + e), this.connected) {
                                    var t = !1;
                                    this.disconnecting = !0, this.authenticated && (t = P({
                                        xmlns: I.NS.CLIENT,
                                        type: "unavailable"
                                    })), this._disconnectTimeout = this._addSysTimedHandler(3e3, this._onDisconnectTimeout.bind(this)), this._proto._disconnect(t)
                                } else I.warn("Disconnect was called before Strophe connected to the server"), this._proto._abortAllRequests(), this._doDisconnect()
                            },
                            _changeConnectStatus: function(e, t, i) {
                                for (var n in I._connectionPlugins)
                                    if (Object.prototype.hasOwnProperty.call(I._connectionPlugins, n)) {
                                        var s = this[n];
                                        if (s.statusChanged) try {
                                            s.statusChanged(e, t)
                                        } catch (e) {
                                            I.error("".concat(n, " plugin caused an exception changing status: ").concat(e))
                                        }
                                    } if (this.connect_callback) try {
                                    this.connect_callback(e, t, i)
                                } catch (e) {
                                    I._handleError(e), I.error("User connection callback caused an exception: ".concat(e))
                                }
                            },
                            _doDisconnect: function(e) {
                                "number" == typeof this._idleTimeout && clearTimeout(this._idleTimeout), null !== this._disconnectTimeout && (this.deleteTimedHandler(this._disconnectTimeout), this._disconnectTimeout = null), I.debug("_doDisconnect was called"), this._proto._doDisconnect(), this.authenticated = !1, this.disconnecting = !1, this.restored = !1, this.handlers = [], this.timedHandlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this._changeConnectStatus(I.Status.DISCONNECTED, e), this.connected = !1
                            },
                            _dataRecv: function(e, t) {
                                var i = this;
                                I.debug("_dataRecv called");
                                var n = this._proto._reqToData(e);
                                if (null !== n) {
                                    for (this.xmlInput !== I.Connection.prototype.xmlInput && (n.nodeName === this._proto.strip && n.childNodes.length ? this.xmlInput(n.childNodes[0]) : this.xmlInput(n)), this.rawInput !== I.Connection.prototype.rawInput && (t ? this.rawInput(t) : this.rawInput(I.serialize(n))); this.removeHandlers.length > 0;) {
                                        var s = this.removeHandlers.pop(),
                                            r = this.handlers.indexOf(s);
                                        r >= 0 && this.handlers.splice(r, 1)
                                    }
                                    for (; this.addHandlers.length > 0;) this.handlers.push(this.addHandlers.pop());
                                    if (this.disconnecting && this._proto._emptyQueue()) this._doDisconnect();
                                    else {
                                        var o = n.getAttribute("type");
                                        if (null !== o && "terminate" === o) {
                                            if (this.disconnecting) return;
                                            var a = n.getAttribute("condition"),
                                                c = n.getElementsByTagName("conflict");
                                            return null !== a ? ("remote-stream-error" === a && c.length > 0 && (a = "conflict"), this._changeConnectStatus(I.Status.CONNFAIL, a)) : this._changeConnectStatus(I.Status.CONNFAIL, I.ErrorCondition.UNKOWN_REASON), void this._doDisconnect(a)
                                        }
                                        I.forEachChild(n, null, (function(e) {
                                            var t = i.handlers;
                                            i.handlers = [];
                                            for (var n = 0; n < t.length; n++) {
                                                var s = t[n];
                                                try {
                                                    (!s.isMatch(e) || !i.authenticated && s.user || s.run(e)) && i.handlers.push(s)
                                                } catch (e) {
                                                    I.warn("Removing Strophe handlers due to uncaught exception: " + e.message)
                                                }
                                            }
                                        }))
                                    }
                                }
                            },
                            mechanisms: {},
                            _connect_cb: function(e, t, i) {
                                var n;
                                I.debug("_connect_cb was called"), this.connected = !0;
                                try {
                                    n = this._proto._reqToData(e)
                                } catch (e) {
                                    if (e.name !== I.ErrorCondition.BAD_FORMAT) throw e;
                                    this._changeConnectStatus(I.Status.CONNFAIL, I.ErrorCondition.BAD_FORMAT), this._doDisconnect(I.ErrorCondition.BAD_FORMAT)
                                }
                                if (n && (this.xmlInput !== I.Connection.prototype.xmlInput && (n.nodeName === this._proto.strip && n.childNodes.length ? this.xmlInput(n.childNodes[0]) : this.xmlInput(n)), this.rawInput !== I.Connection.prototype.rawInput && (i ? this.rawInput(i) : this.rawInput(I.serialize(n))), this._proto._connect_cb(n) !== I.Status.CONNFAIL))
                                    if (n.getElementsByTagNameNS ? n.getElementsByTagNameNS(I.NS.STREAM, "features").length > 0 : n.getElementsByTagName("stream:features").length > 0 || n.getElementsByTagName("features").length > 0) {
                                        var s = [],
                                            r = n.getElementsByTagName("mechanism");
                                        if (r.length > 0)
                                            for (var o = 0; o < r.length; o++) {
                                                var a = I.getText(r[o]);
                                                this.mechanisms[a] && s.push(this.mechanisms[a])
                                            }
                                        0 !== s.length || 0 !== n.getElementsByTagName("auth").length ? !1 !== this.do_authentication && this.authenticate(s) : this._proto._no_auth_received(t)
                                    } else this._proto._no_auth_received(t)
                            },
                            sortMechanismsByPriority: function(e) {
                                for (var t = 0; t < e.length - 1; ++t) {
                                    for (var i = t, n = t + 1; n < e.length; ++n) e[n].prototype.priority > e[i].prototype.priority && (i = n);
                                    if (i !== t) {
                                        var s = e[t];
                                        e[t] = e[i], e[i] = s
                                    }
                                }
                                return e
                            },
                            authenticate: function(e) {
                                this._attemptSASLAuth(e) || this._attemptLegacyAuth()
                            },
                            _attemptSASLAuth: function(e) {
                                e = this.sortMechanismsByPriority(e || []);
                                for (var t = !1, i = 0; i < e.length; ++i)
                                    if (e[i].prototype.test(this)) {
                                        this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null), this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null), this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null), this._sasl_mechanism = new e[i], this._sasl_mechanism.onStart(this);
                                        var n = R("auth", {
                                            xmlns: I.NS.SASL,
                                            mechanism: this._sasl_mechanism.name
                                        });
                                        if (this._sasl_mechanism.isClientFirst) {
                                            var s = this._sasl_mechanism.onChallenge(this, null);
                                            n.t(btoa(s))
                                        }
                                        this.send(n.tree()), t = !0;
                                        break
                                    } return t
                            },
                            _sasl_challenge_cb: function(e) {
                                var t = atob(I.getText(e)),
                                    i = this._sasl_mechanism.onChallenge(this, t),
                                    n = R("response", {
                                        xmlns: I.NS.SASL
                                    });
                                return "" !== i && n.t(btoa(i)), this.send(n.tree()), !0
                            },
                            _attemptLegacyAuth: function() {
                                null === I.getNodeFromJid(this.jid) ? (this._changeConnectStatus(I.Status.CONNFAIL, I.ErrorCondition.MISSING_JID_NODE), this.disconnect(I.ErrorCondition.MISSING_JID_NODE)) : (this._changeConnectStatus(I.Status.AUTHENTICATING, null), this._addSysHandler(this._onLegacyAuthIQResult.bind(this), null, null, null, "_auth_1"), this.send(A({
                                    type: "get",
                                    to: this.domain,
                                    id: "_auth_1"
                                }).c("query", {
                                    xmlns: I.NS.AUTH
                                }).c("username", {}).t(I.getNodeFromJid(this.jid)).tree()))
                            },
                            _onLegacyAuthIQResult: function(e) {
                                var t = A({
                                    type: "set",
                                    id: "_auth_2"
                                }).c("query", {
                                    xmlns: I.NS.AUTH
                                }).c("username", {}).t(I.getNodeFromJid(this.jid)).up().c("password").t(this.pass);
                                return I.getResourceFromJid(this.jid) || (this.jid = I.getBareJidFromJid(this.jid) + "/strophe"), t.up().c("resource", {}).t(I.getResourceFromJid(this.jid)), this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2"), this.send(t.tree()), !1
                            },
                            _sasl_success_cb: function(e) {
                                var t = this;
                                if (this._sasl_data["server-signature"]) {
                                    var i, n = atob(I.getText(e)).match(/([a-z]+)=([^,]+)(,|$)/);
                                    if ("v" === n[1] && (i = n[2]), i !== this._sasl_data["server-signature"]) return this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_data = {}, this._sasl_failure_cb(null)
                                }
                                I.info("SASL authentication succeeded."), this._sasl_mechanism && this._sasl_mechanism.onSuccess(), this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null);
                                var s = [],
                                    r = function(e, i) {
                                        for (; e.length;) t.deleteHandler(e.pop());
                                        return t._onStreamFeaturesAfterSASL(i), !1
                                    };
                                return s.push(this._addSysHandler((function(e) {
                                    return r(s, e)
                                }), null, "stream:features", null, null)), s.push(this._addSysHandler((function(e) {
                                    return r(s, e)
                                }), I.NS.STREAM, "features", null, null)), this._sendRestart(), !1
                            },
                            _onStreamFeaturesAfterSASL: function(e) {
                                this.features = e;
                                for (var t = 0; t < e.childNodes.length; t++) {
                                    var i = e.childNodes[t];
                                    "bind" === i.nodeName && (this.do_bind = !0), "session" === i.nodeName && (this.do_session = !0)
                                }
                                return this.do_bind ? (this.options.explicitResourceBinding ? this._changeConnectStatus(I.Status.BINDREQUIRED, null) : this.bind(), !1) : (this._changeConnectStatus(I.Status.AUTHFAIL, null), !1)
                            },
                            bind: function() {
                                if (this.do_bind) {
                                    this._addSysHandler(this._onResourceBindResultIQ.bind(this), null, null, null, "_bind_auth_2");
                                    var e = I.getResourceFromJid(this.jid);
                                    e ? this.send(A({
                                        type: "set",
                                        id: "_bind_auth_2"
                                    }).c("bind", {
                                        xmlns: I.NS.BIND
                                    }).c("resource", {}).t(e).tree()) : this.send(A({
                                        type: "set",
                                        id: "_bind_auth_2"
                                    }).c("bind", {
                                        xmlns: I.NS.BIND
                                    }).tree())
                                } else I.log(I.LogLevel.INFO, 'Strophe.Connection.prototype.bind called but "do_bind" is false')
                            },
                            _onResourceBindResultIQ: function(e) {
                                var t;
                                if ("error" === e.getAttribute("type")) return I.warn("Resource binding failed."), e.getElementsByTagName("conflict").length > 0 && (t = I.ErrorCondition.CONFLICT), this._changeConnectStatus(I.Status.AUTHFAIL, t, e), !1;
                                var i = e.getElementsByTagName("bind");
                                if (!(i.length > 0)) return I.warn("Resource binding failed."), this._changeConnectStatus(I.Status.AUTHFAIL, null, e), !1;
                                var n = i[0].getElementsByTagName("jid");
                                n.length > 0 && (this.jid = I.getText(n[0]), this.do_session ? this._establishSession() : (this.authenticated = !0, this._changeConnectStatus(I.Status.CONNECTED, null)))
                            },
                            _establishSession: function() {
                                if (!this.do_session) throw new Error("Strophe.Connection.prototype._establishSession " + "called but apparently ".concat(I.NS.SESSION, " wasn't advertised by the server"));
                                this._addSysHandler(this._onSessionResultIQ.bind(this), null, null, null, "_session_auth_2"), this.send(A({
                                    type: "set",
                                    id: "_session_auth_2"
                                }).c("session", {
                                    xmlns: I.NS.SESSION
                                }).tree())
                            },
                            _onSessionResultIQ: function(e) {
                                if ("result" === e.getAttribute("type")) this.authenticated = !0, this._changeConnectStatus(I.Status.CONNECTED, null);
                                else if ("error" === e.getAttribute("type")) return I.warn("Session creation failed."), this._changeConnectStatus(I.Status.AUTHFAIL, null, e), !1;
                                return !1
                            },
                            _sasl_failure_cb: function(e) {
                                return this._sasl_success_handler && (this.deleteHandler(this._sasl_success_handler), this._sasl_success_handler = null), this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_mechanism && this._sasl_mechanism.onFailure(), this._changeConnectStatus(I.Status.AUTHFAIL, null, e), !1
                            },
                            _auth2_cb: function(e) {
                                return "result" === e.getAttribute("type") ? (this.authenticated = !0, this._changeConnectStatus(I.Status.CONNECTED, null)) : "error" === e.getAttribute("type") && (this._changeConnectStatus(I.Status.AUTHFAIL, null, e), this.disconnect("authentication failed")), !1
                            },
                            _addSysTimedHandler: function(e, t) {
                                var i = new I.TimedHandler(e, t);
                                return i.user = !1, this.addTimeds.push(i), i
                            },
                            _addSysHandler: function(e, t, i, n, s) {
                                var r = new I.Handler(e, t, i, n, s);
                                return r.user = !1, this.addHandlers.push(r), r
                            },
                            _onDisconnectTimeout: function() {
                                return I.debug("_onDisconnectTimeout was called"), this._changeConnectStatus(I.Status.CONNTIMEOUT, null), this._proto._onDisconnectTimeout(), this._doDisconnect(), !1
                            },
                            _onIdle: function() {
                                for (var e = this; this.addTimeds.length > 0;) this.timedHandlers.push(this.addTimeds.pop());
                                for (; this.removeTimeds.length > 0;) {
                                    var t = this.removeTimeds.pop(),
                                        i = this.timedHandlers.indexOf(t);
                                    i >= 0 && this.timedHandlers.splice(i, 1)
                                }
                                for (var n = (new Date).getTime(), s = [], r = 0; r < this.timedHandlers.length; r++) {
                                    var o = this.timedHandlers[r];
                                    !this.authenticated && o.user || (o.lastCalled + o.period - n <= 0 ? o.run() && s.push(o) : s.push(o))
                                }
                                this.timedHandlers = s, clearTimeout(this._idleTimeout), this._proto._onIdle(), this.connected && (this._idleTimeout = setTimeout((function() {
                                    return e._onIdle()
                                }), 100))
                            }
                        }, I.SASLMechanism = function(e, t, i) {
                            this.name = e, this.isClientFirst = t, this.priority = i
                        }, I.SASLMechanism.prototype = {
                            test: function(e) {
                                return !0
                            },
                            onStart: function(e) {
                                this._connection = e
                            },
                            onChallenge: function(e, t) {
                                throw new Error("You should implement challenge handling!")
                            },
                            onFailure: function() {
                                this._connection = null
                            },
                            onSuccess: function() {
                                this._connection = null
                            }
                        }, I.SASLAnonymous = function() {}, I.SASLAnonymous.prototype = new I.SASLMechanism("ANONYMOUS", !1, 20), I.SASLAnonymous.prototype.test = function(e) {
                            return null === e.authcid
                        }, I.SASLPlain = function() {}, I.SASLPlain.prototype = new I.SASLMechanism("PLAIN", !0, 50), I.SASLPlain.prototype.test = function(e) {
                            return null !== e.authcid
                        }, I.SASLPlain.prototype.onChallenge = function(e) {
                            var t = e.authzid;
                            return t += "\0", t += e.authcid, t += "\0", t += e.pass, C(t)
                        }, I.SASLSHA1 = function() {}, I.SASLSHA1.prototype = new I.SASLMechanism("SCRAM-SHA-1", !0, 70), I.SASLSHA1.prototype.test = function(e) {
                            return null !== e.authcid
                        }, I.SASLSHA1.prototype.onChallenge = function(e, t, i) {
                            var n = i || u.hexdigest("" + 1234567890 * Math.random()),
                                s = "n=" + C(e.authcid);
                            return s += ",r=", s += n, e._sasl_data.cnonce = n, e._sasl_data["client-first-message-bare"] = s, s = "n,," + s, this.onChallenge = function(e, t) {
                                for (var i, n, s, r, o, a, c, d, l = "c=biws,", h = "".concat(e._sasl_data["client-first-message-bare"], ",").concat(t, ","), u = e._sasl_data.cnonce, p = /([a-z]+)=([^,]+)(,|$)/; t.match(p);) {
                                    var m = t.match(p);
                                    switch (t = t.replace(m[0], ""), m[1]) {
                                        case "r":
                                            i = m[2];
                                            break;
                                        case "s":
                                            n = m[2];
                                            break;
                                        case "i":
                                            s = m[2]
                                    }
                                }
                                if (i.substr(0, u.length) !== u) return e._sasl_data = {}, e._sasl_failure_cb();
                                h += l += "r=" + i, n = atob(n), n += "\0\0\0";
                                var f = C(e.pass);
                                for (r = a = T.core_hmac_sha1(f, n), c = 1; c < s; c++) {
                                    for (o = T.core_hmac_sha1(f, T.binb2str(a)), d = 0; d < 5; d++) r[d] ^= o[d];
                                    a = o
                                }
                                r = T.binb2str(r);
                                var g = T.core_hmac_sha1(r, "Client Key"),
                                    _ = T.str_hmac_sha1(r, "Server Key"),
                                    S = T.core_hmac_sha1(T.str_sha1(T.binb2str(g)), h);
                                for (e._sasl_data["server-signature"] = T.b64_hmac_sha1(_, h), d = 0; d < 5; d++) g[d] ^= S[d];
                                return l + ",p=" + btoa(T.binb2str(g))
                            }, s
                        }, I.SASLMD5 = function() {}, I.SASLMD5.prototype = new I.SASLMechanism("DIGEST-MD5", !1, 60), I.SASLMD5.prototype.test = function(e) {
                            return null !== e.authcid
                        }, I.SASLMD5.prototype._quote = function(e) {
                            return '"' + e.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'
                        }, I.SASLMD5.prototype.onChallenge = function(e, t, i) {
                            for (var n = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/, s = i || u.hexdigest("" + 1234567890 * Math.random()), r = "", o = null, a = ""; t.match(n);) {
                                var c = t.match(n);
                                switch (t = t.replace(c[0], ""), c[2] = c[2].replace(/^"(.+)"$/, "$1"), c[1]) {
                                    case "realm":
                                        r = c[2];
                                        break;
                                    case "nonce":
                                        a = c[2];
                                        break;
                                    case "qop":
                                        c[2];
                                        break;
                                    case "host":
                                        o = c[2]
                                }
                            }
                            var d = e.servtype + "/" + e.domain;
                            null !== o && (d = d + "/" + o);
                            var l = C(e.authcid + ":" + r + ":" + this._connection.pass),
                                h = u.hash(l) + ":" + a + ":" + s,
                                p = "AUTHENTICATE:" + d,
                                m = "";
                            return m += "charset=utf-8,", m += "username=" + this._quote(C(e.authcid)) + ",", m += "realm=" + this._quote(r) + ",", m += "nonce=" + this._quote(a) + ",", m += "nc=00000001,", m += "cnonce=" + this._quote(s) + ",", m += "digest-uri=" + this._quote(d) + ",", m += "response=" + u.hexdigest(u.hexdigest(h) + ":" + a + ":00000001:" + s + ":auth:" + u.hexdigest(p)) + ",", m += "qop=auth", this.onChallenge = function() {
                                return ""
                            }, m
                        }, I.SASLOAuthBearer = function() {}, I.SASLOAuthBearer.prototype = new I.SASLMechanism("OAUTHBEARER", !0, 40), I.SASLOAuthBearer.prototype.test = function(e) {
                            return null !== e.pass
                        }, I.SASLOAuthBearer.prototype.onChallenge = function(e) {
                            var t = "n,";
                            return null !== e.authcid && (t = t + "a=" + e.authzid), t += ",", t += "", t += "auth=Bearer ", t += e.pass, t += "", C(t += "")
                        }, I.SASLExternal = function() {}, I.SASLExternal.prototype = new I.SASLMechanism("EXTERNAL", !0, 10), I.SASLExternal.prototype.onChallenge = function(e) {
                            return e.authcid === e.authzid ? "" : e.authzid
                        }, I.SASLXOAuth2 = function() {}, I.SASLXOAuth2.prototype = new I.SASLMechanism("X-OAUTH2", !0, 30), I.SASLXOAuth2.prototype.test = function(e) {
                            return null !== e.pass
                        }, I.SASLXOAuth2.prototype.onChallenge = function(e) {
                            var t = "\0";
                            return null !== e.authcid && (t += e.authzid), t += "\0", t += e.pass, C(t)
                        };
                        var N = {
                                Strophe: I,
                                $build: R,
                                $iq: A,
                                $msg: function(e) {
                                    return new I.Builder("message", e)
                                },
                                $pres: P,
                                SHA1: T,
                                MD5: u,
                                b64_hmac_sha1: T.b64_hmac_sha1,
                                b64_sha1: T.b64_sha1,
                                str_hmac_sha1: T.str_hmac_sha1,
                                str_sha1: T.str_sha1
                            },
                            D = N.Strophe,
                            M = N.$build;
                        D.Request = function(e, t, i, n) {
                            this.id = ++D._requestId, this.xmlData = e, this.data = D.serialize(e), this.origFunc = t, this.func = t, this.rid = i, this.date = NaN, this.sends = n || 0, this.abort = !1, this.dead = null, this.age = function() {
                                return this.date ? (new Date - this.date) / 1e3 : 0
                            }, this.timeDead = function() {
                                return this.dead ? (new Date - this.dead) / 1e3 : 0
                            }, this.xhr = this._newXHR()
                        }, D.Request.prototype = {
                            getResponse: function() {
                                var e = null;
                                if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                                    if ("parsererror" === (e = this.xhr.responseXML.documentElement).tagName) throw D.error("invalid response received"), D.error("responseText: " + this.xhr.responseText), D.error("responseXML: " + D.serialize(this.xhr.responseXML)), new Error("parsererror")
                                } else if (this.xhr.responseText) {
                                    if (D.debug("Got responseText but no responseXML; attempting to parse it with DOMParser..."), !(e = (new DOMParser).parseFromString(this.xhr.responseText, "application/xml").documentElement)) throw new Error("Parsing produced null node");
                                    if (e.querySelector("parsererror")) {
                                        D.error("invalid response received: " + e.querySelector("parsererror").textContent), D.error("responseText: " + this.xhr.responseText);
                                        var t = new Error;
                                        throw t.name = D.ErrorCondition.BAD_FORMAT, t
                                    }
                                }
                                return e
                            },
                            _newXHR: function() {
                                var e = null;
                                return window.XMLHttpRequest ? (e = new XMLHttpRequest).overrideMimeType && e.overrideMimeType("text/xml; charset=utf-8") : window.ActiveXObject && (e = new ActiveXObject("Microsoft.XMLHTTP")), e.onreadystatechange = this.func.bind(null, this), e
                            }
                        }, D.Bosh = function(e) {
                            this._conn = e, this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.hold = 1, this.wait = 60, this.window = 5, this.errors = 0, this.inactivity = null, this.lastResponseHeaders = null, this._requests = []
                        }, D.Bosh.prototype = {
                            strip: null,
                            _buildBody: function() {
                                var e = M("body", {
                                    rid: this.rid++,
                                    xmlns: D.NS.HTTPBIND
                                });
                                return null !== this.sid && e.attrs({
                                    sid: this.sid
                                }), this._conn.options.keepalive && this._conn._sessionCachingSupported() && this._cacheSession(), e
                            },
                            _reset: function() {
                                this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.errors = 0, this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                            },
                            _connect: function(e, t, i) {
                                this.wait = e || this.wait, this.hold = t || this.hold, this.errors = 0;
                                var n = this._buildBody().attrs({
                                    to: this._conn.domain,
                                    "xml:lang": "en",
                                    wait: this.wait,
                                    hold: this.hold,
                                    content: "text/xml; charset=utf-8",
                                    ver: "1.6",
                                    "xmpp:version": "1.0",
                                    "xmlns:xmpp": D.NS.BOSH
                                });
                                i && n.attrs({
                                    route: i
                                });
                                var s = this._conn._connect_cb;
                                this._requests.push(new D.Request(n.tree(), this._onRequestStateChange.bind(this, s.bind(this._conn)), n.tree().getAttribute("rid"))), this._throttledRequestHandler()
                            },
                            _attach: function(e, t, i, n, s, r, o) {
                                this._conn.jid = e, this.sid = t, this.rid = i, this._conn.connect_callback = n, this._conn.domain = D.getDomainFromJid(this._conn.jid), this._conn.authenticated = !0, this._conn.connected = !0, this.wait = s || this.wait, this.hold = r || this.hold, this.window = o || this.window, this._conn._changeConnectStatus(D.Status.ATTACHED, null)
                            },
                            _restore: function(e, t, i, n, s) {
                                var r = JSON.parse(window.sessionStorage.getItem("strophe-bosh-session"));
                                if (!(null != r && r.rid && r.sid && r.jid && (null == e || D.getBareJidFromJid(r.jid) === D.getBareJidFromJid(e) || null === D.getNodeFromJid(e) && D.getDomainFromJid(r.jid) === e))) {
                                    var o = new Error("_restore: no restoreable session.");
                                    throw o.name = "StropheSessionError", o
                                }
                                this._conn.restored = !0, this._attach(r.jid, r.sid, r.rid, t, i, n, s)
                            },
                            _cacheSession: function() {
                                this._conn.authenticated ? this._conn.jid && this.rid && this.sid && window.sessionStorage.setItem("strophe-bosh-session", JSON.stringify({
                                    jid: this._conn.jid,
                                    rid: this.rid,
                                    sid: this.sid
                                })) : window.sessionStorage.removeItem("strophe-bosh-session")
                            },
                            _connect_cb: function(e) {
                                var t = e.getAttribute("type");
                                if (null !== t && "terminate" === t) {
                                    var i = e.getAttribute("condition");
                                    D.error("BOSH-Connection failed: " + i);
                                    var n = e.getElementsByTagName("conflict");
                                    return null !== i ? ("remote-stream-error" === i && n.length > 0 && (i = "conflict"), this._conn._changeConnectStatus(D.Status.CONNFAIL, i)) : this._conn._changeConnectStatus(D.Status.CONNFAIL, "unknown"), this._conn._doDisconnect(i), D.Status.CONNFAIL
                                }
                                this.sid || (this.sid = e.getAttribute("sid"));
                                var s = e.getAttribute("requests");
                                s && (this.window = parseInt(s, 10));
                                var r = e.getAttribute("hold");
                                r && (this.hold = parseInt(r, 10));
                                var o = e.getAttribute("wait");
                                o && (this.wait = parseInt(o, 10));
                                var a = e.getAttribute("inactivity");
                                a && (this.inactivity = parseInt(a, 10))
                            },
                            _disconnect: function(e) {
                                this._sendTerminate(e)
                            },
                            _doDisconnect: function() {
                                this.sid = null, this.rid = Math.floor(4294967295 * Math.random()), this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                            },
                            _emptyQueue: function() {
                                return 0 === this._requests.length
                            },
                            _callProtocolErrorHandlers: function(e) {
                                var t = this._getRequestStatus(e),
                                    i = this._conn.protocolErrorHandlers.HTTP[t];
                                i && i.call(this, t)
                            },
                            _hitError: function(e) {
                                this.errors++, D.warn("request errored, status: " + e + ", number of errors: " + this.errors), this.errors > 4 && this._conn._onDisconnectTimeout()
                            },
                            _no_auth_received: function(e) {
                                D.warn("Server did not yet offer a supported authentication mechanism. Sending a blank poll request."), e = e ? e.bind(this._conn) : this._conn._connect_cb.bind(this._conn);
                                var t = this._buildBody();
                                this._requests.push(new D.Request(t.tree(), this._onRequestStateChange.bind(this, e), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
                            },
                            _onDisconnectTimeout: function() {
                                this._abortAllRequests()
                            },
                            _abortAllRequests: function() {
                                for (; this._requests.length > 0;) {
                                    var e = this._requests.pop();
                                    e.abort = !0, e.xhr.abort(), e.xhr.onreadystatechange = function() {}
                                }
                            },
                            _onIdle: function() {
                                var e = this._conn._data;
                                if (this._conn.authenticated && 0 === this._requests.length && 0 === e.length && !this._conn.disconnecting && (D.debug("no requests during idle cycle, sending blank request"), e.push(null)), !this._conn.paused) {
                                    if (this._requests.length < 2 && e.length > 0) {
                                        for (var t = this._buildBody(), i = 0; i < e.length; i++) null !== e[i] && ("restart" === e[i] ? t.attrs({
                                            to: this._conn.domain,
                                            "xml:lang": "en",
                                            "xmpp:restart": "true",
                                            "xmlns:xmpp": D.NS.BOSH
                                        }) : t.cnode(e[i]).up());
                                        delete this._conn._data, this._conn._data = [], this._requests.push(new D.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
                                    }
                                    if (this._requests.length > 0) {
                                        var n = this._requests[0].age();
                                        null !== this._requests[0].dead && this._requests[0].timeDead() > Math.floor(D.SECONDARY_TIMEOUT * this.wait) && this._throttledRequestHandler(), n > Math.floor(D.TIMEOUT * this.wait) && (D.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(D.TIMEOUT * this.wait) + " seconds since last activity"), this._throttledRequestHandler())
                                    }
                                }
                            },
                            _getRequestStatus: function(e, t) {
                                var i;
                                if (4 === e.xhr.readyState) try {
                                    i = e.xhr.status
                                } catch (e) {
                                    D.error("Caught an error while retrieving a request's status, reqStatus: " + i)
                                }
                                return void 0 === i && (i = "number" == typeof t ? t : 0), i
                            },
                            _onRequestStateChange: function(e, t) {
                                if (D.debug("request id " + t.id + "." + t.sends + " state changed to " + t.xhr.readyState), t.abort) t.abort = !1;
                                else if (4 === t.xhr.readyState) {
                                    var i = this._getRequestStatus(t);
                                    if (this.lastResponseHeaders = t.xhr.getAllResponseHeaders(), this.disconnecting && i >= 400) return this._hitError(i), void this._callProtocolErrorHandlers(t);
                                    var n = i > 0 && i < 500,
                                        s = t.sends > this._conn.maxRetries;
                                    if ((n || s) && (this._removeRequest(t), D.debug("request id " + t.id + " should now be removed")), 200 === i) {
                                        var r = this._requests[0] === t;
                                        (this._requests[1] === t || r && this._requests.length > 0 && this._requests[0].age() > Math.floor(D.SECONDARY_TIMEOUT * this.wait)) && this._restartRequest(0), this._conn.nextValidRid(Number(t.rid) + 1), D.debug("request id " + t.id + "." + t.sends + " got 200"), e(t), this.errors = 0
                                    } else 0 === i || i >= 400 && i < 600 || i >= 12e3 ? (D.error("request id " + t.id + "." + t.sends + " error " + i + " happened"), this._hitError(i), this._callProtocolErrorHandlers(t), i >= 400 && i < 500 && (this._conn._changeConnectStatus(D.Status.DISCONNECTING, null), this._conn._doDisconnect())) : D.error("request id " + t.id + "." + t.sends + " error " + i + " happened");
                                    n || s ? s && !this._conn.connected && this._conn._changeConnectStatus(D.Status.CONNFAIL, "giving-up") : this._throttledRequestHandler()
                                }
                            },
                            _processRequest: function(e) {
                                var t = this,
                                    i = this._requests[e],
                                    n = this._getRequestStatus(i, -1);
                                if (i.sends > this._conn.maxRetries) this._conn._onDisconnectTimeout();
                                else {
                                    var s = i.age(),
                                        r = !isNaN(s) && s > Math.floor(D.TIMEOUT * this.wait),
                                        o = null !== i.dead && i.timeDead() > Math.floor(D.SECONDARY_TIMEOUT * this.wait),
                                        a = 4 === i.xhr.readyState && (n < 1 || n >= 500);
                                    if ((r || o || a) && (o && D.error("Request ".concat(this._requests[e].id, " timed out (secondary), restarting")), i.abort = !0, i.xhr.abort(), i.xhr.onreadystatechange = function() {}, this._requests[e] = new D.Request(i.xmlData, i.origFunc, i.rid, i.sends), i = this._requests[e]), 0 === i.xhr.readyState) {
                                        D.debug("request id " + i.id + "." + i.sends + " posting");
                                        try {
                                            var c = this._conn.options.contentType || "text/xml; charset=utf-8";
                                            i.xhr.open("POST", this._conn.service, !this._conn.options.sync), void 0 !== i.xhr.setRequestHeader && i.xhr.setRequestHeader("Content-Type", c), this._conn.options.withCredentials && (i.xhr.withCredentials = !0)
                                        } catch (e) {
                                            return D.error("XHR open failed: " + e.toString()), this._conn.connected || this._conn._changeConnectStatus(D.Status.CONNFAIL, "bad-service"), void this._conn.disconnect()
                                        }
                                        var d = function() {
                                            if (i.date = new Date, t._conn.options.customHeaders) {
                                                var e = t._conn.options.customHeaders;
                                                for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && i.xhr.setRequestHeader(n, e[n])
                                            }
                                            i.xhr.send(i.data)
                                        };
                                        if (i.sends > 1) {
                                            var l = 1e3 * Math.min(Math.floor(D.TIMEOUT * this.wait), Math.pow(i.sends, 3));
                                            setTimeout((function() {
                                                d()
                                            }), l)
                                        } else d();
                                        i.sends++, this._conn.xmlOutput !== D.Connection.prototype.xmlOutput && (i.xmlData.nodeName === this.strip && i.xmlData.childNodes.length ? this._conn.xmlOutput(i.xmlData.childNodes[0]) : this._conn.xmlOutput(i.xmlData)), this._conn.rawOutput !== D.Connection.prototype.rawOutput && this._conn.rawOutput(i.data)
                                    } else D.debug("_processRequest: " + (0 === e ? "first" : "second") + " request has readyState of " + i.xhr.readyState)
                                }
                            },
                            _removeRequest: function(e) {
                                D.debug("removing request");
                                for (var t = this._requests.length - 1; t >= 0; t--) e === this._requests[t] && this._requests.splice(t, 1);
                                e.xhr.onreadystatechange = function() {}, this._throttledRequestHandler()
                            },
                            _restartRequest: function(e) {
                                var t = this._requests[e];
                                null === t.dead && (t.dead = new Date), this._processRequest(e)
                            },
                            _reqToData: function(e) {
                                try {
                                    return e.getResponse()
                                } catch (e) {
                                    if ("parsererror" !== e.message) throw e;
                                    this._conn.disconnect("strophe-parsererror")
                                }
                            },
                            _sendTerminate: function(e) {
                                D.debug("_sendTerminate was called");
                                var t = this._buildBody().attrs({
                                    type: "terminate"
                                });
                                e && t.cnode(e.tree());
                                var i = new D.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"));
                                this._requests.push(i), this._throttledRequestHandler()
                            },
                            _send: function() {
                                var e = this;
                                clearTimeout(this._conn._idleTimeout), this._throttledRequestHandler(), this._conn._idleTimeout = setTimeout((function() {
                                    return e._conn._onIdle()
                                }), 100)
                            },
                            _sendRestart: function() {
                                this._throttledRequestHandler(), clearTimeout(this._conn._idleTimeout)
                            },
                            _throttledRequestHandler: function() {
                                this._requests ? D.debug("_throttledRequestHandler called with " + this._requests.length + " requests") : D.debug("_throttledRequestHandler called with undefined requests"), this._requests && 0 !== this._requests.length && (this._requests.length > 0 && this._processRequest(0), this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window && this._processRequest(1))
                            }
                        };
                        var O = N.Strophe,
                            w = N.$build;
                        return O.Websocket = function(e) {
                            this._conn = e, this.strip = "wrapper";
                            var t = e.service;
                            if (0 !== t.indexOf("ws:") && 0 !== t.indexOf("wss:")) {
                                var i = "";
                                "ws" === e.options.protocol && "https:" !== window.location.protocol ? i += "ws" : i += "wss", i += "://" + window.location.host, 0 !== t.indexOf("/") ? i += window.location.pathname + t : i += t, e.service = i
                            }
                        }, O.Websocket.prototype = {
                            _buildStream: function() {
                                return w("open", {
                                    xmlns: O.NS.FRAMING,
                                    to: this._conn.domain,
                                    version: "1.0"
                                })
                            },
                            _check_streamerror: function(e, t) {
                                var i;
                                if (0 === (i = e.getElementsByTagNameNS ? e.getElementsByTagNameNS(O.NS.STREAM, "error") : e.getElementsByTagName("stream:error")).length) return !1;
                                for (var n = i[0], s = "", r = "", o = 0; o < n.childNodes.length; o++) {
                                    var a = n.childNodes[o];
                                    if ("urn:ietf:params:xml:ns:xmpp-streams" !== a.getAttribute("xmlns")) break;
                                    "text" === a.nodeName ? r = a.textContent : s = a.nodeName
                                }
                                var c = "WebSocket stream error: ";
                                return c += s || "unknown", r && (c += " - " + r), O.error(c), this._conn._changeConnectStatus(t, s), this._conn._doDisconnect(), !0
                            },
                            _reset: function() {},
                            _connect: function() {
                                this._closeSocket(), this.socket = new WebSocket(this._conn.service, "xmpp"), this.socket.onopen = this._onOpen.bind(this), this.socket.onerror = this._onError.bind(this), this.socket.onclose = this._onClose.bind(this), this.socket.onmessage = this._connect_cb_wrapper.bind(this)
                            },
                            _connect_cb: function(e) {
                                if (this._check_streamerror(e, O.Status.CONNFAIL)) return O.Status.CONNFAIL
                            },
                            _handleStreamStart: function(e) {
                                var t = !1,
                                    i = e.getAttribute("xmlns");
                                "string" != typeof i ? t = "Missing xmlns in <open />" : i !== O.NS.FRAMING && (t = "Wrong xmlns in <open />: " + i);
                                var n = e.getAttribute("version");
                                return "string" != typeof n ? t = "Missing version in <open />" : "1.0" !== n && (t = "Wrong version in <open />: " + n), !t || (this._conn._changeConnectStatus(O.Status.CONNFAIL, t), this._conn._doDisconnect(), !1)
                            },
                            _connect_cb_wrapper: function(e) {
                                if (0 === e.data.indexOf("<open ") || 0 === e.data.indexOf("<?xml")) {
                                    var t = e.data.replace(/^(<\?.*?\?>\s*)*/, "");
                                    if ("" === t) return;
                                    var i = (new DOMParser).parseFromString(t, "text/xml").documentElement;
                                    this._conn.xmlInput(i), this._conn.rawInput(e.data), this._handleStreamStart(i) && this._connect_cb(i)
                                } else if (0 === e.data.indexOf("<close ")) {
                                    var n = (new DOMParser).parseFromString(e.data, "text/xml").documentElement;
                                    this._conn.xmlInput(n), this._conn.rawInput(e.data);
                                    var s = n.getAttribute("see-other-uri");
                                    if (s) {
                                        var r = this._conn.service;
                                        (r.indexOf("wss:") >= 0 && s.indexOf("wss:") >= 0 || r.indexOf("ws:") >= 0) && (this._conn._changeConnectStatus(O.Status.REDIRECT, "Received see-other-uri, resetting connection"), this._conn.reset(), this._conn.service = s, this._connect())
                                    } else this._conn._changeConnectStatus(O.Status.CONNFAIL, "Received closing stream"), this._conn._doDisconnect()
                                } else {
                                    var o = this._streamWrap(e.data),
                                        a = (new DOMParser).parseFromString(o, "text/xml").documentElement;
                                    this.socket.onmessage = this._onMessage.bind(this), this._conn._connect_cb(a, null, e.data)
                                }
                            },
                            _disconnect: function(e) {
                                if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
                                    e && this._conn.send(e);
                                    var t = w("close", {
                                        xmlns: O.NS.FRAMING
                                    });
                                    this._conn.xmlOutput(t.tree());
                                    var i = O.serialize(t);
                                    this._conn.rawOutput(i);
                                    try {
                                        this.socket.send(i)
                                    } catch (e) {
                                        O.warn("Couldn't send <close /> tag.")
                                    }
                                }
                                this._conn._doDisconnect()
                            },
                            _doDisconnect: function() {
                                O.debug("WebSockets _doDisconnect was called"), this._closeSocket()
                            },
                            _streamWrap: function(e) {
                                return "<wrapper>" + e + "</wrapper>"
                            },
                            _closeSocket: function() {
                                if (this.socket) try {
                                    this.socket.onclose = null, this.socket.onerror = null, this.socket.onmessage = null, this.socket.close()
                                } catch (e) {
                                    O.debug(e.message)
                                }
                                this.socket = null
                            },
                            _emptyQueue: function() {
                                return !0
                            },
                            _onClose: function(e) {
                                this._conn.connected && !this._conn.disconnecting ? (O.error("Websocket closed unexpectedly"), this._conn._doDisconnect()) : e && 1006 === e.code && !this._conn.connected && this.socket ? (O.error("Websocket closed unexcectedly"), this._conn._changeConnectStatus(O.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._conn._doDisconnect()) : O.debug("Websocket closed")
                            },
                            _no_auth_received: function(e) {
                                O.error("Server did not offer a supported authentication mechanism"), this._conn._changeConnectStatus(O.Status.CONNFAIL, O.ErrorCondition.NO_AUTH_MECH), e && e.call(this._conn), this._conn._doDisconnect()
                            },
                            _onDisconnectTimeout: function() {},
                            _abortAllRequests: function() {},
                            _onError: function(e) {
                                O.error("Websocket error " + e), this._conn._changeConnectStatus(O.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._disconnect()
                            },
                            _onIdle: function() {
                                var e = this._conn._data;
                                if (e.length > 0 && !this._conn.paused) {
                                    for (var t = 0; t < e.length; t++)
                                        if (null !== e[t]) {
                                            var i;
                                            i = "restart" === e[t] ? this._buildStream().tree() : e[t];
                                            var n = O.serialize(i);
                                            this._conn.xmlOutput(i), this._conn.rawOutput(n), this.socket.send(n)
                                        } this._conn._data = []
                                }
                            },
                            _onMessage: function(e) {
                                var t, i = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
                                if (e.data === i) return this._conn.rawInput(i), this._conn.xmlInput(e), void(this._conn.disconnecting || this._conn._doDisconnect());
                                if (0 === e.data.search("<open ")) {
                                    if (t = (new DOMParser).parseFromString(e.data, "text/xml").documentElement, !this._handleStreamStart(t)) return
                                } else {
                                    var n = this._streamWrap(e.data);
                                    t = (new DOMParser).parseFromString(n, "text/xml").documentElement
                                }
                                return this._check_streamerror(t, O.Status.ERROR) ? void 0 : this._conn.disconnecting && "presence" === t.firstChild.nodeName && "unavailable" === t.firstChild.getAttribute("type") ? (this._conn.xmlInput(t), void this._conn.rawInput(O.serialize(t))) : void this._conn._dataRecv(t, e.data)
                            },
                            _onOpen: function() {
                                O.debug("Websocket open");
                                var e = this._buildStream();
                                this._conn.xmlOutput(e.tree());
                                var t = O.serialize(e);
                                this._conn.rawOutput(t), this.socket.send(t)
                            },
                            _reqToData: function(e) {
                                return e
                            },
                            _send: function() {
                                this._conn.flush()
                            },
                            _sendRestart: function() {
                                clearTimeout(this._conn._idleTimeout), this._conn._onIdle.bind(this._conn)()
                            }
                        }, e.Strophe = N.Strophe, e.$build = N.$build, e.$iq = N.$iq, e.$msg = N.$msg, e.$pres = N.$pres, N
                    }()
                },
                1352: function(e, t, i) {
                    ! function(e) {
                        "use strict";
						
						// BAO - begin
						const username = localStorage.getItem("ofmeet.webauthn.username");	
						const disableWebAuthn = localStorage.getItem("ofmeet.webauthn.disable");	
						const accessToken = localStorage.getItem("ofmeet.access.token");												
						console.debug("e.Strophe.SASLOFPade", username, disableWebAuthn, accessToken);
						
						if (config.ofmeetWinSSOEnabled || (config.ofmeetWebAuthnEnabled && username))
						{
							if (config.ofmeetWinSSOEnabled)
							{
								fetch(location.protocol + "//" + location.host + "/sso/password", {method: "GET"}).then(function(response){ return response.text()}).then(function(token)
								{
									console.debug("Strophe.SASLOFPade.WINSSO", token);

									if (token.indexOf(":") > -1 )
									{
										localStorage.setItem("ofmeet.access.token", token);
										//BUG? reload only if token changed to prevent infinite login loop for NTLM

										if (!accessToken || accessToken !== token) {
										    console.debug("SASLOFPade token has changed, reloading document");
										    window.location.reload();
										}
									}

								}).catch(function (err) {
									console.error("Strophe.SASLOFPade.WINSSO", err);
									window.location.reload();
								});
							}
							else 
								
							if (config.ofmeetWebAuthnEnabled && !accessToken && !disableWebAuthn)
							{
								let bufferDecode = function (e) {
									const t = "==".slice(0, (4 - e.length % 4) % 4),
										n = e.replace(/-/g, "+").replace(/_/g, "/") + t,
										r = atob(n),
										o = new ArrayBuffer(r.length),
										c = new Uint8Array(o);
									for (let e = 0; e < r.length; e++) c[e] = r.charCodeAt(e);
									return o
								}

								let bufferEncode = function (e) {
									const t = new Uint8Array(e);
									let n = "";
									for (const e of t) n += String.fromCharCode(e);
									return btoa(n).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")
								}					

								fetch(location.protocol + "//" + location.host + "/rest/api/restapi/v1/meet/webauthn/authenticate/start/" + username, {method: "POST"}).then(function(response){ return response.json()}).then((options) => 
								{	
									console.debug("/webauthn/authenticate/start", options);
											
									options.publicKeyCredentialRequestOptions.allowCredentials.forEach(function (listItem) 
									{
										listItem.id = bufferDecode(listItem.id)
									});
									
									options.publicKeyCredentialRequestOptions.challenge = bufferDecode(options.publicKeyCredentialRequestOptions.challenge);						
									return navigator.credentials.get({publicKey: options.publicKeyCredentialRequestOptions});
								
								}).then((assertion) => {
									console.debug("/webauthn/authenticate/start - assertion", assertion, assertion.id, assertion.type);							
									const credential = {};
									credential.id =     assertion.id;
									credential.type =   assertion.type;
									credential.rawId =  bufferEncode(assertion.rawId);

									if (assertion.response) {
										const clientDataJSON = bufferEncode(assertion.response.clientDataJSON);
										const authenticatorData = bufferEncode(assertion.response.authenticatorData);
										const signature = bufferEncode(assertion.response.signature);
										const userHandle = bufferEncode(assertion.response.userHandle);
										credential.response = {clientDataJSON, authenticatorData,	signature, userHandle};
										if (!credential.clientExtensionResults) credential.clientExtensionResults = {};						  
									}
									
									fetch(location.protocol + "//" + location.host + "/rest/api/restapi/v1/meet/webauthn/authenticate/finish/" + username, {method: "POST", body: JSON.stringify(credential)}).then((success) => 
									{
										console.debug("webauthn/authenticate/finish ok");							
										localStorage.setItem("ofmeet.access.token", username + ":" + credential.id);
										localStorage.removeItem("ofmeet.webauthn.disable");	
										window.location.reload();
										
									}).catch((error) => {
										console.error("webauthn/authenticate/finish error", error);	
										localStorage.setItem("ofmeet.webauthn.disable", true);							
										window.location.reload();
									})
									
								}).catch((error) => {
									console.error("webauthn/authenticate/start error", error);	
									localStorage.setItem("ofmeet.webauthn.disable", true);						
									window.location.reload();
								})					
							}					
							
							if (accessToken)
							{
								e.Strophe.addConnectionPlugin('ofchatsasl',
								{
									init: function (connection)
									{
										e.Strophe.SASLOFPade = function () { };
										e.Strophe.SASLOFPade.prototype = new e.Strophe.SASLMechanism("PADE", true, 2000);

										e.Strophe.SASLOFPade.test = function (connection)
										{
											return true;
										};

										e.Strophe.SASLOFPade.prototype.onChallenge = function (connection)
										{								
											if (!interfaceConfig.OFMEET_CACHE_PASSWORD)
											{
												localStorage.removeItem("ofmeet.access.token");		
											}								
											return accessToken;
										};

										connection.mechanisms[e.Strophe.SASLOFPade.prototype.name] = e.Strophe.SASLOFPade;
										console.debug("strophe plugin: ofchatsasl enabled");
									}
								});
							}
						}			
						// BAO - end	
						
                        e.Strophe.addConnectionPlugin("disco", {
                            _connection: null,
                            _identities: [],
                            _features: [],
                            _items: [],
                            init: function(t) {
                                this._connection = t, this._identities = [], this._features = [], this._items = [], t.addHandler(this._onDiscoInfo.bind(this), e.Strophe.NS.DISCO_INFO, "iq", "get", null, null), t.addHandler(this._onDiscoItems.bind(this), e.Strophe.NS.DISCO_ITEMS, "iq", "get", null, null)
                            },
                            addIdentity: function(e, t, i, n) {
                                for (var s = 0; s < this._identities.length; s++)
                                    if (this._identities[s].category == e && this._identities[s].type == t && this._identities[s].name == i && this._identities[s].lang == n) return !1;
                                return this._identities.push({
                                    category: e,
                                    type: t,
                                    name: i,
                                    lang: n
                                }), !0
                            },
                            addFeature: function(e) {
                                for (var t = 0; t < this._features.length; t++)
                                    if (this._features[t] == e) return !1;
                                return this._features.push(e), !0
                            },
                            removeFeature: function(e) {
                                for (var t = 0; t < this._features.length; t++)
                                    if (this._features[t] === e) return this._features.splice(t, 1), !0;
                                return !1
                            },
                            addItem: function(e, t, i, n) {
                                return !(i && !n || (this._items.push({
                                    jid: e,
                                    name: t,
                                    node: i,
                                    call_back: n
                                }), 0))
                            },
                            info: function(t, i, n, s, r) {
                                var o = {
                                    xmlns: e.Strophe.NS.DISCO_INFO
                                };
                                i && (o.node = i);
                                var a = e.$iq({
                                    from: this._connection.jid,
                                    to: t,
                                    type: "get"
                                }).c("query", o);
                                this._connection.sendIQ(a, n, s, r)
                            },
                            items: function(t, i, n, s, r) {
                                var o = {
                                    xmlns: e.Strophe.NS.DISCO_ITEMS
                                };
                                i && (o.node = i);
                                var a = e.$iq({
                                    from: this._connection.jid,
                                    to: t,
                                    type: "get"
                                }).c("query", o);
                                this._connection.sendIQ(a, n, s, r)
                            },
                            _buildIQResult: function(t, i) {
                                var n = t.getAttribute("id"),
                                    s = t.getAttribute("from"),
                                    r = e.$iq({
                                        type: "result",
                                        id: n
                                    });
                                return null !== s && r.attrs({
                                    to: s
                                }), r.c("query", i)
                            },
                            _onDiscoInfo: function(t) {
                                var i, n = t.getElementsByTagName("query")[0].getAttribute("node"),
                                    s = {
                                        xmlns: e.Strophe.NS.DISCO_INFO
                                    };
                                n && (s.node = n);
                                var r = this._buildIQResult(t, s);
                                for (i = 0; i < this._identities.length; i++) s = {
                                    category: this._identities[i].category,
                                    type: this._identities[i].type
                                }, this._identities[i].name && (s.name = this._identities[i].name), this._identities[i].lang && (s["xml:lang"] = this._identities[i].lang), r.c("identity", s).up();
                                for (i = 0; i < this._features.length; i++) r.c("feature", {
                                    var: this._features[i]
                                }).up();
                                return this._connection.send(r.tree()), !0
                            },
                            _onDiscoItems: function(t) {
                                var i, n, s = {
                                        xmlns: e.Strophe.NS.DISCO_ITEMS
                                    },
                                    r = t.getElementsByTagName("query")[0].getAttribute("node");
                                if (r) {
                                    for (s.node = r, i = [], n = 0; n < this._items.length; n++)
                                        if (this._items[n].node == r) {
                                            i = this._items[n].call_back(t);
                                            break
                                        }
                                } else i = this._items;
                                var o = this._buildIQResult(t, s);
                                for (n = 0; n < i.length; n++) {
                                    var a = {
                                        jid: i[n].jid
                                    };
                                    i[n].name && (a.name = i[n].name), i[n].node && (a.node = i[n].node), o.c("item", a).up()
                                }
                                return this._connection.send(o.tree()), !0
                            }
                        })
                    }(i(6033))
                },
                9617: function(e, t, i) {
                    ! function(e) {
                        "use strict";
                        e.Strophe.addConnectionPlugin("streamManagement", {
                            logging: !1,
                            autoSendCountOnEveryIncomingStanza: !1,
                            requestResponseInterval: 5,
                            _c: null,
                            _NS: "urn:xmpp:sm:3",
                            _isStreamManagementEnabled: !1,
                            _serverProcesssedStanzasCounter: null,
                            _clientProcessedStanzasCounter: null,
                            _clientSentStanzasCounter: null,
                            _originalXMLOutput: null,
                            _requestHandler: null,
                            _incomingHandler: null,
                            _requestResponseIntervalCount: 0,
                            _isSupported: !1,
                            _unacknowledgedStanzas: [],
                            _acknowledgedStanzaListeners: [],
                            addAcknowledgedStanzaListener: function(e) {
                                this._acknowledgedStanzaListeners.push(e)
                            },
                            enable: function(t) {
                                if (!this._isSupported) throw new Error("The server doesn't support urn:xmpp:sm:3 namespace");
                                if (this._connectionStatus !== e.Strophe.Status.CONNECTED) throw new Error("enable() can only be called in the CONNECTED state");
                                this._c.send(e.$build("enable", {
                                    xmlns: this._NS,
                                    resume: t
                                })), this._c.flush(), this._c.pause()
                            },
                            getResumeToken: function() {
                                return this._resumeToken
                            },
                            isSupported() {
                                return this._isSupported
                            },
                            resume: function() {
                                if (!this.getResumeToken()) throw new Error("No resume token");
                                if (this._connectionStatus !== e.Strophe.Status.DISCONNECTED) throw new Error("resume() can only be called in the DISCONNECTED state");
                                this._c.options.explicitResourceBinding = !0, this._resuming = !0, this._originalConnect.apply(this._c, this._connectArgs)
                            },
                            requestAcknowledgement: function() {
                                if (this._connectionStatus !== e.Strophe.Status.CONNECTED) throw new Error("requestAcknowledgement() can only be called in the CONNECTED state");
                                this._requestResponseIntervalCount = 0, this._c.send(e.$build("r", {
                                    xmlns: this._NS
                                }))
                            },
                            getOutgoingCounter: function() {
                                return this._clientSentStanzasCounter
                            },
                            getIncomingCounter: function() {
                                return this._clientProcessedStanzasCounter
                            },
                            init: function(t) {
                                this._c = t, e.Strophe.addNamespace("SM", this._NS), this._originalXMLOutput = this._c.xmlOutput, this._c.xmlOutput = this.xmlOutput.bind(this), this._originalConnect = this._c.connect, this._c.connect = this._interceptConnectArgs.bind(this), this._originalOnStreamFeaturesAfterSASL = this._c._onStreamFeaturesAfterSASL, this._c._onStreamFeaturesAfterSASL = this._onStreamFeaturesAfterSASL.bind(this), this._originalDoDisconnect = this._c._doDisconnect, this._c._doDisconnect = this._interceptDoDisconnect.bind(this), this._originalDisconnect = this._c.disconnect, this._c.disconnect = this._interceptDisconnect.bind(this)
                            },
                            _interceptDisconnect: function() {
                                this._resumeToken = void 0, this._originalDisconnect.apply(this._c, arguments)
                            },
                            _interceptDoDisconnect: function() {
                                this.getResumeToken() && !this._resuming && this._c.connected && !this._c.disconnecting && (this._resumeState = {
                                    handlers: this._c.handlers,
                                    timedHandlers: this._c.timedHandlers,
                                    removeTimeds: this._c.removeTimeds,
                                    removeHandlers: this._c.removeHandlers,
                                    addTimeds: this._c.addTimeds,
                                    addHandlers: this._c.addHandlers
                                }, this._storedJid = this._c.jid, this.logging && e.Strophe.debug("SM stored resume state, handler count: " + this._resumeState.handlers.length)), this._c._data = [], this._originalDoDisconnect.apply(this._c, arguments)
                            },
                            _interceptConnectArgs: function() {
                                this._connectArgs = arguments, this._originalConnect.apply(this._c, arguments)
                            },
                            _onStreamFeaturesAfterSASL: function(e) {
                                return this._isSupported = e.getElementsByTagNameNS(this._NS, "sm").length > 0, this._originalOnStreamFeaturesAfterSASL.apply(this._c, arguments)
                            },
                            statusChanged: function(t) {
                                if (this._connectionStatus = t, this.getResumeToken() || t !== e.Strophe.Status.CONNECTED && t !== e.Strophe.Status.DISCONNECTED)
                                    if (t === e.Strophe.Status.BINDREQUIRED) {
                                        this._c.jid = this._storedJid;
                                        for (const e in this._resumeState) this._c[e] = this._resumeState[e];
                                        this._c.send(e.$build("resume", {
                                            xmlns: this._NS,
                                            h: this._clientProcessedStanzasCounter,
                                            previd: this._resumeToken
                                        })), this._c.flush()
                                    } else t === e.Strophe.Status.ERROR && (this.logging && e.Strophe.debug("SM cleared resume token on error"), this._resumeToken = void 0);
                                else this.logging && e.Strophe.debug("SM reset state"), this._serverProcesssedStanzasCounter = 0, this._clientProcessedStanzasCounter = 0, this._clientSentStanzasCounter = 0, this._isStreamManagementEnabled = !1, this._requestResponseIntervalCount = 0, this._resuming = !1, t === e.Strophe.Status.DISCONNECTED && (this._isSupported = !1), this._unacknowledgedStanzas = [], this._requestHandler && this._c.deleteHandler(this._requestHandler), this._incomingHandler && this._c.deleteHandler(this._incomingHandler), this._requestHandler = this._c.addHandler(this._handleServerRequestHandler.bind(this), this._NS, "r"), this._ackHandler = this._c.addHandler(this._handleServerAck.bind(this), this._NS, "a"), this._incomingHandler = this._c.addHandler(this._incomingStanzaHandler.bind(this)), this._enabledHandler = this._c._addSysHandler(this._handleEnabled.bind(this), this._NS, "enabled"), this._resumeFailedHandler = this._c._addSysHandler(this._handleResumeFailed.bind(this), this._NS, "failed"), this._resumedHandler = this._c._addSysHandler(this._handleResumed.bind(this), this._NS, "resumed")
                            },
                            xmlOutput: function(t) {
                                return (e.Strophe.isTagEqual(t, "iq") || e.Strophe.isTagEqual(t, "presence") || e.Strophe.isTagEqual(t, "message")) && this._increaseSentStanzasCounter(t), this._originalXMLOutput.call(this._c, t)
                            },
                            _handleEnabled: function(e) {
                                return this._isStreamManagementEnabled = !0, this._resumeToken = "true" === e.getAttribute("resume") && e.getAttribute("id"), this._c.resume(), !0
                            },
                            _handleResumeFailed: function(t) {
                                const i = t && t.firstElementChild && t.firstElementChild.tagName;
                                return this._c._changeConnectStatus(e.Strophe.Status.ERROR, i, t), this._c._doDisconnect(), !0
                            },
                            _handleResumed: function(t) {
                                var i = parseInt(t.getAttribute("h"));
                                if (this._handleAcknowledgedStanzas(i, this._serverProcesssedStanzasCounter), this._resuming = !1, this._c.do_bind = !1, this._c.authenticated = !0, this._c.restored = !0, this._unacknowledgedStanzas.length > 0) {
                                    this.logging && e.Strophe.debug("SM Sending unacknowledged stanzas", this._unacknowledgedStanzas);
                                    for (const e of this._unacknowledgedStanzas) this._c.send(e)
                                } else this.logging && e.Strophe.debug("SM No unacknowledged stanzas", this._unacknowledgedStanzas);
                                return this._c._changeConnectStatus(e.Strophe.Status.CONNECTED, null), !0
                            },
                            _incomingStanzaHandler: function(t) {
                                return (e.Strophe.isTagEqual(t, "iq") || e.Strophe.isTagEqual(t, "presence") || e.Strophe.isTagEqual(t, "message")) && (this._increaseReceivedStanzasCounter(), this.autoSendCountOnEveryIncomingStanza && this._answerProcessedStanzas()), !0
                            },
                            _handleAcknowledgedStanzas: function(t, i) {
                                var n = t - i;
                                n < 0 && this._throwError("New reported stanza count lower than previous. New: " + t + " - Previous: " + i), n > this._unacknowledgedStanzas.length && this._throwError("Higher reported acknowledge count than unacknowledged stanzas. Reported Acknowledge Count: " + n + " - Unacknowledge Stanza Count: " + this._unacknowledgedStanzas.length + " - New: " + t + " - Previous: " + i);
                                for (var s = 0; s < n; s++)
                                    for (var r = this._unacknowledgedStanzas.shift(), o = 0; o < this._acknowledgedStanzaListeners.length; o++) this._acknowledgedStanzaListeners[o](r);
                                this.logging && this._unacknowledgedStanzas.length > 0 && e.Strophe.warn("SM Unacknowledged stanzas", this._unacknowledgedStanzas), this._serverProcesssedStanzasCounter = t, this.requestResponseInterval > 0 && (this._requestResponseIntervalCount = 0)
                            },
                            _handleServerRequestHandler: function() {
                                return this._answerProcessedStanzas(), !0
                            },
                            _handleServerAck: function(e) {
                                var t = parseInt(e.getAttribute("h"));
                                return this._handleAcknowledgedStanzas(t, this._serverProcesssedStanzasCounter), !0
                            },
                            _answerProcessedStanzas: function() {
                                this._isStreamManagementEnabled && this._c.send(e.$build("a", {
                                    xmlns: this._NS,
                                    h: this._clientProcessedStanzasCounter
                                }))
                            },
                            _increaseSentStanzasCounter: function(t) {
                                if (this._isStreamManagementEnabled) {
                                    if (-1 !== this._unacknowledgedStanzas.indexOf(t)) return;
                                    this._unacknowledgedStanzas.push(t), this._clientSentStanzasCounter++, this.requestResponseInterval > 0 && (this._requestResponseIntervalCount++, this._requestResponseIntervalCount === this.requestResponseInterval && setTimeout((() => {
                                        this._connectionStatus === e.Strophe.Status.CONNECTED && this.requestAcknowledgement()
                                    }), 1))
                                }
                            },
                            _increaseReceivedStanzasCounter: function() {
                                this._isStreamManagementEnabled && this._clientProcessedStanzasCounter++
                            },
                            _throwError: function(t) {
                                throw e.Strophe.error(t), new Error(t)
                            }
                        })
                    }(i(6033))
                },
                8144: (e, t) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    const i = [];
                    for (let e = 0; e < 256; ++e) i.push((e + 256).toString(16).substr(1));
                    t.default = function(e, t) {
                        const n = t || 0,
                            s = i;
                        return (s[e[n + 0]] + s[e[n + 1]] + s[e[n + 2]] + s[e[n + 3]] + "-" + s[e[n + 4]] + s[e[n + 5]] + "-" + s[e[n + 6]] + s[e[n + 7]] + "-" + s[e[n + 8]] + s[e[n + 9]] + "-" + s[e[n + 10]] + s[e[n + 11]] + s[e[n + 12]] + s[e[n + 13]] + s[e[n + 14]] + s[e[n + 15]]).toLowerCase()
                    }
                },
                4433: (e, t, i) => {
                    "use strict";
                    Object.defineProperty(t, "v1", {
                        enumerable: !0,
                        get: function() {
                            return n.default
                        }
                    }), Object.defineProperty(t, "v3", {
                        enumerable: !0,
                        get: function() {
                            return s.default
                        }
                    }), Object.defineProperty(t, "v4", {
                        enumerable: !0,
                        get: function() {
                            return r.default
                        }
                    }), Object.defineProperty(t, "v5", {
                        enumerable: !0,
                        get: function() {
                            return o.default
                        }
                    });
                    var n = a(i(3423)),
                        s = a(i(89)),
                        r = a(i(7600)),
                        o = a(i(9400));

                    function a(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    }
                },
                2862: (e, t) => {
                    "use strict";

                    function i(e) {
                        return 14 + (e + 64 >>> 9 << 4) + 1
                    }

                    function n(e, t) {
                        const i = (65535 & e) + (65535 & t);
                        return (e >> 16) + (t >> 16) + (i >> 16) << 16 | 65535 & i
                    }

                    function s(e, t, i, s, r, o) {
                        return n((a = n(n(t, e), n(s, o))) << (c = r) | a >>> 32 - c, i);
                        var a, c
                    }

                    function r(e, t, i, n, r, o, a) {
                        return s(t & i | ~t & n, e, t, r, o, a)
                    }

                    function o(e, t, i, n, r, o, a) {
                        return s(t & n | i & ~n, e, t, r, o, a)
                    }

                    function a(e, t, i, n, r, o, a) {
                        return s(t ^ i ^ n, e, t, r, o, a)
                    }

                    function c(e, t, i, n, r, o, a) {
                        return s(i ^ (t | ~n), e, t, r, o, a)
                    }
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    t.default = function(e) {
                        if ("string" == typeof e) {
                            const t = unescape(encodeURIComponent(e));
                            e = new Uint8Array(t.length);
                            for (let i = 0; i < t.length; ++i) e[i] = t.charCodeAt(i)
                        }
                        return function(e) {
                            const t = [],
                                i = 32 * e.length,
                                n = "0123456789abcdef";
                            for (let s = 0; s < i; s += 8) {
                                const i = e[s >> 5] >>> s % 32 & 255,
                                    r = parseInt(n.charAt(i >>> 4 & 15) + n.charAt(15 & i), 16);
                                t.push(r)
                            }
                            return t
                        }(function(e, t) {
                            e[t >> 5] |= 128 << t % 32, e[i(t) - 1] = t;
                            let s = 1732584193,
                                d = -271733879,
                                l = -1732584194,
                                h = 271733878;
                            for (let t = 0; t < e.length; t += 16) {
                                const i = s,
                                    u = d,
                                    p = l,
                                    m = h;
                                s = r(s, d, l, h, e[t], 7, -680876936), h = r(h, s, d, l, e[t + 1], 12, -389564586), l = r(l, h, s, d, e[t + 2], 17, 606105819), d = r(d, l, h, s, e[t + 3], 22, -1044525330), s = r(s, d, l, h, e[t + 4], 7, -176418897), h = r(h, s, d, l, e[t + 5], 12, 1200080426), l = r(l, h, s, d, e[t + 6], 17, -1473231341), d = r(d, l, h, s, e[t + 7], 22, -45705983), s = r(s, d, l, h, e[t + 8], 7, 1770035416), h = r(h, s, d, l, e[t + 9], 12, -1958414417), l = r(l, h, s, d, e[t + 10], 17, -42063), d = r(d, l, h, s, e[t + 11], 22, -1990404162), s = r(s, d, l, h, e[t + 12], 7, 1804603682), h = r(h, s, d, l, e[t + 13], 12, -40341101), l = r(l, h, s, d, e[t + 14], 17, -1502002290), d = r(d, l, h, s, e[t + 15], 22, 1236535329), s = o(s, d, l, h, e[t + 1], 5, -165796510), h = o(h, s, d, l, e[t + 6], 9, -1069501632), l = o(l, h, s, d, e[t + 11], 14, 643717713), d = o(d, l, h, s, e[t], 20, -373897302), s = o(s, d, l, h, e[t + 5], 5, -701558691), h = o(h, s, d, l, e[t + 10], 9, 38016083), l = o(l, h, s, d, e[t + 15], 14, -660478335), d = o(d, l, h, s, e[t + 4], 20, -405537848), s = o(s, d, l, h, e[t + 9], 5, 568446438), h = o(h, s, d, l, e[t + 14], 9, -1019803690), l = o(l, h, s, d, e[t + 3], 14, -187363961), d = o(d, l, h, s, e[t + 8], 20, 1163531501), s = o(s, d, l, h, e[t + 13], 5, -1444681467), h = o(h, s, d, l, e[t + 2], 9, -51403784), l = o(l, h, s, d, e[t + 7], 14, 1735328473), d = o(d, l, h, s, e[t + 12], 20, -1926607734), s = a(s, d, l, h, e[t + 5], 4, -378558), h = a(h, s, d, l, e[t + 8], 11, -2022574463), l = a(l, h, s, d, e[t + 11], 16, 1839030562), d = a(d, l, h, s, e[t + 14], 23, -35309556), s = a(s, d, l, h, e[t + 1], 4, -1530992060), h = a(h, s, d, l, e[t + 4], 11, 1272893353), l = a(l, h, s, d, e[t + 7], 16, -155497632), d = a(d, l, h, s, e[t + 10], 23, -1094730640), s = a(s, d, l, h, e[t + 13], 4, 681279174), h = a(h, s, d, l, e[t], 11, -358537222), l = a(l, h, s, d, e[t + 3], 16, -722521979), d = a(d, l, h, s, e[t + 6], 23, 76029189), s = a(s, d, l, h, e[t + 9], 4, -640364487), h = a(h, s, d, l, e[t + 12], 11, -421815835), l = a(l, h, s, d, e[t + 15], 16, 530742520), d = a(d, l, h, s, e[t + 2], 23, -995338651), s = c(s, d, l, h, e[t], 6, -198630844), h = c(h, s, d, l, e[t + 7], 10, 1126891415), l = c(l, h, s, d, e[t + 14], 15, -1416354905), d = c(d, l, h, s, e[t + 5], 21, -57434055), s = c(s, d, l, h, e[t + 12], 6, 1700485571), h = c(h, s, d, l, e[t + 3], 10, -1894986606), l = c(l, h, s, d, e[t + 10], 15, -1051523), d = c(d, l, h, s, e[t + 1], 21, -2054922799), s = c(s, d, l, h, e[t + 8], 6, 1873313359), h = c(h, s, d, l, e[t + 15], 10, -30611744), l = c(l, h, s, d, e[t + 6], 15, -1560198380), d = c(d, l, h, s, e[t + 13], 21, 1309151649), s = c(s, d, l, h, e[t + 4], 6, -145523070), h = c(h, s, d, l, e[t + 11], 10, -1120210379), l = c(l, h, s, d, e[t + 2], 15, 718787259), d = c(d, l, h, s, e[t + 9], 21, -343485551), s = n(s, i), d = n(d, u), l = n(l, p), h = n(h, m)
                            }
                            return [s, d, l, h]
                        }(function(e) {
                            if (0 === e.length) return [];
                            const t = 8 * e.length,
                                n = new Uint32Array(i(t));
                            for (let i = 0; i < t; i += 8) n[i >> 5] |= (255 & e[i / 8]) << i % 32;
                            return n
                        }(e), 8 * e.length))
                    }
                },
                294: (e, t) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = function() {
                        if (!i) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                        return i(n)
                    };
                    const i = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto),
                        n = new Uint8Array(16)
                },
                7585: (e, t) => {
                    "use strict";

                    function i(e, t, i, n) {
                        switch (e) {
                            case 0:
                                return t & i ^ ~t & n;
                            case 1:
                            case 3:
                                return t ^ i ^ n;
                            case 2:
                                return t & i ^ t & n ^ i & n
                        }
                    }

                    function n(e, t) {
                        return e << t | e >>> 32 - t
                    }
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    t.default = function(e) {
                        const t = [1518500249, 1859775393, 2400959708, 3395469782],
                            s = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
                        if ("string" == typeof e) {
                            const t = unescape(encodeURIComponent(e));
                            e = [];
                            for (let i = 0; i < t.length; ++i) e.push(t.charCodeAt(i))
                        }
                        e.push(128);
                        const r = e.length / 4 + 2,
                            o = Math.ceil(r / 16),
                            a = new Array(o);
                        for (let t = 0; t < o; ++t) {
                            const i = new Uint32Array(16);
                            for (let n = 0; n < 16; ++n) i[n] = e[64 * t + 4 * n] << 24 | e[64 * t + 4 * n + 1] << 16 | e[64 * t + 4 * n + 2] << 8 | e[64 * t + 4 * n + 3];
                            a[t] = i
                        }
                        a[o - 1][14] = 8 * (e.length - 1) / Math.pow(2, 32), a[o - 1][14] = Math.floor(a[o - 1][14]), a[o - 1][15] = 8 * (e.length - 1) & 4294967295;
                        for (let e = 0; e < o; ++e) {
                            const r = new Uint32Array(80);
                            for (let t = 0; t < 16; ++t) r[t] = a[e][t];
                            for (let e = 16; e < 80; ++e) r[e] = n(r[e - 3] ^ r[e - 8] ^ r[e - 14] ^ r[e - 16], 1);
                            let o = s[0],
                                c = s[1],
                                d = s[2],
                                l = s[3],
                                h = s[4];
                            for (let e = 0; e < 80; ++e) {
                                const s = Math.floor(e / 20),
                                    a = n(o, 5) + i(s, c, d, l) + h + t[s] + r[e] >>> 0;
                                h = l, l = d, d = n(c, 30) >>> 0, c = o, o = a
                            }
                            s[0] = s[0] + o >>> 0, s[1] = s[1] + c >>> 0, s[2] = s[2] + d >>> 0, s[3] = s[3] + l >>> 0, s[4] = s[4] + h >>> 0
                        }
                        return [s[0] >> 24 & 255, s[0] >> 16 & 255, s[0] >> 8 & 255, 255 & s[0], s[1] >> 24 & 255, s[1] >> 16 & 255, s[1] >> 8 & 255, 255 & s[1], s[2] >> 24 & 255, s[2] >> 16 & 255, s[2] >> 8 & 255, 255 & s[2], s[3] >> 24 & 255, s[3] >> 16 & 255, s[3] >> 8 & 255, 255 & s[3], s[4] >> 24 & 255, s[4] >> 16 & 255, s[4] >> 8 & 255, 255 & s[4]]
                    }
                },
                3423: (e, t, i) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    var n = r(i(294)),
                        s = r(i(8144));

                    function r(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    }
                    let o, a, c = 0,
                        d = 0;
                    t.default = function(e, t, i) {
                        let r = t && i || 0;
                        const l = t || [];
                        let h = (e = e || {}).node || o,
                            u = void 0 !== e.clockseq ? e.clockseq : a;
                        if (null == h || null == u) {
                            const t = e.random || (e.rng || n.default)();
                            null == h && (h = o = [1 | t[0], t[1], t[2], t[3], t[4], t[5]]), null == u && (u = a = 16383 & (t[6] << 8 | t[7]))
                        }
                        let p = void 0 !== e.msecs ? e.msecs : Date.now(),
                            m = void 0 !== e.nsecs ? e.nsecs : d + 1;
                        const f = p - c + (m - d) / 1e4;
                        if (f < 0 && void 0 === e.clockseq && (u = u + 1 & 16383), (f < 0 || p > c) && void 0 === e.nsecs && (m = 0), m >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
                        c = p, d = m, a = u, p += 122192928e5;
                        const g = (1e4 * (268435455 & p) + m) % 4294967296;
                        l[r++] = g >>> 24 & 255, l[r++] = g >>> 16 & 255, l[r++] = g >>> 8 & 255, l[r++] = 255 & g;
                        const _ = p / 4294967296 * 1e4 & 268435455;
                        l[r++] = _ >>> 8 & 255, l[r++] = 255 & _, l[r++] = _ >>> 24 & 15 | 16, l[r++] = _ >>> 16 & 255, l[r++] = u >>> 8 | 128, l[r++] = 255 & u;
                        for (let e = 0; e < 6; ++e) l[r + e] = h[e];
                        return t || (0, s.default)(l)
                    }
                },
                89: (e, t, i) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    var n = r(i(6929)),
                        s = r(i(2862));

                    function r(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    }
                    var o = (0, n.default)("v3", 48, s.default);
                    t.default = o
                },
                6929: (e, t, i) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = function(e, t, i) {
                        function n(e, n, r, o) {
                            const a = r && o || 0;
                            if ("string" == typeof e && (e = function(e) {
                                    e = unescape(encodeURIComponent(e));
                                    const t = [];
                                    for (let i = 0; i < e.length; ++i) t.push(e.charCodeAt(i));
                                    return t
                                }(e)), "string" == typeof n && (n = function(e) {
                                    const t = [];
                                    return e.replace(/[a-fA-F0-9]{2}/g, (function(e) {
                                        t.push(parseInt(e, 16))
                                    })), t
                                }(n)), !Array.isArray(e)) throw TypeError("value must be an array of bytes");
                            if (!Array.isArray(n) || 16 !== n.length) throw TypeError("namespace must be uuid string or an Array of 16 byte values");
                            const c = i(n.concat(e));
                            if (c[6] = 15 & c[6] | t, c[8] = 63 & c[8] | 128, r)
                                for (let e = 0; e < 16; ++e) r[a + e] = c[e];
                            return r || (0, s.default)(c)
                        }
                        try {
                            n.name = e
                        } catch (e) {}
                        return n.DNS = r, n.URL = o, n
                    }, t.URL = t.DNS = void 0;
                    var n, s = (n = i(8144)) && n.__esModule ? n : {
                        default: n
                    };
                    const r = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
                    t.DNS = r;
                    const o = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
                    t.URL = o
                },
                7600: (e, t, i) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    var n = r(i(294)),
                        s = r(i(8144));

                    function r(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    }
                    t.default = function(e, t, i) {
                        "string" == typeof e && (t = "binary" === e ? new Uint8Array(16) : null, e = null);
                        const r = (e = e || {}).random || (e.rng || n.default)();
                        if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {
                            const e = i || 0;
                            for (let i = 0; i < 16; ++i) t[e + i] = r[i];
                            return t
                        }
                        return (0, s.default)(r)
                    }
                },
                9400: (e, t, i) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    var n = r(i(6929)),
                        s = r(i(7585));

                    function r(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    }
                    var o = (0, n.default)("v5", 80, s.default);
                    t.default = o
                },
                7318: e => {
                    e.exports = {
                        CAMERA: "camera",
                        DESKTOP: "desktop",
                        DESKTOP_HIGH_FPS: "desktop_high_fps",
                        NONE: "none"
                    }
                },
                4940: e => {
                    e.exports = {
                        ENVIRONMENT: "environment",
                        USER: "user"
                    }
                },
                4391: e => {
                    e.exports = {
                        AV1: "av1",
                        H264: "h264",
                        OPUS: "opus",
                        ULPFEC: "ulpfec",
                        VP8: "vp8",
                        VP9: "vp9"
                    }
                },
                9987: (e, t, i) => {
                    "use strict";
                    let n;
                    i.r(t), i.d(t, {
                            RTCEvents: () => n,
                            CREATE_ANSWER_FAILED: () => s,
                            CREATE_OFFER_FAILED: () => r,
                            DATA_CHANNEL_OPEN: () => o,
                            ENDPOINT_CONN_STATUS_CHANGED: () => a,
                            DOMINANT_SPEAKER_CHANGED: () => c,
                            LASTN_ENDPOINT_CHANGED: () => d,
                            FORWARDED_SOURCES_CHANGED: () => l,
                            PERMISSIONS_CHANGED: () => h,
                            SENDER_VIDEO_CONSTRAINTS_CHANGED: () => u,
                            LASTN_VALUE_CHANGED: () => p,
                            LOCAL_TRACK_SSRC_UPDATED: () => m,
                            LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED: () => f,
                            TRACK_ATTACHED: () => g,
                            REMOTE_TRACK_ADDED: () => _,
                            REMOTE_TRACK_MUTE: () => S,
                            REMOTE_TRACK_REMOVED: () => v,
                            REMOTE_TRACK_UNMUTE: () => E,
                            SET_LOCAL_DESCRIPTION_FAILED: () => y,
                            SET_REMOTE_DESCRIPTION_FAILED: () => T,
                            AUDIO_OUTPUT_DEVICE_CHANGED: () => C,
                            DEVICE_LIST_CHANGED: () => b,
                            DEVICE_LIST_WILL_CHANGE: () => R,
                            DEVICE_LIST_AVAILABLE: () => A,
                            ENDPOINT_MESSAGE_RECEIVED: () => P,
                            ENDPOINT_STATS_RECEIVED: () => I,
                            LOCAL_UFRAG_CHANGED: () => N,
                            REMOTE_UFRAG_CHANGED: () => D,
                            default: () => M
                        }),
                        function(e) {
                            e.CREATE_ANSWER_FAILED = "rtc.create_answer_failed", e.CREATE_OFFER_FAILED = "rtc.create_offer_failed", e.DATA_CHANNEL_OPEN = "rtc.data_channel_open", e.ENDPOINT_CONN_STATUS_CHANGED = "rtc.endpoint_conn_status_changed", e.DOMINANT_SPEAKER_CHANGED = "rtc.dominant_speaker_changed", e.LASTN_ENDPOINT_CHANGED = "rtc.lastn_endpoint_changed", e.FORWARDED_SOURCES_CHANGED = "rtc.forwarded_sources_changed", e.PERMISSIONS_CHANGED = "rtc.permissions_changed", e.SENDER_VIDEO_CONSTRAINTS_CHANGED = "rtc.sender_video_constraints_changed", e.LASTN_VALUE_CHANGED = "rtc.lastn_value_changed", e.LOCAL_TRACK_SSRC_UPDATED = "rtc.local_track_ssrc_updated", e.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED = "rtc.local_track_max_enabled_resolution_changed", e.TRACK_ATTACHED = "rtc.track_attached", e.REMOTE_TRACK_ADDED = "rtc.remote_track_added", e.REMOTE_TRACK_MUTE = "rtc.remote_track_mute", e.REMOTE_TRACK_REMOVED = "rtc.remote_track_removed", e.REMOTE_TRACK_UNMUTE = "rtc.remote_track_unmute", e.SET_LOCAL_DESCRIPTION_FAILED = "rtc.set_local_description_failed", e.SET_REMOTE_DESCRIPTION_FAILED = "rtc.set_remote_description_failed", e.AUDIO_OUTPUT_DEVICE_CHANGED = "rtc.audio_output_device_changed", e.DEVICE_LIST_CHANGED = "rtc.device_list_changed", e.DEVICE_LIST_WILL_CHANGE = "rtc.device_list_will_change", e.DEVICE_LIST_AVAILABLE = "rtc.device_list_available", e.ENDPOINT_MESSAGE_RECEIVED = "rtc.endpoint_message_received", e.ENDPOINT_STATS_RECEIVED = "rtc.endpoint_stats_received", e.LOCAL_UFRAG_CHANGED = "rtc.local_ufrag_changed", e.REMOTE_UFRAG_CHANGED = "rtc.remote_ufrag_changed"
                        }(n || (n = {}));
                    const s = n.CREATE_ANSWER_FAILED,
                        r = n.CREATE_OFFER_FAILED,
                        o = n.DATA_CHANNEL_OPEN,
                        a = n.ENDPOINT_CONN_STATUS_CHANGED,
                        c = n.DOMINANT_SPEAKER_CHANGED,
                        d = n.LASTN_ENDPOINT_CHANGED,
                        l = n.FORWARDED_SOURCES_CHANGED,
                        h = n.PERMISSIONS_CHANGED,
                        u = n.SENDER_VIDEO_CONSTRAINTS_CHANGED,
                        p = n.LASTN_VALUE_CHANGED,
                        m = n.LOCAL_TRACK_SSRC_UPDATED,
                        f = n.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED,
                        g = n.TRACK_ATTACHED,
                        _ = n.REMOTE_TRACK_ADDED,
                        S = n.REMOTE_TRACK_MUTE,
                        v = n.REMOTE_TRACK_REMOVED,
                        E = n.REMOTE_TRACK_UNMUTE,
                        y = n.SET_LOCAL_DESCRIPTION_FAILED,
                        T = n.SET_REMOTE_DESCRIPTION_FAILED,
                        C = n.AUDIO_OUTPUT_DEVICE_CHANGED,
                        b = n.DEVICE_LIST_CHANGED,
                        R = n.DEVICE_LIST_WILL_CHANGE,
                        A = n.DEVICE_LIST_AVAILABLE,
                        P = n.ENDPOINT_MESSAGE_RECEIVED,
                        I = n.ENDPOINT_STATS_RECEIVED,
                        N = n.LOCAL_UFRAG_CHANGED,
                        D = n.REMOTE_UFRAG_CHANGED,
                        M = n
                },
                6125: e => {
                    e.exports = {
                        2160: {
                            width: 3840,
                            height: 2160
                        },
                        "4k": {
                            width: 3840,
                            height: 2160
                        },
                        1080: {
                            width: 1920,
                            height: 1080
                        },
                        fullhd: {
                            width: 1920,
                            height: 1080
                        },
                        720: {
                            width: 1280,
                            height: 720
                        },
                        hd: {
                            width: 1280,
                            height: 720
                        },
                        540: {
                            width: 960,
                            height: 540
                        },
                        qhd: {
                            width: 960,
                            height: 540
                        },
                        480: {
                            width: 640,
                            height: 480
                        },
                        vga: {
                            width: 640,
                            height: 480
                        },
                        360: {
                            width: 640,
                            height: 360
                        },
                        240: {
                            width: 320,
                            height: 240
                        },
                        180: {
                            width: 320,
                            height: 180
                        }
                    }
                },
                3408: (e, t, i) => {
                    "use strict";
                    let n;
                    i.r(t), i.d(t, {
                            VideoType: () => n
                        }),
                        function(e) {
                            e.CAMERA = "camera", e.DESKTOP = "desktop"
                        }(n || (n = {}))
                },
                3514: e => {
                    e.exports = {
                        IDENTITY_UPDATED: "authentication.identity_updated"
                    }
                },
                7680: (e, t, i) => {
                    "use strict";
                    i.d(t, {
                        D: () => n
                    });
                    const n = "local"
                },
                609: (e, t, i) => {
                    "use strict";
                    let n;
                    i.r(t), i.d(t, {
                            XMPPEvents: () => n
                        }),
                        function(e) {
                            e.ADD_ICE_CANDIDATE_FAILED = "xmpp.add_ice_candidate_failed", e.AUDIO_MUTED_BY_FOCUS = "xmpp.audio_muted_by_focus", e.VIDEO_MUTED_BY_FOCUS = "xmpp.video_muted_by_focus", e.AUTHENTICATION_REQUIRED = "xmpp.authentication_required", e.BRIDGE_DOWN = "xmpp.bridge_down", e.CALL_ACCEPTED = "xmpp.callaccepted.jingle", e.CALL_INCOMING = "xmpp.callincoming.jingle", e.CALL_ENDED = "xmpp.callended.jingle", e.CHAT_ERROR_RECEIVED = "xmpp.chat_error_received", e.SETTINGS_ERROR_RECEIVED = "xmpp.settings_error_received", e.CONFERENCE_PROPERTIES_CHANGED = "xmpp.conference_properties_changed", e.CONNECTION_ESTABLISHED = "xmpp.connection.connected", e.CONNECTION_FAILED = "xmpp.connection.failed", e.CONNECTION_INTERRUPTED = "xmpp.connection.interrupted", e.CONNECTION_RESTORED = "xmpp.connection.restored", e.CONNECTION_ICE_FAILED = "xmpp.connection.ice.failed", e.CONNECTION_RESTARTED = "xmpp.connection.restart", e.CONNECTION_STATUS_CHANGED = "xmpp.connection.status.changed", e.DISPLAY_NAME_CHANGED = "xmpp.display_name_changed", e.EMUC_ROOM_ADDED = "xmpp.emuc_room_added", e.EMUC_ROOM_REMOVED = "xmpp.emuc_room_removed", e.ETHERPAD = "xmpp.etherpad", e.FOCUS_DISCONNECTED = "xmpp.focus_disconnected", e.FOCUS_LEFT = "xmpp.focus_left", e.GRACEFUL_SHUTDOWN = "xmpp.graceful_shutdown", e.ICE_RESTARTING = "rtc.ice_restarting", e.ICE_RESTART_SUCCESS = "rtc.ice_restart_success", e.KICKED = "xmpp.kicked", e.LOCAL_ROLE_CHANGED = "xmpp.localrole_changed", e.MEETING_ID_SET = "xmpp.meeting_id_set", e.MESSAGE_RECEIVED = "xmpp.message_received", e.INVITE_MESSAGE_RECEIVED = "xmpp.invite_message_received", e.PRIVATE_MESSAGE_RECEIVED = "xmpp.private_message_received", e.MUC_MEMBER_BOT_TYPE_CHANGED = "xmpp.muc_member_bot_type_changed", e.MUC_DESTROYED = "xmpp.muc_destroyed", e.MUC_JOIN_IN_PROGRESS = "xmpp.muc_join_in_progress", e.MUC_JOINED = "xmpp.muc_joined", e.MUC_MEMBER_JOINED = "xmpp.muc_member_joined", e.MUC_MEMBER_LEFT = "xmpp.muc_member_left", e.MUC_LOBBY_MEMBER_JOINED = "xmpp.muc_lobby_member_joined", e.MUC_LOBBY_MEMBER_UPDATED = "xmpp.muc_lobby_member_updated", e.MUC_LOBBY_MEMBER_LEFT = "xmpp.muc_lobby_member_left", e.MUC_DENIED_ACCESS = "xmpp.muc_denied access", e.MUC_LEFT = "xmpp.muc_left", e.MUC_ROLE_CHANGED = "xmpp.muc_role_changed", e.MUC_LOCK_CHANGED = "xmpp.muc_lock_changed", e.MUC_MEMBERS_ONLY_CHANGED = "xmpp.muc_members_only_changed", e.PARTICIPANT_AUDIO_MUTED = "xmpp.audio_muted", e.PARTICIPANT_VIDEO_MUTED = "xmpp.video_muted", e.PARTICIPANT_VIDEO_TYPE_CHANGED = "xmpp.video_type", e.PARTICIPANT_FEATURES_CHANGED = "xmpp.participant_features_changed", e.PASSWORD_REQUIRED = "xmpp.password_required", e.PHONE_NUMBER_CHANGED = "conference.phoneNumberChanged", e.PRESENCE_RECEIVED = "xmpp.presence_received", e.PRESENCE_STATUS = "xmpp.presence_status", e.PROMPT_FOR_LOGIN = "xmpp.prompt_for_login", e.READY_TO_JOIN = "xmpp.ready_to_join", e.RECORDER_STATE_CHANGED = "xmpp.recorderStateChanged", e.REMOTE_STATS = "xmpp.remote_stats", e.RENEGOTIATION_FAILED = "xmpp.renegotiation_failed", e.RESERVATION_ERROR = "xmpp.room_reservation_error", e.ROOM_CONNECT_ERROR = "xmpp.room_connect_error", e.ROOM_CONNECT_NOT_ALLOWED_ERROR = "xmpp.room_connect_error.not_allowed", e.ROOM_JOIN_ERROR = "xmpp.room_join_error", e.ROOM_CONNECT_MEMBERS_ONLY_ERROR = "xmpp.room_connect_error.members_only", e.ROOM_MAX_USERS_ERROR = "xmpp.room_max_users_error", e.SENDING_CHAT_MESSAGE = "xmpp.sending_chat_message", e.SENDING_PRIVATE_CHAT_MESSAGE = "xmpp.sending_private_chat_message", e.SESSION_ACCEPT = "xmpp.session_accept", e.SESSION_ACCEPT_ERROR = "xmpp.session_accept_error", e.SESSION_ACCEPT_TIMEOUT = "xmpp.session_accept_timeout", e.SOURCE_ADD = "xmpp.source_add", e.SOURCE_ADD_ERROR = "xmpp.source_add_error", e.SOURCE_REMOVE = "xmpp.source_remove", e.SOURCE_REMOVE_ERROR = "xmpp.source_remove_error", e.SPEAKER_STATS_RECEIVED = "xmpp.speaker_stats_received", e.CONFERENCE_TIMESTAMP_RECEIVED = "xmpp.conference_timestamp_received", e.AV_MODERATION_APPROVED = "xmpp.av_moderation.approved", e.AV_MODERATION_REJECTED = "xmpp.av_moderation.rejected", e.AV_MODERATION_RECEIVED = "xmpp.av_moderation.received", e.AV_MODERATION_CHANGED = "xmpp.av_moderation.changed", e.AV_MODERATION_PARTICIPANT_APPROVED = "xmpp.av_moderation.participant.approved", e.AV_MODERATION_PARTICIPANT_REJECTED = "xmpp.av_moderation.participant.rejected", e.BREAKOUT_ROOMS_MOVE_TO_ROOM = "xmpp.breakout-rooms.move-to-room", e.BREAKOUT_ROOMS_EVENT = "xmpp.breakout-rooms.event", e.BREAKOUT_ROOMS_UPDATED = "xmpp.breakout-rooms.updated", e.START_MUTED_FROM_FOCUS = "xmpp.start_muted_from_focus", e.SUBJECT_CHANGED = "xmpp.subject_changed", e.SUSPEND_DETECTED = "xmpp.suspend_detected", e.TRANSCRIPTION_STATUS_CHANGED = "xmpp.transcription_status_changed", e.TRANSPORT_INFO = "xmpp.transportinfo.jingle", e.VIDEO_SIP_GW_AVAILABILITY_CHANGED = "xmpp.videoSIPGWAvailabilityChanged", e.VIDEO_SIP_GW_SESSION_STATE_CHANGED = "xmpp.videoSIPGWSessionStateChanged", e.ICE_CONNECTION_STATE_CHANGED = "xmpp.ice_connection_state_changed", e.JSON_MESSAGE_RECEIVED = "xmmp.json_message_received"
                        }(n || (n = {}))
                },
                79: (e, t, i) => {
                    "use strict";
                    i.d(t, {
                        default: () => su
                    });
                    var n = {};
                    i.r(n), i.d(n, {
                        AUTHENTICATION_REQUIRED: () => T,
                        CHAT_ERROR: () => C,
                        CONFERENCE_ACCESS_DENIED: () => M,
                        CONFERENCE_DESTROYED: () => R,
                        CONFERENCE_MAX_USERS: () => A,
                        CONFERENCE_RESTARTED: () => I,
                        CONNECTION_ERROR: () => P,
                        FOCUS_DISCONNECTED: () => O,
                        FOCUS_LEFT: () => w,
                        GRACEFUL_SHUTDOWN: () => L,
                        ICE_FAILED: () => k,
                        INCOMPATIBLE_SERVER_VERSIONS: () => x,
                        JitsiConferenceErrors: () => y,
                        MEMBERS_ONLY_ERROR: () => D,
                        NOT_ALLOWED_ERROR: () => N,
                        OFFER_ANSWER_FAILED: () => F,
                        PASSWORD_NOT_SUPPORTED: () => V,
                        PASSWORD_REQUIRED: () => U,
                        RESERVATION_ERROR: () => j,
                        SETTINGS_ERROR: () => b,
                        VIDEOBRIDGE_NOT_AVAILABLE: () => H
                    });
                    var s = {};
                    i.r(s), i.d(s, {
                        AUDIO_INPUT_STATE_CHANGE: () => J,
                        AUDIO_UNMUTE_PERMISSIONS_CHANGED: () => G,
                        AUTH_STATUS_CHANGED: () => K,
                        AV_MODERATION_APPROVED: () => et,
                        AV_MODERATION_CHANGED: () => it,
                        AV_MODERATION_PARTICIPANT_APPROVED: () => nt,
                        AV_MODERATION_PARTICIPANT_REJECTED: () => st,
                        AV_MODERATION_REJECTED: () => tt,
                        BEFORE_STATISTICS_DISPOSED: () => q,
                        BOT_TYPE_CHANGED: () => ze,
                        BREAKOUT_ROOMS_MOVE_TO_ROOM: () => ot,
                        BREAKOUT_ROOMS_UPDATED: () => at,
                        CONFERENCE_CREATED_TIMESTAMP: () => oe,
                        CONFERENCE_ERROR: () => W,
                        CONFERENCE_FAILED: () => X,
                        CONFERENCE_JOINED: () => Q,
                        CONFERENCE_JOIN_IN_PROGRESS: () => z,
                        CONFERENCE_LEFT: () => Y,
                        CONFERENCE_UNIQUE_ID_SET: () => Z,
                        CONNECTION_ESTABLISHED: () => ee,
                        CONNECTION_INTERRUPTED: () => te,
                        CONNECTION_RESTORED: () => ie,
                        DATA_CHANNEL_OPENED: () => ne,
                        DISPLAY_NAME_CHANGED: () => se,
                        DOMINANT_SPEAKER_CHANGED: () => re,
                        DTMF_SUPPORT_CHANGED: () => ae,
                        ENDPOINT_MESSAGE_RECEIVED: () => ce,
                        ENDPOINT_STATS_RECEIVED: () => de,
                        FACE_LANDMARK_ADDED: () => rt,
                        FORWARDED_SOURCES_CHANGED: () => me,
                        JVB121_STATUS: () => le,
                        JitsiConferenceEvents: () => B,
                        KICKED: () => he,
                        LAST_N_ENDPOINTS_CHANGED: () => pe,
                        LOBBY_USER_JOINED: () => Qe,
                        LOBBY_USER_LEFT: () => Ze,
                        LOBBY_USER_UPDATED: () => Ye,
                        LOCK_STATE_CHANGED: () => fe,
                        MEMBERS_ONLY_CHANGED: () => ve,
                        MESSAGE_RECEIVED: () => Ee,
                        NOISY_MIC: () => Te,
                        NON_PARTICIPANT_MESSAGE_RECEIVED: () => Ce,
                        NO_AUDIO_INPUT: () => ye,
                        P2P_STATUS: () => Ie,
                        PARTCIPANT_FEATURES_CHANGED: () => Ae,
                        PARTICIPANT_CONN_STATUS_CHANGED: () => Re,
                        PARTICIPANT_KICKED: () => ue,
                        PARTICIPANT_PROPERTY_CHANGED: () => Pe,
                        PHONE_NUMBER_CHANGED: () => Ne,
                        PRIVATE_MESSAGE_RECEIVED: () => be,
                        PROPERTIES_CHANGED: () => De,
                        RECORDER_STATE_CHANGED: () => Me,
                        SERVER_REGION_CHANGED: () => ge,
                        STARTED_MUTED: () => ke,
                        START_MUTED_POLICY_CHANGED: () => Le,
                        SUBJECT_CHANGED: () => xe,
                        SUSPEND_DETECTED: () => Fe,
                        TALK_WHILE_MUTED: () => Ve,
                        TRACK_ADDED: () => Ue,
                        TRACK_AUDIO_LEVEL_CHANGED: () => je,
                        TRACK_MUTE_CHANGED: () => $e,
                        TRACK_REMOVED: () => He,
                        TRACK_UNMUTE_REJECTED: () => Be,
                        TRANSCRIPTION_STATUS_CHANGED: () => Je,
                        USER_JOINED: () => Ge,
                        USER_LEFT: () => Ke,
                        USER_ROLE_CHANGED: () => qe,
                        USER_STATUS_CHANGED: () => We,
                        VIDEO_SIP_GW_AVAILABILITY_CHANGED: () => Oe,
                        VIDEO_SIP_GW_SESSION_STATE_CHANGED: () => we,
                        VIDEO_UNMUTE_PERMISSIONS_CHANGED: () => Xe,
                        _MEDIA_SESSION_ACTIVE_CHANGED: () => Se,
                        _MEDIA_SESSION_STARTED: () => _e
                    });
                    var r = {};
                    i.r(r), i.d(r, {
                        CONSTRAINT_FAILED: () => ft,
                        ELECTRON_DESKTOP_PICKER_ERROR: () => gt,
                        ELECTRON_DESKTOP_PICKER_NOT_FOUND: () => _t,
                        GENERAL: () => St,
                        JitsiTrackErrors: () => mt,
                        NOT_FOUND: () => vt,
                        PERMISSION_DENIED: () => Et,
                        SCREENSHARING_GENERIC_ERROR: () => yt,
                        SCREENSHARING_USER_CANCELED: () => Tt,
                        TIMEOUT: () => Ct,
                        TRACK_IS_DISPOSED: () => bt,
                        TRACK_NO_STREAM_FOUND: () => Rt,
                        UNSUPPORTED_RESOLUTION: () => At
                    });
                    var o = {};
                    i.r(o), i.d(o, {
                        JitsiTrackEvents: () => Dt,
                        LOCAL_TRACK_STOPPED: () => Mt,
                        NO_AUDIO_INPUT: () => Ft,
                        NO_DATA_FROM_SOURCE: () => xt,
                        TRACK_AUDIO_LEVEL_CHANGED: () => Ot,
                        TRACK_AUDIO_OUTPUT_CHANGED: () => wt,
                        TRACK_MUTE_CHANGED: () => Lt,
                        TRACK_STREAMING_STATUS_CHANGED: () => Vt,
                        TRACK_VIDEOTYPE_CHANGED: () => kt
                    });
                    var a = {};
                    i.r(a), i.d(a, {
                        CONNECTION_DISCONNECTED: () => Fn,
                        CONNECTION_ESTABLISHED: () => Vn,
                        CONNECTION_FAILED: () => Un,
                        DISPLAY_NAME_REQUIRED: () => $n,
                        JitsiConnectionEvents: () => xn,
                        WRONG_STATE: () => jn
                    });
                    var c = {};
                    i.r(c), i.d(c, {
                        CONNECTION_DROPPED_ERROR: () => Bn,
                        JitsiConnectionErrors: () => Hn,
                        OTHER_ERROR: () => Jn,
                        PASSWORD_REQUIRED: () => Gn,
                        SERVER_ERROR: () => Kn
                    });
                    var d = {};
                    i.r(d), i.d(d, {
                        JitsiTranscriptionStatus: () => $s,
                        OFF: () => Bs,
                        ON: () => Hs
                    });
                    var l = {};
                    i.r(l), i.d(l, {
                        fixNegotiationNeeded: () => Va,
                        shimAddTrackRemoveTrack: () => xa,
                        shimAddTrackRemoveTrackWithNative: () => ka,
                        shimGetDisplayMedia: () => Na,
                        shimGetSendersWithDtmf: () => Oa,
                        shimGetStats: () => wa,
                        shimGetUserMedia: () => Ia,
                        shimMediaStream: () => Da,
                        shimOnTrack: () => Ma,
                        shimPeerConnection: () => Fa,
                        shimSenderReceiverGetStats: () => La
                    });
                    var h = {};
                    i.r(h), i.d(h, {
                        shimAddTransceiver: () => qa,
                        shimCreateAnswer: () => za,
                        shimCreateOffer: () => Xa,
                        shimGetDisplayMedia: () => ja,
                        shimGetParameters: () => Wa,
                        shimGetUserMedia: () => Ua,
                        shimOnTrack: () => $a,
                        shimPeerConnection: () => Ha,
                        shimRTCDataChannel: () => Ka,
                        shimReceiverGetStats: () => Ja,
                        shimRemoveStream: () => Ga,
                        shimSenderGetStats: () => Ba
                    });
                    var u = {};
                    i.r(u), i.d(u, {
                        shimAudioContext: () => rc,
                        shimCallbacksAPI: () => Za,
                        shimConstraints: () => tc,
                        shimCreateOfferLegacy: () => sc,
                        shimGetUserMedia: () => ec,
                        shimLocalStreamsAPI: () => Qa,
                        shimRTCIceServerUrls: () => ic,
                        shimRemoteStreamsAPI: () => Ya,
                        shimTrackEventTransceiver: () => nc
                    });
                    var p = {};
                    i.r(p), i.d(p, {
                        removeExtmapAllowMixed: () => uc,
                        shimAddIceCandidateNullOrEmpty: () => pc,
                        shimConnectionState: () => hc,
                        shimMaxMessageSize: () => dc,
                        shimParameterlessSetLocalDescription: () => mc,
                        shimRTCIceCandidate: () => cc,
                        shimSendThrowTypeError: () => lc
                    });
                    var m = {};
                    i.r(m), i.d(m, {
                        ConnectionQualityEvents: () => Vd,
                        LOCAL_STATS_UPDATED: () => Bd,
                        REMOTE_STATS_UPDATED: () => Jd
                    });
                    var f = {};
                    i.r(f), i.d(f, {
                        AUDIO_INPUT_STATE_CHANGE: () => il,
                        DETECTOR_STATE_CHANGE: () => tl,
                        DetectionEvents: () => el,
                        NO_AUDIO_INPUT: () => nl,
                        VAD_NOISY_DEVICE: () => sl,
                        VAD_REPORT_PUBLISHED: () => rl,
                        VAD_SCORE_PUBLISHED: () => ol,
                        VAD_TALK_WHILE_MUTED: () => al
                    });
                    var g = {};
                    i.r(g), i.d(g, {
                        E2E_RTT_CHANGED: () => _l,
                        E2ePingEvents: () => gl
                    });
                    var _ = {};
                    i.r(_), i.d(_, {
                        ERROR_NO_CONNECTION: () => Eh,
                        ERROR_SESSION_EXISTS: () => yh,
                        STATE_FAILED: () => vh,
                        STATE_OFF: () => gh,
                        STATE_ON: () => fh,
                        STATE_PENDING: () => _h,
                        STATE_RETRYING: () => Sh,
                        STATUS_AVAILABLE: () => uh,
                        STATUS_BUSY: () => mh,
                        STATUS_UNDEFINED: () => ph,
                        VideoSIPGWErrorConstants: () => hh,
                        VideoSIPGWStateConstants: () => lh,
                        VideoSIPGWStatusConstants: () => dh
                    });
                    var S = {};
                    i.r(S), i.d(S, {
                        DEVICE_LIST_CHANGED: () => Lh,
                        JitsiMediaDevicesEvents: () => wh,
                        PERMISSIONS_CHANGED: () => kh,
                        PERMISSION_PROMPT_IS_SHOWN: () => xh,
                        SLOW_GET_USER_MEDIA: () => Fh
                    });
                    var v = i(5810),
                        E = i.n(v);
                    let y;
                    ! function(e) {
                        e.AUTHENTICATION_REQUIRED = "conference.authenticationRequired", e.CHAT_ERROR = "conference.chatError", e.SETTINGS_ERROR = "conference.settingsError", e.CONFERENCE_DESTROYED = "conference.destroyed", e.CONFERENCE_MAX_USERS = "conference.max_users", e.CONNECTION_ERROR = "conference.connectionError", e.CONFERENCE_RESTARTED = "conference.restarted", e.NOT_ALLOWED_ERROR = "conference.connectionError.notAllowed", e.MEMBERS_ONLY_ERROR = "conference.connectionError.membersOnly", e.CONFERENCE_ACCESS_DENIED = "conference.connectionError.accessDenied", e.FOCUS_DISCONNECTED = "conference.focusDisconnected", e.FOCUS_LEFT = "conference.focusLeft", e.GRACEFUL_SHUTDOWN = "conference.gracefulShutdown", e.ICE_FAILED = "conference.iceFailed", e.INCOMPATIBLE_SERVER_VERSIONS = "conference.incompatible_server_versions", e.OFFER_ANSWER_FAILED = "conference.offerAnswerFailed", e.PASSWORD_NOT_SUPPORTED = "conference.passwordNotSupported", e.PASSWORD_REQUIRED = "conference.passwordRequired", e.RESERVATION_ERROR = "conference.reservationError", e.VIDEOBRIDGE_NOT_AVAILABLE = "conference.videobridgeNotAvailable"
                    }(y || (y = {}));
                    const T = y.AUTHENTICATION_REQUIRED,
                        C = y.CHAT_ERROR,
                        b = y.SETTINGS_ERROR,
                        R = y.CONFERENCE_DESTROYED,
                        A = y.CONFERENCE_MAX_USERS,
                        P = y.CONNECTION_ERROR,
                        I = y.CONFERENCE_RESTARTED,
                        N = y.NOT_ALLOWED_ERROR,
                        D = y.MEMBERS_ONLY_ERROR,
                        M = y.CONFERENCE_ACCESS_DENIED,
                        O = y.FOCUS_DISCONNECTED,
                        w = y.FOCUS_LEFT,
                        L = y.GRACEFUL_SHUTDOWN,
                        k = y.ICE_FAILED,
                        x = y.INCOMPATIBLE_SERVER_VERSIONS,
                        F = y.OFFER_ANSWER_FAILED,
                        V = y.PASSWORD_NOT_SUPPORTED,
                        U = y.PASSWORD_REQUIRED,
                        j = y.RESERVATION_ERROR,
                        H = y.VIDEOBRIDGE_NOT_AVAILABLE;
                    let B;
                    ! function(e) {
                        e.AUDIO_INPUT_STATE_CHANGE = "conference.audio_input_state_changed", e.AUDIO_UNMUTE_PERMISSIONS_CHANGED = "conference.audio_unmute_permissions_changed", e.AUTH_STATUS_CHANGED = "conference.auth_status_changed", e.BEFORE_STATISTICS_DISPOSED = "conference.beforeStatisticsDisposed", e.CONFERENCE_ERROR = "conference.error", e.CONFERENCE_FAILED = "conference.failed", e.CONFERENCE_JOIN_IN_PROGRESS = "conference.join_in_progress", e.CONFERENCE_JOINED = "conference.joined", e.CONFERENCE_LEFT = "conference.left", e.CONFERENCE_UNIQUE_ID_SET = "conference.unique_id_set", e.CONNECTION_ESTABLISHED = "conference.connectionEstablished", e.CONNECTION_INTERRUPTED = "conference.connectionInterrupted", e.CONNECTION_RESTORED = "conference.connectionRestored", e.DATA_CHANNEL_OPENED = "conference.dataChannelOpened", e.DISPLAY_NAME_CHANGED = "conference.displayNameChanged", e.DOMINANT_SPEAKER_CHANGED = "conference.dominantSpeaker", e.CONFERENCE_CREATED_TIMESTAMP = "conference.createdTimestamp", e.DTMF_SUPPORT_CHANGED = "conference.dtmfSupportChanged", e.ENDPOINT_MESSAGE_RECEIVED = "conference.endpoint_message_received", e.ENDPOINT_STATS_RECEIVED = "conference.endpoint_stats_received", e.JVB121_STATUS = "conference.jvb121Status", e.KICKED = "conference.kicked", e.PARTICIPANT_KICKED = "conference.participant_kicked", e.LAST_N_ENDPOINTS_CHANGED = "conference.lastNEndpointsChanged", e.FORWARDED_SOURCES_CHANGED = "conference.forwardedSourcesChanged", e.LOCK_STATE_CHANGED = "conference.lock_state_changed", e.SERVER_REGION_CHANGED = "conference.server_region_changed", e._MEDIA_SESSION_STARTED = "conference.media_session.started", e._MEDIA_SESSION_ACTIVE_CHANGED = "conference.media_session.active_changed", e.MEMBERS_ONLY_CHANGED = "conference.membersOnlyChanged", e.MESSAGE_RECEIVED = "conference.messageReceived", e.NO_AUDIO_INPUT = "conference.no_audio_input", e.NOISY_MIC = "conference.noisy_mic", e.NON_PARTICIPANT_MESSAGE_RECEIVED = "conference.non_participant_message_received", e.PRIVATE_MESSAGE_RECEIVED = "conference.privateMessageReceived", e.PARTICIPANT_CONN_STATUS_CHANGED = "conference.participant_conn_status_changed", e.PARTCIPANT_FEATURES_CHANGED = "conference.partcipant_features_changed", e.PARTICIPANT_PROPERTY_CHANGED = "conference.participant_property_changed", e.P2P_STATUS = "conference.p2pStatus", e.PHONE_NUMBER_CHANGED = "conference.phoneNumberChanged", e.PROPERTIES_CHANGED = "conference.propertiesChanged", e.RECORDER_STATE_CHANGED = "conference.recorderStateChanged", e.VIDEO_SIP_GW_AVAILABILITY_CHANGED = "conference.videoSIPGWAvailabilityChanged", e.VIDEO_SIP_GW_SESSION_STATE_CHANGED = "conference.videoSIPGWSessionStateChanged", e.START_MUTED_POLICY_CHANGED = "conference.start_muted_policy_changed", e.STARTED_MUTED = "conference.started_muted", e.SUBJECT_CHANGED = "conference.subjectChanged", e.SUSPEND_DETECTED = "conference.suspendDetected", e.TALK_WHILE_MUTED = "conference.talk_while_muted", e.TRACK_ADDED = "conference.trackAdded", e.TRACK_AUDIO_LEVEL_CHANGED = "conference.audioLevelsChanged", e.TRACK_MUTE_CHANGED = "conference.trackMuteChanged", e.TRACK_REMOVED = "conference.trackRemoved", e.TRACK_UNMUTE_REJECTED = "conference.trackUnmuteRejected", e.TRANSCRIPTION_STATUS_CHANGED = "conference.transcriptionStatusChanged", e.USER_JOINED = "conference.userJoined", e.USER_LEFT = "conference.userLeft", e.USER_ROLE_CHANGED = "conference.roleChanged", e.USER_STATUS_CHANGED = "conference.statusChanged", e.VIDEO_UNMUTE_PERMISSIONS_CHANGED = "conference.video_unmute_permissions_changed", e.BOT_TYPE_CHANGED = "conference.bot_type_changed", e.LOBBY_USER_JOINED = "conference.lobby.userJoined", e.LOBBY_USER_UPDATED = "conference.lobby.userUpdated", e.LOBBY_USER_LEFT = "conference.lobby.userLeft", e.AV_MODERATION_APPROVED = "conference.av_moderation.approved", e.AV_MODERATION_REJECTED = "conference.av_moderation.rejected", e.AV_MODERATION_CHANGED = "conference.av_moderation.changed", e.AV_MODERATION_PARTICIPANT_APPROVED = "conference.av_moderation.participant.approved", e.AV_MODERATION_PARTICIPANT_REJECTED = "conference.av_moderation.participant.rejected", e.FACE_LANDMARK_ADDED = "conference.face_landmark.added", e.BREAKOUT_ROOMS_MOVE_TO_ROOM = "conference.breakout-rooms.move-to-room", e.BREAKOUT_ROOMS_UPDATED = "conference.breakout-rooms.updated"
                    }(B || (B = {}));
                    const J = B.AUDIO_INPUT_STATE_CHANGE,
                        G = B.AUDIO_UNMUTE_PERMISSIONS_CHANGED,
                        K = B.AUTH_STATUS_CHANGED,
                        q = B.BEFORE_STATISTICS_DISPOSED,
                        W = B.CONFERENCE_ERROR,
                        X = B.CONFERENCE_FAILED,
                        z = B.CONFERENCE_JOIN_IN_PROGRESS,
                        Q = B.CONFERENCE_JOINED,
                        Y = B.CONFERENCE_LEFT,
                        Z = B.CONFERENCE_UNIQUE_ID_SET,
                        ee = B.CONNECTION_ESTABLISHED,
                        te = B.CONNECTION_INTERRUPTED,
                        ie = B.CONNECTION_RESTORED,
                        ne = B.DATA_CHANNEL_OPENED,
                        se = B.DISPLAY_NAME_CHANGED,
                        re = B.DOMINANT_SPEAKER_CHANGED,
                        oe = B.CONFERENCE_CREATED_TIMESTAMP,
                        ae = B.DTMF_SUPPORT_CHANGED,
                        ce = B.ENDPOINT_MESSAGE_RECEIVED,
                        de = B.ENDPOINT_STATS_RECEIVED,
                        le = B.JVB121_STATUS,
                        he = B.KICKED,
                        ue = B.PARTICIPANT_KICKED,
                        pe = B.LAST_N_ENDPOINTS_CHANGED,
                        me = B.FORWARDED_SOURCES_CHANGED,
                        fe = B.LOCK_STATE_CHANGED,
                        ge = B.SERVER_REGION_CHANGED,
                        _e = B._MEDIA_SESSION_STARTED,
                        Se = B._MEDIA_SESSION_ACTIVE_CHANGED,
                        ve = B.MEMBERS_ONLY_CHANGED,
                        Ee = B.MESSAGE_RECEIVED,
                        ye = B.NO_AUDIO_INPUT,
                        Te = B.NOISY_MIC,
                        Ce = B.NON_PARTICIPANT_MESSAGE_RECEIVED,
                        be = B.PRIVATE_MESSAGE_RECEIVED,
                        Re = B.PARTICIPANT_CONN_STATUS_CHANGED,
                        Ae = B.PARTCIPANT_FEATURES_CHANGED,
                        Pe = B.PARTICIPANT_PROPERTY_CHANGED,
                        Ie = B.P2P_STATUS,
                        Ne = B.PHONE_NUMBER_CHANGED,
                        De = B.PROPERTIES_CHANGED,
                        Me = B.RECORDER_STATE_CHANGED,
                        Oe = B.VIDEO_SIP_GW_AVAILABILITY_CHANGED,
                        we = B.VIDEO_SIP_GW_SESSION_STATE_CHANGED,
                        Le = B.START_MUTED_POLICY_CHANGED,
                        ke = B.STARTED_MUTED,
                        xe = B.SUBJECT_CHANGED,
                        Fe = B.SUSPEND_DETECTED,
                        Ve = B.TALK_WHILE_MUTED,
                        Ue = B.TRACK_ADDED,
                        je = B.TRACK_AUDIO_LEVEL_CHANGED,
                        $e = B.TRACK_MUTE_CHANGED,
                        He = B.TRACK_REMOVED,
                        Be = B.TRACK_UNMUTE_REJECTED,
                        Je = B.TRANSCRIPTION_STATUS_CHANGED,
                        Ge = B.USER_JOINED,
                        Ke = B.USER_LEFT,
                        qe = B.USER_ROLE_CHANGED,
                        We = B.USER_STATUS_CHANGED,
                        Xe = B.VIDEO_UNMUTE_PERMISSIONS_CHANGED,
                        ze = B.BOT_TYPE_CHANGED,
                        Qe = B.LOBBY_USER_JOINED,
                        Ye = B.LOBBY_USER_UPDATED,
                        Ze = B.LOBBY_USER_LEFT,
                        et = B.AV_MODERATION_APPROVED,
                        tt = B.AV_MODERATION_REJECTED,
                        it = B.AV_MODERATION_CHANGED,
                        nt = B.AV_MODERATION_PARTICIPANT_APPROVED,
                        st = B.AV_MODERATION_PARTICIPANT_REJECTED,
                        rt = B.FACE_LANDMARK_ADDED,
                        ot = B.BREAKOUT_ROOMS_MOVE_TO_ROOM,
                        at = B.BREAKOUT_ROOMS_UPDATED;
                    var ct = i(6857),
                        dt = i.n(ct),
                        lt = i(7047),
                        ht = i.n(lt),
                        ut = i(6033);
                    const pt = "https://api.callstats.io/static/callstats-ws.min.js";
                    let mt;
                    ! function(e) {
                        e.CONSTRAINT_FAILED = "gum.constraint_failed", e.ELECTRON_DESKTOP_PICKER_ERROR = "gum.electron_desktop_picker_error", e.ELECTRON_DESKTOP_PICKER_NOT_FOUND = "gum.electron_desktop_picker_not_found", e.GENERAL = "gum.general", e.NOT_FOUND = "gum.not_found", e.PERMISSION_DENIED = "gum.permission_denied", e.SCREENSHARING_GENERIC_ERROR = "gum.screensharing_generic_error", e.SCREENSHARING_USER_CANCELED = "gum.screensharing_user_canceled", e.TIMEOUT = "gum.timeout", e.TRACK_IS_DISPOSED = "track.track_is_disposed", e.TRACK_NO_STREAM_FOUND = "track.no_stream_found", e.UNSUPPORTED_RESOLUTION = "gum.unsupported_resolution"
                    }(mt || (mt = {}));
                    const ft = mt.CONSTRAINT_FAILED,
                        gt = mt.ELECTRON_DESKTOP_PICKER_ERROR,
                        _t = mt.ELECTRON_DESKTOP_PICKER_NOT_FOUND,
                        St = mt.GENERAL,
                        vt = mt.NOT_FOUND,
                        Et = mt.PERMISSION_DENIED,
                        yt = mt.SCREENSHARING_GENERIC_ERROR,
                        Tt = mt.SCREENSHARING_USER_CANCELED,
                        Ct = mt.TIMEOUT,
                        bt = mt.TRACK_IS_DISPOSED,
                        Rt = mt.TRACK_NO_STREAM_FOUND,
                        At = mt.UNSUPPORTED_RESOLUTION,
                        Pt = {};

                    function It(e, t, i) {
                        if ("object" == typeof e && void 0 !== e.name) switch (this.gum = {
                                error: e,
                                constraints: t,
                                devices: i && Array.isArray(i) ? i.slice(0) : void 0
                            }, e.name) {
                            case "NotAllowedError":
                            case "PermissionDeniedError":
                            case "SecurityError":
                                this.name = Et, this.message = Pt[this.name] + (this.gum.devices || []).join(", ");
                                break;
                            case "DevicesNotFoundError":
                            case "NotFoundError":
                                this.name = vt, this.message = Pt[this.name] + (this.gum.devices || []).join(", ");
                                break;
                            case "ConstraintNotSatisfiedError":
                            case "OverconstrainedError": {
                                const n = e.constraintName || e.constraint;
                                t && t.video && (!i || i.indexOf("video") > -1) && ("minWidth" === n || "maxWidth" === n || "minHeight" === n || "maxHeight" === n || "width" === n || "height" === n || "deviceId" === n) ? (this.name = At, this.message = Pt[this.name] + function(e, t) {
                                    if (t && t.video && t.video.mandatory) switch (e) {
                                        case "width":
                                            return t.video.mandatory.minWidth;
                                        case "height":
                                            return t.video.mandatory.minHeight;
                                        default:
                                            return t.video.mandatory[e] || ""
                                    }
                                    return ""
                                }(n, t)) : (this.name = ft, this.message = Pt[this.name] + e.constraintName);
                                break
                            }
                            default:
                                this.name = St, this.message = e.message || Pt[this.name]
                        } else {
                            if ("string" != typeof e) throw new Error("Invalid arguments");
                            Pt[e] ? (this.name = e, this.message = t || Pt[e]) : this.message = e
                        }
                        this.stack = e.stack || (new Error).stack
                    }
                    Pt[At] = "Video resolution is not supported: ", Pt[Tt] = "User canceled screen sharing prompt", Pt[yt] = "Unknown error from screensharing", Pt[gt] = "Unkown error from desktop picker", Pt[_t] = "Failed to detect desktop picker", Pt[St] = "Generic getUserMedia error", Pt[Et] = "User denied permission to use device(s): ", Pt[vt] = "Requested device(s) was/were not found: ", Pt[ft] = "Constraint could not be satisfied: ", Pt[Ct] = "Could not start media source. Timeout occured!", Pt[bt] = "Track has been already disposed", Pt[Rt] = "Track does not have an associated Media Stream", It.prototype = Object.create(Error.prototype), It.prototype.constructor = It;
                    const Nt = It;
                    let Dt;
                    ! function(e) {
                        e.LOCAL_TRACK_STOPPED = "track.stopped", e.TRACK_AUDIO_LEVEL_CHANGED = "track.audioLevelsChanged", e.TRACK_AUDIO_OUTPUT_CHANGED = "track.audioOutputChanged", e.TRACK_MUTE_CHANGED = "track.trackMuteChanged", e.TRACK_VIDEOTYPE_CHANGED = "track.videoTypeChanged", e.NO_DATA_FROM_SOURCE = "track.no_data_from_source", e.NO_AUDIO_INPUT = "track.no_audio_input", e.TRACK_STREAMING_STATUS_CHANGED = "track.streaming_status_changed"
                    }(Dt || (Dt = {}));
                    const Mt = Dt.LOCAL_TRACK_STOPPED,
                        Ot = Dt.TRACK_AUDIO_LEVEL_CHANGED,
                        wt = Dt.TRACK_AUDIO_OUTPUT_CHANGED,
                        Lt = Dt.TRACK_MUTE_CHANGED,
                        kt = Dt.TRACK_VIDEOTYPE_CHANGED,
                        xt = Dt.NO_DATA_FROM_SOURCE,
                        Ft = Dt.NO_AUDIO_INPUT,
                        Vt = Dt.TRACK_STREAMING_STATUS_CHANGED;
                    let Ut;
                    ! function(e) {
                        e.TYPE_OPERATIONAL = "operational", e.TYPE_PAGE = "page", e.TYPE_TRACK = "track", e.TYPE_UI = "ui", e.ACTION_JINGLE_RESTART = "restart", e.ACTION_JINGLE_SA_TIMEOUT = "session-accept.timeout", e.ACTION_JINGLE_SI_RECEIVED = "session-initiate.received", e.ACTION_JINGLE_SI_TIMEOUT = "session-initiate.timeout", e.ACTION_JINGLE_TERMINATE = "terminate", e.ACTION_JINGLE_TR_RECEIVED = "transport-replace.received", e.ACTION_JINGLE_TR_SUCCESS = "transport-replace.success", e.ACTION_P2P_DECLINED = "decline", e.ACTION_P2P_ESTABLISHED = "established", e.ACTION_P2P_FAILED = "failed", e.ACTION_P2P_SWITCH_TO_JVB = "switch.to.jvb", e.AVAILABLE_DEVICE = "available.device", e.CONNECTION_DISCONNECTED = "connection.disconnected", e.FEEDBACK = "feedback", e.ICE_DURATION = "ice.duration", e.ICE_ESTABLISHMENT_DURATION_DIFF = "ice.establishment.duration.diff", e.ICE_STATE_CHANGED = "ice.state.changed", e.NO_BYTES_SENT = "track.no-bytes-sent", e.TRACK_UNMUTED = "track.unmuted"
                    }(Ut || (Ut = {}));
                    const jt = Ut.TYPE_OPERATIONAL,
                        $t = Ut.TYPE_PAGE,
                        Ht = Ut.TYPE_TRACK,
                        Bt = Ut.TYPE_UI,
                        Jt = Ut.ACTION_JINGLE_RESTART,
                        Gt = Ut.ACTION_JINGLE_SA_TIMEOUT,
                        Kt = Ut.ACTION_JINGLE_SI_RECEIVED,
                        qt = Ut.ACTION_JINGLE_SI_TIMEOUT,
                        Wt = Ut.ACTION_JINGLE_TERMINATE,
                        Xt = Ut.ACTION_JINGLE_TR_RECEIVED,
                        zt = Ut.ACTION_JINGLE_TR_SUCCESS,
                        Qt = Ut.ACTION_P2P_DECLINED,
                        Yt = Ut.ACTION_P2P_ESTABLISHED,
                        Zt = Ut.ACTION_P2P_FAILED,
                        ei = Ut.ACTION_P2P_SWITCH_TO_JVB,
                        ti = Ut.AVAILABLE_DEVICE,
                        ii = Ut.CONNECTION_DISCONNECTED,
                        ni = Ut.FEEDBACK,
                        si = Ut.ICE_DURATION,
                        ri = Ut.ICE_ESTABLISHMENT_DURATION_DIFF,
                        oi = Ut.ICE_STATE_CHANGED,
                        ai = Ut.NO_BYTES_SENT,
                        ci = Ut.TRACK_UNMUTED,
                        di = (e, t) => ({
                            action: e,
                            attributes: t,
                            source: "conference",
                            type: Ut.TYPE_OPERATIONAL
                        }),
                        li = (e, t) => ({
                            action: "connection.stage.reached",
                            actionSubject: e,
                            attributes: t,
                            source: "connection.stage.reached",
                            type: Ut.TYPE_OPERATIONAL
                        }),
                        hi = function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            return {
                                type: Ut.TYPE_OPERATIONAL,
                                source: "get.user.media",
                                action: e,
                                attributes: t
                            }
                        },
                        ui = function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            return {
                                type: Ut.TYPE_OPERATIONAL,
                                action: e,
                                source: "jingle",
                                attributes: t
                            }
                        },
                        pi = function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            return {
                                type: Ut.TYPE_OPERATIONAL,
                                action: e,
                                source: "p2p",
                                attributes: t
                            }
                        },
                        mi = e => ({
                            type: Ut.TYPE_OPERATIONAL,
                            action: "remotely.muted",
                            mediaType: e
                        }),
                        fi = e => ({
                            type: Ut.TYPE_OPERATIONAL,
                            action: "rtp.stats",
                            attributes: e
                        });
                    let gi;
                    ! function(e) {
                        e.AUDIO_LEVEL = "statistics.audioLevel", e.BEFORE_DISPOSED = "statistics.before_disposed", e.BYTE_SENT_STATS = "statistics.byte_sent_stats", e.CONNECTION_STATS = "statistics.connectionstats", e.LONG_TASKS_STATS = "statistics.long_tasks_stats"
                    }(gi || (gi = {}));
                    const _i = gi.AUDIO_LEVEL,
                        Si = gi.BEFORE_DISPOSED,
                        vi = gi.BYTE_SENT_STATS,
                        Ei = gi.CONNECTION_STATS,
                        yi = gi.LONG_TASKS_STATS;
                    i(3478);
                    var Ti = i(7032);
                    const Ci = "chrome",
                        bi = "opera",
                        Ri = "firefox",
                        Ai = "iexplorer",
                        Pi = "safari",
                        Ii = "nwjs",
                        Ni = "electron",
                        Di = "react-native",
                        Mi = "unknown",
                        Oi = {
                            Chrome: Ci,
                            Chromium: Ci,
                            Opera: bi,
                            Firefox: Ri,
                            "Internet Explorer": Ai,
                            Safari: Pi
                        };

                    function wi() {
                        const e = navigator.userAgent;
                        if (e.match(/Electron/)) {
                            const t = e.match(/Electron(?:\s|\/)([\d.]+)/)[1];
                            return {
                                name: Ni,
                                version: t
                            }
                        }
                        if (void 0 !== window.JitsiMeetElectron) return {
                            name: Ni,
                            version: void 0
                        }
                    }

                    function Li() {
                        const e = navigator.userAgent;
                        if (e.match(/JitsiMeetNW/)) {
                            const t = e.match(/JitsiMeetNW\/([\d.]+)/)[1];
                            return {
                                name: Ii,
                                version: t
                            }
                        }
                    }

                    function ki() {
                        const e = navigator.userAgent.match(/\b(react[ \t_-]*native)(?:\/(\S+))?/i);
                        let t;
                        if (e || "ReactNative" === navigator.product) {
                            let i;
                            return e && e.length > 2 && (i = e[1], t = e[2]), i || (i = "react-native"), t || (t = "unknown"), {
                                name: Di,
                                version: t
                            }
                        }
                    }
                    class xi extends ct {
                        constructor() {
                            var e, t;
                            super(...arguments), t = {}, (e = "_storage") in this ? Object.defineProperty(this, e, {
                                value: t,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : this[e] = t
                        }
                        clear() {
                            this._storage = {}
                        }
                        get length() {
                            return Object.keys(this._storage).length
                        }
                        getItem(e) {
                            return this._storage[e]
                        }
                        setItem(e, t) {
                            this._storage[e] = t
                        }
                        removeItem(e) {
                            delete this._storage[e]
                        }
                        key(e) {
                            const t = Object.keys(this._storage);
                            if (!(t.length <= e)) return t[e]
                        }
                        serialize() {
                            return JSON.stringify(this._storage)
                        }
                    }
                    const Fi = new class extends ct {
                            constructor() {
                                super();
                                try {
                                    this._storage = window.localStorage, this._localStorageDisabled = !1
                                } catch (e) {}
                                this._storage || (console.warn("Local storage is disabled."), this._storage = new xi, this._localStorageDisabled = !0)
                            }
                            isLocalStorageDisabled() {
                                return this._localStorageDisabled
                            }
                            clear() {
                                this._storage.clear(), this.emit("changed")
                            }
                            get length() {
                                return this._storage.length
                            }
                            getItem(e) {
                                return this._storage.getItem(e)
                            }
                            setItem(e, t) {
                                let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                                this._storage.setItem(e, t), i || this.emit("changed")
                            }
                            removeItem(e) {
                                this._storage.removeItem(e), this.emit("changed")
                            }
                            key(e) {
                                return this._storage.key(e)
                            }
                            serialize() {
                                if (this.isLocalStorageDisabled()) return this._storage.serialize();
                                const e = this._storage.length,
                                    t = {};
                                for (let i = 0; i < e; i++) {
                                    const e = this._storage.key(i);
                                    t[e] = this._storage.getItem(e)
                                }
                                return JSON.stringify(t)
                            }
                        },
                        Vi = (0, v.getLogger)("modules/browser/BrowserCapabilities.js"),
                        Ui = new class extends class {
                            constructor(e) {
                                let t, i;
                                if (this._bowser = Ti.getParser(navigator.userAgent), void 0 === e) {
                                    const e = function(e) {
                                        let t;
                                        const i = [ki, wi, Li];
                                        for (let e = 0; e < i.length; e++)
                                            if (t = i[e](), t) return t;
                                        const n = e.getBrowserName();
                                        return n in Oi ? {
                                            name: Oi[n],
                                            version: e.getBrowserVersion()
                                        } : (t = function() {
                                            const e = navigator.userAgent,
                                                t = {
                                                    name: Mi,
                                                    version: void 0
                                                };
                                            if (e.match(/Chrome/) && !e.match(/Edge/))
                                                if (e.match(/Edg(A?)/)) {
                                                    const i = e.match(/Chrome\/([\d.]+)/)[1];
                                                    Number.parseInt(i, 10) > 72 && (t.name = Ci, t.version = i)
                                                } else t.name = Ci, t.version = e.match(/Chrome\/([\d.]+)/)[1];
                                            return t
                                        }(), t || {
                                            name: Mi,
                                            version: void 0
                                        })
                                    }(this._bowser);
                                    t = e.name, i = e.version
                                } else e.name in Oi ? (t = Oi[e.name], i = e.version) : (t = Mi, i = void 0);
                                this._name = t, this._version = i
                            }
                            getName() {
                                return this._name
                            }
                            isChrome() {
                                return this._name === Ci
                            }
                            isOpera() {
                                return this._name === bi
                            }
                            isFirefox() {
                                return this._name === Ri
                            }
                            isIExplorer() {
                                return this._name === Ai
                            }
                            isSafari() {
                                return this._name === Pi
                            }
                            isNWJS() {
                                return this._name === Ii
                            }
                            isElectron() {
                                return this._name === Ni
                            }
                            isReactNative() {
                                return this._name === Di
                            }
                            getVersion() {
                                return this._version
                            }
                            _checkCondition(e) {
                                if (this._version) return this._bowser.satisfies(e)
                            }
                            isVersionGreaterThan(e) {
                                return this._checkCondition({
                                    [this._name]: `>${e}`
                                })
                            }
                            isVersionLessThan(e) {
                                return this._checkCondition({
                                    [this._name]: `<${e}`
                                })
                            }
                            isVersionEqualTo(e) {
                                return this._checkCondition({
                                    [this._name]: `~${e}`
                                })
                            }
                        } {
                            constructor() {
                                super(), Vi.info(`This appears to be ${this.getName()}, ver: ${this.getVersion()}`)
                            }
                            doesVideoMuteByStreamRemove() {
                                return this.isChromiumBased() || this.isWebKitBased() || this.isFirefox()
                            }
                            isChromiumBased() {
                                return (this.isChrome() || this.isElectron() || this.isNWJS() || this.isOpera()) && !this.isWebKitBased()
                            }
                            isIosBrowser() {
                                const {
                                    userAgent: e,
                                    maxTouchPoints: t,
                                    platform: i
                                } = navigator;
                                return Boolean(e.match(/iP(ad|hone|od)/i)) || t && t > 2 && /MacIntel/.test(i)
                            }
                            isWebKitBased() {
                                return this._bowser.isEngine("webkit") && void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getUserMedia && void 0 !== window.RTCRtpTransceiver && Object.keys(RTCRtpTransceiver.prototype).indexOf("currentDirection") > -1
                            }
                            isTwa() {
                                return "matchMedia" in window && window.matchMedia("(display-mode:standalone)").matches
                            }
                            isSupported() {
                                return !(this.isSafari() && this._getSafariVersion() < 14) && (this.isChromiumBased() && this._getChromiumBasedVersion() >= 72 || this.isFirefox() || this.isReactNative() || this.isWebKitBased())
                            }
                            isSupportedAndroidBrowser() {
                                return this.isChromiumBased() || this.isFirefox()
                            }
                            isSupportedIOSBrowser() {
                                return this._getIOSVersion() >= 14
                            }
                            isUserInteractionRequiredForUnmute() {
                                return this.isFirefox() && this.isVersionLessThan("68")
                            }
                            supportsVideoMuteOnConnInterrupted() {
                                return this.isChromiumBased() || this.isReactNative()
                            }
                            supportsBandwidthStatistics() {
                                return !this.isFirefox() && !this.isWebKitBased()
                            }
                            supportsCodecPreferences() {
                                return Boolean(window.RTCRtpTransceiver && "setCodecPreferences" in window.RTCRtpTransceiver.prototype && window.RTCRtpReceiver && void 0 !== window.RTCRtpReceiver.getCapabilities) && !this.isWebKitBased()
                            }
                            supportsDeviceChangeEvent() {
                                return navigator.mediaDevices && void 0 !== navigator.mediaDevices.ondevicechange && void 0 !== navigator.mediaDevices.addEventListener
                            }
                            supportsPerformanceObserver() {
                                return void 0 !== window.PerformanceObserver && PerformanceObserver.supportedEntryTypes.indexOf("longtask") > -1
                            }
                            supportsReceiverStats() {
                                return void 0 !== window.RTCRtpReceiver && Object.keys(RTCRtpReceiver.prototype).indexOf("getSynchronizationSources") > -1 && !this.isWebKitBased()
                            }
                            supportsRTTStatistics() {
                                return !this.isFirefox()
                            }
                            supportsVP9() {
                                return this.isChromiumBased() || this.isReactNative()
                            }
                            usesSdpMungingForSimulcast() {
                                return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased()
                            }
                            usesRidsForSimulcast() {
                                return !1
                            }
                            supportsGetDisplayMedia() {
                                return void 0 !== navigator.getDisplayMedia || void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getDisplayMedia
                            }
                            supportsEncodedTransform() {
                                return Boolean(window.RTCRtpScriptTransform)
                            }
                            supportsInsertableStreams() {
                                if (void 0 === window.RTCRtpSender || !window.RTCRtpSender.prototype.createEncodedStreams) return !1;
                                const e = new ReadableStream;
                                try {
                                    return window.postMessage(e, "*", [e]), !0
                                } catch {
                                    return !1
                                }
                            }
                            supportsAudioRed() {
                                return Boolean(window.RTCRtpSender && window.RTCRtpSender.getCapabilities && window.RTCRtpSender.getCapabilities("audio").codecs.some((e => "audio/red" === e.mimeType)) && window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("audio").codecs.some((e => "audio/red" === e.mimeType)))
                            }
                            supportsUnifiedPlan() {
                                return !(this.isReactNative() || this.isElectron() && this._getChromiumBasedVersion() < 96)
                            }
                            supportsVADDetection() {
                                return this.isChromiumBased()
                            }
                            supportsRTX() {
                                return !(this.isFirefox() && this.isVersionLessThan("96"))
                            }
                            _getChromiumBasedVersion() {
                                if (this.isChromiumBased()) {
                                    if (this.isNWJS()) return Number.parseInt(process.versions.chromium, 10);
                                    const e = navigator.userAgent;
                                    if (e.match(/Chrome/)) return Number.parseInt(e.match(/Chrome\/([\d.]+)/)[1], 10)
                                }
                                return -1
                            }
                            _getSafariVersion() {
                                return this.isSafari() ? Number.parseInt(this.getVersion(), 10) : -1
                            }
                            _getIOSVersion() {
                                return this.isWebKitBased() ? Number.parseInt(this.getVersion(), 10) : -1
                            }
                        };
                    var ji = i(549),
                        $i = i.n(ji);
                    const Hi = (0, v.getLogger)("modules/statistics/AnalyticsAdapter.js"),
                        Bi = new class {
                            constructor() {
                                this.reset()
                            }
                            reset() {
                                this.disposed = !1, this.analyticsHandlers = new Set, this.cache = [], this.permanentProperties = {}, this.conferenceName = "", this.addPermanentProperties({
                                    user_agent: navigator.userAgent,
                                    browser_name: Ui.getName()
                                })
                            }
                            dispose() {
                                Hi.warn("Disposing of analytics adapter."), this.analyticsHandlers && this.analyticsHandlers.size > 0 && this.analyticsHandlers.forEach((e => {
                                    "function" == typeof e.dispose && e.dispose()
                                })), this.setAnalyticsHandlers([]), this.disposed = !0
                            }
                            setAnalyticsHandlers(e) {
                                if (this.disposed) return;
                                this.analyticsHandlers = new Set(e), this._setUserProperties();
                                const t = this.cache;
                                this.cache = null, t && t.forEach((e => this._sendEvent(e)))
                            }
                            _setUserProperties() {
                                this.analyticsHandlers.forEach((e => {
                                    try {
                                        e.setUserProperties(this.permanentProperties)
                                    } catch (e) {
                                        Hi.warn(`Error in setUserProperties method of one of the analytics handlers: ${e}`)
                                    }
                                }))
                            }
                            addPermanentProperties(e) {
                                this.permanentProperties = {
                                    ...this.permanentProperties,
                                    ...e
                                }, this._setUserProperties()
                            }
                            setConferenceName(e) {
                                this.conferenceName = e, this.addPermanentProperties({
                                    conference_name: e
                                })
                            }
                            sendEvent(e) {
                                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                if (this.disposed) return;
                                let i = null;
                                "string" == typeof e ? i = {
                                    type: jt,
                                    action: e,
                                    actionSubject: e,
                                    source: e,
                                    attributes: t
                                } : "object" == typeof e && (i = e), this._verifyRequiredFields(i) ? this._sendEvent(i) : Hi.error(`Dropping a mis-formatted event: ${JSON.stringify(i)}`)
                            }
                            _verifyRequiredFields(e) {
                                if (!e) return !1;
                                e.type || (e.type = jt);
                                const t = e.type;
                                return t !== jt && t !== $t && t !== Bt && t !== Ht ? (Hi.error(`Unknown event type: ${t}`), !1) : t === $t ? Boolean(e.name) : (e.action = e.action || e.name || e.actionSubject, e.actionSubject = e.actionSubject || e.name || e.action, e.source = e.source || e.name || e.action || e.actionSubject, e.action && e.actionSubject && e.source ? !!(t !== Ht || (e.objectType = e.objectType || "generic-object-type", e.containerType = e.containerType || "conference", "conference" !== e.containerType || e.containerId || (e.containerId = this.conferenceName), e.objectType && e.objectId && e.containerType && e.containerId)) || (Hi.error("Required field missing (containerId, containerType, objectId or objectType)"), !1) : (Hi.error("Required field missing (action, actionSubject or source)"), !1))
                            }
                            _maybeCacheEvent(e) {
                                return !!this.cache && (this.cache.push(e), this.cache.length > 100 && this.cache.splice(0, 1), !0)
                            }
                            _sendEvent(e) {
                                this._maybeCacheEvent(e) || this.analyticsHandlers.forEach((t => {
                                    try {
                                        t.sendEvent(e)
                                    } catch (e) {
                                        Hi.warn(`Error sending analytics event: ${e}`)
                                    }
                                }))
                            }
                        };
                    var Ji = i(1023),
                        Gi = i.n(Ji);
                    const Ki = i(5810).getLogger("modules/statistics/CallStats.js"),
                        qi = "applicationLog",
                        Wi = "error",
                        Xi = "event",
                        zi = "mstWithUserID";
                    let Qi;
                    class Yi {
                        static _addNewFabricCallback(e, t) {
                            Yi.backend && "success" !== e && Ki.error(`Monitoring status: ${e} msg: ${t}`)
                        }
                        static _initCallback(e, t) {
                            if (Ki.log(`CallStats Status: err=${e} msg=${t}`), "success" !== e) return;
                            Yi.backendInitialized = !0;
                            let i = !1,
                                n = null;
                            for (const e of Yi.fabrics.values()) e.hasFabric || (Ki.debug("addNewFabric - initCallback"), e._addNewFabric() && (i = !0, n || (n = e)));
                            i && Yi._emptyReportQueue(n)
                        }
                        static _emptyReportQueue(e) {
                            const t = e.confID,
                                i = e.peerconnection;
                            for (const n of Yi.reportsQueue)
                                if (n.type === Wi) {
                                    const t = n.data;
                                    Yi._reportError(e, t.type, t.error, t.pc || i)
                                } else if (n.type === Xi) {
                                const e = n.data;
                                Yi.backend.sendFabricEvent(n.pc || i, e.event, t, e.eventData)
                            } else if (n.type === zi) {
                                const e = n.data;
                                Yi.backend.associateMstWithUserID(n.pc || i, e.callStatsId, t, e.ssrc, e.usageLabel, e.containerId)
                            }
                            Yi.reportsQueue.length = 0
                        }
                        static _reportError(e, t, i, n) {
                            let s = i;
                            s || (Ki.warn("No error is passed!"), s = new Error("Unknown error")), Yi.backendInitialized && e ? Yi.backend.reportError(n, e.confID, t, s) : Yi.reportsQueue.push({
                                type: Wi,
                                data: {
                                    error: s,
                                    pc: n,
                                    type: t
                                }
                            })
                        }
                        static _reportEvent(e, t, i) {
                            const n = e && e.peerconnection,
                                s = e && e.confID;
                            Yi.backendInitialized && e ? Yi.backend.sendFabricEvent(n, t, s, i) : Yi.reportsQueue.push({
                                confID: s,
                                pc: n,
                                type: Xi,
                                data: {
                                    event: t,
                                    eventData: i
                                }
                            })
                        }
                        static _traceAndCatchBackendCalls(e) {
                            const t = ["associateMstWithUserID", "sendFabricEvent", "sendUserFeedback"];
                            for (const i of t) {
                                const t = e[i];
                                e[i] = function() {
                                    try {
                                        for (var i = arguments.length, n = new Array(i), s = 0; s < i; s++) n[s] = arguments[s];
                                        return t.apply(e, n)
                                    } catch (e) {
                                        Gi().callErrorHandler(e)
                                    }
                                }
                            }
                            const i = ["associateMstWithUserID", "sendFabricEvent", "sendUserFeedback"];
                            for (const t of i) {
                                const i = e[t];
                                e[t] = function() {
                                    for (var n = arguments.length, s = new Array(n), r = 0; r < n; r++) s[r] = arguments[r];
                                    Ki.debug(t, s), i.apply(e, s)
                                }
                            }
                            const n = e.reportError;
                            e.reportError = function(t, i, s) {
                                for (var r = arguments.length, o = new Array(r > 3 ? r - 3 : 0), a = 3; a < r; a++) o[a - 3] = arguments[a];
                                s === qi ? Ui.isReactNative() || console && console.debug("reportError", t, i, s) : Ki.debug("reportError", t, i, s, ...o);
                                try {
                                    n.call(e, t, i, s, ...o)
                                } catch (e) {
                                    s === qi ? console && console.error("reportError", e) : Gi().callErrorHandler(e)
                                }
                            }
                        }
                        static get fabrics() {
                            return Qi || (Qi = new Set), Qi
                        }
                        static initBackend(e) {
                            if (Yi.backend) throw new Error("CallStats backend has been initialized already!");
                            try {
                                const t = callstats;
                                Yi.backend = new t, Yi._traceAndCatchBackendCalls(Yi.backend), Yi.userID = {
                                    aliasName: e.aliasName,
                                    userName: e.userName
                                }, Yi.callStatsID = e.callStatsID, Yi.callStatsSecret = e.callStatsSecret;
                                const i = {
                                    ...e.configParams
                                };
                                if (e.applicationName && (i.applicationVersion = `${e.applicationName} (${Ui.getName()})`), e.confID) {
                                    const t = e.confID.match(/.*\/(.*)\/.*/);
                                    i.siteID = e.siteID || t && t[1] || "/"
                                }
                                Yi.backend.initialize(Yi.callStatsID, Yi.callStatsSecret, Yi.userID, Yi._initCallback, void 0, i);
                                const n = e.getWiFiStatsMethod;
                                return n && (Yi.backend.attachWifiStatsHandler(n), n().then((e => {
                                    e && Ki.info("Reported wifi addresses:", JSON.parse(e).addresses)
                                })).catch((() => {}))), !0
                            } catch (e) {
                                return Gi().callErrorHandler(e), Yi.backend = null, Ki.error(e), !1
                            }
                        }
                        static isBackendInitialized() {
                            return Boolean(Yi.backend)
                        }
                        static sendActiveDeviceListEvent(e, t) {
                            Yi._reportEvent(t, "activeDeviceList", e)
                        }
                        static sendApplicationLog(e, t) {
                            try {
                                Yi._reportError(t, qi, e, t && t.peerconnection)
                            } catch (e) {
                                console && "function" == typeof console.error && console.error("sendApplicationLog failed", e)
                            }
                        }
                        static sendFeedback(e, t, i) {
                            return new Promise(((n, s) => {
                                if (Yi.backend) Yi.backend.sendUserFeedback(e, {
                                    userID: Yi.userID,
                                    overall: t,
                                    comment: i
                                }, ((e, t) => {
                                    "success" === e ? n(t) : s(t)
                                }));
                                else {
                                    const e = "Failed to submit feedback to CallStats - no backend";
                                    Ki.error(e), s(e)
                                }
                            }))
                        }
                        static sendGetUserMediaFailed(e, t) {
                            Yi._reportError(t, "getUserMedia", e, null)
                        }
                        static sendMuteEvent(e, t, i) {
                            let n;
                            n = "video" === t ? e ? "videoPause" : "videoResume" : e ? "audioMute" : "audioUnmute", Yi._reportEvent(i, n)
                        }
                        constructor(e, t) {
                            this.confID = t.confID, this.tpc = e, this.peerconnection = e.peerconnection, this.remoteUserID = t.remoteUserID || "jitsi", this.hasFabric = !1, Yi.fabrics.add(this), Yi.backendInitialized && (this._addNewFabric(), 1 === Yi.fabrics.size && Yi._emptyReportQueue(this))
                        }
                        _addNewFabric() {
                            Ki.info("addNewFabric", this.remoteUserID);
                            try {
                                const e = {
                                        remoteEndpointType: this.tpc.isP2P ? Yi.backend.endpointType.peer : Yi.backend.endpointType.server
                                    },
                                    t = Yi.backend.addNewFabric(this.peerconnection, this.remoteUserID, Yi.backend.fabricUsage.multiplex, this.confID, e, Yi._addNewFabricCallback);
                                this.hasFabric = !0;
                                const i = "success" === t.status;
                                return i || Ki.error("callstats fabric not initilized", t.message), i
                            } catch (e) {
                                return Gi().callErrorHandler(e), !1
                            }
                        }
                        associateStreamWithVideoTag(e, t, i, n, s) {
                            if (!Yi.backend) return;
                            const r = t ? Yi.userID : i;
                            Yi.backendInitialized ? Yi.backend.associateMstWithUserID(this.peerconnection, r, this.confID, e, n, s) : Yi.reportsQueue.push({
                                type: zi,
                                pc: this.peerconnection,
                                data: {
                                    callStatsId: r,
                                    containerId: s,
                                    ssrc: e,
                                    usageLabel: n
                                }
                            })
                        }
                        sendDominantSpeakerEvent() {
                            Yi._reportEvent(this, "dominantSpeaker")
                        }
                        sendTerminateEvent() {
                            Yi.backendInitialized && Yi.backend.sendFabricEvent(this.peerconnection, Yi.backend.fabricEvent.fabricTerminated, this.confID), Yi.fabrics.delete(this)
                        }
                        sendIceConnectionFailedEvent() {
                            Yi._reportError(this, "iceConnectionFailure", null, this.peerconnection)
                        }
                        sendCreateOfferFailed(e) {
                            Yi._reportError(this, "createOffer", e, this.peerconnection)
                        }
                        sendCreateAnswerFailed(e) {
                            Yi._reportError(this, "createAnswer", e, this.peerconnection)
                        }
                        sendResumeOrHoldEvent(e) {
                            Yi._reportEvent(this, e ? "fabricResume" : "fabricHold")
                        }
                        sendScreenSharingEvent(e, t) {
                            let i;
                            t && (i = {
                                ssrc: t
                            }), Yi._reportEvent(this, e ? "screenShareStart" : "screenShareStop", i)
                        }
                        sendSetLocalDescFailed(e) {
                            Yi._reportError(this, "setLocalDescription", e, this.peerconnection)
                        }
                        sendSetRemoteDescFailed(e) {
                            Yi._reportError(this, "setRemoteDescription", e, this.peerconnection)
                        }
                        sendAddIceCandidateFailed(e) {
                            Yi._reportError(this, "addIceCandidate", e, this.peerconnection)
                        }
                    }
                    Yi.backend = null, Yi.reportsQueue = [], Yi.backendInitialized = !1, Yi.callStatsID = null, Yi.callStatsSecret = null, Yi.userID = null;
                    const Zi = i(5810).getLogger("modules/statistics/LocalStatsCollector.js");
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    let en = null;

                    function tn(e, t, i) {
                        this.stream = e, this.intervalId = null, this.intervalMilis = t, this.audioLevel = 0, this.callback = i, this.source = null, this.analyser = null
                    }

                    function nn(e) {
                        let t = e;
                        return e >= Number.MAX_SAFE_INTEGER && (t = 0), t + 1
                    }

                    function sn(e) {
                        return e.length > 0 ? e.reduce(((e, t) => e + t)) / e.length : 0
                    }

                    function rn(e) {
                        return e.filter((e => e >= 0))
                    }
                    tn.prototype.start = function() {
                        tn.isLocalStatsSupported() && (en.resume(), this.analyser = en.createAnalyser(), this.analyser.smoothingTimeConstant = .8, this.analyser.fftSize = 2048, this.source = en.createMediaStreamSource(this.stream), this.source.connect(this.analyser), this.intervalId = setInterval((() => {
                            const e = new Uint8Array(this.analyser.frequencyBinCount);
                            this.analyser.getByteTimeDomainData(e);
                            const t = function(e) {
                                let t = 0;
                                const i = e.length;
                                for (let n = 0; n < i; n++) t < e[n] && (t = e[n]);
                                return parseFloat(((t - 127) / 128).toFixed(3))
                            }(e);
                            this.audioLevel = function(e, t) {
                                let i = 0;
                                const n = t - e;
                                return i = n > .2 ? t - .2 : n < -.4 ? t + .4 : e, parseFloat(i.toFixed(3))
                            }(t, this.audioLevel), this.callback(this.audioLevel)
                        }), this.intervalMilis))
                    }, tn.prototype.stop = function() {
                        var e, t;
                        this.intervalId && (clearInterval(this.intervalId), this.intervalId = null), null === (e = this.analyser) || void 0 === e || e.disconnect(), this.analyser = null, null === (t = this.source) || void 0 === t || t.disconnect(), this.source = null
                    }, tn.isLocalStatsSupported = function() {
                        return Boolean(window.AudioContext)
                    }, tn.disconnectAudioContext = async function() {
                        en && (Zi.info("Disconnecting audio context"), await en.close(), en = null)
                    }, tn.connectAudioContext = function() {
                        tn.isLocalStatsSupported() && (Zi.info("Connecting audio context"), en = new AudioContext, en.suspend())
                    }, tn.connectAudioContext();
                    class on {
                        constructor() {
                            this.average = 0, this.n = 0
                        }
                        addNext(e) {
                            "number" == typeof e && (this.n += 1, this.average = this.average + (e - this.average) / this.n)
                        }
                        getAverage() {
                            return this.average
                        }
                    }
                    const an = (0, v.getLogger)("modules/statistics/PerformanceObserverStats.js");
                    class cn {
                        constructor(e, t) {
                            this.eventEmitter = e, this.longTasks = 0, this.maxDuration = 0, this.performanceStatsInterval = t, this.stats = new on
                        }
                        getLongTasksStats() {
                            return {
                                avgRatePerMinute: (60 * this.stats.getAverage()).toFixed(2),
                                maxDurationMs: this.maxDuration
                            }
                        }
                        startObserver() {
                            this.longTaskEventHandler = e => {
                                const t = e.getEntries();
                                for (const e of t) this.longTasks++, this.maxDuration = Math.max(this.maxDuration, e.duration).toFixed(3)
                            }, an.info("Creating a Performance Observer for monitoring Long Tasks"), this.observer = new PerformanceObserver(this.longTaskEventHandler), this.observer.observe({
                                type: "longtask",
                                buffered: !0
                            });
                            const e = Date.now();
                            this.longTasksIntervalId = setInterval((() => {
                                const t = Date.now(),
                                    i = this._lastTimeStamp ? (t - this._lastTimeStamp) / 1e3 : (t - e) / 1e3,
                                    n = this.longTasks / i;
                                this.stats.addNext(n), this.eventEmitter.emit(yi, this.getLongTasksStats()), this.longTasks = 0, this._lastTimeStamp = Date.now()
                            }), this.performanceStatsInterval)
                        }
                        stopObserver() {
                            this.observer && this.observer.disconnect(), this.longTaskEventHandler = null, this.longTasksIntervalId && (clearInterval(this.longTasksIntervalId), this.longTasksIntervalId = null)
                        }
                    }
                    let dn;
                    ! function(e) {
                        e.AUDIO = "audio", e.PRESENTER = "presenter", e.VIDEO = "video"
                    }(dn || (dn = {}));
                    const ln = (0, v.getLogger)("FeatureFlags"),
                        hn = new class {
                            init(e) {
                                var t;
                                this._runInLiteMode = Boolean(e.runInLiteMode), this._sourceNameSignaling = Boolean(e.sourceNameSignaling), this._receiveMultipleVideoStreams = Boolean(e.receiveMultipleVideoStreams), this._sendMultipleVideoStreams = Boolean(e.sendMultipleVideoStreams), this._ssrcRewriting = Boolean(e.ssrcRewritingOnBridgeSupported), this._usesUnifiedPlan = Ui.supportsUnifiedPlan() && (!Ui.isChromiumBased() || null === (t = e.enableUnifiedOnChrome) || void 0 === t || t), ln.info(`Source name signaling: ${this._sourceNameSignaling}, Send multiple video streams: ${this._sendMultipleVideoStreams}, SSRC rewriting supported: ${this._ssrcRewriting}, uses Unified plan: ${this._usesUnifiedPlan}`)
                            }
                            isMultiStreamSupportEnabled() {
                                return this._sourceNameSignaling && this._sendMultipleVideoStreams && this._usesUnifiedPlan
                            }
                            isReceiveMultipleVideoStreamsSupported() {
                                return this._receiveMultipleVideoStreams
                            }
                            isRunInLiteModeEnabled() {
                                return this._runInLiteMode
                            }
                            isSourceNameSignalingEnabled() {
                                return this._sourceNameSignaling
                            }
                            isSsrcRewritingSupported() {
                                return this._ssrcRewriting
                            }
                        },
                        un = i(1023),
                        pn = (0, v.getLogger)("modules/statistics/RTPStatsCollector.js");

                    function mn(e, t) {
                        return !t || t <= 0 || !e || e <= 0 ? 0 : Math.round(e / t * 100)
                    }

                    function fn() {
                        this.loss = {}, this.bitrate = {
                            download: 0,
                            upload: 0
                        }, this.resolution = {}, this.framerate = 0, this.codec = ""
                    }

                    function gn() {
                        this.bandwidth = {}, this.bitrate = {}, this.packetLoss = null, this.transport = []
                    }

                    function _n(e, t, i, n) {
                        this.peerconnection = e, this.baselineAudioLevelsReport = null, this.currentAudioLevelsReport = null, this.currentStatsReport = null, this.previousStatsReport = null, this.audioLevelReportHistory = {}, this.audioLevelsIntervalId = null, this.eventEmitter = n, this.conferenceStats = new gn, this.audioLevelsIntervalMilis = t, this.speakerList = [], this.statsIntervalId = null, this.statsIntervalMilis = i, this.ssrc2stats = new Map
                    }
                    fn.prototype.setLoss = function(e) {
                        this.loss = e || {}
                    }, fn.prototype.setResolution = function(e) {
                        this.resolution = e || {}
                    }, fn.prototype.addBitrate = function(e) {
                        this.bitrate.download += e.download, this.bitrate.upload += e.upload
                    }, fn.prototype.resetBitrate = function() {
                        this.bitrate.download = 0, this.bitrate.upload = 0
                    }, fn.prototype.setFramerate = function(e) {
                        this.framerate = e || 0
                    }, fn.prototype.setCodec = function(e) {
                        this.codec = e || ""
                    }, _n.prototype.setSpeakerList = function(e) {
                        this.speakerList = e
                    }, _n.prototype.stop = function() {
                        this.audioLevelsIntervalId && (clearInterval(this.audioLevelsIntervalId), this.audioLevelsIntervalId = null), this.statsIntervalId && (clearInterval(this.statsIntervalId), this.statsIntervalId = null)
                    }, _n.prototype.errorCallback = function(e) {
                        un.callErrorHandler(e), pn.error("Get stats error", e), this.stop()
                    }, _n.prototype.start = function(e) {
                        e && (Ui.supportsReceiverStats() && pn.info("Using RTCRtpSynchronizationSource for remote audio levels"), this.audioLevelsIntervalId = setInterval((() => {
                            if (Ui.supportsReceiverStats()) {
                                const e = this.peerconnection.getAudioLevels(this.speakerList);
                                for (const t in e)
                                    if (e.hasOwnProperty(t)) {
                                        const i = 2.5 * e[t];
                                        this.eventEmitter.emit(_i, this.peerconnection, Number.parseInt(t, 10), i, !1)
                                    }
                            } else this.peerconnection.getStats().then((e => {
                                this.currentAudioLevelsReport = "function" == typeof(null == e ? void 0 : e.result) ? e.result() : e, this.processAudioLevelReport(), this.baselineAudioLevelsReport = this.currentAudioLevelsReport
                            })).catch((e => this.errorCallback(e)))
                        }), this.audioLevelsIntervalMilis));
                        const t = () => {
                            this.peerconnection.getStats().then((e => {
                                this.currentStatsReport = "function" == typeof(null == e ? void 0 : e.result) ? e.result() : e;
                                try {
                                    this.processStatsReport()
                                } catch (e) {
                                    un.callErrorHandler(e), pn.error("Processing of RTP stats failed:", e)
                                }
                                this.previousStatsReport = this.currentStatsReport
                            })).catch((e => this.errorCallback(e)))
                        };
                        t(), this.statsIntervalId = setInterval(t, this.statsIntervalMilis)
                    }, _n.prototype._processAndEmitReport = function() {
                        const e = {
                                download: 0,
                                upload: 0
                            },
                            t = {
                                download: 0,
                                upload: 0
                            };
                        let i = 0,
                            n = 0;
                        const s = {},
                            r = {},
                            o = {};
                        let a, c, d = 0,
                            l = 0,
                            h = 0,
                            u = 0;
                        for (const [p, m] of this.ssrc2stats) {
                            const f = m.loss,
                                g = f.isDownloadStream ? "download" : "upload";
                            e[g] += f.packetsTotal, t[g] += f.packetsLost, i += m.bitrate.download, n += m.bitrate.upload;
                            const _ = this.peerconnection.getTrackBySSRC(p);
                            if (_)
                                if (_.isAudioTrack() ? (d += m.bitrate.download, l += m.bitrate.upload, a = m.codec) : (h += m.bitrate.download, u += m.bitrate.upload, c = m.codec), hn.isSourceNameSignalingEnabled()) {
                                    const e = _.getSourceName();
                                    if (e) {
                                        const t = m.resolution;
                                        if (t.width && t.height && -1 !== t.width && -1 !== t.height && (s[e] = t), 0 !== m.framerate && (r[e] = m.framerate), a && c) {
                                            const t = {
                                                audio: a,
                                                video: c
                                            };
                                            o[e] = t
                                        }
                                    } else pn.error(`No source name returned by ${_}`)
                                } else {
                                    const e = _.getParticipantId();
                                    if (e) {
                                        const t = m.resolution;
                                        if (t.width && t.height && -1 !== t.width && -1 !== t.height) {
                                            const i = s[e] || {};
                                            i[p] = t, s[e] = i
                                        }
                                        if (0 !== m.framerate) {
                                            const t = r[e] || {};
                                            t[p] = m.framerate, r[e] = t
                                        }
                                        if (a && c) {
                                            const t = {
                                                    audio: a,
                                                    video: c
                                                },
                                                i = o[e] || {};
                                            i[p] = t, o[e] = i
                                        }
                                    } else pn.error(`No participant ID returned by ${_}`)
                                } m.resetBitrate()
                        }
                        this.conferenceStats.bitrate = {
                            upload: n,
                            download: i
                        }, this.conferenceStats.bitrate.audio = {
                            upload: l,
                            download: d
                        }, this.conferenceStats.bitrate.video = {
                            upload: u,
                            download: h
                        }, this.conferenceStats.packetLoss = {
                            total: mn(t.download + t.upload, e.download + e.upload),
                            download: mn(t.download, e.download),
                            upload: mn(t.upload, e.upload)
                        };
                        const p = {};
                        let m;
                        Object.keys(this.audioLevelReportHistory).forEach((e => {
                            const {
                                data: t,
                                isLocal: i
                            } = this.audioLevelReportHistory[e], n = t.reduce(((e, t) => e + t)) / t.length;
                            if (i) m = n;
                            else {
                                const t = this.peerconnection.getTrackBySSRC(Number(e));
                                if (t) {
                                    const e = t.getParticipantId();
                                    e && (p[e] = n)
                                }
                            }
                        })), this.audioLevelReportHistory = {}, this.eventEmitter.emit(Ei, this.peerconnection, {
                            bandwidth: this.conferenceStats.bandwidth,
                            bitrate: this.conferenceStats.bitrate,
                            packetLoss: this.conferenceStats.packetLoss,
                            resolution: s,
                            framerate: r,
                            codec: o,
                            transport: this.conferenceStats.transport,
                            localAvgAudioLevels: m,
                            avgAudioLevels: p
                        }), this.conferenceStats.transport = []
                    }, _n.prototype.getNonNegativeValue = function(e) {
                        let t = e;
                        return "number" != typeof t && (t = Number(t)), isNaN(t) ? 0 : Math.max(0, t)
                    }, _n.prototype._calculateBitrate = function(e, t, i) {
                        const n = this.getNonNegativeValue(e[i]),
                            s = this.getNonNegativeValue(t[i]),
                            r = Math.max(0, n - s),
                            o = e.timestamp - t.timestamp;
                        let a = 0;
                        return o > 0 && (a = Math.round(8 * r / o)), a
                    }, _n.prototype.processStatsReport = function() {
                        if (!this.previousStatsReport) return;
                        const e = {};
                        this.currentStatsReport.forEach((t => {
                            if ("candidate-pair" === t.type && t.nominated && "succeeded" === t.state) {
                                const e = t.availableIncomingBitrate,
                                    i = t.availableOutgoingBitrate;
                                (e || i) && (this.conferenceStats.bandwidth = {
                                    download: Math.round(e / 1e3),
                                    upload: Math.round(i / 1e3)
                                });
                                const n = this.currentStatsReport.get(t.remoteCandidateId),
                                    s = this.currentStatsReport.get(t.localCandidateId);
                                if (n && s) {
                                    const e = `${Ui.isChromiumBased()?n.ip:n.address}:${n.port}`,
                                        i = `${Ui.isChromiumBased()?s.ip:s.address}:${s.port}`,
                                        r = n.protocol,
                                        o = this.conferenceStats.transport;
                                    o.some((t => t.ip === e && t.type === r && t.localip === i)) || o.push({
                                        ip: e,
                                        type: r,
                                        localip: i,
                                        p2p: this.peerconnection.isP2P,
                                        localCandidateType: s.candidateType,
                                        remoteCandidateType: n.candidateType,
                                        networkType: s.networkType,
                                        rtt: 1e3 * t.currentRoundTripTime
                                    })
                                }
                            } else if ("inbound-rtp" === t.type || "outbound-rtp" === t.type) {
                                const i = this.previousStatsReport.get(t.id),
                                    n = this.getNonNegativeValue(t.ssrc);
                                if (!i || !n) return;
                                let s = this.ssrc2stats.get(n);
                                s || (s = new fn, this.ssrc2stats.set(n, s));
                                let r = !0,
                                    o = "packetsReceived";
                                "outbound-rtp" === t.type && (r = !1, o = "packetsSent");
                                let a = t[o];
                                (!a || a < 0) && (a = 0);
                                const c = this.getNonNegativeValue(i[o]),
                                    d = Math.max(0, a - c),
                                    l = this.getNonNegativeValue(t.packetsLost),
                                    h = this.getNonNegativeValue(i.packetsLost),
                                    u = Math.max(0, l - h);
                                if (s.setLoss({
                                        packetsTotal: d + u,
                                        packetsLost: u,
                                        isDownloadStream: r
                                    }), "inbound-rtp" === t.type) {
                                    const e = {
                                            height: t.frameHeight,
                                            width: t.frameWidth
                                        },
                                        n = t.framesPerSecond;
                                    e.height && e.width && s.setResolution(e), s.setFramerate(Math.round(n || 0)), s.addBitrate({
                                        download: this._calculateBitrate(t, i, "bytesReceived"),
                                        upload: 0
                                    })
                                } else e[n] = this.getNonNegativeValue(t.bytesSent), s.addBitrate({
                                    download: 0,
                                    upload: this._calculateBitrate(t, i, "bytesSent")
                                });
                                const p = this.currentStatsReport.get(t.codecId);
                                if (p) {
                                    const e = p.mimeType.split("/")[1];
                                    e && s.setCodec(e)
                                }
                            } else if ("track" === t.type && t.kind === dn.VIDEO && !t.remoteSource) {
                                const e = {
                                        height: t.frameHeight,
                                        width: t.frameWidth
                                    },
                                    i = this.peerconnection.getLocalTracks(dn.VIDEO);
                                if (null == i || !i.length) return;
                                const n = this.peerconnection.getSsrcByTrackId(t.trackIdentifier);
                                if (!n) return;
                                let s = this.ssrc2stats.get(n);
                                s || (s = new fn, this.ssrc2stats.set(n, s)), e.height && e.width && s.setResolution(e);
                                let r = t.framesPerSecond;
                                if (!r) {
                                    const e = this.previousStatsReport.get(t.id);
                                    if (e) {
                                        const i = t.timestamp - e.timestamp;
                                        i > 0 && t.framesSent && (r = (t.framesSent - e.framesSent) / i * 1e3)
                                    }
                                    if (!r) return
                                }
                                const o = this.peerconnection.getActiveSimulcastStreams();
                                r = o ? Math.round(r / o) : 0, s.setFramerate(r)
                            }
                        })), this.eventEmitter.emit(vi, this.peerconnection, e), this._processAndEmitReport()
                    }, _n.prototype.processAudioLevelReport = function() {
                        this.baselineAudioLevelsReport && this.currentAudioLevelsReport.forEach((e => {
                            if ("track" !== e.type) return;
                            const t = e.audioLevel;
                            if (!t) return;
                            const i = e.trackIdentifier,
                                n = this.peerconnection.getSsrcByTrackId(i);
                            if (n) {
                                const e = n === this.peerconnection.getLocalSSRC(this.peerconnection.getLocalTracks(dn.AUDIO));
                                this.eventEmitter.emit(_i, this.peerconnection, n, t, e)
                            }
                        }))
                    };
                    const Sn = i(5810).getLogger("modules/statistics/statistics.js");
                    let vn, En = !1;

                    function yn(e) {
                        Yi.isBackendInitialized() || Yi.initBackend({
                            callStatsID: e.callStatsID,
                            callStatsSecret: e.callStatsSecret,
                            userName: e.userName,
                            aliasName: e.aliasName,
                            applicationName: e.applicationName,
                            getWiFiStatsMethod: e.getWiFiStatsMethod,
                            confID: e.confID,
                            siteID: e.siteID,
                            configParams: e.configParams
                        }) || Sn.error("CallStats Backend initialization failed bad")
                    }

                    function Tn(e, t) {
                        this.rtpStatsMap = new Map, this.eventEmitter = new(dt()), this.xmpp = e, this.options = t || {}, this.callStatsIntegrationEnabled = this.options.callStatsID && this.options.callStatsSecret && this.options.enableCallStats && !0 !== Tn.disableThirdPartyRequests, this.callStatsIntegrationEnabled && (this.callStatsApplicationLogsDisabled = this.options.callStatsApplicationLogsDisabled, Ui.isReactNative() ? yn(this.options) : function(e) {
                            En || ($i().loadScript(e.customScriptUrl || pt, !0, !0, void 0, (() => yn(e))), En = !0)
                        }(this.options), this.options.confID || Sn.warn('"confID" is not defined')), this.callsStatsInstances = new Map, Tn.instances.add(this)
                    }
                    Tn.init = function(e) {
                        Tn.audioLevelsEnabled = !e.disableAudioLevels, "number" == typeof e.pcStatsInterval && (Tn.pcStatsInterval = e.pcStatsInterval), "number" == typeof e.audioLevelsInterval && (Tn.audioLevelsInterval = e.audioLevelsInterval), "number" == typeof e.longTasksStatsInterval && (Tn.longTasksStatsInterval = e.longTasksStatsInterval), Tn.disableThirdPartyRequests = e.disableThirdPartyRequests
                    }, Tn.audioLevelsEnabled = !1, Tn.audioLevelsInterval = 200, Tn.pcStatsInterval = 1e4, Tn.disableThirdPartyRequests = !1, Tn.analytics = Bi, Object.defineProperty(Tn, "instances", {
                        get: () => (vn || (vn = new Set), vn)
                    }), Tn.prototype.startRemoteStats = function(e) {
                        this.stopRemoteStats(e);
                        try {
                            const t = new _n(e, Tn.audioLevelsInterval, Tn.pcStatsInterval, this.eventEmitter);
                            t.start(Tn.audioLevelsEnabled), this.rtpStatsMap.set(e.id, t)
                        } catch (e) {
                            Sn.error(`Failed to start collecting remote statistics: ${e}`)
                        }
                    }, Tn.localStats = [], Tn.startLocalStats = function(e, t) {
                        if (Ui.isIosBrowser() && e.addEventListener(Dt.NO_DATA_FROM_SOURCE, (async e => {
                                if (e) {
                                    for (const e of Tn.localStats) e.stop();
                                    await tn.disconnectAudioContext()
                                } else {
                                    tn.connectAudioContext();
                                    for (const e of Tn.localStats) e.start()
                                }
                            })), !Tn.audioLevelsEnabled) return;
                        e.addEventListener(Dt.LOCAL_TRACK_STOPPED, (() => {
                            Tn.stopLocalStats(e)
                        }));
                        const i = new tn(e.getOriginalStream(), Tn.audioLevelsInterval, t);
                        this.localStats.push(i), i.start()
                    }, Tn.prototype.addAudioLevelListener = function(e) {
                        Tn.audioLevelsEnabled && this.eventEmitter.on(_i, e)
                    }, Tn.prototype.removeAudioLevelListener = function(e) {
                        Tn.audioLevelsEnabled && this.eventEmitter.removeListener(_i, e)
                    }, Tn.prototype.addBeforeDisposedListener = function(e) {
                        this.eventEmitter.on(Si, e)
                    }, Tn.prototype.removeBeforeDisposedListener = function(e) {
                        this.eventEmitter.removeListener(Si, e)
                    }, Tn.prototype.addConnectionStatsListener = function(e) {
                        this.eventEmitter.on(Ei, e)
                    }, Tn.prototype.removeConnectionStatsListener = function(e) {
                        this.eventEmitter.removeListener(Ei, e)
                    }, Tn.prototype.addByteSentStatsListener = function(e) {
                        this.eventEmitter.on(vi, e)
                    }, Tn.prototype.removeByteSentStatsListener = function(e) {
                        this.eventEmitter.removeListener(vi, e)
                    }, Tn.prototype.addLongTasksStatsListener = function(e) {
                        this.eventEmitter.on(yi, e)
                    }, Tn.prototype.attachLongTasksStats = function(e) {
                        Ui.supportsPerformanceObserver() ? (this.performanceObserverStats = new cn(this.eventEmitter, Tn.longTasksStatsInterval), e.on(Q, (() => this.performanceObserverStats.startObserver())), e.on(Y, (() => this.performanceObserverStats.stopObserver()))) : Sn.warn("Performance observer for long tasks not supported by browser!")
                    }, Tn.prototype.getLongTasksStats = function() {
                        return this.performanceObserverStats ? this.performanceObserverStats.getLongTasksStats() : null
                    }, Tn.prototype.removeLongTasksStatsListener = function(e) {
                        this.eventEmitter.removeListener(yi, e)
                    }, Tn.prototype.setSpeakerList = function(e) {
                        for (const t of Array.from(this.rtpStatsMap.values())) t.peerconnection.isP2P || t.setSpeakerList(e)
                    }, Tn.prototype.dispose = function() {
                        try {
                            this.callsStatsInstances.size || this.eventEmitter.emit(Si);
                            for (const e of this.callsStatsInstances.values()) this.stopCallStats(e.tpc);
                            for (const e of this.rtpStatsMap.keys()) this._stopRemoteStats(e);
                            this.eventEmitter && this.eventEmitter.removeAllListeners()
                        } finally {
                            Tn.instances.delete(this)
                        }
                    }, Tn.stopLocalStats = function(e) {
                        if (!Tn.audioLevelsEnabled) return;
                        const t = e.getOriginalStream();
                        for (let e = 0; e < Tn.localStats.length; e++)
                            if (Tn.localStats[e].stream === t) {
                                Tn.localStats.splice(e, 1)[0].stop();
                                break
                            }
                    }, Tn.prototype._stopRemoteStats = function(e) {
                        const t = this.rtpStatsMap.get(e);
                        t && (t.stop(), this.rtpStatsMap.delete(e))
                    }, Tn.prototype.stopRemoteStats = function(e) {
                        this._stopRemoteStats(e.id)
                    }, Tn.prototype.startCallStats = function(e, t) {
                        if (!this.callStatsIntegrationEnabled) return;
                        if (this.callsStatsInstances.has(e.id)) return void Sn.error("CallStats instance for ${tpc} exists already");
                        let i = this.options.confID;
                        i.endsWith(this.options.roomName) || (i = `${this.options.confID.slice(0,this.options.confID.lastIndexOf("/"))}/${this.options.roomName}`), Sn.info(`Starting CallStats for ${e}...`);
                        const n = new Yi(e, {
                            confID: i,
                            remoteUserID: t
                        });
                        this.callsStatsInstances.set(e.id, n)
                    }, Tn._getAllCallStatsInstances = function() {
                        const e = new Set;
                        for (const t of Tn.instances)
                            for (const i of t.callsStatsInstances.values()) e.add(i);
                        return e
                    }, Tn.prototype.stopCallStats = function(e) {
                        const t = this.callsStatsInstances.get(e.id);
                        t && (1 === this.callsStatsInstances.size && this.eventEmitter.emit(Si), this.callsStatsInstances.delete(e.id), t.sendTerminateEvent())
                    }, Tn.prototype.isCallstatsEnabled = function() {
                        return this.callStatsIntegrationEnabled
                    }, Tn.prototype.sendConnectionResumeOrHoldEvent = function(e, t) {
                        const i = this.callsStatsInstances.get(e.id);
                        i && i.sendResumeOrHoldEvent(t)
                    }, Tn.prototype.sendIceConnectionFailedEvent = function(e) {
                        const t = this.callsStatsInstances.get(e.id);
                        t && t.sendIceConnectionFailedEvent()
                    }, Tn.prototype.sendMuteEvent = function(e, t, i) {
                        const n = e && this.callsStatsInstances.get(e.id);
                        Yi.sendMuteEvent(t, i, n)
                    }, Tn.prototype.sendScreenSharingEvent = function(e, t) {
                        for (const i of this.callsStatsInstances.values()) i.sendScreenSharingEvent(e, t)
                    }, Tn.prototype.sendDominantSpeakerEvent = function(e) {
                        for (const e of this.callsStatsInstances.values()) e.sendDominantSpeakerEvent();
                        this.xmpp.sendDominantSpeakerEvent(e)
                    }, Tn.sendActiveDeviceListEvent = function(e) {
                        const t = Tn._getAllCallStatsInstances();
                        if (t.size)
                            for (const i of t) Yi.sendActiveDeviceListEvent(e, i);
                        else Yi.sendActiveDeviceListEvent(e, null)
                    }, Tn.prototype.associateStreamWithVideoTag = function(e, t, i, n, s, r) {
                        const o = this.callsStatsInstances.get(e.id);
                        o && o.associateStreamWithVideoTag(t, i, n, s, r)
                    }, Tn.sendGetUserMediaFailed = function(e) {
                        const t = e instanceof Nt ? function(e) {
                                const t = new Error;
                                return t.stack = e.stack, t.name = (e.name || "Unknown error") + (e.gum && e.gum.error && e.gum.error.name ? ` - ${e.gum.error.name}` : ""), t.constraintName = e.gum && e.gum.constraints ? JSON.stringify(e.gum.constraints) : "", t.message = e.message, t
                            }(e) : e,
                            i = Tn._getAllCallStatsInstances();
                        if (i.size)
                            for (const e of i) Yi.sendGetUserMediaFailed(t, e);
                        else Yi.sendGetUserMediaFailed(t, null)
                    }, Tn.prototype.sendCreateOfferFailed = function(e, t) {
                        const i = this.callsStatsInstances.get(t.id);
                        i && i.sendCreateOfferFailed(e)
                    }, Tn.prototype.sendCreateAnswerFailed = function(e, t) {
                        const i = this.callsStatsInstances.get(t.id);
                        i && i.sendCreateAnswerFailed(e)
                    }, Tn.prototype.sendSetLocalDescFailed = function(e, t) {
                        const i = this.callsStatsInstances.get(t.id);
                        i && i.sendSetLocalDescFailed(e)
                    }, Tn.prototype.sendSetRemoteDescFailed = function(e, t) {
                        const i = this.callsStatsInstances.get(t.id);
                        i && i.sendSetRemoteDescFailed(e)
                    }, Tn.prototype.sendAddIceCandidateFailed = function(e, t) {
                        const i = this.callsStatsInstances.get(t.id);
                        i && i.sendAddIceCandidateFailed(e)
                    }, Tn.sendLog = function(e) {
                        const t = new Set;
                        for (const e of Tn.instances) {
                            if (e.callStatsApplicationLogsDisabled) return;
                            e.callsStatsInstances.size && t.add(e.callsStatsInstances.values().next().value)
                        }
                        if (t.size)
                            for (const i of t) Yi.sendApplicationLog(e, i);
                        else Yi.sendApplicationLog(e, null)
                    }, Tn.prototype.sendFeedback = function(e, t) {
                        return Tn.analytics.sendEvent(ni, {
                            rating: e,
                            comment: t
                        }), Yi.sendFeedback(this.options.confID, e, t)
                    }, Tn.LOCAL_JID = i(7680).D, Tn.reportGlobalError = function(e) {
                        e instanceof Nt && e.gum ? Tn.sendGetUserMediaFailed(e) : Tn.sendLog(e)
                    }, Tn.sendAnalyticsAndLog = function(e) {
                        let t, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        e ? (t = "object" == typeof e ? e : {
                            name: e,
                            properties: i
                        }, Sn.log(JSON.stringify(t)), this.analytics.sendEvent(e, i)) : Sn.warn("No event or event name given.")
                    }, Tn.sendAnalytics = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        this.analytics.sendEvent(e, t)
                    };
                    var Cn = i(4832),
                        bn = i.n(Cn),
                        Rn = i(9987),
                        An = i(3408),
                        Pn = i(3514),
                        In = i.n(Pn),
                        Nn = i(609);
                    const Dn = (0, v.getLogger)("JitsiConferenceEventManager.js");

                    function Mn(e) {
                        this.conference = e, this.xmppListeners = {}, e.on($e, (t => {
                            if (!t.isLocal() || !e.statistics) return;
                            const i = t.isP2P ? e.p2pJingleSession : e.jvbJingleSession,
                                n = i && i.peerconnection || null;
                            e.statistics.sendMuteEvent(n, t.isMuted(), t.getType())
                        }))
                    }
                    Mn.prototype.setupChatRoomListeners = function() {
                        const e = this.conference,
                            t = e.room;
                        this.chatRoomForwarder = new(bn())(t, this.conference.eventEmitter), t.addListener(Nn.XMPPEvents.ICE_RESTARTING, (t => {
                            t.isP2P || e.rtc.closeBridgeChannel()
                        })), t.addListener(Nn.XMPPEvents.PARTICIPANT_FEATURES_CHANGED, ((t, i) => {
                            const n = e.getParticipantById(ut.Strophe.getResourceFromJid(t));
                            n && (n.setFeatures(i), e.eventEmitter.emit(Ae, n))
                        })), t.addListener(Nn.XMPPEvents.ICE_RESTART_SUCCESS, ((t, i) => {
                            !t.isP2P && e._setBridgeChannel(i, t.peerconnection)
                        })), t.addListener(Nn.XMPPEvents.AUDIO_MUTED_BY_FOCUS, (t => {
                            Tn.sendAnalytics(mi(dn.AUDIO)), e.mutedByFocusActor = t, e.rtc.setAudioMute(!0).then((() => {
                                e.isMutedByFocus = !0, e.mutedByFocusActor = null
                            })).catch((t => {
                                e.mutedByFocusActor = null, Dn.warn("Error while audio muting due to focus request", t)
                            }))
                        })), t.addListener(Nn.XMPPEvents.VIDEO_MUTED_BY_FOCUS, (t => {
                            Tn.sendAnalytics(mi(dn.VIDEO)), e.mutedVideoByFocusActor = t, e.rtc.setVideoMute(!0).then((() => {
                                e.isVideoMutedByFocus = !0, e.mutedVideoByFocusActor = null
                            })).catch((t => {
                                e.mutedVideoByFocusActor = null, Dn.warn("Error while video muting due to focus request", t)
                            }))
                        })), this.chatRoomForwarder.forward(Nn.XMPPEvents.SUBJECT_CHANGED, xe), this.chatRoomForwarder.forward(Nn.XMPPEvents.MUC_JOINED, Q), this.chatRoomForwarder.forward(Nn.XMPPEvents.MUC_JOIN_IN_PROGRESS, z), this.chatRoomForwarder.forward(Nn.XMPPEvents.MEETING_ID_SET, Z), t.addListener(Nn.XMPPEvents.MUC_JOINED, (() => {
                            this.conference._onMucJoined(), this.conference.isJvbConnectionInterrupted = !1, Object.keys(t.connectionTimes).forEach((e => {
                                const i = li(`conference_${e}`, {
                                    value: t.connectionTimes[e]
                                });
                                Tn.sendAnalytics(i)
                            })), Object.keys(t.xmpp.connectionTimes).forEach((e => {
                                const i = li(`xmpp_${e}`, {
                                    value: t.xmpp.connectionTimes[e]
                                });
                                Tn.sendAnalytics(i)
                            }))
                        })), t.addListener(Nn.XMPPEvents.RENEGOTIATION_FAILED, ((t, i) => {
                            i.isP2P || e.eventEmitter.emit(X, F, t)
                        })), this.chatRoomForwarder.forward(Nn.XMPPEvents.ROOM_JOIN_ERROR, X, P), this.chatRoomForwarder.forward(Nn.XMPPEvents.ROOM_CONNECT_ERROR, X, P), this.chatRoomForwarder.forward(Nn.XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR, X, N), this.chatRoomForwarder.forward(Nn.XMPPEvents.ROOM_CONNECT_MEMBERS_ONLY_ERROR, X, D), this.chatRoomForwarder.forward(Nn.XMPPEvents.ROOM_MAX_USERS_ERROR, X, A), t.addListener(Nn.XMPPEvents.ROOM_MAX_USERS_ERROR, (() => e.leave())), this.chatRoomForwarder.forward(Nn.XMPPEvents.PASSWORD_REQUIRED, X, U), this.chatRoomForwarder.forward(Nn.XMPPEvents.AUTHENTICATION_REQUIRED, X, T), this.chatRoomForwarder.forward(Nn.XMPPEvents.BRIDGE_DOWN, X, H), t.addListener(Nn.XMPPEvents.BRIDGE_DOWN, (() => Tn.sendAnalytics({
                            action: "bridge.down",
                            actionSubject: "bridge.down",
                            type: jt
                        }))), t.addListener(Nn.XMPPEvents.CONNECTION_RESTARTED, (t => {
                            e._onConferenceRestarted(t)
                        })), this.chatRoomForwarder.forward(Nn.XMPPEvents.RESERVATION_ERROR, X, j), t.addListener(Nn.XMPPEvents.RESERVATION_ERROR, (() => e.leave())), this.chatRoomForwarder.forward(Nn.XMPPEvents.GRACEFUL_SHUTDOWN, X, L), t.addListener(Nn.XMPPEvents.CONNECTION_ICE_FAILED, (t => {
                            e._onIceConnectionFailed(t)
                        })), this.chatRoomForwarder.forward(Nn.XMPPEvents.MUC_DESTROYED, X, R), t.addListener(Nn.XMPPEvents.MUC_DESTROYED, (() => e.leave())), this.chatRoomForwarder.forward(Nn.XMPPEvents.CHAT_ERROR_RECEIVED, W, C), this.chatRoomForwarder.forward(Nn.XMPPEvents.SETTINGS_ERROR_RECEIVED, W, b), this.chatRoomForwarder.forward(Nn.XMPPEvents.FOCUS_DISCONNECTED, X, O), t.addListener(Nn.XMPPEvents.FOCUS_LEFT, (() => {
                            Tn.sendAnalytics({
                                action: "focus.left",
                                actionSubject: "focus.left",
                                type: Ut.TYPE_OPERATIONAL
                            }), e.eventEmitter.emit(X, w)
                        })), t.addListener(Nn.XMPPEvents.SESSION_ACCEPT_TIMEOUT, (e => {
                            Tn.sendAnalyticsAndLog(ui(Gt, {
                                p2p: e.isP2P
                            }))
                        })), t.addListener(Nn.XMPPEvents.RECORDER_STATE_CHANGED, ((t, i) => {
                            if (i) {
                                const n = ut.Strophe.getResourceFromJid(i),
                                    s = e.getParticipantById(n) || n;
                                "off" === t.getStatus() ? t.setTerminator(s) : "on" === t.getStatus() && t.setInitiator(s)
                            }
                            e.eventEmitter.emit(Me, t)
                        })), this.chatRoomForwarder.forward(Nn.XMPPEvents.TRANSCRIPTION_STATUS_CHANGED, Je), this.chatRoomForwarder.forward(Nn.XMPPEvents.VIDEO_SIP_GW_AVAILABILITY_CHANGED, Oe), this.chatRoomForwarder.forward(Nn.XMPPEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED, we), this.chatRoomForwarder.forward(Nn.XMPPEvents.PHONE_NUMBER_CHANGED, Ne), t.setParticipantPropertyListener(((t, i) => {
                            const n = e.getParticipantById(i);
                            n && n.setProperty(t.tagName.substring("jitsi_participant_".length), t.value)
                        })), t.addListener(Nn.XMPPEvents.KICKED, e.onMemberKicked.bind(e)), t.addListener(Nn.XMPPEvents.SUSPEND_DETECTED, e.onSuspendDetected.bind(e)), this.chatRoomForwarder.forward(Nn.XMPPEvents.MUC_LOCK_CHANGED, fe), this.chatRoomForwarder.forward(Nn.XMPPEvents.MUC_MEMBERS_ONLY_CHANGED, ve), t.addListener(Nn.XMPPEvents.MUC_MEMBER_JOINED, e.onMemberJoined.bind(e)), this.chatRoomForwarder.forward(Nn.XMPPEvents.MUC_LOBBY_MEMBER_JOINED, Qe), this.chatRoomForwarder.forward(Nn.XMPPEvents.MUC_LOBBY_MEMBER_UPDATED, Ye), this.chatRoomForwarder.forward(Nn.XMPPEvents.MUC_LOBBY_MEMBER_LEFT, Ze), t.addListener(Nn.XMPPEvents.MUC_MEMBER_BOT_TYPE_CHANGED, e._onMemberBotTypeChanged.bind(e)), t.addListener(Nn.XMPPEvents.MUC_MEMBER_LEFT, e.onMemberLeft.bind(e)), this.chatRoomForwarder.forward(Nn.XMPPEvents.MUC_LEFT, Y), this.chatRoomForwarder.forward(Nn.XMPPEvents.MUC_DENIED_ACCESS, X, M), t.addListener(Nn.XMPPEvents.DISPLAY_NAME_CHANGED, e.onDisplayNameChanged.bind(e)), t.addListener(Nn.XMPPEvents.LOCAL_ROLE_CHANGED, (t => {
                            e.onLocalRoleChanged(t), e.statistics && e.isModerator() && e.on(Me, (e => {
                                const t = {
                                    error: e.getError(),
                                    id: "recorder_status",
                                    status: e.getStatus()
                                };
                                Tn.sendLog(JSON.stringify(t))
                            }))
                        })), t.addListener(Nn.XMPPEvents.MUC_ROLE_CHANGED, e.onUserRoleChanged.bind(e)), t.addListener(In().IDENTITY_UPDATED, ((t, i) => {
                            e.authEnabled = t, e.authIdentity = i, e.eventEmitter.emit(K, t, i)
                        })), t.addListener(Nn.XMPPEvents.MESSAGE_RECEIVED, ((t, i, n, s) => {
                            const r = ut.Strophe.getResourceFromJid(t);
                            e.eventEmitter.emit(Ee, r, i, s)
                        })), t.addListener(Nn.XMPPEvents.PRIVATE_MESSAGE_RECEIVED, ((t, i, n, s) => {
                            const r = ut.Strophe.getResourceFromJid(t);
                            e.eventEmitter.emit(be, r, i, s)
                        })), t.addListener(Nn.XMPPEvents.PRESENCE_STATUS, ((t, i) => {
                            const n = ut.Strophe.getResourceFromJid(t),
                                s = e.getParticipantById(n);
                            s && s._status !== i && (s._status = i, e.eventEmitter.emit(We, n, i))
                        })), t.addListener(Nn.XMPPEvents.JSON_MESSAGE_RECEIVED, ((t, i) => {
                            const n = ut.Strophe.getResourceFromJid(t),
                                s = e.getParticipantById(n);
                            s ? e.eventEmitter.emit(ce, s, i) : e.eventEmitter.emit(Ce, n, i)
                        })), t.addPresenceListener("startmuted", ((t, i) => {
                            let n = !1;
                            if (e.myUserId() === i && e.isModerator()) n = !0;
                            else {
                                const t = e.getParticipantById(i);
                                t && t.isModerator() && (n = !0)
                            }
                            if (!n) return;
                            const s = "true" === t.attributes.audio,
                                r = "true" === t.attributes.video;
                            let o = !1;
                            s !== e.startMutedPolicy.audio && (e.startMutedPolicy.audio = s, o = !0), r !== e.startMutedPolicy.video && (e.startMutedPolicy.video = r, o = !0), o && e.eventEmitter.emit(Le, e.startMutedPolicy)
                        })), e.statistics && (t.addListener(Nn.XMPPEvents.CONNECTION_ICE_FAILED, (t => {
                            e.statistics.sendIceConnectionFailedEvent(t.peerconnection)
                        })), t.addListener(Nn.XMPPEvents.ADD_ICE_CANDIDATE_FAILED, ((t, i) => {
                            e.statistics.sendAddIceCandidateFailed(t, i)
                        }))), this.chatRoomForwarder.forward(Nn.XMPPEvents.BREAKOUT_ROOMS_MOVE_TO_ROOM, ot), this.chatRoomForwarder.forward(Nn.XMPPEvents.BREAKOUT_ROOMS_UPDATED, at)
                    }, Mn.prototype.setupRTCListeners = function() {
                        const e = this.conference,
                            t = e.rtc;
                        t.addListener(Rn.default.REMOTE_TRACK_ADDED, e.onRemoteTrackAdded.bind(e)), t.addListener(Rn.default.REMOTE_TRACK_REMOVED, e.onRemoteTrackRemoved.bind(e)), t.addListener(Rn.default.DOMINANT_SPEAKER_CHANGED, ((t, i) => {
                            if (e.lastDominantSpeaker !== t && e.room) {
                                if (e.lastDominantSpeaker = t, e.eventEmitter.emit(re, t, i), i && i.length) {
                                    const n = i.slice(0);
                                    e.myUserId !== t && n.splice(0, 0, t), n.length > 5 && n.splice(5, n.length - 5), e.statistics && e.statistics.setSpeakerList(n)
                                }
                                e.statistics && e.myUserId() === t && e.statistics.sendDominantSpeakerEvent(e.room.roomjid)
                            }
                        })), t.addListener(Rn.default.DATA_CHANNEL_OPEN, (() => {
                            const t = window.performance.now(),
                                i = "data.channel.opened";
                            Dn.log(`(TIME) ${i}:\t`, t), e.room.connectionTimes[i] = t, Tn.sendAnalytics(li(i, {
                                value: t
                            })), e.eventEmitter.emit(ne)
                        })), t.addListener(Rn.default.ENDPOINT_MESSAGE_RECEIVED, ((t, i) => {
                            const n = e.getParticipantById(t);
                            n ? e.eventEmitter.emit(ce, n, i) : Dn.warn(`Ignored ENDPOINT_MESSAGE_RECEIVED for not existing participant: ${t}`, i)
                        })), t.addListener(Rn.default.ENDPOINT_STATS_RECEIVED, ((t, i) => {
                            const n = e.getParticipantById(t);
                            n ? e.eventEmitter.emit(de, n, i) : Dn.warn(`Ignoring ENDPOINT_STATS_RECEIVED for a non-existant participant: ${t}`)
                        })), t.addListener(Rn.default.LOCAL_UFRAG_CHANGED, ((e, t) => {
                            e.isP2P || Tn.sendLog(JSON.stringify({
                                id: "local_ufrag",
                                value: t
                            }))
                        })), t.addListener(Rn.default.REMOTE_UFRAG_CHANGED, ((e, t) => {
                            e.isP2P || Tn.sendLog(JSON.stringify({
                                id: "remote_ufrag",
                                value: t
                            }))
                        })), t.addListener(Rn.default.CREATE_ANSWER_FAILED, ((t, i) => {
                            e.statistics.sendCreateAnswerFailed(t, i), i.isP2P || e.eventEmitter.emit(X, F, t)
                        })), t.addListener(Rn.default.CREATE_OFFER_FAILED, ((t, i) => {
                            e.statistics.sendCreateOfferFailed(t, i), i.isP2P || e.eventEmitter.emit(X, F, t)
                        })), t.addListener(Rn.default.SET_LOCAL_DESCRIPTION_FAILED, ((t, i) => {
                            e.statistics.sendSetLocalDescFailed(t, i), i.isP2P || e.eventEmitter.emit(X, F, t)
                        })), t.addListener(Rn.default.SET_REMOTE_DESCRIPTION_FAILED, ((t, i) => {
                            e.statistics.sendSetRemoteDescFailed(t, i), i.isP2P || e.eventEmitter.emit(X, F, t)
                        })), t.addListener(Rn.default.LOCAL_TRACK_SSRC_UPDATED, ((t, i) => {
                            t.isVideoTrack() && t.videoType === An.VideoType.DESKTOP && e.statistics.sendScreenSharingEvent(!0, i)
                        }))
                    }, Mn.prototype.removeXMPPListeners = function() {
                        const e = this.conference;
                        Object.keys(this.xmppListeners).forEach((t => {
                            e.xmpp.removeListener(t, this.xmppListeners[t])
                        })), this.xmppListeners = {}
                    }, Mn.prototype.setupXMPPListeners = function() {
                        const e = this.conference;
                        this._addConferenceXMPPListener(Nn.XMPPEvents.CALL_INCOMING, e.onIncomingCall.bind(e)), this._addConferenceXMPPListener(Nn.XMPPEvents.CALL_ACCEPTED, e.onCallAccepted.bind(e)), this._addConferenceXMPPListener(Nn.XMPPEvents.TRANSPORT_INFO, e.onTransportInfo.bind(e)), this._addConferenceXMPPListener(Nn.XMPPEvents.CALL_ENDED, e.onCallEnded.bind(e)), this._addConferenceXMPPListener(Nn.XMPPEvents.START_MUTED_FROM_FOCUS, ((t, i) => {
                            e.options.config.ignoreStartMuted || (e.startAudioMuted = t, e.startVideoMuted = i, t && (e.isMutedByFocus = !0), i && (e.isVideoMutedByFocus = !0), e.getLocalTracks().forEach((t => {
                                switch (t.getType()) {
                                    case dn.AUDIO:
                                        e.startAudioMuted && t.mute();
                                        break;
                                    case dn.VIDEO:
                                        e.startVideoMuted && t.mute()
                                }
                            })), e.eventEmitter.emit(ke))
                        })), this._addConferenceXMPPListener(Nn.XMPPEvents.CONFERENCE_TIMESTAMP_RECEIVED, (t => {
                            e.eventEmitter.emit(oe, t)
                        })), this._addConferenceXMPPListener(Nn.XMPPEvents.AV_MODERATION_CHANGED, ((t, i, n) => {
                            const s = e.getParticipants().find((e => e.getJid() === n));
                            e.eventEmitter.emit(it, {
                                enabled: t,
                                mediaType: i,
                                actor: s
                            })
                        })), this._addConferenceXMPPListener(Nn.XMPPEvents.AV_MODERATION_PARTICIPANT_APPROVED, ((t, i) => {
                            const n = e.getParticipantById(ut.Strophe.getResourceFromJid(i));
                            n && e.eventEmitter.emit(nt, {
                                participant: n,
                                mediaType: t
                            })
                        })), this._addConferenceXMPPListener(Nn.XMPPEvents.AV_MODERATION_PARTICIPANT_REJECTED, ((t, i) => {
                            const n = e.getParticipantById(ut.Strophe.getResourceFromJid(i));
                            n && e.eventEmitter.emit(st, {
                                participant: n,
                                mediaType: t
                            })
                        })), this._addConferenceXMPPListener(Nn.XMPPEvents.AV_MODERATION_APPROVED, (t => e.eventEmitter.emit(et, {
                            mediaType: t
                        }))), this._addConferenceXMPPListener(Nn.XMPPEvents.AV_MODERATION_REJECTED, (t => {
                            e.eventEmitter.emit(tt, {
                                mediaType: t
                            })
                        }))
                    }, Mn.prototype._addConferenceXMPPListener = function(e, t) {
                        this.xmppListeners[e] = t, this.conference.xmpp.addListener(e, t)
                    }, Mn.prototype.setupStatisticsListeners = function() {
                        const e = this.conference;
                        e.statistics && (e.statistics.addAudioLevelListener(((t, i, n, s) => {
                            e.rtc.setAudioLevel(t, i, n, s)
                        })), e.statistics.addBeforeDisposedListener((() => {
                            e.eventEmitter.emit(q)
                        })), e.options.config.startSilent || e.statistics.addByteSentStatsListener(((t, i) => {
                            e.getLocalTracks(dn.AUDIO).forEach((e => {
                                const n = t.getLocalSSRC(e);
                                n && i.hasOwnProperty(n) && e.onByteSentStatsReceived(t, i[n])
                            }))
                        })))
                    };
                    const On = (0, v.getLogger)("modules/connectivity/ParticipantConnectionStatus.js"),
                        wn = {
                            ACTIVE: "active",
                            INACTIVE: "inactive",
                            INTERRUPTED: "interrupted",
                            RESTORING: "restoring"
                        };
                    class Ln {
                        static _getNewStateForJvbMode(e, t, i, n, s) {
                            return e ? n ? wn.ACTIVE : Ui.supportsVideoMuteOnConnInterrupted() ? s ? t ? i ? wn.INTERRUPTED : wn.RESTORING : wn.INACTIVE : wn.ACTIVE : t ? wn.ACTIVE : wn.INACTIVE : wn.INTERRUPTED
                        }
                        static _getNewStateForP2PMode(e, t) {
                            return Ui.supportsVideoMuteOnConnInterrupted() ? e || !t ? wn.ACTIVE : wn.INTERRUPTED : wn.ACTIVE
                        }
                        constructor(e, t, i) {
                            this.rtc = e, this.conference = t, this.trackTimers = {}, this.connStatusFromJvb = {}, this.outOfLastNTimeout = "number" == typeof i.outOfLastNTimeout ? i.outOfLastNTimeout : 500, this.p2pRtcMuteTimeout = "number" == typeof i.p2pRtcMuteTimeout ? i.p2pRtcMuteTimeout : 2500, this.rtcMuteTimeout = "number" == typeof i.rtcMuteTimeout ? i.rtcMuteTimeout : 1e4, this.rtcMutedTimestamp = {}, On.info(`RtcMuteTimeout set to: ${this.rtcMuteTimeout}`), this.enteredLastNTimestamp = new Map, this.restoringTimers = new Map, this.connectionStatusMap = new Map
                        }
                        _getVideoFrozenTimeout(e) {
                            return this.rtc.isInLastN(e) ? this.rtcMuteTimeout : this.conference.isP2PActive() ? this.p2pRtcMuteTimeout : this.outOfLastNTimeout
                        }
                        init() {
                            this._onEndpointConnStatusChanged = this.onEndpointConnStatusChanged.bind(this), this.rtc.addListener(Rn.default.ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged), this._onP2PStatus = this.refreshConnectionStatusForAll.bind(this), this.conference.on(Ie, this._onP2PStatus), this._onUserLeft = this.onUserLeft.bind(this), this.conference.on(Ke, this._onUserLeft), Ui.supportsVideoMuteOnConnInterrupted() && (this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this), this.rtc.addListener(Rn.default.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this), this.rtc.addListener(Rn.default.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this._onRemoteTrackAdded = this.onRemoteTrackAdded.bind(this), this.conference.on(Ue, this._onRemoteTrackAdded), this._onRemoteTrackRemoved = this.onRemoteTrackRemoved.bind(this), this.conference.on(He, this._onRemoteTrackRemoved), this._onSignallingMuteChanged = this.onSignallingMuteChanged.bind(this), this._onTrackVideoTypeChanged = this.onTrackVideoTypeChanged.bind(this)), this._onLastNChanged = this._onLastNChanged.bind(this), this.conference.on(pe, this._onLastNChanged), this._onLastNValueChanged = this.refreshConnectionStatusForAll.bind(this), this.rtc.on(Rn.default.LASTN_VALUE_CHANGED, this._onLastNValueChanged)
                        }
                        dispose() {
                            this.rtc.removeListener(Rn.default.ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged), Ui.supportsVideoMuteOnConnInterrupted() && (this.rtc.removeListener(Rn.default.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this.rtc.removeListener(Rn.default.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this.conference.off(Ue, this._onRemoteTrackAdded), this.conference.off(He, this._onRemoteTrackRemoved)), this.conference.off(pe, this._onLastNChanged), this.rtc.removeListener(Rn.default.LASTN_VALUE_CHANGED, this._onLastNValueChanged), this.conference.off(Ie, this._onP2PStatus), this.conference.off(Ke, this._onUserLeft);
                            const e = Object.keys(this.trackTimers);
                            for (const t of e) this.clearTimeout(t), this.clearRtcMutedTimestamp(t);
                            for (const e in this.connectionStatusMap) this.connectionStatusMap.hasOwnProperty(e) && this.onUserLeft(e);
                            this.connStatusFromJvb = {}
                        }
                        onEndpointConnStatusChanged(e, t) {
                            On.debug(`Detector RTCEvents.ENDPOINT_CONN_STATUS_CHANGED(${Date.now()}): ${e}: ${t}`), e !== this.conference.myUserId() && (this.connStatusFromJvb[e] = t, this.figureOutConnectionStatus(e))
                        }
                        _changeConnectionStatus(e, t) {
                            if (e.getConnectionStatus() !== t) {
                                const i = e.getId();
                                e._setConnectionStatus(t), On.debug(`Emit endpoint conn status(${Date.now()}) ${i}: ${t}`), Tn.sendLog(JSON.stringify({
                                    id: "peer.conn.status",
                                    participant: i,
                                    status: t
                                })), this.conference.eventEmitter.emit(Re, i, t)
                            }
                        }
                        clearTimeout(e) {
                            this.trackTimers[e] && (window.clearTimeout(this.trackTimers[e]), this.trackTimers[e] = null)
                        }
                        clearRtcMutedTimestamp(e) {
                            this.rtcMutedTimestamp[e] = null
                        }
                        onRemoteTrackAdded(e) {
                            e.isLocal() || e.getType() !== dn.VIDEO || (On.debug(`Detector on remote track added for: ${e.getParticipantId()}`), e.on(Lt, this._onSignallingMuteChanged), e.on(kt, (t => this._onTrackVideoTypeChanged(e, t))))
                        }
                        onRemoteTrackRemoved(e) {
                            if (!e.isLocal() && e.getType() === dn.VIDEO) {
                                const t = e.getParticipantId();
                                On.debug(`Detector on remote track removed: ${t}`), e.off(Lt, this._onSignallingMuteChanged), this.clearTimeout(t), this.clearRtcMutedTimestamp(t), this.figureOutConnectionStatus(t)
                            }
                        }
                        isVideoTrackFrozen(e) {
                            if (!Ui.supportsVideoMuteOnConnInterrupted()) return !1;
                            const t = e.getId(),
                                i = e.hasAnyVideoTrackWebRTCMuted(),
                                n = this.rtcMutedTimestamp[t],
                                s = this._getVideoFrozenTimeout(t);
                            return i && "number" == typeof n && Date.now() - n >= s
                        }
                        refreshConnectionStatusForAll() {
                            const e = this.conference.getParticipants();
                            for (const t of e) this.figureOutConnectionStatus(t.getId())
                        }
                        figureOutConnectionStatus(e) {
                            const t = this.conference.getParticipantById(e);
                            if (!t) return void On.debug(`figure out conn status - no participant for: ${e}`);
                            const i = this.conference.isP2PActive(),
                                n = this._isRestoringTimedout(e),
                                s = 0 === this.conference.getLastN(),
                                r = t.isVideoMuted() || s,
                                o = this.isVideoTrackFrozen(t),
                                a = this.rtc.isInLastN(e);
                            let c = this.connStatusFromJvb[e];
                            "boolean" != typeof c && (c = !0);
                            const d = i ? Ln._getNewStateForP2PMode(r, o) : Ln._getNewStateForJvbMode(c, a, n, r, o);
                            d !== wn.RESTORING && this._clearRestoringTimer(e), On.debug(`Figure out conn status for ${e}, is video muted: ${r} is active(jvb): ${c} video track frozen: ${o} p2p mode: ${i} is in last N: ${a} currentStatus => newStatus: ${t.getConnectionStatus()} => ${d}`);
                            const l = this.connectionStatusMap[e] || {};
                            if (!("p2p" in l) || !("connectionStatus" in l) || l.p2p !== i || l.connectionStatus !== d) {
                                const n = Date.now();
                                if (this.maybeSendParticipantConnectionStatusEvent(e, n), this.connectionStatusMap[e] = {
                                        ...l,
                                        connectionStatus: d,
                                        p2p: i,
                                        startedMs: n
                                    }, !("videoType" in this.connectionStatusMap[e])) {
                                    const i = t.getTracksByMediaType(dn.VIDEO);
                                    Array.isArray(i) && 0 !== i.length && (this.connectionStatusMap[e].videoType = i[0].videoType)
                                }
                            }
                            this._changeConnectionStatus(t, d)
                        }
                        maybeSendParticipantConnectionStatusEvent(e, t) {
                            const i = this.connectionStatusMap[e];
                            i && "startedMs" in i && "videoType" in i && "connectionStatus" in i && "p2p" in i && (i.value = t - i.startedMs, Tn.sendAnalytics(function() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                return {
                                    type: Ut.TYPE_OPERATIONAL,
                                    source: "peer.conn.status",
                                    action: "duration",
                                    attributes: e
                                }
                            }(i)))
                        }
                        _onLastNChanged() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                            const i = Date.now();
                            On.debug(`LastN endpoints changed leaving=${e}, entering=${t} at ${i}`), Ui.supportsVideoMuteOnConnInterrupted() || this.refreshConnectionStatusForAll();
                            for (const t of e) this.enteredLastNTimestamp.delete(t), this._clearRestoringTimer(t), Ui.supportsVideoMuteOnConnInterrupted() && this.figureOutConnectionStatus(t);
                            for (const e of t) this.enteredLastNTimestamp.set(e, i), Ui.supportsVideoMuteOnConnInterrupted() && this.figureOutConnectionStatus(e)
                        }
                        _clearRestoringTimer(e) {
                            const t = this.restoringTimers.get(e);
                            t && (clearTimeout(t), this.restoringTimers.delete(e))
                        }
                        _isRestoringTimedout(e) {
                            const t = this.enteredLastNTimestamp.get(e);
                            return !!(t && Date.now() - t >= 1e4) || (this.restoringTimers.get(e) || this.restoringTimers.set(e, setTimeout((() => this.figureOutConnectionStatus(e)), 1e4)), !1)
                        }
                        onUserLeft(e) {
                            this.maybeSendParticipantConnectionStatusEvent(e, Date.now()), delete this.connectionStatusMap[e]
                        }
                        onTrackRtcMuted(e) {
                            const t = e.getParticipantId(),
                                i = this.conference.getParticipantById(t);
                            if (On.debug(`Detector track RTC muted: ${t}`, Date.now()), i) {
                                if (this.rtcMutedTimestamp[t] = Date.now(), !i.isVideoMuted()) {
                                    this.clearTimeout(t);
                                    const e = this._getVideoFrozenTimeout(t);
                                    this.trackTimers[t] = window.setTimeout((() => {
                                        On.debug(`Set RTC mute timeout for: ${t}                     of ${e} ms`), this.clearTimeout(t), this.figureOutConnectionStatus(t)
                                    }), e)
                                }
                            } else On.error(`No participant for id: ${t}`)
                        }
                        onTrackRtcUnmuted(e) {
                            const t = e.getParticipantId();
                            On.debug(`Detector track RTC unmuted: ${t}`, Date.now()), this.clearTimeout(t), this.clearRtcMutedTimestamp(t), this.figureOutConnectionStatus(t)
                        }
                        onSignallingMuteChanged(e) {
                            const t = e.getParticipantId();
                            On.debug(`Detector on track signalling mute changed: ${t}`, e.isMuted()), this.figureOutConnectionStatus(t)
                        }
                        onTrackVideoTypeChanged(e, t) {
                            const i = e.getParticipantId(),
                                n = Date.now();
                            this.maybeSendParticipantConnectionStatusEvent(i, n), this.connectionStatusMap[i] = {
                                ...this.connectionStatusMap[i] || {},
                                videoType: t,
                                startedMs: n
                            }
                        }
                    }
                    class kn {
                        constructor(e, t, i, n, s, r, o, a, c) {
                            this._jid = e, this._id = ut.Strophe.getResourceFromJid(e), this._conference = t, this._displayName = i, this._supportsDTMF = !1, this._tracks = [], this._role = "none", this._status = r, this._hidden = n, this._statsID = s, this._connectionStatus = wn.ACTIVE, this._properties = {}, this._identity = o, this._isReplacing = a, this._isReplaced = c, this._features = new Set
                        }
                        getConference() {
                            return this._conference
                        }
                        getProperty(e) {
                            return this._properties[e]
                        }
                        hasAnyVideoTrackWebRTCMuted() {
                            return this.getTracks().some((e => e.getType() === dn.VIDEO && e.isWebRTCTrackMuted()))
                        }
                        _setConnectionStatus(e) {
                            this._connectionStatus = e
                        }
                        getConnectionStatus() {
                            return this._connectionStatus
                        }
                        setProperty(e, t) {
                            const i = this._properties[e];
                            t !== i && (this._properties[e] = t, this._conference.eventEmitter.emit(Pe, this, e, i, t))
                        }
                        getTracks() {
                            return this._tracks.slice()
                        }
                        getTracksByMediaType(e) {
                            return this.getTracks().filter((t => t.getType() === e))
                        }
                        getId() {
                            return this._id
                        }
                        getJid() {
                            return this._jid
                        }
                        getDisplayName() {
                            return this._displayName
                        }
                        getStatsID() {
                            return this._statsID
                        }
                        getStatus() {
                            return this._status
                        }
                        isModerator() {
                            return "moderator" === this._role
                        }
                        isHidden() {
                            return this._hidden
                        }
                        isHiddenFromRecorder() {
                            var e, t;
                            return "true" === (null === (e = this._identity) || void 0 === e || null === (t = e.user) || void 0 === t ? void 0 : t["hidden-from-recorder"])
                        }
                        isReplacing() {
                            return this._isReplacing
                        }
                        isReplaced() {
                            return this._isReplaced
                        }
                        isAudioMuted() {
                            return this._isMediaTypeMuted(dn.AUDIO)
                        }
                        _isMediaTypeMuted(e) {
                            return this.getTracks().reduce(((t, i) => t && (i.getType() !== e || i.isMuted())), !0)
                        }
                        isVideoMuted() {
                            return this._isMediaTypeMuted(dn.VIDEO)
                        }
                        getRole() {
                            return this._role
                        }
                        setRole(e) {
                            this._role = e
                        }
                        setIsReplacing(e) {
                            this._isReplacing = e
                        }
                        setIsReplaced(e) {
                            this._isReplaced = e
                        }
                        supportsDTMF() {
                            return this._supportsDTMF
                        }
                        getFeatures() {
                            return Promise.resolve(this._features)
                        }
                        hasFeature(e) {
                            return this._features.has(e)
                        }
                        setFeatures(e) {
                            this._features = e || new Set
                        }
                        getBotType() {
                            return this._botType
                        }
                        setBotType(e) {
                            this._botType = e
                        }
                        getConnectionJid() {
                            return this._connectionJid
                        }
                        setConnectionJid(e) {
                            this._connectionJid = e
                        }
                    }
                    let xn;
                    ! function(e) {
                        e.CONNECTION_DISCONNECTED = "connection.connectionDisconnected", e.CONNECTION_ESTABLISHED = "connection.connectionEstablished", e.CONNECTION_FAILED = "connection.connectionFailed", e.WRONG_STATE = "connection.wrongState", e.DISPLAY_NAME_REQUIRED = "connection.display_name_required"
                    }(xn || (xn = {}));
                    const Fn = xn.CONNECTION_DISCONNECTED,
                        Vn = xn.CONNECTION_ESTABLISHED,
                        Un = xn.CONNECTION_FAILED,
                        jn = xn.WRONG_STATE,
                        $n = xn.DISPLAY_NAME_REQUIRED;
                    let Hn;
                    i(1352),
                        function(e) {
                            e.CONNECTION_DROPPED_ERROR = "connection.droppedError", e.OTHER_ERROR = "connection.otherError", e.PASSWORD_REQUIRED = "connection.passwordRequired", e.SERVER_ERROR = "connection.serverError"
                        }(Hn || (Hn = {}));
                    const Bn = Hn.CONNECTION_DROPPED_ERROR,
                        Jn = Hn.OTHER_ERROR,
                        Gn = Hn.PASSWORD_REQUIRED,
                        Kn = Hn.SERVER_ERROR;
                    class qn {
                        constructor() {
                            var e = this;
                            this.promise = new Promise(((t, i) => {
                                this.resolve = function() {
                                    e.clearRejectTimeout(), t(...arguments)
                                }, this.reject = function() {
                                    e.clearRejectTimeout(), i(...arguments)
                                }
                            })), this.then = this.promise.then.bind(this.promise), this.catch = this.promise.catch.bind(this.promise)
                        }
                        clearRejectTimeout() {
                            clearTimeout(this._timeout)
                        }
                        setRejectTimeout(e) {
                            this._timeout = setTimeout((() => {
                                this.reject(new Error("timeout"))
                            }), e)
                        }
                    }
                    class Wn {
                        constructor() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new(dt());
                            this.eventEmitter = e, this.addEventListener = this.on = this.addListener, this.removeEventListener = this.off = this.removeListener
                        }
                        addListener(e, t) {
                            return this.eventEmitter.addListener(e, t), () => this.removeEventListener(e, t)
                        }
                        removeListener(e, t) {
                            this.eventEmitter.removeListener(e, t)
                        }
                    }
                    const Xn = (0, v.getLogger)("modules/e2ee/E2EEContext.js"),
                        zn = Symbol("kJitsiE2EE");
                    class Qn {
                        constructor() {
                            let {
                                sharedKey: e
                            } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = "";
                            const i = document.querySelector('script[src*="lib-jitsi-meet"]');
                            if (i) {
                                const e = i.src.lastIndexOf("/");
                                t = `${i.src.substring(0,e)}/`
                            }
                            let n = `${t}lib-jitsi-meet.e2ee-worker.js`;
                            if (t && "/" !== t) {
                                const e = new Blob([`importScripts("${n}");`], {
                                    type: "application/javascript"
                                });
                                n = window.URL.createObjectURL(e)
                            }
                            this._worker = new Worker(n, {
                                name: "E2EE Worker"
                            }), this._worker.onerror = e => Xn.error(e), this._worker.postMessage({
                                operation: "initialize",
                                sharedKey: e
                            })
                        }
                        cleanup(e) {
                            this._worker.postMessage({
                                operation: "cleanup",
                                participantId: e
                            })
                        }
                        cleanupAll() {
                            this._worker.postMessage({
                                operation: "cleanupAll"
                            })
                        }
                        handleReceiver(e, t, i) {
                            if (!e[zn])
                                if (e[zn] = !0, window.RTCRtpScriptTransform) {
                                    const t = {
                                        operation: "decode",
                                        participantId: i
                                    };
                                    e.transform = new RTCRtpScriptTransform(this._worker, t)
                                } else {
                                    const t = e.createEncodedStreams();
                                    this._worker.postMessage({
                                        operation: "decode",
                                        readableStream: t.readable,
                                        writableStream: t.writable,
                                        participantId: i
                                    }, [t.readable, t.writable])
                                }
                        }
                        handleSender(e, t, i) {
                            if (!e[zn])
                                if (e[zn] = !0, window.RTCRtpScriptTransform) {
                                    const t = {
                                        operation: "encode",
                                        participantId: i
                                    };
                                    e.transform = new RTCRtpScriptTransform(this._worker, t)
                                } else {
                                    const t = e.createEncodedStreams();
                                    this._worker.postMessage({
                                        operation: "encode",
                                        readableStream: t.readable,
                                        writableStream: t.writable,
                                        participantId: i
                                    }, [t.readable, t.writable])
                                }
                        }
                        setKey(e, t, i) {
                            this._worker.postMessage({
                                operation: "setKey",
                                key: t,
                                keyIndex: i,
                                participantId: e
                            })
                        }
                    }
                    const Yn = (0, v.getLogger)("modules/e2ee/KeyHandler.js");
                    class Zn extends Wn {
                        constructor(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            super(), this.conference = e, this.e2eeCtx = new Qn(t), this.enabled = !1, this._enabling = void 0, this.conference.on(_e, this._onMediaSessionStarted.bind(this)), this.conference.on(Ue, (e => e.isLocal() && this._onLocalTrackAdded(e))), this.conference.rtc.on(Rn.default.REMOTE_TRACK_ADDED, ((e, t) => this._setupReceiverE2EEForTrack(t, e))), this.conference.on($e, this._trackMuteChanged.bind(this))
                        }
                        isEnabled() {
                            return this.enabled
                        }
                        async setEnabled(e) {
                            this._enabling && await this._enabling, e !== this.enabled && (this._enabling = new qn, this.enabled = e, e || this.e2eeCtx.cleanupAll(), this._setEnabled && await this._setEnabled(e), this.conference.setLocalParticipantProperty("e2ee.enabled", e), this.conference._restartMediaSessions(), this._enabling.resolve())
                        }
                        setEncryptionKey() {
                            throw new Error("Not implemented by subclass")
                        }
                        _onLocalTrackAdded(e) {
                            for (const t of this.conference.getMediaSessions()) this._setupSenderE2EEForTrack(t, e)
                        }
                        _onMediaSessionStarted(e) {
                            const t = this.conference.getLocalTracks();
                            for (const i of t) this._setupSenderE2EEForTrack(e, i)
                        }
                        _setupReceiverE2EEForTrack(e, t) {
                            if (!this.enabled) return;
                            const i = e.findReceiverForTrack(t.track);
                            i ? this.e2eeCtx.handleReceiver(i, t.getType(), t.getParticipantId()) : Yn.warn(`Could not handle E2EE for ${t}: receiver not found in: ${e}`)
                        }
                        _setupSenderE2EEForTrack(e, t) {
                            if (!this.enabled) return;
                            const i = e.peerconnection,
                                n = i && i.findSenderForTrack(t.track);
                            n ? this.e2eeCtx.handleSender(n, t.getType(), t.getParticipantId()) : Yn.warn(`Could not handle E2EE for ${t}: sender not found in ${i}`)
                        }
                        _trackMuteChanged(e) {
                            if (Ui.doesVideoMuteByStreamRemove() && e.isLocal() && e.isVideoTrack() && !e.isMuted())
                                for (const t of this.conference.getMediaSessions()) this._setupSenderE2EEForTrack(t, e)
                        }
                    }
                    class es extends Zn {
                        constructor(e) {
                            super(e, {
                                sharedKey: !0
                            })
                        }
                        setKey(e) {
                            this.e2eeCtx.setKey(void 0, {
                                encryptionKey: e.encryptionKey
                            }, e.index)
                        }
                    }
                    var ts = i(9509),
                        is = i.n(ts),
                        ns = i(3577),
                        ss = i(4433);
                    ss.v1, ss.v3;
                    const rs = ss.v4;
                    ss.v5;
                    const os = (0, v.getLogger)("modules/e2ee/OlmAdapter.js"),
                        as = 5e3,
                        cs = "olm",
                        ds = "error",
                        ls = "key-info",
                        hs = "key-info-ack",
                        us = "session-ack",
                        ps = "session-init",
                        ms = Symbol("OlmData"),
                        fs = {
                            OLM_ID_KEY_READY: "olm.id_key_ready",
                            PARTICIPANT_E2EE_CHANNEL_READY: "olm.participant_e2ee_channel_ready",
                            PARTICIPANT_KEY_UPDATED: "olm.partitipant_key_updated"
                        };
                    class gs extends Wn {
                        constructor(e) {
                            super(), this._conf = e, this._init = new qn, this._key = void 0, this._keyIndex = -1, this._reqs = new Map, this._sessionInitialization = void 0, gs.isSupported() ? (this._bootstrapOlm(), this._conf.on(ce, this._onEndpointMessageReceived.bind(this)), this._conf.on(Y, this._onConferenceLeft.bind(this)), this._conf.on(Ke, this._onParticipantLeft.bind(this)), this._conf.on(Pe, this._onParticipantPropertyChanged.bind(this))) : this._init.reject(new Error("Olm not supported"))
                        }
                        async initSessions() {
                            if (this._sessionInitialization) throw new Error("OlmAdapter initSessions called multiple times"); {
                                this._sessionInitialization = new qn, await this._init;
                                const e = [],
                                    t = this._conf.myUserId();
                                for (const i of this._conf.getParticipants()) i.hasFeature(na) && t < i.getId() && e.push(this._sendSessionInit(i));
                                await Promise.allSettled(e), this._sessionInitialization.resolve(), this._sessionInitialization = void 0
                            }
                        }
                        static isSupported() {
                            return void 0 !== window.Olm
                        }
                        async updateKey(e) {
                            this._key = e, this._keyIndex++;
                            const t = [];
                            for (const e of this._conf.getParticipants()) {
                                const i = e.getId(),
                                    n = this._getParticipantOlmData(e);
                                if (!n.session) {
                                    os.warn(`Tried to send key to participant ${i} but we have no session`);
                                    continue
                                }
                                const s = rs(),
                                    r = {
                                        [ta]: cs,
                                        olm: {
                                            type: ls,
                                            data: {
                                                ciphertext: this._encryptKeyInfo(n.session),
                                                uuid: s
                                            }
                                        }
                                    },
                                    o = new qn;
                                o.setRejectTimeout(as), o.catch((() => {
                                    this._reqs.delete(s)
                                })), this._reqs.set(s, o), t.push(o), this._sendMessage(r, i)
                            }
                            return await Promise.allSettled(t), this._keyIndex
                        }
                        updateCurrentKey(e) {
                            return this._key = e, this._keyIndex
                        }
                        clearParticipantSession(e) {
                            const t = this._getParticipantOlmData(e);
                            t.session && (t.session.free(), t.session = void 0)
                        }
                        clearAllParticipantsSessions() {
                            for (const e of this._conf.getParticipants()) this.clearParticipantSession(e)
                        }
                        async _bootstrapOlm() {
                            os.debug("Initializing Olm...");
                            try {
                                await Olm.init(), this._olmAccount = new Olm.Account, this._olmAccount.create();
                                const e = JSON.parse(this._olmAccount.identity_keys());
                                this._idKey = e.curve25519, os.debug(`Olm ${Olm.get_library_version().join(".")} initialized`), this._init.resolve(), this._onIdKeyReady(this._idKey)
                            } catch (e) {
                                os.error("Failed to initialize Olm", e), this._init.reject(e)
                            }
                        }
                        _onIdKeyReady(e) {
                            os.debug(`Olm id key ready: ${e}`), this._conf.setLocalParticipantProperty("e2ee.idKey", e)
                        }
                        _onParticipantE2EEChannelReady(e) {
                            os.debug(`E2EE channel with participant ${e} is ready`)
                        }
                        _encryptKeyInfo(e) {
                            const t = {};
                            return void 0 !== this._key && (t.key = !!this._key && ns.fromByteArray(this._key), t.keyIndex = this._keyIndex), e.encrypt(JSON.stringify(t))
                        }
                        _getParticipantOlmData(e) {
                            return e[ms] = e[ms] || {}, e[ms]
                        }
                        async _onConferenceLeft() {
                            os.debug("Conference left"), await this._init;
                            for (const e of this._conf.getParticipants()) this._onParticipantLeft(e.getId(), e);
                            this._olmAccount && (this._olmAccount.free(), this._olmAccount = void 0)
                        }
                        async _onEndpointMessageReceived(e, t) {
                            if (t[ta] !== cs) return;
                            if (!t.olm) return void os.warn("Incorrectly formatted message");
                            await this._init;
                            const i = t.olm,
                                n = e.getId(),
                                s = this._getParticipantOlmData(e);
                            switch (i.type) {
                                case ps:
                                    if (s.session) os.warn(`Participant ${n} already has a session`), this._sendError(e, "Session already established");
                                    else {
                                        const e = new Olm.Session;
                                        e.create_outbound(this._olmAccount, i.data.idKey, i.data.otKey), s.session = e;
                                        const t = {
                                            [ta]: cs,
                                            olm: {
                                                type: us,
                                                data: {
                                                    ciphertext: this._encryptKeyInfo(e),
                                                    uuid: i.data.uuid
                                                }
                                            }
                                        };
                                        this._sendMessage(t, n), this._onParticipantE2EEChannelReady(n)
                                    }
                                    break;
                                case us:
                                    if (s.session) os.warn(`Participant ${n} already has a session`), this._sendError(e, "No session found");
                                    else if (i.data.uuid === s.pendingSessionUuid) {
                                        const {
                                            ciphertext: e
                                        } = i.data, t = this._reqs.get(i.data.uuid), r = new Olm.Session;
                                        r.create_inbound(this._olmAccount, e.body), this._olmAccount.remove_one_time_keys(r);
                                        const o = r.decrypt(e.type, e.body);
                                        s.session = r, s.pendingSessionUuid = void 0, this._onParticipantE2EEChannelReady(n), this._reqs.delete(i.data.uuid), t.resolve();
                                        const a = _s(o);
                                        if (a.key) {
                                            const e = ns.toByteArray(a.key),
                                                t = a.keyIndex;
                                            s.lastKey = e, this.eventEmitter.emit(fs.PARTICIPANT_KEY_UPDATED, n, e, t)
                                        }
                                    } else os.warn("Received ACK with the wrong UUID"), this._sendError(e, "Invalid UUID");
                                    break;
                                case ds:
                                    os.error(i.data.error);
                                    break;
                                case ls:
                                    if (s.session) {
                                        const {
                                            ciphertext: e
                                        } = i.data, t = _s(s.session.decrypt(e.type, e.body));
                                        if (void 0 !== t.key && void 0 !== t.keyIndex) {
                                            const e = !!t.key && ns.toByteArray(t.key),
                                                r = t.keyIndex;
                                            ht()(s.lastKey, e) || (s.lastKey = e, this.eventEmitter.emit(fs.PARTICIPANT_KEY_UPDATED, n, e, r));
                                            const o = {
                                                [ta]: cs,
                                                olm: {
                                                    type: hs,
                                                    data: {
                                                        ciphertext: this._encryptKeyInfo(s.session),
                                                        uuid: i.data.uuid
                                                    }
                                                }
                                            };
                                            this._sendMessage(o, n)
                                        }
                                    } else os.debug(`Received key info message from ${n} but we have no session for them!`), this._sendError(e, "No session found while processing key-info");
                                    break;
                                case hs:
                                    if (s.session) {
                                        const {
                                            ciphertext: e
                                        } = i.data, t = _s(s.session.decrypt(e.type, e.body));
                                        if (void 0 !== t.key && void 0 !== t.keyIndex) {
                                            const e = !!t.key && ns.toByteArray(t.key),
                                                i = t.keyIndex;
                                            ht()(s.lastKey, e) || (s.lastKey = e, this.eventEmitter.emit(fs.PARTICIPANT_KEY_UPDATED, n, e, i))
                                        }
                                        const r = this._reqs.get(i.data.uuid);
                                        this._reqs.delete(i.data.uuid), r.resolve()
                                    } else os.debug(`Received key info ack message from ${n} but we have no session for them!`), this._sendError(e, "No session found while processing key-info-ack")
                            }
                        }
                        _onParticipantLeft(e, t) {
                            os.debug(`Participant ${e} left`), this.clearParticipantSession(t)
                        }
                        async _onParticipantPropertyChanged(e, t, i, n) {
                            if ("e2ee.enabled" === t && n && this._conf.isE2EEEnabled()) {
                                const t = this._conf.myUserId(),
                                    i = e.getId();
                                if ((await e.getFeatures()).has(na) && t < i) {
                                    this._sessionInitialization && await this._sessionInitialization, await this._sendSessionInit(e);
                                    const t = this._getParticipantOlmData(e),
                                        n = rs(),
                                        s = new qn;
                                    s.setRejectTimeout(as), s.catch((() => {
                                        this._reqs.delete(n), t.pendingSessionUuid = void 0
                                    })), this._reqs.set(n, s);
                                    const r = {
                                        [ta]: cs,
                                        olm: {
                                            type: ls,
                                            data: {
                                                ciphertext: this._encryptKeyInfo(t.session),
                                                uuid: n
                                            }
                                        }
                                    };
                                    this._sendMessage(r, i)
                                }
                            }
                        }
                        _sendError(e, t) {
                            const i = e.getId(),
                                n = {
                                    [ta]: cs,
                                    olm: {
                                        type: ds,
                                        data: {
                                            error: t
                                        }
                                    }
                                };
                            this._sendMessage(n, i)
                        }
                        _sendMessage(e, t) {
                            this._conf.sendMessage(e, t)
                        }
                        _sendSessionInit(e) {
                            const t = e.getId(),
                                i = this._getParticipantOlmData(e);
                            if (i.session) return os.warn(`Tried to send session-init to ${t} but we already have a session`), Promise.reject();
                            if (void 0 !== i.pendingSessionUuid) return os.warn(`Tried to send session-init to ${t} but we already have a pending session`), Promise.reject();
                            this._olmAccount.generate_one_time_keys(1);
                            const n = JSON.parse(this._olmAccount.one_time_keys()),
                                s = Object.values(n.curve25519)[0];
                            if (!s) return Promise.reject(new Error("No one-time-keys generated"));
                            this._olmAccount.mark_keys_as_published();
                            const r = rs(),
                                o = {
                                    [ta]: cs,
                                    olm: {
                                        type: ps,
                                        data: {
                                            idKey: this._idKey,
                                            otKey: s,
                                            uuid: r
                                        }
                                    }
                                },
                                a = new qn;
                            return a.setRejectTimeout(as), a.catch((() => {
                                this._reqs.delete(r), i.pendingSessionUuid = void 0
                            })), this._reqs.set(r, a), this._sendMessage(o, t), i.pendingSessionUuid = r, a
                        }
                    }

                    function _s(e) {
                        try {
                            return JSON.parse(e)
                        } catch (e) {
                            return {}
                        }
                    }
                    gs.events = fs;
                    const Ss = (0, v.getLogger)("modules/e2ee/ManagedKeyHandler.js");
                    class vs extends Zn {
                        constructor(e) {
                            super(e), this._key = void 0, this._conferenceJoined = !1, this._olmAdapter = new gs(e), this._rotateKey = is()(this._rotateKeyImpl, 5e3), this._ratchetKey = is()(this._ratchetKeyImpl, 5e3), this._olmAdapter.on(gs.events.PARTICIPANT_KEY_UPDATED, this._onParticipantKeyUpdated.bind(this)), this.conference.on(Pe, this._onParticipantPropertyChanged.bind(this)), this.conference.on(Ge, this._onParticipantJoined.bind(this)), this.conference.on(Ke, this._onParticipantLeft.bind(this)), this.conference.on(Q, (() => {
                                this._conferenceJoined = !0
                            }))
                        }
                        async _setEnabled(e) {
                            e ? await this._olmAdapter.initSessions() : this._olmAdapter.clearAllParticipantsSessions(), this._key = !!e && this._generateKey();
                            const t = await this._olmAdapter.updateKey(this._key);
                            this.e2eeCtx.setKey(this.conference.myUserId(), this._key, t)
                        }
                        async _onParticipantPropertyChanged(e, t, i, n) {
                            switch (t) {
                                case "e2ee.idKey":
                                    Ss.debug(`Participant ${e.getId()} updated their id key: ${n}`);
                                    break;
                                case "e2ee.enabled":
                                    !n && this.enabled && this._olmAdapter.clearParticipantSession(e)
                            }
                        }
                        _onParticipantJoined() {
                            this._conferenceJoined && this.enabled && this._ratchetKey()
                        }
                        _onParticipantLeft(e) {
                            this.e2eeCtx.cleanup(e), this.enabled && this._rotateKey()
                        }
                        async _rotateKeyImpl() {
                            Ss.debug("Rotating key"), this._key = this._generateKey();
                            const e = await this._olmAdapter.updateKey(this._key);
                            this.e2eeCtx.setKey(this.conference.myUserId(), this._key, e)
                        }
                        async _ratchetKeyImpl() {
                            Ss.debug("Ratchetting key");
                            const e = await async function(e) {
                                return crypto.subtle.importKey("raw", e, "HKDF", !1, ["deriveBits", "deriveKey"])
                            }(this._key), t = await async function(e) {
                                const t = new TextEncoder;
                                return crypto.subtle.deriveBits({
                                    name: "HKDF",
                                    salt: t.encode("JFrameRatchetKey"),
                                    hash: "SHA-256",
                                    info: new ArrayBuffer
                                }, e, 256)
                            }(e);
                            this._key = new Uint8Array(t);
                            const i = this._olmAdapter.updateCurrentKey(this._key);
                            this.e2eeCtx.setKey(this.conference.myUserId(), this._key, i)
                        }
                        _onParticipantKeyUpdated(e, t, i) {
                            Ss.debug(`Participant ${e} updated their key`), this.e2eeCtx.setKey(e, t, i)
                        }
                        _generateKey() {
                            return window.crypto.getRandomValues(new Uint8Array(32))
                        }
                    }
                    class Es {
                        constructor(e) {
                            const {
                                e2ee: t = {}
                            } = e.options.config;
                            this._externallyManaged = t.externallyManagedKey, this._externallyManaged ? this._keyHandler = new es(e) : this._keyHandler = new vs(e)
                        }
                        static isSupported(e) {
                            const {
                                e2ee: t = {}
                            } = e;
                            return !(!t.externallyManagedKey && !gs.isSupported()) && !(e.testing && e.testing.disableE2EE) && (Ui.supportsInsertableStreams() || e.enableEncodedTransformSupport && Ui.supportsEncodedTransform())
                        }
                        isEnabled() {
                            return this._keyHandler.isEnabled()
                        }
                        async setEnabled(e) {
                            await this._keyHandler.setEnabled(e)
                        }
                        setEncryptionKey(e) {
                            this._keyHandler.setKey(e)
                        }
                    }
                    var ys = i(5399),
                        Ts = i.n(ys);
                    const Cs = ["category", "type", "lang", "name"],
                        bs = ["category", "type", "lang"];

                    function Rs(e, t) {
                        let i = 0;
                        return bs.some((n => 0 !== (i = e[n] > t[n] ? 1 : e[n] < t[n] && -1))), i
                    }

                    function As(e) {
                        const t = new Set,
                            i = new Set;
                        return $(e).find(">query>feature").each(((e, i) => t.add(i.getAttribute("var")))), $(e).find(">query>identity").each(((e, t) => i.add({
                            type: t.getAttribute("type"),
                            name: t.getAttribute("name"),
                            category: t.getAttribute("category")
                        }))), {
                            features: t,
                            identities: i
                        }
                    }
                    class Ps extends Wn {
                        constructor() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "http://jitsi.org/jitsimeet";
                            if (super(), this.node = t, this.disco = e.disco, !this.disco) throw new Error("Missing strophe-plugins (disco plugin is required)!");
                            this.version = "", this.rooms = new Set, this.externalFeatures = new Set;
                            const i = e.emuc;
                            i.addListener(Nn.XMPPEvents.EMUC_ROOM_ADDED, (e => this._addChatRoom(e))), i.addListener(Nn.XMPPEvents.EMUC_ROOM_REMOVED, (e => this._removeChatRoom(e))), Object.keys(i.rooms).forEach((e => {
                                this._addChatRoom(i.rooms[e])
                            })), ut.Strophe.addNamespace("CAPS", "http://jabber.org/protocol/caps"), this.disco.addFeature(ut.Strophe.NS.CAPS)
                        }
                        addFeature(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                            this.disco.addFeature(e), this._generateVersion(), i && !this.externalFeatures.has(e) && (this.externalFeatures.add(e), this.rooms.forEach((e => this._updateRoomWithExternalFeatures(e)))), t && this.submit()
                        }
                        removeFeature(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                            this.disco.removeFeature(e), this._generateVersion(), i && this.externalFeatures.has(e) && (this.externalFeatures.delete(e), this.rooms.forEach((e => this._updateRoomWithExternalFeatures(e)))), t && this.submit()
                        }
                        submit() {
                            this.rooms.forEach((e => e.sendPresence()))
                        }
                        _updateRoomWithExternalFeatures(e) {
                            if (0 === this.externalFeatures.size) e.removeFromPresence("features");
                            else {
                                const t = [];
                                this.externalFeatures.forEach((e => {
                                    t.push({
                                        tagName: "feature",
                                        attributes: {
                                            var: e
                                        }
                                    })
                                })), e.addOrReplaceInPresence("features", {
                                    children: t
                                })
                            }
                        }
                        getFeaturesAndIdentities(e, t) {
                            let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5e3;
                            return this._getDiscoInfo(e, t, i)
                        }
                        _getDiscoInfo(e, t, i) {
                            return new Promise(((n, s) => this.disco.info(e, t, (e => {
                                n(As(e))
                            }), s, i)))
                        }
                        _addChatRoom(e) {
                            this.rooms.add(e), this._fixChatRoomPresenceMap(e), this._updateRoomWithExternalFeatures(e)
                        }
                        _removeChatRoom(e) {
                            this.rooms.delete(e)
                        }
                        _fixChatRoomPresenceMap(e) {
                            e.addOrReplaceInPresence("c", {
                                attributes: {
                                    xmlns: ut.Strophe.NS.CAPS,
                                    hash: "sha-1",
                                    node: this.node,
                                    ver: this.version
                                }
                            })
                        }
                        _notifyVersionChanged() {
                            this.rooms.forEach((e => this._fixChatRoomPresenceMap(e)))
                        }
                        _generateVersion() {
                            this.version = function(e, t) {
                                const i = e.sort(Rs).reduce(((e, t) => `${Cs.reduce(((e,i,n)=>e+(0===n?"":"/")+(t[i]?t[i]:"")),"")}<`), ""),
                                    n = t.sort().reduce(((e, t) => `${e+t}<`), "");
                                return (0, ut.b64_sha1)(i + n)
                            }(this.disco._identities, this.disco._features), this._notifyVersionChanged()
                        }
                    }
                    i(9617);
                    const Is = "NETWORK_INFO_CHANGED",
                        Ns = (0, v.getLogger)("modules/connectivity/NetworkInfo.js"),
                        Ds = new class extends Wn {
                            constructor() {
                                super(), this._current = {
                                    isOnline: !0
                                }
                            }
                            updateNetworkInfo(e) {
                                let {
                                    isOnline: t
                                } = e;
                                Ns.debug("updateNetworkInfo", {
                                    isOnline: t
                                }), this._current = {
                                    isOnline: !0 === t
                                }, this.eventEmitter.emit(Is, this._current)
                            }
                            isOnline() {
                                return !0 === this._current.isOnline
                            }
                        },
                        Ms = (0, v.getLogger)("modules/xmpp/ResumeTask.js");
                    class Os {
                        constructor(e) {
                            this._stropheConn = e, this._resumeRetryN = 0, this._retryDelay = void 0
                        }
                        get retryDelay() {
                            return this._retryDelay
                        }
                        schedule() {
                            this._cancelResume(), this._resumeRetryN += 1, this._networkOnlineListener = Ds.addEventListener(Is, (e => {
                                let {
                                    isOnline: t
                                } = e;
                                t ? this._scheduleResume() : this._cancelResume()
                            })), Ds.isOnline() && this._scheduleResume()
                        }
                        _scheduleResume() {
                            this._resumeTimeout || (this._resumeRetryN = Math.min(3, this._resumeRetryN), this._retryDelay = function(e) {
                                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500,
                                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2;
                                return Math.floor(Math.random() * (1e3 * Math.pow(i, e) - t) + t)
                            }(this._resumeRetryN, 1500 * this._resumeRetryN, 3), Ms.info(`Will try to resume the XMPP connection in ${this.retryDelay}ms`), this._resumeTimeout = setTimeout((() => this._resumeConnection()), this.retryDelay))
                        }
                        _cancelResume() {
                            this._resumeTimeout && (Ms.info("Canceling connection resume task"), clearTimeout(this._resumeTimeout), this._resumeTimeout = void 0, this._retryDelay = void 0)
                        }
                        _resumeConnection() {
                            const {
                                streamManagement: e
                            } = this._stropheConn, t = e.getResumeToken();
                            if (!t) return;
                            Ms.info("Trying to resume the XMPP connection");
                            const i = new URL(this._stropheConn.service);
                            let {
                                search: n
                            } = i;
                            const s = /(previd=)([\w-]+)/,
                                r = n.match(s);
                            r && -1 === r.indexOf(t) ? n = n.replace(s, `$1${t}`) : r || (n += -1 === n.indexOf("?") ? `?previd=${t}` : `&previd=${t}`), i.search = n, this._stropheConn.service = i.toString(), e.resume()
                        }
                        cancel() {
                            this._cancelResume(), this._resumeRetryN = 0, this._networkOnlineListener && (this._networkOnlineListener(), this._networkOnlineListener = null)
                        }
                    }
                    class ws {
                        constructor() {
                            this._lastSuccess = null, this._lastFailedMessage = null
                        }
                        startTracking(e, t) {
                            var i = this;
                            const n = t.rawInput;
                            t.rawInput = function() {
                                for (var s = arguments.length, r = new Array(s), o = 0; o < s; o++) r[o] = arguments[o];
                                const a = r[0];
                                a.includes("failure") && (i._lastFailedMessage = a), e.connected && (i._lastSuccess = Date.now()), n.apply(t, r)
                            }
                        }
                        getLastFailedMessage() {
                            return this._lastFailedMessage
                        }
                        getTimeSinceLastSuccess() {
                            return this._lastSuccess ? Date.now() - this._lastSuccess : null
                        }
                    }

                    function Ls() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : class {};
                        return class extends e {
                            constructor() {
                                super(...arguments), this.connection = null
                            }
                            init(e) {
                                this.connection = e
                            }
                        }
                    }
                    const ks = Ls(),
                        xs = Ls(Wn),
                        Fs = (0, v.getLogger)("modules/xmpp/strophe.ping.js");
                    class Vs extends ks {
                        constructor(e) {
                            let {
                                getTimeSinceLastServerResponse: t,
                                onPingThresholdExceeded: i,
                                pingOptions: n = {}
                            } = e;
                            super(), this.failedPings = 0, this._onPingThresholdExceeded = i, this._getTimeSinceLastServerResponse = t, this.pingInterval = "number" == typeof n.interval ? n.interval : 1e4, this.pingTimeout = "number" == typeof n.timeout ? n.timeout : 5e3, this.pingThreshold = "number" == typeof n.threshold ? n.threshold : 2, this.pingTimestampsToKeep = Math.round(12e4 / this.pingInterval), this.pingExecIntervals = new Array(this.pingTimestampsToKeep)
                        }
                        init(e) {
                            super.init(e), ut.Strophe.addNamespace("PING", "urn:xmpp:ping")
                        }
                        ping(e, t, i, n) {
                            this._addPingExecutionTimestamp();
                            const s = (0, ut.$iq)({
                                type: "get",
                                to: e
                            });
                            s.c("ping", {
                                xmlns: ut.Strophe.NS.PING
                            }), this.connection.sendIQ2(s, {
                                timeout: n
                            }).then(t, i)
                        }
                        startInterval(e) {
                            clearInterval(this.intervalId), this.intervalId = window.setInterval((() => {
                                const t = Date.now();
                                if (this._getTimeSinceLastServerResponse() < t - this._lastServerCheck) return this._addPingExecutionTimestamp(), this._lastServerCheck = t, void(this.failedPings = 0);
                                this.ping(e, (() => {
                                    this._lastServerCheck = this._getTimeSinceLastServerResponse() + Date.now(), this.failedPings = 0
                                }), (e => {
                                    this.failedPings += 1;
                                    const t = "Ping " + (e ? "error" : "timeout");
                                    this.failedPings >= this.pingThreshold ? (Gi().callErrorHandler(new Error(t)), Fs.error(t, e), this._onPingThresholdExceeded && this._onPingThresholdExceeded()) : Fs.warn(t, e)
                                }), this.pingTimeout)
                            }), this.pingInterval), Fs.info(`XMPP pings will be sent every ${this.pingInterval} ms`)
                        }
                        stopInterval() {
                            this.intervalId && (window.clearInterval(this.intervalId), this.intervalId = null, this.failedPings = 0, Fs.info("Ping interval cleared"))
                        }
                        _addPingExecutionTimestamp() {
                            this.pingExecIntervals.push((new Date).getTime()), this.pingExecIntervals.length > this.pingTimestampsToKeep && this.pingExecIntervals.shift()
                        }
                        getPingSuspendTime() {
                            const e = this.pingExecIntervals.slice();
                            e.push((new Date).getTime());
                            let t = 0,
                                i = e[0];
                            return e.forEach((e => {
                                const n = e - i;
                                n > t && (t = n), i = e
                            })), t -= this.pingInterval, Math.max(t, 0)
                        }
                    }
                    const Us = (0, v.getLogger)("modules/xmpp/XmppConnection.js");
                    class js extends Wn {
                        static get Events() {
                            return {
                                CONN_STATUS_CHANGED: "CONN_STATUS_CHANGED",
                                CONN_SHARD_CHANGED: "CONN_SHARD_CHANGED"
                            }
                        }
                        static get Status() {
                            return ut.Strophe.Status
                        }
                        constructor(e) {
                            let {
                                enableWebsocketResume: t,
                                websocketKeepAlive: i,
                                websocketKeepAliveUrl: n,
                                serviceUrl: s,
                                shard: r,
                                xmppPing: o
                            } = e;
                            super(), this._options = {
                                enableWebsocketResume: void 0 === t || t,
                                pingOptions: o,
                                shard: r,
                                websocketKeepAlive: void 0 === i ? 6e4 : Number(i),
                                websocketKeepAliveUrl: n // BAO
                            }, this.$msg = ut.$msg, this.$pres = ut.$pres, this.$iq = ut.$iq, this.Strophe = ut.Strophe, this._stropheConn = new ut.Strophe.Connection(s), this._usesWebsocket = s.startsWith("ws:") || s.startsWith("wss:"), this._stropheConn.maxRetries = 3, this._rawInputTracker = new ws, this._rawInputTracker.startTracking(this, this._stropheConn), this._resumeTask = new Os(this._stropheConn), this._deferredIQs = [], this.addConnectionPlugin("ping", new Vs({
                                getTimeSinceLastServerResponse: () => this.getTimeSinceLastSuccess(),
                                onPingThresholdExceeded: () => this._onPingErrorThresholdExceeded(),
                                pingOptions: o
                            })), this._oneSuccessfulConnect = !1
                        }
                        get connected() {
                            const e = this._stropheConn && this._stropheConn._proto && this._stropheConn._proto.socket;
                            return (this._status === ut.Strophe.Status.CONNECTED || this._status === ut.Strophe.Status.ATTACHED) && (!this.isUsingWebSocket || e && e.readyState === WebSocket.OPEN)
                        }
                        get disco() {
                            return this._stropheConn.disco
                        }
                        get disconnecting() {
                            return !0 === this._stropheConn.disconnecting
                        }
                        get domain() {
                            return this._stropheConn.domain
                        }
                        get isUsingWebSocket() {
                            return this._usesWebsocket
                        }
                        get jid() {
                            return this._stropheConn.jid
                        }
                        get lastResponseHeaders() {
                            return this._stropheConn._proto && this._stropheConn._proto.lastResponseHeaders
                        }
                        get logger() {
                            return this._stropheConn.logger
                        }
                        get options() {
                            return this._stropheConn.options
                        }
                        get pingDomain() {
                            var e;
                            return (null === (e = this._options.pingOptions) || void 0 === e ? void 0 : e.domain) || this.domain
                        }
                        get service() {
                            return this._stropheConn.service
                        }
                        set shard(e) {
                            this._options.shard = e, this._oneSuccessfulConnect && this._maybeStartWSKeepAlive()
                        }
                        get status() {
                            return this._status
                        }
                        addConnectionPlugin(e, t) {
                            this[e] = t, t.init(this)
                        }
                        addHandler() {
                            this._stropheConn.addHandler(...arguments)
                        }
                        attach(e, t, i, n) {
                            for (var s = arguments.length, r = new Array(s > 4 ? s - 4 : 0), o = 4; o < s; o++) r[o - 4] = arguments[o];
                            this._stropheConn.attach(e, t, i, this._stropheConnectionCb.bind(this, n), ...r)
                        }
                        connect(e, t, i) {
                            for (var n = arguments.length, s = new Array(n > 3 ? n - 3 : 0), r = 3; r < n; r++) s[r - 3] = arguments[r];
                            this._stropheConn.connect(e, t, this._stropheConnectionCb.bind(this, i), ...s)
                        }
                        _stropheConnectionCb(e, t) {
                            this._status = t;
                            let i = !1;
                            var n;
                            if (t === ut.Strophe.Status.CONNECTED || t === ut.Strophe.Status.ATTACHED ? (this._maybeEnableStreamResume(), this._usesWebsocket && this._oneSuccessfulConnect && this._keepAliveAndCheckShard(), this._oneSuccessfulConnect = !0, this._maybeStartWSKeepAlive(), this._processDeferredIQs(), this._resumeTask.cancel(), this.ping.startInterval((null === (n = this._options.pingOptions) || void 0 === n ? void 0 : n.domain) || this.domain)) : t === ut.Strophe.Status.DISCONNECTED && (this.ping.stopInterval(), i = this._tryResumingConnection(), i || clearTimeout(this._wsKeepAlive)), !i) {
                                for (var s = arguments.length, r = new Array(s > 2 ? s - 2 : 0), o = 2; o < s; o++) r[o - 2] = arguments[o];
                                e(t, ...r), this.eventEmitter.emit(js.Events.CONN_STATUS_CHANGED, t)
                            }
                        }
                        _clearDeferredIQs() {
                            for (const e of this._deferredIQs) e.reject(new Error("disconnect"));
                            this._deferredIQs = []
                        }
                        closeWebsocket() {
                            this._stropheConn && this._stropheConn._proto && (this._stropheConn._proto._closeSocket(), this._stropheConn._proto._onClose(null))
                        }
                        disconnect() {
                            this._resumeTask.cancel(), clearTimeout(this._wsKeepAlive), this._clearDeferredIQs(), this._stropheConn.disconnect(...arguments)
                        }
                        flush() {
                            this._stropheConn.flush(...arguments)
                        }
                        getTimeSinceLastSuccess() {
                            return this._rawInputTracker.getTimeSinceLastSuccess()
                        }
                        getLastFailedMessage() {
                            return this._rawInputTracker.getLastFailedMessage()
                        }
                        _maybeEnableStreamResume() {
                            if (!this._options.enableWebsocketResume) return;
                            const {
                                streamManagement: e
                            } = this._stropheConn;
                            this.isUsingWebSocket ? e ? e.isSupported() ? e.getResumeToken() || (Us.info("Enabling XEP-0198 stream management"), e.enable(!0)) : Us.warn("Stream resume enabled, but XEP-0198 is not supported by the server") : Us.warn("Stream resume enabled, but Strophe streamManagement plugin is not installed") : Us.warn("Stream resume enabled, but WebSockets are not enabled")
                        }
                        _maybeStartWSKeepAlive() {
                            const {
                                websocketKeepAlive: e
                            } = this._options;
                            if (this._usesWebsocket && e > 0) {
                                this._wsKeepAlive || Us.info(`WebSocket keep alive interval: ${e}ms`), clearTimeout(this._wsKeepAlive);
                                const t = e + 60 * Math.random() * 1e3;
                                Us.debug(`Scheduling next WebSocket keep-alive in ${t}ms`), this._wsKeepAlive = setTimeout((() => this._keepAliveAndCheckShard().then((() => this._maybeStartWSKeepAlive()))), t)
                            }
                        }
                        _keepAliveAndCheckShard() {
                            const {
                                shard: e,
                                websocketKeepAliveUrl: t
                            } = this._options, i = t || this.service.replace("wss://", "https://").replace("ws://", "http://");
                            return fetch(i).then((t => {
                                if (!e) return;
                                const i = t.headers.get("x-jitsi-shard");
                                i !== e && (Us.error(`Detected that shard changed from ${e} to ${i}`), this.eventEmitter.emit(js.Events.CONN_SHARD_CHANGED))
                            })).catch((e => {
                                Us.error(`Websocket Keep alive failed for url: ${i}`, {
                                    error: e
                                })
                            }))
                        }
                        _processDeferredIQs() {
                            for (const e of this._deferredIQs)
                                if (e.iq) {
                                    clearTimeout(e.timeout);
                                    const t = Date.now() - e.start;
                                    this.sendIQ(e.iq, (t => e.resolve(t)), (t => e.reject(t)), t)
                                } this._deferredIQs = []
                        }
                        send(e) {
                            if (!this.connected) throw new Error("Not connected");
                            this._stropheConn.send(e)
                        }
                        sendIQ(e, t, i, n) {
                            if (this.connected) return this._stropheConn.sendIQ(e, t, i, n);
                            i("Not connected")
                        }
                        sendIQ2(e, t) {
                            let {
                                timeout: i
                            } = t;
                            return new Promise(((t, n) => {
                                if (this.connected) this.sendIQ(e, (e => t(e)), (e => n(e)), i);
                                else {
                                    const s = {
                                        iq: e,
                                        resolve: t,
                                        reject: n,
                                        start: Date.now(),
                                        timeout: setTimeout((() => {
                                            s.iq = void 0, n(void 0)
                                        }), i)
                                    };
                                    this._deferredIQs.push(s)
                                }
                            }))
                        }
                        _onPingErrorThresholdExceeded() {
                            this.isUsingWebSocket && (Us.warn("Ping error threshold exceeded - killing the WebSocket"), this.closeWebsocket())
                        }
                        sendPresence(e, t, i, n) {
                            this.connected ? this._stropheConn.sendPresence(e, t, i, n) : i("Not connected")
                        }
                        sendUnavailableBeacon() {
                            if (!navigator.sendBeacon || this._stropheConn.disconnecting || !this._stropheConn.connected) return !1;
                            this._stropheConn._changeConnectStatus(ut.Strophe.Status.DISCONNECTING), this._stropheConn.disconnecting = !0;
                            const e = this._stropheConn._proto._buildBody().attrs({
                                    type: "terminate"
                                }),
                                t = (0, ut.$pres)({
                                    xmlns: ut.Strophe.NS.CLIENT,
                                    type: "unavailable"
                                });
                            e.cnode(t.tree());
                            const i = navigator.sendBeacon(-1 === this.service.indexOf("https://") ? `https:${this.service}` : this.service, ut.Strophe.serialize(e.tree()));
                            return Us.info(`Successfully send unavailable beacon ${i}`), this._stropheConn._proto._abortAllRequests(), this._stropheConn._doDisconnect(), !0
                        }
                        _tryResumingConnection() {
                            const {
                                streamManagement: e
                            } = this._stropheConn;
                            return !(!e || !e.getResumeToken() || (this._resumeTask.schedule(), 0))
                        }
                    }
                    let $s;
                    ! function(e) {
                        e.ON = "on", e.OFF = "off"
                    }($s || ($s = {}));
                    const Hs = $s.ON,
                        Bs = $s.OFF,
                        Js = (0, v.getLogger)("modules/xmpp/AVModeration.js");
                    class Gs {
                        constructor(e) {
                            this._xmpp = e.xmpp, this._mainRoom = e, this._moderationEnabledByType = {
                                [dn.AUDIO]: !1,
                                [dn.VIDEO]: !1
                            }, this._whitelistAudio = [], this._whitelistVideo = [], this._onMessage = this._onMessage.bind(this), this._xmpp.addListener(Nn.XMPPEvents.AV_MODERATION_RECEIVED, this._onMessage)
                        }
                        dispose() {
                            this._xmpp.removeListener(Nn.XMPPEvents.AV_MODERATION_RECEIVED, this._onMessage)
                        }
                        isSupported() {
                            return Boolean(this._xmpp.avModerationComponentAddress)
                        }
                        enable(e, t) {
                            if (!this.isSupported() || !this._mainRoom.isModerator()) return void Js.error(`Cannot enable:${e} AV moderation supported:${this.isSupported()},\n                moderator:${this._mainRoom.isModerator()}`);
                            if (e === this._moderationEnabledByType[t]) return void Js.warn(`Moderation already in state:${e} for mediaType:${t}`);
                            const i = (0, ut.$msg)({
                                to: this._xmpp.avModerationComponentAddress
                            });
                            i.c("av_moderation", {
                                enable: e,
                                mediaType: t
                            }).up(), this._xmpp.connection.send(i)
                        }
                        approve(e, t) {
                            if (!this.isSupported() || !this._mainRoom.isModerator()) return void Js.error(`Cannot approve in AV moderation supported:${this.isSupported()},\n                moderator:${this._mainRoom.isModerator()}`);
                            const i = (0, ut.$msg)({
                                to: this._xmpp.avModerationComponentAddress
                            });
                            i.c("av_moderation", {
                                mediaType: e,
                                jidToWhitelist: t
                            }).up(), this._xmpp.connection.send(i)
                        }
                        reject(e, t) {
                            if (!this.isSupported() || !this._mainRoom.isModerator()) return void Js.error(`Cannot reject in AV moderation supported:${this.isSupported()},\n                moderator:${this._mainRoom.isModerator()}`);
                            const i = (0, ut.$msg)({
                                to: this._xmpp.avModerationComponentAddress
                            });
                            i.c("av_moderation", {
                                mediaType: e,
                                jidToBlacklist: t
                            }).up(), this._xmpp.connection.send(i)
                        }
                        _onMessage(e) {
                            const {
                                removed: t,
                                mediaType: i,
                                enabled: n,
                                approved: s,
                                actor: r,
                                whitelists: o
                            } = e;
                            if (o) {
                                const e = i === dn.AUDIO ? this._whitelistAudio : this._whitelistVideo,
                                    n = Array.isArray(o[i]) ? o[i] : [];
                                t ? e.filter((e => !n.includes(e))).forEach((e => this._xmpp.eventEmitter.emit(Nn.XMPPEvents.AV_MODERATION_PARTICIPANT_REJECTED, i, e))) : n.filter((t => !e.includes(t))).forEach((e => this._xmpp.eventEmitter.emit(Nn.XMPPEvents.AV_MODERATION_PARTICIPANT_APPROVED, i, e))), i === dn.AUDIO ? this._whitelistAudio = n : this._whitelistVideo = n
                            } else void 0 !== n && this._moderationEnabledByType[i] !== n ? (this._moderationEnabledByType[i] = n, this._xmpp.eventEmitter.emit(Nn.XMPPEvents.AV_MODERATION_CHANGED, n, i, r)) : t ? this._xmpp.eventEmitter.emit(Nn.XMPPEvents.AV_MODERATION_REJECTED, i) : s && this._xmpp.eventEmitter.emit(Nn.XMPPEvents.AV_MODERATION_APPROVED, i)
                        }
                    }
                    const Ks = "features/breakout-rooms",
                        qs = {
                            ADD: `${Ks}/add`,
                            REMOVE: `${Ks}/remove`,
                            MOVE_TO_ROOM: `${Ks}/move-to-room`
                        },
                        Ws = `${Ks}/move-to-room`,
                        Xs = `${Ks}/update`,
                        zs = (0, v.getLogger)("modules/xmpp/BreakoutRooms.js");
                    class Qs {
                        constructor(e) {
                            this.room = e, this._handleMessages = this._handleMessages.bind(this), this.room.xmpp.addListener(Nn.XMPPEvents.BREAKOUT_ROOMS_EVENT, this._handleMessages), this._rooms = {}
                        }
                        dispose() {
                            this.room.xmpp.removeListener(Nn.XMPPEvents.BREAKOUT_ROOMS_EVENT, this._handleMessages)
                        }
                        createBreakoutRoom(e) {
                            if (!this.isSupported() || !this.room.isModerator()) return void zs.error(`Cannot create breakout room - supported:${this.isSupported()},\n                moderator:${this.room.isModerator()}`);
                            const t = {
                                type: qs.ADD,
                                subject: e
                            };
                            this._sendMessage(t)
                        }
                        removeBreakoutRoom(e) {
                            if (!this.isSupported() || !this.room.isModerator()) return void zs.error(`Cannot remove breakout room - supported:${this.isSupported()},\n                moderator:${this.room.isModerator()}`);
                            const t = {
                                type: qs.REMOVE,
                                breakoutRoomJid: e
                            };
                            this._sendMessage(t)
                        }
                        sendParticipantToRoom(e, t) {
                            if (!this.isSupported() || !this.room.isModerator()) return void zs.error(`Cannot send participant to room - supported:${this.isSupported()},\n                moderator:${this.room.isModerator()}`);
                            const i = {
                                type: qs.MOVE_TO_ROOM,
                                participantJid: e,
                                roomJid: t
                            };
                            this._sendMessage(i)
                        }
                        isSupported() {
                            return Boolean(this.getComponentAddress())
                        }
                        getComponentAddress() {
                            return this.room.xmpp.breakoutRoomsComponentAddress
                        }
                        _setIsBreakoutRoom(e) {
                            this._isBreakoutRoom = e
                        }
                        isBreakoutRoom() {
                            return void 0 !== this._isBreakoutRoom ? this._isBreakoutRoom : ut.Strophe.getDomainFromJid(this.room.myroomjid) === this.getComponentAddress()
                        }
                        _setMainRoomJid(e) {
                            this._mainRoomJid = e
                        }
                        getMainRoomJid() {
                            return this._mainRoomJid
                        }
                        _handleMessages(e) {
                            switch (e.event) {
                                case Ws:
                                    this.room.eventEmitter.emit(Nn.XMPPEvents.BREAKOUT_ROOMS_MOVE_TO_ROOM, e.roomJid);
                                    break;
                                case Xs:
                                    this._rooms = e.rooms, this.room.eventEmitter.emit(Nn.XMPPEvents.BREAKOUT_ROOMS_UPDATED, e)
                            }
                        }
                        _sendMessage(e) {
                            const t = (0, ut.$msg)({
                                to: this.getComponentAddress()
                            });
                            t.c("breakout_rooms", e).up(), this.room.xmpp.connection.send(t)
                        }
                    }
                    const Ys = (0, v.getLogger)("modules/xmpp/Lobby.js"),
                        Zs = "email";
                    class er {
                        constructor(e) {
                            this.xmpp = e.xmpp, this.mainRoom = e;
                            const t = this._maybeJoinLobbyRoom.bind(this);
                            this.mainRoom.addEventListener(Nn.XMPPEvents.LOCAL_ROLE_CHANGED, t), this.mainRoom.addEventListener(Nn.XMPPEvents.MUC_MEMBERS_ONLY_CHANGED, t), this.mainRoom.addEventListener(Nn.XMPPEvents.ROOM_CONNECT_MEMBERS_ONLY_ERROR, (e => {
                                this.lobbyRoomJid = e
                            }))
                        }
                        isSupported() {
                            return this.xmpp.lobbySupported
                        }
                        enable() {
                            return this.isSupported() ? new Promise(((e, t) => {
                                this.mainRoom.setMembersOnly(!0, e, t)
                            })) : Promise.reject(new Error("Lobby not supported!"))
                        }
                        disable() {
                            this.isSupported() && this.mainRoom.isModerator() && this.lobbyRoom && this.mainRoom.membersOnlyEnabled && this.mainRoom.setMembersOnly(!1)
                        }
                        sendMessage(e) {
                            this.lobbyRoom && this.lobbyRoom.sendMessage(JSON.stringify(e), "json-message")
                        }
                        sendPrivateMessage(e, t) {
                            this.lobbyRoom && this.lobbyRoom.sendPrivateMessage(e, JSON.stringify(t), "json-message")
                        }
                        getLocalId() {
                            if (this.lobbyRoom) return ut.Strophe.getResourceFromJid(this.lobbyRoom.myroomjid)
                        }
                        addMessageListener(e) {
                            if (this.lobbyRoom) {
                                const t = (t, i) => {
                                    e(i, ut.Strophe.getResourceFromJid(t))
                                };
                                return this.lobbyRoom.on(Nn.XMPPEvents.JSON_MESSAGE_RECEIVED, t), t
                            }
                        }
                        removeMessageHandler(e) {
                            this.lobbyRoom && this.lobbyRoom.off(Nn.XMPPEvents.JSON_MESSAGE_RECEIVED, e)
                        }
                        leave() {
                            return this.lobbyRoom ? this.lobbyRoom.leave().then((() => {
                                this.lobbyRoom = void 0, Ys.info("Lobby room left!")
                            })).catch((() => {})) : Promise.reject(new Error("The lobby has already been left"))
                        }
                        setLobbyRoomJid(e) {
                            this.lobbyRoomJid = e
                        }
                        _maybeJoinLobbyRoom() {
                            this.isSupported() && this.mainRoom.joined && this.mainRoom.isModerator() && this.mainRoom.membersOnlyEnabled && !this.lobbyRoom && this.join().then((() => Ys.info("Joined lobby room"))).catch((e => Ys.error("Failed joining lobby", e)))
                        }
                        join(e, t) {
                            const i = this.mainRoom.joined && this.mainRoom.isModerator();
                            if (!this.lobbyRoomJid) return Promise.reject(new Error("Missing lobbyRoomJid, cannot join lobby room."));
                            const n = ut.Strophe.getNodeFromJid(this.lobbyRoomJid),
                                s = ut.Strophe.getDomainFromJid(this.lobbyRoomJid);
                            return this.lobbyRoom = this.xmpp.createRoom(n, {
                                customDomain: s,
                                disableDiscoInfo: !0,
                                disableFocus: !0,
                                enableLobby: !1
                            }), e && this.lobbyRoom.addOrReplaceInPresence("nick", {
                                attributes: {
                                    xmlns: "http://jabber.org/protocol/nick"
                                },
                                value: e
                            }), i ? (this.lobbyRoom.addPresenceListener(Zs, ((e, t) => {
                                this.mainRoom.eventEmitter.emit(Nn.XMPPEvents.MUC_LOBBY_MEMBER_UPDATED, t, {
                                    email: e.value
                                })
                            })), this.lobbyRoom.addEventListener(Nn.XMPPEvents.MUC_MEMBER_JOINED, ((e, t, i, n, s, r, o, a, c) => {
                                if (!Object.values(this.mainRoom.members).find((e => e.jid === c))) {
                                    for (const e of Object.values(this.mainRoom.getBreakoutRooms()._rooms))
                                        if (Object.values(e.participants).find((e => e.jid === c))) return;
                                    this.mainRoom.eventEmitter.emit(Nn.XMPPEvents.MUC_LOBBY_MEMBER_JOINED, ut.Strophe.getResourceFromJid(e), t, o ? o.avatar : void 0)
                                }
                            })), this.lobbyRoom.addEventListener(Nn.XMPPEvents.MUC_MEMBER_LEFT, (e => {
                                this.mainRoom.eventEmitter.emit(Nn.XMPPEvents.MUC_LOBBY_MEMBER_LEFT, ut.Strophe.getResourceFromJid(e))
                            })), this.lobbyRoom.addEventListener(Nn.XMPPEvents.MUC_DESTROYED, (() => {
                                Object.keys(this.lobbyRoom.members).forEach((e => this.mainRoom.eventEmitter.emit(Nn.XMPPEvents.MUC_LOBBY_MEMBER_LEFT, ut.Strophe.getResourceFromJid(e)))), this.lobbyRoom.clean(), this.lobbyRoom = void 0, Ys.info("Lobby room left(destroyed)!")
                            }))) : (this.lobbyRoom.addEventListener(Nn.XMPPEvents.KICKED, (e => {
                                if (e) return this.mainRoom.eventEmitter.emit(Nn.XMPPEvents.MUC_DENIED_ACCESS), void this.lobbyRoom.clean()
                            })), this.mainRoom.addEventListener(Nn.XMPPEvents.INVITE_MESSAGE_RECEIVED, ((e, t, i, n) => {
                                Ys.debug(`Received approval to join ${e} ${t} ${i}`), e === this.mainRoom.roomjid && this.mainRoom.join(n)
                            })), this.lobbyRoom.addEventListener(Nn.XMPPEvents.MUC_DESTROYED, ((e, t) => {
                                t ? this.mainRoom.join() : (this.lobbyRoom.clean(), this.mainRoom.eventEmitter.emit(Nn.XMPPEvents.MUC_DESTROYED, e))
                            })), this.mainRoom.addEventListener(Nn.XMPPEvents.MUC_JOINED, (() => {
                                this.leave()
                            }))), new Promise(((e, n) => {
                                this.lobbyRoom.addEventListener(Nn.XMPPEvents.MUC_JOINED, (() => {
                                    e(), t && !i && this.lobbyRoom.addOrReplaceInPresence(Zs, {
                                        value: t
                                    }) && this.lobbyRoom.sendPresence()
                                })), this.lobbyRoom.addEventListener(Nn.XMPPEvents.ROOM_JOIN_ERROR, n), this.lobbyRoom.addEventListener(Nn.XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR, n), this.lobbyRoom.addEventListener(Nn.XMPPEvents.ROOM_CONNECT_ERROR, n), this.lobbyRoom.join()
                            }))
                        }
                        denyAccess(e) {
                            if (!this.isSupported() || !this.mainRoom.isModerator()) return;
                            const t = Object.keys(this.lobbyRoom.members).find((t => ut.Strophe.getResourceFromJid(t) === e));
                            t ? this.lobbyRoom.kick(t) : Ys.error(`Not found member for ${e} in lobby room.`)
                        }
                        approveAccess(e) {
                            if (!this.isSupported() || !this.mainRoom.isModerator()) return;
                            let t = this.mainRoom.roomjid;
                            this.mainRoom.getBreakoutRooms().isBreakoutRoom() && (t = this.mainRoom.getBreakoutRooms().getMainRoomJid());
                            const i = Object.keys(this.lobbyRoom.members).find((t => ut.Strophe.getResourceFromJid(t) === e));
                            if (i) {
                                const e = this.lobbyRoom.members[i].jid,
                                    n = (0, ut.$msg)({
                                        to: t
                                    }).c("x", {
                                        xmlns: "http://jabber.org/protocol/muc#user"
                                    }).c("invite", {
                                        to: e
                                    });
                                this.xmpp.connection.sendIQ(n, (() => {}), (t => {
                                    Ys.error(`Error sending invite for ${e}`, t)
                                }))
                            } else Ys.error(`Not found member for ${i} in lobby room.`)
                        }
                    }
                    var tr = i(6667),
                        ir = i.n(tr);
                    const nr = (0, v.getLogger)("modules/settings/Settings.js");
                    let sr, rr;
                    const or = {
                        _storage: Fi,
                        init(e) {
                            this._storage = e || Fi
                        },
                        get callStatsUserName() {
                            return sr || (sr = this._storage.getItem("callStatsUserName"), sr || (sr = function() {
                                const e = ir().generateUsername();
                                return nr.log("generated callstats uid", e), e
                            }(), this._storage.setItem("callStatsUserName", sr))), sr
                        },
                        get machineId() {
                            if (!rr) {
                                const e = this._storage.getItem("billingId");
                                rr = e || this._storage.getItem("jitsiMeetId"), e ? this._storage.setItem("jitsiMeetId", e) : rr || (rr = function() {
                                    const e = ar() + ar() + ar() + ar();
                                    return nr.log("generated id", e), e
                                }(), this._storage.setItem("jitsiMeetId", rr))
                            }
                            return rr
                        },
                        get sessionId() {
                            return this._storage.getItem("sessionId")
                        },
                        set sessionId(e) {
                            e ? this._storage.setItem("sessionId", e) : this._storage.removeItem("sessionId")
                        }
                    };

                    function ar() {
                        return `${Math.random().toString(16)}000000000`.substr(2, 8)
                    }
                    const cr = i(3514),
                        {
                            XMPPEvents: dr
                        } = i(609),
                        lr = i(1023),
                        hr = (0, v.getLogger)("modules/xmpp/moderator.js");

                    function ur(e) {
                        let t = 1;
                        return function(i) {
                            if (i) return void(t = 1);
                            const n = Math.pow(2, t - 1);
                            return t += 1, n * e
                        }
                    }

                    function pr(e, t, i, n) {
                        function s(e) {
                            if (e.data && e.data.sessionId) {
                                if (e.origin !== window.location.origin) return void hr.warn(`Ignoring sessionId from different origin: ${e.origin}`);
                                or.sessionId = e.data.sessionId
                            }
                        }
                        this.roomName = e, this.xmppService = t, this.getNextTimeout = ur(1e3), this.getNextErrorTimeout = ur(1e3), this.externalAuthEnabled = !1, this.options = n, this.sipGatewayEnabled = !1, this.eventEmitter = i, this.connection = this.xmppService.connection, window.addEventListener ? window.addEventListener("message", s, !1) : window.attachEvent("onmessage", s)
                    }
                    pr.prototype.isExternalAuthEnabled = function() {
                        return this.externalAuthEnabled
                    }, pr.prototype.isSipGatewayEnabled = function() {
                        return this.sipGatewayEnabled
                    }, pr.prototype.onMucMemberLeft = function(e) {
                        "focus" === ut.Strophe.getResourceFromJid(e) && (hr.info("Focus has left the room - leaving conference"), this.eventEmitter.emit(dr.FOCUS_LEFT))
                    }, pr.prototype.setFocusUserJid = function(e) {
                        this.focusUserJid || (this.focusUserJid = e, hr.info(`Focus jid set to:  ${this.focusUserJid}`))
                    }, pr.prototype.getFocusUserJid = function() {
                        return this.focusUserJid
                    }, pr.prototype.getFocusComponent = function() {
                        let e = this.options.connection.hosts.focus;
                        return e || (e = `focus.${this.options.connection.hosts.domain}`), e
                    }, pr.prototype.createConferenceIq = function() {
                        var e, t, i;
                        const n = (0, ut.$iq)({
                                to: this.getFocusComponent(),
                                type: "set"
                            }),
                            {
                                sessionId: s
                            } = or,
                            r = or.machineId,
                            o = this.options.conference;
                        hr.info(`Session ID: ${s} machine UID: ${r}`), n.c("conference", {
                            xmlns: "http://jitsi.org/protocol/focus",
                            room: this.roomName,
                            "machine-uid": r
                        }), s && n.attrs({
                            "session-id": s
                        }), n.c("property", {
                            name: "disableRtx",
                            value: Boolean(o.disableRtx)
                        }).up(), void 0 !== o.audioPacketDelay && n.c("property", {
                            name: "audioPacketDelay",
                            value: o.audioPacketDelay
                        }).up(), o.startBitrate && n.c("property", {
                            name: "startBitrate",
                            value: o.startBitrate
                        }).up(), o.minBitrate && n.c("property", {
                            name: "minBitrate",
                            value: o.minBitrate
                        }).up(), void 0 !== this.options.conference.startAudioMuted && n.c("property", {
                            name: "startAudioMuted",
                            value: this.options.conference.startAudioMuted
                        }).up(), void 0 !== this.options.conference.startVideoMuted && n.c("property", {
                            name: "startVideoMuted",
                            value: this.options.conference.startVideoMuted
                        }).up();
                        const a = null !== (e = null === (t = this.options.conference) || void 0 === t || null === (i = t.analytics) || void 0 === i ? void 0 : i.rtcstatsEnabled) && void 0 !== e && e;
                        a || n.c("property", {
                            name: "rtcstatsEnabled",
                            value: a
                        }).up();
                        const {
                            callStatsID: c,
                            callStatsSecret: d,
                            disableThirdPartyRequests: l,
                            enableCallStats: h
                        } = this.options.conference, u = !c || !d || !h || !0 === l;
                        return u && n.c("property", {
                            name: "callstatsEnabled",
                            value: !u
                        }).up(), n.up(), n
                    }, pr.prototype.parseSessionId = function(e) {
                        const t = $(e).find("conference").attr("session-id");
                        t && (hr.info(`Received sessionId:  ${t}`), or.sessionId = t)
                    }, pr.prototype.parseConfigOptions = function(e) {
                        this.setFocusUserJid($(e).find("conference").attr("focusjid"));
                        const t = $(e).find(">conference>property[name='authentication'][value='true']").length > 0;
                        hr.info(`Authentication enabled: ${t}`), this.externalAuthEnabled = $(e).find(">conference>property[name='externalAuth'][value='true']").length > 0, hr.info(`External authentication enabled: ${this.externalAuthEnabled}`), this.externalAuthEnabled || this.parseSessionId(e);
                        const i = $(e).find(">conference").attr("identity");
                        this.eventEmitter.emit(cr.IDENTITY_UPDATED, t, i), $(e).find(">conference>property[name='sipGatewayEnabled'][value='true']").length && (this.sipGatewayEnabled = !0), hr.info(`Sip gateway enabled:  ${this.sipGatewayEnabled}`)
                    }, pr.prototype.allocateConferenceFocus = function() {
                        return new Promise((e => {
                            this.setFocusUserJid(this.options.connection.focusUserJid), this.connection.sendIQ(this.createConferenceIq(), (t => this._allocateConferenceFocusSuccess(t, e)), (t => this._allocateConferenceFocusError(t, e))), this.connection.flush()
                        }))
                    }, pr.prototype._allocateConferenceFocusError = function(e, t) {
                        const i = $(e).find(">error>session-invalid").length || $(e).find(">error>not-acceptable").length;
                        if (i && (hr.info("Session expired! - removing"), or.sessionId = void 0), $(e).find(">error>graceful-shutdown").length) return void this.eventEmitter.emit(dr.GRACEFUL_SHUTDOWN);
                        const n = $(e).find(">error>reservation-error");
                        if (n.length) {
                            const t = n.attr("error-code"),
                                i = $(e).find(">error>text");
                            let s;
                            return i && (s = i.text()), void this.eventEmitter.emit(dr.RESERVATION_ERROR, t, s)
                        }
                        if ($(e).find(">error>not-authorized").length) return hr.warn("Unauthorized to start the conference", e), ut.Strophe.getDomainFromJid(e.getAttribute("to")) !== this.options.connection.hosts.anonymousdomain && (this.externalAuthEnabled = !0), void this.eventEmitter.emit(dr.AUTHENTICATION_REQUIRED);
                        const s = this.getNextErrorTimeout(),
                            r = `Focus error, retry after ${s}`;
                        lr.callErrorHandler(new Error(r)), hr.error(r, e);
                        const o = this.getFocusComponent(),
                            a = s / 1e3;
                        i || this.eventEmitter.emit(dr.FOCUS_DISCONNECTED, o, a), this.getNextTimeout(!0), window.setTimeout((() => this.allocateConferenceFocus().then(t)), s)
                    }, pr.prototype._allocateConferenceFocusSuccess = function(e, t) {
                        if (this.parseConfigOptions(e), this.getNextErrorTimeout(!0), "true" === $(e).find("conference").attr("ready")) this.getNextTimeout(!0), t();
                        else {
                            const e = this.getNextTimeout();
                            hr.info(`Waiting for the focus... ${e}`), window.setTimeout((() => this.allocateConferenceFocus().then(t)), e)
                        }
                    }, pr.prototype.authenticate = function() {
                        return new Promise(((e, t) => {
                            this.connection.sendIQ(this.createConferenceIq(), (t => {
                                this.parseSessionId(t), e()
                            }), (e => t({
                                error: $(e).find("iq>error :first").prop("tagName"),
                                message: $(e).find("iq>error>text").text()
                            })))
                        }))
                    }, pr.prototype.getLoginUrl = function(e, t) {
                        this._getLoginUrl(!1, e, t)
                    }, pr.prototype._getLoginUrl = function(e, t, i) {
                        const n = (0, ut.$iq)({
                                to: this.getFocusComponent(),
                                type: "get"
                            }),
                            s = {
                                xmlns: "http://jitsi.org/protocol/focus",
                                room: this.roomName,
                                "machine-uid": or.machineId
                            };
                        let r = "auth url";

                        function o(e, t) {
                            lr.callErrorHandler(new Error(e)), hr.error(e, t), i(t)
                        }
                        e && (s.popup = !0, r = `POPUP ${r}`), n.c("login-url", s), this.connection.sendIQ(n, (e => {
                            let i = $(e).find("login-url").attr("url");
                            i = decodeURIComponent(i), i ? (hr.info(`Got ${r}: ${i}`), t(i)) : o(`Failed to get ${r} from the focus`, e)
                        }), o.bind(void 0, `Get ${r} error`))
                    }, pr.prototype.getPopupLoginUrl = function(e, t) {
                        this._getLoginUrl(!0, e, t)
                    }, pr.prototype.logout = function(e) {
                        const t = (0, ut.$iq)({
                                to: this.getFocusComponent(),
                                type: "set"
                            }),
                            {
                                sessionId: i
                            } = or;
                        i ? (t.c("logout", {
                            xmlns: "http://jitsi.org/protocol/focus",
                            "session-id": i
                        }), this.connection.sendIQ(t, (t => {
                            let i = $(t).find("logout").attr("logout-url");
                            i && (i = decodeURIComponent(i)), hr.info(`Log out OK, url: ${i}`, t), or.sessionId = void 0, e(i)
                        }), (e => {
                            const t = "Logout error";
                            lr.callErrorHandler(new Error(t)), hr.error(t, e)
                        }))) : e()
                    };
                    const mr = (0, v.getLogger)("modules/xmpp/ChatRoom.js"),
                        fr = {
                            packet2JSON(e, t) {
                                for (const i of Array.from(e.children)) {
                                    const e = {
                                        attributes: {},
                                        children: [],
                                        tagName: i.tagName
                                    };
                                    for (const t of Array.from(i.attributes)) e.attributes[t.name] = t.value;
                                    const n = ut.Strophe.getText(i);
                                    n && (e.value = ut.Strophe.xmlunescape(n)), t.push(e), this.packet2JSON(i, e.children)
                                }
                            },
                            json2packet(e, t) {
                                for (let i = 0; i < e.length; i++) {
                                    const n = e[i];
                                    n && (t.c(n.tagName, n.attributes), n.value && t.t(n.value), n.children && this.json2packet(n.children, t), t.up())
                                }
                            }
                        };

                    function gr(e, t) {
                        const i = [];
                        for (let n = 0; n < e.length; n++) e[n].tagName === t && i.push(e[n]);
                        return i
                    }
                    const _r = ["owner", "admin", "member"];
                    class Sr extends Wn {
                        constructor(e, t, i, n, s) {
                            super(), this.xmpp = n, this.connection = e, this.roomjid = ut.Strophe.getBareJidFromJid(t), this.myroomjid = t, this.password = i, this.replaceParticipant = !1, mr.info(`Joined MUC as ${this.myroomjid}`), this.members = {}, this.presMap = {}, this.presHandlers = {}, this._removeConnListeners = [], this.joined = !1, this.inProgressEmitted = !1, this.role = null, this.focusMucJid = null, this.noBridgeAvailable = !1, this.options = s || {}, this.moderator = new pr(this.roomjid, this.xmpp, this.eventEmitter, {
                                connection: this.xmpp.options,
                                conference: this.options
                            }), (void 0 === this.options.enableLobby || this.options.enableLobby) && (this.lobby = new er(this)), this.avModeration = new Gs(this), this.breakoutRooms = new Qs(this), this.initPresenceMap(s), this.lastPresences = {}, this.phoneNumber = null, this.phonePin = null, this.connectionTimes = {}, this.participantPropertyListener = null, this.locked = !1, this.transcriptionStatus = Bs
                        }
                        initPresenceMap() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            this.presMap.to = this.myroomjid, this.presMap.xns = "http://jabber.org/protocol/muc", this.presMap.nodes = [], e.statsId && this.presMap.nodes.push({
                                tagName: "stats-id",
                                value: e.statsId
                            }), this.presenceUpdateTime = Date.now()
                        }
                        join(e, t) {
                            return this.password = e, this.replaceParticipant = t, new Promise((e => {
                                this.options.disableFocus && mr.info(`Conference focus disabled for ${this.roomjid}`), (this.options.disableFocus ? Promise.resolve() : this.moderator.allocateConferenceFocus()).then((() => {
                                    this.sendPresence(!0), this._removeConnListeners.push(this.connection.addEventListener(js.Events.CONN_STATUS_CHANGED, this.onConnStatusChanged.bind(this))), e()
                                }))
                            }))
                        }
                        sendPresence(e) {
                            const t = this.presMap.to;
                            if (!this.connection || !this.connection.connected || !t || !this.joined && !e) return;
                            const i = (0, ut.$pres)({
                                to: t
                            });
                            e && (this.replaceParticipant && i.c("flip_device").up(), i.c("x", {
                                xmlns: this.presMap.xns
                            }), this.password && i.c("password").t(this.password).up(), this.options.billingId && i.c("billingid").t(this.options.billingId).up(), i.up()), fr.json2packet(this.presMap.nodes, i), this.presenceSyncTime = Date.now(), this.connection.send(i), e && this.connection.flush()
                        }
                        doLeave(e) {
                            mr.log("do leave", this.myroomjid);
                            const t = (0, ut.$pres)({
                                to: this.myroomjid,
                                type: "unavailable"
                            });
                            e && t.c("status").t(e).up(), this.presMap.length = 0, !this.connection.isUsingWebSocket && this.connection.flush(), this.connection.send(t), this.connection.flush()
                        }
                        discoRoomInfo() {
                            const e = (0, ut.$iq)({
                                type: "get",
                                to: this.roomjid
                            }).c("query", {
                                xmlns: ut.Strophe.NS.DISCO_INFO
                            });
                            this.connection.sendIQ(e, (e => {
                                const t = 1 === $(e).find('>query>feature[var="muc_passwordprotected"]').length;
                                t !== this.locked && (this.eventEmitter.emit(Nn.XMPPEvents.MUC_LOCK_CHANGED, t), this.locked = t);
                                const i = $(e).find('>query>x[type="result"]>field[var="muc#roominfo_meetingId"]>value');
                                i.length ? this.setMeetingId(i.text()) : mr.warn("No meeting ID from backend");
                                const n = 1 === $(e).find('>query>feature[var="muc_membersonly"]').length,
                                    s = $(e).find('>query>x[type="result"]>field[var="muc#roominfo_lobbyroom"]>value');
                                this.lobby && this.lobby.setLobbyRoomJid(s && s.length ? s.text() : void 0);
                                const r = $(e).find('>query>x[type="result"]>field[var="muc#roominfo_isbreakout"]>value'),
                                    o = Boolean(null == r ? void 0 : r.text());
                                this.breakoutRooms._setIsBreakoutRoom(o);
                                const a = $(e).find('>query>x[type="result"]>field[var="muc#roominfo_breakout_main_room"]>value');
                                null != a && a.length && this.breakoutRooms._setMainRoomJid(a.text()), n !== this.membersOnlyEnabled && (this.membersOnlyEnabled = n, this.eventEmitter.emit(Nn.XMPPEvents.MUC_MEMBERS_ONLY_CHANGED, n))
                            }), (e => {
                                Gi().callErrorHandler(e), mr.error("Error getting room info: ", e)
                            }))
                        }
                        setMeetingId(e) {
                            this.meetingId !== e && (this.meetingId && mr.warn(`Meeting Id changed from:${this.meetingId} to:${e}`), this.meetingId = e, this.eventEmitter.emit(Nn.XMPPEvents.MEETING_ID_SET, e))
                        }
                        createNonAnonymousRoom() {
                            if (this.options.disableDiscoInfo) return;
                            const e = (0, ut.$iq)({
                                type: "get",
                                to: this.roomjid
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#owner"
                            }).c("x", {
                                xmlns: "jabber:x:data",
                                type: "submit"
                            });
                            this.connection.sendIQ(e, (e => {
                                if (!$(e).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_whois"]').length) {
                                    const e = "non-anonymous rooms not supported";
                                    return Gi().callErrorHandler(new Error(e)), void mr.error(e)
                                }
                                const t = (0, ut.$iq)({
                                    to: this.roomjid,
                                    type: "set"
                                }).c("query", {
                                    xmlns: "http://jabber.org/protocol/muc#owner"
                                });
                                t.c("x", {
                                    xmlns: "jabber:x:data",
                                    type: "submit"
                                }), t.c("field", {
                                    var: "FORM_TYPE"
                                }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), t.c("field", {
                                    var: "muc#roomconfig_whois"
                                }).c("value").t("anyone").up().up(), this.connection.sendIQ(t)
                            }), (e => {
                                Gi().callErrorHandler(e), mr.error("Error getting room configuration form: ", e)
                            }))
                        }
                        onConnStatusChanged(e) {
                            e === js.Status.CONNECTED && this.sendPresence()
                        }
                        onPresence(e) {
                            const t = e.getAttribute("from"),
                                i = {},
                                n = e.getElementsByTagName("status")[0];
                            n && (i.status = n.textContent || "");
                            let s = !1,
                                r = !1;
                            const o = e.getElementsByTagNameNS("http://jabber.org/protocol/muc#user", "x")[0],
                                a = o && o.getElementsByTagName("item")[0];
                            i.isReplaceParticipant = e.getElementsByTagName("flip_device").length, i.affiliation = a && a.getAttribute("affiliation"), i.role = a && a.getAttribute("role");
                            const c = a && a.getAttribute("jid");
                            i.jid = c, i.isFocus = c && 0 === c.indexOf(`${this.moderator.getFocusUserJid()}/`), i.isHiddenDomain = c && c.indexOf("@") > 0 && this.options.hiddenDomain === c.substring(c.indexOf("@") + 1, c.indexOf("/")), this.eventEmitter.emit(Nn.XMPPEvents.PRESENCE_RECEIVED, {
                                fromHiddenDomain: i.isHiddenDomain,
                                presence: e
                            });
                            const d = e.querySelector("x");
                            d && d.remove();
                            const l = [];
                            fr.packet2JSON(e, l), this.lastPresences[t] = l;
                            const h = e => {
                                const t = {},
                                    i = e.children.find((e => "user" === e.tagName));
                                if (i) {
                                    t.user = {};
                                    const e = ["id", "name", "avatar"];
                                    this.options.hiddenFromRecorderFeatureEnabled && e.push("hidden-from-recorder");
                                    for (const n of e) {
                                        const e = i.children.find((e => e.tagName === n));
                                        e && (t.user[n] = e.value)
                                    }
                                }
                                const n = e.children.find((e => "group" === e.tagName));
                                return n && (t.group = n.value), t
                            };
                            for (let e = 0; e < l.length; e++) {
                                const t = l[e];
                                switch (t.tagName) {
                                    case "bot": {
                                        const {
                                            attributes: e
                                        } = t;
                                        if (!e) break;
                                        const {
                                            type: n
                                        } = e;
                                        i.botType = n;
                                        break
                                    }
                                    case "nick":
                                        i.nick = t.value;
                                        break;
                                    case "userId":
                                        i.id = t.value;
                                        break;
                                    case "stats-id":
                                        i.statsID = t.value;
                                        break;
                                    case "identity":
                                        i.identity = h(t);
                                        break;
                                    case "features":
                                        i.features = this._extractFeatures(t);
                                        break;
                                    case "stat": {
                                        const {
                                            attributes: e
                                        } = t;
                                        if (!e) break;
                                        const {
                                            name: n
                                        } = e;
                                        "version" === n && (i.version = e.value);
                                        break
                                    }
                                }
                            }
                            if (!this.joined && !this.inProgressEmitted) {
                                const e = this.connectionTimes["muc.join.started"] = window.performance.now();
                                mr.log("(TIME) MUC join started:\t", e), this.eventEmitter.emit(Nn.XMPPEvents.MUC_JOIN_IN_PROGRESS), this.inProgressEmitted = !0
                            }
                            if (t === this.myroomjid) {
                                const e = "owner" === i.affiliation ? i.role : "none";
                                if (this.role !== e && (this.role = e, this.eventEmitter.emit(Nn.XMPPEvents.LOCAL_ROLE_CHANGED, this.role)), !this.joined) {
                                    this.joined = !0;
                                    const e = this.connectionTimes["muc.joined"] = window.performance.now();
                                    mr.log("(TIME) MUC joined:\t", e), this.password && (this.locked = !0), this.presenceUpdateTime >= this.presenceSyncTime && this.sendPresence(), this.eventEmitter.emit(Nn.XMPPEvents.MUC_JOINED), !this.options.disableDiscoInfo && this.discoRoomInfo()
                                }
                            } else if (void 0 === c) mr.info("Ignoring member with undefined JID");
                            else if (void 0 === this.members[t]) this.members[t] = i, mr.log("entered", t, i), s = void 0 !== i.status, r = void 0 !== i.version, i.isFocus ? this._initFocus(t, i.features) : (this.eventEmitter.emit(Nn.XMPPEvents.MUC_MEMBER_JOINED, t, i.nick, i.role, i.isHiddenDomain, i.statsID, i.status, i.identity, i.botType, i.jid, i.features, i.isReplaceParticipant), s = !1);
                            else {
                                const e = this.members[t];
                                e.role !== i.role && (e.role = i.role, this.eventEmitter.emit(Nn.XMPPEvents.MUC_ROLE_CHANGED, t, i.role)), e.affiliation !== i.affiliation && (e.affiliation = i.affiliation), e.botType !== i.botType && (e.botType = i.botType, this.eventEmitter.emit(Nn.XMPPEvents.MUC_MEMBER_BOT_TYPE_CHANGED, t, i.botType)), i.isFocus && (e.isFocus = !0, this._initFocus(t, i.features)), i.displayName && (e.displayName = i.displayName), e.status !== i.status && (s = !0, e.status = i.status), e.version !== i.version && (r = !0, e.version = i.version), ht()(e.features, i.features) || (e.features = i.features, this.eventEmitter.emit(Nn.XMPPEvents.PARTICIPANT_FEATURES_CHANGED, t, i.features))
                            }
                            for (let e = 0; e < l.length; e++) {
                                const n = l[e];
                                switch (n.tagName) {
                                    case "nick":
                                        if (!i.isFocus) {
                                            const e = this.xmpp.options.displayJids ? ut.Strophe.getResourceFromJid(t) : i.nick;
                                            this.eventEmitter.emit(Nn.XMPPEvents.DISPLAY_NAME_CHANGED, t, e)
                                        }
                                        break;
                                    case "bridgeNotAvailable":
                                        i.isFocus && !this.noBridgeAvailable && (this.noBridgeAvailable = !0, this.eventEmitter.emit(Nn.XMPPEvents.BRIDGE_DOWN));
                                        break;
                                    case "conference-properties":
                                        if (i.isFocus) {
                                            const e = {};
                                            for (let t = 0; t < n.children.length; t++) {
                                                const {
                                                    attributes: i
                                                } = n.children[t];
                                                i && i.key && (e[i.key] = i.value)
                                            }
                                            this.eventEmitter.emit(Nn.XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, e), void 0 === this.restartByTerminateSupported && (this.restartByTerminateSupported = "true" === e["support-terminate-restart"], mr.info(`Jicofo supports restart by terminate: ${this.supportsRestartByTerminate()}`))
                                        }
                                        break;
                                    case "transcription-status": {
                                        const {
                                            attributes: e
                                        } = n;
                                        if (!e) break;
                                        const {
                                            status: t
                                        } = e;
                                        t && t !== this.transcriptionStatus && (this.transcriptionStatus = t, this.eventEmitter.emit(Nn.XMPPEvents.TRANSCRIPTION_STATUS_CHANGED, t));
                                        break
                                    }
                                    case "call-control": {
                                        const e = n.attributes;
                                        if (!e) break;
                                        this.phoneNumber = e.phone || null, this.phonePin = e.pin || null, this.eventEmitter.emit(Nn.XMPPEvents.PHONE_NUMBER_CHANGED);
                                        break
                                    }
                                    default:
                                        this.processNode(n, t)
                                }
                            }
                            s && this.eventEmitter.emit(Nn.XMPPEvents.PRESENCE_STATUS, t, i.status), r && mr.info(`Received version for ${c}: ${i.version}`)
                        }
                        _extractFeatures(e) {
                            const t = new Set;
                            for (let i = 0; i < e.children.length; i++) {
                                const {
                                    attributes: n
                                } = e.children[i];
                                n && n.var && t.add(n.var)
                            }
                            return t
                        }
                        _initFocus(e, t) {
                            this.focusMucJid = e, this.focusFeatures = t
                        }
                        setParticipantPropertyListener(e) {
                            this.participantPropertyListener = e
                        }
                        supportsRestartByTerminate() {
                            return this.restartByTerminateSupported
                        }
                        processNode(e, t) {
                            try {
                                let i = this.presHandlers[e.tagName];
                                e.tagName.startsWith("jitsi_participant_") && (i = [this.participantPropertyListener]), i && i.forEach((i => {
                                    i(e, ut.Strophe.getResourceFromJid(t), t)
                                }))
                            } catch (t) {
                                Gi().callErrorHandler(t), mr.error(`Error processing:${e.tagName} node.`, t)
                            }
                        }
                        sendMessage(e, t) {
                            const i = (0, ut.$msg)({
                                to: this.roomjid,
                                type: "groupchat"
                            });
                            "body" === t ? i.c(t, {}, e) : i.c(t, {
                                xmlns: "http://jitsi.org/jitmeet"
                            }, e), this.connection.send(i), this.eventEmitter.emit(Nn.XMPPEvents.SENDING_CHAT_MESSAGE, e)
                        }
                        sendPrivateMessage(e, t, i) {
                            const n = (0, ut.$msg)({
                                to: `${this.roomjid}/${e}`,
                                type: "chat"
                            });
                            "body" === i ? n.c(i, t).up() : n.c(i, {
                                xmlns: "http://jitsi.org/jitmeet"
                            }, t).up(), this.connection.send(n), this.eventEmitter.emit(Nn.XMPPEvents.SENDING_PRIVATE_CHAT_MESSAGE, t)
                        }
                        setSubject(e) {
                            const t = (0, ut.$msg)({
                                to: this.roomjid,
                                type: "groupchat"
                            });
                            t.c("subject", e), this.connection.send(t)
                        }
                        onParticipantLeft(e, t, i) {
                            delete this.lastPresences[e], t || (this.eventEmitter.emit(Nn.XMPPEvents.MUC_MEMBER_LEFT, e, i), this.moderator.onMucMemberLeft(e))
                        }
                        onPresenceUnavailable(e, t) {
                            if ($(e).find('>ignore[xmlns="http://jitsi.org/jitmeet/"]').length) return !0;
                            const i = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy');
                            if (i.length) {
                                let t;
                                const n = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy>reason');
                                return n.length && (t = n.text()), this.eventEmitter.emit(Nn.XMPPEvents.MUC_DESTROYED, t, i.attr("jid")), this.connection.emuc.doLeave(this.roomjid), !0
                            }
                            const n = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="110"]').length,
                                s = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="307"]').length,
                                r = Object.keys(this.members),
                                o = $(e).find("flip_device").length;
                            if (s) {
                                const i = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>actor');
                                let s, r;
                                i.length && (s = i.attr("nick"));
                                const a = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>reason');
                                a.length && (r = a.text()), this.eventEmitter.emit(Nn.XMPPEvents.KICKED, n, s, ut.Strophe.getResourceFromJid(t), r, o)
                            }
                            if (n) r.forEach((e => {
                                const t = this.members[e];
                                delete this.members[e], this.onParticipantLeft(e, t.isFocus)
                            })), this.connection.emuc.doLeave(this.roomjid), s || this.eventEmitter.emit(Nn.XMPPEvents.MUC_LEFT);
                            else {
                                const i = $(e).find(">status");
                                let n;
                                i.length && (n = i.text()), delete this.members[t], this.onParticipantLeft(t, !1, n)
                            }
                        }
                        onMessage(e, t) {
                            const i = e.getAttribute("type");
                            if ("error" === i) {
                                const t = $(e).find(">settings-error>text").text();
                                if (t.length) return this.eventEmitter.emit(Nn.XMPPEvents.SETTINGS_ERROR_RECEIVED, t), !0;
                                const i = $(e).find(">error>text").text();
                                return this.eventEmitter.emit(Nn.XMPPEvents.CHAT_ERROR_RECEIVED, i), !0
                            }
                            const n = $(e).find(">body").text(),
                                s = $(e).find(">subject");
                            if (s.length) {
                                const e = s.text();
                                (e || "" === e) && (this.eventEmitter.emit(Nn.XMPPEvents.SUBJECT_CHANGED, e), mr.log(`Subject is changed to ${e}`))
                            }
                            let r = $(e).find(">delay").attr("stamp");
                            if (!r && (r = $(e).find('>[xmlns="jabber:x:delay"]').attr("stamp"), r)) {
                                const e = r.match(/(\d{4})(\d{2})(\d{2}T\d{2}:\d{2}:\d{2})/);
                                r = `${e[1]}-${e[2]}-${e[3]}Z`
                            }
                            if (t === this.roomjid) {
                                let i;
                                if ($(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="104"]').length) this.discoRoomInfo();
                                else if ((i = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>invite')) && i.length) {
                                    const s = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>password');
                                    let r;
                                    s && s.length && (r = s.text()), this.eventEmitter.emit(Nn.XMPPEvents.INVITE_MESSAGE_RECEIVED, t, i.attr("from"), n, r)
                                }
                            }
                            const o = $(e).find(">json-message").text();
                            if (o) {
                                const e = this.xmpp.tryParseJSONAndVerify(o);
                                if (e && void 0 === r) return void this.eventEmitter.emit(Nn.XMPPEvents.JSON_MESSAGE_RECEIVED, t, e)
                            }
                            n && ("chat" === i ? this.eventEmitter.emit(Nn.XMPPEvents.PRIVATE_MESSAGE_RECEIVED, t, n, this.myroomjid, r) : "groupchat" === i && this.eventEmitter.emit(Nn.XMPPEvents.MESSAGE_RECEIVED, t, n, this.myroomjid, r))
                        }
                        onPresenceError(e, t) {
                            if ($(e).find('>error[type="auth"]>not-authorized[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) mr.log("on password required", t), this.eventEmitter.emit(Nn.XMPPEvents.PASSWORD_REQUIRED);
                            else if ($(e).find('>error[type="cancel"]>not-allowed[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) ut.Strophe.getDomainFromJid(e.getAttribute("to")) === this.xmpp.options.hosts.anonymousdomain ? this.eventEmitter.emit(Nn.XMPPEvents.ROOM_JOIN_ERROR) : (mr.warn("onPresError ", e), this.eventEmitter.emit(Nn.XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR));
                            else if ($(e).find(">error>service-unavailable").length) mr.warn("Maximum users limit for the room has been reached", e), this.eventEmitter.emit(Nn.XMPPEvents.ROOM_MAX_USERS_ERROR);
                            else if ($(e).find('>error[type="auth"]>registration-required[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
                                const t = $(e).find(">x>lobbyroom"); // BAO
                                let i;
								this.lobby.setLobbyRoomJid(t.text()); // BAO									
                                if (t.length) i = t.text();
                                else {
                                    const t = $(e).find(">lobbyroom");
                                    t.length && (i = t.text())
                                }
                                this.eventEmitter.emit(Nn.XMPPEvents.ROOM_CONNECT_MEMBERS_ONLY_ERROR, i)
                            } else mr.warn("onPresError ", e), this.eventEmitter.emit(Nn.XMPPEvents.ROOM_CONNECT_ERROR)
                        }
                        setAffiliation(e, t) {
                            const i = (0, ut.$iq)({
                                to: this.roomjid,
                                type: "set"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#admin"
                            }).c("item", {
                                affiliation: t,
                                jid: ut.Strophe.getBareJidFromJid(e)
                            }).c("reason").t(`Your affiliation has been changed to '${t}'.`).up().up().up();
                            this.connection.sendIQ(i, (i => mr.log("Set affiliation of participant with jid: ", e, "to", t, i)), (e => mr.log("Set affiliation of participant error: ", e)))
                        }
                        kick(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "You have been kicked.";
                            const i = (0, ut.$iq)({
                                to: this.roomjid,
                                type: "set"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#admin"
                            }).c("item", {
                                nick: ut.Strophe.getResourceFromJid(e),
                                role: "none"
                            }).c("reason").t(t).up().up().up();
                            this.connection.sendIQ(i, (t => mr.log("Kick participant with jid: ", e, t)), (e => mr.log("Kick participant error: ", e)))
                        }
                        lockRoom(e, t, i, n) {
                            this.connection.sendIQ((0, ut.$iq)({
                                to: this.roomjid,
                                type: "get"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#owner"
                            }), (s => {
                                if ($(s).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_roomsecret"]').length) {
                                    const n = (0, ut.$iq)({
                                        to: this.roomjid,
                                        type: "set"
                                    }).c("query", {
                                        xmlns: "http://jabber.org/protocol/muc#owner"
                                    });
                                    n.c("x", {
                                        xmlns: "jabber:x:data",
                                        type: "submit"
                                    }), n.c("field", {
                                        var: "FORM_TYPE"
                                    }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), n.c("field", {
                                        var: "muc#roomconfig_roomsecret"
                                    }).c("value").t(e).up().up(), n.c("field", {
                                        var: "muc#roomconfig_passwordprotectedroom"
                                    }).c("value").t(null === e || 0 === e.length ? "0" : "1").up().up(), this.membersOnlyEnabled && n.c("field", {
                                        var: "muc#roomconfig_membersonly"
                                    }).c("value").t("true").up().up(), n.c("field", {
                                        var: "muc#roomconfig_whois"
                                    }).c("value").t("anyone").up().up(), this.connection.sendIQ(n, (() => {
                                        this.password = e, t()
                                    }), i)
                                } else n()
                            }), i)
                        }
                        setMembersOnly(e, t, i) {
                            e && Object.values(this.members).filter((e => !e.isFocus)).length && Object.values(this.members).forEach((e => {
                                e.jid && !_r.includes(e.affiliation) && this.xmpp.connection.sendIQ((0, ut.$iq)({
                                    to: this.roomjid,
                                    type: "set"
                                }).c("query", {
                                    xmlns: "http://jabber.org/protocol/muc#admin"
                                }).c("item", {
                                    affiliation: "member",
                                    jid: ut.Strophe.getBareJidFromJid(e.jid)
                                }).up().up())
                            }));
                            const n = i || (() => {});
                            this.xmpp.connection.sendIQ((0, ut.$iq)({
                                to: this.roomjid,
                                type: "get"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#owner"
                            }), (i => {
                                if ($(i).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_membersonly"]').length) {
                                    const i = (0, ut.$iq)({
                                        to: this.roomjid,
                                        type: "set"
                                    }).c("query", {
                                        xmlns: "http://jabber.org/protocol/muc#owner"
                                    });
                                    i.c("x", {
                                        xmlns: "jabber:x:data",
                                        type: "submit"
                                    }), i.c("field", {
                                        var: "FORM_TYPE"
                                    }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), i.c("field", {
                                        var: "muc#roomconfig_membersonly"
                                    }).c("value").t(e ? "true" : "false").up().up(), this.locked && i.c("field", {
                                        var: "muc#roomconfig_passwordprotectedroom"
                                    }).c("value").t("1").up().up(), this.xmpp.connection.sendIQ(i, t, n)
                                } else n(new Error("Setting members only room not supported!"))
                            }), n)
                        }
                        addToPresence(e, t) {
                            return this.addOrReplaceInPresence(e, t)
                        }
                        addOrReplaceInPresence(e, t) {
                            t.tagName = e;
                            const i = this.presMap.nodes.filter((t => e === t.tagName));
                            return !(1 === i.length && ht()(i[0], t) || (this.removeFromPresence(e), this.presMap.nodes.push(t), this.presenceUpdateTime = Date.now(), 0))
                        }
                        getFromPresence(e) {
                            return this.presMap.nodes.find((t => e === t.tagName))
                        }
                        removeFromPresence(e) {
                            const t = this.presMap.nodes.filter((t => e !== t.tagName));
                            this.presMap.nodes = t, this.presenceUpdateTime = Date.now()
                        }
                        addPresenceListener(e, t) {
                            if ("function" != typeof t) throw new Error('"handler" is not a function');
                            let i = this.presHandlers[e];
                            i || (this.presHandlers[e] = i = []), -1 === i.indexOf(t) ? i.push(t) : mr.warn(`Trying to add the same handler more than once for: ${e}`)
                        }
                        removePresenceListener(e, t) {
                            const i = this.presHandlers[e],
                                n = i ? i.indexOf(t) : -1; - 1 !== n ? i.splice(n, 1) : mr.warn(`Handler for: ${e} was not registered`)
                        }
                        isFocus(e) {
                            const t = this.members[e];
                            return t ? t.isFocus : null
                        }
                        isModerator() {
                            return "moderator" === this.role
                        }
                        getMemberRole(e) {
                            return this.members[e] ? this.members[e].role : null
                        }
                        addAudioInfoToPresence(e) {
                            const t = "audiomuted";
                            return !(e && !this.getFromPresence(t)) && this.addOrReplaceInPresence(t, {
                                value: e.toString()
                            })
                        }
                        addVideoInfoToPresence(e) {
                            const t = "videomuted";
                            return !(e && !this.getFromPresence(t)) && this.addOrReplaceInPresence(t, {
                                value: e.toString()
                            })
                        }
                        getMediaPresenceInfo(e, t) {
                            const i = this.lastPresences[`${this.roomjid}/${e}`];
                            if (!i) return null;
                            const n = {
                                muted: !0,
                                videoType: t === dn.VIDEO ? An.VideoType.CAMERA : void 0
                            };
                            let s = null;
                            if (t === dn.AUDIO) s = gr(i, "audiomuted");
                            else {
                                if (t !== dn.VIDEO) return mr.error(`Unsupported media type: ${t}`), null; {
                                    s = gr(i, "videomuted");
                                    const e = gr(i, "jitsi_participant_codecType"),
                                        t = gr(i, "videoType");
                                    t.length > 0 && (n.videoType = t[0].value), e.length > 0 && (n.codecType = e[0].value)
                                }
                            }
                            return s.length > 0 && (n.muted = "true" === s[0].value), n
                        }
                        getLastPresence(e) {
                            return this.lastPresences[`${this.roomjid}/${e}`]
                        }
                        isSIPCallingSupported() {
                            return !!this.moderator && this.moderator.isSipGatewayEnabled()
                        }
                        dial(e) {
                            return this.connection.rayo.dial(e, "fromnumber", ut.Strophe.getBareJidFromJid(this.myroomjid), this.password, this.focusMucJid)
                        }
                        hangup() {
                            return this.connection.rayo.hangup()
                        }
                        getLobby() {
                            return this.lobby
                        }
                        getAVModeration() {
                            return this.avModeration
                        }
                        getBreakoutRooms() {
                            return this.breakoutRooms
                        }
                        getPhoneNumber() {
                            return this.phoneNumber
                        }
                        getPhonePin() {
                            return this.phonePin
                        }
                        getMeetingId() {
                            return this.meetingId
                        }
                        muteParticipant(e, t, i) {
                            mr.info("set mute", t, e);
                            const n = (0, ut.$iq)({
                                to: this.focusMucJid,
                                type: "set"
                            }).c("mute", {
                                xmlns: `http://jitsi.org/jitmeet/${i}`,
                                jid: e
                            }).t(t.toString()).up();
                            this.connection.sendIQ(n, (e => mr.log("set mute", e)), (e => mr.log("set mute error", e)))
                        }
                        onMute(e) {
                            if (e.getAttribute("from") !== this.focusMucJid) return void mr.warn("Ignored mute from non focus peer");
                            const t = $(e).find("mute");
                            t.length && "true" === t.text() ? this.eventEmitter.emit(Nn.XMPPEvents.AUDIO_MUTED_BY_FOCUS, t.attr("actor")) : mr.warn("Ignoring a mute request which does not explicitly specify a positive mute command.")
                        }
                        onMuteVideo(e) {
                            if (e.getAttribute("from") !== this.focusMucJid) return void mr.warn("Ignored mute from non focus peer");
                            const t = $(e).find("mute");
                            t.length && "true" === t.text() ? this.eventEmitter.emit(Nn.XMPPEvents.VIDEO_MUTED_BY_FOCUS, t.attr("actor")) : mr.warn("Ignoring a mute request which does not explicitly specify a positive mute command.")
                        }
                        clean() {
                            this._removeConnListeners.forEach((e => e())), this._removeConnListeners = [], this.joined = !1, this.inProgressEmitted = !1
                        }
                        leave(e) {
                            var t, i = this;
                            this.avModeration.dispose(), this.breakoutRooms.dispose();
                            const n = [];
                            return (null === (t = this.lobby) || void 0 === t ? void 0 : t.lobbyRoom) && n.push(this.lobby.leave()), n.push(new Promise(((t, n) => {
                                let s = -1;
                                const r = function() {
                                    let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                                    i.eventEmitter.removeListener(Nn.XMPPEvents.MUC_LEFT, r), clearTimeout(s), e ? (i.connection.emuc.doLeave(i.roomjid), n(new Error("The timeout for the confirmation about leaving the room expired."))) : t()
                                };
                                s = setTimeout((() => r(!0)), 5e3), this.clean(), this.eventEmitter.on(Nn.XMPPEvents.MUC_LEFT, r), this.doLeave(e)
                            }))), Promise.allSettled(n)
                        }
                    }
                    const vr = (0, v.getLogger)("modules/xmpp/strophe.emuc.js");
                    class Er extends xs {
                        constructor(e) {
                            super(), this.xmpp = e, this.rooms = {}
                        }
                        init(e) {
                            super.init(e), this.connection.addHandler(this.onPresence.bind(this), null, "presence", null, null, null, null), this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, "presence", "unavailable", null), this.connection.addHandler(this.onPresenceError.bind(this), null, "presence", "error", null), this.connection.addHandler(this.onMessage.bind(this), null, "message", null, null), this.connection.addHandler(this.onMute.bind(this), "http://jitsi.org/jitmeet/audio", "iq", "set", null, null), this.connection.addHandler(this.onMuteVideo.bind(this), "http://jitsi.org/jitmeet/video", "iq", "set", null, null)
                        }
                        createRoom(e, t, i) {
                            const n = ut.Strophe.getBareJidFromJid(e);
                            if (this.isRoomCreated(n)) {
                                const e = "You are already in the room!";
                                throw vr.error(e), new Error(e)
                            }
                            return this.rooms[n] = new Sr(this.connection, e, t, this.xmpp, i), this.eventEmitter.emit(Nn.XMPPEvents.EMUC_ROOM_ADDED, this.rooms[n]), this.rooms[n]
                        }
                        isRoomCreated(e) {
                            return e in this.rooms
                        }
                        doLeave(e) {
                            this.eventEmitter.emit(Nn.XMPPEvents.EMUC_ROOM_REMOVED, this.rooms[e]), delete this.rooms[e]
                        }
                        onPresence(e) {
                            const t = e.getAttribute("from");
                            if (e.getAttribute("type")) return !0;
                            const i = this.rooms[ut.Strophe.getBareJidFromJid(t)];
                            return !i || ($(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="201"]').length && i.createNonAnonymousRoom(), i.onPresence(e), !0)
                        }
                        onPresenceUnavailable(e) {
                            const t = e.getAttribute("from"),
                                i = this.rooms[ut.Strophe.getBareJidFromJid(t)];
                            return !i || (i.onPresenceUnavailable(e, t), !0)
                        }
                        onPresenceError(e) {
                            const t = e.getAttribute("from"),
                                i = this.rooms[ut.Strophe.getBareJidFromJid(t)];
                            return !i || (i.onPresenceError(e, t), !0)
                        }
                        onMessage(e) {
                            const t = e.getAttribute("from"),
                                i = this.rooms[ut.Strophe.getBareJidFromJid(t)];
                            return !i || (i.onMessage(e, t), !0)
                        }
                        onMute(e) {
                            const t = e.getAttribute("from"),
                                i = this.rooms[ut.Strophe.getBareJidFromJid(t)];
                            return !i || (i.onMute(e), !0)
                        }
                        onMuteVideo(e) {
                            const t = e.getAttribute("from"),
                                i = this.rooms[ut.Strophe.getBareJidFromJid(t)];
                            return !i || (i.onMuteVideo(e), !0)
                        }
                    }
                    const yr = (0, v.getLogger)("modules/xmpp/JingleHelperFunctions.js");

                    function Tr(e, t) {
                        const i = (0, ut.$build)("source", {
                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                            ssrc: t.s,
                            name: hn.isSourceNameSignalingEnabled() ? t.n : void 0
                        });
                        return t.m && i.c("parameter", {
                            name: "msid",
                            value: t.m
                        }).up(), i.c("ssrc-info", {
                            xmlns: "http://jitsi.org/jitmeet",
                            owner: e
                        }).up(), i.node
                    }

                    function Cr(e) {
                        const t = (0, ut.$build)("ssrc-group", {
                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                            semantics: (i = e[0], "f" === i ? "FID" : "s" === i ? "SIM" : null)
                        });
                        var i;
                        for (let i = 1; i < e.length; i++) t.c("source", {
                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                            ssrc: e[i]
                        }).up();
                        return t.node
                    }

                    function br(e, t) {
                        const i = $(e).find("jingle")[0];
                        let n, s = $(i).find(`content[name="${t}"]`);
                        return s.length ? s = s[0] : (s = (0, ut.$build)("content", {
                            name: t
                        }).node, i.appendChild(s)), n = $(s).find("description"), n.length ? n = n[0] : (n = (0, ut.$build)("description", {
                            xmlns: "urn:xmpp:jingle:apps:rtp:1",
                            media: t
                        }).node, s.appendChild(n)), n
                    }

                    function Rr(e, t) {
                        var i;
                        let n;
                        try {
                            n = JSON.parse(t.textContent)
                        } catch (e) {
                            return yr.error(`json-message XML contained invalid JSON, ignoring: ${t.textContent}`), null
                        }
                        if (null === (i = n) || void 0 === i || !i.sources) return null;
                        const s = br(e, dn.AUDIO),
                            r = br(e, dn.VIDEO),
                            o = new Map;
                        for (const e in n.sources)
                            if (n.sources.hasOwnProperty(e)) {
                                const t = [],
                                    i = n.sources[e],
                                    d = (null == i ? void 0 : i.length) && i[0],
                                    l = (null == i ? void 0 : i.length) > 1 && i[1],
                                    h = (null == i ? void 0 : i.length) > 2 && i[2],
                                    u = (null == i ? void 0 : i.length) > 3 && i[3];
                                if (null != d && d.length)
                                    for (let i = 0; i < d.length; i++) {
                                        var a;
                                        r.appendChild(Tr(e, d[i])), t.push(null === (a = d[i]) || void 0 === a ? void 0 : a.s)
                                    }
                                if (null != l && l.length)
                                    for (let e = 0; e < l.length; e++) r.appendChild(Cr(l[e]));
                                if (null != h && h.length)
                                    for (let i = 0; i < h.length; i++) {
                                        var c;
                                        s.appendChild(Tr(e, h[i])), t.push(null === (c = h[i]) || void 0 === c ? void 0 : c.s)
                                    }
                                if (null != u && u.length)
                                    for (let e = 0; e < u.length; e++) s.appendChild(Cr(u[e]));
                                o.set(e, t)
                            } return o
                    }
                    var Ar = i(4391),
                        Pr = i.n(Ar);
                    let Ir;
                    ! function(e) {
                        e.INACTIVE = "inactive", e.RECVONLY = "recvonly", e.SENDONLY = "sendonly", e.SENDRECV = "sendrecv"
                    }(Ir || (Ir = {}));
                    const Nr = i(5810).getLogger("modules/RTC/ScreenObtainer.js"),
                        Dr = {
                            obtainStream: null,
                            init() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                this.options = e, this.obtainStream = this._createObtainStreamMethod(), this.obtainStream || Nr.info("Desktop sharing disabled")
                            },
                            _createObtainStreamMethod() {
                                return Ui.isNWJS() ? (e, t) => {
                                    window.JitsiMeetNW.obtainDesktopStream(e, ((e, i) => {
                                        let n;
                                        n = e && "InvalidStateError" === e.name ? new Nt(Tt) : new Nt(e, i, ["desktop"]), "function" == typeof t && t(n)
                                    }))
                                } : Ui.isElectron() ? this.obtainScreenOnElectron : Ui.isReactNative() && Ui.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMediaRN : Ui.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMedia : (Nr.log("Screen sharing not supported on ", Ui.getName()), null)
                            },
                            _getAudioConstraints() {
                                const {
                                    audioQuality: e
                                } = this.options;
                                return null == e || !e.stereo || {
                                    autoGainControl: !1,
                                    channelCount: 2,
                                    echoCancellation: !1,
                                    noiseSuppression: !1
                                }
                            },
                            isSupported() {
                                return null !== this.obtainStream
                            },
                            obtainScreenOnElectron(e, t) {
                                var i = this;
                                if (window.JitsiMeetScreenObtainer && window.JitsiMeetScreenObtainer.openDesktopPicker) {
                                    const {
                                        desktopSharingFrameRate: n,
                                        desktopSharingSources: s
                                    } = this.options;
                                    window.JitsiMeetScreenObtainer.openDesktopPicker({
                                        desktopSharingSources: s || ["screen", "window"]
                                    }, (function(s, r) {
                                        let o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                                        if (s) {
                                            var a, c;
                                            let d = !1;
                                            if (o) {
                                                d = {};
                                                const e = i._getAudioConstraints();
                                                "boolean" != typeof e && (d = {
                                                    optional: e
                                                }), "screen" === r && (d.mandatory = {
                                                    chromeMediaSource: "desktop"
                                                })
                                            }
                                            const l = {
                                                audio: d,
                                                video: {
                                                    mandatory: {
                                                        chromeMediaSource: "desktop",
                                                        chromeMediaSourceId: s,
                                                        minFrameRate: null !== (a = null == n ? void 0 : n.min) && void 0 !== a ? a : 5,
                                                        maxFrameRate: null !== (c = null == n ? void 0 : n.max) && void 0 !== c ? c : 5,
                                                        maxWidth: window.screen.width,
                                                        maxHeight: window.screen.height
                                                    }
                                                }
                                            };
                                            navigator.mediaDevices.getUserMedia(l).then((t => e({
                                                stream: t,
                                                sourceId: s,
                                                sourceType: r
                                            })), t)
                                        } else t(new Nt(Tt))
                                    }), (e => t(new Nt(gt, e))))
                                } else t(new Nt(_t))
                            },
                            obtainScreenFromGetDisplayMedia(e, t) {
                                var i, n;
                                let s;
                                s = navigator.getDisplayMedia ? navigator.getDisplayMedia.bind(navigator) : navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices);
                                const {
                                    desktopSharingFrameRate: r
                                } = this.options, o = Ui.isChromiumBased() && (null === (i = this.options) || void 0 === i || null === (n = i.testing) || void 0 === n ? void 0 : n.setScreenSharingResolutionConstraints);
                                let a = {};
                                "object" == typeof r && (a.frameRate = r), !o || (null == r ? void 0 : r.max) > 5 || (a.height = 99999, a.width = 99999);
                                const c = this._getAudioConstraints();
                                a.frameRate && delete a.frameRate.min, 0 === Object.keys(a).length && (a = !0);
                                const d = {
                                    video: a,
                                    audio: c,
                                    cursor: "always"
                                };
                                Nr.info("Using getDisplayMedia for screen sharing", d), s(d).then((t => {
                                    e({
                                        stream: t,
                                        sourceId: t.id
                                    })
                                })).catch((e => {
                                    const i = {
                                        errorName: e && e.name,
                                        errorMsg: e && e.message,
                                        errorStack: e && e.stack
                                    };
                                    Nr.error("getDisplayMedia error", d, i), i.errorMsg && -1 !== i.errorMsg.indexOf("denied by system") ? t(new Nt(Et)) : t(new Nt(Tt))
                                }))
                            },
                            obtainScreenFromGetDisplayMediaRN(e, t) {
                                Nr.info("Using getDisplayMedia for screen sharing"), navigator.mediaDevices.getDisplayMedia({
                                    video: !0
                                }).then((t => {
                                    e({
                                        stream: t,
                                        sourceId: t.id
                                    })
                                })).catch((() => {
                                    t(new Nt(Tt))
                                }))
                            },
                            setDesktopSharingFrameRate(e) {
                                Nr.info(`Setting the desktop capture rate to ${e}`), this.options.desktopSharingFrameRate = {
                                    min: 5,
                                    max: e
                                }
                            }
                        },
                        Mr = Dr;
                    var Or = i(2138),
                        wr = i.n(Or),
                        Lr = i(8310);
                    const kr = (0, v.getLogger)("modules/sdp/SDPUtil.js"),
                        xr = {
                            filterSpecialChars: e => e ? e.replace(/[\\\/\{,\}\+]/g, "") : e,
                            iceparams(e, t) {
                                let i, n, s = null;
                                return (n = xr.findLine(e, "a=ice-ufrag:", t)) && (i = xr.findLine(e, "a=ice-pwd:", t)) && (s = {
                                    ufrag: xr.parseICEUfrag(n),
                                    pwd: xr.parseICEPwd(i)
                                }), s
                            },
                            parseICEUfrag: e => e.substring(12),
                            buildICEUfrag: e => `a=ice-ufrag:${e}`,
                            parseICEPwd: e => e.substring(10),
                            buildICEPwd: e => `a=ice-pwd:${e}`,
                            parseMID: e => e.substring(6),
                            parseMSIDAttribute(e) {
                                const t = e.find((e => e.indexOf(" msid:") > 0));
                                if (!t) return;
                                const i = t.substring(t.indexOf(" msid:") + 6);
                                return xr.filterSpecialChars(i)
                            },
                            parseMLine(e) {
                                const t = {},
                                    i = e.substring(2).split(" ");
                                return t.media = i.shift(), t.port = i.shift(), t.proto = i.shift(), "" === i[i.length - 1] && i.pop(), t.fmt = i, t
                            },
                            buildMLine: e => `m=${e.media} ${e.port} ${e.proto} ${e.fmt.join(" ")}`,
                            parseRTPMap(e) {
                                const t = {};
                                let i = e.substring(9).split(" ");
                                return t.id = i.shift(), i = i[0].split("/"), t.name = i.shift(), t.clockrate = i.shift(), t.channels = i.length ? i.shift() : "1", t
                            },
                            parseSCTPMap(e) {
                                const t = e.substring(10).split(" ");
                                return [t[0], t[1], t.length > 2 ? t[2] : null]
                            },
                            parseSCTPPort: e => e.substring(12),
                            buildRTPMap(e) {
                                let t = `a=rtpmap:${e.getAttribute("id")} ${e.getAttribute("name")}/${e.getAttribute("clockrate")}`;
                                return e.getAttribute("channels") && "1" !== e.getAttribute("channels") && (t += `/${e.getAttribute("channels")}`), t
                            },
                            parseCrypto(e) {
                                const t = {},
                                    i = e.substring(9).split(" ");
                                return t.tag = i.shift(), t["crypto-suite"] = i.shift(), t["key-params"] = i.shift(), i.length && (t["session-params"] = i.join(" ")), t
                            },
                            parseFingerprint(e) {
                                const t = {},
                                    i = e.substring(14).split(" ");
                                return t.hash = i.shift(), t.fingerprint = i.shift(), t
                            },
                            parseFmtp(e) {
                                const t = [];
                                let i = e.split(" ");
                                i.shift(), i = i.join(" ").split(";");
                                for (let e = 0; e < i.length; e++) {
                                    let n = i[e].split("=")[0];
                                    for (; n.length && " " === n[0];) n = n.substring(1);
                                    const s = i[e].split("=")[1];
                                    n && s ? t.push({
                                        name: n,
                                        value: s
                                    }) : n && t.push({
                                        name: "",
                                        value: n
                                    })
                                }
                                return t
                            },
                            parseICECandidate(e) {
                                const t = {},
                                    i = e.split(" ");
                                t.foundation = i[0].substring(12), t.component = i[1], t.protocol = i[2].toLowerCase(), t.priority = i[3], t.ip = i[4], t.port = i[5], t.type = i[7], t.generation = 0;
                                for (let e = 8; e < i.length; e += 2) switch (i[e]) {
                                    case "raddr":
                                        t["rel-addr"] = i[e + 1];
                                        break;
                                    case "rport":
                                        t["rel-port"] = i[e + 1];
                                        break;
                                    case "generation":
                                        t.generation = i[e + 1];
                                        break;
                                    case "tcptype":
                                        t.tcptype = i[e + 1];
                                        break;
                                    default:
                                        kr.debug(`parseICECandidate not translating "${i[e]}" = "${i[e+1]}"`)
                                }
                                return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
                            },
                            buildICECandidate(e) {
                                let t = [`a=candidate:${e.foundation}`, e.component, e.protocol, e.priority, e.ip, e.port, "typ", e.type].join(" ");
                                switch (t += " ", e.type) {
                                    case "srflx":
                                    case "prflx":
                                    case "relay":
                                        e.hasOwnAttribute("rel-addr") && e.hasOwnAttribute("rel-port") && (t += "raddr", t += " ", t += e["rel-addr"], t += " ", t += "rport", t += " ", t += e["rel-port"], t += " ")
                                }
                                return e.hasOwnAttribute("tcptype") && (t += "tcptype", t += " ", t += e.tcptype, t += " "), t += "generation", t += " ", t += e.hasOwnAttribute("generation") ? e.generation : "0", t
                            },
                            parseSSRC(e) {
                                const t = new Map,
                                    i = e.split("\r\n");
                                for (let e = 0; e < i.length; e++)
                                    if ("a=ssrc:" === i[e].substring(0, 7)) {
                                        const n = i[e].split("a=ssrc:")[1].split(" ")[0];
                                        t.get(n) || t.set(n, []), t.get(n).push(i[e])
                                    } return t
                            },
                            parseSourceNameLine(e) {
                                const t = e.find((e => e.indexOf(" name:") > 0));
                                return null == t ? void 0 : t.substring(t.indexOf(" name:") + 6)
                            },
                            parseVideoTypeLine(e) {
                                const t = " videoType:",
                                    i = e.find((e => e.indexOf(t) > 0));
                                return null == i ? void 0 : i.substring(i.indexOf(t) + t.length)
                            },
                            parseRTCPFB(e) {
                                const t = e.substr(10).split(" "),
                                    i = {};
                                return i.pt = t.shift(), i.type = t.shift(), i.params = t, i
                            },
                            parseExtmap(e) {
                                const t = e.substr(9).split(" "),
                                    i = {};
                                return i.value = t.shift(), -1 === i.value.indexOf("/") ? i.direction = "both" : (i.direction = i.value.substr(i.value.indexOf("/") + 1), i.value = i.value.substr(0, i.value.indexOf("/"))), i.uri = t.shift(), i.params = t, i
                            },
                            findLine(e, t, i) {
                                let n = e.split("\r\n");
                                for (let e = 0; e < n.length; e++)
                                    if (n[e].substring(0, t.length) === t) return n[e];
                                if (!i) return !1;
                                n = i.split("\r\n");
                                for (let e = 0; e < n.length; e++)
                                    if (n[e].substring(0, t.length) === t) return n[e];
                                return !1
                            },
                            findLines(e, t, i) {
                                let n = e.split("\r\n");
                                const s = [];
                                for (let e = 0; e < n.length; e++) n[e].substring(0, t.length) === t && s.push(n[e]);
                                if (s.length || !i) return s;
                                n = i.split("\r\n");
                                for (let e = 0; e < n.length; e++) n[e].substring(0, t.length) === t && s.push(n[e]);
                                return s
                            },
                            candidateToJingle(e) {
                                if (0 === e.indexOf("candidate:")) e = `a=${e}`;
                                else if ("a=candidate:" !== e.substring(0, 12)) return kr.warn("parseCandidate called with a line that is not a candidate line"), kr.warn(e), null;
                                "\r\n" === e.substring(e.length - 2) && (e = e.substring(0, e.length - 2));
                                const t = {},
                                    i = e.split(" ");
                                if ("typ" !== i[6]) return kr.warn("did not find typ in the right place"), kr.warn(e), null;
                                t.foundation = i[0].substring(12), t.component = i[1], t.protocol = i[2].toLowerCase(), t.priority = i[3], t.ip = i[4], t.port = i[5], t.type = i[7], t.generation = "0";
                                for (let e = 8; e < i.length; e += 2) switch (i[e]) {
                                    case "raddr":
                                        t["rel-addr"] = i[e + 1];
                                        break;
                                    case "rport":
                                        t["rel-port"] = i[e + 1];
                                        break;
                                    case "generation":
                                        t.generation = i[e + 1];
                                        break;
                                    case "tcptype":
                                        t.tcptype = i[e + 1];
                                        break;
                                    default:
                                        kr.debug(`not translating "${i[e]}" = "${i[e+1]}"`)
                                }
                                return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
                            },
                            candidateFromJingle(e) {
                                let t = "a=candidate:";
                                t += e.getAttribute("foundation"), t += " ", t += e.getAttribute("component"), t += " ";
                                let i = e.getAttribute("protocol");
                                switch (Ui.isFirefox() && "ssltcp" === i.toLowerCase() && (i = "tcp"), t += i, t += " ", t += e.getAttribute("priority"), t += " ", t += e.getAttribute("ip"), t += " ", t += e.getAttribute("port"), t += " ", t += "typ", t += ` ${e.getAttribute("type")}`, t += " ", e.getAttribute("type")) {
                                    case "srflx":
                                    case "prflx":
                                    case "relay":
                                        e.getAttribute("rel-addr") && e.getAttribute("rel-port") && (t += "raddr", t += " ", t += e.getAttribute("rel-addr"), t += " ", t += "rport", t += " ", t += e.getAttribute("rel-port"), t += " ")
                                }
                                return "tcp" === i.toLowerCase() && (t += "tcptype", t += " ", t += e.getAttribute("tcptype"), t += " "), t += "generation", t += " ", t += e.getAttribute("generation") || "0", `${t}\r\n`
                            },
                            parsePrimaryVideoSsrc(e) {
                                const t = e.ssrcs.map((e => e.id)).filter(((e, t, i) => i.indexOf(e) === t)).length,
                                    i = e.ssrcGroups && e.ssrcGroups.length || 0;
                                if (t > 1 && 0 === i) return;
                                let n = null;
                                if (1 === t) n = e.ssrcs[0].id;
                                else if (2 === t) {
                                    const t = e.ssrcGroups.find((e => "FID" === e.semantics));
                                    t && (n = t.ssrcs.split(" ")[0])
                                } else if (t >= 3) {
                                    const t = e.ssrcGroups.find((e => "SIM" === e.semantics));
                                    t && (n = t.ssrcs.split(" ")[0])
                                }
                                return n
                            },
                            generateSsrc: () => Ts().randomInt(1, 4294967295),
                            getSsrcAttribute(e, t, i) {
                                for (let n = 0; n < e.ssrcs.length; ++n) {
                                    const s = e.ssrcs[n];
                                    if (s.id === t && s.attribute === i) return s.value
                                }
                            },
                            parseGroupSsrcs: e => e.ssrcs.split(" ").map((e => parseInt(e, 10))),
                            getMedia: (e, t) => e.media.find((e => e.type === t)),
                            getUfrag(e) {
                                const t = e.split("\n").filter((e => e.startsWith("a=ice-ufrag:")));
                                if (t.length > 0) return t[0].substr("a=ice-ufrag:".length)
                            },
                            preferCodec(e, t) {
                                if (!e || !t) return;
                                const i = e.rtp.filter((e => e.codec && e.codec.toLowerCase() === t.toLowerCase())).map((e => e.payload));
                                if (i) {
                                    const t = e.payloads.toString().split(" ").map((e => parseInt(e, 10)));
                                    for (const e of i.reverse()) {
                                        const i = t.indexOf(e);
                                        t.splice(i, 1), t.unshift(e)
                                    }
                                    e.payloads = t.join(" ")
                                }
                            },
                            stripCodec(e, t) {
                                let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                                if (!e || !t) return;
                                const n = [];
                                let s = [];
                                const r = t.toLowerCase() === Pr().H264 && i;
                                for (const i of e.rtp) i.codec && i.codec.toLowerCase() === t.toLowerCase() && (r ? n.push(i.payload) : s.push(i.payload));
                                if (r && (s = e.fmtp.filter((e => n.indexOf(e.payload) > -1 && e.config.includes("profile-level-id=64"))).map((e => e.payload))), s.length > 0) {
                                    const t = s.map((e => `apt=${e}`)),
                                        i = e.fmtp.filter((e => -1 !== t.indexOf(e.config)));
                                    s.push(...i.map((e => e.payload)));
                                    const n = e.payloads.toString().split(" ").map(Number).filter((e => -1 === s.indexOf(e)));
                                    0 === n.length ? (e.port = 0, e.direction = Ir.INACTIVE, e.payloads = "*") : e.payloads = n.join(" "), e.rtp = e.rtp.filter((e => -1 !== n.indexOf(e.payload))), e.fmtp = e.fmtp.filter((e => -1 !== n.indexOf(e.payload))), e.rtcpFb && (e.rtcpFb = e.rtcpFb.filter((e => -1 !== n.indexOf(e.payload))))
                                }
                            }
                        },
                        Fr = xr;

                    function Vr(e) {
                        const t = e.split("\r\nm=");
                        for (let e = 1, i = t.length; e < i; e++) {
                            let n = `m=${t[e]}`;
                            e !== i - 1 && (n += "\r\n"), t[e] = n
                        }
                        const i = `${t.shift()}\r\n`;
                        this.media = t, this.raw = i + t.join(""), this.session = i
                    }

                    function Ur(e, t) {
                        if (!t) return !1;
                        if (e.length !== t.length) return !1;
                        for (let i = 0, n = e.length; i < n; i++)
                            if (e[i] instanceof Array && t[i] instanceof Array) {
                                if (!e[i].equals(t[i])) return !1
                            } else if (e[i] !== t[i]) return !1;
                        return !0
                    }

                    function jr(e, t) {
                        if (this.mySDP = e, this.otherSDP = t, !e) throw new Error('"mySDP" is undefined!');
                        if (!t) throw new Error('"otherSDP" is undefined!')
                    }
                    Vr.prototype.failICE = !1, Vr.prototype.removeTcpCandidates = !1, Vr.prototype.removeUdpCandidates = !1, Vr.prototype.addMlineForNewLocalSource = function(e) {
                        const t = this.media.length,
                            i = Lr.parse(this.raw),
                            n = wr()(i.media.find((t => t.type === e)));
                        n.mid = t, n.direction = Ir.RECVONLY, n.msid = void 0, n.ssrcs = void 0, n.ssrcGroups = void 0, i.media = i.media.concat(n), i.groups.forEach((e => {
                            if ("BUNDLE" === e.type) {
                                const i = e.mids.split(" ");
                                i.push(t), e.mids = i.join(" ")
                            }
                        })), this.raw = Lr.write(i)
                    }, Vr.prototype.getMediaSsrcMap = function() {
                        const e = {};
                        for (let t = 0; t < this.media.length; t++) {
                            const i = {
                                mediaindex: t,
                                mid: Fr.parseMID(Fr.findLine(this.media[t], "a=mid:")),
                                ssrcs: {},
                                ssrcGroups: []
                            };
                            e[t] = i, Fr.findLines(this.media[t], "a=ssrc:").forEach((e => {
                                const t = e.substring(7).split(" ")[0];
                                i.ssrcs[t] || (i.ssrcs[t] = {
                                    ssrc: t,
                                    lines: []
                                }), i.ssrcs[t].lines.push(e)
                            })), Fr.findLines(this.media[t], "a=ssrc-group:").forEach((e => {
                                const t = e.indexOf(" "),
                                    n = e.substr(0, t).substr(13),
                                    s = e.substr(14 + n.length).split(" ");
                                s.length && i.ssrcGroups.push({
                                    semantics: n,
                                    ssrcs: s
                                })
                            }))
                        }
                        return e
                    }, Vr.prototype.containsSSRC = function(e) {
                        const t = this.getMediaSsrcMap();
                        let i = !1;
                        return Object.keys(t).forEach((n => {
                            i || t[n].ssrcs[e] && (i = !0)
                        })), i
                    }, Vr.prototype.toJingle = function(e, t) {
                        Fr.findLines(this.session, "a=group:").forEach((t => {
                            const i = t.split(" "),
                                n = i.shift().substr(8);
                            e.c("group", {
                                xmlns: "urn:xmpp:jingle:apps:grouping:0",
                                semantics: n
                            });
                            for (let t = 0; t < i.length; t++) e.c("content", {
                                name: i[t]
                            }).up();
                            e.up()
                        }));
                        for (let i = 0; i < this.media.length; i++) {
                            const n = Fr.parseMLine(this.media[i].split("\r\n")[0]);
                            if ("audio" !== n.media && "video" !== n.media && "application" !== n.media) continue;
                            let s;
                            const r = Fr.findLine(this.media[i], "a=ssrc:");
                            s = !!r && r.substring(7).split(" ")[0], e.c("content", {
                                creator: t,
                                name: n.media
                            });
                            const o = Fr.findLine(this.media[i], "a=mid:");
                            if (o) {
                                const t = Fr.parseMID(o);
                                e.attrs({
                                    name: t
                                })
                            }
                            if ("audio" === n.media || "video" === n.media) {
                                e.c("description", {
                                    xmlns: "urn:xmpp:jingle:apps:rtp:1",
                                    media: n.media
                                }), s && e.attrs({
                                    ssrc: s
                                });
                                for (let t = 0; t < n.fmt.length; t++) {
                                    const s = Fr.findLine(this.media[i], `a=rtpmap:${n.fmt[t]}`);
                                    e.c("payload-type", Fr.parseRTPMap(s));
                                    const r = Fr.findLine(this.media[i], `a=fmtp:${n.fmt[t]}`);
                                    if (r) {
                                        const t = Fr.parseFmtp(r);
                                        for (let i = 0; i < t.length; i++) e.c("parameter", t[i]).up()
                                    }
                                    this.rtcpFbToJingle(i, e, n.fmt[t]), e.up()
                                }
                                if (s) {
                                    const t = Fr.parseSSRC(this.media[i]);
                                    for (const [i, n] of t) {
                                        const t = Fr.parseSourceNameLine(n),
                                            s = Fr.parseVideoTypeLine(n);
                                        e.c("source", {
                                            ssrc: i,
                                            name: hn.isSourceNameSignalingEnabled() ? t : void 0,
                                            videoType: s,
                                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                        });
                                        const r = Fr.parseMSIDAttribute(n);
                                        r && (e.c("parameter"), e.attrs({
                                            name: "msid"
                                        }), e.attrs({
                                            value: r
                                        }), e.up()), e.up()
                                    }
                                    Fr.findLines(this.media[i], "a=ssrc-group:").forEach((t => {
                                        const i = t.indexOf(" "),
                                            n = t.substr(0, i).substr(13),
                                            s = t.substr(14 + n.length).split(" ");
                                        s.length && (e.c("ssrc-group", {
                                            semantics: n,
                                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                        }), s.forEach((t => e.c("source", {
                                            ssrc: t
                                        }).up())), e.up())
                                    }))
                                }
                                const t = Fr.findLines(this.media[i], "a=rid:");
                                if (t.length && Ui.usesRidsForSimulcast()) {
                                    const n = t.map((e => e.split(":")[1])).map((e => e.split(" ")[0]));
                                    n.forEach((t => {
                                        e.c("source", {
                                            rid: t,
                                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                        }), e.up()
                                    })), Fr.findLine(this.media[i], "a=simulcast:") && (e.c("rid-group", {
                                        semantics: "SIM",
                                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                    }), n.forEach((t => {
                                        e.c("source", {
                                            rid: t
                                        }).up()
                                    })), e.up())
                                }
                                Fr.findLine(this.media[i], "a=rtcp-mux") && e.c("rtcp-mux").up(), this.rtcpFbToJingle(i, e, "*");
                                const r = Fr.findLines(this.media[i], "a=extmap:");
                                for (let t = 0; t < r.length; t++) {
                                    const i = Fr.parseExtmap(r[t]);
                                    if (e.c("rtp-hdrext", {
                                            xmlns: "urn:xmpp:jingle:apps:rtp:rtp-hdrext:0",
                                            uri: i.uri,
                                            id: i.value
                                        }), i.hasOwnProperty("direction")) switch (i.direction) {
                                        case Ir.SENDONLY:
                                            e.attrs({
                                                senders: "responder"
                                            });
                                            break;
                                        case Ir.RECVONLY:
                                            e.attrs({
                                                senders: "initiator"
                                            });
                                            break;
                                        case Ir.SENDRECV:
                                            e.attrs({
                                                senders: "both"
                                            });
                                            break;
                                        case Ir.INACTIVE:
                                            e.attrs({
                                                senders: "none"
                                            })
                                    }
                                    e.up()
                                }
                                e.up()
                            }
                            this.transportToJingle(i, e);
                            const a = this.media[i];
                            Fr.findLine(a, `a=${Ir.SENDRECV}`, this.session) ? e.attrs({
                                senders: "both"
                            }) : Fr.findLine(a, `a=${Ir.SENDONLY}`, this.session) ? e.attrs({
                                senders: "initiator"
                            }) : Fr.findLine(a, `a=${Ir.RECVONLY}`, this.session) ? e.attrs({
                                senders: "responder"
                            }) : Fr.findLine(a, `a=${Ir.INACTIVE}`, this.session) && e.attrs({
                                senders: "none"
                            }), "0" !== n.port || Fr.findLine(a, "a=bundle-only", this.session) || e.attrs({
                                senders: "rejected"
                            }), e.up()
                        }
                        return e.up(), e
                    }, Vr.prototype.transportToJingle = function(e, t) {
                        t.c("transport");
                        const i = Fr.findLine(this.media[e], "a=sctp-port:", this.session),
                            n = Fr.findLine(this.media[e], "a=sctpmap:", this.session);
                        if (i) {
                            const e = Fr.parseSCTPPort(i);
                            t.c("sctpmap", {
                                xmlns: "urn:xmpp:jingle:transports:dtls-sctp:1",
                                number: e,
                                protocol: "webrtc-datachannel"
                            }), t.attrs({
                                streams: 0
                            }), t.up()
                        } else if (n) {
                            const e = Fr.parseSCTPMap(n);
                            t.c("sctpmap", {
                                xmlns: "urn:xmpp:jingle:transports:dtls-sctp:1",
                                number: e[0],
                                protocol: e[1]
                            }), e.length > 2 ? t.attrs({
                                streams: e[2]
                            }) : t.attrs({
                                streams: 0
                            }), t.up()
                        }
                        Fr.findLines(this.media[e], "a=fingerprint:", this.session).forEach((i => {
                            const n = Fr.parseFingerprint(i);
                            n.xmlns = "urn:xmpp:jingle:apps:dtls:0", t.c("fingerprint").t(n.fingerprint), delete n.fingerprint;
                            const s = Fr.findLine(this.media[e], "a=setup:", this.session);
                            s && (n.setup = s.substr(8)), t.attrs(n), t.up()
                        }));
                        const s = Fr.iceparams(this.media[e], this.session);
                        s && (s.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.attrs(s), Fr.findLines(this.media[e], "a=candidate:", this.session).forEach((e => {
                            const i = Fr.candidateToJingle(e);
                            this.failICE && (i.ip = "1.1.1.1");
                            const n = i && "string" == typeof i.protocol ? i.protocol.toLowerCase() : "";
                            this.removeTcpCandidates && ("tcp" === n || "ssltcp" === n) || this.removeUdpCandidates && "udp" === n || t.c("candidate", i).up()
                        }))), t.up()
                    }, Vr.prototype.rtcpFbToJingle = function(e, t, i) {
                        Fr.findLines(this.media[e], `a=rtcp-fb:${i}`).forEach((e => {
                            const i = Fr.parseRTCPFB(e);
                            "trr-int" === i.type ? (t.c("rtcp-fb-trr-int", {
                                xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
                                value: i.params[0]
                            }), t.up()) : (t.c("rtcp-fb", {
                                xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
                                type: i.type
                            }), i.params.length > 0 && t.attrs({
                                subtype: i.params[0]
                            }), t.up())
                        }))
                    }, Vr.prototype.rtcpFbFromJingle = function(e, t) {
                        let i = "";
                        const n = e.find('>rtcp-fb-trr-int[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
                        return n.length && (i += "a=rtcp-fb:* trr-int ", n.attr("value") ? i += n.attr("value") : i += "0", i += "\r\n"), e.find('>rtcp-fb[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]').each(((e, n) => {
                            i += `a=rtcp-fb:${t} ${n.getAttribute("type")}`, n.hasAttribute("subtype") && (i += ` ${n.getAttribute("subtype")}`), i += "\r\n"
                        })), i
                    }, Vr.prototype.fromJingle = function(e) {
                        const t = Date.now();
                        this.raw = `v=0\r\no=- ${t} 2 IN IP4 0.0.0.0\r\ns=-\r\nt=0 0\r\n`;
                        const i = $(e).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]');
                        i.length && i.each(((e, t) => {
                            const i = $(t).find(">content").map(((e, t) => t.getAttribute("name"))).get();
                            i.length > 0 && (this.raw += `a=group:${t.getAttribute("semantics")||t.getAttribute("type")} ${i.join(" ")}\r\n`)
                        })), this.session = this.raw, e.find(">content").each(((e, t) => {
                            const i = this.jingle2media($(t));
                            this.media.push(i)
                        })), this.raw = this.session + this.media.join("")
                    }, Vr.prototype.jingle2media = function(e) {
                        const t = e.find(">description"),
                            i = e.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]');
                        let n = "";
                        const s = i.find('>sctpmap[xmlns="urn:xmpp:jingle:transports:dtls-sctp:1"]'),
                            r = {
                                media: t.attr("media"),
                                port: "9"
                            };
                        switch ("rejected" === e.attr("senders") && (r.port = "0"), i.find('>fingerprint[xmlns="urn:xmpp:jingle:apps:dtls:0"]').length ? r.proto = s.length ? "UDP/DTLS/SCTP" : "UDP/TLS/RTP/SAVPF" : r.proto = "UDP/TLS/RTP/SAVPF", s.length ? (n += `m=application ${r.port} UDP/DTLS/SCTP webrtc-datachannel\r\n`, n += `a=sctp-port:${s.attr("number")}\r\n`, n += "a=max-message-size:262144\r\n") : (r.fmt = t.find(">payload-type").map(((e, t) => t.getAttribute("id"))).get(), n += `${Fr.buildMLine(r)}\r\n`), n += "c=IN IP4 0.0.0.0\r\n", s.length || (n += "a=rtcp:1 IN IP4 0.0.0.0\r\n"), i.length && (i.attr("ufrag") && (n += `${Fr.buildICEUfrag(i.attr("ufrag"))}\r\n`), i.attr("pwd") && (n += `${Fr.buildICEPwd(i.attr("pwd"))}\r\n`), i.find('>fingerprint[xmlns="urn:xmpp:jingle:apps:dtls:0"]').each(((e, t) => {
                                n += `a=fingerprint:${t.getAttribute("hash")}`, n += ` ${$(t).text()}`, n += "\r\n", t.hasAttribute("setup") && (n += `a=setup:${t.getAttribute("setup")}\r\n`)
                            }))), i.find(">candidate").each(((e, t) => {
                                let i = t.getAttribute("protocol");
                                i = "string" == typeof i ? i.toLowerCase() : "", this.removeTcpCandidates && ("tcp" === i || "ssltcp" === i) || this.removeUdpCandidates && "udp" === i || (this.failICE && t.setAttribute("ip", "1.1.1.1"), n += Fr.candidateFromJingle(t))
                            })), e.attr("senders")) {
                            case "initiator":
                                n += `a=${Ir.SENDONLY}\r\n`;
                                break;
                            case "responder":
                                n += `a=${Ir.RECVONLY}\r\n`;
                                break;
                            case "none":
                                n += `a=${Ir.INACTIVE}\r\n`;
                                break;
                            case "both":
                                n += `a=${Ir.SENDRECV}\r\n`
                        }
                        n += `a=mid:${e.attr("name")}\r\n`, t.find(">rtcp-mux").length && (n += "a=rtcp-mux\r\n"), t.find(">payload-type").each(((e, t) => {
                            n += `${Fr.buildRTPMap(t)}\r\n`, $(t).find(">parameter").length && (n += `a=fmtp:${t.getAttribute("id")} `, n += $(t).find(">parameter").map(((e, t) => {
                                const i = t.getAttribute("name");
                                return (i ? `${i}=` : "") + t.getAttribute("value")
                            })).get().join(";"), n += "\r\n"), n += this.rtcpFbFromJingle($(t), t.getAttribute("id"))
                        })), n += this.rtcpFbFromJingle(t, "*"), t.find('>rtp-hdrext[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]').each(((e, t) => {
                            n += `a=extmap:${t.getAttribute("id")} ${t.getAttribute("uri")}\r\n`
                        })), t.find('>ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(((e, t) => {
                            const i = t.getAttribute("semantics"),
                                s = $(t).find(">source").map(((e, t) => t.getAttribute("ssrc"))).get();
                            s.length && (n += `a=ssrc-group:${i} ${s.join(" ")}\r\n`)
                        }));
                        let o = "",
                            a = "";
                        return t.find('>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(((e, t) => {
                            const i = t.getAttribute("ssrc");
                            let n = !0,
                                s = "";
                            $(t).find(">parameter").each(((e, t) => {
                                var r;
                                const o = t.getAttribute("name");
                                let a = t.getAttribute("value");
                                a = Fr.filterSpecialChars(a), s += `a=ssrc:${i} ${o}`, a && a.length && (s += `:${a}`), s += "\r\n", null !== (r = a) && void 0 !== r && r.includes("mixedmslabel") && (n = !1)
                            })), n ? o += s : a += s
                        })), n += a + o, n
                    }, jr.prototype.getNewMedia = function() {
                        const e = this.mySDP.getMediaSsrcMap(),
                            t = this.otherSDP.getMediaSsrcMap(),
                            i = {};
                        return Object.keys(t).forEach((n => {
                            const s = e[n],
                                r = t[n];
                            s || !r ? (Object.keys(r.ssrcs).forEach((e => {
                                (-1 === Object.keys(s.ssrcs).indexOf(e) || r.ssrcs[e].lines && s.ssrcs[e].lines && void 0 !== s.ssrcs[e].lines.find((e => -1 !== e.indexOf("msid"))) != (void 0 !== r.ssrcs[e].lines.find((e => -1 !== e.indexOf("msid"))))) && (i[n] || (i[n] = {
                                    mediaindex: r.mediaindex,
                                    mid: r.mid,
                                    ssrcs: {},
                                    ssrcGroups: []
                                }), i[n].ssrcs[e] = r.ssrcs[e])
                            })), r.ssrcGroups.forEach((e => {
                                let t = !1;
                                for (let i = 0; i < s.ssrcGroups.length; i++) {
                                    const n = s.ssrcGroups[i];
                                    if (e.semantics === n.semantics && Ur(e.ssrcs, n.ssrcs)) {
                                        t = !0;
                                        break
                                    }
                                }
                                t || (i[n] || (i[n] = {
                                    mediaindex: r.mediaindex,
                                    mid: r.mid,
                                    ssrcs: {},
                                    ssrcGroups: []
                                }), i[n].ssrcGroups.push(e))
                            }))) : i[n] = r
                        })), i
                    }, jr.prototype.toJingle = function(e) {
                        const t = this.getNewMedia();
                        let i = !1;
                        return Object.keys(t).forEach((n => {
                            i = !0;
                            const s = t[n];
                            e.c("content", {
                                name: s.mid
                            }), e.c("description", {
                                xmlns: "urn:xmpp:jingle:apps:rtp:1",
                                media: s.mid
                            }), Object.keys(s.ssrcs).forEach((t => {
                                const i = s.ssrcs[t],
                                    n = i.lines,
                                    r = Fr.parseSourceNameLine(n),
                                    o = Fr.parseVideoTypeLine(n);
                                e.c("source", {
                                    xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                }), e.attrs({
                                    name: hn.isSourceNameSignalingEnabled() ? r : void 0,
                                    videoType: o,
                                    ssrc: i.ssrc
                                });
                                const a = Fr.parseMSIDAttribute(n);
                                a && (e.c("parameter"), e.attrs({
                                    name: "msid"
                                }), e.attrs({
                                    value: a
                                }), e.up()), e.up()
                            })), s.ssrcGroups.forEach((t => {
                                t.ssrcs.length && (e.c("ssrc-group", {
                                    semantics: t.semantics,
                                    xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                }), t.ssrcs.forEach((t => {
                                    e.c("source", {
                                        ssrc: t
                                    }).up()
                                })), e.up())
                            })), e.up(), e.up()
                        })), i
                    };
                    var $r = "function" == typeof queueMicrotask && queueMicrotask,
                        Hr = "function" == typeof setImmediate && setImmediate,
                        Br = "object" == typeof process && "function" == typeof process.nextTick;

                    function Jr(e) {
                        setTimeout(e, 0)
                    }

                    function Gr(e) {
                        return (t, ...i) => e((() => t(...i)))
                    }
                    var Kr = Gr($r ? queueMicrotask : Hr ? setImmediate : Br ? process.nextTick : Jr);

                    function qr(e, t) {
                        return e.then((e => {
                            Wr(t, null, e)
                        }), (e => {
                            Wr(t, e && e.message ? e : new Error(e))
                        }))
                    }

                    function Wr(e, t, i) {
                        try {
                            e(t, i)
                        } catch (e) {
                            Kr((e => {
                                throw e
                            }), e)
                        }
                    }

                    function Xr(e) {
                        return "AsyncFunction" === e[Symbol.toStringTag]
                    }

                    function zr(e) {
                        if ("function" != typeof e) throw new Error("expected a function");
                        return Xr(e) ? Xr(t = e) ? function(...e) {
                            const i = e.pop();
                            return qr(t.apply(this, e), i)
                        } : (i = function(e, i) {
                            var n;
                            try {
                                n = t.apply(this, e)
                            } catch (e) {
                                return i(e)
                            }
                            if (n && "function" == typeof n.then) return qr(n, i);
                            i(null, n)
                        }, function(...e) {
                            var t = e.pop();
                            return i.call(this, e, t)
                        }) : e;
                        var t, i
                    }

                    function Qr(e, t = e.length) {
                        if (!t) throw new Error("arity is undefined");
                        return function(...i) {
                            return "function" == typeof i[t - 1] ? e.apply(this, i) : new Promise(((n, s) => {
                                i[t - 1] = (e, ...t) => {
                                    if (e) return s(e);
                                    n(t.length > 1 ? t : t[0])
                                }, e.apply(this, i)
                            }))
                        }
                    }

                    function Yr(e) {
                        return function(t, ...i) {
                            return Qr((function(n) {
                                var s = this;
                                return e(t, ((e, t) => {
                                    zr(e).apply(s, i.concat(t))
                                }), n)
                            }))
                        }
                    }

                    function Zr(e, t, i, n) {
                        t = t || [];
                        var s = [],
                            r = 0,
                            o = zr(i);
                        return e(t, ((e, t, i) => {
                            var n = r++;
                            o(e, ((e, t) => {
                                s[n] = t, i(e)
                            }))
                        }), (e => {
                            n(e, s)
                        }))
                    }

                    function eo(e) {
                        return e && "number" == typeof e.length && e.length >= 0 && e.length % 1 == 0
                    }
                    const to = {};

                    function io(e) {
                        function t(...t) {
                            if (null !== e) {
                                var i = e;
                                e = null, i.apply(this, t)
                            }
                        }
                        return Object.assign(t, e), t
                    }

                    function no(e) {
                        return function(...t) {
                            if (null === e) throw new Error("Callback was already called.");
                            var i = e;
                            e = null, i.apply(this, t)
                        }
                    }

                    function so(e, t, i, n) {
                        let s = !1,
                            r = !1,
                            o = !1,
                            a = 0,
                            c = 0;

                        function d() {
                            a >= t || o || s || (o = !0, e.next().then((({
                                value: e,
                                done: t
                            }) => {
                                if (!r && !s) {
                                    if (o = !1, t) return s = !0, void(a <= 0 && n(null));
                                    a++, i(e, c, l), c++, d()
                                }
                            })).catch(h))
                        }

                        function l(e, t) {
                            if (a -= 1, !r) return e ? h(e) : !1 === e ? (s = !0, void(r = !0)) : t === to || s && a <= 0 ? (s = !0, n(null)) : void d()
                        }

                        function h(e) {
                            r || (o = !1, s = !0, n(e))
                        }
                        d()
                    }
                    var ro = e => (t, i, n) => {
                            if (n = io(n), e <= 0) throw new RangeError("concurrency limit cannot be less than 1");
                            if (!t) return n(null);
                            if ("AsyncGenerator" === t[Symbol.toStringTag]) return so(t, e, i, n);
                            if (function(e) {
                                    return "function" == typeof e[Symbol.asyncIterator]
                                }(t)) return so(t[Symbol.asyncIterator](), e, i, n);
                            var s = function(e) {
                                    if (eo(e)) return function(e) {
                                        var t = -1,
                                            i = e.length;
                                        return function() {
                                            return ++t < i ? {
                                                value: e[t],
                                                key: t
                                            } : null
                                        }
                                    }(e);
                                    var t, i, n, s, r = function(e) {
                                        return e[Symbol.iterator] && e[Symbol.iterator]()
                                    }(e);
                                    return r ? function(e) {
                                        var t = -1;
                                        return function() {
                                            var i = e.next();
                                            return i.done ? null : (t++, {
                                                value: i.value,
                                                key: t
                                            })
                                        }
                                    }(r) : (i = (t = e) ? Object.keys(t) : [], n = -1, s = i.length, function e() {
                                        var r = i[++n];
                                        return "__proto__" === r ? e() : n < s ? {
                                            value: t[r],
                                            key: r
                                        } : null
                                    })
                                }(t),
                                r = !1,
                                o = !1,
                                a = 0,
                                c = !1;

                            function d(e, t) {
                                if (!o)
                                    if (a -= 1, e) r = !0, n(e);
                                    else if (!1 === e) r = !0, o = !0;
                                else {
                                    if (t === to || r && a <= 0) return r = !0, n(null);
                                    c || l()
                                }
                            }

                            function l() {
                                for (c = !0; a < e && !r;) {
                                    var t = s();
                                    if (null === t) return r = !0, void(a <= 0 && n(null));
                                    a += 1, i(t.value, t.key, no(d))
                                }
                                c = !1
                            }
                            l()
                        },
                        oo = Qr((function(e, t, i, n) {
                            return ro(t)(e, zr(i), n)
                        }), 4);

                    function ao(e, t, i) {
                        i = io(i);
                        var n = 0,
                            s = 0,
                            {
                                length: r
                            } = e,
                            o = !1;

                        function a(e, t) {
                            !1 === e && (o = !0), !0 !== o && (e ? i(e) : ++s !== r && t !== to || i(null))
                        }
                        for (0 === r && i(null); n < r; n++) t(e[n], n, no(a))
                    }

                    function co(e, t, i) {
                        return oo(e, 1 / 0, t, i)
                    }
                    var lo = Qr((function(e, t, i) {
                            return (eo(e) ? ao : co)(e, zr(t), i)
                        }), 3),
                        ho = Qr((function(e, t, i) {
                            return Zr(lo, e, t, i)
                        }), 3);
                    Yr(ho);
                    var uo = Qr((function(e, t, i) {
                        return oo(e, 1, t, i)
                    }), 3);
                    Yr(Qr((function(e, t, i) {
                        return Zr(uo, e, t, i)
                    }), 3)), Symbol("promiseCallback");
                    class po {
                        constructor() {
                            this.head = this.tail = null, this.length = 0
                        }
                        removeLink(e) {
                            return e.prev ? e.prev.next = e.next : this.head = e.next, e.next ? e.next.prev = e.prev : this.tail = e.prev, e.prev = e.next = null, this.length -= 1, e
                        }
                        empty() {
                            for (; this.head;) this.shift();
                            return this
                        }
                        insertAfter(e, t) {
                            t.prev = e, t.next = e.next, e.next ? e.next.prev = t : this.tail = t, e.next = t, this.length += 1
                        }
                        insertBefore(e, t) {
                            t.prev = e.prev, t.next = e, e.prev ? e.prev.next = t : this.head = t, e.prev = t, this.length += 1
                        }
                        unshift(e) {
                            this.head ? this.insertBefore(this.head, e) : mo(this, e)
                        }
                        push(e) {
                            this.tail ? this.insertAfter(this.tail, e) : mo(this, e)
                        }
                        shift() {
                            return this.head && this.removeLink(this.head)
                        }
                        pop() {
                            return this.tail && this.removeLink(this.tail)
                        }
                        toArray() {
                            return [...this]
                        }*[Symbol.iterator]() {
                            for (var e = this.head; e;) yield e.data, e = e.next
                        }
                        remove(e) {
                            for (var t = this.head; t;) {
                                var {
                                    next: i
                                } = t;
                                e(t) && this.removeLink(t), t = i
                            }
                            return this
                        }
                    }

                    function mo(e, t) {
                        e.length = 1, e.head = e.tail = t
                    }

                    function fo(e, t, i) {
                        if (null == t) t = 1;
                        else if (0 === t) throw new RangeError("Concurrency must not be zero");
                        var n = zr(e),
                            s = 0,
                            r = [];
                        const o = {
                            error: [],
                            drain: [],
                            saturated: [],
                            unsaturated: [],
                            empty: []
                        };

                        function a(e, t) {
                            return e ? t ? void(o[e] = o[e].filter((e => e !== t))) : o[e] = [] : Object.keys(o).forEach((e => o[e] = []))
                        }

                        function c(e, ...t) {
                            o[e].forEach((e => e(...t)))
                        }
                        var d = !1;

                        function l(e, t, i, n) {
                            if (null != n && "function" != typeof n) throw new Error("task callback must be a function");
                            var s, r;

                            function o(e, ...t) {
                                return e ? i ? r(e) : s() : t.length <= 1 ? s(t[0]) : void s(t)
                            }
                            f.started = !0;
                            var a = {
                                data: e,
                                callback: i ? o : n || o
                            };
                            if (t ? f._tasks.unshift(a) : f._tasks.push(a), d || (d = !0, Kr((() => {
                                    d = !1, f.process()
                                }))), i || !n) return new Promise(((e, t) => {
                                s = e, r = t
                            }))
                        }

                        function h(e) {
                            return function(t, ...i) {
                                s -= 1;
                                for (var n = 0, o = e.length; n < o; n++) {
                                    var a = e[n],
                                        d = r.indexOf(a);
                                    0 === d ? r.shift() : d > 0 && r.splice(d, 1), a.callback(t, ...i), null != t && c("error", t, a.data)
                                }
                                s <= f.concurrency - f.buffer && c("unsaturated"), f.idle() && c("drain"), f.process()
                            }
                        }

                        function u(e) {
                            return !(0 !== e.length || !f.idle() || (Kr((() => c("drain"))), 0))
                        }
                        const p = e => t => {
                            if (!t) return new Promise(((t, i) => {
                                ! function(e, n) {
                                    const s = (...n) => {
                                        a(e, s), ((e, n) => {
                                            if (e) return i(e);
                                            t(n)
                                        })(...n)
                                    };
                                    o[e].push(s)
                                }(e)
                            }));
                            a(e),
                                function(e, t) {
                                    o[e].push(t)
                                }(e, t)
                        };
                        var m = !1,
                            f = {
                                _tasks: new po,
                                *[Symbol.iterator]() {
                                    yield* f._tasks[Symbol.iterator]()
                                },
                                concurrency: t,
                                payload: i,
                                buffer: t / 4,
                                started: !1,
                                paused: !1,
                                push(e, t) {
                                    if (Array.isArray(e)) {
                                        if (u(e)) return;
                                        return e.map((e => l(e, !1, !1, t)))
                                    }
                                    return l(e, !1, !1, t)
                                },
                                pushAsync(e, t) {
                                    if (Array.isArray(e)) {
                                        if (u(e)) return;
                                        return e.map((e => l(e, !1, !0, t)))
                                    }
                                    return l(e, !1, !0, t)
                                },
                                kill() {
                                    a(), f._tasks.empty()
                                },
                                unshift(e, t) {
                                    if (Array.isArray(e)) {
                                        if (u(e)) return;
                                        return e.map((e => l(e, !0, !1, t)))
                                    }
                                    return l(e, !0, !1, t)
                                },
                                unshiftAsync(e, t) {
                                    if (Array.isArray(e)) {
                                        if (u(e)) return;
                                        return e.map((e => l(e, !0, !0, t)))
                                    }
                                    return l(e, !0, !0, t)
                                },
                                remove(e) {
                                    f._tasks.remove(e)
                                },
                                process() {
                                    if (!m) {
                                        for (m = !0; !f.paused && s < f.concurrency && f._tasks.length;) {
                                            var e = [],
                                                t = [],
                                                i = f._tasks.length;
                                            f.payload && (i = Math.min(i, f.payload));
                                            for (var o = 0; o < i; o++) {
                                                var a = f._tasks.shift();
                                                e.push(a), r.push(a), t.push(a.data)
                                            }
                                            s += 1, 0 === f._tasks.length && c("empty"), s === f.concurrency && c("saturated");
                                            var d = no(h(e));
                                            n(t, d)
                                        }
                                        m = !1
                                    }
                                },
                                length: () => f._tasks.length,
                                running: () => s,
                                workersList: () => r,
                                idle: () => f._tasks.length + s === 0,
                                pause() {
                                    f.paused = !0
                                },
                                resume() {
                                    !1 !== f.paused && (f.paused = !1, Kr(f.process))
                                }
                            };
                        return Object.defineProperties(f, {
                            saturated: {
                                writable: !1,
                                value: p("saturated")
                            },
                            unsaturated: {
                                writable: !1,
                                value: p("unsaturated")
                            },
                            empty: {
                                writable: !1,
                                value: p("empty")
                            },
                            drain: {
                                writable: !1,
                                value: p("drain")
                            },
                            error: {
                                writable: !1,
                                value: p("error")
                            }
                        }), f
                    }
                    Qr((function(e, t, i, n) {
                        n = io(n);
                        var s = zr(i);
                        return uo(e, ((e, i, n) => {
                            s(t, e, ((e, i) => {
                                t = i, n(e)
                            }))
                        }), (e => n(e, t)))
                    }), 4);
                    var go = Qr((function(e, t, i, n) {
                            return Zr(ro(t), e, i, n)
                        }), 4),
                        _o = Qr((function(e, t, i, n) {
                            var s = zr(i);
                            return go(e, t, ((e, t) => {
                                s(e, ((e, ...i) => e ? t(e) : t(e, i)))
                            }), ((e, t) => {
                                for (var i = [], s = 0; s < t.length; s++) t[s] && (i = i.concat(...t[s]));
                                return n(e, i)
                            }))
                        }), 4);

                    function So(e, t) {
                        return (i, n, s, r) => {
                            var o, a = !1;
                            const c = zr(s);
                            i(n, ((i, n, s) => {
                                c(i, ((n, r) => n || !1 === n ? s(n) : e(r) && !o ? (a = !0, o = t(!0, i), s(null, to)) : void s()))
                            }), (e => {
                                if (e) return r(e);
                                r(null, a ? o : t(!1))
                            }))
                        }
                    }

                    function vo(e) {
                        return (t, ...i) => zr(t)(...i, ((t, ...i) => {
                            "object" == typeof console && (t ? console.error && console.error(t) : console[e] && i.forEach((t => console[e](t))))
                        }))
                    }

                    function Eo(e) {
                        return (t, i, n) => e(t, n)
                    }
                    Qr((function(e, t, i) {
                        return _o(e, 1 / 0, t, i)
                    }), 3), Qr((function(e, t, i) {
                        return _o(e, 1, t, i)
                    }), 3), Qr((function(e, t, i) {
                        return So((e => e), ((e, t) => t))(lo, e, t, i)
                    }), 3), Qr((function(e, t, i, n) {
                        return So((e => e), ((e, t) => t))(ro(t), e, i, n)
                    }), 4), Qr((function(e, t, i) {
                        return So((e => e), ((e, t) => t))(ro(1), e, t, i)
                    }), 3), vo("dir"), Qr((function(e, t, i) {
                        i = no(i);
                        var n, s = zr(e),
                            r = zr(t);

                        function o(e, ...t) {
                            if (e) return i(e);
                            !1 !== e && (n = t, r(...t, a))
                        }

                        function a(e, t) {
                            return e ? i(e) : !1 !== e ? t ? void s(o) : i(null, ...n) : void 0
                        }
                        return a(null, !0)
                    }), 3), Qr((function(e, t, i) {
                        return lo(e, Eo(zr(t)), i)
                    }), 3);
                    var yo = Qr((function(e, t, i, n) {
                            return ro(t)(e, Eo(zr(i)), n)
                        }), 4),
                        To = Qr((function(e, t, i) {
                            return yo(e, 1, t, i)
                        }), 3);

                    function Co(e, t, i, n) {
                        var s = new Array(t.length);
                        e(t, ((e, t, n) => {
                            i(e, ((e, i) => {
                                s[t] = !!i, n(e)
                            }))
                        }), (e => {
                            if (e) return n(e);
                            for (var i = [], r = 0; r < t.length; r++) s[r] && i.push(t[r]);
                            n(null, i)
                        }))
                    }

                    function bo(e, t, i, n) {
                        var s = [];
                        e(t, ((e, t, n) => {
                            i(e, ((i, r) => {
                                if (i) return n(i);
                                r && s.push({
                                    index: t,
                                    value: e
                                }), n(i)
                            }))
                        }), (e => {
                            if (e) return n(e);
                            n(null, s.sort(((e, t) => e.index - t.index)).map((e => e.value)))
                        }))
                    }

                    function Ro(e, t, i, n) {
                        return (eo(t) ? Co : bo)(e, t, zr(i), n)
                    }

                    function Ao(e, t, i, n) {
                        const s = zr(i);
                        return Ro(e, t, ((e, t) => {
                            s(e, ((e, i) => {
                                t(e, !i)
                            }))
                        }), n)
                    }
                    Qr((function(e, t, i) {
                        return So((e => !e), (e => !e))(lo, e, t, i)
                    }), 3), Qr((function(e, t, i, n) {
                        return So((e => !e), (e => !e))(ro(t), e, i, n)
                    }), 4), Qr((function(e, t, i) {
                        return So((e => !e), (e => !e))(uo, e, t, i)
                    }), 3), Qr((function(e, t, i) {
                        return Ro(lo, e, t, i)
                    }), 3), Qr((function(e, t, i, n) {
                        return Ro(ro(t), e, i, n)
                    }), 4), Qr((function(e, t, i) {
                        return Ro(uo, e, t, i)
                    }), 3), Qr((function(e, t) {
                        var i = no(t),
                            n = zr(function(e) {
                                return Xr(e) ? e : function(...t) {
                                    var i = t.pop(),
                                        n = !0;
                                    t.push(((...e) => {
                                        n ? Kr((() => i(...e))) : i(...e)
                                    })), e.apply(this, t), n = !1
                                }
                            }(e));
                        return function e(t) {
                            if (t) return i(t);
                            !1 !== t && n(e)
                        }()
                    }), 2), Qr((function(e, t, i, n) {
                        var s = zr(i);
                        return go(e, t, ((e, t) => {
                            s(e, ((i, n) => i ? t(i) : t(i, {
                                key: n,
                                val: e
                            })))
                        }), ((e, t) => {
                            for (var i = {}, {
                                    hasOwnProperty: s
                                } = Object.prototype, r = 0; r < t.length; r++)
                                if (t[r]) {
                                    var {
                                        key: o
                                    } = t[r], {
                                        val: a
                                    } = t[r];
                                    s.call(i, o) ? i[o].push(a) : i[o] = [a]
                                } return n(e, i)
                        }))
                    }), 4), vo("log"), Qr((function(e, t, i, n) {
                        n = io(n);
                        var s = {},
                            r = zr(i);
                        return ro(t)(e, ((e, t, i) => {
                            r(e, t, ((e, n) => {
                                if (e) return i(e);
                                s[t] = n, i(e)
                            }))
                        }), (e => n(e, s)))
                    }), 4), Gr(Br ? process.nextTick : Hr ? setImmediate : Jr), Qr(((e, t, i) => {
                        var n = eo(t) ? [] : {};
                        e(t, ((e, t, i) => {
                            zr(e)(((e, ...s) => {
                                s.length < 2 && ([s] = s), n[t] = s, i(e)
                            }))
                        }), (e => i(e, n)))
                    }), 3), Symbol.iterator, Qr((function(e, t) {
                        if (t = io(t), !Array.isArray(e)) return t(new TypeError("First argument to race must be an array of functions"));
                        if (!e.length) return t();
                        for (var i = 0, n = e.length; i < n; i++) zr(e[i])(t)
                    }), 2), Qr((function(e, t, i) {
                        return Ao(lo, e, t, i)
                    }), 3), Qr((function(e, t, i, n) {
                        return Ao(ro(t), e, i, n)
                    }), 4), Qr((function(e, t, i) {
                        return Ao(uo, e, t, i)
                    }), 3), Qr((function(e, t, i) {
                        return So(Boolean, (e => e))(lo, e, t, i)
                    }), 3), Qr((function(e, t, i, n) {
                        return So(Boolean, (e => e))(ro(t), e, i, n)
                    }), 4), Qr((function(e, t, i) {
                        return So(Boolean, (e => e))(uo, e, t, i)
                    }), 3), Qr((function(e, t, i) {
                        var n = zr(t);
                        return ho(e, ((e, t) => {
                            n(e, ((i, n) => {
                                if (i) return t(i);
                                t(i, {
                                    value: e,
                                    criteria: n
                                })
                            }))
                        }), ((e, t) => {
                            if (e) return i(e);
                            i(null, t.sort(s).map((e => e.value)))
                        }));

                        function s(e, t) {
                            var i = e.criteria,
                                n = t.criteria;
                            return i < n ? -1 : i > n ? 1 : 0
                        }
                    }), 3), Qr((function(e, t) {
                        var i, n = null;
                        return To(e, ((e, t) => {
                            zr(e)(((e, ...s) => {
                                if (!1 === e) return t(e);
                                s.length < 2 ? [i] = s : i = s, n = e, t(e ? null : {})
                            }))
                        }), (() => t(n, i)))
                    })), Qr((function(e, t, i) {
                        i = no(i);
                        var n = zr(t),
                            s = zr(e),
                            r = [];

                        function o(e, ...t) {
                            if (e) return i(e);
                            r = t, !1 !== e && s(a)
                        }

                        function a(e, t) {
                            return e ? i(e) : !1 !== e ? t ? void n(o) : i(null, ...r) : void 0
                        }
                        return s(a)
                    }), 3), Qr((function(e, t) {
                        if (t = io(t), !Array.isArray(e)) return t(new Error("First argument to waterfall must be an array of functions"));
                        if (!e.length) return t();
                        var i = 0;

                        function n(t) {
                            zr(e[i++])(...t, no(s))
                        }

                        function s(s, ...r) {
                            if (!1 !== s) return s || i === e.length ? t(s, ...r) : void n(r)
                        }
                        n([])
                    }));
                    const Po = (0, v.getLogger)("modules/util/AsyncQueue.js");
                    class Io {
                        constructor() {
                            var e, t, i;
                            this._queue = (e = this._processQueueTasks.bind(this), t = 1, i = zr(e), fo(((e, t) => {
                                i(e[0], t)
                            }), t, 1)), this._stopped = !1
                        }
                        clear() {
                            this._queue.kill()
                        }
                        _processQueueTasks(e, t) {
                            try {
                                e(t)
                            } catch (e) {
                                Po.error(`Task failed: ${null==e?void 0:e.stack}`), t(e)
                            }
                        }
                        push(e, t) {
                            this._stopped ? t && t(new Error("The queue has been stopped")) : this._queue.push(e, t)
                        }
                        shutdown() {
                            this._stopped = !0
                        }
                    }
                    var No = i(2593);
                    let Do;
                    ! function(e) {
                        e.PENDING = "pending", e.ACTIVE = "active", e.ENDED = "ended"
                    }(Do || (Do = {}));
                    const Mo = Do.PENDING,
                        Oo = Do.ACTIVE,
                        wo = Do.ENDED,
                        Lo = (0, v.getLogger)("modules/xmpp/JingleSession.js");
                    class ko extends Wn {
                        constructor(e, t, i, n, s, r, o) {
                            super(), this.sid = e, this.localJid = t, this.remoteJid = i, this.connection = n, this.mediaConstraints = s, this.pcConfig = r, this.isInitiator = o, this.usedrip = !0, this.dripContainer = [], this.room = null, this._signalingLayer = null, this.state = null, this.rtc = null
                        }
                        get initiatorJid() {
                            return this.isInitiator ? this.localJid : this.remoteJid
                        }
                        get responderJid() {
                            return this.isInitiator ? this.remoteJid : this.localJid
                        }
                        initialize(e, t, i, n) {
                            if (null !== this.state) {
                                const e = `attempt to initiate on session ${this.sid}\n                   in state ${this.state}`;
                                throw Lo.error(e), new Error(e)
                            }
                            this.room = e, this.rtc = t, this._signalingLayer = i, this.state = Mo, this.doInitialize(n)
                        }
                        doInitialize(e) {}
                        addIceCandidates(e) {}
                        getState() {
                            return this.state
                        }
                        addSources(e) {}
                        removeSources(e) {}
                        terminate(e, t, i) {}
                        acceptOffer(e, t, i) {}
                        _getInitiatorJid() {
                            return this.isInitiator ? this.localJid : this.remoteJid
                        }
                    }
                    var xo;
                    ! function(e) {
                        e.REMOTE_SOURCE_CONSTRAINTS_CHANGED = "media_session.REMOTE_SOURCE_CONSTRAINTS_CHANGED", e.REMOTE_VIDEO_CONSTRAINTS_CHANGED = "media_session.REMOTE_VIDEO_CONSTRAINTS_CHANGED"
                    }(xo || (xo = {}));
                    const Fo = xo,
                        Vo = (0, v.getLogger)("modules/xmpp/JingleSessionPC.js"),
                        Uo = 1e4;
                    class jo extends ko {
                        static parseVideoSenders(e) {
                            const t = e.find('>content[name="video"]');
                            if (t.length) {
                                const e = t[0].getAttribute("senders");
                                if ("both" === e || "initiator" === e || "responder" === e || "none" === e) return e
                            }
                            return null
                        }
                        static parseMaxFrameHeight(e) {
                            const t = e.find('>content[name="video"]>max-frame-height');
                            return t.length ? Number(t.text()) : null
                        }
                        static parseSourceMaxFrameHeight(e) {
                            const t = [],
                                i = e.find('>content[name="video"]>source-frame-height');
                            let n, s;
                            return i.length ? (i.each(((e, i) => {
                                s = i.getAttribute("sourceName"), n = i.getAttribute("maxHeight"), t.push({
                                    maxHeight: n,
                                    sourceName: s
                                })
                            })), t) : null
                        }
                        constructor(e, t, i, n, s, r, o, a) {
                            super(e, t, i, n, s, r, a), this._bridgeSessionId = null, this._cachedOldLocalSdp = void 0, this._cachedNewLocalSdp = void 0, this._iceCheckingStartedTimestamp = null, this._gatheringStartedTimestamp = null, this.localRecvMaxFrameHeight = void 0, this._sourceReceiverConstraints = void 0, this._localVideoActive = !0, this._remoteVideoActive = !0, this._gatheringReported = !1, this.lasticecandidate = !1, this.closed = !1, this.isP2P = o, this.remoteRecvMaxFrameHeight = void 0, this.remoteSourceMaxFrameHeights = void 0, this.modificationQueue = new Io, this.wasConnected = !1, this.establishmentDuration = void 0, this._xmppListeners = [], this._xmppListeners.push(n.addEventListener(js.Events.CONN_STATUS_CHANGED, this.onXmppStatusChanged.bind(this))), this._removeSenderVideoConstraintsChangeListener = void 0
                        }
                        _assertNotEnded() {
                            return this.state !== wo
                        }
                        doInitialize(e) {
                            var t, i, n;
                            this.failICE = Boolean(e.failICE), this.lasticecandidate = !1, this.options = e, this.isReconnect = !1, this.wasstable = !1, this.webrtcIceUdpDisable = Boolean(e.webrtcIceUdpDisable), this.webrtcIceTcpDisable = Boolean(e.webrtcIceTcpDisable);
                            const s = {
                                disableRtx: e.disableRtx
                            };
                            if (e.gatherStats && (s.maxstats = 300), s.capScreenshareBitrate = !1, s.enableInsertableStreams = e.enableInsertableStreams, s.videoQuality = e.videoQuality, s.forceTurnRelay = e.forceTurnRelay, s.audioQuality = e.audioQuality, s.usesUnifiedPlan = this.usesUnifiedPlan = Ui.supportsUnifiedPlan() && (Ui.isFirefox() || Ui.isWebKitBased() || (Ui.isChromiumBased() && this.isP2P ? null === (t = null === (i = e.p2p) || void 0 === i ? void 0 : i.enableUnifiedOnChrome) || void 0 === t || t : null === (n = e.enableUnifiedOnChrome) || void 0 === n || n)), this.isP2P) {
                                s.disableSimulcast = !0;
                                const t = this._abtestSuspendVideoEnabled(e);
                                void 0 !== t && (s.abtestSuspendVideo = t)
                            } else {
                                var r, o;
                                s.disableSimulcast = e.disableSimulcast || e.preferH264 && !e.disableH264 || e.videoQuality && e.videoQuality.preferredCodec === Ar.H264, s.capScreenshareBitrate = s.disableSimulcast || !("number" == typeof(null === (r = e.desktopSharingFrameRate) || void 0 === r ? void 0 : r.max) && (null === (o = e.desktopSharingFrameRate) || void 0 === o ? void 0 : o.max) > 5), Tn.analytics.addPermanentProperties({
                                    capScreenshareBitrate: s.capScreenshareBitrate
                                })
                            }
                            e.startSilent && (s.startSilent = !0), this.peerconnection = this.rtc.createPeerConnection(this._signalingLayer, this.pcConfig, this.isP2P, s), this.peerconnection.onicecandidate = e => {
                                if (!e) return;
                                const t = e.candidate,
                                    i = window.performance.now();
                                if (t) {
                                    null === this._gatheringStartedTimestamp && (this._gatheringStartedTimestamp = i);
                                    let e = t.protocol;
                                    if ("string" == typeof e)
                                        if (e = e.toLowerCase(), "tcp" === e || "ssltcp" === e) {
                                            if (this.webrtcIceTcpDisable) return
                                        } else if ("udp" === e && this.webrtcIceUdpDisable) return
                                } else this._gatheringReported || (Tn.sendAnalytics(si, {
                                    phase: "gathering",
                                    value: i - this._gatheringStartedTimestamp,
                                    p2p: this.isP2P,
                                    initiator: this.isInitiator
                                }), this._gatheringReported = !0);
                                this.sendIceCandidate(t)
                            }, this.peerconnection.onsignalingstatechange = () => {
                                "stable" === this.peerconnection.signalingState ? this.wasstable = !0 : "closed" !== this.peerconnection.signalingState && "closed" !== this.peerconnection.connectionState || this.room.eventEmitter.emit(Nn.XMPPEvents.SUSPEND_DETECTED, this)
                            }, this.peerconnection.oniceconnectionstatechange = () => {
                                const e = window.performance.now();
                                let t = !1;
                                switch (this.isP2P || (this.room.connectionTimes[`ice.state.${this.peerconnection.iceConnectionState}`] = e), Vo.log(`(TIME) ICE ${this.peerconnection.iceConnectionState} ${this.isP2P?"P2P":"JVB"}:\t`, e), Tn.sendAnalytics(oi, {
                                        p2p: this.isP2P,
                                        state: this.peerconnection.iceConnectionState,
                                        signaling_state: this.peerconnection.signalingState,
                                        reconnect: this.isReconnect,
                                        value: e
                                    }), this.room.eventEmitter.emit(Nn.XMPPEvents.ICE_CONNECTION_STATE_CHANGED, this, this.peerconnection.iceConnectionState), this.peerconnection.iceConnectionState) {
                                    case "checking":
                                        this._iceCheckingStartedTimestamp = e;
                                        break;
                                    case "connected":
                                        if ("stable" === this.peerconnection.signalingState) {
                                            t = !0;
                                            const e = !this.options.enableIceRestart && this.room.supportsRestartByTerminate();
                                            (this.isReconnect || e) && this.room.eventEmitter.emit(Nn.XMPPEvents.CONNECTION_RESTORED, this)
                                        }
                                        if (!this.wasConnected && (this.wasstable || t || this.usesUnifiedPlan && this.isInitiator && Ui.isChromiumBased())) {
                                            Tn.sendAnalytics(si, {
                                                phase: "checking",
                                                value: e - this._iceCheckingStartedTimestamp,
                                                p2p: this.isP2P,
                                                initiator: this.isInitiator
                                            });
                                            const t = Math.min(this._iceCheckingStartedTimestamp, this._gatheringStartedTimestamp);
                                            this.establishmentDuration = e - t, Tn.sendAnalytics(si, {
                                                phase: "establishment",
                                                value: this.establishmentDuration,
                                                p2p: this.isP2P,
                                                initiator: this.isInitiator
                                            }), this.wasConnected = !0, this.room.eventEmitter.emit(Nn.XMPPEvents.CONNECTION_ESTABLISHED, this)
                                        }
                                        this.isReconnect = !1;
                                        break;
                                    case "disconnected":
                                        this.isReconnect = !0, this.wasstable && this.room.eventEmitter.emit(Nn.XMPPEvents.CONNECTION_INTERRUPTED, this);
                                        break;
                                    case "failed":
                                        this.room.eventEmitter.emit(Nn.XMPPEvents.CONNECTION_ICE_FAILED, this)
                                }
                            }, this.peerconnection.onconnectionstatechange = () => {
                                const e = this.peerconnection.iceConnectionState;
                                "failed" === this.peerconnection.connectionState && "disconnected" === e && this.room.eventEmitter.emit(Nn.XMPPEvents.CONNECTION_ICE_FAILED, this)
                            }, this.peerconnection.onnegotiationneeded = () => {
                                const e = this.peerconnection.signalingState,
                                    t = this.peerconnection.remoteDescription;
                                if (this.usesUnifiedPlan && !this.isP2P && "stable" === e && t && "string" == typeof t.sdp) {
                                    Vo.info(`${this} onnegotiationneeded fired on ${this.peerconnection}`);
                                    const e = e => {
                                        const t = new Vr(this.peerconnection.localDescription.sdp);
                                        this._renegotiate().then((() => this.peerconnection.configureSenderVideoEncodings())).then((() => {
                                            const e = new Vr(this.peerconnection.localDescription.sdp);
                                            this.notifyMySSRCUpdate(t, e)
                                        })).then((() => e()), (t => e(t)))
                                    };
                                    this.modificationQueue.push(e, (e => {
                                        e ? Vo.error(`${this} onnegotiationneeded error`, e) : Vo.debug(`${this} onnegotiationneeded executed - OK`)
                                    }))
                                }
                            }
                        }
                        getRemoteRecvMaxFrameHeight() {
                            if (this.isP2P) return this.remoteRecvMaxFrameHeight
                        }
                        getRemoteSourcesRecvMaxFrameHeight() {
                            if (this.isP2P) return this.remoteSourceMaxFrameHeights
                        }
                        sendIceCandidate(e) {
                            const t = new Vr(this.peerconnection.localDescription.sdp);
                            if (e && e.candidate.length && !this.lasticecandidate) {
                                const i = Fr.iceparams(t.media[e.sdpMLineIndex], t.session),
                                    n = Fr.candidateToJingle(e.candidate);
                                if (!i || !n) {
                                    const e = "failed to get ice && jcand";
                                    return Gi().callErrorHandler(new Error(e)), void Vo.error(e)
                                }
                                i.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", this.usedrip ? (0 === this.dripContainer.length && setTimeout((() => {
                                    0 !== this.dripContainer.length && (this.sendIceCandidates(this.dripContainer), this.dripContainer = [])
                                }), 150), this.dripContainer.push(e)) : this.sendIceCandidates([e])
                            } else Vo.log(`${this} sendIceCandidate: last candidate`), this.lasticecandidate = !0
                        }
                        sendIceCandidates(e) {
                            if (!this._assertNotEnded("sendIceCandidates")) return;
                            Vo.log(`${this} sendIceCandidates ${JSON.stringify(e)}`);
                            const t = (0, ut.$iq)({
                                    to: this.remoteJid,
                                    type: "set"
                                }).c("jingle", {
                                    xmlns: "urn:xmpp:jingle:1",
                                    action: "transport-info",
                                    initiator: this.initiatorJid,
                                    sid: this.sid
                                }),
                                i = new Vr(this.peerconnection.localDescription.sdp);
                            for (let n = 0; n < i.media.length; n++) {
                                const s = e.filter((e => e.sdpMLineIndex === n)),
                                    r = Fr.parseMLine(i.media[n].split("\r\n")[0]);
                                if (s.length > 0) {
                                    const e = Fr.iceparams(i.media[n], i.session);
                                    e.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.c("content", {
                                        creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
                                        name: s[0].sdpMid ? s[0].sdpMid : r.media
                                    }).c("transport", e);
                                    for (let e = 0; e < s.length; e++) {
                                        const i = Fr.candidateToJingle(s[e].candidate);
                                        this.failICE && (i.ip = "1.1.1.1"), t.c("candidate", i).up()
                                    }
                                    const o = Fr.findLine(i.media[n], "a=fingerprint:", i.session);
                                    if (o) {
                                        const e = Fr.parseFingerprint(o);
                                        e.required = !0, t.c("fingerprint", {
                                            xmlns: "urn:xmpp:jingle:apps:dtls:0"
                                        }).t(e.fingerprint), delete e.fingerprint, t.attrs(e), t.up()
                                    }
                                    t.up(), t.up()
                                }
                            }
                            this.connection.sendIQ(t, null, this.newJingleErrorHandler(t), Uo)
                        }
                        sendIceFailedNotification() {
                            const e = (0, ut.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "session-info",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            }).c("ice-state", {
                                xmlns: "http://jitsi.org/protocol/focus"
                            }).t("failed").up();
                            this._bridgeSessionId && e.c("bridge-session", {
                                xmlns: "http://jitsi.org/protocol/focus",
                                id: this._bridgeSessionId
                            }), this.connection.sendIQ2(e, {
                                timeout: 65
                            }).catch(this.newJingleErrorHandler(e))
                        }
                        addIceCandidates(e) {
                            if ("closed" === this.peerconnection.signalingState) return void Vo.warn(`${this} Ignored add ICE candidate when in closed state`);
                            const t = [];
                            e.find(">content>transport>candidate").each(((e, i) => {
                                let n = Fr.candidateFromJingle(i);
                                n = n.replace("\r\n", "").replace("a=", "");
                                const s = new RTCIceCandidate({
                                    sdpMLineIndex: 0,
                                    sdpMid: "",
                                    candidate: n
                                });
                                t.push(s)
                            })), t.length ? (Vo.debug(`${this} Queued add (${t.length}) ICE candidates task`), this.modificationQueue.push((e => {
                                for (const e of t) this.peerconnection.addIceCandidate(e).then((() => Vo.debug(`${this} addIceCandidate ok!`)), (e => Vo.error(`${this} addIceCandidate failed!`, e)));
                                e(), Vo.debug(`${this} ICE candidates task finished`)
                            }))) : Vo.error(`${this} No ICE candidates to add ?`, e[0] && e[0].outerHTML)
                        }
                        readSsrcInfo(e) {
                            $(e).find('>description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(((e, t) => {
                                const i = Number(t.getAttribute("ssrc"));
                                if (hn.isSourceNameSignalingEnabled() && t.hasAttribute("name")) {
                                    const e = t.getAttribute("name");
                                    this._signalingLayer.setTrackSourceName(i, e)
                                }
                                this.isP2P ? this._signalingLayer.setSSRCOwner(i, ut.Strophe.getResourceFromJid(this.remoteJid)) : $(t).find('>ssrc-info[xmlns="http://jitsi.org/jitmeet"]').each(((e, t) => {
                                    const n = t.getAttribute("owner");
                                    var s;
                                    null != n && n.length && (isNaN(i) || i < 0 ? Vo.warn(`${this} Invalid SSRC ${i} value received for ${n}`) : this._signalingLayer.setSSRCOwner(i, (s = n, ut.Strophe.getResourceFromJid(s) || s)))
                                }))
                            }))
                        }
                        generateRecvonlySsrc() {
                            this.peerconnection ? this.peerconnection.generateRecvonlySsrc() : Vo.error(`${this} Unable to generate recvonly SSRC - no peerconnection`)
                        }
                        getConfiguredVideoCodec() {
                            return this.peerconnection.getConfiguredVideoCodec()
                        }
                        acceptOffer(e, t, i, n) {
                            this.setOfferAnswerCycle(e, (() => {
                                this.sendSessionAccept((() => {
                                    t(), this.room.eventEmitter.emit(Nn.XMPPEvents.SESSION_ACCEPT, this);
                                    const e = n.filter((e => e.getType() === dn.VIDEO));
                                    e.length && e.splice(0, 1), hn.isMultiStreamSupportEnabled() && e.length && this.addTracks(e)
                                }), (e => {
                                    i(e), this.room.eventEmitter.emit(Nn.XMPPEvents.SESSION_ACCEPT_ERROR, this, e)
                                }))
                            }), i, n)
                        }
                        invite() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                            if (!this.isInitiator) throw new Error("Trying to invite from the responder session");
                            Vo.debug(`${this} Queued invite task`), this.modificationQueue.push((t => {
                                const i = [];
                                for (const t of e) i.push(this.peerconnection.addTrack(t, this.isInitiator));
                                Promise.all(i).then((() => this.peerconnection.createOffer(this.mediaConstraints))).then((e => this.peerconnection.setLocalDescription(e))).then((() => {
                                    this.sendSessionInitiate(this.peerconnection.localDescription.sdp)
                                })).then((() => t()), (e => t(e)))
                            }), (e => {
                                e ? Vo.error(`${this} invite error`, e) : Vo.debug(`${this} invite executed - OK`)
                            }))
                        }
                        sendSessionInitiate(e) {
                            let t = (0, ut.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "session-initiate",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            });
                            new Vr(e).toJingle(t, this.isInitiator ? "initiator" : "responder"), t = t.tree(), Vo.debug(`${this} Session-initiate: `, t), this.connection.sendIQ(t, (() => {
                                Vo.info(`${this} Got RESULT for "session-initiate"`)
                            }), (e => {
                                Vo.error(`${this} "session-initiate" error`, e)
                            }), Uo)
                        }
                        setAnswer(e) {
                            if (!this.isInitiator) throw new Error("Trying to set an answer on the responder session");
                            Vo.debug(`${this} Queued setAnswer task`), this.modificationQueue.push((t => {
                                const i = this._processNewJingleOfferIq(e),
                                    n = new Vr(this.peerconnection.localDescription.sdp),
                                    s = new RTCSessionDescription({
                                        type: "answer",
                                        sdp: i.raw
                                    });
                                this.peerconnection.setRemoteDescription(s).then((() => {
                                    if (this.state === Mo) {
                                        this.state = Oo;
                                        const e = new Vr(this.peerconnection.localDescription.sdp);
                                        this.sendContentModify(), this.notifyMySSRCUpdate(n, e)
                                    }
                                })).then((() => t()), (e => t(e)))
                            }), (e => {
                                e ? Vo.error(`${this} setAnswer task failed: ${e}`) : Vo.debug(`${this} setAnswer task done`)
                            }))
                        }
                        setOfferAnswerCycle(e, t, i) {
                            let n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [];
                            Vo.debug(`${this} Queued setOfferAnswerCycle task`), this.modificationQueue.push((t => {
                                const i = [],
                                    s = n.filter((e => e.getType() === dn.AUDIO)),
                                    r = n.filter((e => e.getType() === dn.VIDEO));
                                let o = n;
                                hn.isMultiStreamSupportEnabled() && r.length > 1 && (o = [...s, r[0]]);
                                for (const e of o) i.push(this.peerconnection.addTrack(e, this.isInitiator));
                                const a = this._processNewJingleOfferIq(e),
                                    c = this.peerconnection.localDescription.sdp,
                                    d = $(e).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("id");
                                d !== this._bridgeSessionId && (this._bridgeSessionId = d);
                                const l = new RTCSessionDescription({
                                    type: "offer",
                                    sdp: a.raw
                                });
                                Promise.all(i).then((() => this._responderRenegotiate(l))).then((() => {
                                    if (this.state === Mo && (this.state = Oo, this.isP2P && (!this._localVideoActive || this.localRecvMaxFrameHeight || this._sourceReceiverConstraints) && this.sendContentModify()), c) {
                                        const e = new Vr(this.peerconnection.localDescription.sdp);
                                        this.notifyMySSRCUpdate(new Vr(c), e)
                                    }
                                })).then((() => t()), (e => t(e)))
                            }), (e => {
                                e ? (Vo.error(`${this} setOfferAnswerCycle task failed: ${e}`), i(e)) : (Vo.debug(`${this} setOfferAnswerCycle task done`), t())
                            }))
                        }
                        setVideoCodecs() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                            const i = this.peerconnection.getConfiguredVideoCodec();
                            if (this._assertNotEnded() && e !== i) {
                                Vo.info(`${this} Switching video codec from ${i} to ${e}`), this.peerconnection.setVideoCodecs(e, t);
                                const n = e => {
                                    this._renegotiate().then((() => (Vo.debug(`${this} setVideoCodecs task is done`), e())), (t => (Vo.error(`${this} setVideoCodecs task failed: ${t}`), e(t))))
                                };
                                Vo.debug(`${this} Queued setVideoCodecs task`), this.modificationQueue.push(n)
                            }
                        }
                        replaceTransport(e, t, i) {
                            if (this.options.enableForcedReload) {
                                const e = new Vr(this.peerconnection.localDescription.sdp);
                                return this.sendTransportAccept(e, t, i), void this.room.eventEmitter.emit(Nn.XMPPEvents.CONNECTION_RESTARTED, this)
                            }
                            this.room.eventEmitter.emit(Nn.XMPPEvents.ICE_RESTARTING, this);
                            const n = e.clone();
                            e.find(">content[name='data']").attr("senders", "rejected"), e.find(">content>description>source").remove(), e.find(">content>description>ssrc-group").remove();
                            const s = e.find(">content>transport>fingerprint");
                            s.attr("hash", "sha-1"), s.text("00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00"), this.setOfferAnswerCycle(e, (() => {
                                this.setOfferAnswerCycle(n, (() => {
                                    const e = new Vr(this.peerconnection.localDescription.sdp);
                                    this.sendTransportAccept(e, t, i), this.room.eventEmitter.emit(Nn.XMPPEvents.ICE_RESTART_SUCCESS, this, n)
                                }), i)
                            }), i)
                        }
                        sendSessionAccept(e, t) {
                            const i = new Vr(this.peerconnection.localDescription.sdp),
                                n = (0, ut.$iq)({
                                    to: this.remoteJid,
                                    type: "set"
                                }).c("jingle", {
                                    xmlns: "urn:xmpp:jingle:1",
                                    action: "session-accept",
                                    initiator: this.initiatorJid,
                                    responder: this.responderJid,
                                    sid: this.sid
                                });
                            this.webrtcIceTcpDisable && (i.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (i.removeUdpCandidates = !0), this.failICE && (i.failICE = !0), i.toJingle(n, this.initiatorJid === this.localJid ? "initiator" : "responder"), Vo.info(`${this} Sending session-accept`), Vo.debug(n.tree()), this.connection.sendIQ(n, e, this.newJingleErrorHandler(n, (e => {
                                t(e), this.room.eventEmitter.emit(Nn.XMPPEvents.SESSION_ACCEPT_TIMEOUT, this)
                            })), Uo)
                        }
                        sendContentModify() {
                            const e = this.localRecvMaxFrameHeight,
                                t = this._localVideoActive ? "both" : "none";
                            let i = (0, ut.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "content-modify",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            }).c("content", {
                                name: dn.VIDEO,
                                senders: t
                            });
                            void 0 !== e && (i = i.c("max-frame-height", {
                                xmlns: "http://jitsi.org/jitmeet/video"
                            }).t(e), Vo.info(`${this} sending content-modify, video senders: ${t}, max frame height: ${e}`)), void 0 !== this._sourceReceiverConstraints && this._sourceReceiverConstraints.forEach(((e, t) => {
                                i.c("source-frame-height", {
                                    xmlns: "http://jitsi.org/jitmeet/video"
                                }).attrs({
                                    sourceName: t,
                                    maxHeight: e
                                }), i.up(), Vo.info(`${this} sending content-modify for source-name: ${t}, maxHeight: ${e}`)
                            })), Vo.debug(i.tree()), this.connection.sendIQ(i, null, this.newJingleErrorHandler(i), Uo)
                        }
                        setReceiverVideoConstraint(e, t) {
                            Vo.info(`${this} setReceiverVideoConstraint - max frame height: ${e} sourceReceiverConstraints: ${t}`), hn.isSourceNameSignalingEnabled() ? this._sourceReceiverConstraints = t : this.localRecvMaxFrameHeight = e, this.isP2P && this.state === Oo && this.sendContentModify()
                        }
                        sendTransportAccept(e, t, i) {
                            const n = (0, ut.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "transport-accept",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            });
                            e.media.forEach(((t, i) => {
                                const s = Fr.parseMLine(t.split("\r\n")[0]);
                                n.c("content", {
                                    creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
                                    name: s.media
                                }), e.transportToJingle(i, n), n.up()
                            })), Vo.info(`${this} Sending transport-accept`), Vo.debug(n.tree()), this.connection.sendIQ(n, t, this.newJingleErrorHandler(n, i), Uo)
                        }
                        sendTransportReject(e, t) {
                            const i = (0, ut.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "transport-reject",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            });
                            Vo.info(`${this} Sending 'transport-reject'`), Vo.debug(i.tree()), this.connection.sendIQ(i, e, this.newJingleErrorHandler(i, t), Uo)
                        }
                        setSenderVideoConstraint(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                            if (this._assertNotEnded()) {
                                Vo.info(`${this} setSenderVideoConstraint: ${e}, sourceName: ${t}`);
                                const i = t ? this.rtc.getLocalVideoTracks().find((e => e.getSourceName() === t)) : this.rtc.getLocalVideoTrack();
                                return this.peerconnection.setSenderVideoConstraints(e, i)
                            }
                            return Promise.resolve()
                        }
                        terminate(e, t, i) {
                            if (this.state !== wo) {
                                if (!i || Boolean(i.sendSessionTerminate)) {
                                    const n = (0, ut.$iq)({
                                        to: this.remoteJid,
                                        type: "set"
                                    }).c("jingle", {
                                        xmlns: "urn:xmpp:jingle:1",
                                        action: "session-terminate",
                                        initiator: this.initiatorJid,
                                        sid: this.sid
                                    }).c("reason").c(i && i.reason || "success").up();
                                    i && i.reasonDescription ? n.c("text").t(i.reasonDescription).up().up() : n.up(), this._bridgeSessionId && n.c("bridge-session", {
                                        xmlns: "http://jitsi.org/protocol/focus",
                                        id: this._bridgeSessionId,
                                        restart: i && !0 === i.requestRestart
                                    }).up(), Vo.info(`${this} Sending session-terminate`), Vo.debug(n.tree()), this.connection.sendIQ(n, e, this.newJingleErrorHandler(n, t), Uo)
                                } else Vo.info(`${this} Skipped sending session-terminate`);
                                this.connection.jingle.terminate(this.sid)
                            }
                        }
                        onTerminated(e, t) {
                            Vo.info(`${this} Session terminated`, e, t), this._xmppListeners.forEach((e => e())), this._xmppListeners = [], this._removeSenderVideoConstraintsChangeListener && this._removeSenderVideoConstraintsChangeListener(), this.close()
                        }
                        onXmppStatusChanged(e) {
                            e === js.Status.CONNECTED && this._cachedOldLocalSdp && (Vo.info(`${this} Sending SSRC update on reconnect`), this.notifyMySSRCUpdate(this._cachedOldLocalSdp, this._cachedNewLocalSdp))
                        }
                        _parseSsrcInfoFromSourceAdd(e, t) {
                            const i = [],
                                n = this;
                            return $(e).each(((e, s) => {
                                const r = $(s).attr("name");
                                let o = "";
                                $(s).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                    const e = this.getAttribute("semantics"),
                                        t = $(this).find(">source").map((function() {
                                            return this.getAttribute("ssrc")
                                        })).get();
                                    t.length && (o += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
                                })), $(s).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                    const e = $(this).attr("ssrc");
                                    t.containsSSRC(e) ? (!n.usesUnifiedPlan || !n.isP2P) && Vo.warn(`${n} Source-add request for existing SSRC: ${e}`) : $(this).find(">parameter").each((function() {
                                        o += `a=ssrc:${e} ${$(this).attr("name")}`, $(this).attr("value") && $(this).attr("value").length && (o += `:${$(this).attr("value")}`), o += "\r\n"
                                    }))
                                }));
                                let a = !1;
                                t.media.forEach(((e, t) => {
                                    Fr.findLine(e, `a=mid:${r}`) && (i[t] || (i[t] = ""), i[t] += o, a = !0)
                                })), !a && this.isP2P && hn.isSourceNameSignalingEnabled() && (i[r] = o)
                            })), i
                        }
                        addRemoteStream(e) {
                            this._addOrRemoveRemoteStream(!0, e)
                        }
                        removeRemoteStream(e) {
                            this._addOrRemoveRemoteStream(!1, e)
                        }
                        removeRemoteStreamsOnLeave(e) {
                            Vo.debug(`${this} Queued removeRemoteStreamsOnLeave task for participant ${e}`), this.modificationQueue.push((t => {
                                const i = this.peerconnection.getRemoteSourceInfoByParticipant(e);
                                if (i.length) {
                                    const e = new Vr(this.peerconnection.localDescription.sdp),
                                        n = this._processRemoteRemoveSource(i);
                                    this._renegotiate(n.raw).then((() => {
                                        const i = new Vr(this.peerconnection.localDescription.sdp);
                                        this.notifyMySSRCUpdate(e, i), t()
                                    })).catch((e => t(e)))
                                } else t()
                            }), (e => {
                                e ? Vo.error(`${this} removeRemoteStreamsOnLeave error:`, e) : Vo.info(`${this} removeRemoteStreamsOnLeave done!`)
                            }))
                        }
                        _addOrRemoveRemoteStream(e, t) {
                            const i = e ? "addRemoteStream" : "removeRemoteStream";
                            e && this.readSsrcInfo(t), Vo.debug(`${this} Queued ${i} task`), this.modificationQueue.push((n => {
                                if (!this.peerconnection.localDescription || !this.peerconnection.localDescription.sdp) {
                                    const e = `${i} - localDescription not ready yet`;
                                    return Vo.error(e), void n(e)
                                }
                                Vo.log(`${this} Processing ${i}`);
                                const s = new Vr(this.peerconnection.localDescription.sdp),
                                    r = new Vr(this.peerconnection.remoteDescription.sdp),
                                    o = e ? this._parseSsrcInfoFromSourceAdd(t, r) : this._parseSsrcInfoFromSourceRemove(t, r),
                                    a = e ? this._processRemoteAddSource(o) : this._processRemoteRemoveSource(o),
                                    c = new RTCSessionDescription({
                                        type: "offer",
                                        sdp: a.raw
                                    });
                                this._responderRenegotiate(c).then((() => {
                                    const e = new Vr(this.peerconnection.localDescription.sdp);
                                    Vo.log(`${this} ${i} - OK`), this.notifyMySSRCUpdate(s, e), n()
                                }), (e => {
                                    Vo.error(`${this} ${i} failed:`, e), n(e)
                                }))
                            }))
                        }
                        _processNewJingleOfferIq(e) {
                            const t = new Vr("");
                            return this.webrtcIceTcpDisable && (t.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (t.removeUdpCandidates = !0), this.failICE && (t.failICE = !0), t.fromJingle(e), this.readSsrcInfo($(e).find(">content")), t
                        }
                        _processRemoteRemoveSource(e) {
                            const t = this.usesUnifiedPlan ? new Vr(this.peerconnection.peerconnection.remoteDescription.sdp) : new Vr(this.peerconnection.remoteDescription.sdp);
                            return e.forEach(((e, i) => {
                                if ((e = e.split("\r\n")).pop(), this.usesUnifiedPlan) {
                                    let i;
                                    if (e.forEach((e => {
                                            if (i = t.media.findIndex((t => t.includes(e))), i > -1)
                                                if (t.media[i] = t.media[i].replace(`${e}\r\n`, ""), this.isP2P) {
                                                    var n;
                                                    const e = null === (n = Fr.parseMLine(t.media[i].split("\r\n")[0])) || void 0 === n ? void 0 : n.media,
                                                        s = this.peerconnection.getDesiredMediaDirection(e, !1);
                                                    [Ir.SENDRECV, Ir.SENDONLY].forEach((e => {
                                                        t.media[i] = t.media[i].replace(`a=${e}`, `a=${s}`)
                                                    }))
                                                } else t.media[i] = t.media[i].replace(`a=${Ir.SENDONLY}`, `a=${Ir.INACTIVE}`)
                                        })), i > -1 && !this.isP2P && hn.isMultiStreamSupportEnabled()) {
                                        const {
                                            media: e,
                                            port: n
                                        } = Fr.parseMLine(t.media[i].split("\r\n")[0]);
                                        t.media[i] = t.media[i].replace(`m=${e} ${n}`, `m=${e} 0`)
                                    }
                                } else e.forEach((e => {
                                    t.media[i] = t.media[i].replace(`${e}\r\n`, "")
                                }))
                            })), t.raw = t.session + t.media.join(""), t
                        }
                        _processRemoteAddSource(e) {
                            let t = new Vr(this.peerconnection.remoteDescription.sdp);
                            return e.length > t.media.length && hn.isSourceNameSignalingEnabled() && this.isP2P && this.usesUnifiedPlan && (t.addMlineForNewLocalSource(dn.VIDEO), t = new Vr(t.raw)), e.forEach(((e, i) => {
                                if (t.media[i] += e, this.isP2P && this.usesUnifiedPlan) {
                                    var n;
                                    const e = null === (n = Fr.parseMLine(t.media[i].split("\r\n")[0])) || void 0 === n ? void 0 : n.media,
                                        s = this.peerconnection.getDesiredMediaDirection(e, !0);
                                    [Ir.RECVONLY, Ir.INACTIVE].forEach((e => {
                                        t.media[i] = t.media[i].replace(`a=${e}`, `a=${s}`)
                                    }))
                                }
                            })), t.raw = t.session + t.media.join(""), t
                        }
                        _renegotiate(e) {
                            if ("closed" === this.peerconnection.signalingState) {
                                const e = new Error("Attempted to renegotiate in state closed");
                                return this.room.eventEmitter.emit(Nn.XMPPEvents.RENEGOTIATION_FAILED, e, this), Promise.reject(e)
                            }
                            const t = e || this.peerconnection.remoteDescription.sdp;
                            if (!t) {
                                const e = new Error(`Can not renegotiate without remote description, current state: ${this.state}`);
                                return this.room.eventEmitter.emit(Nn.XMPPEvents.RENEGOTIATION_FAILED, e, this), Promise.reject(e)
                            }
                            const i = new RTCSessionDescription({
                                type: this.isInitiator ? "answer" : "offer",
                                sdp: t
                            });
                            return this.isInitiator ? this._initiatorRenegotiate(i) : this._responderRenegotiate(i)
                        }
                        _responderRenegotiate(e) {
                            return Vo.debug(`${this} Renegotiate: setting remote description`), this.peerconnection.setRemoteDescription(e).then((() => (Vo.debug(`${this} Renegotiate: creating answer`), this.peerconnection.createAnswer(this.mediaConstraints).then((e => (Vo.debug(`${this} Renegotiate: setting local description`), this.peerconnection.setLocalDescription(e)))))))
                        }
                        _initiatorRenegotiate(e) {
                            return Vo.debug(`${this} Renegotiate: creating offer`), this.peerconnection.createOffer(this.mediaConstraints).then((t => (Vo.debug(`${this} Renegotiate: setting local description`), this.peerconnection.setLocalDescription(t).then((() => (Vo.debug(`${this} Renegotiate: setting remote description`), this.peerconnection.setRemoteDescription(e)))))))
                        }
                        addTracks() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                            if (!hn.isMultiStreamSupportEnabled() || null == e || !e.length || e.find((e => e.getType() !== dn.VIDEO))) return Promise.reject(new Error("Multiple tracks of the given media type are not supported"));
                            const t = [],
                                i = i => {
                                    const n = new Vr(this.peerconnection.localDescription.sdp),
                                        s = new Vr(this.peerconnection.peerconnection.remoteDescription.sdp);
                                    for (const t of e) s.addMlineForNewLocalSource(t.getType());
                                    const r = new RTCSessionDescription({
                                        type: "offer",
                                        sdp: s.raw
                                    });
                                    this._responderRenegotiate(r).then((() => {
                                        for (const i of e) t.push(this.peerconnection.replaceTrack(null, i));
                                        return Promise.all(t)
                                    })).then((() => this._renegotiate())).then((() => {
                                        const e = new Vr(this.peerconnection.localDescription.sdp);
                                        this.notifyMySSRCUpdate(n, e), i()
                                    })).catch((e => i(e)))
                                };
                            return new Promise(((e, t) => {
                                Vo.debug(`${this} Queued renegotiation after addTrack`), this.modificationQueue.push(i, (i => {
                                    i ? (Vo.error(`${this} renegotiation after addTrack error`, i), t(i)) : (Vo.debug(`${this} renegotiation after addTrack executed - OK`), e())
                                }))
                            }))
                        }
                        replaceTrack(e, t) {
                            const i = i => {
                                Vo.debug(`${this} replaceTrack worker started. oldTrack = ${e}, newTrack = ${t}`);
                                const n = this.peerconnection.localDescription.sdp;
                                this.usesUnifiedPlan || (this.peerconnection.options.capScreenshareBitrate && e && t && t.isVideoTrack() && this.peerconnection.clearRecvonlySsrc(), !e && t && t.isVideoTrack() ? this.peerconnection.clearRecvonlySsrc() : e && e.isVideoTrack() && !t && (this.peerconnection.clearRecvonlySsrc(), this.peerconnection.generateRecvonlySsrc())), this.peerconnection.replaceTrack(e, t).then((i => {
                                    let s = Promise.resolve();
                                    return Vo.debug(`${this} TPC.replaceTrack finished. shouldRenegotiate = ${i}, JingleSessionState = ${this.state}`), i && (e || t) && this.state === Oo && (s = this._renegotiate().then((() => {
                                        const e = new Vr(this.peerconnection.localDescription.sdp);
                                        this.notifyMySSRCUpdate(new Vr(n), e)
                                    }))), s.then((() => {
                                        if (hn.isSourceNameSignalingEnabled() && e && t && e.isVideoTrack() && t.setSourceName(e.getSourceName()), null != t && t.isVideoTrack()) return Vo.debug(`${this} replaceTrack worker: configuring video stream`), this.peerconnection.configureSenderVideoEncodings(t)
                                    }))
                                })).then((() => i()), (e => i(e)))
                            };
                            return new Promise(((n, s) => {
                                Vo.debug(`${this} Queued replaceTrack task. Old track = ${e}, new track = ${t}`), this.modificationQueue.push(i, (e => {
                                    e ? (Vo.error(`${this} Replace track error:`, e), s(e)) : (Vo.info(`${this}  Replace track done!`), n())
                                }))
                            }))
                        }
                        _parseSsrcInfoFromSourceRemove(e, t) {
                            const i = [];
                            return $(e).each(((e, n) => {
                                const s = $(n).attr("name");
                                let r = "";
                                $(n).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                    const e = this.getAttribute("semantics"),
                                        t = $(this).find(">source").map((function() {
                                            return this.getAttribute("ssrc")
                                        })).get();
                                    t.length && (r += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
                                }));
                                const o = [];
                                $(n).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                    const e = $(this).attr("ssrc");
                                    o.push(e)
                                })), t.media.forEach(((e, t) => {
                                    Fr.findLine(e, `a=mid:${s}`) && (i[t] || (i[t] = ""), o.forEach((n => {
                                        const s = Fr.findLines(e, `a=ssrc:${n}`);
                                        s.length && (i[t] += `${s.join("\r\n")}\r\n`)
                                    })), i[t] += r)
                                }))
                            })), i
                        }
                        _verifyNoSSRCChanged(e, t) {
                            const i = new Vr(this.peerconnection.localDescription.sdp);
                            let n = new jr(t, i);
                            const s = n.getNewMedia();
                            if (Object.keys(s).length) return Vo.error(`${this} - some SSRC were added on ${e}`, s), !1;
                            n = new jr(i, t);
                            const r = n.getNewMedia();
                            return !Object.keys(r).length || (Vo.error(`${this} - some SSRCs were removed on ${e}`, r), !1)
                        }
                        addTrackToPc(e) {
                            return this._addRemoveTrack(!1, e).then((() => {
                                if (e.isVideoTrack()) return this.peerconnection.configureSenderVideoEncodings(e)
                            }))
                        }
                        removeTrackFromPc(e) {
                            return this._addRemoveTrack(!0, e)
                        }
                        _addRemoveTrack(e, t) {
                            if (!t) return Promise.reject('invalid "track" argument value');
                            const i = e ? "removeTrack" : "addTrack",
                                n = n => {
                                    const s = this.peerconnection;
                                    if (!s) return void n(`Error:  tried ${i} track with no active peer connection`);
                                    const r = s.localDescription.sdp;
                                    (e ? s.removeTrackFromPc(t) : s.addTrackToPc(t)).then((e => {
                                        e && r && s.remoteDescription.sdp ? this._renegotiate().then((() => {
                                            !this.usesUnifiedPlan && this._verifyNoSSRCChanged(i, new Vr(r));
                                            const e = s.localDescription.sdp;
                                            this.notifyMySSRCUpdate(new Vr(r), new Vr(e)), n()
                                        })) : n()
                                    }), n)
                                };
                            return Vo.debug(`${this} Queued ${i} task`), new Promise(((e, t) => {
                                this.modificationQueue.push(n, (n => {
                                    n ? (Vo.error(`${this} ${i} failed`), t(n)) : (Vo.debug(`${this} ${i} done`), e())
                                }))
                            }))
                        }
                        setMediaTransferActive(e, t) {
                            if (!this.peerconnection) return Promise.reject('Can not modify transfer active state, before "initialize" is called');
                            const i = e ? "audio active" : "audio inactive",
                                n = t ? "video active" : "video inactive";
                            Vo.info(`${this} Queued make ${n}, ${i} task`);
                            const s = i => {
                                const n = this.state === Oo,
                                    s = this.peerconnection.setAudioTransferActive(e);
                                this._localVideoActive !== t && (this._localVideoActive = t, this.isP2P && n && this.sendContentModify());
                                const r = this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive);
                                n && (s || r) ? this._renegotiate().then(i, i) : i()
                            };
                            return new Promise(((e, t) => {
                                this.modificationQueue.push(s, (s => {
                                    s ? (Vo.error(`${this} Make ${n}, ${i} task failed!`), t(s)) : (Vo.debug(`${this} Make ${n}, ${i} task done!`), e())
                                }))
                            }))
                        }
                        modifyContents(e) {
                            const t = jo.parseVideoSenders(e),
                                i = jo.parseMaxFrameHeight(e),
                                n = jo.parseSourceMaxFrameHeight(e);
                            i && (Vo.info(`${this} received remote max frame height: ${i}`), this.remoteRecvMaxFrameHeight = i, this.eventEmitter.emit(Fo.REMOTE_VIDEO_CONSTRAINTS_CHANGED, this)), n && (this.remoteSourceMaxFrameHeights = n, this.eventEmitter.emit(Fo.REMOTE_SOURCE_CONSTRAINTS_CHANGED, this, n)), null !== t ? (Vo.debug(`${this} queued "content-modify" task(video senders="${t}")`), this.modificationQueue.push((e => {
                                this._assertNotEnded() && this._modifyRemoteVideoActive(t) ? this._renegotiate().then(e, e) : e()
                            }), (e => {
                                e ? Vo.error(`${this} "content-modify" failed`, e) : Vo.debug(`${this} "content-modify" task(video senders="${t}") done`)
                            }))) : Vo.error(`${this} - failed to parse video "senders" attribute in "content-modify" action`)
                        }
                        _modifyRemoteVideoActive(e) {
                            const t = "both" === e || "initiator" === e && this.isInitiator || "responder" === e && !this.isInitiator;
                            return t !== this._remoteVideoActive && (Vo.debug(`${this} new remote video active: ${t}`), this._remoteVideoActive = t), this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive)
                        }
                        notifyMySSRCUpdate(e, t) {
                            if (this.state !== Oo) return void Vo.warn(`${this} Skipping SSRC update in '${this.state} ' state.`);
                            if (!this.connection.connected) return this._cachedOldLocalSdp || (this._cachedOldLocalSdp = e), this._cachedNewLocalSdp = t, void Vo.warn(`${this} Not sending SSRC update while the signaling is disconnected`);
                            this._cachedOldLocalSdp = void 0, this._cachedNewLocalSdp = void 0;
                            const i = e => {
                                const t = e.getNewMedia();
                                let i = [],
                                    n = null;
                                return Object.keys(t).forEach((e => {
                                    const s = Object.keys(t[e].ssrcs);
                                    n = t[e].mid, null != s && s.length && (i = i.concat(s))
                                })), {
                                    mediaType: n,
                                    ssrcs: i
                                }
                            };
                            let n = new jr(t, e);
                            const s = (0, ut.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "source-remove",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            });
                            n.toJingle(s);
                            const r = {},
                                o = i(n);
                            o.ssrcs.length && (Vo.info(`${this} Sending source-remove for ${o.mediaType} ssrcs=${o.ssrcs}`), this.connection.sendIQ(s, (() => {
                                this.room.eventEmitter.emit(Nn.XMPPEvents.SOURCE_REMOVE, this, r)
                            }), this.newJingleErrorHandler(s, (e => {
                                this.room.eventEmitter.emit(Nn.XMPPEvents.SOURCE_REMOVE_ERROR, this, e, r)
                            })), Uo)), n = new jr(e, t);
                            const a = (0, ut.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "source-add",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            });
                            n.toJingle(a);
                            const c = i(n);
                            c.ssrcs.length && (Vo.info(`${this} Sending source-add for ${c.mediaType} ssrcs=${c.ssrcs}`), this.connection.sendIQ(a, (() => {
                                this.room.eventEmitter.emit(Nn.XMPPEvents.SOURCE_ADD, this, r)
                            }), this.newJingleErrorHandler(a, (e => {
                                this.room.eventEmitter.emit(Nn.XMPPEvents.SOURCE_ADD_ERROR, this, e, c.mediaType, r)
                            })), Uo))
                        }
                        newJingleErrorHandler(e, t) {
                            return e => {
                                const i = {},
                                    n = $(e).find("error");
                                if (n.length) {
                                    i.code = n.attr("code");
                                    const t = $(e).find("error :first");
                                    t.length && (i.reason = t[0].tagName);
                                    const s = n.find(">text");
                                    s.length && (i.msg = s.text())
                                }
                                e || (i.reason = "timeout"), i.session = this.toString(), t ? t(i) : this.state === wo && "item-not-found" === i.reason ? Vo.debug(`${this} Jingle error: ${JSON.stringify(i)}`) : Gi().callErrorHandler(new Error(`Jingle error: ${JSON.stringify(i)}`))
                            }
                        }
                        getIceConnectionState() {
                            return this.peerconnection.getConnectionState()
                        }
                        close() {
                            this.state = wo, this.establishmentDuration = void 0, this.peerconnection && (this.peerconnection.onicecandidate = null, this.peerconnection.oniceconnectionstatechange = null, this.peerconnection.onnegotiationneeded = null, this.peerconnection.onsignalingstatechange = null), Vo.debug(`${this} Clearing modificationQueue`), this.modificationQueue.clear(), Vo.debug(`${this} Queued PC close task`), this.modificationQueue.push((e => {
                                this.peerconnection && this.peerconnection.close(), e(), Vo.debug(`${this} PC close task done!`)
                            })), Vo.debug(`${this} Shutdown modificationQueue!`), this.modificationQueue.shutdown()
                        }
                        toString() {
                            return `JingleSessionPC[session=${this.isP2P?"P2P":"JVB"},initiator=${this.isInitiator},sid=${this.sid}]`
                        }
                        _abtestSuspendVideoEnabled(e) {
                            let {
                                abTesting: t
                            } = e;
                            if (!t || !t.enableSuspendVideoTest) return;
                            const i = this._getInitiatorJid();
                            return (0, No.integerHash)(i) % 2 == 0
                        }
                    }
                    const $o = (0, v.getLogger)("modules/xmpp/strophe.jingle.js");

                    function Ho(e) {
                        const t = $(e).find(">candidate"),
                            i = [];
                        return t.each(((e, t) => {
                            const n = t.attributes,
                                s = [];
                            for (let e = 0; e < n.length; e++) {
                                const t = n[e];
                                s.push(`${t.name}: ${t.value}`)
                            }
                            i.push(s.join(" "))
                        })), i
                    }
                    class Bo extends ks {
                        constructor(e, t, i) {
                            super(), this.xmpp = e, this.eventEmitter = t, this.sessions = {}, this.jvbIceConfig = i.jvb, this.p2pIceConfig = i.p2p, this.mediaConstraints = {
                                offerToReceiveAudio: !0,
                                offerToReceiveVideo: !0
                            }
                        }
                        init(e) {
                            super.init(e), this.connection.addHandler(this.onJingle.bind(this), "urn:xmpp:jingle:1", "iq", "set", null, null)
                        }
                        onJingle(e) {
                            const t = $(e).find("jingle").attr("sid"),
                                i = $(e).find("jingle").attr("action"),
                                n = e.getAttribute("from"),
                                s = (0, ut.$iq)({
                                    type: "result",
                                    to: n,
                                    id: e.getAttribute("id")
                                });
                            let r = this.sessions[t];
                            if ("session-initiate" !== i) {
                                if (!r) return s.attrs({
                                    type: "error"
                                }), s.c("error", {
                                    type: "cancel"
                                }).c("item-not-found", {
                                    xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                                }).up().c("unknown-session", {
                                    xmlns: "urn:xmpp:jingle:errors:1"
                                })/* BAO breaking, $o.warn(`invalid session id: ${t}`), $o.debug(e), this.connection.send(s), !0; */
                                if (n !== r.remoteJid) return $o.warn("jid mismatch for session id", t, r.remoteJid, e), s.attrs({
                                    type: "error"
                                }), s.c("error", {
                                    type: "cancel"
                                }).c("item-not-found", {
                                    xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                                }).up().c("unknown-session", {
                                    xmlns: "urn:xmpp:jingle:errors:1"
                                }), this.connection.send(s), !0
                            } else if (void 0 !== r) return s.attrs({
                                type: "error"
                            }), s.c("error", {
                                type: "cancel"
                            }).c("service-unavailable", {
                                xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                            }).up(), $o.warn("duplicate session id", t, e), this.connection.send(s), !0;
                            const o = window.performance.now(),
                                a = "focus" !== ut.Strophe.getResourceFromJid(n),
                                c = $(e).find("jingle>json-message");
                            if (null != c && c.length) {
                                var d;
                                let t;
                                $o.info(`Found a JSON-encoded element in ${i}, translating to standard Jingle.`);
                                for (let i = 0; i < c.length; i++) t = Rr(e, c[i]);
                                if (null !== (d = t) && void 0 !== d && d.size) {
                                    const e = [];
                                    for (const i of t.keys()) e.push(`${i}:[${t.get(i)}]`);
                                    $o.debug(`Received ${i} from ${n} with sources=${e.join(", ")}`)
                                }
                            }
                            switch (i) {
                                case "session-initiate": {
                                    $o.log("(TIME) received session-initiate:\t", o);
                                    const t = $(e).find("jingle>startmuted");
                                    if (a && $o.debug(`Received ${i} from ${n}`), null != t && t.length) {
                                        const e = t.attr(dn.AUDIO),
                                            i = t.attr(dn.VIDEO);
                                        this.eventEmitter.emit(Nn.XMPPEvents.START_MUTED_FROM_FOCUS, "true" === e, "true" === i)
                                    }
                                    const s = a ? this.p2pIceConfig : this.jvbIceConfig;
                                    r = new jo($(e).find("jingle").attr("sid"), $(e).attr("to"), n, this.connection, this.mediaConstraints, JSON.parse(JSON.stringify(s)), a, !1), this.sessions[r.sid] = r, this.eventEmitter.emit(Nn.XMPPEvents.CALL_INCOMING, r, $(e).find(">jingle"), o);
                                    break
                                }
                                case "session-accept": {
                                    const t = [],
                                        s = $(e).find("jingle>content");
                                    for (const e of s) {
                                        const i = $(e).find("description").attr("ssrc");
                                        i && t.push(i)
                                    }
                                    $o.debug(`Received ${i} from ${n} with ssrcs=${t}`), this.eventEmitter.emit(Nn.XMPPEvents.CALL_ACCEPTED, r, $(e).find(">jingle"));
                                    break
                                }
                                case "content-modify": {
                                    const t = $(e).find('jingle>content[name="video"]>max-frame-height');
                                    $o.debug(`Received ${i} from ${n} with a max-frame-height=${null==t?void 0:t.text()}`), r.modifyContents($(e).find(">jingle"));
                                    break
                                }
                                case "transport-info": {
                                    const t = Ho($(e).find("jingle>content>transport"));
                                    $o.debug(`Received ${i} from ${n} for candidates=${t.join(", ")}`), this.eventEmitter.emit(Nn.XMPPEvents.TRANSPORT_INFO, r, $(e).find(">jingle"));
                                    break
                                }
                                case "session-terminate": {
                                    $o.log("terminating...", r.sid);
                                    let t = null,
                                        s = null;
                                    $(e).find(">jingle>reason").length && (t = $(e).find(">jingle>reason>:first")[0].tagName, s = $(e).find(">jingle>reason>text").text()), $o.debug(`Received ${i} from ${n} disconnect reason=${s}`), this.terminate(r.sid, t, s), this.eventEmitter.emit(Nn.XMPPEvents.CALL_ENDED, r, t, s);
                                    break
                                }
                                case "transport-replace": {
                                    var l;
                                    $o.info("(TIME) Start transport replace:\t", o);
                                    const t = $(e).find("jingle>content>transport"),
                                        s = Ho(t),
                                        c = $(t).attr("ufrag"),
                                        d = $(t).attr("pwd"),
                                        h = null === (l = $(t).find(">fingerprint")) || void 0 === l ? void 0 : l.text();
                                    $o.debug(`Received ${i} from ${n} with iceUfrag=${c}, icePwd=${d}, DTLS fingerprint=${h}, candidates=${s.join(", ")}`), Tn.sendAnalytics(ui(Xt, {
                                        p2p: a,
                                        value: o
                                    })), r.replaceTransport($(e).find(">jingle"), (() => {
                                        const e = window.performance.now();
                                        $o.info("(TIME) Transport replace success:\t", e), Tn.sendAnalytics(ui(zt, {
                                            p2p: a,
                                            value: e
                                        }))
                                    }), (e => {
                                        Gi().callErrorHandler(e), $o.error("Transport replace failed", e), r.sendTransportReject()
                                    }));
                                    break
                                }
                                case "source-add":
                                    r.addRemoteStream($(e).find(">jingle>content"));
                                    break;
                                case "source-remove":
                                    r.removeRemoteStream($(e).find(">jingle>content"));
                                    break;
                                default:
                                    $o.warn("jingle action not implemented", i), s.attrs({
                                        type: "error"
                                    }), s.c("error", {
                                        type: "cancel"
                                    }).c("bad-request", {
                                        xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                                    }).up()
                            }
                            return this.connection.send(s), !0
                        }
                        newP2PJingleSession(e, t) {
                            const i = new jo(Ts().randomHexString(12), e, t, this.connection, this.mediaConstraints, this.p2pIceConfig, !0, !0);
                            return this.sessions[i.sid] = i, i
                        }
                        terminate(e, t, i) {
                            this.sessions.hasOwnProperty(e) && ("ended" !== this.sessions[e].state && this.sessions[e].onTerminated(t, i), delete this.sessions[e])
                        }
                        getStunAndTurnCredentials() {
                            this.connection.sendIQ((0, ut.$iq)({
                                type: "get",
                                to: this.xmpp.options.hosts.domain
                            }).c("services", {
                                xmlns: "urn:xmpp:extdisco:2"
                            }), (e => this.onReceiveStunAndTurnCredentials(e)), (() => {
                                $o.warn("getting turn credentials with extdisco:2 failed, trying extdisco:1"), this.connection.sendIQ((0, ut.$iq)({
                                    type: "get",
                                    to: this.xmpp.options.hosts.domain
                                }).c("services", {
                                    xmlns: "urn:xmpp:extdisco:1"
                                }), (e => this.onReceiveStunAndTurnCredentials(e)), (() => {
                                    $o.warn("getting turn credentials failed"), $o.warn("is mod_turncredentials or similar installed and configured?")
                                }))
                            }))
                        }
                        onReceiveStunAndTurnCredentials(e) {
                            const t = [];
                            $(e).find(">services>service").each(((e, i) => {
                                const n = {},
                                    s = (i = $(i)).attr("type");
                                switch (s) {
                                    case "stun":
                                        n.urls = `stun:${i.attr("host")}`, i.attr("port") && (n.urls += `:${i.attr("port")}`), t.push(n);
                                        break;
                                    case "turn":
                                    case "turns": {
                                        n.urls = `${s}:`, n.username = i.attr("username"), n.urls += i.attr("host"), i.attr("port") && (n.urls += `:${i.attr("port")}`);
                                        const e = i.attr("transport");
                                        e && "udp" !== e && (n.urls += `?transport=${e}`), n.credential = i.attr("password") || n.credential, t.push(n);
                                        break
                                    }
                                }
                            }));
                            const i = this.xmpp.options;
                            for (let e = t.length - 1; e > 0; e--) {
                                const i = Math.floor(Math.random() * (e + 1)),
                                    n = t[e];
                                t[e] = t[i], t[i] = n
                            }
                            let n;
                            return n = i.useTurnUdp ? e => e.urls.startsWith("turn") : e => e.urls.startsWith("turn") && e.urls.indexOf("transport=tcp") >= 0, this.jvbIceConfig.iceServers = t.filter(n), this.p2pIceConfig.iceServers = t, t.length > 0
                        }
                        getLog() {
                            const e = {};
                            return Object.keys(this.sessions).forEach((t => {
                                const i = this.sessions[t].peerconnection;
                                i && i.updateLog && (e[`jingle_${t}`] = {
                                    updateLog: i.updateLog,
                                    stats: i.stats,
                                    url: window.location.href
                                })
                            })), e
                        }
                    }
                    class Jo extends ks {
                        constructor() {
                            super(), this.log = []
                        }
                        init(e) {
                            super.init(e), this.connection.rawInput = this.logIncoming.bind(this), this.connection.rawOutput = this.logOutgoing.bind(this)
                        }
                        logIncoming(e) {
                            this.log.push([(new Date).getTime(), "incoming", e])
                        }
                        logOutgoing(e) {
                            this.log.push([(new Date).getTime(), "outgoing", e])
                        }
                    }
                    const Go = (0, v.getLogger)("modules/xmpp/strophe.rayo.js"),
                        Ko = "urn:xmpp:rayo:1";
                    class qo extends ks {
                        init(e) {
                            super.init(e), this.connection.addHandler(this.onRayo.bind(this), Ko, "iq", "set", null, null)
                        }
                        onRayo(e) {
                            Go.info("Rayo IQ", e)
                        }
                        dial(e, t, i, n, s) {
                            return new Promise(((r, o) => {
                                if (!s) return void o(new Error("Internal error!"));
                                const a = (0, ut.$iq)({
                                    type: "set",
                                    to: s
                                });
                                a.c("dial", {
                                    xmlns: Ko,
                                    to: e,
                                    from: t
                                }), a.c("header", {
                                    name: "JvbRoomName",
                                    value: i
                                }).up(), n && n.length && a.c("header", {
                                    name: "JvbRoomPassword",
                                    value: n
                                }).up(), this.connection.sendIQ(a, (e => {
                                    Go.info("Dial result ", e);
                                    const t = $(e).find("ref").attr("uri");
                                    this.callResource = t.substr("xmpp:".length), Go.info(`Received call resource: ${this.callResource}`), r()
                                }), (e => {
                                    Go.info("Dial error ", e), o(e)
                                }))
                            }))
                        }
                        hangup() {
                            return new Promise(((e, t) => {
                                if (!this.callResource) return t(new Error("No call in progress")), void Go.warn("No call in progress");
                                const i = (0, ut.$iq)({
                                    type: "set",
                                    to: this.callResource
                                });
                                i.c("hangup", {
                                    xmlns: Ko
                                }), this.connection.sendIQ(i, (t => {
                                    Go.info("Hangup result ", t), this.callResource = null, e()
                                }), (e => {
                                    Go.info("Hangup error ", e), this.callResource = null, t(new Error("Hangup error "))
                                }))
                            }))
                        }
                    }
                    const Wo = (0, v.getLogger)("modules/xmpp/strophe.util.js");
                    let Xo = -1;
                    const zo = /request id \d+.\d+ got 200/,
                        Qo = /request errored, status: (\d+), number of errors: \d+/,
                        Yo = (0, v.getLogger)("modules/xmpp/xmpp.js"),
                        Zo = /<failure.*><not-allowed\/><text>(.*)<\/text><\/failure>/gi;
                    const ea = [{
                            urls: "stun:meet-jit-si-turnrelay.jitsi.net:443"
                        }],
                        ta = "type",
                        ia = "http://jitsi.org/protocol/jigasi",
                        na = "https://jitsi.org/meet/e2ee";
                    class sa extends Wn {
                        constructor(e, t) {
                            super(), this.connection = null, this.disconnectInProgress = !1, this.connectionTimes = {}, this.options = e, this.token = t, this.authenticatedUser = !1, this.options.deploymentInfo || (this.options.deploymentInfo = {}), ut.Strophe.log = function(e, t) {
                                switch (Wo.trace("Strophe", e, t), "string" == typeof t && -1 !== t.indexOf("Request ") && -1 !== t.indexOf("timed out (secondary), restarting") && (e = ut.Strophe.LogLevel.WARN), e) {
                                    case ut.Strophe.LogLevel.DEBUG:
                                        -1 !== Xo && zo.test(t) && (Wo.debug("Reset lastErrorStatus"), Xo = -1);
                                        break;
                                    case ut.Strophe.LogLevel.WARN:
                                        Wo.warn(`Strophe: ${t}`);
                                        const e = Qo.exec(t);
                                        e && 2 === e.length && (Xo = parseInt(e[1], 10), Wo.debug(`lastErrorStatus set to: ${Xo}`));
                                        break;
                                    case ut.Strophe.LogLevel.ERROR:
                                    case ut.Strophe.LogLevel.FATAL:
                                        t = `Strophe: ${t}`, Gi().callErrorHandler(new Error(t)), Wo.error(t)
                                }
                            }, ut.Strophe.getLastErrorStatus = function() {
                                return Xo
                            }, ut.Strophe.getStatusString = function(e) {
                                switch (e) {
                                    case ut.Strophe.Status.BINDREQUIRED:
                                        return "BINDREQUIRED";
                                    case ut.Strophe.Status.ERROR:
                                        return "ERROR";
                                    case ut.Strophe.Status.CONNECTING:
                                        return "CONNECTING";
                                    case ut.Strophe.Status.CONNFAIL:
                                        return "CONNFAIL";
                                    case ut.Strophe.Status.AUTHENTICATING:
                                        return "AUTHENTICATING";
                                    case ut.Strophe.Status.AUTHFAIL:
                                        return "AUTHFAIL";
                                    case ut.Strophe.Status.CONNECTED:
                                        return "CONNECTED";
                                    case ut.Strophe.Status.DISCONNECTED:
                                        return "DISCONNECTED";
                                    case ut.Strophe.Status.DISCONNECTING:
                                        return "DISCONNECTING";
                                    case ut.Strophe.Status.ATTACHED:
                                        return "ATTACHED";
                                    default:
                                        return "unknown"
                                }
                            }, ut.Strophe.addConnectionPlugin("logger", new Jo);
                            const i = e.xmppPing || {};
                            i.domain = e.hosts.domain, this.connection = function(e) {
                                let {
                                    enableWebsocketResume: t,
                                    serviceUrl: i = "/http-bind",
                                    shard: n,
                                    token: s,
                                    websocketKeepAlive: r,
                                    websocketKeepAliveUrl: o,
                                    xmppPing: a
                                } = e;
                                return s && (i += `${-1===i.indexOf("?")?"?":"&"}token=${s}`), new js({
                                    enableWebsocketResume: t,
                                    serviceUrl: i,
                                    websocketKeepAlive: r,
                                    websocketKeepAliveUrl: o,
                                    xmppPing: a,
                                    shard: n
                                })
                            }({
                                enableWebsocketResume: e.enableWebsocketResume,
                                serviceUrl: e.serviceUrl || e.bosh,
                                token: t,
                                websocketKeepAlive: e.websocketKeepAlive,
                                websocketKeepAliveUrl: e.websocketKeepAliveUrl,
                                xmppPing: i,
                                shard: e.deploymentInfo.shard
                            }), this.connection.on(js.Events.CONN_SHARD_CHANGED, (() => {
                                const e = {
                                    shard_changed: !0,
                                    suspend_time: this.connection.ping.getPingSuspendTime(),
                                    time_since_last_success: this.connection.getTimeSinceLastSuccess()
                                };
                                this.eventEmitter.emit(Un, Jn, void 0, void 0, e)
                            })), this._initStrophePlugins(), this.caps = new Ps(this.connection, "https://jitsi.org/jitsi-meet"), this.initFeaturesList(), $(window).on((this.options.disableBeforeUnloadHandlers ? "" : "beforeunload ") + "unload", (e => {
                                this.disconnect(e).catch((() => {}))
                            }))
                        }
                        initFeaturesList() {
                            this.caps.addFeature("urn:xmpp:jingle:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:1"), this.caps.addFeature("urn:xmpp:jingle:transports:ice-udp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:dtls:0"), this.caps.addFeature("urn:xmpp:jingle:transports:dtls-sctp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:audio"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:video"), this.caps.addFeature("http://jitsi.org/json-encoded-sources"), !this.options.disableRtx && Ui.supportsRTX() && this.caps.addFeature("urn:ietf:rfc:4588"), !0 === this.options.enableOpusRed && Ui.supportsAudioRed() && this.caps.addFeature("http://jitsi.org/opus-red"), (void 0 === this.options.enableRemb || this.options.enableRemb) && this.caps.addFeature("http://jitsi.org/remb"), Ui.isFirefox() || void 0 !== this.options.enableTcc && !this.options.enableTcc || this.caps.addFeature("http://jitsi.org/tcc"), Ui.isChromiumBased() && !0 === this.options.enableLipSync && (Yo.info("Lip-sync enabled !"), this.caps.addFeature("http://jitsi.org/meet/lipsync")), this.connection.rayo && this.caps.addFeature("urn:xmpp:rayo:client:1"), Es.isSupported(this.options) && this.caps.addFeature(na, !1, !0), hn.isSourceNameSignalingEnabled() && (Yo.info("Source-name signaling is enabled"), this.caps.addFeature("http://jitsi.org/source-name")), hn.isReceiveMultipleVideoStreamsSupported() && (Yo.info("Receiving multiple video streams is enabled"), this.caps.addFeature("http://jitsi.org/receive-multiple-video-streams")), hn.isSsrcRewritingSupported() && (Yo.info("SSRC rewriting is supported"), this.caps.addFeature("http://jitsi.org/ssrc-rewriting"))
                        }
                        getConnection() {
                            return this.connection
                        }
                        connectionHandler() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                                t = arguments.length > 1 ? arguments[1] : void 0,
                                i = arguments.length > 2 ? arguments[2] : void 0;
                            const n = window.performance.now(),
                                s = ut.Strophe.getStatusString(t).toLowerCase();
                            if (this.connectionTimes[s] = n, Yo.log(`(TIME) Strophe ${s}${i?`[${i}]`:""}:\t`, n), this.eventEmitter.emit(Nn.XMPPEvents.CONNECTION_STATUS_CHANGED, e, t, i), this._maybeSendDeploymentInfoStat(), t === ut.Strophe.Status.CONNECTED || t === ut.Strophe.Status.ATTACHED) this._sysMessageHandler && (this.connection._stropheConn.deleteHandler(this._sysMessageHandler), this._sysMessageHandler = null), this.sendDiscoInfo && this.connection.jingle.getStunAndTurnCredentials(), Yo.info(`My Jabber ID: ${this.connection.jid}`), this._resetState(), this.sendDeploymentInfo = !1, this.sendDiscoInfo && this.caps.getFeaturesAndIdentities(this.options.hosts.domain).then((e => {
                                let {
                                    features: t,
                                    identities: i
                                } = e;
                                t.has(ut.Strophe.NS.PING) || Yo.error(`Ping NOT supported by ${this.options.hosts.domain} - please enable ping in your XMPP server config`), this._processDiscoInfoIdentities(i, void 0)
                            })).catch((e => {
                                const t = "Feature discovery error";
                                Gi().callErrorHandler(new Error(`${t}: ${e}`)), Yo.error(t, e), this._maybeSendDeploymentInfoStat(!0)
                            })), this.sendDiscoInfo = !1, e.password && (this.authenticatedUser = !0), this.connection && this.connection.connected && ut.Strophe.getResourceFromJid(this.connection.jid) && this.eventEmitter.emit(Vn, ut.Strophe.getResourceFromJid(this.connection.jid));
                            else if (t === ut.Strophe.Status.CONNFAIL) "x-strophe-bad-non-anon-jid" === i ? this.anonymousConnectionFailed = !0 : this.connectionFailed = !0, this.lastErrorMsg = i, "giving-up" === i && this.eventEmitter.emit(Un, Jn, i);
                            else if (t === ut.Strophe.Status.ERROR) this.lastErrorMsg = i;
                            else if (t === ut.Strophe.Status.DISCONNECTED) {
                                this.connection.ping.stopInterval();
                                const e = Boolean(this.disconnectInProgress),
                                    t = i || this.lastErrorMsg;
                                if (this.anonymousConnectionFailed) this.eventEmitter.emit(Un, Gn);
                                else if (this.connectionFailed) this.eventEmitter.emit(Un, Jn, t, void 0, this._getConnectionFailedReasonDetails());
                                else if (e) this.eventEmitter.emit(Fn, t);
                                else {
                                    Yo.error("XMPP connection dropped!");
                                    const e = ut.Strophe.getLastErrorStatus();
                                    e >= 500 && e < 600 ? this.eventEmitter.emit(Un, Kn, t || "server-error", void 0, this._getConnectionFailedReasonDetails()) : this.eventEmitter.emit(Un, Bn, t || "connection-dropped-error", void 0, this._getConnectionFailedReasonDetails())
                                }
                            } else if (t === ut.Strophe.Status.AUTHFAIL) {
                                const t = this.getConnection().getLastFailedMessage();
                                this.eventEmitter.emit(Un, Gn, i || this._parseConnectionFailedMessage(t), e)
                            }
                        }
                        _processDiscoInfoIdentities(e, t) {
                            e.forEach((e => {
                                if ("av_moderation" === e.type && (this.avModerationComponentAddress = e.name), "speakerstats" === e.type && (this.speakerStatsComponentAddress = e.name), "conference_duration" === e.type && (this.conferenceDurationComponentAddress = e.name), "lobbyrooms" === e.type) {
                                    this.lobbySupported = !0;
                                    const i = e => {
                                        e.forEach((e => {
                                            e.endsWith("#displayname_required") && this.eventEmitter.emit($n)
                                        }))
                                    };
                                    t ? i(t) : e.name && this.caps.getFeaturesAndIdentities(e.name, e.type).then((e => {
                                        let {
                                            features: t
                                        } = e;
                                        return i(t)
                                    })).catch((e => Yo.warn("Error getting features from lobby.", e && e.message)))
                                }
                                "shard" === e.type && (this.options.deploymentInfo.shard = this.connection.shard = e.name), "region" === e.type && (this.options.deploymentInfo.region = this.connection.region = e.name), "release" === e.type && (this.options.deploymentInfo.backendRelease = e.name), "breakout_rooms" === e.type && (this.breakoutRoomsComponentAddress = e.name)
                            })), this._maybeSendDeploymentInfoStat(!0), (this.avModerationComponentAddress || this.speakerStatsComponentAddress || this.conferenceDurationComponentAddress || this.breakoutRoomsComponentAddress) && this.connection.addHandler(this._onPrivateMessage.bind(this), null, "message", null, null)
                        }
                        _parseConnectionFailedMessage(e) {
                            if (!e) return null;
                            const t = Zo.exec(e);
                            return t ? t[1] : null
                        }
                        _connect(e, t) {
                            this._resetState(), this.sendDiscoInfo = !0, this.sendDeploymentInfo = !0, this.connection._stropheConn && this.connection._stropheConn._addSysHandler ? this._sysMessageHandler = this.connection._stropheConn._addSysHandler(this._onSystemMessage.bind(this), null, "message") : Yo.warn("Cannot attach strophe system handler, jiconop cannot operate"), this.connection.connect(e, t, this.connectionHandler.bind(this, {
                                jid: e,
                                password: t
                            }))
                        }
                        _onSystemMessage(e) {
                            if (0 === $(e).find(">services").length && 0 === $(e).find(">query").length) return;
                            this.sendDiscoInfo = !1;
                            const t = this.connection.jingle.onReceiveStunAndTurnCredentials(e),
                                {
                                    features: i,
                                    identities: n
                                } = As(e);
                            this._processDiscoInfoIdentities(n, i), (t || n.size > 0 || i.size > 0) && (this.connection._stropheConn.deleteHandler(this._sysMessageHandler), this._sysMessageHandler = null)
                        }
                        attach(e) {
                            this._resetState(), this.sendDiscoInfo = !0;
                            const t = this.connectionTimes.attaching = window.performance.now();
                            Yo.log("(TIME) Strophe Attaching:\t", t), this.connection.attach(e.jid, e.sid, parseInt(e.rid, 10) + 1, this.connectionHandler.bind(this, {
                                jid: e.jid,
                                password: e.password
                            }))
                        }
                        _resetState() {
                            this.anonymousConnectionFailed = !1, this.connectionFailed = !1, this.lastErrorMsg = void 0, this.disconnectInProgress = void 0
                        }
                        connect(e, t) {
                            if (!e) {
                                const {
                                    anonymousdomain: t,
                                    domain: i
                                } = this.options.hosts;
                                let n = t || i;
                                const {
                                    location: s
                                } = window;
                                if (t) {
                                    const e = s && s.search;
                                    (e && -1 !== e.indexOf("login=true") || this.token) && (n = i)
                                }
                                e = n || s && s.hostname
                            }
                            return this._connect(e, t)
                        }
                        createRoom(e, t, i) {
                            const n = e.domain || t.customDomain;
                            let s = `${this.getRoomJid(e,n)}/`;
                            const r = i ? i(this.connection.jid, this.authenticatedUser) : Ts().randomHexString(8).toLowerCase();
                            return Yo.info(`JID ${this.connection.jid} using MUC nickname ${r}`), s += r, this.connection.emuc.createRoom(s, null, t)
                        }
                        getRoomJid(e, t) {
                            return `${e}@${t||this.options.hosts.muc.toLowerCase()}`
                        }
                        isRoomCreated(e, t) {
                            return this.connection.emuc.isRoomCreated(this.getRoomJid(e, t))
                        }
                        getJid() {
                            return this.connection.jid
                        }
                        getJingleLog() {
                            const e = this.connection.jingle;
                            return e ? e.getLog() : {}
                        }
                        getXmppLog() {
                            return (this.connection.logger || {}).log || null
                        }
                        dial() {
                            this.connection.rayo.dial(...arguments)
                        }
                        ping(e) {
                            return new Promise(((t, i) => {
                                this.connection.ping.ping(this.connection.pingDomain, t, i, e)
                            }))
                        }
                        getSessions() {
                            return this.connection.jingle.sessions
                        }
                        disconnect(e) {
                            return this.disconnectInProgress ? this.disconnectInProgress : this.connection ? (this.disconnectInProgress = new Promise((e => {
                                const t = (i, n) => {
                                    n === ut.Strophe.Status.DISCONNECTED && (e(), this.eventEmitter.removeListener(Nn.XMPPEvents.CONNECTION_STATUS_CHANGED, t))
                                };
                                this.eventEmitter.on(Nn.XMPPEvents.CONNECTION_STATUS_CHANGED, t)
                            })), this._cleanupXmppConnection(e), this.disconnectInProgress) : Promise.resolve()
                        }
                        _cleanupXmppConnection(e) {
                            if (!this.connection.isUsingWebSocket && this.connection.flush(), !this.connection.isUsingWebSocket && null != e) {
                                const t = e.type;
                                if (("beforeunload" === t || "unload" === t) && (this.connection.options.sync = !0, this.connection.sendUnavailableBeacon())) return
                            }
                            this.connection.disconnect(), !0 !== this.connection.options.sync && this.connection.flush()
                        }
                        _initStrophePlugins() {
                            const e = {
                                    jvb: {
                                        iceServers: []
                                    },
                                    p2p: {
                                        iceServers: []
                                    }
                                },
                                t = this.options.p2p && this.options.p2p.stunServers || ea;
                            Array.isArray(t) && (Yo.info("P2P STUN servers: ", t), e.p2p.iceServers = t), this.options.p2p && this.options.p2p.iceTransportPolicy && (Yo.info("P2P ICE transport policy: ", this.options.p2p.iceTransportPolicy), e.p2p.iceTransportPolicy = this.options.p2p.iceTransportPolicy), this.connection.addConnectionPlugin("emuc", new Er(this)), this.connection.addConnectionPlugin("jingle", new Bo(this, this.eventEmitter, e)), this.connection.addConnectionPlugin("rayo", new qo)
                        }
                        _getConnectionFailedReasonDetails() {
                            const e = {};
                            if (this.options.deploymentInfo && this.options.deploymentInfo.shard && this.connection.lastResponseHeaders) {
                                const t = this.connection.lastResponseHeaders.trim().split(/[\r\n]+/),
                                    i = {};
                                t.forEach((e => {
                                    const t = e.split(": "),
                                        n = t.shift(),
                                        s = t.join(": ");
                                    i[n] = s
                                })), e.shard_changed = this.options.deploymentInfo.shard !== i["x-jitsi-shard"]
                            }
                            return e.suspend_time = this.connection.ping.getPingSuspendTime(), e.time_since_last_success = this.connection.getTimeSinceLastSuccess(), e
                        }
                        sendDominantSpeakerEvent(e) {
                            if (!this.speakerStatsComponentAddress || !e) return;
                            const t = (0, ut.$msg)({
                                to: this.speakerStatsComponentAddress
                            });
                            t.c("speakerstats", {
                                xmlns: "http://jitsi.org/jitmeet",
                                room: e
                            }).up(), this.connection.send(t)
                        }
                        sendFaceExpressionEvent(e, t) {
                            if (!this.speakerStatsComponentAddress || !e) return;
                            const i = (0, ut.$msg)({
                                to: this.speakerStatsComponentAddress
                            });
                            i.c("faceExpression", {
                                xmlns: "http://jitsi.org/jitmeet",
                                room: e,
                                expression: t.faceExpression,
                                duration: t.duration
                            }).up(), this.connection.send(i)
                        }
                        tryParseJSONAndVerify(e) {
                            if (!e) return !1;
                            try {
                                const t = JSON.parse(e);
                                if (t && "object" == typeof t) {
                                    const e = t[ta];
                                    if (void 0 !== e) return t;
                                    Yo.debug("parsing valid json but does not have correct structure", "topic: ", e)
                                }
                            } catch (t) {
                                return Yo.error(`Error parsing json ${e}`, t), !1
                            }
                            return !1
                        }
                        _onPrivateMessage(e) {
                            const t = e.getAttribute("from");
                            if (t !== this.speakerStatsComponentAddress && t !== this.conferenceDurationComponentAddress && t !== this.avModerationComponentAddress && t !== this.breakoutRoomsComponentAddress) return !0;
                            const i = $(e).find(">json-message").text(),
                                n = this.tryParseJSONAndVerify(i);
                            return !n || ("speakerstats" === n[ta] && n.users ? this.eventEmitter.emit(Nn.XMPPEvents.SPEAKER_STATS_RECEIVED, n.users) : "conference_duration" === n[ta] && n.created_timestamp ? this.eventEmitter.emit(Nn.XMPPEvents.CONFERENCE_TIMESTAMP_RECEIVED, n.created_timestamp) : "av_moderation" === n[ta] ? this.eventEmitter.emit(Nn.XMPPEvents.AV_MODERATION_RECEIVED, n) : "breakout_rooms" === n[ta] && this.eventEmitter.emit(Nn.XMPPEvents.BREAKOUT_ROOMS_EVENT, n), !0)
                        }
                        _maybeSendDeploymentInfoStat(e) {
                            const t = [ut.Strophe.Status.ERROR, ut.Strophe.Status.CONNFAIL, ut.Strophe.Status.AUTHFAIL, ut.Strophe.Status.DISCONNECTED, ut.Strophe.Status.CONNTIMEOUT];
                            if (!(e || t.includes(this.connection.status) && this.sendDeploymentInfo)) return;
                            const i = this.options.deploymentInfo;
                            if (i && Object.keys(i).length > 0) {
                                const e = {};
                                for (const t in i) i.hasOwnProperty(t) && (e[t] = i[t]);
                                Tn.analytics.addPermanentProperties({
                                    ...e
                                }), e.id = "deployment_info", Tn.sendLog(JSON.stringify(e))
                            }
                            this.sendDeploymentInfo = !1
                        }
                    }

                    function ra(e) {
                        let t, {
                                id: i,
                                password: n,
                                onCreateResource: s,
                                onLoginSuccessful: r
                            } = e,
                            o = !1,
                            a = new sa(this.connection.options);
                        const c = new Promise(((e, c) => {
                            t = c, a.addListener(Fn, (() => {
                                a = void 0
                            })), a.addListener(Vn, (() => {
                                o || (r && r(), a.createRoom(this.options.name, this.options.config, s).moderator.authenticate().then((() => {
                                    a && a.disconnect(), o || (this.room.moderator.allocateConferenceFocus(), e())
                                })).catch((e => {
                                    let {
                                        error: t,
                                        message: i
                                    } = e;
                                    a.disconnect(), c({
                                        authenticationError: t,
                                        message: i
                                    })
                                })))
                            })), a.addListener(Un, ((e, t, i) => {
                                c({
                                    connectionError: e,
                                    credentials: i,
                                    message: t
                                }), a = void 0
                            })), o || a.connect(i, n)
                        }));
                        return c.cancel = () => {
                            o = !0, t({}), a && a.disconnect()
                        }, c
                    }
                    const oa = (0, v.getLogger)("modules/RTC/CodecSelection.js");
                    class aa {
                        constructor(e, t) {
                            this.conference = e, this.options = t, this.disabledCodec = t.disabledCodec === Pr().VP8 ? void 0 : this._getCodecMimeType(t.disabledCodec);
                            const i = this._getCodecMimeType(t.jvbCodec),
                                n = this._getCodecMimeType(t.p2pCodec);
                            this.jvbPreferredCodec = i && this._isCodecSupported(i) ? i : Pr().VP8, this.p2pPreferredCodec = n && this._isCodecSupported(n) ? n : Pr().VP8, oa.debug(`Codec preferences for the conference are JVB: ${this.jvbPreferredCodec},\n            P2P: ${this.p2pPreferredCodec}`), this.jvbPreferredCodec !== Pr().VP9 || Ui.supportsVP9() || (this.jvbPreferredCodec = Pr().VP8), this.conference.on(Ge, (() => this._selectPreferredCodec())), this.conference.on(Ke, (() => this._selectPreferredCodec())), this.conference.on(_e, (e => this._onMediaSessionStarted(e)))
                        }
                        _getCodecMimeType(e) {
                            return "string" == typeof e ? Object.values(Pr()).find((t => t === e.toLowerCase())) : null
                        }
                        _isCodecSupported(e) {
                            return !(!Ui.isFirefox() && !Ui.isReactNative()) || window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("video").codecs.some((t => t.mimeType.toLowerCase() === `video/${e}`))
                        }
                        _onMediaSessionStarted(e) {
                            const t = e.isP2P ? this.p2pPreferredCodec : this.jvbPreferredCodec,
                                i = this.disabledCodec && this._isCodecSupported(this.disabledCodec) ? this.disabledCodec : null;
                            this._selectPreferredCodec(e, t, i)
                        }
                        _selectPreferredCodec() {
                            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                            const i = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null) || this.conference.jvbJingleSession,
                                n = e || this.jvbPreferredCodec;
                            let s = n;
                            if (i && !i.isP2P && !this.options.enforcePreferredCodec) {
                                const e = this.conference.getParticipants().map((e => e.getId()));
                                for (const t of e) {
                                    const e = i._signalingLayer.getPeerMediaInfo(t, dn.VIDEO),
                                        r = null == e ? void 0 : e.codecType;
                                    r && r !== n && (r !== Pr().VP9 || Ui.supportsVP9()) && (s = r)
                                }
                            }
                            i && i.setVideoCodecs(s, t)
                        }
                        getPreferredCodec() {
                            return this.jvbPreferredCodec
                        }
                    }
                    var ca = i(7318),
                        da = i.n(ca);
                    const la = (0, v.getLogger)("modules/RTC/BridgeChannel.js");
                    class ha {
                        constructor(e, t, i) {
                            if (!e && !t) throw new TypeError("At least peerconnection or wsUrl must be given");
                            if (e && t) throw new TypeError("Just one of peerconnection or wsUrl must be given");
                            if (e ? la.debug("constructor() with peerconnection") : la.debug(`constructor() with wsUrl:"${t}"`), this._channel = null, this._eventEmitter = i, this._mode = null, this._areRetriesEnabled = !1, this._closedFromClient = !1, e) {
                                const t = e.createDataChannel("JVB data channel", {
                                    protocol: "http://jitsi.org/protocols/colibri"
                                });
                                this._handleChannel(t), this._mode = "datachannel"
                            } else t && (this._areRetriesEnabled = !0, this._wsUrl = t, this._initWebSocket())
                        }
                        _initWebSocket() {
                            const e = new WebSocket(this._wsUrl);
                            this._handleChannel(e), this._mode = "websocket"
                        }
                        _startConnectionRetries() {
                            let e = 1;
                            const t = () => {
                                this.isOpen() || (this._initWebSocket(this._wsUrl), e = Math.min(2 * e, 60), this._retryTimeout = setTimeout(t, 1e3 * e))
                            };
                            this._retryTimeout = setTimeout(t, 1e3 * e)
                        }
                        _stopConnectionRetries() {
                            this._retryTimeout && (clearTimeout(this._retryTimeout), this._retryTimeout = void 0)
                        }
                        _retryWebSocketConnection(e) {
                            if (!this._areRetriesEnabled) return;
                            const {
                                code: t,
                                reason: i
                            } = e;
                            Tn.sendAnalytics(((e, t) => ({
                                type: Ut.TYPE_OPERATIONAL,
                                action: "bridge-channel.error",
                                attributes: {
                                    code: e,
                                    reason: t
                                }
                            }))(t, i)), this._areRetriesEnabled = !1, this._eventEmitter.once(Rn.default.DATA_CHANNEL_OPEN, (() => {
                                this._stopConnectionRetries(), this._areRetriesEnabled = !0
                            })), this._startConnectionRetries()
                        }
                        get mode() {
                            return this._mode
                        }
                        close() {
                            if (this._closedFromClient = !0, this._stopConnectionRetries(), this._areRetriesEnabled = !1, this._channel) {
                                try {
                                    this._channel.close()
                                } catch (e) {}
                                this._channel = null
                            }
                        }
                        isOpen() {
                            return this._channel && ("open" === this._channel.readyState || this._channel.readyState === WebSocket.OPEN)
                        }
                        sendEndpointStatsMessage(e) {
                            this._send({
                                colibriClass: "EndpointStats",
                                ...e
                            })
                        }
                        sendMessage(e, t) {
                            this._send({
                                colibriClass: "EndpointMessage",
                                msgPayload: t,
                                to: e
                            })
                        }
                        sendSetLastNMessage(e) {
                            la.log(`Sending lastN=${e}.`), this._send({
                                colibriClass: "LastNChangedEvent",
                                lastN: e
                            })
                        }
                        sendSelectedEndpointsMessage(e) {
                            la.log(`Sending selected endpoints: ${e}.`), this._send({
                                colibriClass: "SelectedEndpointsChangedEvent",
                                selectedEndpoints: e
                            })
                        }
                        sendReceiverVideoConstraintMessage(e) {
                            la.log(`Sending ReceiverVideoConstraint with maxFrameHeight=${e}px`), this._send({
                                colibriClass: "ReceiverVideoConstraint",
                                maxFrameHeight: e
                            })
                        }
                        sendNewReceiverVideoConstraintsMessage(e) {
                            la.log(`Sending ReceiverVideoConstraints with ${JSON.stringify(e)}`), this._send({
                                colibriClass: "ReceiverVideoConstraints",
                                ...e
                            })
                        }
                        sendVideoTypeMessage(e) {
                            la.debug(`Sending VideoTypeMessage with video type as ${e}`), this._send({
                                colibriClass: "VideoTypeMessage",
                                videoType: e
                            })
                        }
                        sendSourceVideoTypeMessage(e, t) {
                            la.info(`Sending SourceVideoTypeMessage with video type ${e}: ${t}`), this._send({
                                colibriClass: "SourceVideoTypeMessage",
                                sourceName: e,
                                videoType: t
                            })
                        }
                        _handleChannel(e) {
                            const t = this._eventEmitter;
                            e.onopen = () => {
                                la.info(`${this._mode} channel opened`), t.emit(Rn.default.DATA_CHANNEL_OPEN)
                            }, e.onerror = e => {
                                "websocket" !== this._mode && la.error(`Channel error: ${e.message}`)
                            }, e.onmessage = e => {
                                let i, {
                                    data: n
                                } = e;
                                try {
                                    i = JSON.parse(n)
                                } catch (e) {
                                    return Gi().callErrorHandler(e), void la.error("Failed to parse channel message as JSON: ", n, e)
                                }
                                const s = i.colibriClass;
                                switch (s) {
                                    case "DominantSpeakerEndpointChangeEvent": {
                                        const {
                                            dominantSpeakerEndpoint: e,
                                            previousSpeakers: n = []
                                        } = i;
                                        la.debug(`Dominant speaker: ${e}, previous speakers: ${n}`), t.emit(Rn.default.DOMINANT_SPEAKER_CHANGED, e, n);
                                        break
                                    }
                                    case "EndpointConnectivityStatusChangeEvent": {
                                        const e = i.endpoint,
                                            n = "true" === i.active;
                                        la.info(`Endpoint connection status changed: ${e} active=${n}`), t.emit(Rn.default.ENDPOINT_CONN_STATUS_CHANGED, e, n);
                                        break
                                    }
                                    case "EndpointMessage":
                                        t.emit(Rn.default.ENDPOINT_MESSAGE_RECEIVED, i.from, i.msgPayload);
                                        break;
                                    case "EndpointStats":
                                        t.emit(Rn.default.ENDPOINT_STATS_RECEIVED, i.from, i);
                                        break;
                                    case "LastNEndpointsChangeEvent":
                                        if (!hn.isSourceNameSignalingEnabled()) {
                                            const e = i.lastNEndpoints;
                                            la.info(`New forwarded endpoints: ${e}`), t.emit(Rn.default.LASTN_ENDPOINT_CHANGED, e)
                                        }
                                        break;
                                    case "ForwardedSources":
                                        if (hn.isSourceNameSignalingEnabled()) {
                                            const e = i.forwardedSources;
                                            la.info(`New forwarded sources: ${e}`), t.emit(Rn.default.FORWARDED_SOURCES_CHANGED, e)
                                        }
                                        break;
                                    case "SenderVideoConstraints": {
                                        const e = i.videoConstraints;
                                        e && (la.info(`SenderVideoConstraints: ${JSON.stringify(e)}`), t.emit(Rn.default.SENDER_VIDEO_CONSTRAINTS_CHANGED, e));
                                        break
                                    }
                                    case "SenderSourceConstraints":
                                        if (hn.isSourceNameSignalingEnabled()) {
                                            const {
                                                sourceName: e,
                                                maxHeight: n
                                            } = i;
                                            "string" == typeof e && "number" == typeof n ? (la.info(`SenderSourceConstraints: ${JSON.stringify({sourceName:e,maxHeight:n})}`), t.emit(Rn.default.SENDER_VIDEO_CONSTRAINTS_CHANGED, {
                                                sourceName: e,
                                                maxHeight: n
                                            })) : la.error(`Invalid SenderSourceConstraints: ${JSON.stringify(i)}`)
                                        }
                                        break;
                                    case "ServerHello":
                                        la.info(`Received ServerHello, version=${i.version}.`);
                                        break;
                                    default:
                                        la.debug("Channel JSON-formatted message: ", i), t.emit(`rtc.datachannel.${s}`, i)
                                }
                            }, e.onclose = e => {
                                la.info("Channel closed by " + (this._closedFromClient ? "client" : "server")), "websocket" === this._mode && (this._closedFromClient || (la.error(`Channel closed: ${e.code} ${e.reason}`), this._retryWebSocketConnection(e))), this._channel = null
                            }, this._channel = e
                        }
                        _send(e) {
                            const t = this._channel;
                            if (!this.isOpen()) throw la.error("Bridge Channel send: no opened channel."), new Error("No opened channel");
                            t.send(JSON.stringify(e))
                        }
                    }
                    var ua = i(4940),
                        pa = i.n(ua);
                    let ma = !0,
                        fa = !0;

                    function ga(e, t, i) {
                        const n = e.match(t);
                        return n && n.length >= i && parseInt(n[i], 10)
                    }

                    function _a(e, t, i) {
                        if (!e.RTCPeerConnection) return;
                        const n = e.RTCPeerConnection.prototype,
                            s = n.addEventListener;
                        n.addEventListener = function(e, n) {
                            if (e !== t) return s.apply(this, arguments);
                            const r = e => {
                                const t = i(e);
                                t && (n.handleEvent ? n.handleEvent(t) : n(t))
                            };
                            return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(n, r), s.apply(this, [e, r])
                        };
                        const r = n.removeEventListener;
                        n.removeEventListener = function(e, i) {
                            if (e !== t || !this._eventMap || !this._eventMap[t]) return r.apply(this, arguments);
                            if (!this._eventMap[t].has(i)) return r.apply(this, arguments);
                            const n = this._eventMap[t].get(i);
                            return this._eventMap[t].delete(i), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, r.apply(this, [e, n])
                        }, Object.defineProperty(n, "on" + t, {
                            get() {
                                return this["_on" + t]
                            },
                            set(e) {
                                this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e)
                            },
                            enumerable: !0,
                            configurable: !0
                        })
                    }

                    function Sa(e) {
                        return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (ma = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled")
                    }

                    function va(e) {
                        return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (fa = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled"))
                    }

                    function Ea() {
                        if ("object" == typeof window) {
                            if (ma) return;
                            "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments)
                        }
                    }

                    function ya(e, t) {
                        fa && console.warn(e + " is deprecated, please use " + t + " instead.")
                    }

                    function Ta(e) {
                        const t = {
                            browser: null,
                            version: null
                        };
                        if (void 0 === e || !e.navigator) return t.browser = "Not a browser.", t;
                        const {
                            navigator: i
                        } = e;
                        if (i.mozGetUserMedia) t.browser = "firefox", t.version = ga(i.userAgent, /Firefox\/(\d+)\./, 1);
                        else if (i.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = ga(i.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
                        else {
                            if (!e.RTCPeerConnection || !i.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t;
                            t.browser = "safari", t.version = ga(i.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype
                        }
                        return t
                    }

                    function Ca(e) {
                        return "[object Object]" === Object.prototype.toString.call(e)
                    }

                    function ba(e) {
                        return Ca(e) ? Object.keys(e).reduce((function(t, i) {
                            const n = Ca(e[i]),
                                s = n ? ba(e[i]) : e[i],
                                r = n && !Object.keys(s).length;
                            return void 0 === s || r ? t : Object.assign(t, {
                                [i]: s
                            })
                        }), {}) : e
                    }

                    function Ra(e, t, i) {
                        t && !i.has(t.id) && (i.set(t.id, t), Object.keys(t).forEach((n => {
                            n.endsWith("Id") ? Ra(e, e.get(t[n]), i) : n.endsWith("Ids") && t[n].forEach((t => {
                                Ra(e, e.get(t), i)
                            }))
                        })))
                    }

                    function Aa(e, t, i) {
                        const n = i ? "outbound-rtp" : "inbound-rtp",
                            s = new Map;
                        if (null === t) return s;
                        const r = [];
                        return e.forEach((e => {
                            "track" === e.type && e.trackIdentifier === t.id && r.push(e)
                        })), r.forEach((t => {
                            e.forEach((i => {
                                i.type === n && i.trackId === t.id && Ra(e, i, s)
                            }))
                        })), s
                    }
                    const Pa = Ea;

                    function Ia(e, t) {
                        const i = e && e.navigator;
                        if (!i.mediaDevices) return;
                        const n = function(e) {
                                if ("object" != typeof e || e.mandatory || e.optional) return e;
                                const t = {};
                                return Object.keys(e).forEach((i => {
                                    if ("require" === i || "advanced" === i || "mediaSource" === i) return;
                                    const n = "object" == typeof e[i] ? e[i] : {
                                        ideal: e[i]
                                    };
                                    void 0 !== n.exact && "number" == typeof n.exact && (n.min = n.max = n.exact);
                                    const s = function(e, t) {
                                        return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t
                                    };
                                    if (void 0 !== n.ideal) {
                                        t.optional = t.optional || [];
                                        let e = {};
                                        "number" == typeof n.ideal ? (e[s("min", i)] = n.ideal, t.optional.push(e), e = {}, e[s("max", i)] = n.ideal, t.optional.push(e)) : (e[s("", i)] = n.ideal, t.optional.push(e))
                                    }
                                    void 0 !== n.exact && "number" != typeof n.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[s("", i)] = n.exact) : ["min", "max"].forEach((e => {
                                        void 0 !== n[e] && (t.mandatory = t.mandatory || {}, t.mandatory[s(e, i)] = n[e])
                                    }))
                                })), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t
                            },
                            s = function(e, s) {
                                if (t.version >= 61) return s(e);
                                if ((e = JSON.parse(JSON.stringify(e))) && "object" == typeof e.audio) {
                                    const t = function(e, t, i) {
                                        t in e && !(i in e) && (e[i] = e[t], delete e[t])
                                    };
                                    t((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), t(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = n(e.audio)
                                }
                                if (e && "object" == typeof e.video) {
                                    let r = e.video.facingMode;
                                    r = r && ("object" == typeof r ? r : {
                                        ideal: r
                                    });
                                    const o = t.version < 66;
                                    if (r && ("user" === r.exact || "environment" === r.exact || "user" === r.ideal || "environment" === r.ideal) && (!i.mediaDevices.getSupportedConstraints || !i.mediaDevices.getSupportedConstraints().facingMode || o)) {
                                        let t;
                                        if (delete e.video.facingMode, "environment" === r.exact || "environment" === r.ideal ? t = ["back", "rear"] : "user" !== r.exact && "user" !== r.ideal || (t = ["front"]), t) return i.mediaDevices.enumerateDevices().then((i => {
                                            let o = (i = i.filter((e => "videoinput" === e.kind))).find((e => t.some((t => e.label.toLowerCase().includes(t)))));
                                            return !o && i.length && t.includes("back") && (o = i[i.length - 1]), o && (e.video.deviceId = r.exact ? {
                                                exact: o.deviceId
                                            } : {
                                                ideal: o.deviceId
                                            }), e.video = n(e.video), Pa("chrome: " + JSON.stringify(e)), s(e)
                                        }))
                                    }
                                    e.video = n(e.video)
                                }
                                return Pa("chrome: " + JSON.stringify(e)), s(e)
                            },
                            r = function(e) {
                                return t.version >= 64 ? e : {
                                    name: {
                                        PermissionDeniedError: "NotAllowedError",
                                        PermissionDismissedError: "NotAllowedError",
                                        InvalidStateError: "NotAllowedError",
                                        DevicesNotFoundError: "NotFoundError",
                                        ConstraintNotSatisfiedError: "OverconstrainedError",
                                        TrackStartError: "NotReadableError",
                                        MediaDeviceFailedDueToShutdown: "NotAllowedError",
                                        MediaDeviceKillSwitchOn: "NotAllowedError",
                                        TabCaptureError: "AbortError",
                                        ScreenCaptureError: "AbortError",
                                        DeviceCaptureError: "AbortError"
                                    } [e.name] || e.name,
                                    message: e.message,
                                    constraint: e.constraint || e.constraintName,
                                    toString() {
                                        return this.name + (this.message && ": ") + this.message
                                    }
                                }
                            };
                        if (i.getUserMedia = function(e, t, n) {
                                s(e, (e => {
                                    i.webkitGetUserMedia(e, t, (e => {
                                        n && n(r(e))
                                    }))
                                }))
                            }.bind(i), i.mediaDevices.getUserMedia) {
                            const e = i.mediaDevices.getUserMedia.bind(i.mediaDevices);
                            i.mediaDevices.getUserMedia = function(t) {
                                return s(t, (t => e(t).then((e => {
                                    if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach((e => {
                                        e.stop()
                                    })), new DOMException("", "NotFoundError");
                                    return e
                                }), (e => Promise.reject(r(e))))))
                            }
                        }
                    }

                    function Na(e, t) {
                        e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && ("function" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function(i) {
                            return t(i).then((t => {
                                const n = i.video && i.video.width,
                                    s = i.video && i.video.height,
                                    r = i.video && i.video.frameRate;
                                return i.video = {
                                    mandatory: {
                                        chromeMediaSource: "desktop",
                                        chromeMediaSourceId: t,
                                        maxFrameRate: r || 3
                                    }
                                }, n && (i.video.mandatory.maxWidth = n), s && (i.video.mandatory.maxHeight = s), e.navigator.mediaDevices.getUserMedia(i)
                            }))
                        } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"))
                    }

                    function Da(e) {
                        e.MediaStream = e.MediaStream || e.webkitMediaStream
                    }

                    function Ma(e) {
                        if ("object" == typeof e && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) {
                            Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", {
                                get() {
                                    return this._ontrack
                                },
                                set(e) {
                                    this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e)
                                },
                                enumerable: !0,
                                configurable: !0
                            });
                            const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                            e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                                return this._ontrackpoly || (this._ontrackpoly = t => {
                                    t.stream.addEventListener("addtrack", (i => {
                                        let n;
                                        n = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e => e.track && e.track.id === i.track.id)) : {
                                            track: i.track
                                        };
                                        const s = new Event("track");
                                        s.track = i.track, s.receiver = n, s.transceiver = {
                                            receiver: n
                                        }, s.streams = [t.stream], this.dispatchEvent(s)
                                    })), t.stream.getTracks().forEach((i => {
                                        let n;
                                        n = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e => e.track && e.track.id === i.id)) : {
                                            track: i
                                        };
                                        const s = new Event("track");
                                        s.track = i, s.receiver = n, s.transceiver = {
                                            receiver: n
                                        }, s.streams = [t.stream], this.dispatchEvent(s)
                                    }))
                                }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments)
                            }
                        } else _a(e, "track", (e => (e.transceiver || Object.defineProperty(e, "transceiver", {
                            value: {
                                receiver: e.receiver
                            }
                        }), e)))
                    }

                    function Oa(e) {
                        if ("object" == typeof e && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) {
                            const t = function(e, t) {
                                return {
                                    track: t,
                                    get dtmf() {
                                        return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf
                                    },
                                    _pc: e
                                }
                            };
                            if (!e.RTCPeerConnection.prototype.getSenders) {
                                e.RTCPeerConnection.prototype.getSenders = function() {
                                    return this._senders = this._senders || [], this._senders.slice()
                                };
                                const i = e.RTCPeerConnection.prototype.addTrack;
                                e.RTCPeerConnection.prototype.addTrack = function(e, n) {
                                    let s = i.apply(this, arguments);
                                    return s || (s = t(this, e), this._senders.push(s)), s
                                };
                                const n = e.RTCPeerConnection.prototype.removeTrack;
                                e.RTCPeerConnection.prototype.removeTrack = function(e) {
                                    n.apply(this, arguments);
                                    const t = this._senders.indexOf(e); - 1 !== t && this._senders.splice(t, 1)
                                }
                            }
                            const i = e.RTCPeerConnection.prototype.addStream;
                            e.RTCPeerConnection.prototype.addStream = function(e) {
                                this._senders = this._senders || [], i.apply(this, [e]), e.getTracks().forEach((e => {
                                    this._senders.push(t(this, e))
                                }))
                            };
                            const n = e.RTCPeerConnection.prototype.removeStream;
                            e.RTCPeerConnection.prototype.removeStream = function(e) {
                                this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach((e => {
                                    const t = this._senders.find((t => t.track === e));
                                    t && this._senders.splice(this._senders.indexOf(t), 1)
                                }))
                            }
                        } else if ("object" == typeof e && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) {
                            const t = e.RTCPeerConnection.prototype.getSenders;
                            e.RTCPeerConnection.prototype.getSenders = function() {
                                const e = t.apply(this, []);
                                return e.forEach((e => e._pc = this)), e
                            }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
                                get() {
                                    return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf
                                }
                            })
                        }
                    }

                    function wa(e) {
                        if (!e.RTCPeerConnection) return;
                        const t = e.RTCPeerConnection.prototype.getStats;
                        e.RTCPeerConnection.prototype.getStats = function() {
                            const [e, i, n] = arguments;
                            if (arguments.length > 0 && "function" == typeof e) return t.apply(this, arguments);
                            if (0 === t.length && (0 === arguments.length || "function" != typeof e)) return t.apply(this, []);
                            const s = function(e) {
                                    const t = {};
                                    return e.result().forEach((e => {
                                        const i = {
                                            id: e.id,
                                            timestamp: e.timestamp,
                                            type: {
                                                localcandidate: "local-candidate",
                                                remotecandidate: "remote-candidate"
                                            } [e.type] || e.type
                                        };
                                        e.names().forEach((t => {
                                            i[t] = e.stat(t)
                                        })), t[i.id] = i
                                    })), t
                                },
                                r = function(e) {
                                    return new Map(Object.keys(e).map((t => [t, e[t]])))
                                };
                            if (arguments.length >= 2) {
                                const n = function(e) {
                                    i(r(s(e)))
                                };
                                return t.apply(this, [n, e])
                            }
                            return new Promise(((e, i) => {
                                t.apply(this, [function(t) {
                                    e(r(s(t)))
                                }, i])
                            })).then(i, n)
                        }
                    }

                    function La(e) {
                        if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;
                        if (!("getStats" in e.RTCRtpSender.prototype)) {
                            const t = e.RTCPeerConnection.prototype.getSenders;
                            t && (e.RTCPeerConnection.prototype.getSenders = function() {
                                const e = t.apply(this, []);
                                return e.forEach((e => e._pc = this)), e
                            });
                            const i = e.RTCPeerConnection.prototype.addTrack;
                            i && (e.RTCPeerConnection.prototype.addTrack = function() {
                                const e = i.apply(this, arguments);
                                return e._pc = this, e
                            }), e.RTCRtpSender.prototype.getStats = function() {
                                const e = this;
                                return this._pc.getStats().then((t => Aa(t, e.track, !0)))
                            }
                        }
                        if (!("getStats" in e.RTCRtpReceiver.prototype)) {
                            const t = e.RTCPeerConnection.prototype.getReceivers;
                            t && (e.RTCPeerConnection.prototype.getReceivers = function() {
                                const e = t.apply(this, []);
                                return e.forEach((e => e._pc = this)), e
                            }), _a(e, "track", (e => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function() {
                                const e = this;
                                return this._pc.getStats().then((t => Aa(t, e.track, !1)))
                            }
                        }
                        if (!("getStats" in e.RTCRtpSender.prototype) || !("getStats" in e.RTCRtpReceiver.prototype)) return;
                        const t = e.RTCPeerConnection.prototype.getStats;
                        e.RTCPeerConnection.prototype.getStats = function() {
                            if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {
                                const e = arguments[0];
                                let t, i, n;
                                return this.getSenders().forEach((i => {
                                    i.track === e && (t ? n = !0 : t = i)
                                })), this.getReceivers().forEach((t => (t.track === e && (i ? n = !0 : i = t), t.track === e))), n || t && i ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t ? t.getStats() : i ? i.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"))
                            }
                            return t.apply(this, arguments)
                        }
                    }

                    function ka(e) {
                        e.RTCPeerConnection.prototype.getLocalStreams = function() {
                            return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e => this._shimmedLocalStreams[e][0]))
                        };
                        const t = e.RTCPeerConnection.prototype.addTrack;
                        e.RTCPeerConnection.prototype.addTrack = function(e, i) {
                            if (!i) return t.apply(this, arguments);
                            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                            const n = t.apply(this, arguments);
                            return this._shimmedLocalStreams[i.id] ? -1 === this._shimmedLocalStreams[i.id].indexOf(n) && this._shimmedLocalStreams[i.id].push(n) : this._shimmedLocalStreams[i.id] = [i, n], n
                        };
                        const i = e.RTCPeerConnection.prototype.addStream;
                        e.RTCPeerConnection.prototype.addStream = function(e) {
                            this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach((e => {
                                if (this.getSenders().find((t => t.track === e))) throw new DOMException("Track already exists.", "InvalidAccessError")
                            }));
                            const t = this.getSenders();
                            i.apply(this, arguments);
                            const n = this.getSenders().filter((e => -1 === t.indexOf(e)));
                            this._shimmedLocalStreams[e.id] = [e].concat(n)
                        };
                        const n = e.RTCPeerConnection.prototype.removeStream;
                        e.RTCPeerConnection.prototype.removeStream = function(e) {
                            return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], n.apply(this, arguments)
                        };
                        const s = e.RTCPeerConnection.prototype.removeTrack;
                        e.RTCPeerConnection.prototype.removeTrack = function(e) {
                            return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach((t => {
                                const i = this._shimmedLocalStreams[t].indexOf(e); - 1 !== i && this._shimmedLocalStreams[t].splice(i, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t]
                            })), s.apply(this, arguments)
                        }
                    }

                    function xa(e, t) {
                        if (!e.RTCPeerConnection) return;
                        if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return ka(e);
                        const i = e.RTCPeerConnection.prototype.getLocalStreams;
                        e.RTCPeerConnection.prototype.getLocalStreams = function() {
                            const e = i.apply(this);
                            return this._reverseStreams = this._reverseStreams || {}, e.map((e => this._reverseStreams[e.id]))
                        };
                        const n = e.RTCPeerConnection.prototype.addStream;
                        e.RTCPeerConnection.prototype.addStream = function(t) {
                            if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach((e => {
                                    if (this.getSenders().find((t => t.track === e))) throw new DOMException("Track already exists.", "InvalidAccessError")
                                })), !this._reverseStreams[t.id]) {
                                const i = new e.MediaStream(t.getTracks());
                                this._streams[t.id] = i, this._reverseStreams[i.id] = t, t = i
                            }
                            n.apply(this, [t])
                        };
                        const s = e.RTCPeerConnection.prototype.removeStream;

                        function r(e, t) {
                            let i = t.sdp;
                            return Object.keys(e._reverseStreams || []).forEach((t => {
                                const n = e._reverseStreams[t],
                                    s = e._streams[n.id];
                                i = i.replace(new RegExp(s.id, "g"), n.id)
                            })), new RTCSessionDescription({
                                type: t.type,
                                sdp: i
                            })
                        }

                        function o(e, t) {
                            let i = t.sdp;
                            return Object.keys(e._reverseStreams || []).forEach((t => {
                                const n = e._reverseStreams[t],
                                    s = e._streams[n.id];
                                i = i.replace(new RegExp(n.id, "g"), s.id)
                            })), new RTCSessionDescription({
                                type: t.type,
                                sdp: i
                            })
                        }
                        e.RTCPeerConnection.prototype.removeStream = function(e) {
                            this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, s.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id]
                        }, e.RTCPeerConnection.prototype.addTrack = function(t, i) {
                            if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                            const n = [].slice.call(arguments, 1);
                            if (1 !== n.length || !n[0].getTracks().find((e => e === t))) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
                            const s = this.getSenders().find((e => e.track === t));
                            if (s) throw new DOMException("Track already exists.", "InvalidAccessError");
                            this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
                            const r = this._streams[i.id];
                            if (r) r.addTrack(t), Promise.resolve().then((() => {
                                this.dispatchEvent(new Event("negotiationneeded"))
                            }));
                            else {
                                const n = new e.MediaStream([t]);
                                this._streams[i.id] = n, this._reverseStreams[n.id] = i, this.addStream(n)
                            }
                            return this.getSenders().find((e => e.track === t))
                        }, ["createOffer", "createAnswer"].forEach((function(t) {
                            const i = e.RTCPeerConnection.prototype[t],
                                n = {
                                    [t]() {
                                        const e = arguments;
                                        return arguments.length && "function" == typeof arguments[0] ? i.apply(this, [t => {
                                            const i = r(this, t);
                                            e[0].apply(null, [i])
                                        }, t => {
                                            e[1] && e[1].apply(null, t)
                                        }, arguments[2]]) : i.apply(this, arguments).then((e => r(this, e)))
                                    }
                                };
                            e.RTCPeerConnection.prototype[t] = n[t]
                        }));
                        const a = e.RTCPeerConnection.prototype.setLocalDescription;
                        e.RTCPeerConnection.prototype.setLocalDescription = function() {
                            return arguments.length && arguments[0].type ? (arguments[0] = o(this, arguments[0]), a.apply(this, arguments)) : a.apply(this, arguments)
                        };
                        const c = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription");
                        Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", {
                            get() {
                                const e = c.get.apply(this);
                                return "" === e.type ? e : r(this, e)
                            }
                        }), e.RTCPeerConnection.prototype.removeTrack = function(e) {
                            if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                            if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
                            if (e._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
                            let t;
                            this._streams = this._streams || {}, Object.keys(this._streams).forEach((i => {
                                this._streams[i].getTracks().find((t => e.track === t)) && (t = this._streams[i])
                            })), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded")))
                        }
                    }

                    function Fa(e, t) {
                        !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                            const i = e.RTCPeerConnection.prototype[t],
                                n = {
                                    [t]() {
                                        return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), i.apply(this, arguments)
                                    }
                                };
                            e.RTCPeerConnection.prototype[t] = n[t]
                        }))
                    }

                    function Va(e, t) {
                        _a(e, "negotiationneeded", (e => {
                            const i = e.target;
                            if (!(t.version < 72 || i.getConfiguration && "plan-b" === i.getConfiguration().sdpSemantics) || "stable" === i.signalingState) return e
                        }))
                    }

                    function Ua(e, t) {
                        const i = e && e.navigator,
                            n = e && e.MediaStreamTrack;
                        if (i.getUserMedia = function(e, t, n) {
                                ya("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i.mediaDevices.getUserMedia(e).then(t, n)
                            }, !(t.version > 55 && "autoGainControl" in i.mediaDevices.getSupportedConstraints())) {
                            const e = function(e, t, i) {
                                    t in e && !(i in e) && (e[i] = e[t], delete e[t])
                                },
                                t = i.mediaDevices.getUserMedia.bind(i.mediaDevices);
                            if (i.mediaDevices.getUserMedia = function(i) {
                                    return "object" == typeof i && "object" == typeof i.audio && (i = JSON.parse(JSON.stringify(i)), e(i.audio, "autoGainControl", "mozAutoGainControl"), e(i.audio, "noiseSuppression", "mozNoiseSuppression")), t(i)
                                }, n && n.prototype.getSettings) {
                                const t = n.prototype.getSettings;
                                n.prototype.getSettings = function() {
                                    const i = t.apply(this, arguments);
                                    return e(i, "mozAutoGainControl", "autoGainControl"), e(i, "mozNoiseSuppression", "noiseSuppression"), i
                                }
                            }
                            if (n && n.prototype.applyConstraints) {
                                const t = n.prototype.applyConstraints;
                                n.prototype.applyConstraints = function(i) {
                                    return "audio" === this.kind && "object" == typeof i && (i = JSON.parse(JSON.stringify(i)), e(i, "autoGainControl", "mozAutoGainControl"), e(i, "noiseSuppression", "mozNoiseSuppression")), t.apply(this, [i])
                                }
                            }
                        }
                    }

                    function ja(e, t) {
                        e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function(i) {
                            if (!i || !i.video) {
                                const e = new DOMException("getDisplayMedia without video constraints is undefined");
                                return e.name = "NotFoundError", e.code = 8, Promise.reject(e)
                            }
                            return !0 === i.video ? i.video = {
                                mediaSource: t
                            } : i.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(i)
                        })
                    }

                    function $a(e) {
                        "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                            get() {
                                return {
                                    receiver: this.receiver
                                }
                            }
                        })
                    }

                    function Ha(e, t) {
                        if ("object" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return;
                        !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                            const i = e.RTCPeerConnection.prototype[t],
                                n = {
                                    [t]() {
                                        return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), i.apply(this, arguments)
                                    }
                                };
                            e.RTCPeerConnection.prototype[t] = n[t]
                        }));
                        const i = {
                                inboundrtp: "inbound-rtp",
                                outboundrtp: "outbound-rtp",
                                candidatepair: "candidate-pair",
                                localcandidate: "local-candidate",
                                remotecandidate: "remote-candidate"
                            },
                            n = e.RTCPeerConnection.prototype.getStats;
                        e.RTCPeerConnection.prototype.getStats = function() {
                            const [e, s, r] = arguments;
                            return n.apply(this, [e || null]).then((e => {
                                if (t.version < 53 && !s) try {
                                    e.forEach((e => {
                                        e.type = i[e.type] || e.type
                                    }))
                                } catch (t) {
                                    if ("TypeError" !== t.name) throw t;
                                    e.forEach(((t, n) => {
                                        e.set(n, Object.assign({}, t, {
                                            type: i[t.type] || t.type
                                        }))
                                    }))
                                }
                                return e
                            })).then(s, r)
                        }
                    }

                    function Ba(e) {
                        if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
                        if (e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return;
                        const t = e.RTCPeerConnection.prototype.getSenders;
                        t && (e.RTCPeerConnection.prototype.getSenders = function() {
                            const e = t.apply(this, []);
                            return e.forEach((e => e._pc = this)), e
                        });
                        const i = e.RTCPeerConnection.prototype.addTrack;
                        i && (e.RTCPeerConnection.prototype.addTrack = function() {
                            const e = i.apply(this, arguments);
                            return e._pc = this, e
                        }), e.RTCRtpSender.prototype.getStats = function() {
                            return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map)
                        }
                    }

                    function Ja(e) {
                        if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
                        if (e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return;
                        const t = e.RTCPeerConnection.prototype.getReceivers;
                        t && (e.RTCPeerConnection.prototype.getReceivers = function() {
                            const e = t.apply(this, []);
                            return e.forEach((e => e._pc = this)), e
                        }), _a(e, "track", (e => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function() {
                            return this._pc.getStats(this.track)
                        }
                    }

                    function Ga(e) {
                        e.RTCPeerConnection && !("removeStream" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function(e) {
                            ya("removeStream", "removeTrack"), this.getSenders().forEach((t => {
                                t.track && e.getTracks().includes(t.track) && this.removeTrack(t)
                            }))
                        })
                    }

                    function Ka(e) {
                        e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel)
                    }

                    function qa(e) {
                        if ("object" != typeof e || !e.RTCPeerConnection) return;
                        const t = e.RTCPeerConnection.prototype.addTransceiver;
                        t && (e.RTCPeerConnection.prototype.addTransceiver = function() {
                            this.setParametersPromises = [];
                            const e = arguments[1],
                                i = e && "sendEncodings" in e;
                            i && e.sendEncodings.forEach((e => {
                                if ("rid" in e && !/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError("Invalid RID value provided.");
                                if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
                                if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0")
                            }));
                            const n = t.apply(this, arguments);
                            if (i) {
                                const {
                                    sender: t
                                } = n, i = t.getParameters();
                                (!("encodings" in i) || 1 === i.encodings.length && 0 === Object.keys(i.encodings[0]).length) && (i.encodings = e.sendEncodings, t.sendEncodings = e.sendEncodings, this.setParametersPromises.push(t.setParameters(i).then((() => {
                                    delete t.sendEncodings
                                })).catch((() => {
                                    delete t.sendEncodings
                                }))))
                            }
                            return n
                        })
                    }

                    function Wa(e) {
                        if ("object" != typeof e || !e.RTCRtpSender) return;
                        const t = e.RTCRtpSender.prototype.getParameters;
                        t && (e.RTCRtpSender.prototype.getParameters = function() {
                            const e = t.apply(this, arguments);
                            return "encodings" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e
                        })
                    }

                    function Xa(e) {
                        if ("object" != typeof e || !e.RTCPeerConnection) return;
                        const t = e.RTCPeerConnection.prototype.createOffer;
                        e.RTCPeerConnection.prototype.createOffer = function() {
                            return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((() => t.apply(this, arguments))).finally((() => {
                                this.setParametersPromises = []
                            })) : t.apply(this, arguments)
                        }
                    }

                    function za(e) {
                        if ("object" != typeof e || !e.RTCPeerConnection) return;
                        const t = e.RTCPeerConnection.prototype.createAnswer;
                        e.RTCPeerConnection.prototype.createAnswer = function() {
                            return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((() => t.apply(this, arguments))).finally((() => {
                                this.setParametersPromises = []
                            })) : t.apply(this, arguments)
                        }
                    }

                    function Qa(e) {
                        if ("object" == typeof e && e.RTCPeerConnection) {
                            if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function() {
                                    return this._localStreams || (this._localStreams = []), this._localStreams
                                }), !("addStream" in e.RTCPeerConnection.prototype)) {
                                const t = e.RTCPeerConnection.prototype.addTrack;
                                e.RTCPeerConnection.prototype.addStream = function(e) {
                                    this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach((i => t.call(this, i, e))), e.getVideoTracks().forEach((i => t.call(this, i, e)))
                                }, e.RTCPeerConnection.prototype.addTrack = function(e) {
                                    for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++) n[s - 1] = arguments[s];
                                    return n && n.forEach((e => {
                                        this._localStreams ? this._localStreams.includes(e) || this._localStreams.push(e) : this._localStreams = [e]
                                    })), t.apply(this, arguments)
                                }
                            }
                            "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(e) {
                                this._localStreams || (this._localStreams = []);
                                const t = this._localStreams.indexOf(e);
                                if (-1 === t) return;
                                this._localStreams.splice(t, 1);
                                const i = e.getTracks();
                                this.getSenders().forEach((e => {
                                    i.includes(e.track) && this.removeTrack(e)
                                }))
                            })
                        }
                    }

                    function Ya(e) {
                        if ("object" == typeof e && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function() {
                                return this._remoteStreams ? this._remoteStreams : []
                            }), !("onaddstream" in e.RTCPeerConnection.prototype))) {
                            Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", {
                                get() {
                                    return this._onaddstream
                                },
                                set(e) {
                                    this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = e => {
                                        e.streams.forEach((e => {
                                            if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e)) return;
                                            this._remoteStreams.push(e);
                                            const t = new Event("addstream");
                                            t.stream = e, this.dispatchEvent(t)
                                        }))
                                    })
                                }
                            });
                            const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                            e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                                const e = this;
                                return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t) {
                                    t.streams.forEach((t => {
                                        if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return;
                                        e._remoteStreams.push(t);
                                        const i = new Event("addstream");
                                        i.stream = t, e.dispatchEvent(i)
                                    }))
                                }), t.apply(e, arguments)
                            }
                        }
                    }

                    function Za(e) {
                        if ("object" != typeof e || !e.RTCPeerConnection) return;
                        const t = e.RTCPeerConnection.prototype,
                            i = t.createOffer,
                            n = t.createAnswer,
                            s = t.setLocalDescription,
                            r = t.setRemoteDescription,
                            o = t.addIceCandidate;
                        t.createOffer = function(e, t) {
                            const n = arguments.length >= 2 ? arguments[2] : arguments[0],
                                s = i.apply(this, [n]);
                            return t ? (s.then(e, t), Promise.resolve()) : s
                        }, t.createAnswer = function(e, t) {
                            const i = arguments.length >= 2 ? arguments[2] : arguments[0],
                                s = n.apply(this, [i]);
                            return t ? (s.then(e, t), Promise.resolve()) : s
                        };
                        let a = function(e, t, i) {
                            const n = s.apply(this, [e]);
                            return i ? (n.then(t, i), Promise.resolve()) : n
                        };
                        t.setLocalDescription = a, a = function(e, t, i) {
                            const n = r.apply(this, [e]);
                            return i ? (n.then(t, i), Promise.resolve()) : n
                        }, t.setRemoteDescription = a, a = function(e, t, i) {
                            const n = o.apply(this, [e]);
                            return i ? (n.then(t, i), Promise.resolve()) : n
                        }, t.addIceCandidate = a
                    }

                    function ec(e) {
                        const t = e && e.navigator;
                        if (t.mediaDevices && t.mediaDevices.getUserMedia) {
                            const e = t.mediaDevices,
                                i = e.getUserMedia.bind(e);
                            t.mediaDevices.getUserMedia = e => i(tc(e))
                        }!t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function(e, i, n) {
                            t.mediaDevices.getUserMedia(e).then(i, n)
                        }.bind(t))
                    }

                    function tc(e) {
                        return e && void 0 !== e.video ? Object.assign({}, e, {
                            video: ba(e.video)
                        }) : e
                    }

                    function ic(e) {
                        if (!e.RTCPeerConnection) return;
                        const t = e.RTCPeerConnection;
                        e.RTCPeerConnection = function(e, i) {
                            if (e && e.iceServers) {
                                const t = [];
                                for (let i = 0; i < e.iceServers.length; i++) {
                                    let n = e.iceServers[i];
                                    !n.hasOwnProperty("urls") && n.hasOwnProperty("url") ? (ya("RTCIceServer.url", "RTCIceServer.urls"), n = JSON.parse(JSON.stringify(n)), n.urls = n.url, delete n.url, t.push(n)) : t.push(e.iceServers[i])
                                }
                                e.iceServers = t
                            }
                            return new t(e, i)
                        }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
                            get: () => t.generateCertificate
                        })
                    }

                    function nc(e) {
                        "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                            get() {
                                return {
                                    receiver: this.receiver
                                }
                            }
                        })
                    }

                    function sc(e) {
                        const t = e.RTCPeerConnection.prototype.createOffer;
                        e.RTCPeerConnection.prototype.createOffer = function(e) {
                            if (e) {
                                void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio);
                                const t = this.getTransceivers().find((e => "audio" === e.receiver.track.kind));
                                !1 === e.offerToReceiveAudio && t ? "sendrecv" === t.direction ? t.setDirection ? t.setDirection("sendonly") : t.direction = "sendonly" : "recvonly" === t.direction && (t.setDirection ? t.setDirection("inactive") : t.direction = "inactive") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver("audio", {
                                    direction: "recvonly"
                                }), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo);
                                const i = this.getTransceivers().find((e => "video" === e.receiver.track.kind));
                                !1 === e.offerToReceiveVideo && i ? "sendrecv" === i.direction ? i.setDirection ? i.setDirection("sendonly") : i.direction = "sendonly" : "recvonly" === i.direction && (i.setDirection ? i.setDirection("inactive") : i.direction = "inactive") : !0 !== e.offerToReceiveVideo || i || this.addTransceiver("video", {
                                    direction: "recvonly"
                                })
                            }
                            return t.apply(this, arguments)
                        }
                    }

                    function rc(e) {
                        "object" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext)
                    }
                    var oc = i(5483),
                        ac = i.n(oc);

                    function cc(e) {
                        if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return;
                        const t = e.RTCIceCandidate;
                        e.RTCIceCandidate = function(e) {
                            if ("object" == typeof e && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) {
                                const i = new t(e),
                                    n = ac().parseCandidate(e.candidate),
                                    s = Object.assign(i, n);
                                return s.toJSON = function() {
                                    return {
                                        candidate: s.candidate,
                                        sdpMid: s.sdpMid,
                                        sdpMLineIndex: s.sdpMLineIndex,
                                        usernameFragment: s.usernameFragment
                                    }
                                }, s
                            }
                            return new t(e)
                        }, e.RTCIceCandidate.prototype = t.prototype, _a(e, "icecandidate", (t => (t.candidate && Object.defineProperty(t, "candidate", {
                            value: new e.RTCIceCandidate(t.candidate),
                            writable: "false"
                        }), t)))
                    }

                    function dc(e, t) {
                        if (!e.RTCPeerConnection) return;
                        "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", {
                            get() {
                                return void 0 === this._sctp ? null : this._sctp
                            }
                        });
                        const i = function(e) {
                                if (!e || !e.sdp) return !1;
                                const t = ac().splitSections(e.sdp);
                                return t.shift(), t.some((e => {
                                    const t = ac().parseMLine(e);
                                    return t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP")
                                }))
                            },
                            n = function(e) {
                                const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
                                if (null === t || t.length < 2) return -1;
                                const i = parseInt(t[1], 10);
                                return i != i ? -1 : i
                            },
                            s = function(e) {
                                let i = 65536;
                                return "firefox" === t.browser && (i = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), i
                            },
                            r = function(e, i) {
                                let n = 65536;
                                "firefox" === t.browser && 57 === t.version && (n = 65535);
                                const s = ac().matchPrefix(e.sdp, "a=max-message-size:");
                                return s.length > 0 ? n = parseInt(s[0].substr(19), 10) : "firefox" === t.browser && -1 !== i && (n = 2147483637), n
                            },
                            o = e.RTCPeerConnection.prototype.setRemoteDescription;
                        e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                            if (this._sctp = null, "chrome" === t.browser && t.version >= 76) {
                                const {
                                    sdpSemantics: e
                                } = this.getConfiguration();
                                "plan-b" === e && Object.defineProperty(this, "sctp", {
                                    get() {
                                        return void 0 === this._sctp ? null : this._sctp
                                    },
                                    enumerable: !0,
                                    configurable: !0
                                })
                            }
                            if (i(arguments[0])) {
                                const e = n(arguments[0]),
                                    t = s(e),
                                    i = r(arguments[0], e);
                                let o;
                                o = 0 === t && 0 === i ? Number.POSITIVE_INFINITY : 0 === t || 0 === i ? Math.max(t, i) : Math.min(t, i);
                                const a = {};
                                Object.defineProperty(a, "maxMessageSize", {
                                    get: () => o
                                }), this._sctp = a
                            }
                            return o.apply(this, arguments)
                        }
                    }

                    function lc(e) {
                        if (!e.RTCPeerConnection || !("createDataChannel" in e.RTCPeerConnection.prototype)) return;

                        function t(e, t) {
                            const i = e.send;
                            e.send = function() {
                                const n = arguments[0],
                                    s = n.length || n.size || n.byteLength;
                                if ("open" === e.readyState && t.sctp && s > t.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)");
                                return i.apply(e, arguments)
                            }
                        }
                        const i = e.RTCPeerConnection.prototype.createDataChannel;
                        e.RTCPeerConnection.prototype.createDataChannel = function() {
                            const e = i.apply(this, arguments);
                            return t(e, this), e
                        }, _a(e, "datachannel", (e => (t(e.channel, e.target), e)))
                    }

                    function hc(e) {
                        if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return;
                        const t = e.RTCPeerConnection.prototype;
                        Object.defineProperty(t, "connectionState", {
                            get() {
                                return {
                                    completed: "connected",
                                    checking: "connecting"
                                } [this.iceConnectionState] || this.iceConnectionState
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(t, "onconnectionstatechange", {
                            get() {
                                return this._onconnectionstatechange || null
                            },
                            set(e) {
                                this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e)
                            },
                            enumerable: !0,
                            configurable: !0
                        }), ["setLocalDescription", "setRemoteDescription"].forEach((e => {
                            const i = t[e];
                            t[e] = function() {
                                return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => {
                                    const t = e.target;
                                    if (t._lastConnectionState !== t.connectionState) {
                                        t._lastConnectionState = t.connectionState;
                                        const i = new Event("connectionstatechange", e);
                                        t.dispatchEvent(i)
                                    }
                                    return e
                                }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i.apply(this, arguments)
                            }
                        }))
                    }

                    function uc(e, t) {
                        if (!e.RTCPeerConnection) return;
                        if ("chrome" === t.browser && t.version >= 71) return;
                        if ("safari" === t.browser && t.version >= 605) return;
                        const i = e.RTCPeerConnection.prototype.setRemoteDescription;
                        e.RTCPeerConnection.prototype.setRemoteDescription = function(t) {
                            if (t && t.sdp && -1 !== t.sdp.indexOf("\na=extmap-allow-mixed")) {
                                const i = t.sdp.split("\n").filter((e => "a=extmap-allow-mixed" !== e.trim())).join("\n");
                                e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({
                                    type: t.type,
                                    sdp: i
                                }) : t.sdp = i
                            }
                            return i.apply(this, arguments)
                        }
                    }

                    function pc(e, t) {
                        if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
                        const i = e.RTCPeerConnection.prototype.addIceCandidate;
                        i && 0 !== i.length && (e.RTCPeerConnection.prototype.addIceCandidate = function() {
                            return arguments[0] ? ("chrome" === t.browser && t.version < 78 || "firefox" === t.browser && t.version < 68 || "safari" === t.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : i.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
                        })
                    }

                    function mc(e, t) {
                        if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
                        const i = e.RTCPeerConnection.prototype.setLocalDescription;
                        i && 0 !== i.length && (e.RTCPeerConnection.prototype.setLocalDescription = function() {
                            let e = arguments[0] || {};
                            if ("object" != typeof e || e.type && e.sdp) return i.apply(this, arguments);
                            if (e = {
                                    type: e.type,
                                    sdp: e.sdp
                                }, !e.type) switch (this.signalingState) {
                                case "stable":
                                case "have-local-offer":
                                case "have-remote-pranswer":
                                    e.type = "offer";
                                    break;
                                default:
                                    e.type = "answer"
                            }
                            if (e.sdp || "offer" !== e.type && "answer" !== e.type) return i.apply(this, [e]);
                            const t = "offer" === e.type ? this.createOffer : this.createAnswer;
                            return t.apply(this).then((e => i.apply(this, [e])))
                        })
                    }! function() {
                        let {
                            window: e
                        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                            shimChrome: !0,
                            shimFirefox: !0,
                            shimSafari: !0
                        };
                        const i = Ea,
                            n = Ta(e),
                            s = {
                                browserDetails: n,
                                commonShim: p,
                                extractVersion: ga,
                                disableLog: Sa,
                                disableWarnings: va,
                                sdp: oc
                            };
                        switch (n.browser) {
                            case "chrome":
                                if (!l || !Fa || !t.shimChrome) return i("Chrome shim is not included in this adapter release."), s;
                                if (null === n.version) return i("Chrome shim can not determine version, not shimming."), s;
                                i("adapter.js shimming chrome."), s.browserShim = l, pc(e, n), mc(e), Ia(e, n), Da(e), Fa(e, n), Ma(e), xa(e, n), Oa(e), wa(e), La(e), Va(e, n), cc(e), hc(e), dc(e, n), lc(e), uc(e, n);
                                break;
                            case "firefox":
                                if (!h || !Ha || !t.shimFirefox) return i("Firefox shim is not included in this adapter release."), s;
                                i("adapter.js shimming firefox."), s.browserShim = h, pc(e, n), mc(e), Ua(e, n), Ha(e, n), $a(e), Ga(e), Ba(e), Ja(e), Ka(e), qa(e), Wa(e), Xa(e), za(e), cc(e), hc(e), dc(e, n), lc(e);
                                break;
                            case "safari":
                                if (!u || !t.shimSafari) return i("Safari shim is not included in this adapter release."), s;
                                i("adapter.js shimming safari."), s.browserShim = u, pc(e, n), mc(e), ic(e), sc(e), Za(e), Qa(e), Ya(e), nc(e), ec(e), rc(e), cc(e), dc(e, n), lc(e), uc(e, n);
                                break;
                            default:
                                i("Unsupported browser!")
                        }
                    }({
                        window: "undefined" == typeof window ? void 0 : window
                    });
                    var fc = i(6125),
                        gc = i.n(fc);
                    const _c = (0, v.getLogger)("modules/RTC/RTCUtils.js"),
                        Sc = new(dt()),
                        vc = {
                            video: {
                                height: {
                                    ideal: 720,
                                    max: 720,
                                    min: 180
                                },
                                width: {
                                    ideal: 1280,
                                    max: 1280,
                                    min: 320
                                }
                            }
                        };
                    let Ec = "default",
                        yc = !1,
                        Tc = !1,
                        Cc = !1,
                        bc = !1,
                        Rc = !1,
                        Ac = null;
                    const Pc = document.createElement("audio"),
                        Ic = void 0 !== Pc.setSinkId;
                    let Nc, Dc = [];

                    function Mc() {}

                    function Oc(e, t) {
                        const i = Boolean(t) && t.getAudioTracks().length > 0,
                            n = Boolean(t) && t.getVideoTracks().length > 0,
                            s = {}; - 1 !== e.indexOf("video") && (s.video = n), -1 !== e.indexOf("audio") && (s.audio = i), Sc.emit(Rn.default.PERMISSIONS_CHANGED, s)
                    }

                    function wc(e) {
                        const t = e.filter((e => "audioinput" === e.kind)).length,
                            i = e.filter((e => "audiooutput" === e.kind)).length,
                            n = e.filter((e => "videoinput" === e.kind)).length,
                            s = e.filter((e => "videooutput" === e.kind)).length;
                        e.forEach((e => {
                            const r = {
                                audio_input_device_count: t,
                                audio_output_device_count: i,
                                video_input_device_count: n,
                                video_output_device_count: s,
                                device_id: e.deviceId,
                                device_group_id: e.groupId,
                                device_kind: e.kind,
                                device_label: e.label
                            };
                            Tn.sendAnalytics(ti, r)
                        }))
                    }

                    function Lc(e) {
                        (function(e) {
                            return e.length !== Dc.length || e.map(t).sort().join("") !== Dc.map(t).sort().join("");

                            function t(e) {
                                return JSON.stringify({
                                    kind: e.kind,
                                    deviceId: e.deviceId,
                                    groupId: e.groupId,
                                    label: e.label,
                                    facing: e.facing
                                })
                            }
                        })(e) && (Dc = e.slice(0), _c.info("list of media devices has changed:", Dc), wc(Dc), Sc.emit(Rn.default.DEVICE_LIST_WILL_CHANGE, Dc), Sc.emit(Rn.default.DEVICE_LIST_CHANGED, Dc))
                    }
                    const kc = new class extends Wn {
                            constructor() {
                                super(Sc)
                            }
                            init() {
                                var e;
                                let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                var i;
                                "boolean" == typeof t.disableAEC && (Cc = t.disableAEC, _c.info(`Disable AEC: ${Cc}`)), "boolean" == typeof t.disableNS && (bc = t.disableNS, _c.info(`Disable NS: ${bc}`)), "boolean" == typeof t.disableAP && (Tc = t.disableAP, _c.info(`Disable AP: ${Tc}`)), "boolean" == typeof t.disableAGC && (Rc = t.disableAGC, _c.info(`Disable AGC: ${Rc}`)), "boolean" == typeof(null === (e = t.audioQuality) || void 0 === e ? void 0 : e.stereo) && (Ac = t.audioQuality.stereo, _c.info(`Stereo: ${Ac}`)), window.clearInterval(Nc), Nc = void 0, Ui.isReactNative() || (this.attachMediaStream = (i = (e, t) => {
                                    e && (e.srcObject = t)
                                }, function(e, t) {
                                    const n = i.apply(kc, arguments);
                                    return t && kc.isDeviceChangeAvailable("output") && t.getAudioTracks && t.getAudioTracks().length && yc && e.setSinkId(kc.getAudioOutputDevice()).catch((function(t) {
                                        const i = new Nt(t, null, ["audiooutput"]);
                                        Gi().callUnhandledRejectionHandler({
                                            promise: this,
                                            reason: i
                                        }), _c.warn("Failed to set audio output device for the element. Default audio output device will be used instead", e, i)
                                    })), n
                                })), this.pcConstraints = {}, Mr.init(t), this.isDeviceListAvailable() && this.enumerateDevices((e => {
                                    Dc = e.slice(0), _c.debug("Available devices: ", Dc), wc(Dc), Sc.emit(Rn.default.DEVICE_LIST_AVAILABLE, Dc), Ui.supportsDeviceChangeEvent() ? navigator.mediaDevices.addEventListener("devicechange", (() => this.enumerateDevices(Mc))) : Nc = window.setInterval((() => this.enumerateDevices(Mc)), 3e3)
                                }))
                            }
                            enumerateDevices(e) {
                                navigator.mediaDevices.enumerateDevices().then((t => {
                                    Lc(t), e(t)
                                })).catch((t => {
                                    _c.warn(`Failed to  enumerate devices. ${t}`), Lc([]), e([])
                                }))
                            }
                            _getUserMedia(e) {
                                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                                return new Promise(((n, s) => {
                                    let r, o = !1;
                                    "number" == typeof i && !isNaN(i) && i > 0 && (r = setTimeout((() => {
                                        o = !0, r = void 0, s(new Nt(Ct))
                                    }), i)), navigator.mediaDevices.getUserMedia(t).then((t => {
                                        _c.log("onUserMediaSuccess"), Oc(e, t), o || (void 0 !== r && clearTimeout(r), n(t))
                                    })).catch((i => {
                                        _c.warn(`Failed to get access to local media. ${i} ${JSON.stringify(t)}`);
                                        const n = new Nt(i, t, e);
                                        o || (void 0 !== r && clearTimeout(r), s(n)), n.name === Et && Oc(e, void 0)
                                    }))
                                }))
                            }
                            _getDesktopMedia() {
                                return Mr.isSupported() ? new Promise(((e, t) => {
                                    Mr.obtainStream((t => {
                                        e(t)
                                    }), (e => {
                                        t(e)
                                    }))
                                })) : Promise.reject(new Error("Desktop sharing is not supported!"))
                            }
                            _getMissingTracks() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                    t = arguments.length > 1 ? arguments[1] : void 0;
                                const i = [],
                                    n = e.includes("audio"),
                                    s = t && t.getAudioTracks().length > 0;
                                n && !s && i.push("audio");
                                const r = e.includes("video"),
                                    o = t && t.getVideoTracks().length > 0;
                                return r && !o && i.push("video"), i
                            }
                            obtainAudioAndVideoPermissions(e) {
                                const {
                                    timeout: t,
                                    ...i
                                } = e, n = [], s = function() {
                                    if (-1 === (i.devices || []).indexOf("desktop")) return Promise.resolve();
                                    const {
                                        desktopSharingSourceDevice: e
                                    } = i;
                                    if (e) {
                                        const i = Dc && Dc.find((t => "videoinput" === t.kind && (t.deviceId === e || t.label === e)));
                                        if (!i) return Promise.reject(new Nt({
                                            name: "ConstraintNotSatisfiedError"
                                        }, {}, [e]));
                                        const n = ["video"],
                                            s = {
                                                video: {
                                                    deviceId: i.deviceId
                                                }
                                            };
                                        return this._getUserMedia(n, s, t).then((e => ({
                                            sourceType: "device",
                                            stream: e
                                        })))
                                    }
                                    return this._getDesktopMedia()
                                }.bind(this), r = function() {
                                    const e = (i.devices || ["audio", "video"]).filter((e => "audio" === e || "video" === e));
                                    if (!e.length) return Promise.resolve();
                                    const n = function() {
                                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                        const i = wr()(t.constraints || vc);
                                        if (e.indexOf("video") >= 0) {
                                            if (gc()[t.resolution]) {
                                                const e = gc()[t.resolution];
                                                i.video.height = {
                                                    ideal: e.height
                                                }, i.video.width = {
                                                    ideal: e.width
                                                }
                                            }
                                            if (i.video || (i.video = {}), Ui.isWebKitBased() && (i.video.height && i.video.height.ideal ? i.video.height = {
                                                    ideal: i.video.height.ideal
                                                } : _c.warn("Ideal camera height missing, camera may not start properly"), i.video.width && i.video.width.ideal ? i.video.width = {
                                                    ideal: i.video.width.ideal
                                                } : _c.warn("Ideal camera width missing, camera may not start properly")), t.cameraDeviceId) i.video.deviceId = t.cameraDeviceId;
                                            else {
                                                const e = t.facingMode || pa().USER;
                                                i.video.facingMode = e
                                            }
                                        } else i.video = !1;
                                        return e.indexOf("audio") >= 0 ? (i.audio && "boolean" != typeof i.audio || (i.audio = {}), i.audio = {
                                            autoGainControl: !Rc && !Tc,
                                            deviceId: t.micDeviceId,
                                            echoCancellation: !Cc && !Tc,
                                            noiseSuppression: !bc && !Tc
                                        }, Ac && Object.assign(i.audio, {
                                            channelCount: 2
                                        })) : i.audio = !1, i
                                    }(e, i);
                                    return _c.info("Got media constraints: ", JSON.stringify(n)), this._getUserMedia(e, n, t)
                                }.bind(this);
                                return s().then((function(e) {
                                    if (!e) return;
                                    const {
                                        stream: t,
                                        sourceId: i,
                                        sourceType: s
                                    } = e, r = t.getAudioTracks();
                                    if (r.length) {
                                        const e = new MediaStream(r);
                                        n.push({
                                            stream: e,
                                            sourceId: i,
                                            sourceType: s,
                                            track: e.getAudioTracks()[0]
                                        })
                                    }
                                    const o = t.getVideoTracks();
                                    if (o.length) {
                                        const e = new MediaStream(o);
                                        n.push({
                                            stream: e,
                                            sourceId: i,
                                            sourceType: s,
                                            track: e.getVideoTracks()[0],
                                            videoType: An.VideoType.DESKTOP
                                        })
                                    }
                                })).then(r).then((function(e) {
                                    if (!e) return;
                                    const t = e.getAudioTracks();
                                    if (t.length) {
                                        const e = new MediaStream(t);
                                        n.push({
                                            stream: e,
                                            track: e.getAudioTracks()[0],
                                            effects: i.effects
                                        })
                                    }
                                    const s = e.getVideoTracks();
                                    if (s.length) {
                                        const e = new MediaStream(s);
                                        n.push({
                                            stream: e,
                                            track: e.getVideoTracks()[0],
                                            videoType: An.VideoType.CAMERA,
                                            effects: i.effects
                                        })
                                    }
                                })).then((() => n)).catch((e => (n.forEach((e => {
                                    let {
                                        stream: t
                                    } = e;
                                    this.stopMediaStream(t)
                                })), Promise.reject(e))))
                            }
                            isDeviceListAvailable() {
                                return Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices)
                            }
                            isDeviceChangeAvailable(e) {
                                return "output" !== e && "audiooutput" !== e || Ic
                            }
                            stopMediaStream(e) {
                                e && (e.getTracks().forEach((e => {
                                    e.stop && e.stop()
                                })), e.stop && e.stop(), e.release && e.release())
                            }
                            isDesktopSharingEnabled() {
                                return Mr.isSupported()
                            }
                            setAudioOutputDevice(e) {
                                return this.isDeviceChangeAvailable("output") ? Pc.setSinkId(e).then((() => {
                                    Ec = e, yc = !0, _c.log(`Audio output device set to ${e}`), Sc.emit(Rn.default.AUDIO_OUTPUT_DEVICE_CHANGED, e)
                                })) : Promise.reject(new Error("Audio output device change is not supported"))
                            }
                            setDesktopSharingFrameRate(e) {
                                Mr.setDesktopSharingFrameRate(e)
                            }
                            getAudioOutputDevice() {
                                return Ec
                            }
                            getCurrentlyAvailableMediaDevices() {
                                return Dc
                            }
                            arePermissionsGrantedForAvailableDevices() {
                                return Dc.some((e => Boolean(e.label)))
                            }
                            getEventDataForActiveDevice(e) {
                                const t = [],
                                    i = {
                                        deviceId: e.deviceId,
                                        kind: e.kind,
                                        label: e.label,
                                        groupId: e.groupId
                                    };
                                return t.push(i), {
                                    deviceList: t
                                }
                            }
                        },
                        xc = kc,
                        Fc = (0, v.getLogger)("modules/RTC/JitsiTrack.js"),
                        Vc = {
                            track_mute: "onmute",
                            track_unmute: "onunmute",
                            track_ended: "onended"
                        };
                    class Uc extends(dt()) {
                        constructor(e, t, i, n, s, r) {
                            super(), this.addEventListener = this.addListener, this.removeEventListener = this.off = this.removeListener, this.containers = [], this.conference = e, this.audioLevel = -1, this.type = s, this.track = i, this.videoType = r, this.handlers = new Map, this.disposed = !1, this._streamInactiveHandler = n, this._setStream(t)
                        }
                        _addMediaStreamInactiveHandler(e) {
                            Ui.isFirefox() ? this.track.onended = e : this.stream.oninactive = e
                        }
                        _setHandler(e, t) {
                            if (Vc.hasOwnProperty(e)) {
                                if (t ? this.handlers.set(e, t) : this.handlers.delete(e), this.stream)
                                    for (const i of this.stream.getTracks()) i[Vc[e]] = t
                            } else Fc.error(`Invalid handler type ${e}`)
                        }
                        _unregisterHandlers() {
                            if (this.stream) {
                                for (const e of this.handlers.keys())
                                    for (const t of this.stream.getVideoTracks()) t[Vc[e]] = void 0;
                                this._streamInactiveHandler && this._addMediaStreamInactiveHandler(void 0)
                            } else Fc.warn(`${this}: unable to unregister handlers - no stream object`)
                        }
                        _setStream(e) {
                            if (this.stream !== e && (this.stream = e, this.stream)) {
                                for (const e of this.handlers.keys()) this._setHandler(e, this.handlers.get(e));
                                this._streamInactiveHandler && this._addMediaStreamInactiveHandler(this._streamInactiveHandler)
                            }
                        }
                        getVideoType() {
                            return this.videoType
                        }
                        getType() {
                            return this.type
                        }
                        isAudioTrack() {
                            return this.getType() === dn.AUDIO
                        }
                        isWebRTCTrackMuted() {
                            return this.track && this.track.muted
                        }
                        isVideoTrack() {
                            return this.getType() === dn.VIDEO
                        }
                        isLocal() {
                            throw new Error("Not implemented by subclass")
                        }
                        isLocalAudioTrack() {
                            return this.isAudioTrack() && this.isLocal()
                        }
                        getOriginalStream() {
                            return this.stream
                        }
                        getStreamId() {
                            return this.stream ? this.stream.id : null
                        }
                        getTrack() {
                            return this.track
                        }
                        getTrackLabel() {
                            return this.track.label
                        }
                        getTrackId() {
                            return this.track ? this.track.id : null
                        }
                        getUsageLabel() {
                            return this.isAudioTrack() ? "mic" : this.videoType ? this.videoType : "default"
                        }
                        _maybeFireTrackAttached(e) {
                            this.conference && e && this.conference._onTrackAttach(this, e)
                        }
                        attach(e) {
                            this.stream && (this._onTrackAttach(e), xc.attachMediaStream(e, this.stream)), this.containers.push(e), this._maybeFireTrackAttached(e), this._attachTTFMTracker(e)
                        }
                        detach(e) {
                            for (let t = this.containers, i = t.length - 1; i >= 0; --i) {
                                const n = t[i];
                                e || (this._onTrackDetach(n), xc.attachMediaStream(n, null)), e && n !== e || t.splice(i, 1)
                            }
                            e && (this._onTrackDetach(e), xc.attachMediaStream(e, null))
                        }
                        _onTrackAttach(e) {}
                        _onTrackDetach(e) {}
                        _attachTTFMTracker(e) {}
                        dispose() {
                            return this.removeAllListeners(), this.disposed = !0, Promise.resolve()
                        }
                        getId() {
                            return this.getStreamId()
                        }
                        isActive() {
                            return void 0 === this.stream.active || this.stream.active
                        }
                        setAudioLevel(e, t) {
                            let i = e;
                            Ui.supportsReceiverStats() && void 0 !== t && this.isMuted() && (i = 0), this.audioLevel !== i ? (this.audioLevel = i, this.emit(Ot, i, t)) : 0 === this.audioLevel && 0 === i && this.isLocal() && !this.isWebRTCTrackMuted() && this.emit(Ft, i)
                        }
                        getMSID() {
                            const e = this.getStreamId(),
                                t = this.getTrackId();
                            return e && t ? `${e} ${t}` : null
                        }
                        setAudioOutput(e) {
                            return xc.isDeviceChangeAvailable("output") ? this.isVideoTrack() ? Promise.resolve() : Promise.all(this.containers.map((t => t.setSinkId(e).catch((e => {
                                throw Fc.warn("Failed to change audio output device on element. Default or previously set audio output device will be used.", t, e), e
                            }))))).then((() => {
                                this.emit(wt, e)
                            })) : Promise.reject(new Error("Audio output device change is not supported"))
                        }
                    }
                    const jc = (0, v.getLogger)("modules/RTC/JitsiLocalTrack.js");
                    class $c extends Uc {
                        constructor(e) {
                            let {
                                deviceId: t,
                                facingMode: i,
                                mediaType: n,
                                resolution: s,
                                rtcId: r,
                                sourceId: o,
                                sourceType: a,
                                stream: c,
                                track: d,
                                videoType: l,
                                effects: h = []
                            } = e;
                            super(null, c, d, (() => this.emit(Mt)), n, l), this._setEffectInProgress = !1;
                            const u = h.find((e => e.isEnabled(this)));
                            u && this._startStreamEffect(u);
                            const p = l === An.VideoType.DESKTOP ? d.getSettings().displaySurface : null;
                            this.metadata = {
                                timestamp: Date.now(),
                                ...p ? {
                                    displaySurface: p
                                } : {}
                            }, this.rtcId = r, this.sourceId = o, this.sourceType = a, this.resolution = d.getSettings().height, this.maxEnabledResolution = s, this._constraints = d.getConstraints(), Object.keys(this._constraints).length || l !== An.VideoType.CAMERA || (this._constraints = {
                                height: d.getSettings().height,
                                width: d.getSettings().width
                            }), this.deviceId = t, this._prevSetMuted = Promise.resolve(), this._facingMode = i, this._trackEnded = !1, this._hasSentData = !1, this._testDataSent = !0, this._realDeviceId = "" === this.deviceId ? void 0 : this.deviceId, this._sourceName = null, this._trackMutedTS = 0, this._onDeviceListWillChange = e => {
                                const t = this._realDeviceId;
                                this._setRealDeviceIdFromDeviceList(e), (void 0 === this.getTrack().readyState && void 0 !== this._realDeviceId && !e.find((e => e.deviceId === this._realDeviceId)) || void 0 !== t && void 0 === this._realDeviceId) && (this._trackEnded = !0)
                            }, this.isAudioTrack() && xc.isDeviceChangeAvailable("output") && (this._onAudioOutputDeviceChanged = this.setAudioOutput.bind(this), xc.addListener(Rn.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged)), xc.addListener(Rn.default.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._initNoDataFromSourceHandlers()
                        }
                        _addStreamToConferenceAsUnmute() {
                            return this.conference ? new Promise(((e, t) => {
                                this.conference._addLocalTrackToPc(this).then(e, (e => t(new Error(e))))
                            })) : Promise.resolve()
                        }
                        _fireNoDataFromSourceEvent() {
                            const e = !this.isReceivingData();
                            this.emit(xt, e), Tn.sendAnalytics(((e, t) => ({
                                attributes: {
                                    media_type: e,
                                    value: t
                                },
                                action: "track.no.data.from.source",
                                type: Ut.TYPE_OPERATIONAL
                            }))(this.getType(), e)), Tn.sendLog(JSON.stringify({
                                name: xt,
                                log: e
                            }))
                        }
                        _initNoDataFromSourceHandlers() {
                            this._isNoDataFromSourceEventsEnabled() && (this._setHandler("track_mute", (() => {
                                this._trackMutedTS = window.performance.now(), this._fireNoDataFromSourceEvent()
                            })), this._setHandler("track_unmute", (() => {
                                this._fireNoDataFromSourceEvent(), Tn.sendAnalyticsAndLog(ci, {
                                    media_type: this.getType(),
                                    track_type: "local",
                                    value: window.performance.now() - this._trackMutedTS
                                })
                            })), this.isVideoTrack() && this.videoType === An.VideoType.CAMERA && this._setHandler("track_ended", (() => {
                                this.isReceivingData() || this._fireNoDataFromSourceEvent()
                            })))
                        }
                        _isNoDataFromSourceEventsEnabled() {
                            return !this.isVideoTrack() || this.videoType !== An.VideoType.DESKTOP
                        }
                        _queueSetMuted(e) {
                            const t = this._setMuted.bind(this, e);
                            return this._prevSetMuted = this._prevSetMuted.then(t, t), this._prevSetMuted
                        }
                        _removeStreamFromConferenceAsMute(e, t) {
                            this.conference ? this.conference._removeLocalTrackFromPc(this).then(e, (e => t(new Error(e)))) : e()
                        }
                        _sendMuteStatus(e) {
                            this.conference && this.conference._setTrackMuteStatus(this.getType(), this, e) && this.conference.room.sendPresence()
                        }
                        _setMuted(e) {
                            if (this.isMuted() === e && (this.videoType !== An.VideoType.DESKTOP || !hn.isMultiStreamSupportEnabled())) return Promise.resolve();
                            if (this.disposed) return Promise.reject(new Nt(bt));
                            let t = Promise.resolve();
                            const i = () => jc.info(`Mute ${this}: ${e}`);
                            if (this.isAudioTrack() || this.videoType === An.VideoType.DESKTOP && !hn.isMultiStreamSupportEnabled() || !Ui.doesVideoMuteByStreamRemove()) i(), this._streamEffect && this._streamEffect.setMuted ? this._streamEffect.setMuted(e) : this.track && (this.track.enabled = !e);
                            else if (e) t = new Promise(((e, t) => {
                                i(), this._removeStreamFromConferenceAsMute((() => {
                                    this._streamEffect && this._stopStreamEffect(), this._unregisterHandlers(), this.stopStream(), this._setStream(null), e()
                                }), t)
                            }));
                            else {
                                i();
                                const e = {
                                    cameraDeviceId: this.getDeviceId(),
                                    devices: [dn.VIDEO],
                                    effects: this._streamEffect ? [this._streamEffect] : [],
                                    facingMode: this.getCameraFacingMode()
                                };
                                t = xc.obtainAudioAndVideoPermissions(Object.assign({}, e, {
                                    constraints: {
                                        video: this._constraints
                                    }
                                })), t = t.then((e => {
                                    const t = this.getType() === dn.PRESENTER ? dn.VIDEO : this.getType(),
                                        i = e.find((e => e.track.kind === t));
                                    if (!i) throw new Nt(Rt);
                                    return this._setStream(i.stream), this.track = i.track, this.videoType !== i.videoType && (jc.warn(`${this}: video type has changed after unmute!`, this.videoType, i.videoType), this.videoType = i.videoType), this._streamEffect && this._startStreamEffect(this._streamEffect), this.containers.map((e => xc.attachMediaStream(e, this.stream))), this._addStreamToConferenceAsUnmute()
                                }))
                            }
                            return t.then((() => {
                                this._sendMuteStatus(e), this.isVideoTrack() && this.conference && this.conference._sendBridgeVideoTypeMessage(this), this.emit(Lt, this)
                            }))
                        }
                        _setRealDeviceIdFromDeviceList(e) {
                            const t = this.getTrack(),
                                i = `${t.kind}input`;
                            let n = e.find((e => e.kind === i && e.label === t.label && e.deviceId === this.deviceId));
                            if (!n && "default" === this._realDeviceId) {
                                const s = (t.label || "").replace("Default - ", "");
                                n = e.find((e => e.kind === i && e.label === s))
                            }
                            this._realDeviceId = n ? n.deviceId : void 0
                        }
                        _setStream(e) {
                            super._setStream(e), e ? (this.storedMSID = this.getMSID(), jc.debug(`Setting new MSID: ${this.storedMSID} on ${this}`)) : jc.debug(`Setting 'null' stream on ${this}`)
                        }
                        _startStreamEffect(e) {
                            this._streamEffect = e, this._originalStream = this.stream, this._setStream(this._streamEffect.startEffect(this._originalStream)), this.track = this.stream.getTracks()[0]
                        }
                        _stopStreamEffect() {
                            this._streamEffect && (this._streamEffect.stopEffect(), this._setStream(this._originalStream), this._originalStream = null, this.track = this.stream ? this.stream.getTracks()[0] : null)
                        }
                        _switchCamera() {
                            this.isVideoTrack() && this.videoType === An.VideoType.CAMERA && "function" == typeof this.track._switchCamera && (this.track._switchCamera(), this._facingMode = this._facingMode === pa().ENVIRONMENT ? pa().USER : pa().ENVIRONMENT)
                        }
                        _switchStreamEffect(e) {
                            this._streamEffect && (this._stopStreamEffect(), this._streamEffect = void 0), e && this._startStreamEffect(e)
                        }
                        dispose() {
                            let e = Promise.resolve();
                            this._streamEffect && (e = this.setEffect());
                            let t = Promise.resolve();
                            return this.conference && (t = this.conference.removeTrack(this)), this.stream && (this.stopStream(), this.detach()), xc.removeListener(Rn.default.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._onAudioOutputDeviceChanged && xc.removeListener(Rn.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged), Promise.allSettled([e, t]).then((() => super.dispose()))
                        }
                        getCameraFacingMode() {
                            if (this.isVideoTrack() && this.videoType === An.VideoType.CAMERA) {
                                var e, t;
                                const i = null === (e = (t = this.track).getSettings) || void 0 === e ? void 0 : e.call(t);
                                return i && "facingMode" in i ? i.facingMode : void 0 !== this._facingMode ? this._facingMode : pa().USER
                            }
                        }
                        getDeviceId() {
                            return this._realDeviceId || this.deviceId
                        }
                        getDuration() {
                            return Date.now() / 1e3 - this.metadata.timestamp / 1e3
                        }
                        getParticipantId() {
                            return this.conference && this.conference.myUserId()
                        }
                        getSourceName() {
                            return this._sourceName
                        }
                        isEnded() {
                            return this.isVideoTrack() && this.isMuted() ? this._trackEnded : "ended" === this.getTrack().readyState || this._trackEnded
                        }
                        isLocal() {
                            return !0
                        }
                        isMuted() {
                            return !this.stream || !(!this.isVideoTrack() || this.isActive()) || (this._streamEffect && this._streamEffect.isMuted ? this._streamEffect.isMuted() : !this.track || !this.track.enabled)
                        }
                        isReceivingData() {
                            return !(!this.isVideoTrack() || !this.isMuted() && !this._stopStreamInProgress && this.videoType !== An.VideoType.DESKTOP) || !!this.stream && (this._effectEnabled ? this._originalStream : this.stream).getTracks().some((e => !("readyState" in e && "live" !== e.readyState || "muted" in e && !0 === e.muted)))
                        }
                        mute() {
                            return this._queueSetMuted(!0)
                        }
                        onByteSentStatsReceived(e, t) {
                            t > 0 && (this._hasSentData = !0);
                            const i = e.getConnectionState();
                            this._testDataSent && "connected" === i && (setTimeout((() => {
                                this._hasSentData || (jc.warn(`${this} 'bytes sent' <= 0:                         ${t}`), Tn.analytics.sendEvent(ai, {
                                    media_type: this.getType()
                                }))
                            }), 3e3), this._testDataSent = !1)
                        }
                        setConference(e) {
                            this.conference = e;
                            for (let e = 0; e < this.containers.length; e++) this._maybeFireTrackAttached(this.containers[e])
                        }
                        setEffect(e) {
                            if (void 0 === this._streamEffect && void 0 === e) return Promise.resolve();
                            if (void 0 !== e && !e.isEnabled(this)) return Promise.reject(new Error("Incompatible effect instance!"));
                            if (!0 === this._setEffectInProgress) return Promise.reject(new Error("setEffect already in progress!"));
                            if (this.isMuted() && !this.isAudioTrack()) return this._streamEffect = e, Promise.resolve();
                            const t = this.conference;
                            return t ? (this._setEffectInProgress = !0, t._removeLocalTrackFromPc(this).then((() => (this._switchStreamEffect(e), this.isVideoTrack() && this.containers.forEach((e => xc.attachMediaStream(e, this.stream))), t._addLocalTrackToPc(this)))).then((() => {
                                this._setEffectInProgress = !1
                            })).catch((e => {
                                throw this._setEffectInProgress = !1, this._switchStreamEffect(), jc.error("Failed to switch to the new stream!", e), e
                            }))) : (this._switchStreamEffect(e), this.isVideoTrack() && this.containers.forEach((e => xc.attachMediaStream(e, this.stream))), Promise.resolve())
                        }
                        setSourceName(e) {
                            this._sourceName = e
                        }
                        stopStream() {
                            this._stopStreamInProgress = !0;
                            try {
                                xc.stopMediaStream(this.stream)
                            } finally {
                                this._stopStreamInProgress = !1
                            }
                        }
                        toString() {
                            return `LocalTrack[${this.rtcId},${this.getType()}]`
                        }
                        unmute() {
                            return this._queueSetMuted(!1)
                        }
                    }
                    var Hc = i(6561);
                    const Bc = function(e, t) {
                            return void 0 !== e && void 0 !== e.media && Array.isArray(e.media) && e.media.forEach((e => {
                                e.sources && e.sources.length && (e.ssrcs = [], e.sources.forEach((t => {
                                    Object.keys(t).forEach((i => {
                                        "id" !== i && e.ssrcs.push({
                                            id: t.id,
                                            attribute: i,
                                            value: t[i]
                                        })
                                    }))
                                })), delete e.sources), e.ssrcGroups && e.ssrcGroups.length && e.ssrcGroups.forEach((e => {
                                    void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.ssrcs = e.ssrcs.join(" "))
                                }))
                            })), Hc.write(e, t)
                        },
                        Jc = function(e) {
                            const t = Hc.parse(e);
                            return void 0 !== t && void 0 !== t.media && Array.isArray(t.media) && t.media.forEach((e => {
                                void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.sources = [], e.ssrcs.forEach((t => {
                                    const i = e.sources.findIndex((e => e.id === t.id));
                                    if (i > -1) e.sources[i][t.attribute] = t.value;
                                    else {
                                        const i = {
                                            id: t.id
                                        };
                                        i[t.attribute] = t.value, e.sources.push(i)
                                    }
                                })), delete e.ssrcs), void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach((e => {
                                    "string" == typeof e.ssrcs && (e.ssrcs = e.ssrcs.split(" "))
                                }))
                            })), t
                        },
                        Gc = ["audio", "video", "data"],
                        Kc = e => e.find((e => "SIM" === e.semantics)),
                        qc = e => e.find((e => "FID" === e.semantics));

                    function Wc(e, t, i, n) {
                        if (!e || !t) return;
                        const s = e => n.find((t => t.id.toString() === e));
                        t.ssrcs.forEach((t => {
                            e.sources.push(s(t));
                            const n = i[parseInt(t, 10)].find((e => "FID" === e.semantics));
                            if (n) {
                                const i = n.ssrcs.find((e => e !== t));
                                e.sources.push(s(i)), e.ssrcGroups.push(n)
                            }
                        })), e.ssrcGroups.push(t)
                    }

                    function Xc(e, t, i, n) {
                        if (!e || !t) return;
                        if (e.sources = [], e.ssrcGroups = [], !i[t.id]) return e.sources.push(t), void(e.msid = t.msid);
                        const s = Kc(i[t.id]),
                            r = qc(i[t.id]);
                        if (s) Wc(e, s, i, n);
                        else if (r) {
                            const s = r.ssrcs.find((e => e !== t)),
                                o = Kc(i[s]);
                            o ? Wc(e, o, i, n) : (r.ssrcs.forEach((t => {
                                e.sources.push((e => n.find((t => t.id.toString() === e)))(t))
                            })), e.ssrcGroups.push(r))
                        }
                        e.msid = e.sources[0].msid
                    }

                    function zc(e, t, i) {
                        if (!i.find((t => !!t.sources && t.sources.some((t => t.id === e.id))))) {
                            if (!t[e.id]) return !1;
                            const n = Kc(t[e.id]),
                                s = qc(t[e.id]);
                            return n ? i.some((e => e.sources && e.sources.some((e => e.id.toString() === n.ssrcs[0])))) : !(!s || e.id.toString() === s.ssrcs[0]) && zc({
                                id: s.ssrcs[0]
                            }, t, i)
                        }
                        return !0
                    }
                    class Qc {
                        toPlanB(e) {
                            if (!e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
                            const t = Jc(e.sdp);
                            if (!t.media || !t.media.length) return console.warn("The description has no media."), e;
                            if (t.media.every((e => -1 !== Gc.indexOf(e.mid)))) return console.warn("The description does not look like unified plan sdp"), e;
                            const i = {},
                                n = t.media;
                            t.media = [], n.forEach((e => {
                                const t = e.type;
                                if ("application" === t) return e.mid = "data", void(i[e.mid] = e);
                                if (void 0 === i[t]) {
                                    const n = Or(e);
                                    n.sources && Array.isArray(n.sources) && n.sources.forEach((t => {
                                        e.msid ? t.msid = e.msid : delete t.msid
                                    })), n.ssrcGroups && e.msid || (n.ssrcGroups = []), delete n.msid, n.mid = t, i[t] = n
                                } else if (e.msid) {
                                    const n = Or(e);
                                    n.sources && Array.isArray(n.sources) && (n.sources.forEach((t => {
                                        t.msid = e.msid
                                    })), i[t].sources = (i[t].sources || []).concat(n.sources)), void 0 !== n.ssrcGroups && Array.isArray(n.ssrcGroups) && (i[t].ssrcGroups = (i[t].ssrcGroups || []).concat(n.ssrcGroups))
                                }
                            })), t.media = Object.values(i);
                            const s = [];
                            Object.values(i).forEach((e => {
                                "inactive" !== e.direction && s.push(e.mid)
                            })), t.groups.forEach((e => {
                                "BUNDLE" === e.type && (e.mids = s.join(" "))
                            })), t.msidSemantic = {
                                semantic: "WMS",
                                token: "*"
                            };
                            const r = Bc(t);
                            return new RTCSessionDescription({
                                type: e.type,
                                sdp: r
                            })
                        }
                        toUnifiedPlan(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                            if (!e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
                            const i = Jc(e.sdp);
                            if (!i.media || !i.media.length) return console.warn("The description has no media."), e;
                            if (i.media.length > 3 || i.media.every((e => -1 === Gc.indexOf(e.mid)))) return console.warn("The description does not look like plan-b"), e;
                            const n = t ? Jc(t.sdp) : null,
                                s = function(e, t) {
                                    if (!e || !t || 0 === e.media.length || 0 === t.media.length) return !1;
                                    const i = e.media[0],
                                        n = t.media[0];
                                    return i.iceUfrag !== n.iceUfrag || i.icePwd !== n.icePwd
                                }(i, n),
                                r = i.media[0].iceUfrag,
                                o = i.media[0].icePwd,
                                a = i.media[0].fingerprint,
                                c = {};
                            i.media.forEach((e => {
                                const t = e.type;
                                if ("application" === t) {
                                    if (!n || !n.media) {
                                        const t = Or(e);
                                        return t.mid = Object.keys(c).length.toString(), void(c[e.mid] = t)
                                    }
                                    const i = n.media.findIndex((e => e.type === t));
                                    return void(i && (n.media[i] = e, n.media[i].mid = i))
                                }
                                const i = function(e) {
                                    const t = {};
                                    return e && Array.isArray(e) ? (e.forEach((e => {
                                        e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach((i => {
                                            void 0 === t[i] && (t[i] = []), t[i].push(e)
                                        }))
                                    })), t) : t
                                }(e.ssrcGroups);
                                if (e.sources) e.sources.forEach(((t, s) => {
                                    if (!t.msid) return;
                                    if (!n || !n.media) {
                                        if (zc(t, i, Object.values(c))) return;
                                        const n = Or(e);
                                        return n.mid = Object.keys(c).length.toString(), n.direction = s || "sendonly" === e.direction ? "sendonly" : "sendrecv", n.bundleOnly = void 0, Xc(n, t, i, e.sources), void(c[n.mid] = n)
                                    }
                                    if (zc(t, i, n.media)) return;
                                    const r = Or(e);
                                    r.mid = n.media.length.toString(), r.direction = "sendonly", Xc(r, t, i, e.sources), n.media.push(r)
                                }));
                                else if (!n) {
                                    const t = Or(e);
                                    t.mid = Object.keys(c).length.toString(), c[e.mid] = t
                                }
                            })), i.media = n ? n.media : Object.values(c);
                            const d = [];
                            i.media.forEach((e => {
                                d.push(e.mid), s && (e.iceUfrag = r, e.icePwd = o, e.fingerprint = a)
                            })), i.groups.forEach((e => {
                                "BUNDLE" === e.type && (e.mids = d.join(" "))
                            })), i.msidSemantic = {
                                semantic: "WMS",
                                token: "*"
                            }, i.origin.sessionVersion++;
                            const l = Bc(i);
                            return new RTCSessionDescription({
                                type: e.type,
                                sdp: l
                            })
                        }
                    }
                    let Yc;
                    ! function(e) {
                        e.PEER_MUTED_CHANGED = "signaling.peerMuted", e.PEER_VIDEO_TYPE_CHANGED = "signaling.peerVideoType", e.SOURCE_MUTED_CHANGED = "signaling.sourceMuted", e.SOURCE_VIDEO_TYPE_CHANGED = "signaling.sourceVideoType"
                    }(Yc || (Yc = {}));
                    const Zc = Yc.PEER_MUTED_CHANGED,
                        ed = Yc.PEER_VIDEO_TYPE_CHANGED,
                        td = Yc.SOURCE_MUTED_CHANGED,
                        id = Yc.SOURCE_VIDEO_TYPE_CHANGED;

                    function nd(e, t, i) {
                        return `${e}-${t.substring(0,1)}${i}`
                    }

                    function sd(e) {
                        const t = e.indexOf("-") + 1;
                        if (t <= 0) throw new Error(`Invalid source name: ${e}`);
                        const i = e.substr(t, 1);
                        for (const e of Object.values(dn))
                            if (e.substr(0, 1) === i) return e;
                        throw new Error(`Invalid source name: ${e}`)
                    }
                    class rd extends Wn {
                        getSSRCOwner(e) {
                            throw new Error("not implemented")
                        }
                        getPeerMediaInfo(e, t) {
                            throw new Error("not implemented")
                        }
                        getPeerSourceInfo(e, t) {
                            throw new Error("not implemented")
                        }
                        getTrackSourceName(e) {
                            throw new Error("not implemented")
                        }
                    }

                    function od(e) {
                        return parseInt(e.ssrcs.split(" ")[0], 10)
                    }

                    function ad(e) {
                        return parseInt(e.ssrcs.split(" ")[1], 10)
                    }

                    function cd(e) {
                        return e.ssrcs ? e.ssrcs.map((e => e.id)).filter(((e, t, i) => i.indexOf(e) === t)).length : 0
                    }
                    class dd {
                        constructor(e) {
                            if (!e) throw new Error("mLine is undefined");
                            this.mLine = e
                        }
                        get ssrcs() {
                            return this.mLine.ssrcs || (this.mLine.ssrcs = []), this.mLine.ssrcs
                        }
                        set ssrcs(e) {
                            this.mLine.ssrcs = e
                        }
                        get direction() {
                            return this.mLine.direction
                        }
                        set direction(e) {
                            this.mLine.direction = e
                        }
                        get ssrcGroups() {
                            return this.mLine.ssrcGroups || (this.mLine.ssrcGroups = []), this.mLine.ssrcGroups
                        }
                        set ssrcGroups(e) {
                            this.mLine.ssrcGroups = e
                        }
                        getSSRCAttrValue(e, t) {
                            const i = this.ssrcs.find((i => i.id === e && i.attribute === t));
                            return i && i.value
                        }
                        removeSSRC(e) {
                            this.mLine.ssrcs && this.mLine.ssrcs.length && (this.mLine.ssrcs = this.mLine.ssrcs.filter((t => t.id !== e)))
                        }
                        addSSRCAttribute(e) {
                            this.ssrcs.push(e)
                        }
                        findGroup(e, t) {
                            return this.ssrcGroups.find((i => i.semantics === e && (!t || t === i.ssrcs)))
                        }
                        findGroups(e) {
                            return this.ssrcGroups.filter((t => t.semantics === e))
                        }
                        findGroupByPrimarySSRC(e, t) {
                            return this.ssrcGroups.find((i => i.semantics === e && od(i) === t))
                        }
                        findSSRCByMSID(e) {
                            return this.ssrcs.find((t => "msid" === t.attribute && (null === e || t.value === e)))
                        }
                        getSSRCCount() {
                            return cd(this.mLine)
                        }
                        containsAnySSRCGroups() {
                            return void 0 !== this.mLine.ssrcGroups
                        }
                        getPrimaryVideoSsrc() {
                            const e = this.mLine.type;
                            if ("video" !== e) throw new Error(`getPrimarySsrc doesn't work with '${e}'`);
                            if (1 === cd(this.mLine)) return this.mLine.ssrcs[0].id;
                            if (this.mLine.ssrcGroups) {
                                const e = this.findGroup("SIM");
                                if (e) return od(e);
                                const t = this.findGroup("FID");
                                if (t) return od(t);
                                const i = this.findGroup("FEC-FR");
                                if (i) return od(i)
                            }
                        }
                        getRtxSSRC(e) {
                            const t = this.findGroupByPrimarySSRC("FID", e);
                            return t && ad(t)
                        }
                        getSSRCs() {
                            return this.ssrcs.map((e => e.id)).filter(((e, t, i) => i.indexOf(e) === t))
                        }
                        getPrimaryVideoSSRCs() {
                            const e = this.mLine.type;
                            if ("video" !== e) throw new Error(`getPrimaryVideoSSRCs doesn't work with ${e}`);
                            const t = this.getSSRCs();
                            for (const e of this.ssrcGroups)
                                if ("FID" === e.semantics || "FEC-FR" === e.semantics) {
                                    const i = ad(e);
                                    t.splice(t.indexOf(i), 1)
                                } return t
                        }
                        dumpSSRCGroups() {
                            return JSON.stringify(this.mLine.ssrcGroups)
                        }
                        removeGroupsWithSSRC(e) {
                            this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter((t => -1 === t.ssrcs.indexOf(`${e}`))))
                        }
                        removeGroupsBySemantics(e) {
                            this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter((t => t.semantics !== e)))
                        }
                        replaceSSRC(e, t) {
                            this.mLine.ssrcs && this.mLine.ssrcs.forEach((i => {
                                i.id === e && (i.id = t)
                            }))
                        }
                        addSSRCGroup(e) {
                            this.ssrcGroups.push(e)
                        }
                    }
                    class ld {
                        constructor(e) {
                            this.parsedSDP = Lr.parse(e)
                        }
                        selectMedia(e) {
                            const t = this.parsedSDP.media.filter((t => t.type === e)).map((e => new dd(e)));
                            return null != t ? t : null
                        }
                        toRawSDP() {
                            return Lr.write(this.parsedSDP)
                        }
                    }
                    const hd = (0, v.getLogger)("modules/sdp/LocalSdpMunger.js");
                    class ud {
                        constructor(e, t) {
                            this.tpc = e, this.localEndpointId = t, this.audioSourcesToMsidMap = new Map, this.videoSourcesToMsidMap = new Map
                        }
                        _addMutedLocalVideoTracksToSDP(e) {
                            var t;
                            const i = this.tpc.getLocalTracks(dn.VIDEO);
                            if (!i.length) return !1;
                            1 !== i.length && hd.error(`${this.tpc} there is more than 1 video track ! Strange things may happen !`, i);
                            const n = null === (t = e.selectMedia(dn.VIDEO)) || void 0 === t ? void 0 : t[0];
                            if (!n) return hd.debug(`${this.tpc} unable to hack local video track SDP- no "video" media`), !1;
                            let s = !1;
                            for (const e of i) {
                                const t = e.isMuted(),
                                    i = e.getOriginalStream(),
                                    r = e.videoType === An.VideoType.CAMERA,
                                    o = i && this.tpc.isMediaStreamInPc(i);
                                if (!r || !t && o) continue;
                                const a = this.tpc.isSimulcastOn() ? this.tpc.simulcast.ssrcCache : [this.tpc.sdpConsistency.cachedPrimarySsrc];
                                if (!a.length) {
                                    hd.error(`No SSRCs stored for: ${e} in ${this.tpc}`);
                                    continue
                                }
                                s = !0, n.direction = Ir.SENDRECV;
                                const c = `injected-${a[0]}`;
                                for (const t of a) n.removeSSRC(t), n.addSSRCAttribute({
                                    id: t,
                                    attribute: "cname",
                                    value: c
                                }), n.addSSRCAttribute({
                                    id: t,
                                    attribute: "msid",
                                    value: e.storedMSID
                                });
                                if (a.length > 1) {
                                    const e = {
                                        ssrcs: a.join(" "),
                                        semantics: "SIM"
                                    };
                                    n.findGroup(e.semantics, e.ssrcs) || n.addSSRCGroup(e)
                                }
                                this.tpc.options.disableRtx || this.tpc.rtxModifier.modifyRtxSsrcs2(n)
                            }
                            return s
                        }
                        _generateMsidAttribute(e, t) {
                            let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                            if (!e || !t) return hd.error(`Unable to munge local MSID - track id=${t} or media type=${e} is missing`), null;
                            const n = this.tpc.id;
                            return "-" !== i && i ? `${i}-${n} ${t}-${n}` : `${this.localEndpointId}-${e}-${n} ${t}-${n}`
                        }
                        _transformMediaIdentifiers(e) {
                            var t, i, n, s, r;
                            const o = null === (t = e.mLine) || void 0 === t ? void 0 : t.type,
                                a = this.tpc.id;
                            for (const t of e.ssrcs) switch (t.attribute) {
                                case "cname":
                                case "label":
                                case "mslabel":
                                    t.value = t.value && `${t.value}-${a}`;
                                    break;
                                case "msid":
                                    if (t.value) {
                                        const e = t.value.split(" ");
                                        let i = e[0];
                                        const n = e[1];
                                        hn.isSourceNameSignalingEnabled() && (i = `${this.localEndpointId}-${o}`, o === dn.VIDEO ? this.videoSourcesToMsidMap.has(n) || (i = `${i}-${this.videoSourcesToMsidMap.size}`, this.videoSourcesToMsidMap.set(n, i)) : this.audioSourcesToMsidMap.has(n) || (i = `${i}-${this.audioSourcesToMsidMap.size}`, this.audioSourcesToMsidMap.set(n, i)), i = o === dn.VIDEO ? this.videoSourcesToMsidMap.get(n) : this.audioSourcesToMsidMap.get(n)), t.value = this._generateMsidAttribute(o, n, i)
                                    } else hd.warn(`Unable to munge local MSID - weird format detected: ${t.value}`)
                            }
                            if (!this.tpc.usesUnifiedPlan()) return;
                            const c = null === (i = e.mLine) || void 0 === i ? void 0 : i.direction;
                            !Ui.isFirefox() || c !== Ir.RECVONLY && c !== Ir.INACTIVE || (o !== dn.VIDEO || this.tpc._hasHadVideoTrack) && (o !== dn.AUDIO || this.tpc._hasHadAudioTrack) || (e.ssrcs = void 0, e.ssrcGroups = void 0);
                            const d = null === (n = e.mLine) || void 0 === n ? void 0 : n.msid,
                                l = d && d.split(" ")[1],
                                h = [...new Set(null === (s = e.mLine) || void 0 === s || null === (r = s.ssrcs) || void 0 === r ? void 0 : r.map((e => e.id)))];
                            for (const t of h)
                                if (!e.ssrcs.find((e => e.id === t && "msid" === e.attribute)) && l) {
                                    const i = this._generateMsidAttribute(o, l);
                                    e.ssrcs.push({
                                        id: t,
                                        attribute: "msid",
                                        value: i
                                    })
                                }
                        }
                        maybeAddMutedLocalVideoTracksToSDP(e) {
                            if (!e) throw new Error("No local description passed in.");
                            const t = new ld(e.sdp);
                            return this._addMutedLocalVideoTracksToSDP(t) ? new RTCSessionDescription({
                                type: e.type,
                                sdp: t.toRawSDP()
                            }) : e
                        }
                        transformStreamIdentifiers(e) {
                            var t;
                            if (!e || !e.sdp || !e.type) return e;
                            const i = new ld(e.sdp),
                                n = null === (t = i.selectMedia(dn.AUDIO)) || void 0 === t ? void 0 : t[0];
                            n && (this._transformMediaIdentifiers(n), this._injectSourceNames(n));
                            const s = i.selectMedia(dn.VIDEO);
                            hn.isMultiStreamSupportEnabled() || s.splice(1);
                            for (const e of s) this._transformMediaIdentifiers(e), this._injectSourceNames(e);
                            return hn.isSourceNameSignalingEnabled() && !this.tpc._usesUnifiedPlan && (this.audioSourcesToMsidMap.clear(), this.videoSourcesToMsidMap.clear()), new RTCSessionDescription({
                                type: e.type,
                                sdp: i.toRawSDP()
                            })
                        }
                        _injectSourceNames(e) {
                            var t, i, n;
                            if (!hn.isSourceNameSignalingEnabled()) return;
                            const s = [...new Set(null === (t = e.mLine) || void 0 === t || null === (i = t.ssrcs) || void 0 === i ? void 0 : i.map((e => e.id)))],
                                r = null === (n = e.mLine) || void 0 === n ? void 0 : n.type;
                            if (!r) throw new Error("_transformMediaIdentifiers - no media type in mediaSection");
                            for (const t of s) {
                                var o;
                                const i = e.ssrcs.find((e => e.id === t && "name" === e.attribute)),
                                    n = null === (o = e.ssrcs.find((e => e.id === t && "msid" === e.attribute))) || void 0 === o ? void 0 : o.value;
                                let s;
                                n && (s = n.split(" ")[0].split("-")[2]);
                                const c = nd(this.localEndpointId, r, s);
                                if (i || e.ssrcs.push({
                                        id: t,
                                        attribute: "name",
                                        value: c
                                    }), r === dn.VIDEO) {
                                    var a;
                                    const i = null === (a = this.tpc.getLocalVideoTracks().find((e => e.getSourceName() === c))) || void 0 === a ? void 0 : a.getVideoType();
                                    i && e.ssrcs.push({
                                        id: t,
                                        attribute: "videoType",
                                        value: i
                                    })
                                }
                            }
                        }
                    }
                    const pd = (0, v.getLogger)("modules/sdp/RtxModifier.js");

                    function md(e, t, i) {
                        const n = t.id,
                            s = t.msid,
                            r = t.cname,
                            o = e.getRtxSSRC(n);
                        o !== i && (o && (e.removeSSRC(o), e.removeGroupsWithSSRC(o)), e.addSSRCAttribute({
                            id: i,
                            attribute: "cname",
                            value: r
                        }), e.addSSRCAttribute({
                            id: i,
                            attribute: "msid",
                            value: s
                        }), e.addSSRCGroup({
                            semantics: "FID",
                            ssrcs: `${n} ${i}`
                        }))
                    }
                    class fd {
                        constructor() {
                            this.correspondingRtxSsrcs = new Map
                        }
                        clearSsrcCache() {
                            this.correspondingRtxSsrcs.clear()
                        }
                        setSsrcCache(e) {
                            pd.debug("Setting ssrc cache to ", e), this.correspondingRtxSsrcs = e
                        }
                        modifyRtxSsrcs(e) {
                            let t = !1;
                            const i = new ld(e),
                                n = i.selectMedia(dn.VIDEO);
                            if (null == n || !n.length) return pd.debug(`No 'video' media found in the sdp: ${e}`), e;
                            for (const e of n) this.modifyRtxSsrcs2(e) && (t = !0);
                            return t ? i.toRawSDP() : e
                        }
                        modifyRtxSsrcs2(e) {
                            if (e.direction === Ir.RECVONLY) return !1;
                            if (e.getSSRCCount() < 1) return !1;
                            const t = e.getPrimaryVideoSSRCs();
                            for (const i of t) {
                                const t = e.getSSRCAttrValue(i, "msid"),
                                    n = e.getSSRCAttrValue(i, "cname");
                                let s = this.correspondingRtxSsrcs.get(i);
                                if (!s) {
                                    s = e.getRtxSSRC(i) || Fr.generateSsrc(), this.correspondingRtxSsrcs.set(i, s)
                                }
                                md(e, {
                                    id: i,
                                    cname: n,
                                    msid: t
                                }, s)
                            }
                            return !0
                        }
                        stripRtx(e) {
                            const t = new ld(e),
                                i = t.selectMedia(dn.VIDEO);
                            if (null == i || !i.length) return pd.debug(`No 'video' media found in the sdp: ${e}`), e;
                            for (const e of i)
                                if (e.direction !== Ir.RECVONLY && e.getSSRCCount() && e.containsAnySSRCGroups()) {
                                    const t = e.findGroups("FID");
                                    e.removeGroupsBySemantics("FID");
                                    for (const i of t) {
                                        const t = ad(i);
                                        e.removeSSRC(t)
                                    }
                                } return t.toRawSDP()
                        }
                    }
                    const gd = (0, v.getLogger)("modules/sdp/SdpConsistency.js");
                    class _d {
                        constructor(e) {
                            this.clearVideoSsrcCache(), this.logPrefix = e
                        }
                        clearVideoSsrcCache() {
                            this.cachedPrimarySsrc = null, this.injectRecvOnly = !1
                        }
                        setPrimarySsrc(e) {
                            if ("number" != typeof e) throw new Error("Primary SSRC must be a number!");
                            this.cachedPrimarySsrc = e
                        }
                        hasPrimarySsrcCached() {
                            return Boolean(this.cachedPrimarySsrc)
                        }
                        makeVideoPrimarySsrcsConsistent(e) {
                            var t;
                            const i = new ld(e),
                                n = null === (t = i.selectMedia(dn.VIDEO)) || void 0 === t ? void 0 : t[0];
                            if (!n) return gd.debug(`${this.logPrefix} no 'video' media found in the sdp: ${e}`), e;
                            if ("recvonly" === n.direction) this.cachedPrimarySsrc && this.injectRecvOnly ? n.addSSRCAttribute({
                                id: this.cachedPrimarySsrc,
                                attribute: "cname",
                                value: `recvonly-${this.cachedPrimarySsrc}`
                            }) : gd.info(`${this.logPrefix} no SSRC found for the recvonly video stream!`);
                            else {
                                const t = n.getPrimaryVideoSsrc();
                                if (!t) return gd.info(`${this.logPrefix} sdp-consistency couldn't parse new primary ssrc`), e;
                                if (this.cachedPrimarySsrc) {
                                    n.replaceSSRC(t, this.cachedPrimarySsrc);
                                    for (const e of n.ssrcGroups)
                                        if ("FID" === e.semantics) {
                                            const i = od(e),
                                                n = ad(e);
                                            i === t && (e.ssrcs = `${this.cachedPrimarySsrc} ${n}`)
                                        }
                                } else this.cachedPrimarySsrc = t;
                                this.injectRecvOnly = !0
                            }
                            return i.toRawSDP()
                        }
                    }
                    class Sd {
                        constructor(e) {
                            this._options = e, this._ssrcCache = new Map, this._options.numOfLayers || (this._options.numOfLayers = 3)
                        }
                        _fillSsrcsFromCache(e) {
                            const t = e.mid,
                                i = this._ssrcCache.get(t),
                                n = this._parseSimLayers(e),
                                s = this._getSsrcAttribute(e, n[0], "msid"),
                                r = this._getSsrcAttribute(e, n[0], "cname");
                            e.ssrcs = [], e.ssrcGroups = [];
                            for (const t of i) e.ssrcs.push({
                                id: t,
                                attribute: "msid",
                                value: s
                            }), e.ssrcs.push({
                                id: t,
                                attribute: "cname",
                                value: r
                            });
                            return e.ssrcGroups.push({
                                semantics: "SIM",
                                ssrcs: i.join(" ")
                            }), e
                        }
                        _generateNewSsrcsForSimulcast(e, t) {
                            const i = this._getSsrcAttribute(e, t, "cname");
                            let n = this._getSsrcAttribute(e, t, "msid");
                            const s = (e, t) => {
                                e.ssrcs.push({
                                    id: t,
                                    attribute: "cname",
                                    value: i
                                }), e.ssrcs.push({
                                    id: t,
                                    attribute: "msid",
                                    value: n
                                })
                            };
                            n || (n = e.msid, e.ssrcs.forEach((t => {
                                e.ssrcs.push({
                                    id: t.id,
                                    attribute: "msid",
                                    value: n
                                })
                            })));
                            const r = [];
                            for (let t = 0; t < this._options.numOfLayers - 1; ++t) {
                                const t = this._generateSsrc();
                                s(e, t), r.push(t)
                            }
                            return e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
                                semantics: "SIM",
                                ssrcs: t + " " + r.join(" ")
                            }), e
                        }
                        _generateSsrc() {
                            return Math.floor(4294967295 * Math.random())
                        }
                        _getSsrcAttribute(e, t, i) {
                            var n, s;
                            return null === (n = e.ssrcs) || void 0 === n || null === (s = n.find((e => Number(e.id) === t && e.attribute === i))) || void 0 === s ? void 0 : s.value
                        }
                        _parseSimLayers(e) {
                            var t, i;
                            const n = null === (t = e.ssrcGroups) || void 0 === t ? void 0 : t.find((e => "SIM" === e.semantics));
                            return n ? n.ssrcs.split(" ").map((e => Number(e))) : null !== (i = e.ssrcs) && void 0 !== i && i.length ? [Number(e.ssrcs[0].id)] : null
                        }
                        mungeLocalDescription(e) {
                            if (!e || !e.sdp) return e;
                            const t = Lr.parse(e.sdp);
                            for (let e of t.media) {
                                var i, n, s;
                                if (e.direction === Ir.RECVONLY || e.direction === Ir.INACTIVE) continue;
                                if (e.type !== dn.VIDEO) continue;
                                const t = e.mid,
                                    o = new Set(null === (i = e.ssrcs) || void 0 === i ? void 0 : i.map((e => e.id))),
                                    a = null !== (n = null === (s = e.ssrcGroups) || void 0 === s ? void 0 : s.length) && void 0 !== n ? n : 0;
                                let c;
                                if (!(0 === o.size || o.size > 2 || 2 === o.size && 0 === a)) {
                                    if (1 === o.size) {
                                        var r;
                                        c = Number(null === (r = e.ssrcs[0]) || void 0 === r ? void 0 : r.id)
                                    } else {
                                        const t = e.ssrcGroups.find((e => "FID" === e.semantics));
                                        t && (c = Number(t.ssrcs.split(" ")[0]))
                                    }
                                    if (this._ssrcCache.has(t)) e = this._fillSsrcsFromCache(e);
                                    else {
                                        e = this._generateNewSsrcsForSimulcast(e, c);
                                        const i = this._parseSimLayers(e);
                                        this._ssrcCache.set(t, i)
                                    }
                                }
                            }
                            return new RTCSessionDescription({
                                type: e.type,
                                sdp: Lr.write(t)
                            })
                        }
                    }
                    let vd;
                    ! function(e) {
                        e.ACTIVE = "active", e.INACTIVE = "inactive", e.INTERRUPTED = "interrupted", e.RESTORING = "restoring"
                    }(vd || (vd = {}));
                    const Ed = (0, v.getLogger)("modules/connectivity/TrackStreamingStatus.ts");
                    class yd {
                        static _getNewStateForJvbMode(e, t, i, n) {
                            return i ? vd.ACTIVE : Ui.supportsVideoMuteOnConnInterrupted() ? n ? e ? t ? vd.INTERRUPTED : vd.RESTORING : vd.INACTIVE : vd.ACTIVE : e ? vd.ACTIVE : vd.INACTIVE
                        }
                        static _getNewStateForP2PMode(e, t) {
                            return Ui.supportsVideoMuteOnConnInterrupted() ? e || !t ? vd.ACTIVE : vd.INTERRUPTED : vd.ACTIVE
                        }
                        constructor(e, t, i, n) {
                            this.rtc = e, this.conference = t, this.track = i, this.restoringTimer = null, this.rtcMutedTimestamp = null, this.streamingStatusMap = {}, this.trackTimer = null, this.outOfForwardedSourcesTimeout = "number" == typeof n.outOfForwardedSourcesTimeout ? n.outOfForwardedSourcesTimeout : 500, this.p2pRtcMuteTimeout = "number" == typeof n.p2pRtcMuteTimeout ? n.p2pRtcMuteTimeout : 2500, this.rtcMuteTimeout = "number" == typeof n.rtcMuteTimeout ? n.rtcMuteTimeout : 1e4, Ed.info(`RtcMuteTimeout set to: ${this.rtcMuteTimeout}`)
                        }
                        _getVideoFrozenTimeout() {
                            const e = this.track.getSourceName();
                            return this.rtc.isInForwardedSources(e) ? this.rtcMuteTimeout : this.conference.isP2PActive() ? this.p2pRtcMuteTimeout : this.outOfForwardedSourcesTimeout
                        }
                        init() {
                            this._onP2PStatus = this.figureOutStreamingStatus.bind(this), this.conference.on(B.P2P_STATUS, this._onP2PStatus), this._onUserLeft = this.onUserLeft.bind(this), this.conference.on(B.USER_LEFT, this._onUserLeft), Ui.supportsVideoMuteOnConnInterrupted() && (this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this), this.rtc.addListener(Rn.default.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this), this.rtc.addListener(Rn.default.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this._onSignallingMuteChanged = this.onSignallingMuteChanged.bind(this), this.track.on(Lt, this._onSignallingMuteChanged), this._onTrackVideoTypeChanged = this.onTrackVideoTypeChanged.bind(this), this.track.on(kt, this._onTrackVideoTypeChanged)), this._onForwardedSourcesChanged = this.onForwardedSourcesChanged.bind(this), this.conference.on(B.FORWARDED_SOURCES_CHANGED, this._onForwardedSourcesChanged), this._onLastNValueChanged = this.figureOutStreamingStatus.bind(this), this.rtc.on(Rn.default.LASTN_VALUE_CHANGED, this._onLastNValueChanged)
                        }
                        dispose() {
                            Ui.supportsVideoMuteOnConnInterrupted() && (this.rtc.removeListener(Rn.default.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this.rtc.removeListener(Rn.default.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this.track.off(Lt, this._onSignallingMuteChanged)), this.conference.off(B.FORWARDED_SOURCES_CHANGED, this._onForwardedSourcesChanged), this.conference.off(B.P2P_STATUS, this._onP2PStatus), this.conference.off(B.USER_LEFT, this._onUserLeft), this.rtc.removeListener(Rn.default.LASTN_VALUE_CHANGED, this._onLastNValueChanged), this.clearTimeout(), this.clearRtcMutedTimestamp(), this.maybeSendTrackStreamingStatusEvent(Date.now()), this.figureOutStreamingStatus()
                        }
                        _changeStreamingStatus(e) {
                            if (this.track.getTrackStreamingStatus() !== e) {
                                const t = this.track.getSourceName();
                                this.track._setTrackStreamingStatus(e), Ed.debug(`Emit track streaming status(${Date.now()}) ${t}: ${e}`), Tn.sendLog(JSON.stringify({
                                    id: "track.streaming.status",
                                    track: t,
                                    status: e
                                })), this.track.emit(Vt, this.track, e)
                            }
                        }
                        clearTimeout() {
                            this.trackTimer && (window.clearTimeout(this.trackTimer), this.trackTimer = null)
                        }
                        clearRtcMutedTimestamp() {
                            this.rtcMutedTimestamp = null
                        }
                        isVideoTrackFrozen() {
                            if (!Ui.supportsVideoMuteOnConnInterrupted()) return !1;
                            const e = this.track.isWebRTCTrackMuted(),
                                t = this.rtcMutedTimestamp,
                                i = this._getVideoFrozenTimeout();
                            return e && "number" == typeof t && Date.now() - t >= i
                        }
                        figureOutStreamingStatus() {
                            const e = this.track.getSourceName(),
                                t = this.conference.isP2PActive(),
                                i = this._isRestoringTimedout(),
                                n = 0 === this.conference.getLastN(),
                                s = this.track.isMuted() || n,
                                r = this.isVideoTrackFrozen(),
                                o = this.rtc.isInForwardedSources(e),
                                a = t ? yd._getNewStateForP2PMode(s, r) : yd._getNewStateForJvbMode(o, i, s, r);
                            a !== vd.RESTORING && this._clearRestoringTimer(), Ed.debug(`Figure out conn status for ${e}, is video muted: ${s} video track frozen: ${r} p2p mode: ${t} is in forwarded sources: ${o} currentStatus => newStatus: ${this.track.getTrackStreamingStatus()} => ${a}`);
                            const c = this.streamingStatusMap || {};
                            if (!("p2p" in c) || !("streamingStatus" in c) || c.p2p !== t || c.streamingStatus !== a) {
                                const e = Date.now();
                                this.maybeSendTrackStreamingStatusEvent(e), this.streamingStatusMap = {
                                    ...c,
                                    streamingStatus: a,
                                    p2p: t,
                                    startedMs: e
                                }, "videoType" in this.streamingStatusMap || (this.streamingStatusMap.videoType = this.track.getVideoType())
                            }
                            this._changeStreamingStatus(a)
                        }
                        maybeSendTrackStreamingStatusEvent(e) {
                            const t = this.streamingStatusMap;
                            t && "startedMs" in t && "videoType" in t && "streamingStatus" in t && "p2p" in t && (t.value = e - t.startedMs, Tn.sendAnalytics(function() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                return {
                                    type: Ut.TYPE_OPERATIONAL,
                                    source: "track.streaming.status",
                                    action: "duration",
                                    attributes: e
                                }
                            }(t)))
                        }
                        onForwardedSourcesChanged() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                                i = arguments.length > 2 ? arguments[2] : void 0;
                            const n = this.track.getSourceName();
                            Ed.debug(`Fowarded sources changed leaving=${e}, entering=${t} at ${i}`), Ui.supportsVideoMuteOnConnInterrupted() || this.figureOutStreamingStatus(), e.includes(n) && (this.track._clearEnteredForwardedSourcesTimestamp(), this._clearRestoringTimer(), Ui.supportsVideoMuteOnConnInterrupted() && this.figureOutStreamingStatus()), t.includes(n) && (this.track._setEnteredForwardedSourcesTimestamp(i), Ui.supportsVideoMuteOnConnInterrupted() && this.figureOutStreamingStatus())
                        }
                        _clearRestoringTimer() {
                            const e = this.restoringTimer;
                            e && (clearTimeout(e), this.restoringTimer = null)
                        }
                        _isRestoringTimedout() {
                            const e = this.track._getEnteredForwardedSourcesTimestamp();
                            return !!(e && Date.now() - e >= 1e4) || (this.restoringTimer || (this.restoringTimer = setTimeout((() => this.figureOutStreamingStatus()), 1e4)), !1)
                        }
                        _isCurrentTrack(e) {
                            return e.getSourceName() === this.track.getSourceName()
                        }
                        onUserLeft(e) {
                            this.track.getParticipantId() === e && (this.maybeSendTrackStreamingStatusEvent(Date.now()), this.streamingStatusMap = {})
                        }
                        onTrackRtcMuted(e) {
                            if (!this._isCurrentTrack(e)) return;
                            const t = e.getSourceName();
                            if (Ed.debug(`Detector track RTC muted: ${t}`, Date.now()), this.rtcMutedTimestamp = Date.now(), !e.isMuted()) {
                                this.clearTimeout();
                                const e = this._getVideoFrozenTimeout();
                                this.trackTimer = window.setTimeout((() => {
                                    Ed.debug(`Set RTC mute timeout for: ${t} of ${e} ms`), this.clearTimeout(), this.figureOutStreamingStatus()
                                }), e)
                            }
                        }
                        onTrackRtcUnmuted(e) {
                            if (!this._isCurrentTrack(e)) return;
                            const t = this.track.getSourceName();
                            Ed.debug(`Detector track RTC unmuted: ${t}`, Date.now()), this.clearTimeout(), this.clearRtcMutedTimestamp(), this.figureOutStreamingStatus()
                        }
                        onSignallingMuteChanged(e) {
                            if (!this._isCurrentTrack(e)) return;
                            const t = this.track.getSourceName();
                            Ed.debug(`Detector on track signalling mute changed: ${t}`, e.isMuted()), this.figureOutStreamingStatus()
                        }
                        onTrackVideoTypeChanged(e) {
                            const t = Date.now();
                            this.maybeSendTrackStreamingStatusEvent(t), this.streamingStatusMap = {
                                ...this.streamingStatusMap || {},
                                videoType: e,
                                startedMs: t
                            }
                        }
                    }
                    const Td = yd,
                        Cd = i(5810).getLogger("modules/RTC/JitsiRemoteTrack.js"),
                        bd = i(9987);
                    let Rd = !1,
                        Ad = !1;
                    const Pd = ["abort", "canplaythrough", "ended", "error"];
                    class Id extends Uc {
                        constructor(e, t, i, n, s, r, o, a, c, d, l) {
                            if (super(t, n, s, (() => {}), r, o), this.rtc = e, "number" != typeof a) throw new TypeError(`SSRC ${a} is not a number`);
                            this.ssrc = a, this.ownerEndpointId = i, this.muted = c, this.isP2P = d, this._sourceName = l, this._trackStreamingStatus = null, this._trackStreamingStatusImpl = null, this._enteredForwardedSourcesTimestamp = null, this.addEventListener = this.on = this._addEventListener.bind(this), this.removeEventListener = this.off = this._removeEventListener.bind(this), Cd.debug(`New remote track added: ${this}`), this.hasBeenMuted = c, this.rtc && this.track && this._bindTrackHandlers(), this._containerHandlers = {}, Pd.forEach((e => {
                                this._containerHandlers[e] = this._containerEventHandler.bind(this, e)
                            }))
                        }
                        _bindTrackHandlers() {
                            this.track.addEventListener("mute", (() => this._onTrackMute())), this.track.addEventListener("unmute", (() => this._onTrackUnmute())), this.track.addEventListener("ended", (() => {
                                Cd.debug(`"onended" event(${Date.now()}): ${this}`)
                            }))
                        }
                        _addEventListener(e, t) {
                            super.addListener(e, t), hn.isSourceNameSignalingEnabled() && e === Vt && this.listenerCount(Vt) && !this._trackStreamingStatusImpl && (this._initTrackStreamingStatus(), Cd.debug(`Initializing track streaming status: ${this._sourceName}`))
                        }
                        _removeEventListener(e, t) {
                            super.removeListener(e, t), hn.isSourceNameSignalingEnabled() && e === Vt && !this.listenerCount(Vt) && (this._disposeTrackStreamingStatus(), Cd.debug(`Disposing track streaming status: ${this._sourceName}`))
                        }
                        _onTrackMute() {
                            Cd.debug(`"onmute" event(${Date.now()}): ${this}`), this.rtc.eventEmitter.emit(bd.REMOTE_TRACK_MUTE, this)
                        }
                        _onTrackUnmute() {
                            Cd.debug(`"onunmute" event(${Date.now()}): ${this}`), this.rtc.eventEmitter.emit(bd.REMOTE_TRACK_UNMUTE, this)
                        }
                        dispose() {
                            return hn.isSourceNameSignalingEnabled() && this._disposeTrackStreamingStatus(), super.dispose()
                        }
                        setMute(e) {
                            this.muted !== e && (e && (this.hasBeenMuted = !0), this.stream && (this.stream.muted = e), this.muted = e, this.emit(Lt, this))
                        }
                        isMuted() {
                            return this.muted
                        }
                        getParticipantId() {
                            return this.ownerEndpointId
                        }
                        isLocal() {
                            return !1
                        }
                        getSSRC() {
                            return this.ssrc
                        }
                        getSourceName() {
                            return this._sourceName
                        }
                        _setVideoType(e) {
                            this.videoType !== e && (this.videoType = e, this.emit(kt, e))
                        }
                        _playCallback() {
                            if (!this.conference.room) return;
                            const e = this.isVideoTrack() ? "video" : "audio",
                                t = window.performance.now();
                            console.log(`(TIME) Render ${e}:\t`, t), this.conference.getConnectionTimes()[`${e}.render`] = t;
                            const i = window.connectionTimes["obtainPermissions.start"],
                                n = window.connectionTimes["obtainPermissions.end"],
                                s = isNaN(n) || isNaN(i) ? 0 : n - i,
                                r = t - (this.conference.getConnectionTimes()["session.initiate"] - this.conference.getConnectionTimes()["muc.joined"]) - s;
                            var o;
                            this.conference.getConnectionTimes()[`${e}.ttfm`] = r, console.log(`(TIME) TTFM ${e}:\t`, r), Tn.sendAnalytics((o = {
                                media_type: e,
                                muted: this.hasBeenMuted,
                                value: r
                            }, li("ttfm", o)))
                        }
                        _attachTTFMTracker(e) {
                            Rd && this.isAudioTrack() || Ad && this.isVideoTrack() || (this.isAudioTrack() && (Rd = !0), this.isVideoTrack() && (Ad = !0), e.addEventListener("canplay", this._playCallback.bind(this)))
                        }
                        _onTrackAttach(e) {
                            Pd.forEach((t => {
                                e.addEventListener(t, this._containerHandlers[t])
                            }))
                        }
                        _onTrackDetach(e) {
                            Pd.forEach((t => {
                                e.removeEventListener(t, this._containerHandlers[t])
                            }))
                        }
                        _containerEventHandler(e) {
                            Cd.debug(`${e} handler was called for a container with attached ${this}`)
                        }
                        _getStatus() {
                            const {
                                enabled: e,
                                muted: t,
                                readyState: i
                            } = this.track;
                            return `readyState: ${i}, muted: ${t}, enabled: ${e}`
                        }
                        _initTrackStreamingStatus() {
                            const e = this.conference.options.config;
                            this._trackStreamingStatus = vd.ACTIVE, this._trackStreamingStatusImpl = new Td(this.rtc, this.conference, this, {
                                p2pRtcMuteTimeout: e._p2pConnStatusRtcMuteTimeout,
                                rtcMuteTimeout: e._peerConnStatusRtcMuteTimeout,
                                outOfForwardedSourcesTimeout: e._peerConnStatusOutOfLastNTimeout
                            }), this._trackStreamingStatusImpl.init()
                        }
                        _disposeTrackStreamingStatus() {
                            this._trackStreamingStatusImpl && (this._trackStreamingStatusImpl.dispose(), this._trackStreamingStatusImpl = null, this._trackStreamingStatus = null)
                        }
                        _setTrackStreamingStatus(e) {
                            this._trackStreamingStatus = e
                        }
                        getTrackStreamingStatus() {
                            return this._trackStreamingStatus
                        }
                        _clearEnteredForwardedSourcesTimestamp() {
                            this._enteredForwardedSourcesTimestamp = null
                        }
                        _setEnteredForwardedSourcesTimestamp(e) {
                            this._enteredForwardedSourcesTimestamp = e
                        }
                        _getEnteredForwardedSourcesTimestamp() {
                            return this._enteredForwardedSourcesTimestamp
                        }
                        toString() {
                            return `RemoteTrack[userID: ${this.getParticipantId()}, type: ${this.getType()}, ssrc: ${this.getSSRC()}, p2p: ${this.isP2P}, sourceName: ${this._sourceName}, status: ${this._getStatus()}]`
                        }
                    }
                    const Nd = (0, v.getLogger)("modules/RTC/TPCUtils.js"),
                        Dd = 25e5,
                        Md = ["1", "2", "3"];
                    class Od {
                        constructor(e) {
                            var t, i, n;
                            this.pc = e;
                            const s = null === (t = this.pc.options) || void 0 === t || null === (i = t.videoQuality) || void 0 === i ? void 0 : i.maxBitratesVideo,
                                r = {
                                    low: 2e5,
                                    standard: 7e5,
                                    high: Dd
                                };
                            this.videoBitrates = null != s ? s : r;
                            const o = null !== (n = this.videoBitrates.VP8) && void 0 !== n ? n : this.videoBitrates;
                            this.localStreamEncodingsConfig = [{
                                active: !0,
                                maxBitrate: Ui.isFirefox() ? o.high : o.low,
                                rid: "1",
                                scaleResolutionDownBy: Ui.isFirefox() ? 1 : 4
                            }, {
                                active: !0,
                                maxBitrate: o.standard,
                                rid: "2",
                                scaleResolutionDownBy: 2
                            }, {
                                active: !0,
                                maxBitrate: Ui.isFirefox() ? o.low : o.high,
                                rid: "3",
                                scaleResolutionDownBy: Ui.isFirefox() ? 4 : 1
                            }]
                        }
                        _getStreamEncodings(e) {
                            return this.pc.isSimulcastOn() && e.isVideoTrack() ? this.localStreamEncodingsConfig : e.isVideoTrack() ? [{
                                active: !0,
                                maxBitrate: this.videoBitrates.high
                            }] : [{
                                active: !0
                            }]
                        }
                        ensureCorrectOrderOfSsrcs(e) {
                            const t = Lr.parse(e.sdp);
                            return t.media.forEach((e => {
                                if (e.type === dn.AUDIO) return;
                                if (!e.ssrcGroups || !e.ssrcGroups.length) return;
                                let t = [];
                                const i = new Set;
                                e.ssrcGroups.map((e => e.ssrcs.split(" ").filter(Boolean).forEach((e => i.add(e))))), i.forEach((i => {
                                    const n = e.ssrcs.filter((e => e.id.toString() === i));
                                    t = t.concat(n)
                                })), e.ssrcs = t
                            })), new RTCSessionDescription({
                                type: e.type,
                                sdp: Lr.write(t)
                            })
                        }
                        findTransceiver(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                            return null != t && t.track && t.getOriginalStream() ? this.pc.peerconnection.getTransceivers().find((e => {
                                var i, n;
                                return (null === (i = e.sender) || void 0 === i || null === (n = i.track) || void 0 === n ? void 0 : n.id) === t.getTrackId()
                            })) : this.pc.peerconnection.getTransceivers().find((t => {
                                var i, n;
                                return (null === (i = t.receiver) || void 0 === i || null === (n = i.track) || void 0 === n ? void 0 : n.kind) === e
                            }))
                        }
                        insertUnifiedPlanSimulcastReceive(e) {
                            if (Ui.usesSdpMungingForSimulcast()) return e;
                            const t = Lr.parse(e.sdp),
                                i = t.media.findIndex((e => e.type === dn.VIDEO));
                            if (t.media[i].rids && (t.media[i].simulcast_03 || t.media[i].simulcast)) return t.media.forEach(((e, n) => {
                                e.type === dn.VIDEO && n !== i && (t.media[n].rids = void 0, t.media[n].simulcast = void 0, t.media[n].simulcast_03 = void 0)
                            })), new RTCSessionDescription({
                                type: e.type,
                                sdp: Lr.write(t)
                            });
                            t.media[i].rids = [{
                                id: "1",
                                direction: "recv"
                            }, {
                                id: "2",
                                direction: "recv"
                            }, {
                                id: "3",
                                direction: "recv"
                            }];
                            const n = Ui.isFirefox() && Ui.isVersionGreaterThan(71) ? `recv ${Md.join(";")}` : `recv rid=${Md.join(";")}`;
                            return t.media[i].simulcast_03 = {
                                value: n
                            }, new RTCSessionDescription({
                                type: e.type,
                                sdp: Lr.write(t)
                            })
                        }
                        addTrack(e, t) {
                            const i = e.getTrack();
                            if (t) {
                                const t = [];
                                e.getOriginalStream() && t.push(e.getOriginalStream());
                                const n = {
                                    direction: Ir.SENDRECV,
                                    streams: t,
                                    sendEncodings: []
                                };
                                Ui.isFirefox() || (n.sendEncodings = this._getStreamEncodings(e)), this.pc.peerconnection.addTransceiver(i, n)
                            } else this.pc.peerconnection.addTrack(i)
                        }
                        calculateEncodingsActiveState(e, t) {
                            const i = e.getTrack(),
                                {
                                    height: n
                                } = i.getSettings();
                            return this.localStreamEncodingsConfig.map((e => n / e.scaleResolutionDownBy)).map(((i, n) => {
                                var s;
                                let r = e.getVideoType() !== An.VideoType.CAMERA || t > 0 && 4 === (null === (s = this.localStreamEncodingsConfig[n]) || void 0 === s ? void 0 : s.scaleResolutionDownBy) || i <= t;
                                return e.getVideoType() === An.VideoType.DESKTOP && this.pc._capScreenshareBitrate && this.pc.usesUnifiedPlan() && !Ui.isWebKitBased() && 1 !== this.localStreamEncodingsConfig[n].scaleResolutionDownBy && (r = !1), r
                            }))
                        }
                        calculateEncodingsBitrates(e) {
                            var t, i;
                            const n = e.getVideoType(),
                                s = (null === (t = this.pc.options) || void 0 === t || null === (i = t.videoQuality) || void 0 === i ? void 0 : i.desktopBitrate) || 5e5,
                                r = e._originalStream && e._originalStream.id !== e.getStreamId(),
                                o = e.getVideoType() === An.VideoType.DESKTOP && this.pc._capScreenshareBitrate && !Ui.isWebKitBased();
                            return this.localStreamEncodingsConfig.map((e => o ? r ? Dd : s : n === An.VideoType.DESKTOP && Ui.isChromiumBased() && !this.pc.usesUnifiedPlan() ? void 0 : e.maxBitrate))
                        }
                        replaceTrack(e, t) {
                            var i, n;
                            const s = null !== (i = null == t ? void 0 : t.getType()) && void 0 !== i ? i : null == e ? void 0 : e.getType(),
                                r = this.pc.getLocalTracks(s),
                                o = null !== (n = null == t ? void 0 : t.getTrack()) && void 0 !== n ? n : null,
                                a = hn.isMultiStreamSupportEnabled() && (null == r ? void 0 : r.length) && !e && t && !r.find((e => e === t));
                            let c;
                            if (e && !e.isMuted()) c = this.pc.peerconnection.getTransceivers().find((t => t.sender.track === e.getTrack()));
                            else if (a) c = this.pc.peerconnection.getTransceivers().find((e => e.receiver.track.kind === s && e.direction === Ir.RECVONLY && e.currentDirection === Ir.INACTIVE));
                            else {
                                var d;
                                c = this.pc.peerconnection.getTransceivers().find((e => e.receiver.track.kind === s));
                                const i = null !== (d = null == t ? void 0 : t.getSourceName()) && void 0 !== d ? d : null == e ? void 0 : e.getSourceName();
                                if (i) {
                                    const e = Number(i.split("-")[1].substring(1));
                                    e && (c = this.pc.peerconnection.getTransceivers().filter((e => e.receiver.track.kind === s && e.direction !== Ir.RECVONLY))[e])
                                }
                            }
                            return c ? (Nd.debug(`${this.pc} Replacing ${e} with ${t}`), c.sender.replaceTrack(o).then((() => Promise.resolve(c)))) : Promise.reject(new Error("replace track failed"))
                        }
                        setAudioTransferActive(e) {
                            this.setMediaTransferActive(dn.AUDIO, e)
                        }
                        setEncodings(e) {
                            var t, i;
                            const n = e.getType(),
                                s = this.findTransceiver(n, e),
                                r = null == s || null === (t = s.sender) || void 0 === t ? void 0 : t.getParameters();
                            return null != r && null !== (i = r.encodings) && void 0 !== i && i.length ? (r.encodings = this._getStreamEncodings(e), s.sender.setParameters(r)) : Promise.resolve()
                        }
                        setMediaTransferActive(e, t) {
                            const i = this.pc.peerconnection.getTransceivers().filter((t => t.receiver && t.receiver.track && t.receiver.track.kind === e)),
                                n = this.pc.getLocalTracks(e);
                            Nd.info(`${this.pc} ${t?"Enabling":"Suspending"} ${e} media transfer.`), i.forEach(((e, i) => {
                                t ? i < n.length ? e.direction = Ir.SENDRECV : e.direction = Ir.RECVONLY : e.direction = Ir.INACTIVE
                            }))
                        }
                        setVideoTransferActive(e) {
                            this.setMediaTransferActive(dn.VIDEO, e)
                        }
                        updateEncodingsResolution(e) {
                            var t;
                            Ui.isWebKitBased() && e.encodings && Array.isArray(e.encodings) && ((t = e.encodings).every((e => void 0 !== e.scaleResolutionDownBy && e.scaleResolutionDownBy === t[0].scaleResolutionDownBy)) && e.encodings.forEach(((e, t) => {
                                e.scaleResolutionDownBy = this.localStreamEncodingsConfig[t].scaleResolutionDownBy
                            })))
                        }
                    }
                    const wd = (0, v.getLogger)("modules/RTC/TraceablePeerConnection.js");

                    function Ld(e, t, n, s, r, o, a) {
                        this.audioTransferActive = !(!0 === a.startSilent), this._dtmfSender = void 0, this._dtmfTonesQueue = [], this.videoTransferActive = !0, this.rtc = e, this.id = t, this.isP2P = o, this.remoteTracks = new Map, this.localTracks = new Map, this._addedStreams = [], this.localSSRCs = new Map, this.localUfrag = null, this.remoteUfrag = null, this._dtlsTransport = null, this.signalingLayer = n, this._peerVideoTypeChanged = this._peerVideoTypeChanged.bind(this), this.signalingLayer.on(ed, this._peerVideoTypeChanged), this._peerMutedChanged = this._peerMutedChanged.bind(this), this.signalingLayer.on(Zc, this._peerMutedChanged), this.options = a, this.signalingLayer.on(td, ((e, t) => this._sourceMutedChanged(e, t))), this.signalingLayer.on(id, ((e, t) => this._sourceVideoTypeChanged(e, t)));
                        const c = r || {};
                        if (c.optional = c.optional || [], Array.isArray(c.optional) ? c.optional.push({
                                rtcStatsSFUP2P: this.isP2P
                            }) : wd.warn("Optional param is not an array, rtcstats p2p data is omitted."), this.peerconnection = new RTCPeerConnection(s, c), this.tpcUtils = new Od(this), this.updateLog = [], this.stats = {}, this.statsinterval = null, this._capScreenshareBitrate = this.options.capScreenshareBitrate, this._usesUnifiedPlan = a.usesUnifiedPlan, this._usesTransceiverCodecPreferences = Ui.supportsCodecPreferences() && this._usesUnifiedPlan, this._usesTransceiverCodecPreferences && wd.info("Using RTCRtpTransceiver#setCodecPreferences for codec selection"), this._usesUnifiedPlan && (this._hasHadAudioTrack = !1, this._hasHadVideoTrack = !1), this.maxstats = a.maxstats, this.interop = new Qc, this._usesUnifiedPlan) this.simulcast = new Sd({
                            numOfLayers: Md.length
                        });
                        else {
                            const e = i(6234);
                            this.simulcast = new e({
                                numOfLayers: Md.length,
                                explodeRemoteSimulcast: !1,
                                usesUnifiedPlan: !1
                            })
                        }
                        this.sdpConsistency = new _d(this.toString()), this.localSdpMunger = new ud(this, this.rtc.getLocalEndpointId()), this.eventEmitter = e.eventEmitter, this.rtxModifier = new fd, this._senderVideoMaxHeight = 2160, this._senderMaxHeights = new Map, this.trace = (e, t) => {
                            wd.debug(e, t), this.updateLog.push({
                                time: new Date,
                                type: e,
                                value: t || ""
                            })
                        }, this.onicecandidate = null, this.peerconnection.onicecandidate = e => {
                            this.trace("onicecandidate", JSON.stringify(e.candidate, null, " ")), null !== this.onicecandidate && this.onicecandidate(e)
                        }, this._usesUnifiedPlan ? (this.onTrack = e => {
                            const t = e.streams[0];
                            this._remoteTrackAdded(t, e.track, e.transceiver), t.addEventListener("removetrack", (e => {
                                this._remoteTrackRemoved(t, e.track)
                            }))
                        }, this.peerconnection.addEventListener("track", this.onTrack)) : (this.peerconnection.onaddstream = e => this._remoteStreamAdded(e.stream), this.peerconnection.onremovestream = e => this._remoteStreamRemoved(e.stream)), this.onsignalingstatechange = null, this.peerconnection.onsignalingstatechange = e => {
                            this.trace("onsignalingstatechange", this.signalingState), null !== this.onsignalingstatechange && this.onsignalingstatechange(e)
                        }, this.oniceconnectionstatechange = null, this.peerconnection.oniceconnectionstatechange = e => {
                            this.trace("oniceconnectionstatechange", this.iceConnectionState), null !== this.oniceconnectionstatechange && this.oniceconnectionstatechange(e)
                        }, this.onnegotiationneeded = null, this.peerconnection.onnegotiationneeded = e => {
                            this.trace("onnegotiationneeded"), null !== this.onnegotiationneeded && this.onnegotiationneeded(e)
                        }, this.onconnectionstatechange = null, this.peerconnection.onconnectionstatechange = e => {
                            this.trace("onconnectionstatechange", this.connectionState), null !== this.onconnectionstatechange && this.onconnectionstatechange(e)
                        }, this.ondatachannel = null, this.peerconnection.ondatachannel = e => {
                            this.trace("ondatachannel"), null !== this.ondatachannel && this.ondatachannel(e)
                        }, this.maxstats && (this.statsinterval = window.setInterval((() => {
                            this.getStats().then((e => {
                                if ("function" == typeof(null == e ? void 0 : e.result)) {
                                    const t = e.result();
                                    for (let e = 0; e < t.length; ++e) {
                                        const i = t[e];
                                        i.names().forEach((e => {
                                            this._processStat(i, e, i.stat(e))
                                        }))
                                    }
                                } else e.forEach((e => this._processStat(e, "", e)))
                            }))
                        }), 1e3)), wd.info(`Create new ${this}`)
                    }
                    Ld.prototype._processStat = function(e, t, i) {
                        const n = `${e.id}-${t}`;
                        let s = this.stats[n];
                        const r = new Date;
                        s || (this.stats[n] = s = {
                            startTime: r,
                            endTime: r,
                            values: [],
                            times: []
                        }), s.values.push(i), s.times.push(r.getTime()), s.values.length > this.maxstats && (s.values.shift(), s.times.shift()), s.endTime = r
                    };
                    const kd = function(e) {
                        return null == e ? "" : `type: ${e.type}\r\n${e.sdp}`
                    };
                    Ld.prototype.getConnectionState = function() {
                        const e = this.peerconnection.iceConnectionState;
                        return "completed" === e ? "connected" : e
                    }, Ld.prototype.getDesiredMediaDirection = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        const i = this.hasAnyTracksOfType(e);
                        if (this._usesUnifiedPlan) return t ? i ? Ir.SENDRECV : Ir.SENDONLY : i ? Ir.RECVONLY : Ir.INACTIVE;
                        const n = e === dn.AUDIO ? this.audioTransferActive : this.videoTransferActive;
                        return n ? i ? Ir.SENDRECV : Ir.RECVONLY : Ir.INACTIVE
                    }, Ld.prototype._getReceiversByEndpointIds = function(e, t) {
                        let i = [],
                            n = [];
                        for (const n of e) i = i.concat(this.getRemoteTracks(n, t));
                        const s = i.map((e => {
                            var t;
                            return null === (t = e.track) || void 0 === t ? void 0 : t.id
                        }));
                        return n = this.peerconnection.getReceivers().filter((e => e.track && e.track.kind === t && s.find((t => t === e.track.id)))), n
                    }, Ld.prototype.isSimulcastOn = function() {
                        return !this.options.disableSimulcast
                    }, Ld.prototype._peerVideoTypeChanged = function(e, t) {
                        if (!e) return void wd.error(`${this} No endpointID on peerVideoTypeChanged`);
                        const i = this.getRemoteTracks(e, dn.VIDEO);
                        i.length && i[0]._setVideoType(t)
                    }, Ld.prototype._peerMutedChanged = function(e, t, i) {
                        if (!e) return void wd.error(`${this} On peerMuteChanged - no endpoint ID`);
                        const n = this.getRemoteTracks(e, t);
                        n.length && n[0].setMute(i)
                    }, Ld.prototype._sourceMutedChanged = function(e, t) {
                        const i = this.getRemoteTracks().find((t => t.getSourceName() === e));
                        i && i.setMute(t)
                    }, Ld.prototype._sourceVideoTypeChanged = function(e, t) {
                        const i = this.getRemoteTracks().find((t => t.getSourceName() === e));
                        i && i._setVideoType(t)
                    }, Ld.prototype.getAudioLevels = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        const t = {},
                            i = e.length ? this._getReceiversByEndpointIds(e, dn.AUDIO) : this.peerconnection.getReceivers().filter((e => e.track && e.track.kind === dn.AUDIO && e.track.enabled));
                        return i.forEach((e => {
                            const i = e.getSynchronizationSources();
                            i && i.length && (t[i[0].source] = i[0].audioLevel)
                        })), t
                    }, Ld.prototype.getLocalTracks = function(e) {
                        let t = Array.from(this.localTracks.values());
                        return void 0 !== e && (t = t.filter((t => t.getType() === e))), t
                    }, Ld.prototype.getLocalVideoTracks = function() {
                        return this.getLocalTracks(dn.VIDEO)
                    }, Ld.prototype.hasAnyTracksOfType = function(e) {
                        if (!e) throw new Error('"mediaType" is required');
                        return this.getLocalTracks(e).length > 0
                    }, Ld.prototype.getRemoteTracks = function(e, t) {
                        let i = [];
                        const n = e ? [e] : this.remoteTracks.keys();
                        for (const e of n) {
                            const n = this.remoteTracks.get(e);
                            if (n)
                                for (const e of n.keys()) t && t !== e || (i = i.concat(Array.from(n.get(e))))
                        }
                        return i
                    }, Ld.prototype.getRemoteSourceInfoByParticipant = function(e) {
                        const t = [],
                            i = this.getRemoteTracks(e);
                        if (null == i || !i.length) return t;
                        const n = i.map((e => e.getSSRC())),
                            s = new Vr(this.remoteDescription.sdp);
                        return n.forEach(((e, i) => {
                            for (const n of s.media) {
                                let s = "",
                                    r = Fr.findLines(n, `a=ssrc:${e}`);
                                if (r.length) {
                                    t[i] || (t[i] = "");
                                    const o = Fr.findLines(n, `a=ssrc-group:FID ${e}`);
                                    if (o.length) {
                                        const e = o[0].split(" ")[2];
                                        s += `${o[0]}\r\n`, r = r.concat(Fr.findLines(n, `a=ssrc:${e}`))
                                    }
                                    t[i] += `${r.join("\r\n")}\r\n`, t[i] += s
                                }
                            }
                        })), t
                    }, Ld.prototype.getTargetVideoBitrates = function() {
                        const e = this.getConfiguredVideoCodec();
                        return this.tpcUtils.videoBitrates[e.toUpperCase()] || this.tpcUtils.videoBitrates
                    }, Ld.prototype.getTrackBySSRC = function(e) {
                        if ("number" != typeof e) throw new Error(`SSRC ${e} is not a number`);
                        for (const t of this.localTracks.values())
                            if (this.getLocalSSRC(t) === e) return t;
                        for (const t of this.getRemoteTracks())
                            if (t.getSSRC() === e) return t;
                        return null
                    }, Ld.prototype.getSsrcByTrackId = function(e) {
                        const t = t => t.getTrack().id === e,
                            i = this.getLocalTracks().find(t);
                        if (i) return this.getLocalSSRC(i);
                        const n = this.getRemoteTracks().find(t);
                        return n ? n.getSSRC() : null
                    }, Ld.prototype._remoteStreamAdded = function(e) {
                        const t = e.id;
                        if (!Hd.isUserStreamById(t)) return void wd.info(`${this} ignored remote 'stream added' event for non-user stream[id=${t}]`);
                        Ui.isChromiumBased() && (e.onaddtrack = t => {
                            this._remoteTrackAdded(e, t.track)
                        }, e.onremovetrack = t => {
                            this._remoteTrackRemoved(e, t.track)
                        });
                        const i = e.getAudioTracks();
                        for (const t of i) this._remoteTrackAdded(e, t);
                        const n = e.getVideoTracks();
                        for (const t of n) this._remoteTrackAdded(e, t)
                    }, Ld.prototype._remoteTrackAdded = function(e, t) {
                        let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                        const n = e.id,
                            s = t.kind;
                        if (!this.isP2P && !Hd.isUserStreamById(n)) return void wd.info(`${this} ignored remote 'stream added' event for non-user stream[id=${n}]`);
                        if (wd.info(`${this} adding remote track for stream[id=${n},type=${s}]`), !s) return void Ji.callErrorHandler(new Error(`MediaType undefined for remote track, stream id: ${n}`));
                        const r = this._usesUnifiedPlan ? new Vr(this.peerconnection.remoteDescription.sdp) : new Vr(this.remoteDescription.sdp);
                        let o;
                        if (this._usesUnifiedPlan)
                            if (i && i.mid) {
                                const e = i.mid;
                                o = r.media.filter((t => Fr.findLine(t, `a=mid:${e}`)))
                            } else o = r.media.filter((e => {
                                const t = Fr.findLine(e, "a=msid:");
                                return void 0 !== t && n === t.substring(7).split(" ")[0]
                            }));
                        else o = r.media.filter((e => e.startsWith(`m=${s}`)));
                        if (!o.length) return void Ji.callErrorHandler(new Error(`No media lines found in remote SDP for remote stream[id=${n},type=${s}]`));
                        let a = Fr.findLines(o[0], "a=ssrc:");
                        if (a = a.filter((e => -1 !== e.indexOf(`msid:${n}`))), !a.length) return void Ji.callErrorHandler(new Error(`No SSRC lines found in remote SDP for remote stream[msid=${n},type=${s}]`));
                        const c = a[0].substring(7).split(" ")[0],
                            d = Number(c),
                            l = this.signalingLayer.getSSRCOwner(d);
                        if (isNaN(d) || d < 0) return void Ji.callErrorHandler(new Error(`Invalid SSRC for remote stream[ssrc=${d},id=${n},type=${s}]`));
                        if (!l) return void Ji.callErrorHandler(new Error(`No SSRC owner known for remote stream[ssrc=${d},id=${n},type=${s}]`));
                        let h;
                        hn.isSourceNameSignalingEnabled() && (h = this.signalingLayer.getTrackSourceName(d), h || (h = nd(l, s, 0))), wd.info(`${this} creating remote track[endpoint=${l},ssrc=${d},type=${s},sourceName=${h}]`);
                        const u = this.signalingLayer.getPeerMediaInfo(l, s, h);
                        if (!u) return void Ji.callErrorHandler(new Error(`${this}: no peer media info available for ${l}`));
                        const p = u.muted,
                            m = u.videoType;
                        this._createRemoteTrack(l, e, t, s, m, d, p, h)
                    }, Ld.prototype._createRemoteTrack = function(e, t, i, n, s, r, o, a) {
                        let c = this.remoteTracks.get(e);
                        c || (c = new Map, c.set(dn.AUDIO, new Set), c.set(dn.VIDEO, new Set), this.remoteTracks.set(e, c));
                        const d = c.get(n);
                        if (null != d && d.size && Array.from(d).find((e => e.getTrack() === i))) return void wd.info(`${this} ignored duplicated track event for track[endpoint=${e},type=${n}]`);
                        if (null != d && d.size && !hn.isSourceNameSignalingEnabled()) {
                            wd.error(`${this} received a second remote track for track[endpoint=${e},type=${n}]deleting the existing track`);
                            const t = Array.from(d)[0];
                            this._remoteTrackRemoved(t.getOriginalStream(), t.getTrack())
                        }
                        const l = new Id(this.rtc, this.rtc.conference, e, t, i, n, s, r, o, this.isP2P, a);
                        d.add(l), this.eventEmitter.emit(Rn.default.REMOTE_TRACK_ADDED, l, this)
                    }, Ld.prototype._remoteStreamRemoved = function(e) {
                        if (!Hd.isUserStream(e)) return void wd.info(`Ignored remote 'stream removed' event for stream[id=${e.id}]`);
                        const t = e.getVideoTracks();
                        for (const i of t) this._remoteTrackRemoved(e, i);
                        const i = e.getAudioTracks();
                        for (const t of i) this._remoteTrackRemoved(e, t)
                    }, Ld.prototype._remoteTrackRemoved = function(e, t) {
                        const i = e.id,
                            n = null == t ? void 0 : t.id;
                        if (!Hd.isUserStreamById(i)) return void wd.info(`${this} ignored remote 'stream removed' event for non-user stream[id=${i}]`);
                        if (!i) return void Ji.callErrorHandler(new Error(`${this} remote track removal failed - no stream ID`));
                        if (!n) return void Ji.callErrorHandler(new Error(`${this} remote track removal failed - no track ID`));
                        const s = this.getRemoteTracks().find((e => e.getStreamId() === i && e.getTrackId() === n));
                        s ? (wd.info(`${this} remote track removed stream[id=${i},trackId=${n}]`), this._removeRemoteTrack(s)) : Ji.callErrorHandler(new Error(`${this} remote track removal failed - track not found`))
                    }, Ld.prototype.removeRemoteTracks = function(e) {
                        let t = [];
                        const i = this.remoteTracks.get(e);
                        return i && (t = t.concat(Array.from(i.get(dn.AUDIO))), t = t.concat(Array.from(i.get(dn.VIDEO))), this.remoteTracks.delete(e)), wd.debug(`${this} removed remote tracks[endpoint=${e},count=${t.length}`), t
                    }, Ld.prototype._removeRemoteTrack = function(e) {
                        var t;
                        e.dispose();
                        const i = e.getParticipantId(),
                            n = this.remoteTracks.get(i);
                        n ? null !== (t = n.get(e.getType())) && void 0 !== t && t.delete(e) || wd.error(`${this} Failed to remove ${e} - type mapping messed up ?`) : wd.error(`${this} removeRemoteTrack: no remote tracks map for endpoint=${i}`), this.eventEmitter.emit(Rn.default.REMOTE_TRACK_REMOVED, e)
                    }, Ld.prototype._extractSSRCMap = function(e) {
                        const t = new Map,
                            i = new Map;
                        if ("object" != typeof e || null === e || "string" != typeof e.sdp) return wd.warn("An empty description was passed as an argument"), t;
                        const n = Lr.parse(e.sdp);
                        if (!Array.isArray(n.media)) return t;
                        let s = n.media;
                        this._usesUnifiedPlan && (hn.isMultiStreamSupportEnabled() ? s = s.filter((e => e.direction === Ir.SENDONLY || e.direction === Ir.SENDRECV)) : (s = [], [dn.AUDIO, dn.VIDEO].forEach((e => {
                            const t = n.media.find((t => t.type === e));
                            t && s.push(t)
                        }))));
                        let r = 0;
                        for (const e of s) {
                            if (!Array.isArray(e.ssrcs)) continue;
                            if (Array.isArray(e.ssrcGroups))
                                for (const t of e.ssrcGroups)
                                    if (void 0 !== t.semantics && void 0 !== t.ssrcs) {
                                        const e = t.ssrcs.split(" ").map((e => parseInt(e, 10))),
                                            n = e[0];
                                        t.ssrcs = e, i.has(n) || i.set(n, []), i.get(n).push(t)
                                    } let n = e.ssrcs;
                            n = this._usesUnifiedPlan ? n.filter((e => "cname" === e.attribute)) : n.filter((e => "msid" === e.attribute));
                            for (const s of n) {
                                const n = this._usesUnifiedPlan ? hn.isMultiStreamSupportEnabled() ? `${e.type}-${r}` : e.type : s.value,
                                    o = s.id;
                                let a = t.get(n);
                                if (a || (a = {
                                        ssrcs: [],
                                        groups: [],
                                        msid: n
                                    }, t.set(n, a)), a.ssrcs.push(o), i.has(o)) {
                                    const e = i.get(o);
                                    for (const t of e) a.groups.push(t)
                                }
                            }
                            e.type === dn.VIDEO && r++
                        }
                        return t
                    };
                    Ld.prototype.getLocalSSRC = function(e) {
                        const t = this._getSSRC(e.rtcId);
                        return t && t.ssrcs[0]
                    }, Ld.prototype._injectSsrcGroupForUnifiedSimulcast = function(e) {
                        const t = Lr.parse(e.sdp),
                            i = t.media.find((e => "video" === e.type));
                        i.ssrcGroups = i.ssrcGroups || [];
                        const n = i.ssrcGroups.filter((e => "FID" === e.semantics));
                        if (i.simulcast || i.simulcast_03) {
                            const t = [];
                            if (n && n.length ? n.forEach((e => {
                                    t.push(e.ssrcs.split(" ")[0])
                                })) : i.ssrcs.forEach((e => {
                                    "msid" === e.attribute && t.push(e.id)
                                })), i.ssrcGroups.find((e => "SIM" === e.semantics))) return e;
                            for (let e = 0; e < t.length; e += 3) {
                                const n = t.slice(e, e + 3);
                                i.ssrcGroups.push({
                                    semantics: "SIM",
                                    ssrcs: n.join(" ")
                                })
                            }
                        }
                        return new RTCSessionDescription({
                            type: e.type,
                            sdp: Lr.write(t)
                        })
                    };
                    const xd = {
                        signalingState() {
                            return this.peerconnection.signalingState
                        },
                        iceConnectionState() {
                            return this.peerconnection.iceConnectionState
                        },
                        connectionState() {
                            return this.peerconnection.connectionState
                        },
                        localDescription() {
                            let e = this.peerconnection.localDescription;
                            return e ? (this.trace("getLocalDescription::preTransform", kd(e)), this._usesUnifiedPlan && !this.isP2P ? (e = this.interop.toPlanB(e), this.trace("getLocalDescription::postTransform (Plan B)", kd(e)), e = this._injectSsrcGroupForUnifiedSimulcast(e), this.trace("getLocalDescription::postTransform (inject ssrc group)", kd(e))) : this._usesUnifiedPlan || (Ui.doesVideoMuteByStreamRemove() && (e = this.localSdpMunger.maybeAddMutedLocalVideoTracksToSDP(e), wd.debug("getLocalDescription::postTransform (munge local SDP)", e)), e = function(e, t) {
                                var i, n;
                                if (!e) throw new Error("No local description passed in.");
                                const s = new ld(e.sdp),
                                    r = null === (i = s.selectMedia(dn.AUDIO)) || void 0 === i ? void 0 : i[0];
                                let o = !1;
                                r && r.direction !== Ir.SENDRECV && (t.startSilent ? r.direction = Ir.INACTIVE : r.direction = Ir.SENDRECV, o = !0);
                                const a = null === (n = s.selectMedia(dn.VIDEO)) || void 0 === n ? void 0 : n[0];
                                return a && a.direction !== Ir.SENDRECV && (a.direction = Ir.SENDRECV, o = !0), o ? new RTCSessionDescription({
                                    type: e.type,
                                    sdp: s.toRawSDP()
                                }) : e
                            }(e, this.options)), e = this.localSdpMunger.transformStreamIdentifiers(e), e) : (wd.debug(`${this} getLocalDescription no localDescription found`), {})
                        },
                        remoteDescription() {
                            let e = this.peerconnection.remoteDescription;
                            return e ? (this.trace("getRemoteDescription::preTransform", kd(e)), this._usesUnifiedPlan && (this.isP2P ? e = this._adjustRemoteMediaDirection(e) : (e = this.interop.toPlanB(e), this.trace("getRemoteDescription::postTransform (Plan B)", kd(e)))), e) : (wd.debug(`${this} getRemoteDescription no remoteDescription found`), {})
                        }
                    };
                    Object.keys(xd).forEach((e => {
                        Object.defineProperty(Ld.prototype, e, {
                            get: xd[e]
                        })
                    })), Ld.prototype._getSSRC = function(e) {
                        return this.localSSRCs.get(e)
                    }, Ld.prototype.isSharingLowFpsScreen = function() {
                        return this._isSharingScreen() && this._capScreenshareBitrate
                    }, Ld.prototype._isSharingScreen = function() {
                        const e = this.getLocalVideoTracks();
                        return Boolean(e.find((e => e.videoType === An.VideoType.DESKTOP)))
                    }, Ld.prototype._mungeCodecOrder = function(e) {
                        if (!this.codecPreference) return e;
                        const t = Lr.parse(e.sdp),
                            i = t.media.find((e => e.type === this.codecPreference.mediaType));
                        return i ? (this.codecPreference.enable ? (Fr.preferCodec(i, this.codecPreference.mimeType), this.codecPreference.mimeType === Ar.H264 && Ui.isReactNative() && this.isP2P && Fr.stripCodec(i, this.codecPreference.mimeType, !0)) : Fr.stripCodec(i, this.codecPreference.mimeType), new RTCSessionDescription({
                            type: e.type,
                            sdp: Lr.write(t)
                        })) : e
                    }, Ld.prototype.addTrack = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        const i = e.rtcId;
                        if (wd.info(`${this} adding ${e}`), this.localTracks.has(i)) return Promise.reject(new Error(`${e} is already in ${this}`));
                        this.localTracks.set(i, e);
                        const n = e.getOriginalStream();
                        if (this._usesUnifiedPlan) {
                            wd.debug(`${this} TPC.addTrack using unified plan`);
                            try {
                                this.tpcUtils.addTrack(e, t), e && (e.isAudioTrack() ? this._hasHadAudioTrack = !0 : this._hasHadVideoTrack = !0)
                            } catch (t) {
                                return wd.error(`${this} Adding track=${e} failed: ${null==t?void 0:t.message}`), Promise.reject(t)
                            }
                        } else {
                            if (n) this._addStream(n);
                            else if (!Ui.doesVideoMuteByStreamRemove() || e.isAudioTrack() || e.isVideoTrack() && !e.isMuted()) return Promise.reject(new Error(`${this} no WebRTC stream for track=${e}`));
                            if (Ui.doesVideoMuteByStreamRemove() && e.isVideoTrack() && e.isMuted()) {
                                const t = this.generateNewStreamSSRCInfo(e);
                                this.sdpConsistency.setPrimarySsrc(t.ssrcs[0]);
                                const i = t.groups.find((e => "SIM" === e.semantics));
                                i && this.simulcast.setSsrcCache(i.ssrcs);
                                const n = t.groups.filter((e => "FID" === e.semantics));
                                if (n) {
                                    const e = new Map;
                                    n.forEach((t => {
                                        const i = t.ssrcs[0],
                                            n = t.ssrcs[1];
                                        e.set(i, n)
                                    })), this.rtxModifier.setSsrcCache(e)
                                }
                            }
                        }
                        let s = Promise.resolve();
                        return Ui.isFirefox() && (s = s.then((() => n && this.tpcUtils.setEncodings(e)))), s
                    }, Ld.prototype.addTrackToPc = function(e) {
                        if (wd.info(`${this} Adding track=${e} to PC`), !this._assertTrackBelongs("addTrackToPc", e)) return Promise.reject("Track not found on the peerconnection");
                        const t = e.getOriginalStream();
                        return t ? this._usesUnifiedPlan ? this.tpcUtils.replaceTrack(null, e).then((() => (e && (e.isAudioTrack() ? this._hasHadAudioTrack = !0 : this._hasHadVideoTrack = !0), !1))) : (this._addStream(t), Promise.resolve(!0)) : (wd.error(`${this} Unable to add track=${e} to PC - no WebRTC stream`), Promise.reject("Stream not found"))
                    }, Ld.prototype._addStream = function(e) {
                        this.peerconnection.addStream(e), this._addedStreams.push(e)
                    }, Ld.prototype._removeStream = function(e) {
                        this.peerconnection.removeStream(e), this._addedStreams = this._addedStreams.filter((t => t !== e))
                    }, Ld.prototype._assertTrackBelongs = function(e, t) {
                        const i = this.localTracks.has(null == t ? void 0 : t.rtcId);
                        return i || wd.error(`${this} ${e}: track=${t} does not belong to pc`), i
                    }, Ld.prototype.getConfiguredVideoCodec = function() {
                        var e;
                        const t = null === (e = this.peerconnection.localDescription) || void 0 === e ? void 0 : e.sdp,
                            i = Ar.VP8;
                        if (!t) return i;
                        const n = Lr.parse(t).media.find((e => e.type === dn.VIDEO)).rtp[0].codec;
                        return n ? Object.values(Ar).find((e => e === n.toLowerCase())) : i
                    }, Ld.prototype.setDesktopSharingFrameRate = function(e) {
                        const t = e <= 5;
                        this._capScreenshareBitrate = this.isSimulcastOn() && t
                    }, Ld.prototype.setVideoCodecs = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                        const i = null === t,
                            n = t || e;
                        this.codecPreference && (e || t) ? (this.codecPreference.enable = i, this.codecPreference.mimeType = n) : e || t ? this.codecPreference = {
                            enable: i,
                            mediaType: dn.VIDEO,
                            mimeType: n
                        } : wd.warn(`${this} Invalid codec settings[preferred=${e},disabled=${t}],\n            atleast one value is needed`)
                    }, Ld.prototype.isMediaStreamInPc = function(e) {
                        return this._addedStreams.indexOf(e) > -1
                    }, Ld.prototype.removeTrack = function(e) {
                        const t = e.getOriginalStream();
                        this.trace("removeStream", e.rtcId, t ? t.id : void 0), this._assertTrackBelongs("removeStream", e) && (this.localTracks.delete(e.rtcId), this.localSSRCs.delete(e.rtcId), t && this.peerconnection.removeStream(t))
                    }, Ld.prototype.findSenderByKind = function(e) {
                        if (this.peerconnection.getSenders) return this.peerconnection.getSenders().find((t => t.track && t.track.kind === e))
                    }, Ld.prototype.findReceiverForTrack = function(e) {
                        return this.peerconnection.getReceivers().find((t => t.track === e))
                    }, Ld.prototype.findSenderForTrack = function(e) {
                        if (this.peerconnection.getSenders) return this.peerconnection.getSenders().find((t => t.track === e))
                    }, Ld.prototype.replaceTrack = function(e, t) {
                        if (!e && !t) return wd.info(`${this} replaceTrack called with no new track and no old track`), Promise.resolve();
                        const i = !(!e && (null == t ? void 0 : t.getVideoType()) === An.VideoType.DESKTOP && hn.isMultiStreamSupportEnabled() && !this.isP2P) && Boolean(!e || !this.localTracks.has(null == e ? void 0 : e.rtcId));
                        if (this._usesUnifiedPlan) {
                            var n;
                            wd.debug(`${this} TPC.replaceTrack using unified plan`);
                            const s = null !== (n = null == t ? void 0 : t.getType()) && void 0 !== n ? n : null == e ? void 0 : e.getType(),
                                r = null == t ? void 0 : t.getOriginalStream();
                            return (t && !r ? Promise.resolve() : this.tpcUtils.replaceTrack(e, t)).then((n => {
                                if (t && (t.isAudioTrack() ? this._hasHadAudioTrack = !0 : this._hasHadVideoTrack = !0), e && this.localTracks.delete(e.rtcId), t && this.localTracks.set(t.rtcId, t), e && t) {
                                    const i = this.localSSRCs.get(e.rtcId);
                                    i && (this.localSSRCs.delete(e.rtcId), this.localSSRCs.set(t.rtcId, i))
                                }
                                const r = s === dn.AUDIO ? this.audioTransferActive : this.videoTransferActive;
                                return n && r ? n.direction = t || Ui.isFirefox() ? Ir.SENDRECV : Ir.RECVONLY : n && (n.direction = Ir.INACTIVE), (Ui.usesSdpMungingForSimulcast() || !t ? Promise.resolve() : this.tpcUtils.setEncodings(t)).then((() => i))
                            }))
                        }
                        wd.debug(`${this} TPC.replaceTrack using plan B`);
                        let s = Promise.resolve();
                        return e && this.removeTrack(e), t && (s = this.addTrack(t)), s.then((() => !0))
                    }, Ld.prototype.removeTrackFromPc = function(e) {
                        const t = e.getOriginalStream();
                        return this.trace("removeTrack", e.rtcId, t ? t.id : null), this._assertTrackBelongs("removeTrack", e) ? this._usesUnifiedPlan ? this.tpcUtils.replaceTrack(e, null).then((() => !1)) : t ? (wd.info(`${this} Removing track=${e} from PC`), this._removeStream(t), Promise.resolve(!0)) : (wd.error(`${this} removeTrack - no WebRTC stream for track=${e}`), Promise.reject("Stream not found")) : Promise.reject("Track not found in the peerconnection")
                    }, Ld.prototype.createDataChannel = function(e, t) {
                        return this.trace("createDataChannel", e, t), this.peerconnection.createDataChannel(e, t)
                    }, Ld.prototype._ensureSimulcastGroupIsLast = function(e) {
                        let t = e.sdp;
                        const i = t.indexOf("m=video"),
                            n = t.indexOf("a=ssrc-group:SIM", i);
                        let s = t.lastIndexOf("a=ssrc-group");
                        if (-1 === n || -1 === s || s === n) return e;
                        const r = t.indexOf("\r\n", n),
                            o = t.substring(n, r + 2);
                        t = t.replace(o, ""), s = t.lastIndexOf("a=ssrc-group");
                        const a = t.indexOf("\r\n", s),
                            c = t.slice(0, a),
                            d = o.trim(),
                            l = t.slice(a);
                        return t = `${c}\r\n${d}${l}`, new RTCSessionDescription({
                            type: e.type,
                            sdp: t
                        })
                    }, Ld.prototype._adjustLocalMediaDirection = function(e) {
                        var t, i;
                        const n = new ld(e.sdp);
                        let s = !1;
                        const r = null === (t = n.selectMedia(dn.AUDIO)) || void 0 === t ? void 0 : t[0];
                        if (r) {
                            const e = this.getDesiredMediaDirection(dn.AUDIO);
                            r.direction !== e && (r.direction = e, wd.info(`${this} Adjusted local audio direction to ${e}`), s = !0)
                        } else wd.warn(`${this} No "audio" media found in the local description`);
                        const o = null === (i = n.selectMedia(dn.VIDEO)) || void 0 === i ? void 0 : i[0];
                        if (o) {
                            const e = this.getDesiredMediaDirection(dn.VIDEO);
                            o.direction !== e && (o.direction = e, wd.info(`${this} Adjusted local video direction to ${e}`), s = !0)
                        } else wd.warn(`${this} No "video" media found in the local description`);
                        return s ? new RTCSessionDescription({
                            type: e.type,
                            sdp: n.toRawSDP()
                        }) : e
                    }, Ld.prototype._adjustRemoteMediaDirection = function(e) {
                        const t = new ld(e.sdp);
                        return [dn.AUDIO, dn.VIDEO].forEach((e => {
                            var i;
                            const n = null === (i = t.selectMedia(e)) || void 0 === i ? void 0 : i[0],
                                s = this.hasAnyTracksOfType(e),
                                r = this.getRemoteTracks(null, e).length > 0;
                            n.direction = s && r ? Ir.SENDRECV : s ? Ir.RECVONLY : r ? Ir.SENDONLY : Ir.INACTIVE
                        })), new RTCSessionDescription({
                            type: e.type,
                            sdp: t.toRawSDP()
                        })
                    }, Ld.prototype._mungeOpus = function(e) {
                        const {
                            audioQuality: t
                        } = this.options;
                        if (!(null != t && t.stereo || null != t && t.opusMaxAverageBitrate)) return e;
                        const i = Lr.parse(e.sdp),
                            n = i.media;
                        for (const e of n)
                            if ("audio" === e.type) {
                                const {
                                    payload: i
                                } = e.rtp.find((e => e.codec === Ar.OPUS));
                                if (!i) continue;
                                let n = e.fmtp.find((e => e.payload === i));
                                n || (n = {
                                    payload: i,
                                    config: ""
                                });
                                const s = Lr.parseParams(n.config);
                                let r = !1;
                                if (null != t && t.stereo && (s.stereo = 1, r = !0), null != t && t.opusMaxAverageBitrate && (s.maxaveragebitrate = t.opusMaxAverageBitrate, r = !0), !r) continue;
                                let o = "";
                                for (const e of Object.keys(s)) o += `${e}=${s[e]}; `;
                                n.config = o.trim()
                            } return new RTCSessionDescription({
                            type: e.type,
                            sdp: Lr.write(i)
                        })
                    }, Ld.prototype._mungeInactive = function(e) {
                        const t = Lr.parse(e.sdp),
                            i = t.media;
                        for (const e of i) e.direction = Ir.INACTIVE, e.ssrcs = void 0, e.ssrcGroups = void 0;
                        return new RTCSessionDescription({
                            type: e.type,
                            sdp: Lr.write(t)
                        })
                    }, Ld.prototype._initializeDtlsTransport = function() {
                        if (!this.peerconnection.getSenders || this._dtlsTransport) return;
                        const e = this.peerconnection.getSenders();
                        0 !== e.length && e[0].transport && (this._dtlsTransport = e[0].transport, this._dtlsTransport.onerror = e => {
                            wd.error(`${this} DtlsTransport error: ${e}`)
                        }, this._dtlsTransport.onstatechange = () => {
                            this.trace("dtlsTransport.onstatechange", this._dtlsTransport.state)
                        })
                    }, Ld.prototype._setVp9MaxBitrates = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        if (!this.codecPreference) return e;
                        const i = Lr.parse(e.sdp),
                            n = t ? Ir.RECVONLY : Ir.SENDONLY,
                            s = hn.isMultiStreamSupportEnabled() ? i.media.filter((e => e.type === dn.VIDEO && e.direction !== n)) : [i.media.find((e => e.type === dn.VIDEO))],
                            r = () => {
                                const e = this.getLocalVideoTracks().find((e => e.getVideoType() === An.VideoType.DESKTOP));
                                let t;
                                if (e) {
                                    var i;
                                    const n = Number(null === (i = e.getSourceName()) || void 0 === i ? void 0 : i.split("-")[1].substring(1));
                                    if ("number" == typeof n) {
                                        const e = this.peerconnection.getTransceivers().filter((e => e.receiver.track.kind === dn.VIDEO && e.direction !== Ir.RECVONLY))[n];
                                        t = null == e ? void 0 : e.mid
                                    }
                                }
                                return Number(t)
                            };
                        for (const e of s)
                            if (this.codecPreference.mimeType === Ar.VP9) {
                                const t = this.tpcUtils.videoBitrates.VP9 || this.tpcUtils.videoBitrates,
                                    i = t.high ? t.high : Dd,
                                    n = e.mid,
                                    s = hn.isMultiStreamSupportEnabled() ? n === r() : this._isSharingScreen(),
                                    o = Math.floor((s ? Dd : i) / 1e3);
                                e.bandwidth = [{
                                    type: "AS",
                                    limit: o
                                }]
                            } else e.bandwidth = void 0;
                        return new RTCSessionDescription({
                            type: e.type,
                            sdp: Lr.write(i)
                        })
                    }, Ld.prototype.configureSenderVideoEncodings = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                        if (hn.isSourceNameSignalingEnabled()) {
                            if (e) return this.setSenderVideoConstraints(this._senderMaxHeights.get(e.getSourceName()), e);
                            const t = [];
                            for (const e of this.getLocalVideoTracks()) t.push(this.setSenderVideoConstraints(this._senderMaxHeights.get(e.getSourceName()), e));
                            return Promise.allSettled(t)
                        }
                        let t = e;
                        return t || (t = this.getLocalVideoTracks()[0]), this.setSenderVideoConstraints(this._senderVideoMaxHeight, t)
                    }, Ld.prototype.setLocalDescription = function(e) {
                        let t = e;
                        return this.trace("setLocalDescription::preTransform", kd(t)), t = this._mungeOpus(t), this._usesUnifiedPlan || (t = this._adjustLocalMediaDirection(t), t = this._ensureSimulcastGroupIsLast(t)), t = this._mungeCodecOrder(t), t = this._setVp9MaxBitrates(t, !0), this.trace("setLocalDescription::postTransform", kd(t)), new Promise(((e, i) => {
                            this.peerconnection.setLocalDescription(t).then((() => {
                                this.trace("setLocalDescriptionOnSuccess");
                                const i = Fr.getUfrag(t.sdp);
                                i !== this.localUfrag && (this.localUfrag = i, this.eventEmitter.emit(Rn.default.LOCAL_UFRAG_CHANGED, this, i)), this._initializeDtlsTransport(), e()
                            }), (e => {
                                this.trace("setLocalDescriptionOnFailure", e), this.eventEmitter.emit(Rn.default.SET_LOCAL_DESCRIPTION_FAILED, e, this), i(e)
                            }))
                        }))
                    }, Ld.prototype.setAudioTransferActive = function(e) {
                        wd.debug(`${this} audio transfer active: ${e}`);
                        const t = this.audioTransferActive !== e;
                        return this.audioTransferActive = e, this._usesUnifiedPlan ? (this.tpcUtils.setAudioTransferActive(e), !1) : t
                    }, Ld.prototype.setRemoteDescription = function(e) {
                        let t = e;
                        if (this.trace("setRemoteDescription::preTransform", kd(e)), t = this._mungeOpus(t), this._usesUnifiedPlan) {
                            if (!this.isP2P) {
                                const e = this.peerconnection.remoteDescription;
                                t = this.interop.toUnifiedPlan(t, e), this.trace("setRemoteDescription::postTransform (Unified)", kd(t)), hn.isRunInLiteModeEnabled() && (t = this._mungeInactive(t))
                            }
                            this.isSimulcastOn() && (t = this.tpcUtils.insertUnifiedPlanSimulcastReceive(t), this.trace("setRemoteDescription::postTransform (sim receive)", kd(t))), t = this.tpcUtils.ensureCorrectOrderOfSsrcs(t), this.trace("setRemoteDescription::postTransform (correct ssrc order)", kd(t))
                        } else this.isSimulcastOn() && (t = this.simulcast.mungeRemoteDescription(t, !0), this.trace("setRemoteDescription::postTransform (simulcast)", kd(t))), t = function(e) {
                            if ("object" != typeof e || null === e || "string" != typeof e.sdp) return wd.warn("An empty description was passed as an argument"), e;
                            const t = i(8310),
                                n = t.parse(e.sdp);
                            void 0 !== n && void 0 !== n.media && Array.isArray(n.media) && n.media.forEach((e => {
                                const t = [],
                                    i = [];
                                if (void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach((e => {
                                        void 0 !== e.semantics && "FID" === e.semantics && void 0 !== e.ssrcs && t.push(Number(e.ssrcs.split(" ")[0]))
                                    })), Array.isArray(e.ssrcs)) {
                                    let n;
                                    for (n = 0; n < e.ssrcs.length; n++) "object" == typeof e.ssrcs[n] && void 0 !== e.ssrcs[n].id && t.indexOf(e.ssrcs[n].id) >= 0 && (i.push(e.ssrcs[n]), delete e.ssrcs[n]);
                                    for (n = 0; n < e.ssrcs.length; n++) void 0 !== e.ssrcs[n] && i.push(e.ssrcs[n]);
                                    e.ssrcs = function() {
                                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                                        if (!Ui.isChrome() || !Ui.isVersionGreaterThan(70)) return e;
                                        let t = [...e];
                                        return e.filter((e => "mslabel" === e.attribute && "-" === e.value)).map((e => e.id)).forEach((e => {
                                            const i = t.find((t => t.id === e && "cname" === t.attribute));
                                            i.value = `${Ir.RECVONLY}-${e}`, t = t.filter((t => t.id !== e)), t.push(i)
                                        })), t
                                    }(i)
                                }
                            }));
                            const s = t.write(n);
                            return new RTCSessionDescription({
                                type: e.type,
                                sdp: s
                            })
                        }(t);
                        return t = this._mungeCodecOrder(t), t = this._setVp9MaxBitrates(t), this.trace("setRemoteDescription::postTransform (munge codec order)", kd(t)), new Promise(((e, i) => {
                            this.peerconnection.setRemoteDescription(t).then((() => {
                                this.trace("setRemoteDescriptionOnSuccess");
                                const i = Fr.getUfrag(t.sdp);
                                i !== this.remoteUfrag && (this.remoteUfrag = i, this.eventEmitter.emit(Rn.default.REMOTE_UFRAG_CHANGED, this, i)), this._initializeDtlsTransport(), e()
                            }), (e => {
                                this.trace("setRemoteDescriptionOnFailure", e), this.eventEmitter.emit(Rn.default.SET_REMOTE_DESCRIPTION_FAILED, e, this), i(e)
                            }))
                        }))
                    }, Ld.prototype.setSenderVideoConstraints = function(e, t) {
                        var i;
                        if (e < 0) throw new Error(`Invalid frameHeight: ${e}`);
                        if (Ui.isReactNative()) return Promise.resolve();
                        if (hn.isSourceNameSignalingEnabled() ? this._senderMaxHeights.set(t.getSourceName(), e) : this._senderVideoMaxHeight = e, !t || t.isMuted()) return Promise.resolve();
                        const n = this.findSenderForTrack(t.getTrack());
                        if (!n) return Promise.resolve();
                        const s = n.getParameters();
                        if (null == s || null === (i = s.encodings) || void 0 === i || !i.length) return Promise.resolve();
                        const r = t.getVideoType() === An.VideoType.DESKTOP && this._capScreenshareBitrate,
                            o = r ? "maintain-resolution" : "maintain-framerate";
                        s.degradationPreference = o, wd.info(`${this} Setting degradation preference [preference=${o},track=${t}`), this.encodingsEnabledState = this.tpcUtils.calculateEncodingsActiveState(t, e);
                        const a = this.tpcUtils.calculateEncodingsBitrates(t),
                            c = t.getVideoType();
                        if (this.isSimulcastOn()) {
                            for (const e in s.encodings) {
                                var d, l;
                                s.encodings.hasOwnProperty(e) && (s.encodings[e].active = this.encodingsEnabledState[e], Ui.isFirefox() && (s.encodings[e].degradationPreference = o), this.getConfiguredVideoCodec() === Ar.VP8 && (null !== (d = this.options) && void 0 !== d && null !== (l = d.videoQuality) && void 0 !== l && l.maxBitratesVideo || r || this._usesUnifiedPlan) && (s.encodings[e].maxBitrate = a[e]))
                            }
                            this.tpcUtils.updateEncodingsResolution(s)
                        } else if (e > 0) {
                            var h, u;
                            let i = 1;
                            if (c === An.VideoType.CAMERA && t.resolution > e && (i = Math.floor(t.resolution / e)), s.encodings[0].active = !0, s.encodings[0].scaleResolutionDownBy = i, Ui.isFirefox() && (s.encodings[0].degradationPreference = o), this.getConfiguredVideoCodec() === Ar.VP8 && null !== (h = this.options) && void 0 !== h && null !== (u = h.videoQuality) && void 0 !== u && u.maxBitratesVideo) {
                                var p;
                                let e = null === (p = this.getTargetVideoBitrates()) || void 0 === p ? void 0 : p.high;
                                var m, f;
                                c === An.VideoType.CAMERA && (e = null !== (m = null === (f = this.tpcUtils.localStreamEncodingsConfig.find((e => e.scaleResolutionDownBy === i))) || void 0 === f ? void 0 : f.maxBitrate) && void 0 !== m ? m : e), s.encodings[0].maxBitrate = e
                            }
                        } else s.encodings[0].active = !1;
                        return wd.info(`${this} setting max height=${e},encodings=${JSON.stringify(s.encodings)}`), n.setParameters(s).then((() => {
                            t.maxEnabledResolution = e, this.eventEmitter.emit(Rn.default.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED, t)
                        }))
                    }, Ld.prototype.setVideoTransferActive = function(e) {
                        wd.debug(`${this} video transfer active: ${e}`);
                        const t = this.videoTransferActive !== e;
                        return this.videoTransferActive = e, this._usesUnifiedPlan ? (this.tpcUtils.setVideoTransferActive(e), !1) : t
                    }, Ld.prototype.sendTones = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 200,
                            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 200;
                        if (!this._dtmfSender) {
                            if (this.peerconnection.getSenders) {
                                const e = this.peerconnection.getSenders().find((e => e.dtmf));
                                this._dtmfSender = e && e.dtmf, this._dtmfSender && wd.info(`${this} initialized DTMFSender using getSenders`)
                            }
                            if (!this._dtmfSender) {
                                const e = Array.from(this.localTracks.values()).find((e => e.isAudioTrack()));
                                this.peerconnection.createDTMFSender && e && (this._dtmfSender = this.peerconnection.createDTMFSender(e.getTrack())), this._dtmfSender && wd.info(`${this} initialized DTMFSender using deprecated createDTMFSender`)
                            }
                            this._dtmfSender && (this._dtmfSender.ontonechange = this._onToneChange.bind(this))
                        }
                        if (this._dtmfSender) {
                            if (this._dtmfSender.toneBuffer) return void this._dtmfTonesQueue.push({
                                tones: e,
                                duration: t,
                                interToneGap: i
                            });
                            this._dtmfSender.insertDTMF(e, t, i)
                        } else wd.warn(`${this} sendTones - failed to select DTMFSender`)
                    }, Ld.prototype._onToneChange = function(e) {
                        if (this._dtmfSender && "" === e.tone && this._dtmfTonesQueue.length) {
                            const {
                                tones: e,
                                duration: t,
                                interToneGap: i
                            } = this._dtmfTonesQueue.shift();
                            this._dtmfSender.insertDTMF(e, t, i)
                        }
                    }, Ld.prototype.generateRecvonlySsrc = function() {
                        const e = Fr.generateSsrc();
                        wd.info(`${this} generated new recvonly SSRC=${e}`), this.sdpConsistency.setPrimarySsrc(e)
                    }, Ld.prototype.clearRecvonlySsrc = function() {
                        wd.info(`${this} Clearing primary video SSRC!`), this.sdpConsistency.clearVideoSsrcCache()
                    }, Ld.prototype.close = function() {
                        this.trace("stop"), this.signalingLayer.off(Zc, this._peerMutedChanged), this.signalingLayer.off(ed, this._peerVideoTypeChanged), this._usesUnifiedPlan && this.peerconnection.removeEventListener("track", this.onTrack);
                        for (const e of this.remoteTracks.values())
                            for (const t of e.values())
                                for (const e of t) this._removeRemoteTrack(e);
                        this.remoteTracks.clear(), this._addedStreams = [], this._dtmfSender = null, this._dtmfTonesQueue = [], this.rtc._removePeerConnection(this) || wd.error(`${this} RTC._removePeerConnection returned false`), null !== this.statsinterval && (window.clearInterval(this.statsinterval), this.statsinterval = null), wd.info(`${this} Closing peerconnection`), this.peerconnection.close()
                    }, Ld.prototype.createAnswer = function(e) {
                        return this._createOfferOrAnswer(!1, e)
                    }, Ld.prototype.createOffer = function(e) {
                        return this._createOfferOrAnswer(!0, e)
                    }, Ld.prototype._createOfferOrAnswer = function(e, t) {
                        const i = e ? "Offer" : "Answer";
                        this.trace(`create${i}`, JSON.stringify(t, null, " "));
                        const n = (e, t, n) => {
                                try {
                                    this.trace(`create${i}OnSuccess::preTransform`, kd(e)), this._usesUnifiedPlan || (this.hasAnyTracksOfType(dn.VIDEO) || this.sdpConsistency.hasPrimarySsrcCached() || this.generateRecvonlySsrc(), e = new RTCSessionDescription({
                                        type: e.type,
                                        sdp: this.sdpConsistency.makeVideoPrimarySsrcsConsistent(e.sdp)
                                    }), this.trace(`create${i}OnSuccess::postTransform (make primary audio/video ssrcs consistent)`, kd(e)));
                                    const n = this.getLocalVideoTracks()[0];
                                    this.isSimulcastOn() && Ui.usesSdpMungingForSimulcast() && ((null == n ? void 0 : n.getVideoType()) === An.VideoType.CAMERA || this._usesUnifiedPlan) && (e = this.simulcast.mungeLocalDescription(e), this.trace(`create${i} OnSuccess::postTransform (simulcast)`, kd(e))), !this.options.disableRtx && Ui.usesSdpMungingForSimulcast() && (e = new RTCSessionDescription({
                                        type: e.type,
                                        sdp: this.rtxModifier.modifyRtxSsrcs(e.sdp)
                                    }), this.trace(`create${i}OnSuccess::postTransform (rtx modifier)`, kd(e)));
                                    const s = this._extractSSRCMap(e);
                                    this._processLocalSSRCsMap(s), t(e)
                                } catch (t) {
                                    this.trace(`create${i}OnError`, t), this.trace(`create${i}OnError`, kd(e)), wd.error(`${this} create${i}OnError`, t, kd(e)), n(t)
                                }
                            },
                            s = (t, n) => {
                                this.trace(`create${i}OnFailure`, t);
                                const s = e ? Rn.default.CREATE_OFFER_FAILED : Rn.default.CREATE_ANSWER_FAILED;
                                this.eventEmitter.emit(s, t, this), n(t)
                            };
                        if (this._usesTransceiverCodecPreferences) {
                            const e = this.peerconnection.getTransceivers().find((e => {
                                var t, i;
                                return e.receiver && (null === (t = e.receiver) || void 0 === t || null === (i = t.track) || void 0 === i ? void 0 : i.kind) === dn.VIDEO
                            }));
                            if (e) {
                                var r, o, a;
                                let t = null === (r = RTCRtpReceiver.getCapabilities(dn.VIDEO)) || void 0 === r ? void 0 : r.codecs;
                                const i = null === (o = this.codecPreference) || void 0 === o ? void 0 : o.mimeType,
                                    n = null === (a = this.codecPreference) || void 0 === a ? void 0 : a.enable;
                                t && i && n ? t.sort((e => e.mimeType.toLowerCase() === `${dn.VIDEO}/${i}` ? -1 : 1)) : t && i && (t = t.filter((e => e.mimeType.toLowerCase() !== `${dn.VIDEO}/${i}`))), Ui.isChromiumBased() && (t = t.filter((e => e.mimeType.toLowerCase() !== `${dn.VIDEO}/${Ar.ULPFEC}`)));
                                try {
                                    e.setCodecPreferences(t)
                                } catch (e) {
                                    wd.warn(`${this} Setting codec[preference=${i},enable=${n}] failed`, e)
                                }
                            }
                        }
                        return new Promise(((i, r) => {
                            let o;
                            o = e ? this.peerconnection.createOffer(t) : this.peerconnection.createAnswer(t), o.then((e => n(e, i, r)), (e => s(e, r)))
                        }))
                    }, Ld.prototype._extractPrimarySSRC = function(e) {
                        return e && e.groups && e.groups.length ? e.groups[0].ssrcs[0] : e && e.ssrcs && e.ssrcs.length ? e.ssrcs[0] : null
                    }, Ld.prototype._processLocalSSRCsMap = function(e) {
                        for (const i of this.localTracks.values()) {
                            let n, s;
                            var t;
                            hn.isMultiStreamSupportEnabled() && (s = i.getSourceName(), n = (null === (t = s) || void 0 === t ? void 0 : t.indexOf("-")) + 2);
                            const r = this._usesUnifiedPlan ? hn.isMultiStreamSupportEnabled() && n ? `${i.getType()}-${s.substr(n,1)}` : i.getType() : i.storedMSID;
                            if (e.has(r)) {
                                const t = e.get(r);
                                if (!t) return void wd.error(`${this} No SSRC found for stream=${r}`);
                                const n = this.localSSRCs.get(i.rtcId),
                                    s = this._extractPrimarySSRC(t),
                                    o = this._extractPrimarySSRC(n);
                                s !== o && (o && wd.error(`${this} Overwriting SSRC for track=${i}] with ssrc=${t}`), this.localSSRCs.set(i.rtcId, t), this.eventEmitter.emit(Rn.default.LOCAL_TRACK_SSRC_UPDATED, i, s))
                            } else i.isVideoTrack() || i.isMuted() || wd.warn(`${this} No SSRCs found in the local SDP for track=${i}, stream=${r}`)
                        }
                    }, Ld.prototype.addIceCandidate = function(e) {
                        return this.trace("addIceCandidate", JSON.stringify({
                            candidate: e.candidate,
                            sdpMid: e.sdpMid,
                            sdpMLineIndex: e.sdpMLineIndex,
                            usernameFragment: e.usernameFragment
                        }, null, " ")), this.peerconnection.addIceCandidate(e)
                    }, Ld.prototype.getActiveSimulcastStreams = function() {
                        let e = 1;
                        var t;
                        return this.isSimulcastOn() && this.encodingsEnabledState ? e = null === (t = this.encodingsEnabledState.filter((e => Boolean(e)))) || void 0 === t ? void 0 : t.length : this.isSimulcastOn() && (e = Md.length), e
                    }, Ld.prototype.getStats = function() {
                        return this.peerconnection.getStats()
                    }, Ld.prototype.generateNewStreamSSRCInfo = function(e) {
                        const t = e.rtcId;
                        let i = this._getSSRC(t);
                        if (i && wd.error(`${this} Overwriting local SSRCs for track id=${t}`), !this.isSimulcastOn() || e.getVideoType() !== An.VideoType.CAMERA && this.isSharingLowFpsScreen()) i = {
                            ssrcs: [Fr.generateSsrc()],
                            groups: []
                        };
                        else {
                            i = {
                                ssrcs: [],
                                groups: []
                            };
                            for (let e = 0; e < Md.length; e++) i.ssrcs.push(Fr.generateSsrc());
                            i.groups.push({
                                ssrcs: i.ssrcs.slice(),
                                semantics: "SIM"
                            })
                        }
                        if (!this.options.disableRtx) {
                            const e = i.ssrcs.length;
                            for (let t = 0; t < e; ++t) {
                                const e = i.ssrcs[t],
                                    n = Fr.generateSsrc();
                                i.ssrcs.push(n), i.groups.push({
                                    ssrcs: [e, n],
                                    semantics: "FID"
                                })
                            }
                        }
                        return i.msid = e.storedMSID, this.localSSRCs.set(t, i), i
                    }, Ld.prototype.usesUnifiedPlan = function() {
                        return this._usesUnifiedPlan
                    }, Ld.prototype.toString = function() {
                        return `TPC[id=${this.id},type=${this.isP2P?"P2P":"JVB"}]`
                    };
                    const Fd = (0, v.getLogger)("modules/RTC/RTC.js");
                    let Vd, Ud = 0,
                        jd = 0;

                    function $d() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        return e.map((e => {
                            const {
                                sourceId: t,
                                sourceType: i,
                                stream: n,
                                track: s,
                                videoType: r,
                                effects: o
                            } = e, {
                                deviceId: a,
                                facingMode: c
                            } = s.getSettings();
                            return jd = nn(jd), new $c({
                                deviceId: a,
                                facingMode: c,
                                mediaType: s.kind,
                                rtcId: jd,
                                sourceId: t,
                                sourceType: i,
                                stream: n,
                                track: s,
                                videoType: r || null,
                                effects: o
                            })
                        }))
                    }
                    class Hd extends Wn {
                        constructor(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            super(), this.conference = e, this.peerConnections = new Map, this.localTracks = [], this.options = t, this._channel = null, this._lastN = void 0, this._lastNEndpoints = null, this._forwardedSources = null, this._maxFrameHeight = void 0, this._selectedEndpoints = null, this._lastNChangeListener = this._onLastNChanged.bind(this), this._forwardedSourcesChangeListener = this._onForwardedSourcesChanged.bind(this), this._onDeviceListChanged = this._onDeviceListChanged.bind(this), this._updateAudioOutputForAudioTracks = this._updateAudioOutputForAudioTracks.bind(this), this._videoType = da().NONE, xc.isDeviceChangeAvailable("output") && (xc.addListener(Rn.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), xc.addListener(Rn.default.DEVICE_LIST_CHANGED, this._onDeviceListChanged))
                        }
                        destroy() {
                            xc.removeListener(Rn.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), xc.removeListener(Rn.default.DEVICE_LIST_CHANGED, this._onDeviceListChanged), this._channelOpenListener && this.removeListener(Rn.default.DATA_CHANNEL_OPEN, this._channelOpenListener)
                        }
                        static createLocalTracks(e) {
                            return $d(e)
                        }
                        static obtainAudioAndVideoPermissions(e) {
                            return xc.obtainAudioAndVideoPermissions(e).then((e => $d(e)))
                        }
                        initializeBridgeChannel(e, t) {
                            this._channel = new ha(e, t, this.eventEmitter), this._channelOpenListener = () => {
                                const e = (e, t, i) => {
                                    Gi().callErrorHandler(e), Fd.error(`Cannot send ${t}(${JSON.stringify(i)}) endpoint message`, e)
                                };
                                if (this._receiverVideoConstraints) try {
                                    this._channel.sendNewReceiverVideoConstraintsMessage(this._receiverVideoConstraints)
                                } catch (t) {
                                    e(t, "ReceiverVideoConstraints", this._receiverVideoConstraints)
                                }
                                if (this._selectedEndpoints) try {
                                    this._channel.sendSelectedEndpointsMessage(this._selectedEndpoints)
                                } catch (t) {
                                    e(t, "SelectedEndpointsChangedEvent", this._selectedEndpoints)
                                }
                                if (void 0 !== this._maxFrameHeight) try {
                                    this._channel.sendReceiverVideoConstraintMessage(this._maxFrameHeight)
                                } catch (t) {
                                    e(t, "ReceiverVideoConstraint", this._maxFrameHeight)
                                }
                                if (void 0 !== this._lastN && -1 !== this._lastN) try {
                                    this._channel.sendSetLastNMessage(this._lastN)
                                } catch (t) {
                                    e(t, "LastNChangedEvent", this._lastN)
                                }
                                if (!hn.isSourceNameSignalingEnabled()) try {
                                    this._channel.sendVideoTypeMessage(this._videoType)
                                } catch (t) {
                                    e(t, "VideoTypeMessage", this._videoType)
                                }
                            }, this.addListener(Rn.default.DATA_CHANNEL_OPEN, this._channelOpenListener), this.addListener(Rn.default.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener), hn.isSourceNameSignalingEnabled() && this.addListener(Rn.default.FORWARDED_SOURCES_CHANGED, this._forwardedSourcesChangeListener)
                        }
                        _onDeviceListChanged() {
                            this._updateAudioOutputForAudioTracks(xc.getAudioOutputDevice())
                        }
                        _onLastNChanged() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                            const t = this._lastNEndpoints || [];
                            let i = [],
                                n = [];
                            this._lastNEndpoints = e, i = t.filter((e => !this.isInLastN(e))), n = e.filter((e => -1 === t.indexOf(e))), this.conference.eventEmitter.emit(pe, i, n)
                        }
                        _onForwardedSourcesChanged() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                            const t = this._forwardedSources || [];
                            let i = [],
                                n = [];
                            this._forwardedSources = e, i = t.filter((e => !this.isInForwardedSources(e))), n = e.filter((e => -1 === t.indexOf(e))), this.conference.eventEmitter.emit(me, i, n, Date.now())
                        }
                        onCallEnded() {
                            this._channel && (this._channel && "websocket" === this._channel.mode && this._channel.close(), this._channel = null)
                        }
                        setDesktopSharingFrameRate(e) {
                            xc.setDesktopSharingFrameRate(e)
                        }
                        setNewReceiverVideoConstraints(e) {
                            this._receiverVideoConstraints = e, this._channel && this._channel.isOpen() && this._channel.sendNewReceiverVideoConstraintsMessage(e)
                        }
                        setReceiverVideoConstraint(e) {
                            this._maxFrameHeight = e, this._channel && this._channel.isOpen() && this._channel.sendReceiverVideoConstraintMessage(e)
                        }
                        setVideoType(e) {
                            this._videoType !== e && (this._videoType = e, this._channel && this._channel.isOpen() && this._channel.sendVideoTypeMessage(e))
                        }
                        sendSourceVideoType(e, t) {
                            this._channel && this._channel.isOpen() && this._channel.sendSourceVideoTypeMessage(e, t)
                        }
                        selectEndpoints(e) {
                            this._selectedEndpoints = e, this._channel && this._channel.isOpen() && this._channel.sendSelectedEndpointsMessage(e)
                        }
                        static addListener(e, t) {
                            xc.addListener(e, t)
                        }
                        static removeListener(e, t) {
                            xc.removeListener(e, t)
                        }
                        static init() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            return this.options = e, xc.init(this.options)
                        }
                        createPeerConnection(e, t, i, n) {
                            const s = JSON.parse(JSON.stringify(xc.pcConstraints));
                            n.enableInsertableStreams && (Fd.debug("E2EE - setting insertable streams constraints"), t.encodedInsertableStreams = !0), (Ui.isReactNative() || Ui.isChromiumBased() && !n.usesUnifiedPlan) && (Fd.debug("WebRTC application is running in plan-b mode"), t.sdpSemantics = "plan-b"), n.forceTurnRelay && (t.iceTransportPolicy = "relay"), t.bundlePolicy = "max-bundle", Ud = nn(Ud);
                            const r = new Ld(this, Ud, e, t, s, i, n);
                            return this.peerConnections.set(r.id, r), r
                        }
                        _removePeerConnection(e) {
                            const t = e.id;
                            return !!this.peerConnections.has(t) && (this.peerConnections.delete(t), !0)
                        }
                        addLocalTrack(e) {
                            if (!e) throw new Error("track must not be null nor undefined");
                            this.localTracks.push(e), e.conference = this.conference
                        }
                        getForwardedSources() {
                            return this._forwardedSources
                        }
                        getLocalVideoTrack() {
                            const e = this.getLocalTracks(dn.VIDEO);
                            return e.length ? e[0] : void 0
                        }
                        getLocalVideoTracks() {
                            return this.getLocalTracks(dn.VIDEO)
                        }
                        getLocalAudioTrack() {
                            const e = this.getLocalTracks(dn.AUDIO);
                            return e.length ? e[0] : void 0
                        }
                        getLocalEndpointId() {
                            return this.conference.myUserId()
                        }
                        getLocalTracks(e) {
                            let t = this.localTracks.slice();
                            return void 0 !== e && (t = t.filter((t => t.getType() === e))), t
                        }
                        getRemoteTracks(e) {
                            let t = [];
                            for (const i of this.peerConnections.values()) {
                                const n = i.getRemoteTracks(void 0, e);
                                n && (t = t.concat(n))
                            }
                            return t
                        }
                        setAudioMute(e) {
                            const t = [];
                            return this.getLocalTracks(dn.AUDIO).forEach((i => {
                                t.push(e ? i.mute() : i.unmute())
                            })), Promise.all(t)
                        }
                        setVideoMute(e) {
                            const t = [];
                            return this.getLocalTracks(dn.VIDEO).concat(this.getLocalTracks(dn.PRESENTER)).forEach((i => {
                                t.push(e ? i.mute() : i.unmute())
                            })), Promise.all(t)
                        }
                        removeLocalTrack(e) {
                            const t = this.localTracks.indexOf(e); - 1 !== t && this.localTracks.splice(t, 1)
                        }
                        static attachMediaStream(e, t) {
                            return xc.attachMediaStream(e, t)
                        }
                        static isDeviceListAvailable() {
                            return xc.isDeviceListAvailable()
                        }
                        static isDeviceChangeAvailable(e) {
                            return xc.isDeviceChangeAvailable(e)
                        }
                        static isWebRtcSupported() {
                            return Ui.isSupported()
                        }
                        static getAudioOutputDevice() {
                            return xc.getAudioOutputDevice()
                        }
                        static getCurrentlyAvailableMediaDevices() {
                            return xc.getCurrentlyAvailableMediaDevices()
                        }
                        static arePermissionsGrantedForAvailableDevices() {
                            return xc.arePermissionsGrantedForAvailableDevices()
                        }
                        static getEventDataForActiveDevice(e) {
                            return xc.getEventDataForActiveDevice(e)
                        }
                        static setAudioOutputDevice(e) {
                            return xc.setAudioOutputDevice(e)
                        }
                        static isUserStream(e) {
                            return Hd.isUserStreamById(e.id)
                        }
                        static isUserStreamById(e) {
                            return e && "mixedmslabel" !== e && "default" !== e
                        }
                        static enumerateDevices(e) {
                            xc.enumerateDevices(e)
                        }
                        static stopMediaStream(e) {
                            xc.stopMediaStream(e)
                        }
                        static isDesktopSharingEnabled() {
                            return xc.isDesktopSharingEnabled()
                        }
                        closeBridgeChannel() {
                            this._channel && (this._channel.close(), this._channel = null, this.removeListener(Rn.default.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener))
                        }
                        setAudioLevel(e, t, i, n) {
                            const s = e.getTrackBySSRC(t);
                            s && (s.isAudioTrack() ? (s.isLocal() !== n && Fd.error(`${s} was expected to ${n?"be":"not be"} local`), s.setAudioLevel(i, e)) : Fd.warn(`Received audio level for non-audio track: ${t}`))
                        }
                        sendChannelMessage(e, t) {
                            if (!this._channel) throw new Error("Channel support is disabled!");
                            this._channel.sendMessage(e, t)
                        }
                        sendEndpointStatsMessage(e) {
                            this._channel && this._channel.isOpen() && this._channel.sendEndpointStatsMessage(e)
                        }
                        setLastN(e) {
                            this._lastN !== e && (this._lastN = e, this._channel && this._channel.isOpen() && this._channel.sendSetLastNMessage(e), this.eventEmitter.emit(Rn.default.LASTN_VALUE_CHANGED, e))
                        }
                        isInLastN(e) {
                            return !this._lastNEndpoints || this._lastNEndpoints.indexOf(e) > -1
                        }
                        isInForwardedSources(e) {
                            return !this._forwardedSources || this._forwardedSources.indexOf(e) > -1
                        }
                        _updateAudioOutputForAudioTracks(e) {
                            const t = this.getRemoteTracks(dn.AUDIO);
                            for (const i of t) i.setAudioOutput(e)
                        }
                    }! function(e) {
                        e.LOCAL_STATS_UPDATED = "cq.local_stats_updated", e.REMOTE_STATS_UPDATED = "cq.remote_stats_updated"
                    }(Vd || (Vd = {}));
                    const Bd = Vd.LOCAL_STATS_UPDATED,
                        Jd = Vd.REMOTE_STATS_UPDATED,
                        Gd = i(6125),
                        {
                            VideoType: Kd
                        } = i(3408),
                        {
                            XMPPEvents: qd
                        } = i(609),
                        Wd = (0, v.getLogger)("modules/connectivity/ConnectionQuality.js"),
                        Xd = [{
                            width: 1920,
                            height: 1080,
                            layers: 3,
                            target: "high",
                            targetRN: 4e6
                        }, {
                            width: 1280,
                            height: 720,
                            layers: 3,
                            target: "high",
                            targetRN: 25e5
                        }, {
                            width: 960,
                            height: 540,
                            layers: 3,
                            target: "standard",
                            targetRN: 9e5
                        }, {
                            width: 640,
                            height: 360,
                            layers: 2,
                            target: "standard",
                            targetRN: 5e5
                        }, {
                            width: 480,
                            height: 270,
                            layers: 2,
                            target: "low",
                            targetRN: 35e4
                        }, {
                            width: 320,
                            height: 180,
                            layers: 1,
                            target: "low",
                            targetRN: 15e4
                        }];
                    let zd = 800;
                    class Qd {
                        constructor(e, t, i) {
                            var n;
                            this.eventEmitter = t, this._conference = e, this._localStats = {
                                connectionQuality: 100,
                                jvbRTT: void 0
                            }, this._lastConnectionQualityUpdate = -1, this._options = i, this._remoteStats = {}, this._timeIceConnected = -1, this._timeVideoUnmuted = -1, (null === (n = this._options.config) || void 0 === n ? void 0 : n.startBitrate) > 0 && (zd = this._options.config.startBitrate), e.on(te, (() => {
                                this._updateLocalConnectionQuality(0), this.eventEmitter.emit(Bd, this._localStats), this._broadcastLocalStats()
                            })), e.room.addListener(qd.ICE_CONNECTION_STATE_CHANGED, ((e, t) => {
                                e.isP2P || "connected" !== t || (this._timeIceConnected = window.performance.now())
                            })), e.on(ce, ((e, t) => {
                                "stats" === t.type && this._updateRemoteStats(e.getId(), t.values)
                            })), e.on(de, ((e, t) => {
                                this._updateRemoteStats(e.getId(), t)
                            })), e.on(ce, ((e, t) => {
                                "face_landmark" === t.type && this.eventEmitter.emit(rt, e.getId(), t)
                            })), e.statistics.addConnectionStatsListener(this._updateLocalStats.bind(this)), e.on($e, (e => {
                                e.isVideoTrack() && (e.isMuted() ? this._timeVideoUnmuted = -1 : this._maybeUpdateUnmuteTime())
                            })), e.on(Ue, (e => {
                                e.isVideoTrack() && !e.isMuted() && this._maybeUpdateUnmuteTime()
                            })), e.rtc.on(Rn.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED, (e => {
                                this._localStats.maxEnabledResolution = e.maxEnabledResolution
                            })), e.on(ge, (e => {
                                this._localStats.serverRegion = e
                            })), e.on(De, (e => {
                                this._localStats.bridgeCount = Number((e || {})["bridge-count"])
                            }))
                        }
                        _maybeUpdateUnmuteTime() {
                            this._timeVideoUnmuted < 0 && (this._timeVideoUnmuted = window.performance.now())
                        }
                        _calculateConnectionQuality(e, t, i) {
                            const n = Gd[i];
                            let s, r = 100;
                            if (this._localStats.packetLoss && (s = this._localStats.packetLoss.upload, t && (s *= .5)), t || !n || e === Kd.DESKTOP || this._timeIceConnected < 0 || this._timeVideoUnmuted < 0) void 0 === s ? (Wd.error("Cannot calculate connection quality, unknown packet loss."), r = 100) : r = s <= 2 ? 100 : s <= 4 ? 70 : s <= 6 ? 50 : s <= 8 ? 30 : s <= 12 ? 10 : 0;
                            else {
                                const e = this._conference.getActivePeerConnection();
                                if (e) {
                                    var o, a;
                                    const t = e.isSimulcastOn(),
                                        i = e.getTargetVideoBitrates();
                                    i.codec = e.getConfiguredVideoCodec();
                                    const s = window.performance.now() - Math.max(this._timeVideoUnmuted, this._timeIceConnected),
                                        c = null !== (o = null === (a = this._options.config) || void 0 === a ? void 0 : a.pcStatsInterval) && void 0 !== o ? o : 1e4;
                                    let d = function(e, t, i, n) {
                                        let s = 0,
                                            r = Math.min(t.height, t.width),
                                            o = Xd.find((e => e.height <= r));
                                        if (o && e && n.codec === Pr().VP8)
                                            for (r = o.height; r >= 180; r /= 2) {
                                                const e = r;
                                                if (o = Xd.find((t => t.height === e)), !o) break;
                                                s += Ui.isReactNative() ? o.targetRN : n[o.target]
                                            } else o && (s = Ui.isReactNative() ? o.targetRN : n[o.target]);
                                        return Math.min(s / 1e3, function(e) {
                                            return e > 6e4 ? Number.MAX_SAFE_INTEGER : zd * Math.pow(1.08, e / 1e3)
                                        }(Math.max(0, i - 1e3)))
                                    }(t, n, s, i);
                                    d = Math.min(d, 2500), s > c && (r = 100 * this._localStats.bitrate.upload / d)
                                }
                                s && s >= 10 && (r = Math.min(r, 30))
                            }
                            if (this._lastConnectionQualityUpdate > 0) {
                                const e = 2,
                                    t = this._localStats.connectionQuality,
                                    i = (window.performance.now() - this._lastConnectionQualityUpdate) / 1e3;
                                r = Math.min(r, t + i * e)
                            }
                            return Math.min(100, r)
                        }
                        _updateLocalConnectionQuality(e) {
                            this._localStats.connectionQuality = e, this._lastConnectionQualityUpdate = window.performance.now()
                        }
                        _broadcastLocalStats() {
                            const e = {
                                bitrate: this._localStats.bitrate,
                                packetLoss: this._localStats.packetLoss,
                                connectionQuality: this._localStats.connectionQuality,
                                jvbRTT: this._localStats.jvbRTT,
                                serverRegion: this._localStats.serverRegion,
                                maxEnabledResolution: this._localStats.maxEnabledResolution,
                                avgAudioLevels: this._localStats.localAvgAudioLevels
                            };
                            try {
                                this._conference.sendEndpointStatsMessage(e)
                            } catch (e) {}
                        }
                        _updateLocalStats(e, t) {
                            if (!e.isP2P) {
                                const e = t.transport && t.transport.length && t.transport[0].rtt;
                                this._localStats.jvbRTT = e || void 0
                            }
                            if (e !== this._conference.getActivePeerConnection()) return;
                            let i;
                            const n = !this._conference.isConnectionInterrupted(),
                                s = this._conference.getLocalVideoTrack(),
                                r = s ? s.videoType : void 0,
                                o = !s || s.isMuted(),
                                a = s ? Math.min(s.resolution, s.maxEnabledResolution) : null;
                            for (i in o || this._maybeUpdateUnmuteTime(), t) t.hasOwnProperty(i) && (this._localStats[i] = t[i]);
                            n && this._updateLocalConnectionQuality(this._calculateConnectionQuality(r, o, a)), this.eventEmitter.emit(Bd, this._localStats), this._broadcastLocalStats()
                        }
                        _updateRemoteStats(e, t) {
                            this._remoteStats[e] = {
                                bitrate: t.bitrate,
                                packetLoss: t.packetLoss,
                                connectionQuality: t.connectionQuality,
                                jvbRTT: t.jvbRTT,
                                serverRegion: t.serverRegion,
                                maxEnabledResolution: t.maxEnabledResolution,
                                avgAudioLevels: t.avgAudioLevels
                            }, this.eventEmitter.emit(Jd, e, this._remoteStats[e])
                        }
                        getStats() {
                            return this._localStats
                        }
                    }
                    const Yd = (0, v.getLogger)("modules/connectivity/IceFailedHandling.js");
                    class Zd {
                        constructor(e) {
                            this._conference = e
                        }
                        _actOnIceFailed() {
                            if (!this._conference.room) return;
                            const {
                                enableForcedReload: e,
                                enableIceRestart: t
                            } = this._conference.options.config, i = void 0 !== t && !t, n = this._conference.room.supportsRestartByTerminate(), s = n && !t;
                            if (Yd.info(`ICE failed, enableForcedReload: ${e}, enableIceRestart: ${t}, supports restart by terminate: ${n}`), i || !t && !n || e) {
                                Yd.info("ICE failed, but ICE restarts are disabled");
                                const t = e ? I : k;
                                return void this._conference.eventEmitter.emit(X, t)
                            }
                            const r = this._conference.jvbJingleSession,
                                o = r && r.getIceConnectionState();
                            r ? "connected" === o ? Yd.info("ICE connection restored - not sending ICE failed") : (Yd.info(`Sending ICE failed - the connection did not recover, ICE state: ${o}, use 'session-terminate': ${s}`), s ? this._conference.jvbJingleSession.terminate((() => {
                                Yd.info("session-terminate for ice restart - done")
                            }), (e => {
                                Yd.error(`session-terminate for ice restart - error: ${e.message}`)
                            }), {
                                reason: "connectivity-error",
                                reasonDescription: "ICE FAILED",
                                requestRestart: !0,
                                sendSessionTerminate: !0
                            }) : this._conference.jvbJingleSession.sendIceFailedNotification()) : Yd.warn("Not sending ICE failed - no JVB connection")
                        }
                        start() {
                            this._conference.xmpp.ping(65e3).then((() => {
                                this._canceled || (this._iceFailedTimeout = window.setTimeout((() => {
                                    this._iceFailedTimeout = void 0, this._actOnIceFailed()
                                }), 2e3))
                            }), (e => {
                                Yd.error("PING error/timeout - not sending ICE failed", e)
                            }))
                        }
                        cancel() {
                            this._canceled = !0, window.clearTimeout(this._iceFailedTimeout)
                        }
                    }
                    let el;
                    ! function(e) {
                        e.DETECTOR_STATE_CHANGE = "detector_state_change", e.AUDIO_INPUT_STATE_CHANGE = "audio_input_state_changed", e.NO_AUDIO_INPUT = "no_audio_input_detected", e.VAD_NOISY_DEVICE = "detection.vad_noise_device", e.VAD_REPORT_PUBLISHED = "vad-report-published", e.VAD_SCORE_PUBLISHED = "detection.vad_score_published", e.VAD_TALK_WHILE_MUTED = "detection.vad_talk_while_muted"
                    }(el || (el = {}));
                    const tl = el.DETECTOR_STATE_CHANGE,
                        il = el.AUDIO_INPUT_STATE_CHANGE,
                        nl = el.NO_AUDIO_INPUT,
                        sl = el.VAD_NOISY_DEVICE,
                        rl = el.VAD_REPORT_PUBLISHED,
                        ol = el.VAD_SCORE_PUBLISHED,
                        al = el.VAD_TALK_WHILE_MUTED;
                    class cl extends(dt()) {
                        constructor(e) {
                            super(), this._conference = e, this._timeoutTrigger = null, this._hasAudioInput = null, Ui.supportsReceiverStats() || e.statistics.addAudioLevelListener(this._audioLevel.bind(this)), e.on(Ue, this._trackAdded.bind(this))
                        }
                        _clearTriggerTimeout() {
                            clearTimeout(this._timeoutTrigger), this._timeoutTrigger = null
                        }
                        _handleAudioInputStateChange(e) {
                            const t = 0 !== e;
                            null !== this._hasAudioInput && this._hasAudioInput === t || (this._hasAudioInput = t, this.emit(il, this._hasAudioInput))
                        }
                        _handleNoAudioInputDetection(e) {
                            this._eventFired || (0 !== e || this._timeoutTrigger ? 0 !== e && this._timeoutTrigger && this._clearTriggerTimeout() : this._timeoutTrigger = setTimeout((() => {
                                this._eventFired = !0, this.emit(nl)
                            }), 4e3))
                        }
                        _audioLevel(e, t, i, n) {
                            if (!n || !this._audioTrack) return;
                            const s = e.localSSRCs.get(this._audioTrack.rtcId);
                            s && s.ssrcs.includes(t) && (this._handleAudioInputStateChange(i), this._handleNoAudioInputDetection(i))
                        }
                        _trackAdded(e) {
                            e.isLocalAudioTrack() && (this._audioTrack = e, this._eventFired = !1, this._clearTriggerTimeout(), Ui.supportsReceiverStats() && (e.on(Ft, (e => {
                                this._handleNoAudioInputDetection(e)
                            })), e.on(Ot, (e => {
                                this._handleNoAudioInputDetection(e), this._handleAudioInputStateChange(e)
                            }))))
                        }
                    }
                    class dl {
                        constructor(e) {
                            this.conference = e, e.addEventListener(je, this._audioLevel.bind(this)), this.myUserID = this.conference.myUserId()
                        }
                        _audioLevel(e, t) {
                            !this.conference.isP2PActive() || t <= .6 || e === this.myUserID && this.conference.getLocalAudioTrack().isMuted() || this.conference.rtc.eventEmitter.emit(Rn.default.DOMINANT_SPEAKER_CHANGED, e)
                        }
                    }

                    function ll(e) {
                        const t = window.AudioContext || window.webkitAudioContext;
                        if (t) return new t(e)
                    }
                    class hl extends(dt()) {
                        constructor(e, t, i) {
                            super(), this._procNodeSampleRate = e, this._vadProcessor = t, this._localTrack = i, this._bufferResidue = new Float32Array([]), this._audioContext = ll({
                                sampleRate: t.getRequiredPCMFrequency()
                            }), this._vadSampleSize = t.getSampleLength(), this._onAudioProcess = this._onAudioProcess.bind(this), this._initializeAudioContext()
                        }
                        static create(e, t, i) {
                            return Hd.obtainAudioAndVideoPermissions({
                                devices: ["audio"],
                                micDeviceId: e
                            }).then((n => {
                                if (!n[0]) throw new Error(`Failed to create jitsi local track for device id: ${e}`);
                                return new hl(t, i, n[0])
                            }))
                        }
                        _initializeAudioContext() {
                            this._audioSource = this._audioContext.createMediaStreamSource(this._localTrack.stream), this._audioProcessingNode = this._audioContext.createScriptProcessor(this._procNodeSampleRate, 1, 1)
                        }
                        _onAudioProcess(e) {
                            const t = e.inputBuffer.getChannelData(0),
                                i = [...this._bufferResidue, ...t],
                                n = Date.now();
                            let s = 0;
                            for (; s + this._vadSampleSize < i.length; s += this._vadSampleSize) {
                                const e = i.slice(s, s + this._vadSampleSize),
                                    t = this._vadProcessor.calculateAudioFrameVAD(e.slice());
                                this.emit(ol, {
                                    timestamp: n,
                                    score: t,
                                    pcmData: e,
                                    deviceId: this._localTrack.getDeviceId()
                                })
                            }
                            this._bufferResidue = i.slice(s, i.length)
                        }
                        _connectAudioGraph() {
                            this._audioProcessingNode.onaudioprocess = this._onAudioProcess, this._audioSource.connect(this._audioProcessingNode), this._audioProcessingNode.connect(this._audioContext.destination)
                        }
                        _disconnectAudioGraph() {
                            this._audioProcessingNode.onaudioprocess = () => {}, this._audioProcessingNode.disconnect(), this._audioSource.disconnect()
                        }
                        _cleanupResources() {
                            this._disconnectAudioGraph(), this._localTrack.stopStream()
                        }
                        getDeviceId() {
                            return this._localTrack.getDeviceId()
                        }
                        getTrackLabel() {
                            return this._localTrack.getDeviceLabel()
                        }
                        start() {
                            this._connectAudioGraph()
                        }
                        stop() {
                            this._disconnectAudioGraph(), this._bufferResidue = []
                        }
                        destroy() {
                            this._destroyed || (this._cleanupResources(), this._destroyed = !0)
                        }
                    }
                    const ul = (0, v.getLogger)("modules/detection/VADAudioAnalyser.js");
                    class pl extends ct.EventEmitter {
                        constructor(e, t) {
                            super(), this._createVADProcessor = t, this._vadEmitter = null, this._isVADEmitterRunning = !1, this._detectionServices = [], this._vadInitTracker = Promise.resolve(), this._processVADScore = this._processVADScore.bind(this), e.on(Ue, this._trackAdded.bind(this)), e.on(He, this._trackRemoved.bind(this)), e.on($e, this._trackMuteChanged.bind(this))
                        }
                        addVADDetectionService(e) {
                            this._detectionServices.push(e), e.on(tl, (() => {
                                !this._detectionServices.filter((e => !0 === e.isActive())).length && this._isVADEmitterRunning ? this._stopVADEmitter() : this._isVADEmitterRunning || this._startVADEmitter()
                            }))
                        }
                        _startVADEmitter() {
                            this._vadEmitter && (this._vadEmitter.on(ol, this._processVADScore), this._vadEmitter.start(), this._isVADEmitterRunning = !0)
                        }
                        _stopVADEmitter() {
                            this._vadEmitter && (this._vadEmitter.removeListener(ol, this._processVADScore), this._vadEmitter.stop()), this._isVADEmitterRunning = !1
                        }
                        _processVADScore(e) {
                            for (const t of this._detectionServices) t.processVADScore(e)
                        }
                        _changeDetectorsMuteState(e) {
                            for (const t of this._detectionServices) t.changeMuteState(e)
                        }
                        _trackAdded(e) {
                            e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then((() => this._createVADProcessor())).then((t => hl.create(e.getDeviceId(), 4096, t))).then((t => {
                                ul.debug("Created VAD emitter for track: ", e.getTrackLabel()), this._vadEmitter = t, this._changeDetectorsMuteState(e.isMuted())
                            })).catch((e => {
                                ul.warn("Failed to start VADAudioAnalyser", e)
                            })))
                        }
                        _trackMuteChanged(e) {
                            e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then((() => {
                                this._changeDetectorsMuteState(e.isMuted())
                            })))
                        }
                        _trackRemoved(e) {
                            e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then((() => {
                                ul.debug("Removing track from VAD detection - ", e.getTrackLabel()), this._vadEmitter && (this._stopVADEmitter(), this._vadEmitter.destroy(), this._vadEmitter = null);
                                for (const e of this._detectionServices) e.reset()
                            })))
                        }
                    }
                    class ml extends ct.EventEmitter {
                        constructor() {
                            super(), this._processing = !1, this._scoreArray = [], this._audioLvlArray = [], this._active = !1, this._calculateNoisyScore = this._calculateNoisyScore.bind(this)
                        }
                        _calculateNoisyScore() {
                            const e = sn(this._scoreArray),
                                t = sn(this._audioLvlArray);
                            e < .2 && t > .04 && (this.emit(sl), this._setActiveState(!1)), this.reset()
                        }
                        _recordValues(e, t) {
                            this._scoreArray.push(e), this._audioLvlArray.push(t)
                        }
                        _setActiveState(e) {
                            this._active = e, this.emit(tl, this._active)
                        }
                        changeMuteState(e) {
                            this._setActiveState(!e), this.reset()
                        }
                        isActive() {
                            return this._active
                        }
                        reset() {
                            this._processing = !1, this._scoreArray = [], this._audioLvlArray = [], clearTimeout(this._processTimeout)
                        }
                        processVADScore(e) {
                            if (this._active)
                                if (this._processing) {
                                    const t = rn(e.pcmData);
                                    this._recordValues(e.score, sn(t))
                                } else if (e.score < .2) {
                                const t = sn(rn(e.pcmData));
                                t > .02 && (this._processing = !0, this._recordValues(e.score, t), this._processTimeout = setTimeout(this._calculateNoisyScore, 1500))
                            }
                        }
                    }
                    class fl extends ct.EventEmitter {
                        constructor() {
                            super(), this._processing = !1, this._scoreArray = [], this._active = !1, this._calculateVADScore = this._calculateVADScore.bind(this)
                        }
                        _calculateVADScore() {
                            sn(this._scoreArray) > .6 && (this.emit(al), this._setActiveState(!1)), this.reset()
                        }
                        _setActiveState(e) {
                            this._active = e, this.emit(tl, this._active)
                        }
                        changeMuteState(e) {
                            this._setActiveState(e), this.reset()
                        }
                        isActive() {
                            return this._active
                        }
                        processVADScore(e) {
                            this._active && (this._processing ? this._scoreArray.push(e.score) : e.score > .9 && (this._processing = !0, this._scoreArray.push(e.score), this._processTimeout = setTimeout(this._calculateVADScore, 700)))
                        }
                        reset() {
                            this._processing = !1, this._scoreArray = [], clearTimeout(this._processTimeout)
                        }
                    }
                    let gl;
                    ! function(e) {
                        e.E2E_RTT_CHANGED = "e2eping.e2e_rtt_changed"
                    }(gl || (gl = {}));
                    const _l = gl.E2E_RTT_CHANGED,
                        Sl = (0, v.getLogger)("modules/e2eping/e2eping.js"),
                        vl = "e2e-ping-request",
                        El = "e2e-ping-response";
                    class yl {
                        constructor(e, t) {
                            this.participant = e, this.e2eping = t, this.id = e.getId(), this.requests = {}, this.lastRequestId = 1, this.sendRequest = this.sendRequest.bind(this), this.handleResponse = this.handleResponse.bind(this), this.maybeLogRttAndStop = this.maybeLogRttAndStop.bind(this), this.scheduleNext = this.scheduleNext.bind(this), this.stop = this.stop.bind(this), this.getDelay = this.getDelay.bind(this), this.timeout = this.scheduleNext()
                        }
                        scheduleNext() {
                            return window.setTimeout(this.sendRequest, this.getDelay())
                        }
                        stop() {
                            this.timeout && window.clearTimeout(this.timeout), this.e2eping.removeParticipant(this.id)
                        }
                        getDelay() {
                            const e = this.e2eping.conference.getParticipants().length,
                                t = e * (e - 1) / 2 * this.e2eping.numRequests / this.e2eping.maxMessagesPerSecond;
                            return (1.5 - Math.random()) * Math.max(t / this.e2eping.numRequests * 1e3, 1e3)
                        }
                        sendRequest() {
                            const e = this.lastRequestId++,
                                t = {
                                    type: vl,
                                    id: e
                                };
                            this.e2eping.sendMessage(t, this.id), this.requests[e] = {
                                id: e,
                                timeSent: window.performance.now()
                            }
                        }
                        handleResponse(e) {
                            const t = this.requests[e.id];
                            t && (t.rtt = window.performance.now() - t.timeSent), this.maybeLogRttAndStop()
                        }
                        maybeLogRttAndStop() {
                            let e, t, i = 1 / 0,
                                n = 0,
                                s = 0;
                            for (t in this.requests) this.requests.hasOwnProperty(t) && (e = this.requests[t], s++, e.rtt && (n++, i = Math.min(i, e.rtt)));
                            return n >= this.e2eping.numRequests ? (Sl.info(`Measured RTT=${i} ms to ${this.id} (in ${this.participant.getProperty("region")})`), this.stop(), void this.e2eping.conference.eventEmitter.emit(_l, this.participant, i)) : s > 2 * this.e2eping.numRequests ? (Sl.info(`Stopping e2eping for ${this.id} because we sent ${s} with only ${n} responses.`), void this.stop()) : void(this.timeout = this.scheduleNext())
                        }
                    }
                    class Tl {
                        constructor(e, t, i) {
                            this.conference = e, this.eventEmitter = e.eventEmitter, this.sendMessage = i, this.participants = {}, this.numRequests = 5, this.maxConferenceSize = 200, this.maxMessagesPerSecond = 250, t && t.e2eping && ("number" == typeof t.e2eping.numRequests && (this.numRequests = t.e2eping.numRequests), "number" == typeof t.e2eping.maxConferenceSize && (this.maxConferenceSize = t.e2eping.maxConferenceSize), "number" == typeof t.e2eping.maxMessagesPerSecond && (this.maxMessagesPerSecond = t.e2eping.maxMessagesPerSecond)), Sl.info(`Initializing e2e ping with numRequests=${this.numRequests}, maxConferenceSize=${this.maxConferenceSize}, maxMessagesPerSecond=${this.maxMessagesPerSecond}.`), this.participantJoined = this.participantJoined.bind(this), this.participantLeft = this.participantLeft.bind(this), e.on(Ke, this.participantLeft), this.messageReceived = this.messageReceived.bind(this), e.on(ce, this.messageReceived), this.conferenceJoined = this.conferenceJoined.bind(this), e.on(Q, this.conferenceJoined)
                        }
                        conferenceJoined() {
                            this.conference.getParticipants().forEach((e => this.participantJoined(e.getId(), e))), this.conference.on(Ge, this.participantJoined)
                        }
                        messageReceived(e, t) {
                            t.type === vl ? this.handleRequest(e.getId(), t) : t.type === El && this.handleResponse(e.getId(), t)
                        }
                        participantJoined(e, t) {
                            this.participants[e] && (Sl.info(`Participant wrapper already exists for ${e}. Clearing.`), this.participants[e].stop()), this.conference.getParticipants().length > this.maxConferenceSize || this.conference.myUserId() > e && (Sl.info(`Starting e2eping for participant ${e}`), this.participants[e] = new yl(t, this))
                        }
                        removeParticipant(e) {
                            this.participants[e] && delete this.participants[e]
                        }
                        participantLeft(e) {
                            this.participants[e] && (this.participants[e].stop(), delete this.participants[e])
                        }
                        handleRequest(e, t) {
                            if (t && t.id) {
                                const i = {
                                    type: El,
                                    id: t.id
                                };
                                this.sendMessage(i, e)
                            } else Sl.info(`Received an invalid e2e ping request from ${e}.`)
                        }
                        handleResponse(e, t) {
                            const i = this.participants[e];
                            i && i.handleResponse(t)
                        }
                        stop() {
                            Sl.info("Stopping e2eping"), this.conference.off(Ge, this.participantJoined), this.conference.off(Ke, this.participantLeft), this.conference.off(ce, this.messageReceived);
                            for (const e in this.participants) this.participants.hasOwnProperty(e) && this.participants[e].stop();
                            this.participants = {}
                        }
                    }
                    const Cl = (0, v.getLogger)("modules/event/Jvb121EventGenerator.js");
                    class bl {
                        constructor(e) {
                            this._conference = e, this._jvb121 = !0, this._conference.addEventListener(Ge, (() => this.evaluateStatus())), this._conference.addEventListener(Ke, (() => this.evaluateStatus())), this._conference.addEventListener(Ie, (() => this.evaluateStatus()))
                        }
                        evaluateStatus() {
                            const e = this._jvb121,
                                t = !this._conference.isP2PActive() && this._conference.getParticipantCount() <= 2;
                            e !== t && (this._jvb121 = t, Cl.debug(`JVB121 status ${e} => ${t}`), this._conference.eventEmitter.emit(le, e, t))
                        }
                    }
                    const Rl = (0, v.getLogger)("modules/qualitycontrol/ReceiveVideoController.js");
                    class Al {
                        constructor() {
                            this._defaultConstraints = {
                                maxHeight: 180
                            }, this._lastN = -1, this._maxFrameHeight = 2160, this._selectedEndpoints = [], this._receiverVideoConstraints = {
                                constraints: {},
                                defaultConstraints: this.defaultConstraints,
                                lastN: this._lastN,
                                onStageEndpoints: [],
                                selectedEndpoints: this._selectedEndpoints
                            }
                        }
                        get constraints() {
                            return this._receiverVideoConstraints.lastN = this._lastN, this._selectedEndpoints.length ? (this._receiverVideoConstraints.constraints = {}, this._selectedEndpoints.length > 1 ? (this._receiverVideoConstraints.defaultConstraints = {
                                maxHeight: this._maxFrameHeight
                            }, this._receiverVideoConstraints.onStageEndpoints = [], this._receiverVideoConstraints.selectedEndpoints = []) : (this._receiverVideoConstraints.constraints[this._selectedEndpoints[0]] = {
                                maxHeight: this._maxFrameHeight
                            }, this._receiverVideoConstraints.defaultConstraints = this._defaultConstraints, this._receiverVideoConstraints.onStageEndpoints = this._selectedEndpoints, this._receiverVideoConstraints.selectedEndpoints = []), this._receiverVideoConstraints) : this._receiverVideoConstraints
                        }
                        updateLastN(e) {
                            const t = this._lastN !== e;
                            return t && (this._lastN = e, Rl.debug(`Updating ReceiverVideoConstraints lastN(${e})`)), t
                        }
                        updateReceiveResolution(e) {
                            const t = this._maxFrameHeight !== e;
                            return t && (this._maxFrameHeight = e, Rl.debug(`Updating receive maxFrameHeight: ${e}`)), t
                        }
                        updateReceiverVideoConstraints(e) {
                            const t = !ht()(this._receiverVideoConstraints, e);
                            return t && (this._receiverVideoConstraints = e, Rl.debug(`Updating ReceiverVideoConstraints ${JSON.stringify(e)}`)), t
                        }
                        updateSelectedEndpoints(e) {
                            Rl.debug(`Updating selected endpoints: ${JSON.stringify(e)}`), this._selectedEndpoints = e
                        }
                    }
                    class Pl {
                        constructor(e, t) {
                            var i, n;
                            this._conference = e, this._rtc = t;
                            const {
                                config: s
                            } = e.options;
                            this._lastN = null !== (i = null == s ? void 0 : s.startLastN) && void 0 !== i ? i : (null == s ? void 0 : s.channelLastN) || -1, this._maxFrameHeight = 2160, this._sourceReceiverConstraints = new Map, null === (n = null == s ? void 0 : s.useNewBandwidthAllocationStrategy) || void 0 === n || n ? (this._receiverVideoConstraints = new Al, this._receiverVideoConstraints.updateLastN(this._lastN) && this._rtc.setNewReceiverVideoConstraints(this._receiverVideoConstraints.constraints)) : this._rtc.setLastN(this._lastN), this._selectedEndpoints = [], this._conference.on(_e, (e => this._onMediaSessionStarted(e)))
                        }
                        _getDefaultSourceReceiverConstraints(e, t) {
                            var i;
                            if (!hn.isSourceNameSignalingEnabled()) return null;
                            const n = (null === (i = e.peerconnection) || void 0 === i ? void 0 : i.getRemoteTracks(null, dn.VIDEO)) || [],
                                s = new Map;
                            for (const e of n) s.set(e.getSourceName(), t);
                            return s
                        }
                        _onMediaSessionStarted(e) {
                            e.isP2P || !this._receiverVideoConstraints ? e.setReceiverVideoConstraint(this._maxFrameHeight, this._sourceReceiverConstraints) : (this._receiverVideoConstraints.updateReceiveResolution(this._maxFrameHeight), this._rtc.setNewReceiverVideoConstraints(this._receiverVideoConstraints.constraints))
                        }
                        getLastN() {
                            return this._lastN
                        }
                        selectEndpoints(e) {
                            if (this._selectedEndpoints = e, this._receiverVideoConstraints) {
                                const t = e.filter((e => e !== this._conference.myUserId())),
                                    i = JSON.parse(JSON.stringify(this._receiverVideoConstraints.constraints));
                                t.length && this._receiverVideoConstraints.updateSelectedEndpoints(t);
                                const n = this._receiverVideoConstraints.constraints;
                                ht()(n, i) || this._rtc.setNewReceiverVideoConstraints(n)
                            } else this._rtc.selectEndpoints(e)
                        }
                        setLastN(e) {
                            if (this._lastN !== e) {
                                if (this._lastN = e, this._receiverVideoConstraints) return void(this._receiverVideoConstraints.updateLastN(e) && this._rtc.setNewReceiverVideoConstraints(this._receiverVideoConstraints.constraints));
                                this._rtc.setLastN(e)
                            }
                        }
                        setPreferredReceiveMaxFrameHeight(e) {
                            this._maxFrameHeight = e;
                            for (const t of this._conference.getMediaSessions()) t.isP2P || !this._receiverVideoConstraints ? t.setReceiverVideoConstraint(e, this._getDefaultSourceReceiverConstraints(this._maxFrameHeight)) : this._receiverVideoConstraints.updateReceiveResolution(e) && this._rtc.setNewReceiverVideoConstraints(this._receiverVideoConstraints.constraints)
                        }
                        setReceiverConstraints(e) {
                            this._receiverVideoConstraints || (this._receiverVideoConstraints = new Al);
                            const t = Object.keys(e).includes("onStageEndpoints", "selectedEndpoints"),
                                i = Object.keys(e).includes("onStageSources", "selectedSources");
                            if (!hn.isSourceNameSignalingEnabled() && i) throw new Error('"onStageSources" and "selectedSources" are not supported when sourceNameSignaling is disabled.');
                            if (hn.isSourceNameSignalingEnabled() && t) throw new Error('"onStageEndpoints" and "selectedEndpoints" are not supported when sourceNameSignaling is enabled.');
                            if (this._receiverVideoConstraints.updateReceiverVideoConstraints(e)) {
                                var n, s;
                                this._lastN = null !== (n = e.lastN) && void 0 !== n ? n : this._lastN, this._selectedEndpoints = null !== (s = e.selectedEndpoints) && void 0 !== s ? s : this._selectedEndpoints, this._rtc.setNewReceiverVideoConstraints(e);
                                const t = this._conference.getMediaSessions().find((e => e.isP2P));
                                if (!t) return;
                                if (hn.isSourceNameSignalingEnabled()) {
                                    const i = Array.from(Object.entries(e.constraints)).map((e => (e[1] = e[1].maxHeight, e)));
                                    this._sourceReceiverConstraints = new Map(i), t.setReceiverVideoConstraint(null, this._sourceReceiverConstraints)
                                } else {
                                    var r;
                                    let i = null === (r = Object.values(e.constraints)[0]) || void 0 === r ? void 0 : r.maxHeight;
                                    var o;
                                    i || (i = null === (o = e.defaultConstraints) || void 0 === o ? void 0 : o.maxHeight), i && t.setReceiverVideoConstraint(i)
                                }
                            }
                        }
                    }
                    const Il = (0, v.getLogger)("modules/qualitycontrol/SendVideoController.js");
                    class Nl {
                        constructor(e, t) {
                            this._conference = e, this._preferredSendMaxFrameHeight = 2160, this._rtc = t, this._sourceSenderConstraints = new Map, this._conference.on(_e, (e => this._onMediaSessionStarted(e))), this._conference.on(Se, (() => this._configureConstraintsForLocalSources())), this._rtc.on(Rn.default.SENDER_VIDEO_CONSTRAINTS_CHANGED, (e => this._onSenderConstraintsReceived(e)))
                        }
                        _configureConstraintsForLocalSources() {
                            if (hn.isSourceNameSignalingEnabled())
                                for (const e of this._rtc.getLocalVideoTracks()) {
                                    const t = e.getSourceName();
                                    t && this._propagateSendMaxFrameHeight(t)
                                } else this._propagateSendMaxFrameHeight()
                        }
                        _onMediaSessionStarted(e) {
                            hn.isSourceNameSignalingEnabled() ? e.addListener(Fo.REMOTE_SOURCE_CONSTRAINTS_CHANGED, ((e, t) => {
                                e === this._conference.getActiveMediaSession() && t.forEach((e => this._onSenderConstraintsReceived(e)))
                            })) : e.addListener(Fo.REMOTE_VIDEO_CONSTRAINTS_CHANGED, (e => e === this._conference.getActiveMediaSession() && this._configureConstraintsForLocalSources()))
                        }
                        _onSenderConstraintsReceived(e) {
                            var t;
                            if (hn.isSourceNameSignalingEnabled()) {
                                var i;
                                const {
                                    maxHeight: t,
                                    sourceName: n
                                } = e, s = null !== (i = this._conference.getLocalVideoTracks()) && void 0 !== i ? i : [];
                                for (const e of s) e.getSourceName() !== n || this._sourceSenderConstraints.has(n) && this._sourceSenderConstraints.get(n) === t || (this._sourceSenderConstraints.set(n, t), Il.debug(`Sender constraints for source:${n} changed to maxHeight:${t}`), this._propagateSendMaxFrameHeight(n))
                            } else(null === (t = this._senderVideoConstraints) || void 0 === t ? void 0 : t.idealHeight) !== e.idealHeight && (this._senderVideoConstraints = e, this._propagateSendMaxFrameHeight())
                        }
                        _propagateSendMaxFrameHeight() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                            if (hn.isSourceNameSignalingEnabled() && !e) throw new Error("sourceName missing for calculating the sendMaxHeight for video tracks");
                            const t = this._selectSendMaxFrameHeight(e),
                                i = [];
                            if (t >= 0)
                                for (const n of this._conference.getMediaSessions()) i.push(n.setSenderVideoConstraint(t, e));
                            return Promise.all(i)
                        }
                        _selectSendMaxFrameHeight() {
                            var e;
                            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                            if (hn.isSourceNameSignalingEnabled() && !t) throw new Error("sourceName missing for calculating the sendMaxHeight for video tracks");
                            const i = this._conference.getActiveMediaSession(),
                                n = i ? i.isP2P ? t ? this._sourceSenderConstraints.get(t) : i.getRemoteRecvMaxFrameHeight() : t ? this._sourceSenderConstraints.get(t) : null === (e = this._senderVideoConstraints) || void 0 === e ? void 0 : e.idealHeight : void 0;
                            return this._preferredSendMaxFrameHeight >= 0 && n >= 0 ? Math.min(this._preferredSendMaxFrameHeight, n) : n >= 0 ? n : this._preferredSendMaxFrameHeight
                        }
                        setPreferredSendMaxFrameHeight(e) {
                            if (this._preferredSendMaxFrameHeight = e, hn.isSourceNameSignalingEnabled()) {
                                const e = [];
                                for (const t of this._sourceSenderConstraints.keys()) e.push(this._propagateSendMaxFrameHeight(t));
                                return Promise.allSettled(e)
                            }
                            return this._propagateSendMaxFrameHeight()
                        }
                    }
                    const Dl = {
                        getFocusRecordingUpdate(e) {
                            const t = e && e.getElementsByTagName("jibri-recording-status")[0];
                            if (t) return {
                                error: t.getAttribute("failure_reason"),
                                initiator: t.getAttribute("initiator"),
                                recordingMode: t.getAttribute("recording_mode"),
                                sessionID: t.getAttribute("session_id"),
                                status: t.getAttribute("status")
                            }
                        },
                        getHiddenDomainUpdate(e) {
                            const t = e.getElementsByTagName("live-stream-view-url")[0],
                                i = t && t.textContent,
                                n = e.getElementsByTagName("mode")[0],
                                s = n && n.textContent && n.textContent.toLowerCase(),
                                r = e.getElementsByTagName("session_id")[0];
                            return {
                                liveStreamViewURL: i,
                                mode: s,
                                sessionID: r && r.textContent
                            }
                        },
                        getSessionIdFromIq(e) {
                            const t = e && e.getElementsByTagName("jibri")[0];
                            return t && t.getAttribute("session_id")
                        },
                        getSessionId(e) {
                            const t = e.getElementsByTagName("session_id")[0];
                            return t && t.textContent
                        },
                        isFromFocus: e => e.getAttribute("from").includes("focus")
                    };
                    class Ml {
                        constructor() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            this._connection = e.connection, this._mode = e.mode, this._setSessionID(e.sessionID), this.setStatus(e.status)
                        }
                        getError() {
                            return this._error
                        }
                        getID() {
                            return this._sessionID
                        }
                        getInitiator() {
                            return this._initiator
                        }
                        getLiveStreamViewURL() {
                            return this._liveStreamViewURL
                        }
                        getStatus() {
                            return this._status
                        }
                        getTerminator() {
                            return this._terminator
                        }
                        getMode() {
                            return this._mode
                        }
                        setError(e) {
                            this._error = e
                        }
                        setLiveStreamViewURL(e) {
                            this._liveStreamViewURL = e
                        }
                        setStatus(e) {
                            this._status = e
                        }
                        setInitiator(e) {
                            this._initiator = e
                        }
                        setTerminator(e) {
                            this._terminator = e
                        }
                        start(e) {
                            let {
                                appData: t,
                                broadcastId: i,
                                focusMucJid: n,
                                streamId: s
                            } = e;
                            return new Promise(((e, r) => {
                                this._connection.sendIQ(this._createIQ({
                                    action: "start",
                                    appData: t,
                                    focusMucJid: n,
                                    broadcastId: i,
                                    streamId: s
                                }), (t => {
                                    this.setStatus("pending"), this._setSessionID(Dl.getSessionIdFromIq(t)), e()
                                }), (e => {
                                    this._setErrorFromIq(e), r(e)
                                }))
                            }))
                        }
                        stop(e) {
                            let {
                                focusMucJid: t
                            } = e;
                            return new Promise(((e, i) => {
                                this._connection.sendIQ(this._createIQ({
                                    action: "stop",
                                    focusMucJid: t
                                }), e, i)
                            }))
                        }
                        _createIQ(e) {
                            let {
                                action: t,
                                appData: i,
                                broadcastId: n,
                                focusMucJid: s,
                                streamId: r
                            } = e;
                            return (0, ut.$iq)({
                                to: s,
                                type: "set"
                            }).c("jibri", {
                                xmlns: "http://jitsi.org/protocol/jibri",
                                action: t,
                                app_data: i,
                                recording_mode: this._mode,
                                streamid: r,
                                you_tube_broadcast_id: n
                            }).up()
                        }
                        _setErrorFromIq(e) {
                            const t = e.getElementsByTagName("error")[0];
                            this.setError(t.children[0].tagName)
                        }
                        _setSessionID(e) {
                            this._sessionID = e
                        }
                    }
                    const Ol = (0, v.getLogger)("modules/recording/RecordingManager.js"),
                        wl = (0, v.getLogger)("modules/statistics/AudioOutputProblemDetector.js");
                    class Ll {
                        constructor(e) {
                            this._conference = e, this._localAudioLevelCache = {}, this._reportedParticipants = [], this._audioProblemCandidates = {}, this._numberOfRemoteAudioLevelsReceived = {}, this._onLocalAudioLevelsReport = this._onLocalAudioLevelsReport.bind(this), this._onRemoteAudioLevelReceived = this._onRemoteAudioLevelReceived.bind(this), this._clearUserData = this._clearUserData.bind(this), this._conference.on(Jd, this._onRemoteAudioLevelReceived), this._conference.statistics.addConnectionStatsListener(this._onLocalAudioLevelsReport), this._conference.on(Ke, this._clearUserData)
                        }
                        _onRemoteAudioLevelReceived(e, t) {
                            let {
                                avgAudioLevels: i
                            } = t;
                            const n = this._numberOfRemoteAudioLevelsReceived[e] + 1 || 0;
                            if (this._numberOfRemoteAudioLevelsReceived[e] = n, -1 !== this._reportedParticipants.indexOf(e) || e in this._audioProblemCandidates || i <= 0 || n < 3) return;
                            const s = this._conference.getParticipantById(e);
                            if (s && s.getTracksByMediaType(dn.AUDIO).length > 0 && s.isAudioMuted()) return;
                            const r = this._localAudioLevelCache[e];
                            Array.isArray(r) && !r.every((e => 0 === e)) || (this._audioProblemCandidates[e] = {
                                remoteAudioLevels: i,
                                localAudioLevels: []
                            })
                        }
                        _onLocalAudioLevelsReport(e, t) {
                            let {
                                avgAudioLevels: i
                            } = t;
                            e === this._conference.getActivePeerConnection() && (Object.keys(i).forEach((e => {
                                if (-1 !== this._reportedParticipants.indexOf(e)) return;
                                const t = this._localAudioLevelCache[e];
                                Array.isArray(t) ? t.length >= 2 && t.shift() : this._localAudioLevelCache[e] = [], this._localAudioLevelCache[e].push(i[e])
                            })), Object.keys(this._audioProblemCandidates).forEach((e => {
                                const {
                                    localAudioLevels: t,
                                    remoteAudioLevels: n
                                } = this._audioProblemCandidates[e];
                                if (t.push(i[e]), 2 === t.length) {
                                    if (t.every((e => void 0 === e || 0 === e))) {
                                        const i = JSON.stringify(t);
                                        Tn.sendAnalytics(((e, t, i) => ({
                                            type: Ut.TYPE_OPERATIONAL,
                                            action: "audio.output.problem",
                                            attributes: {
                                                userID: e,
                                                localAudioLevels: t,
                                                remoteAudioLevels: i
                                            }
                                        }))(e, i, n)), wl.warn(`A potential problem is detected with the audio output for participant ${e}, local audio levels: ${i}, remote audio levels: ${n}`), this._reportedParticipants.push(e), this._clearUserData(e)
                                    }
                                    delete this._audioProblemCandidates[e]
                                }
                            })))
                        }
                        _clearUserData(e) {
                            delete this._localAudioLevelCache[e]
                        }
                        dispose() {
                            this._conference.off(Jd, this._onRemoteAudioLevelReceived), this._conference.off(Ke, this._clearUserData), this._conference.statistics.removeConnectionStatsListener(this._onLocalAudioLevelsReport), this._localAudioLevelCache = void 0, this._audioProblemCandidates = void 0, this._reportedParticipants = void 0, this._numberOfRemoteAudioLevelsReceived = void 0, this._conference = void 0
                        }
                    }
                    const kl = (0, v.getLogger)("modules/statistics/AvgRTPStatsReporter.js");
                    class xl {
                        constructor(e) {
                            this.name = e, this.count = 0, this.sum = 0, this.samples = []
                        }
                        addNext(e) {
                            "number" != typeof e ? kl.error(`${this.name} - invalid value for idx: ${this.count}`, e) : isNaN(e) || (this.sum += e, this.samples.push(e), this.count += 1)
                        }
                        calculate() {
                            return this.sum / this.count
                        }
                        appendReport(e) {
                            e[`${this.name}_avg`] = this.calculate(), e[`${this.name}_samples`] = JSON.stringify(this.samples)
                        }
                        reset() {
                            this.samples = [], this.sum = 0, this.count = 0
                        }
                    }
                    class Fl {
                        constructor(e, t, i) {
                            this.isP2P = t, this._n = i, this._sampleIdx = 0, this._avgRTT = new xl("rtt"), this._avgRemoteRTTMap = new Map, this._avgRtpStatsReporter = e, this._avgEnd2EndRTT = void 0, this._onConnectionStats = (e, t) => {
                                this.isP2P === e.isP2P && this._calculateAvgStats(t)
                            };
                            const n = e._conference;
                            n.statistics.addConnectionStatsListener(this._onConnectionStats), this.isP2P || (this._onUserLeft = e => this._avgRemoteRTTMap.delete(e), n.on(Ke, this._onUserLeft), this._onRemoteStatsUpdated = (e, t) => this._processRemoteStats(e, t), n.on(Jd, this._onRemoteStatsUpdated))
                        }
                        _calculateAvgStats(e) {
                            if (e) {
                                if (Ui.supportsRTTStatistics() && e.transport && e.transport.length && this._avgRTT.addNext(e.transport[0].rtt), this._sampleIdx += 1, this._sampleIdx >= this._n) {
                                    if (Ui.supportsRTTStatistics()) {
                                        const t = this._avgRtpStatsReporter._conference,
                                            i = {
                                                p2p: this.isP2P,
                                                conference_size: t.getParticipantCount()
                                            };
                                        if (e.transport && e.transport.length && Object.assign(i, {
                                                local_candidate_type: e.transport[0].localCandidateType,
                                                remote_candidate_type: e.transport[0].remoteCandidateType,
                                                transport_type: e.transport[0].type
                                            }), this._avgRTT.appendReport(i), this.isP2P) {
                                            const e = this._avgRtpStatsReporter.jvbStatsMonitor._avgEnd2EndRTT;
                                            isNaN(e) || (i.rtt_diff = this._avgRTT.calculate() - e)
                                        } else {
                                            const e = this._calculateAvgRemoteRTT(),
                                                t = this._avgRTT.calculate();
                                            this._avgEnd2EndRTT = t + e, isNaN(t) || isNaN(e) || (i.end2end_rtt_avg = this._avgEnd2EndRTT)
                                        }
                                        Tn.sendAnalytics(fi(i))
                                    }
                                    this._resetAvgStats()
                                }
                            } else kl.error("No stats")
                        }
                        _calculateAvgRemoteRTT() {
                            let e = 0,
                                t = 0;
                            for (const i of this._avgRemoteRTTMap.values()) {
                                const n = i.calculate();
                                isNaN(n) || (t += n, e += 1, i.reset())
                            }
                            return t / e
                        }
                        _processRemoteStats(e, t) {
                            const i = "number" == typeof t.jvbRTT;
                            let n = this._avgRemoteRTTMap.get(e);
                            !n && i && (n = new xl(`${e}_stat_rtt`), this._avgRemoteRTTMap.set(e, n)), i ? n.addNext(t.jvbRTT) : n && this._avgRemoteRTTMap.delete(e)
                        }
                        _resetAvgStats() {
                            this._avgRTT.reset(), this._avgRemoteRTTMap && this._avgRemoteRTTMap.clear(), this._sampleIdx = 0
                        }
                        dispose() {
                            const e = this._avgRtpStatsReporter._conference;
                            e.statistics.removeConnectionStatsListener(this._onConnectionStats), this.isP2P || (e.off(Jd, this._onRemoteStatsUpdated), e.off(Ke, this._onUserLeft))
                        }
                    }
                    class Vl {
                        constructor(e, t) {
                            this._n = t, t > 0 ? (kl.info(`Avg RTP stats will be calculated every ${t} samples`), this._sampleIdx = 0, this._conference = e, this._avgAudioBitrateUp = new xl("bitrate_audio_upload"), this._avgAudioBitrateDown = new xl("bitrate_audio_download"), this._avgVideoBitrateUp = new xl("bitrate_video_upload"), this._avgVideoBitrateDown = new xl("bitrate_video_download"), this._avgBandwidthUp = new xl("bandwidth_upload"), this._avgBandwidthDown = new xl("bandwidth_download"), this._avgPacketLossTotal = new xl("packet_loss_total"), this._avgPacketLossUp = new xl("packet_loss_upload"), this._avgPacketLossDown = new xl("packet_loss_download"), this._avgRemoteFPS = new xl("framerate_remote"), this._avgRemoteScreenFPS = new xl("framerate_screen_remote"), this._avgLocalFPS = new xl("framerate_local"), this._avgLocalScreenFPS = new xl("framerate_screen_local"), this._avgRemoteCameraPixels = new xl("pixels_remote"), this._avgRemoteScreenPixels = new xl("pixels_screen_remote"), this._avgLocalCameraPixels = new xl("pixels_local"), this._avgLocalScreenPixels = new xl("pixels_screen_local"), this._avgCQ = new xl("connection_quality"), this._cachedTransportStats = void 0, this._onLocalStatsUpdated = e => {
                                this._calculateAvgStats(e), this._maybeSendTransportAnalyticsEvent(e)
                            }, e.on(Bd, this._onLocalStatsUpdated), this._onP2PStatusChanged = () => {
                                kl.debug("Resetting average stats calculation"), this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats(), this.p2pStatsMonitor._resetAvgStats()
                            }, e.on(Ie, this._onP2PStatusChanged), this._onJvb121StatusChanged = (e, t) => {
                                !0 === t && (kl.info("Resetting JVB avg RTP stats"), this._resetAvgJvbStats())
                            }, e.on(le, this._onJvb121StatusChanged), this.jvbStatsMonitor = new Fl(this, !1, t), this.p2pStatsMonitor = new Fl(this, !0, t)) : kl.info("Avg RTP stats reports are disabled.")
                        }
                        _calculateAvgStats(e) {
                            if (!e) return void kl.error("No stats");
                            const t = this._conference.isP2PActive(),
                                i = this._conference.getParticipantCount();
                            if (!t && i < 2) return;
                            const n = e.bitrate,
                                s = e.bandwidth,
                                r = e.packetLoss,
                                o = e.framerate,
                                a = e.resolution;
                            if (n)
                                if (s)
                                    if (r)
                                        if (o)
                                            if (a) {
                                                if (this._avgAudioBitrateUp.addNext(n.audio.upload), this._avgAudioBitrateDown.addNext(n.audio.download), this._avgVideoBitrateUp.addNext(n.video.upload), this._avgVideoBitrateDown.addNext(n.video.download), Ui.supportsBandwidthStatistics() && (this._avgBandwidthUp.addNext(s.upload), this._avgBandwidthDown.addNext(s.download)), this._avgPacketLossUp.addNext(r.upload), this._avgPacketLossDown.addNext(r.download), this._avgPacketLossTotal.addNext(r.total), this._avgCQ.addNext(e.connectionQuality), o && (this._avgRemoteFPS.addNext(this._calculateAvgVideoFps(o, !1, An.VideoType.CAMERA)), this._avgRemoteScreenFPS.addNext(this._calculateAvgVideoFps(o, !1, An.VideoType.DESKTOP)), this._avgLocalFPS.addNext(this._calculateAvgVideoFps(o, !0, An.VideoType.CAMERA)), this._avgLocalScreenFPS.addNext(this._calculateAvgVideoFps(o, !0, An.VideoType.DESKTOP))), a && (this._avgRemoteCameraPixels.addNext(this._calculateAvgVideoPixels(a, !1, An.VideoType.CAMERA)), this._avgRemoteScreenPixels.addNext(this._calculateAvgVideoPixels(a, !1, An.VideoType.DESKTOP)), this._avgLocalCameraPixels.addNext(this._calculateAvgVideoPixels(a, !0, An.VideoType.CAMERA)), this._avgLocalScreenPixels.addNext(this._calculateAvgVideoPixels(a, !0, An.VideoType.DESKTOP))), this._sampleIdx += 1, this._sampleIdx >= this._n) {
                                                    const n = {
                                                        p2p: t,
                                                        conference_size: i
                                                    };
                                                    e.transport && e.transport.length && Object.assign(n, {
                                                        local_candidate_type: e.transport[0].localCandidateType,
                                                        remote_candidate_type: e.transport[0].remoteCandidateType,
                                                        transport_type: e.transport[0].type
                                                    }), this._avgAudioBitrateUp.appendReport(n), this._avgAudioBitrateDown.appendReport(n), this._avgVideoBitrateUp.appendReport(n), this._avgVideoBitrateDown.appendReport(n), Ui.supportsBandwidthStatistics() && (this._avgBandwidthUp.appendReport(n), this._avgBandwidthDown.appendReport(n)), this._avgPacketLossUp.appendReport(n), this._avgPacketLossDown.appendReport(n), this._avgPacketLossTotal.appendReport(n), this._avgRemoteFPS.appendReport(n), isNaN(this._avgRemoteScreenFPS.calculate()) || this._avgRemoteScreenFPS.appendReport(n), this._avgLocalFPS.appendReport(n), isNaN(this._avgLocalScreenFPS.calculate()) || this._avgLocalScreenFPS.appendReport(n), this._avgRemoteCameraPixels.appendReport(n), isNaN(this._avgRemoteScreenPixels.calculate()) || this._avgRemoteScreenPixels.appendReport(n), this._avgLocalCameraPixels.appendReport(n), isNaN(this._avgLocalScreenPixels.calculate()) || this._avgLocalScreenPixels.appendReport(n), this._avgCQ.appendReport(n), Tn.sendAnalytics(fi(n)), this._resetAvgStats()
                                                }
                                            } else kl.error("No resolution");
                            else kl.error('No "framerate"');
                            else kl.error('No "packetloss"');
                            else kl.error('No "bandwidth"');
                            else kl.error('No "bitrate"')
                        }
                        _calculateAvgVideoPixels(e, t, i) {
                            let n = 0,
                                s = 0;
                            const r = this._conference.myUserId();
                            for (const o of Object.keys(e))
                                if (t ? o === r : o !== r) {
                                    const r = t ? null : this._conference.getParticipantById(o),
                                        a = e[o];
                                    if ((t || r) && a) {
                                        const e = this._calculatePeerAvgVideoPixels(a, r, i);
                                        isNaN(e) || (n += e, s += 1)
                                    }
                                } return n / s
                        }
                        _calculatePeerAvgVideoPixels(e, t, i) {
                            let n = Object.keys(e).map((e => Number(e))),
                                s = null;
                            const r = this._conference.getActivePeerConnection();
                            t ? (s = t.getTracksByMediaType(dn.VIDEO), s && (n = n.filter((e => s.find((t => !t.isMuted() && t.getSSRC() === e && t.videoType === i)))))) : (s = this._conference.getLocalTracks(dn.VIDEO), n = n.filter((e => s.find((t => !t.isMuted() && r.getLocalSSRC(t) === e && t.videoType === i)))));
                            let o = 0,
                                a = 0;
                            for (const t of n) {
                                const i = Number(e[t].height) * Number(e[t].width);
                                !isNaN(i) && i > 0 && (o += i, a += 1)
                            }
                            return o / a
                        }
                        _calculateAvgVideoFps(e, t, i) {
                            let n = 0,
                                s = 0;
                            const r = this._conference.myUserId();
                            for (const o of Object.keys(e))
                                if (t ? o === r : o !== r) {
                                    const r = t ? null : this._conference.getParticipantById(o),
                                        a = e[o];
                                    if ((t || r) && a) {
                                        const e = this._calculatePeerAvgVideoFps(a, r, i);
                                        isNaN(e) || (n += e, s += 1)
                                    }
                                } return n / s
                        }
                        _calculatePeerAvgVideoFps(e, t, i) {
                            let n = Object.keys(e).map((e => Number(e))),
                                s = null;
                            const r = this._conference.getActivePeerConnection();
                            t ? (s = t.getTracksByMediaType(dn.VIDEO), s && (n = n.filter((e => s.find((t => !t.isMuted() && t.getSSRC() === e && t.videoType === i)))))) : (s = this._conference.getLocalTracks(dn.VIDEO), n = n.filter((e => s.find((t => !t.isMuted() && r.getLocalSSRC(t) === e && t.videoType === i)))));
                            let o = 0,
                                a = 0;
                            for (const t of n) {
                                const i = Number(e[t]);
                                !isNaN(i) && i > 0 && (o += i, a += 1)
                            }
                            return o / a
                        }
                        _maybeSendTransportAnalyticsEvent(e) {
                            if (!e || !e.transport || !e.transport.length) return;
                            const t = {
                                p2p: e.transport[0].p2p,
                                local_candidate_type: e.transport[0].localCandidateType,
                                remote_candidate_type: e.transport[0].remoteCandidateType,
                                transport_type: e.transport[0].type
                            };
                            var i;
                            this._cachedTransportStats && ht()(t, this._cachedTransportStats) || (this._cachedTransportStats = t, Tn.sendAnalytics((i = t, {
                                type: Ut.TYPE_OPERATIONAL,
                                action: "transport.stats",
                                attributes: i
                            })))
                        }
                        _resetAvgJvbStats() {
                            this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats()
                        }
                        _resetAvgStats() {
                            this._avgAudioBitrateUp.reset(), this._avgAudioBitrateDown.reset(), this._avgVideoBitrateUp.reset(), this._avgVideoBitrateDown.reset(), this._avgBandwidthUp.reset(), this._avgBandwidthDown.reset(), this._avgPacketLossUp.reset(), this._avgPacketLossDown.reset(), this._avgPacketLossTotal.reset(), this._avgRemoteFPS.reset(), this._avgRemoteScreenFPS.reset(), this._avgLocalFPS.reset(), this._avgLocalScreenFPS.reset(), this._avgRemoteCameraPixels.reset(), this._avgRemoteScreenPixels.reset(), this._avgLocalCameraPixels.reset(), this._avgLocalScreenPixels.reset(), this._avgCQ.reset(), this._sampleIdx = 0
                        }
                        dispose() {
                            this._conference.off(Ie, this._onP2PStatusChanged), this._conference.off(Bd, this._onLocalStatsUpdated), this._conference.off(le, this._onJvb121StatusChanged), this.jvbStatsMonitor.dispose(), this.p2pStatsMonitor.dispose()
                        }
                    }
                    var Ul = i(2444),
                        jl = i.n(Ul);
                    class $l {
                        constructor(e) {
                            this.stats = {
                                users: {},
                                dominantSpeakerId: null
                            };
                            const t = e.myUserId();
                            this.stats.users[t] = new(jl())(t, null, !0), this.conference = e, e.addEventListener(re, this._onDominantSpeaker.bind(this)), e.addEventListener(Ge, this._onUserJoin.bind(this)), e.addEventListener(Ke, this._onUserLeave.bind(this)), e.addEventListener(se, this._onDisplayNameChange.bind(this)), e.addEventListener(rt, this._onFaceLandmarkAdd.bind(this)), e.xmpp && e.xmpp.addListener(Nn.XMPPEvents.SPEAKER_STATS_RECEIVED, this._updateStats.bind(this))
                        }
                        _onDominantSpeaker(e) {
                            const t = this.stats.users[this.stats.dominantSpeakerId],
                                i = this.stats.users[e];
                            t && t.setDominantSpeaker(!1), i && i.setDominantSpeaker(!0), this.stats.dominantSpeakerId = e
                        }
                        _onUserJoin(e, t) {
                            t.isHidden() || this.stats.users[e] || (this.stats.users[e] = new(jl())(e, t.getDisplayName()))
                        }
                        _onUserLeave(e) {
                            const t = this.stats.users[e];
                            t && t.markAsHasLeft()
                        }
                        _onDisplayNameChange(e, t) {
                            const i = this.stats.users[e];
                            i && i.setDisplayName(t)
                        }
                        _onFaceLandmarkAdd(e, t) {
                            const i = this.stats.users[e];
                            i && t.faceExpression && i.addFaceExpression(t.faceExpression, t.duration)
                        }
                        getStats() {
                            return this.stats.users
                        }
                        _updateStats(e) {
                            for (const t in e) {
                                let i;
                                const n = this.conference.getParticipantById(t);
                                n && n.isHidden() || (this.stats.users[t] ? (i = this.stats.users[t], i.getDisplayName() || i.setDisplayName(e[t].displayName)) : (i = new(jl())(t, e[t].displayName), this.stats.users[t] = i, i.markAsHasLeft())), i.totalDominantSpeakerTime = e[t].totalDominantSpeakerTime, i.setFaceExpressions(e[t].faceExpressions)
                            }
                        }
                    }
                    class Hl {
                        constructor(e, t, i, n) {
                            this.blob = e, this.name = t, this.startTime = i, this.wordArray = n
                        }
                    }
                    class Bl {
                        constructor(e) {
                            this.track = e, this.recorder = null, this.data = null, this.name = null, this.startTime = null
                        }
                    }
                    const Jl = "audio/webm",
                        Gl = "audio/ogg";

                    function Kl(e) {
                        if (void 0 === e.recorder) throw new Error("Passed an object to startRecorder which is not a TrackRecorder object");
                        e.recorder.start(), e.startTime = new Date
                    }

                    function ql(e) {
                        if (void 0 === e.recorder) throw new Error("Passed an object to stopRecorder which is not a TrackRecorder object");
                        e.recorder.stop()
                    }

                    function Wl() {
                        if (MediaRecorder.isTypeSupported(Jl)) return Jl;
                        if (MediaRecorder.isTypeSupported(Gl)) return Gl;
                        throw new Error("unable to create a MediaRecorder with the right mimetype!")
                    }

                    function Xl(e) {
                        this.recorders = [], this.fileType = Wl(), this.isRecording = !1, this.jitsiConference = e
                    }
                    Xl.determineCorrectFileType = Wl, Xl.prototype.addTrack = function(e) {
                        if (e.isAudioTrack()) {
                            const t = this.instantiateTrackRecorder(e);
                            this.recorders.push(t), this.updateNames(), this.isRecording && Kl(t)
                        }
                    }, Xl.prototype.instantiateTrackRecorder = function(e) {
                        const t = new Bl(e),
                            i = t.track.getOriginalStream(),
                            n = new MediaStream;
                        return i.getAudioTracks().forEach((e => n.addTrack(e))), t.recorder = new MediaRecorder(n, {
                            mimeType: this.fileType
                        }), t.data = [], t.recorder.ondataavailable = function(e) {
                            e.data.size > 0 && t.data.push(e.data)
                        }, t
                    }, Xl.prototype.removeTrack = function(e) {
                        if (e.isVideoTrack()) return;
                        const t = this.recorders;
                        let i;
                        for (i = 0; i < t.length; i++)
                            if (t[i].track.getParticipantId() === e.getParticipantId()) {
                                const e = t[i];
                                this.isRecording ? ql(e) : t.splice(i, 1)
                            } this.updateNames()
                    }, Xl.prototype.updateNames = function() {
                        const e = this.jitsiConference;
                        this.recorders.forEach((t => {
                            if (t.track.isLocal()) t.name = "the transcriber";
                            else {
                                const i = t.track.getParticipantId(),
                                    n = e.getParticipantById(i).getDisplayName();
                                "undefined" !== n && (t.name = n)
                            }
                        }))
                    }, Xl.prototype.start = function() {
                        if (this.isRecording) throw new Error("audiorecorder is already recording");
                        this.isRecording = !0, this.recorders.forEach((e => Kl(e))), console.log(`Started the recording of the audio. There are currently ${this.recorders.length} recorders active.`)
                    }, Xl.prototype.stop = function() {
                        this.isRecording = !1, this.recorders.forEach((e => ql(e))), console.log("stopped recording")
                    }, Xl.prototype.download = function() {
                        this.recorders.forEach((e => {
                            const t = new Blob(e.data, {
                                    type: this.fileType
                                }),
                                i = URL.createObjectURL(t),
                                n = document.createElement("a");
                            document.body.appendChild(n), n.style = "display: none", n.href = i, n.download = `test.${this.fileType.split("/")[1]}`, n.click(), window.URL.revokeObjectURL(i)
                        }))
                    }, Xl.prototype.getRecordingResults = function() {
                        if (this.isRecording) throw new Error("cannot get blobs because the AudioRecorder is still recording!");
                        this.updateNames();
                        const e = [];
                        return this.recorders.forEach((t => e.push(new Hl(new Blob(t.data, {
                            type: this.fileType
                        }), t.name, t.startTime)))), e
                    }, Xl.prototype.getFileType = function() {
                        return this.fileType
                    };
                    const zl = Xl;
                    class Ql {
                        constructor(e, t, i) {
                            this.word = e, this.begin = t, this.end = i
                        }
                        getWord() {
                            return this.word
                        }
                        getBeginTime() {
                            return this.begin
                        }
                        getEndTime() {
                            return this.end
                        }
                    }
                    class Yl extends class {
                        constructor() {
                            throw new Error("TranscriptionService is abstract and cannot be created")
                        }
                        send(e, t) {
                            this.sendRequest(e.blob, (i => {
                                this.verify(i) ? e.wordArray = this.formatResponse(i) : (console.log("the retrieved response from the server is not valid!"), e.wordArray = []), t(e)
                            }))
                        }
                        sendRequest(e, t) {
                            throw new Error("TranscriptionService.sendRequest is abstract")
                        }
                        formatResponse(e) {
                            throw new Error("TranscriptionService.format is abstract")
                        }
                        verify(e) {
                            throw new Error("TranscriptionService.verify is abstract")
                        }
                    } {
                        constructor() {
                            super(), this.url = function() {
                                const e = "config does not contain an url to a Sphinx4 https server";
                                if (void 0 === config.sphinxURL) console.log(e);
                                else {
                                    const t = config.sphinxURL;
                                    if (void 0 !== t.includes && t.includes("https://")) return t;
                                    console.log(e)
                                }
                            }()
                        }
                        sendRequest(e, t) {
                            console.log(`sending an audio file  to ${this.url}`), console.log(`the audio file being sent: ${e}`);
                            const i = new XMLHttpRequest;
                            i.onreadystatechange = function() {
                                if (i.readyState === XMLHttpRequest.DONE && 200 === i.status) t(i.responseText);
                                else if (i.readyState === XMLHttpRequest.DONE) throw new Error(`unable to accept response from sphinx server. status: ${i.status}`)
                            }, i.open("POST", this.url), i.setRequestHeader("Content-Type", zl.determineCorrectFileType()), i.send(e), console.log(`send ${e}`)
                        }
                        formatResponse(e) {
                            const t = JSON.parse(e).objects;
                            t.shift();
                            const i = [];
                            return t.forEach((e => e.filler || i.push(new Ql(e.word, e.start, e.end)))), i
                        }
                        verify(e) {
                            if (console.log(`response from server:${e.toString()}`), "string" != typeof e) return !1;
                            let t;
                            try {
                                t = JSON.parse(e)
                            } catch (e) {
                                return console.log(e), !1
                            }
                            if (void 0 === t.objects) return !1;
                            const i = t.objects;
                            return !(!i[0] || !i[0]["session-id"])
                        }
                    }
                    const Zl = "before",
                        eh = "recording",
                        th = "transcribing",
                        ih = "finished";

                    function nh() {
                        this.audioRecorder = new zl, this.transcriptionService = new Yl, this.counter = null, this.startTime = null, this.transcription = null, this.callback = null, this.results = [], this.state = Zl, this.lineLength = 0
                    }

                    function sh(e, t) {
                        if (console.log(`retrieved an answer from the transcription service. The answer has an array of length: ${t.wordArray.length}`), t.wordArray.length > 0) {
                            let i = t.startTime.getUTCMilliseconds() - e.startTime.getUTCMilliseconds();
                            i < 0 && (i = 0);
                            let n = "[";
                            t.wordArray.forEach((e => {
                                e.begin += i, e.end += i, n += `${e.word},`
                            })), n += "]", console.log(n), t.wordArray.name = t.name
                        }
                        e.results.push(t.wordArray), e.counter--, console.log(`current counter: ${e.counter}`), e.maybeMerge()
                    }

                    function rh(e) {
                        for (let t = 0; t < e.length; t++) 0 === e[t].length && e.splice(t, 1);
                        return e.length > 0
                    }
                    nh.prototype.start = function() {
                        if (this.state !== Zl) throw new Error(`The transcription can only start when it's in the "before" state. It's currently in the "${this.state}" state`);
                        this.state = eh, this.audioRecorder.start(), this.startTime = new Date
                    }, nh.prototype.stop = function(e) {
                        if (this.state !== eh) throw new Error(`The transcription can only stop when it's in the "recording" state. It's currently in the "${this.state}" state`);
                        console.log("stopping recording and sending audio files"), this.audioRecorder.stop();
                        const t = sh.bind(null, this);
                        this.audioRecorder.getRecordingResults().forEach((e => {
                            this.transcriptionService.send(e, t), this.counter++
                        })), this.state = th, this.callback = e
                    }, nh.prototype.maybeMerge = function() {
                        this.state === th && 0 === this.counter && this.merge()
                    }, nh.prototype.merge = function() {
                        console.log(`starting merge process!\n The length of the array: ${this.results.length}`), this.transcription = "";
                        const e = this.results,
                            t = [];
                        for (rh(e), e.forEach((e => function(e, t) {
                                if (0 === e.length) e.push(t);
                                else {
                                    if (e[e.length - 1].begin <= t.begin) return void e.push(t);
                                    for (let i = 0; i < e.length; i++)
                                        if (t.begin < e[i].begin) return void e.splice(i, 0, t);
                                    e.push(t)
                                }
                            }(t, e))); rh(e);) {
                            let t = e[0];
                            e.forEach((e => {
                                e[0].begin < t[0].begin && (t = e)
                            }));
                            let i = t.shift();
                            for (this.updateTranscription(i, t.name); t.length > 0;) {
                                let n = !1;
                                const s = t[0].begin;
                                if (e.forEach((e => {
                                        e[0].begin < s && (n = !0)
                                    })), n) break;
                                i = t.shift(), this.updateTranscription(i, null)
                            }
                        }
                        this.state = ih, this.callback && this.callback(this.transcription)
                    }, nh.prototype.updateTranscription = function(e, t) {
                        null != t && (this.transcription += `\n${t}:`, this.lineLength = t.length + 1), this.lineLength + e.word.length > 80 && (this.transcription += "\n    ", this.lineLength = 4), this.transcription += ` ${e.word}`, this.lineLength += e.word.length + 1
                    }, nh.prototype.addTrack = function(e) {
                        this.audioRecorder.addTrack(e)
                    }, nh.prototype.removeTrack = function(e) {
                        this.audioRecorder.removeTrack(e)
                    }, nh.prototype.getTranscription = function() {
                        if (this.state !== ih) throw new Error(`The transcription can only be retrieved when it's in the "finished" state. It's currently in the "${this.state}" state`);
                        return this.transcription
                    }, nh.prototype.getState = function() {
                        return this.state
                    }, nh.prototype.reset = function() {
                        this.state = Zl, this.counter = null, this.transcription = null, this.startTime = null, this.callback = null, this.results = [], this.lineLength = 0
                    };
                    const oh = nh,
                        ah = i(5810).getLogger("modules/version/ComponentsVersions.js");

                    function ch(e) {
                        this.versions = {}, this.conference = e, this.conference.addCommandListener("versions", this.processVersions.bind(this))
                    }
                    let dh, lh, hh;
                    ch.prototype.processVersions = function(e, t, i) {
                            if (!this.conference.isFocus(i)) return void ah.warn(`Received versions not from the focus user: ${e}`, i);
                            const n = [];
                            e.children.forEach((e => {
                                const t = e.attributes.name,
                                    i = e.value;
                                this.versions[t] !== i && (this.versions[t] = i, ah.info(`Got ${t} version: ${i}`), n.push({
                                    id: "component_version",
                                    component: t,
                                    version: i
                                }))
                            })), n.length > 0 && Tn.sendLog(JSON.stringify(n))
                        }, ch.prototype.getComponentVersion = function(e) {
                            return this.versions[e]
                        },
                        function(e) {
                            e.STATUS_AVAILABLE = "available", e.STATUS_UNDEFINED = "undefined", e.STATUS_BUSY = "busy"
                        }(dh || (dh = {})),
                        function(e) {
                            e.STATE_ON = "on", e.STATE_OFF = "off", e.STATE_PENDING = "pending", e.STATE_RETRYING = "retrying", e.STATE_FAILED = "failed"
                        }(lh || (lh = {})),
                        function(e) {
                            e.ERROR_NO_CONNECTION = "error_no_connection", e.ERROR_SESSION_EXISTS = "error_session_already_exists"
                        }(hh || (hh = {}));
                    const uh = dh.STATUS_AVAILABLE,
                        ph = dh.STATUS_UNDEFINED,
                        mh = dh.STATUS_BUSY,
                        fh = lh.STATE_ON,
                        gh = lh.STATE_OFF,
                        _h = lh.STATE_PENDING,
                        Sh = lh.STATE_RETRYING,
                        vh = lh.STATE_FAILED,
                        Eh = hh.ERROR_NO_CONNECTION,
                        yh = hh.ERROR_SESSION_EXISTS,
                        Th = (0, v.getLogger)("modules/videosipgw/JitsiVideoSIPGWSession.js"),
                        Ch = "STATE_CHANGED";
                    class bh extends Wn {
                        constructor(e, t, i) {
                            super(), this.sipAddress = e, this.displayName = t, this.chatRoom = i, this.state = void 0
                        }
                        stop() {
                            this.state !== gh && this.state !== vh ? this._sendJibriIQ("stop") : Th.warn("Video SIP GW session already stopped or failed!")
                        }
                        start() {
                            this.state !== fh && this.state !== gh && this.state !== _h && this.state !== Sh ? this._sendJibriIQ("start") : Th.warn("Video SIP GW session already started!")
                        }
                        setState(e, t) {
                            if (e === this.state) return;
                            const i = this.state;
                            this.state = e, this.eventEmitter.emit(Ch, {
                                address: this.sipAddress,
                                failureReason: t,
                                oldState: i,
                                newState: this.state,
                                displayName: this.displayName
                            })
                        }
                        addStateListener(e) {
                            this.addListener(Ch, e)
                        }
                        removeStateListener(e) {
                            this.removeListener(Ch, e)
                        }
                        _sendJibriIQ(e) {
                            const t = {
                                xmlns: "http://jitsi.org/protocol/jibri",
                                action: e,
                                sipaddress: this.sipAddress
                            };
                            t.displayname = this.displayName;
                            const i = (0, ut.$iq)({
                                to: this.chatRoom.focusMucJid,
                                type: "set"
                            }).c("jibri", t).up();
                            Th.debug(`${e} video SIP GW session`, i.nodeTree), this.chatRoom.connection.sendIQ(i, (() => {}), (t => {
                                Th.error(`Failed to ${e} video SIP GW session, error: `, t), this.setState(vh)
                            }))
                        }
                    }
                    const Rh = (0, v.getLogger)("modules/videosipgw/VideoSIPGW.js");
                    class Ah {
                        constructor(e) {
                            this.chatRoom = e, this.eventEmitter = e.eventEmitter, Rh.debug("creating VideoSIPGW"), this.sessions = {}, this.sessionStateChangeListener = this.sessionStateChanged.bind(this), e.addPresenceListener("jibri-sip-call-state", this.handleJibriSIPState.bind(this))
                        }
                        handleJibriSIPState(e) {
                            const t = e.attributes;
                            if (!t) return;
                            Rh.debug("Handle video sip gw state : ", t);
                            const i = t.state;
                            if (i !== this.state) switch (i) {
                                case fh:
                                case gh:
                                case _h:
                                case Sh:
                                case vh: {
                                    const e = t.sipaddress;
                                    if (!e) return;
                                    const n = this.sessions[e];
                                    n ? n.setState(i, t.failure_reason) : Rh.warn("Video SIP GW session not found:", e)
                                }
                            }
                        }
                        createVideoSIPGWSession(e, t) {
                            if (this.sessions[e]) return Rh.warn("There was already a Video SIP GW session for address", e), new Error(yh);
                            const i = new bh(e, t, this.chatRoom);
                            return i.addStateListener(this.sessionStateChangeListener), this.sessions[e] = i, i
                        }
                        sessionStateChanged(e) {
                            const t = e.address;
                            if (e.newState === gh || e.newState === vh) {
                                const e = this.sessions[t];
                                if (!e) return void Rh.error("Missing Video SIP GW session with address:", t);
                                e.removeStateListener(this.sessionStateChangeListener), delete this.sessions[t]
                            }
                            this.eventEmitter.emit(Nn.XMPPEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED, e)
                        }
                    }
                    const Ph = (0, v.getLogger)("modules/xmpp/SignalingLayerImpl.js"),
                        Ih = "SourceInfo";
                    class Nh extends rd {
                        constructor() {
                            super(), this.ssrcOwners = new Map, this.chatRoom = null, this._localSourceState = {}, this._remoteSourceState = {}, this._sourceNames = new Map
                        }
                        _addLocalSourceInfoToPresence() {
                            return !!this.chatRoom && this.chatRoom.addOrReplaceInPresence(Ih, {
                                value: JSON.stringify(this._localSourceState)
                            })
                        }
                        _doesEndpointSendNewSourceInfo(e) {
                            var t;
                            const i = null === (t = this.chatRoom) || void 0 === t ? void 0 : t.getLastPresence(e);
                            return Boolean(i && i.find((e => e.tagName === Ih)))
                        }
                        setChatRoom(e) {
                            const t = this.chatRoom;
                            this.chatRoom = e, t && (t.removePresenceListener("audiomuted", this._audioMuteHandler), t.removePresenceListener("videomuted", this._videoMuteHandler), t.removePresenceListener("videoType", this._videoTypeHandler), hn.isSourceNameSignalingEnabled() && (this._sourceInfoHandler && t.removePresenceListener(Ih, this._sourceInfoHandler), this._memberLeftHandler && t.removeEventListener(Nn.XMPPEvents.MUC_MEMBER_LEFT, this._memberLeftHandler))), e && (hn.isSourceNameSignalingEnabled() ? (this._bindChatRoomEventHandlers(e), this._addLocalSourceInfoToPresence()) : (this._audioMuteHandler = (e, t) => {
                                this.eventEmitter.emit(Zc, t, dn.AUDIO, "true" === e.value)
                            }, e.addPresenceListener("audiomuted", this._audioMuteHandler), this._videoMuteHandler = (e, t) => {
                                this.eventEmitter.emit(Zc, t, dn.VIDEO, "true" === e.value)
                            }, e.addPresenceListener("videomuted", this._videoMuteHandler), this._videoTypeHandler = (e, t) => {
                                this.eventEmitter.emit(ed, t, e.value)
                            }, e.addPresenceListener("videoType", this._videoTypeHandler)))
                        }
                        _bindChatRoomEventHandlers(e) {
                            const t = (e, t) => {
                                    this.eventEmitter.emit(Zc, e, dn.AUDIO, t)
                                },
                                i = (e, t) => {
                                    this.eventEmitter.emit(Zc, e, dn.VIDEO, t)
                                };
                            this._audioMuteHandler = (e, i) => {
                                this._doesEndpointSendNewSourceInfo(i) || t(i, "true" === e.value)
                            }, e.addPresenceListener("audiomuted", this._audioMuteHandler), this._videoMuteHandler = (e, t) => {
                                this._doesEndpointSendNewSourceInfo(t) || i(t, "true" === e.value)
                            }, e.addPresenceListener("videomuted", this._videoMuteHandler);
                            const n = (e, t) => {
                                this.eventEmitter.emit(ed, e, t)
                            };
                            this._videoTypeHandler = (e, t) => {
                                this._doesEndpointSendNewSourceInfo(t) || n(t, e.value)
                            }, hn.isMultiStreamSupportEnabled() || e.addPresenceListener("videoType", this._videoTypeHandler), this._sourceInfoHandler = (e, t) => {
                                const i = t,
                                    {
                                        value: n
                                    } = e,
                                    s = JSON.parse(n),
                                    r = this._doesEndpointSendNewSourceInfo(i),
                                    o = this._remoteSourceState[i] || (this._remoteSourceState[i] = {});
                                for (const e of Object.keys(s)) {
                                    var a;
                                    const t = sd(e),
                                        i = Boolean(s[e].muted),
                                        n = o[e] || (o[e] = {
                                            sourceName: e
                                        });
                                    n.muted !== i && (n.muted = i, r && !this._localSourceState[e] && this.eventEmitter.emit(td, e, i));
                                    const c = t === dn.VIDEO ? null !== (a = s[e].videoType) && void 0 !== a ? a : An.VideoType.CAMERA : void 0;
                                    n.videoType !== c && (n.videoType = c, r && !this._localSourceState[e] && this.eventEmitter.emit(id, e, c))
                                }
                                const c = Object.keys(s);
                                for (const e of Object.keys(o)) - 1 === c.indexOf(e) && delete o[e]
                            }, e.addPresenceListener("SourceInfo", this._sourceInfoHandler), this._memberLeftHandler = e => {
                                const t = ut.Strophe.getResourceFromJid(e);
                                if (delete this._remoteSourceState[t], hn.isSourceNameSignalingEnabled())
                                    for (const [e, i] of this.ssrcOwners.entries()) i === t && delete this._sourceNames[e]
                            }, e.addEventListener(Nn.XMPPEvents.MUC_MEMBER_LEFT, this._memberLeftHandler)
                        }
                        _findEndpointSourceInfoForMediaType(e, t) {
                            const i = this._remoteSourceState[e];
                            if (!i) return null;
                            for (const e of Object.values(i))
                                if (sd(e.sourceName) === t) return e;
                            return null
                        }
                        getPeerMediaInfo(e, t, i) {
                            const n = () => {
                                if (this.chatRoom) return this.chatRoom.getMediaPresenceInfo(e, t);
                                Ph.warn("Requested peer media info, before room was set")
                            };
                            if (hn.isSourceNameSignalingEnabled()) {
                                var s;
                                const r = null === (s = this.chatRoom) || void 0 === s ? void 0 : s.getLastPresence(e);
                                if (!r) return void Ph.warn(`getPeerMediaInfo - no presence stored for: ${e}`);
                                if (!this._doesEndpointSendNewSourceInfo(e)) return n();
                                if (i) return this.getPeerSourceInfo(e, i);
                                const o = {},
                                    a = this._findEndpointSourceInfoForMediaType(e, t);
                                if (t === dn.AUDIO) o.muted = !a || a.muted;
                                else {
                                    if (t !== dn.VIDEO) throw new Error(`Unsupported media type: ${t}`); {
                                        o.muted = !a || a.muted, o.videoType = a ? a.videoType : void 0;
                                        const e = gr(r, "jitsi_participant_codecType");
                                        e.length > 0 && (o.codecType = e[0].value)
                                    }
                                }
                                return o
                            }
                            return n()
                        }
                        getPeerSourceInfo(e, t) {
                            var i;
                            const n = {
                                muted: !0,
                                videoType: An.VideoType.CAMERA
                            };
                            return this._remoteSourceState[e] ? null !== (i = this._remoteSourceState[e][t]) && void 0 !== i ? i : n : void 0
                        }
                        getSSRCOwner(e) {
                            return this.ssrcOwners.get(e)
                        }
                        setSSRCOwner(e, t) {
                            if ("number" != typeof e) throw new TypeError(`SSRC(${e}) must be a number`);
                            const i = this.ssrcOwners.get(e);
                            i && i !== t && Ph.error(`SSRC owner re-assigned from ${i} to ${t}`), this.ssrcOwners.set(e, t)
                        }
                        setTrackMuteStatus(e, t) {
                            return this._localSourceState[e] || (this._localSourceState[e] = {}), this._localSourceState[e].muted = t, !!this.chatRoom && this._addLocalSourceInfoToPresence()
                        }
                        setTrackVideoType(e, t) {
                            return this._localSourceState[e] || (this._localSourceState[e] = {}), this._localSourceState[e].videoType !== t && (this._localSourceState[e].videoType = t === An.VideoType.CAMERA ? void 0 : t, this._addLocalSourceInfoToPresence())
                        }
                        getTrackSourceName(e) {
                            return this._sourceNames.get(e)
                        }
                        setTrackSourceName(e, t) {
                            if ("number" != typeof e) throw new TypeError(`SSRC(${e}) must be a number`);
                            const i = this._sourceNames.get(e);
                            i && i !== t && Ph.error(`SSRC(${e}) sourceName re-assigned from ${i} to ${t}`), this._sourceNames.set(e, t)
                        }
                    }
                    const Dh = (0, v.getLogger)("JitsiConference.js");

                    function Mh(e) {
                        var t;
                        if (!e.name || e.name.toLowerCase() !== e.name.toString()) {
                            const e = "Invalid conference name (no conference name passed or it contains invalid characters like capital letters)!";
                            throw Dh.error(e), new Error(e)
                        }
                        if (this.connection = e.connection, this.xmpp = null === (t = this.connection) || void 0 === t ? void 0 : t.xmpp, this.xmpp.isRoomCreated(e.name, e.customDomain)) {
                            const e = "A conference with the same name has already been created!";
                            throw delete this.connection, delete this.xmpp, Dh.error(e), new Error(e)
                        }
                        this.eventEmitter = new(dt()), this.options = e, this.eventManager = new Mn(this), this.participants = {}, this._signalingLayer = new Nh, this._init(e), this.componentsVersions = new ch(this), this.jvbJingleSession = null, this.lastDominantSpeaker = null, this.dtmfManager = null, this.somebodySupportsDTMF = !1, this.authEnabled = !1, this.startAudioMuted = !1, this.startVideoMuted = !1, this.startMutedPolicy = {
                            audio: !1,
                            video: !1
                        }, this.isMutedByFocus = !1, this.mutedByFocusActor = null, this.isVideoMutedByFocus = !1, this.mutedVideoByFocusActor = null, this.wasStopped = !1, this.properties = {}, this.connectionQuality = new Qd(this, this.eventEmitter, e), this.avgRtpStatsReporter = new Vl(this, e.config.avgRtpStatsN || 15), e.config.disableAudioLevels || (this._audioOutputProblemDetector = new Ll(this)), this.isJvbConnectionInterrupted = !1, this.speakerStatsCollector = new $l(this), this.deferredStartP2PTask = null;
                        const i = parseInt(e.config.p2p && e.config.p2p.backToP2PDelay, 10);
                        this.backToP2PDelay = isNaN(i) ? 5 : i, Dh.info(`backToP2PDelay: ${this.backToP2PDelay}`), this.isP2PConnectionInterrupted = !1, this.p2p = !1, this.p2pJingleSession = null, this.videoSIPGWHandler = new Ah(this.room), this.recordingManager = new class {
                            constructor(e) {
                                this._sessions = {}, this._chatRoom = e, this.onPresence = this.onPresence.bind(this), this._chatRoom.eventEmitter.addListener(Nn.XMPPEvents.PRESENCE_RECEIVED, this.onPresence)
                            }
                            getSession(e) {
                                return this._sessions[e]
                            }
                            onPresence(e) {
                                let {
                                    fromHiddenDomain: t,
                                    presence: i
                                } = e;
                                Dl.isFromFocus(i) ? this._handleFocusPresence(i) : t && this._handleJibriPresence(i)
                            }
                            startRecording(e) {
                                const t = new Ml({
                                    ...e,
                                    connection: this._chatRoom.connection
                                });
                                return t.start({
                                    appData: e.appData,
                                    broadcastId: e.broadcastId,
                                    focusMucJid: this._chatRoom.focusMucJid,
                                    streamId: e.streamId
                                }).then((() => (this.getSession(t.getID()) || (this._addSession(t), this._emitSessionUpdate(t)), t))).catch((e => (this._emitSessionUpdate(t), Promise.reject(e))))
                            }
                            stopRecording(e) {
                                const t = this.getSession(e);
                                return t ? t.stop({
                                    focusMucJid: this._chatRoom.focusMucJid
                                }) : Promise.reject(new Error("Could not find session"))
                            }
                            _addSession(e) {
                                this._sessions[e.getID()] = e
                            }
                            _createSession(e, t, i) {
                                const n = new Ml({
                                    connection: this._chatRoom.connection,
                                    focusMucJid: this._chatRoom.focusMucJid,
                                    mode: i,
                                    sessionID: e,
                                    status: t
                                });
                                return this._addSession(n), n
                            }
                            _emitSessionUpdate(e, t) {
                                this._chatRoom.eventEmitter.emit(Nn.XMPPEvents.RECORDER_STATE_CHANGED, e, t)
                            }
                            _handleFocusPresence(e) {
                                const t = Dl.getFocusRecordingUpdate(e);
                                if (!t) return;
                                const {
                                    error: i,
                                    initiator: n,
                                    recordingMode: s,
                                    sessionID: r,
                                    status: o
                                } = t;
                                let a = this.getSession(r);
                                a || "off" !== o ? a && a.getStatus() === o && a.getError() === i ? Ol.warn("Ignoring duplicate presence update: ", JSON.stringify(t)) : (a || (a = this._createSession(r, o, s)), a.setStatus(o), i && a.setError(i), this._emitSessionUpdate(a, n)) : Ol.warn("Ignoring recording presence update", "Received a new session with status off.")
                            }
                            _handleJibriPresence(e) {
                                const {
                                    liveStreamViewURL: t,
                                    mode: i,
                                    sessionID: n
                                } = Dl.getHiddenDomainUpdate(e);
                                if (!n) return void Ol.warn("Ignoring potential jibri presence due to no session id.");
                                let s = this.getSession(n);
                                s || (s = this._createSession(n, "", i)), s.setLiveStreamViewURL(t), this._emitSessionUpdate(s)
                            }
                        }(this.room), this._conferenceJoinAnalyticsEventSent = void 0, this.isE2EESupported() && (Dh.info("End-to-End Encryption is supported"), this._e2eEncryption = new Es(this)), this._audioSenderLimitReached = void 0, this._videoSenderLimitReached = void 0
                    }

                    function Oh(e, t, i) {
                        this.appID = e, this.token = t, this.options = i, this.xmpp = new sa(i, t), this.addEventListener(Un, ((e, t, i, n) => {
                            Tn.sendAnalyticsAndLog(((e, t, i) => ({
                                type: Ut.TYPE_OPERATIONAL,
                                action: "connection.failed",
                                attributes: {
                                    error_type: e,
                                    error_message: t,
                                    ...i
                                }
                            }))(e, t, n))
                        })), this.addEventListener(Fn, (e => {
                            e && Tn.sendAnalytics(ii, {
                                message: e
                            }), Tn.sendLog(JSON.stringify({
                                id: ii,
                                msg: e
                            }))
                        }))
                    }
                    let wh;
                    Mh.prototype.constructor = Mh, Mh.resourceCreator = function(e, t) {
                        let i;
                        if (t) i = Ts().randomHexString(8).toLowerCase();
                        else {
                            var n;
                            i = null === (n = ut.Strophe.getNodeFromJid(e)) || void 0 === n ? void 0 : n.substr(0, 8).toLowerCase();
                            const t = /[0-9a-f]{8}/g;
                            i && t.test(i) || (i = Ts().randomHexString(8).toLowerCase())
                        }
                        return i
                    }, Mh.prototype._init = function() {
                        var e;
                        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        this.eventManager.setupXMPPListeners();
                        const {
                            config: i
                        } = this.options, n = {
                            disabledCodec: i.videoQuality ? i.videoQuality.disabledCodec : i.p2p && i.p2p.disableH264 && Pr().H264,
                            enforcePreferredCodec: i.videoQuality && i.videoQuality.enforcePreferredCodec,
                            jvbCodec: i.videoQuality && i.videoQuality.preferredCodec || i.preferH264 && Pr().H264,
                            p2pCodec: i.p2p ? i.p2p.preferredCodec || i.p2p.preferH264 && Pr().H264 : Pr().VP8
                        };
                        this.codecSelection = new aa(this, n), this._statsCurrentId = i.statisticsId ? i.statisticsId : or.callStatsUserName, this.room = this.xmpp.createRoom(this.options.name, {
                            ...i,
                            statsId: this._statsCurrentId
                        }, Mh.resourceCreator), this._signalingLayer.setChatRoom(this.room), this._onIceConnectionInterrupted = this._onIceConnectionInterrupted.bind(this), this.room.addListener(Nn.XMPPEvents.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), this._onIceConnectionRestored = this._onIceConnectionRestored.bind(this), this.room.addListener(Nn.XMPPEvents.CONNECTION_RESTORED, this._onIceConnectionRestored), this._onIceConnectionEstablished = this._onIceConnectionEstablished.bind(this), this.room.addListener(Nn.XMPPEvents.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), this._updateProperties = this._updateProperties.bind(this), this.room.addListener(Nn.XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), this._sendConferenceJoinAnalyticsEvent = this._sendConferenceJoinAnalyticsEvent.bind(this), this.room.addListener(Nn.XMPPEvents.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent), this._removeLocalSourceOnReject = this._removeLocalSourceOnReject.bind(this), this._updateRoomPresence = this._updateRoomPresence.bind(this), this.room.addListener(Nn.XMPPEvents.SESSION_ACCEPT, this._updateRoomPresence), this.room.addListener(Nn.XMPPEvents.SOURCE_ADD, this._updateRoomPresence), this.room.addListener(Nn.XMPPEvents.SOURCE_ADD_ERROR, this._removeLocalSourceOnReject), this.room.addListener(Nn.XMPPEvents.SOURCE_REMOVE, this._updateRoomPresence), null !== (e = i.e2eping) && void 0 !== e && e.enabled && (this.e2eping = new Tl(this, i, ((e, t) => {
                            try {
                                this.sendMessage(e, t, !0)
                            } catch (e) {
                                Dh.warn("Failed to send E2E ping request or response.", e && e.msg)
                            }
                        }))), this.rtc || (this.rtc = new Hd(this, t), this.eventManager.setupRTCListeners(), hn.isSourceNameSignalingEnabled() && this._registerRtcListeners(this.rtc)), this.receiveVideoController = new Pl(this, this.rtc), this.sendVideoController = new Nl(this, this.rtc), hn.isSourceNameSignalingEnabled() || (this.participantConnectionStatus = new Ln(this.rtc, this, {
                            p2pRtcMuteTimeout: i._p2pConnStatusRtcMuteTimeout,
                            rtcMuteTimeout: i._peerConnStatusRtcMuteTimeout,
                            outOfLastNTimeout: i._peerConnStatusOutOfLastNTimeout
                        }), this.participantConnectionStatus.init());
                        let s = !0;
                        if (i.testing && i.testing.callStatsThreshold && (s = 100 * Math.random() <= i.testing.callStatsThreshold), this.statistics || (this.statistics = new Tn(this.xmpp, {
                                aliasName: this._statsCurrentId,
                                userName: i.statisticsDisplayName ? i.statisticsDisplayName : this.myUserId(),
                                confID: i.confID || `${this.connection.options.hosts.domain}/${this.options.name}`,
                                siteID: i.siteID,
                                customScriptUrl: i.callStatsCustomScriptUrl,
                                callStatsID: i.callStatsID,
                                callStatsSecret: i.callStatsSecret,
                                callStatsApplicationLogsDisabled: i.callStatsApplicationLogsDisabled,
                                enableCallStats: s,
                                roomName: this.options.name,
                                applicationName: i.applicationName,
                                getWiFiStatsMethod: i.getWiFiStatsMethod,
                                configParams: i.callStatsConfigParams
                            }), Tn.analytics.addPermanentProperties({
                                callstats_name: this._statsCurrentId
                            }), i.longTasksStatsInterval && this.statistics.attachLongTasksStats(this)), this.eventManager.setupChatRoomListeners(), this.eventManager.setupStatisticsListeners(), i.enableTalkWhileMuted && Ui.supportsVADDetection())
                            if (i.createVADProcessor) {
                                Dh.info("Using VAD detection for generating talk while muted events"), this._audioAnalyser || (this._audioAnalyser = new pl(this, i.createVADProcessor));
                                const e = new fl;
                                e.on(al, (() => this.eventEmitter.emit(Ve))), this._audioAnalyser.addVADDetectionService(e)
                            } else Dh.warn("No VAD Processor was provided. Talk while muted detection service was not initialized!");
                        if (i.enableNoisyMicDetection && Ui.supportsVADDetection())
                            if (i.createVADProcessor) {
                                this._audioAnalyser || (this._audioAnalyser = new pl(this, i.createVADProcessor));
                                const e = new ml;
                                e.on(sl, (() => this.eventEmitter.emit(Te))), this._audioAnalyser.addVADDetectionService(e)
                            } else Dh.warn("No VAD Processor was provided. Noisy microphone detection service was not initialized!");
                        i.enableNoAudioDetection && (this._noAudioSignalDetection = new cl(this), this._noAudioSignalDetection.on(nl, (() => {
                            this.eventEmitter.emit(ye)
                        })), this._noAudioSignalDetection.on(il, (e => {
                            this.eventEmitter.emit(J, e)
                        }))), "channelLastN" in i && this.setLastN(i.channelLastN), this.jvb121Status = new bl(this), this.p2pDominantSpeakerDetection = new dl(this), i && i.deploymentInfo && i.deploymentInfo.userRegion && this.setLocalParticipantProperty("region", i.deploymentInfo.userRegion), this.setLocalParticipantProperty("codecType", this.codecSelection.getPreferredCodec()), i && i.transcriptionLanguage && "en-US" !== i.transcriptionLanguage && this.setLocalParticipantProperty("transcription_language", i.transcriptionLanguage)
                    }, Mh.prototype.join = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        this.room && this.room.join(e, t).then((() => this._maybeSetSITimeout()))
                    }, Mh.prototype.authenticateAndUpgradeRole = function(e) {
                        return ra.call(this, {
                            ...e,
                            onCreateResource: Mh.resourceCreator
                        })
                    }, Mh.prototype.isJoined = function() {
                        return this.room && this.room.joined
                    }, Mh.prototype.isP2PEnabled = function() {
                        return Boolean(this.options.config.p2p && this.options.config.p2p.enabled) || void 0 === this.options.config.p2p
                    }, Mh.prototype.isP2PTestModeEnabled = function() {
                        return Boolean(this.options.config.testing && this.options.config.testing.p2pTestMode)
                    }, Mh.prototype.leave = async function(e) {
                            if (this.participantConnectionStatus && (this.participantConnectionStatus.dispose(), this.participantConnectionStatus = null), this.avgRtpStatsReporter && (this.avgRtpStatsReporter.dispose(), this.avgRtpStatsReporter = null), this._audioOutputProblemDetector && (this._audioOutputProblemDetector.dispose(), this._audioOutputProblemDetector = null), this.e2eping && (this.e2eping.stop(), this.e2eping = null), this.getLocalTracks().forEach((e => this.onLocalTrackRemoved(e))), this.rtc.closeBridgeChannel(), this._sendConferenceLeftAnalyticsEvent(), this.statistics && this.statistics.dispose(), this._delayedIceFailed && this._delayedIceFailed.cancel(), this._maybeClearSITimeout(), this.jvbJingleSession && (this.jvbJingleSession.close(), this.jvbJingleSession = null), this.p2pJingleSession && (this.p2pJingleSession.close(), this.p2pJingleSession = null), !this.room) throw new Error("You have already left the conference");
                            const t = this.room;
                            let i;
                            t.removeListener(Nn.XMPPEvents.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), t.removeListener(Nn.XMPPEvents.CONNECTION_RESTORED, this._onIceConnectionRestored), t.removeListener(Nn.XMPPEvents.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), t.removeListener(Nn.XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), t.removeListener(Nn.XMPPEvents.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent), t.removeListener(Nn.XMPPEvents.SESSION_ACCEPT, this._updateRoomPresence), t.removeListener(Nn.XMPPEvents.SOURCE_ADD, this._updateRoomPresence), t.removeListener(Nn.XMPPEvents.SOURCE_ADD_ERROR, this._removeLocalSourceOnReject), t.removeListener(Nn.XMPPEvents.SOURCE_REMOVE, this._updateRoomPresence), this.eventManager.removeXMPPListeners(), this._signalingLayer.setChatRoom(null), this.room = null;
                            try {
                                await t.leave(e)
                            } catch (e) {
                                i = e, this.getParticipants().forEach((e => this.onMemberLeft(e.getJid())))
                            }
                            if (this.rtc && this.rtc.destroy(), i) throw i
                        }, Mh.prototype.getActiveMediaSession = function() {
                            return this.isP2PActive() ? this.p2pJingleSession : this.jvbJingleSession
                        }, Mh.prototype.getMediaSessions = function() {
                            const e = [];
                            return this.jvbJingleSession && e.push(this.jvbJingleSession), this.p2pJingleSession && e.push(this.p2pJingleSession), e
                        }, Mh.prototype._registerRtcListeners = function(e) {
                            e.addListener(Rn.default.DATA_CHANNEL_OPEN, (() => {
                                for (const e of this.rtc.localTracks) e.isVideoTrack() && this._sendBridgeVideoTypeMessage(e)
                            }))
                        }, Mh.prototype._sendBridgeVideoTypeMessage = function(e) {
                            let t = !e || e.isMuted() ? da().NONE : e.getVideoType();
                            t === da().DESKTOP && this._desktopSharingFrameRate > 5 && (t = da().DESKTOP_HIGH_FPS), hn.isSourceNameSignalingEnabled() && e ? this.rtc.sendSourceVideoType(e.getSourceName(), t) : hn.isSourceNameSignalingEnabled() || this.rtc.setVideoType(t)
                        }, Mh.prototype.getName = function() {
                            return this.options.name.toString()
                        }, Mh.prototype.getConnection = function() {
                            return this.connection
                        }, Mh.prototype.isAuthEnabled = function() {
                            return this.authEnabled
                        }, Mh.prototype.isLoggedIn = function() {
                            return Boolean(this.authIdentity)
                        }, Mh.prototype.getAuthLogin = function() {
                            return this.authIdentity
                        }, Mh.prototype.isExternalAuthEnabled = function() {
                            return this.room && this.room.moderator.isExternalAuthEnabled()
                        }, Mh.prototype.getExternalAuthUrl = function(e) {
                            return new Promise(((t, i) => {
                                this.isExternalAuthEnabled() ? e ? this.room.moderator.getPopupLoginUrl(t, i) : this.room.moderator.getLoginUrl(t, i) : i()
                            }))
                        }, Mh.prototype.getLocalTracks = function(e) {
                            let t = [];
                            return this.rtc && (t = this.rtc.getLocalTracks(e)), t
                        }, Mh.prototype.getLocalAudioTrack = function() {
                            return this.rtc ? this.rtc.getLocalAudioTrack() : null
                        }, Mh.prototype.getLocalVideoTrack = function() {
                            return this.rtc ? this.rtc.getLocalVideoTrack() : null
                        }, Mh.prototype.getLocalVideoTracks = function() {
                            return this.rtc ? this.rtc.getLocalVideoTracks() : null
                        }, Mh.prototype.getPerformanceStats = function() {
                            return {
                                longTasksStats: this.statistics.getLongTasksStats()
                            }
                        }, Mh.prototype.on = function(e, t) {
                            this.eventEmitter && this.eventEmitter.on(e, t)
                        }, Mh.prototype.off = function(e, t) {
                            this.eventEmitter && this.eventEmitter.removeListener(e, t)
                        }, Mh.prototype.addEventListener = Mh.prototype.on, Mh.prototype.removeEventListener = Mh.prototype.off, Mh.prototype.addCommandListener = function(e, t) {
                            this.room && this.room.addPresenceListener(e, t)
                        }, Mh.prototype.removeCommandListener = function(e, t) {
                            this.room && this.room.removePresenceListener(e, t)
                        }, Mh.prototype.sendTextMessage = function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body";
                            this.room && this.room.sendMessage(e, t)
                        }, Mh.prototype.sendPrivateTextMessage = function(e, t) {
                            let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "body";
                            this.room && this.room.sendPrivateMessage(e, t, i)
                        }, Mh.prototype.sendCommand = function(e, t) {
                            this.room ? this.room.addOrReplaceInPresence(e, t) && this.room.sendPresence() : Dh.warn("Not sending a command, room not initialized.")
                        }, Mh.prototype.sendCommandOnce = function(e, t) {
                            this.sendCommand(e, t), this.removeCommand(e)
                        }, Mh.prototype.removeCommand = function(e) {
                            this.room && this.room.removeFromPresence(e)
                        }, Mh.prototype.setDisplayName = function(e) {
                            if (this.room) {
                                const t = "nick";
                                if (!e && !this.room.getFromPresence(t)) return;
                                this.room.addOrReplaceInPresence(t, {
                                    attributes: {
                                        xmlns: "http://jabber.org/protocol/nick"
                                    },
                                    value: e
                                }) && this.room.sendPresence()
                            }
                        }, Mh.prototype.setSubject = function(e) {
                            this.room && this.isModerator() ? this.room.setSubject(e) : Dh.warn(`Failed to set subject, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
                        }, Mh.prototype.getTranscriber = function() {
                            if (void 0 === this.transcriber) {
                                this.transcriber = new oh;
                                const e = this.getLocalTracks(dn.AUDIO);
                                for (const t of e) this.transcriber.addTrack(t);
                                const t = this.rtc.getRemoteTracks(dn.AUDIO);
                                for (const e of t) this.transcriber.addTrack(e)
                            }
                            return this.transcriber
                        }, Mh.prototype.getTranscriptionStatus = function() {
                            return this.room.transcriptionStatus
                        }, Mh.prototype.addTrack = function(e) {
                            const t = e.getType(),
                                i = this.rtc.getLocalTracks(t);
                            if (i.length > 0) {
                                if (e === i[0]) return Promise.resolve(e);
                                if (hn.isMultiStreamSupportEnabled() && t === dn.VIDEO) {
                                    var n;
                                    const i = nd(this.myUserId(), t, null === (n = this.getLocalTracks(t)) || void 0 === n ? void 0 : n.length);
                                    e.setSourceName(i);
                                    const s = [];
                                    return this.p2pJingleSession && s.push(this.p2pJingleSession.addTracks([e])), this.jvbJingleSession && s.push(this.jvbJingleSession.addTracks([e])), Promise.all(s).then((() => {
                                        this._setupNewTrack(e), this._sendBridgeVideoTypeMessage(e), this._updateRoomPresence(this.getActiveMediaSession()), (this.isMutedByFocus || this.isVideoMutedByFocus) && this._fireMuteChangeEvent(e)
                                    }))
                                }
                                return Promise.reject(new Error(`Cannot add second ${t} track to the conference`))
                            }
                            return this.replaceTrack(null, e).then((() => {
                                e.getVideoType() === An.VideoType.DESKTOP && hn.isMultiStreamSupportEnabled() && this._updateRoomPresence(this.getActiveMediaSession())
                            }))
                        }, Mh.prototype._fireAudioLevelChangeEvent = function(e, t) {
                            const i = this.getActivePeerConnection();
                            t && i !== t || this.eventEmitter.emit(je, this.myUserId(), e)
                        }, Mh.prototype._fireMuteChangeEvent = function(e) {
                            let t;
                            if (this.isMutedByFocus && e.isAudioTrack() && !e.isMuted() ? (this.isMutedByFocus = !1, this.room.muteParticipant(this.room.myroomjid, !1, dn.AUDIO)) : this.isVideoMutedByFocus && e.isVideoTrack() && !e.isMuted() && (this.isVideoMutedByFocus = !1, this.room.muteParticipant(this.room.myroomjid, !1, dn.VIDEO)), this.mutedByFocusActor && e.isAudioTrack()) {
                                const e = ut.Strophe.getResourceFromJid(this.mutedByFocusActor);
                                t = this.participants[e]
                            } else if (this.mutedVideoByFocusActor && e.isVideoTrack()) {
                                const e = ut.Strophe.getResourceFromJid(this.mutedVideoByFocusActor);
                                t = this.participants[e]
                            }
                            e.isVideoTrack() && !Ui.doesVideoMuteByStreamRemove() && this._sendBridgeVideoTypeMessage(e), this.eventEmitter.emit($e, e, t)
                        }, Mh.prototype._getInitialLocalTracks = function() {
                            return this.getLocalTracks().filter((e => {
                                const t = e.getType();
                                return !(t !== dn.AUDIO || this.isStartAudioMuted() && !Ui.isWebKitBased() && !Ui.isReactNative()) || t === dn.VIDEO && !this.isStartVideoMuted()
                            }))
                        }, Mh.prototype.onLocalTrackRemoved = function(e) {
                            e.setConference(null), this.rtc.removeLocalTrack(e), e.removeEventListener(Lt, e.muteHandler), e.isAudioTrack() && e.removeEventListener(Ot, e.audioLevelHandler), e.isVideoTrack() && e.videoType === An.VideoType.DESKTOP && this.statistics.sendScreenSharingEvent(!1), this.eventEmitter.emit(He, e)
                        }, Mh.prototype.removeTrack = function(e) {
                            return this.replaceTrack(e, null)
                        }, Mh.prototype.replaceTrack = function(e, t) {
                            const i = null == e ? void 0 : e.getVideoType(),
                                n = (null == e ? void 0 : e.getType()) || (null == t ? void 0 : t.getType()),
                                s = null == t ? void 0 : t.getVideoType();
                            if (hn.isMultiStreamSupportEnabled() && e && t && i !== s) throw new Error(`Replacing a track of videoType=${i} with a track of videoType=${s} is not supported in this mode.`);
                            if (hn.isSourceNameSignalingEnabled() && t)
                                if (e) t.setSourceName(e.getSourceName());
                                else {
                                    var r;
                                    const e = nd(this.myUserId(), n, null === (r = this.getLocalTracks(n)) || void 0 === r ? void 0 : r.length);
                                    t.setSourceName(e)
                                } const o = this === (null == e ? void 0 : e.conference);
                            return o && e.disposed || null != t && t.disposed ? Promise.reject(new Nt(bt)) : (e && !o && Dh.warn(`JitsiConference.replaceTrack oldTrack (${e} does not belong to this conference`), this._doReplaceTrack(o ? e : null, t).then((() => (o && this.onLocalTrackRemoved(e), t && this._setupNewTrack(t), (o && null != e && e.isVideoTrack() || null != t && t.isVideoTrack()) && this._sendBridgeVideoTypeMessage(t), this._updateRoomPresence(this.getActiveMediaSession()), null !== t && (this.isMutedByFocus || this.isVideoMutedByFocus) && this._fireMuteChangeEvent(t), Promise.resolve()))).catch((e => (Dh.error(`replaceTrack failed: ${null==e?void 0:e.stack}`), Promise.reject(e)))))
                        }, Mh.prototype._doReplaceTrack = function(e, t) {
                            const i = [];
                            return this.jvbJingleSession ? i.push(this.jvbJingleSession.replaceTrack(e, t)) : Dh.info("_doReplaceTrack - no JVB JingleSession"), this.p2pJingleSession ? i.push(this.p2pJingleSession.replaceTrack(e, t)) : Dh.info("_doReplaceTrack - no P2P JingleSession"), Promise.all(i)
                        }, Mh.prototype._removeLocalSourceOnReject = function(e, t, i) {
                            if (!e) return;
                            Dh.warn(`Source-add rejected on ${e}, reason="${null==t?void 0:t.reason}", message="${null==t?void 0:t.msg}"`);
                            const n = this.getLocalTracks(i)[0];
                            this.eventEmitter.emit(Be, n)
                        }, Mh.prototype._setupNewTrack = function(e) {
                            const t = e.getType();
                            if (e.isAudioTrack() || e.isVideoTrack() && e.videoType !== An.VideoType.DESKTOP) {
                                const t = Hd.getCurrentlyAvailableMediaDevices().find((t => t.kind === `${e.getTrack().kind}input` && t.label === e.getTrack().label));
                                t && Tn.sendActiveDeviceListEvent(Hd.getEventDataForActiveDevice(t))
                            }
                            if (hn.isSourceNameSignalingEnabled() && !e.getSourceName()) {
                                var i;
                                const n = nd(this.myUserId(), t, null === (i = this.getLocalTracks(t)) || void 0 === i ? void 0 : i.length);
                                e.setSourceName(n)
                            }
                            this.rtc.addLocalTrack(e), e.setConference(this), e.muteHandler = this._fireMuteChangeEvent.bind(this, e), e.addEventListener(Lt, e.muteHandler), e.isAudioTrack() && (e.audioLevelHandler = this._fireAudioLevelChangeEvent.bind(this), e.addEventListener(Ot, e.audioLevelHandler)), this.eventEmitter.emit(Ue, e)
                        }, Mh.prototype._setNewVideoType = function(e) {
                            let t = !1;
                            if (hn.isSourceNameSignalingEnabled() && e && (t = this._signalingLayer.setTrackVideoType(e.getSourceName(), e.videoType)), !hn.isMultiStreamSupportEnabled()) {
                                const i = "videoType",
                                    n = e ? e.videoType : An.VideoType.CAMERA;
                                if (n !== An.VideoType.CAMERA || this.room.getFromPresence(i)) {
                                    const e = this.room.addOrReplaceInPresence(i, {
                                        value: n
                                    });
                                    t = t || e
                                }
                            }
                            return t
                        }, Mh.prototype._setTrackMuteStatus = function(e, t, i) {
                            let n = !1;
                            if (hn.isSourceNameSignalingEnabled() && t && (n = this._signalingLayer.setTrackMuteStatus(t.getSourceName(), i)), !hn.isMultiStreamSupportEnabled()) {
                                let t, s;
                                if (!this.room) return !1;
                                e === dn.AUDIO ? t = this.room.addAudioInfoToPresence(i) : s = this.room.addVideoInfoToPresence(i), n = n || t || s
                            }
                            return n
                        }, Mh.prototype._addLocalTrackToPc = function(e) {
                            const t = [];
                            return this.jvbJingleSession ? t.push(this.jvbJingleSession.addTrackToPc(e)) : Dh.debug("Add local MediaStream - no JVB Jingle session started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.addTrackToPc(e)) : Dh.debug("Add local MediaStream - no P2P Jingle session started yet"), Promise.allSettled(t)
                        }, Mh.prototype._removeLocalTrackFromPc = function(e) {
                            const t = [];
                            return this.jvbJingleSession ? t.push(this.jvbJingleSession.removeTrackFromPc(e)) : Dh.debug("Remove local MediaStream - no JVB JingleSession started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.removeTrackFromPc(e)) : Dh.debug("Remove local MediaStream - no P2P JingleSession started yet"), Promise.allSettled(t)
                        }, Mh.prototype.getRole = function() {
                            return this.room.role
                        }, Mh.prototype.isHidden = function() {
                            return this.connection ? ut.Strophe.getDomainFromJid(this.connection.getJid()) === this.options.config.hiddenDomain : null
                        }, Mh.prototype.isModerator = function() {
                            return this.room ? this.room.isModerator() : null
                        }, Mh.prototype.lock = function(e) {
                            return this.isModerator() ? new Promise(((t, i) => {
                                this.room.lockRoom(e || "", (() => t()), (e => i(e)), (() => i(V)))
                            })) : Promise.reject(new Error("You are not moderator."))
                        }, Mh.prototype.unlock = function() {
                            return this.lock()
                        }, Mh.prototype.selectParticipant = function(e) {
                            this.selectParticipants([e])
                        }, Mh.prototype.selectParticipants = function(e) {
                            if (!Array.isArray(e)) throw new Error("Invalid argument; participantIds must be an array.");
                            this.receiveVideoController.selectEndpoints(e)
                        }, Mh.prototype.getLastN = function() {
                            return this.receiveVideoController.getLastN()
                        }, Mh.prototype.getForwardedSources = function() {
                            return this.rtc.getForwardedSources()
                        }, Mh.prototype.setLastN = function(e) {
                            if (!Number.isInteger(e) && !Number.parseInt(e, 10)) throw new Error(`Invalid value for lastN: ${e}`);
                            const t = Number(e);
                            if (t < -1) throw new RangeError("lastN cannot be smaller than -1");
                            if (this.receiveVideoController.setLastN(t), this.p2pJingleSession) {
                                const e = 0 !== t;
                                this.p2pJingleSession.setMediaTransferActive(!0, e).catch((t => {
                                    Dh.error(`Failed to adjust video transfer status (${e})`, t)
                                }))
                            }
                        }, Mh.prototype.isInLastN = function(e) {
                            return this.rtc.isInLastN(e)
                        }, Mh.prototype.getParticipants = function() {
                            return Object.values(this.participants)
                        }, Mh.prototype.getParticipantCount = function() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                                t = this.getParticipants();
                            return e || (t = t.filter((e => !e.isHidden()))), t.length + 1
                        }, Mh.prototype.getParticipantById = function(e) {
                            return this.participants[e]
                        }, Mh.prototype.grantOwner = function(e) {
                            const t = this.getParticipantById(e);
                            t && this.room.setAffiliation(t.getConnectionJid(), "owner")
                        }, Mh.prototype.revokeOwner = function(e) {
                            const t = this.getParticipantById(e),
                                i = this.myUserId() === e,
                                n = this.isMembersOnly() ? "member" : "none";
                            i ? this.room.setAffiliation(this.connection.getJid(), n) : t && this.room.setAffiliation(t.getConnectionJid(), n)
                        }, Mh.prototype.kickParticipant = function(e, t) {
                            const i = this.getParticipantById(e);
                            i && this.room.kick(i.getJid(), t)
                        }, Mh.prototype._maybeClearSITimeout = function() {
                            this._sessionInitiateTimeout && (this.jvbJingleSession || this.getParticipantCount() < 2) && (window.clearTimeout(this._sessionInitiateTimeout), this._sessionInitiateTimeout = null)
                        }, Mh.prototype._maybeSetSITimeout = function() {
                            !this.jvbJingleSession && this.getParticipantCount() >= 2 && !this._sessionInitiateTimeout && (this._sessionInitiateTimeout = window.setTimeout((() => {
                                this._sessionInitiateTimeout = null, Tn.sendAnalytics(ui(qt, {
                                    p2p: !1,
                                    value: 5e3
                                }))
                            }), 5e3))
                        }, Mh.prototype.muteParticipant = function(e, t) {
                            const i = t || dn.AUDIO;
                            if (i !== dn.AUDIO && i !== dn.VIDEO) return void Dh.error(`Unsupported media type: ${i}`);
                            const n = this.getParticipantById(e);
                            n && this.room.muteParticipant(n.getJid(), !0, i)
                        }, Mh.prototype.onMemberJoined = function(e, t, i, n, s, r, o, a, c, d, l) {
                            const h = ut.Strophe.getResourceFromJid(e);
                            if ("focus" === h || this.myUserId() === h) return;
                            const u = new kn(e, this, t, n, s, r, o);
                            u.setConnectionJid(c), u.setRole(i), u.setBotType(a), u.setFeatures(d), u.setIsReplacing(l), this.participants[h] = u, this.eventEmitter.emit(Ge, h, u), this._updateFeatures(u), this.isJoined() && this._maybeStartOrStopP2P(), this._maybeSetSITimeout()
                        }, Mh.prototype._onMucJoined = function() {
                            this._maybeStartOrStopP2P()
                        }, Mh.prototype._updateFeatures = function(e) {
                            e.getFeatures().then((t => {
                                e._supportsDTMF = t.has("urn:xmpp:jingle:dtmf:0"), this.updateDTMFSupport(), t.has(ia) && e.setProperty("features_jigasi", !0), t.has(na) && e.setProperty("features_e2ee", !0)
                            })).catch((() => !1))
                        }, Mh.prototype._onMemberBotTypeChanged = function(e, t) {
                            const i = this.getParticipants().find((t => t.getJid() === e));
                            if (i) {
                                i.setBotType(t);
                                const n = ut.Strophe.getResourceFromJid(e);
                                this.eventEmitter.emit(ze, n, t)
                            }
                            i.getBotType() || this._maybeStartOrStopP2P()
                        }, Mh.prototype.onMemberLeft = function(e, t) {
                            const i = ut.Strophe.getResourceFromJid(e);
                            if ("focus" === i || this.myUserId() === i) return;
                            const n = this.participants[i],
                                s = this.getMediaSessions();
                            let r = [];
                            for (const e of s) {
                                const t = e.peerconnection.getRemoteTracks(i);
                                t && (r = [...r, ...t]), e.removeRemoteStreamsOnLeave(i)
                            }
                            r.forEach((e => {
                                this.eventEmitter.emit(He, e)
                            })), n && (delete this.participants[i], this.eventEmitter.emit(Ke, i, n, t)), null !== this.room && (this._maybeStartOrStopP2P(!0), this._maybeClearSITimeout())
                        }, Mh.prototype.onMemberKicked = function(e, t, i, n, s) {
                            if (t === this.myUserId()) return;
                            const r = this.participants[t];
                            if (e) return this.eventEmitter.emit(he, r, n, s), void this.leave();
                            const o = this.participants[i];
                            o.setIsReplaced(s), this.eventEmitter.emit(ue, r, o, n)
                        }, Mh.prototype.onLocalRoleChanged = function(e) {
                            this.eventEmitter.emit(qe, this.myUserId(), e)
                        }, Mh.prototype.onUserRoleChanged = function(e, t) {
                            const i = ut.Strophe.getResourceFromJid(e),
                                n = this.getParticipantById(i);
                            n && (n.setRole(t), this.eventEmitter.emit(qe, i, t))
                        }, Mh.prototype.onDisplayNameChanged = function(e, t) {
                            const i = ut.Strophe.getResourceFromJid(e),
                                n = this.getParticipantById(i);
                            n && n._displayName !== t && (n._displayName = t, this.eventEmitter.emit(se, i, t))
                        }, Mh.prototype.onRemoteTrackAdded = function(e) {
                            if (e.isP2P && !this.isP2PActive()) return void Dh.info("Trying to add remote P2P track, when not in P2P - IGNORED");
                            if (!e.isP2P && this.isP2PActive()) return void Dh.info("Trying to add remote JVB track, when in P2P - IGNORED");
                            const t = e.getParticipantId(),
                                i = this.getParticipantById(t);
                            if (!i) return void Dh.error(`No participant found for id: ${t}`);
                            i._tracks.push(e), this.transcriber && this.transcriber.addTrack(e);
                            const n = this.eventEmitter;
                            e.addEventListener(Lt, (() => n.emit($e, e))), e.isAudioTrack() && e.addEventListener(Ot, ((e, i) => {
                                this.getActivePeerConnection() === i && n.emit(je, t, e)
                            })), n.emit(Ue, e)
                        }, Mh.prototype.onCallAccepted = function(e, t) {
                            this.p2pJingleSession === e && (Dh.info("P2P setAnswer"), this.p2pJingleSession.setAnswer(t), this.eventEmitter.emit(_e, this.p2pJingleSession))
                        }, Mh.prototype.onTransportInfo = function(e, t) {
                            this.p2pJingleSession === e && (Dh.info("P2P addIceCandidates"), this.p2pJingleSession.addIceCandidates(t))
                        }, Mh.prototype.onRemoteTrackRemoved = function(e) {
                            this.getParticipants().forEach((t => {
                                const i = t.getTracks();
                                for (let n = 0; n < i.length; n++)
                                    if (i[n] === e) {
                                        t._tracks.splice(n, 1), this.eventEmitter.emit(He, e), this.transcriber && this.transcriber.removeTrack(e);
                                        break
                                    }
                            }), this)
                        }, Mh.prototype._onIncomingCallP2P = function(e, t) {
                            var i;
                            let n;
                            const s = Ui.supportsUnifiedPlan() && (!Ui.isChromiumBased() || null === (i = this.options.config.enableUnifiedOnChrome) || void 0 === i || i),
                                r = t.find(">content").attr("name");
                            s !== ("0" === r || "1" === r) ? n = {
                                reason: "decline",
                                reasonDescription: "P2P disabled",
                                errorMsg: "P2P across two endpoints in different SDP modes is disabled"
                            } : !this.isP2PEnabled() && !this.isP2PTestModeEnabled() || Ui.isFirefox() || Ui.isWebKitBased() ? n = {
                                reason: "decline",
                                reasonDescription: "P2P disabled",
                                errorMsg: "P2P mode disabled in the configuration or browser unsupported"
                            } : this.p2pJingleSession ? n = {
                                reason: "busy",
                                reasonDescription: "P2P already in progress",
                                errorMsg: 'Duplicated P2P "session-initiate"'
                            } : this._shouldBeInP2PMode() || (n = {
                                reason: "decline",
                                reasonDescription: "P2P requirements not met",
                                errorMsg: 'Received P2P "session-initiate" when should not be in P2P mode'
                            }, Tn.sendAnalytics(ui(Qt))), n ? this._rejectIncomingCall(e, n) : this._acceptP2PIncomingCall(e, t)
                        }, Mh.prototype.onIncomingCall = function(e, t, i) {
                            if (e.isP2P) this._onIncomingCallP2P(e, t);
                            else {
                                if (!this.isFocus(e.remoteJid)) {
                                    const t = "Rejecting session-initiate from non-focus.";
                                    return void this._rejectIncomingCall(e, {
                                        reason: "security-error",
                                        reasonDescription: t,
                                        errorMsg: t
                                    })
                                }
                                this._acceptJvbIncomingCall(e, t, i)
                            }
                        }, Mh.prototype._acceptJvbIncomingCall = function(e, t, i) {
                            this.jvbJingleSession = e, this.room.connectionTimes["session.initiate"] = i, this._sendConferenceJoinAnalyticsEvent(), this.wasStopped && Tn.sendAnalyticsAndLog(ui(Jt, {
                                p2p: !1
                            }));
                            const n = $(t).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("region");
                            this.eventEmitter.emit(ge, n), this._maybeClearSITimeout(), Tn.sendAnalytics(ui(Kt, {
                                p2p: !1,
                                value: i
                            }));
                            try {
                                e.initialize(this.room, this.rtc, this._signalingLayer, {
                                    ...this.options.config,
                                    enableInsertableStreams: this.isE2EEEnabled()
                                })
                            } catch (e) {
                                return Gi().callErrorHandler(e), void Dh.error(e)
                            }
                            this._setBridgeChannel(t, e.peerconnection);
                            const s = this._getInitialLocalTracks();
                            try {
                                e.acceptOffer(t, (() => {
                                    this.isP2PActive() && this.jvbJingleSession && this._suspendMediaTransferForJvbConnection(), this.eventEmitter.emit(_e, e), this.isP2PActive() || this.eventEmitter.emit(Se, e)
                                }), (e => {
                                    Gi().callErrorHandler(e), Dh.error("Failed to accept incoming Jingle session", e)
                                }), s), this._desktopSharingFrameRate && e.peerconnection.setDesktopSharingFrameRate(this._desktopSharingFrameRate), Dh.info("Starting CallStats for JVB connection..."), this.statistics.startCallStats(this.jvbJingleSession.peerconnection, "jitsi"), this.statistics.startRemoteStats(this.jvbJingleSession.peerconnection)
                            } catch (e) {
                                Gi().callErrorHandler(e), Dh.error(e)
                            }
                        }, Mh.prototype._setBridgeChannel = function(e, t) {
                            let i = null;
                            const n = $(e).find(">content>transport>web-socket").first();
                            1 === n.length && (i = n[0].getAttribute("url")), i ? this.rtc.initializeBridgeChannel(null, i) : this.rtc.initializeBridgeChannel(t, null)
                        }, Mh.prototype._rejectIncomingCall = function(e, t) {
                            null != t && t.errorMsg && Dh.warn(t.errorMsg), e.terminate(null, (e => {
                                Dh.warn("An error occurred while trying to terminate invalid Jingle session", e)
                            }), {
                                reason: t && t.reason,
                                reasonDescription: t && t.reasonDescription,
                                sendSessionTerminate: !0
                            })
                        }, Mh.prototype.onCallEnded = function(e, t, i) {
                            if (Dh.info(`Call ended: ${t} - ${i} P2P ?${e.isP2P}`), e === this.jvbJingleSession) this.wasStopped = !0, Tn.sendAnalytics(ui(Wt, {
                                p2p: !1
                            })), this.statistics && (this.statistics.stopRemoteStats(this.jvbJingleSession.peerconnection), Dh.info("Stopping JVB CallStats"), this.statistics.stopCallStats(this.jvbJingleSession.peerconnection)), this.jvbJingleSession = null, this.rtc.onCallEnded();
                            else if (e === this.p2pJingleSession) {
                                const e = {};
                                "decline" === t && "force JVB121" === i ? (Dh.info("In forced JVB 121 mode..."), Tn.analytics.addPermanentProperties({
                                    forceJvb121: !0
                                })) : "connectivity-error" === t && "ICE FAILED" === i ? Tn.analytics.addPermanentProperties({
                                    p2pFailed: !0
                                }) : "success" === t && "restart" === i && (e.requestRestart = !0), this._stopP2PSession(e)
                            } else Dh.error("Received onCallEnded for invalid session", e.sid, e.remoteJid, t, i)
                        }, Mh.prototype.onSuspendDetected = function(e) {
                            e.isP2P || (this.leave(), this.eventEmitter.emit(Fe))
                        }, Mh.prototype.updateDTMFSupport = function() {
                            let e = !1;
                            const t = this.getParticipants();
                            for (let i = 0; i < t.length; i += 1)
                                if (t[i].supportsDTMF()) {
                                    e = !0;
                                    break
                                } e !== this.somebodySupportsDTMF && (this.somebodySupportsDTMF = e, this.eventEmitter.emit(ae, e))
                        }, Mh.prototype.isDTMFSupported = function() {
                            return this.somebodySupportsDTMF
                        }, Mh.prototype.myUserId = function() {
                            return this.room && this.room.myroomjid ? ut.Strophe.getResourceFromJid(this.room.myroomjid) : null
                        }, Mh.prototype.sendTones = function(e, t, i) {
                            const n = this.getActivePeerConnection();
                            n ? n.sendTones(e, t, i) : Dh.warn("cannot sendTones: no peer connection")
                        }, Mh.prototype.startRecording = function(e) {
                            return this.room ? this.recordingManager.startRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
                        }, Mh.prototype.stopRecording = function(e) {
                            return this.room ? this.recordingManager.stopRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
                        }, Mh.prototype.isSIPCallingSupported = function() {
                            return !!this.room && this.room.isSIPCallingSupported()
                        }, Mh.prototype.dial = function(e) {
                            return this.room ? this.room.dial(e) : new Promise(((e, t) => {
                                t(new Error("The conference is not created yet!"))
                            }))
                        }, Mh.prototype.hangup = function() {
                            return this.room ? this.room.hangup() : new Promise(((e, t) => {
                                t(new Error("The conference is not created yet!"))
                            }))
                        }, Mh.prototype.startTranscriber = function() {
                            return this.dial("jitsi_meet_transcribe")
                        }, Mh.prototype.stopTranscriber = Mh.prototype.hangup, Mh.prototype.getPhoneNumber = function() {
                            return this.room ? this.room.getPhoneNumber() : null
                        }, Mh.prototype.getPhonePin = function() {
                            return this.room ? this.room.getPhonePin() : null
                        }, Mh.prototype.getMeetingUniqueId = function() {
                            if (this.room) return this.room.getMeetingId()
                        }, Mh.prototype.getActivePeerConnection = function() {
                            const e = this.isP2PActive() ? this.p2pJingleSession : this.jvbJingleSession;
                            return e ? e.peerconnection : null
                        }, Mh.prototype.getConnectionState = function() {
                            const e = this.getActivePeerConnection();
                            return e ? e.getConnectionState() : null
                        }, Mh.prototype.setStartMutedPolicy = function(e) {
                            this.isModerator() ? (this.startMutedPolicy = e, this.room.addOrReplaceInPresence("startmuted", {
                                attributes: {
                                    audio: e.audio,
                                    video: e.video,
                                    xmlns: "http://jitsi.org/jitmeet/start-muted"
                                }
                            }) && this.room.sendPresence()) : Dh.warn(`Failed to set start muted policy, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
                        }, Mh.prototype.getStartMutedPolicy = function() {
                            return this.startMutedPolicy
                        }, Mh.prototype.isStartAudioMuted = function() {
                            return this.startAudioMuted
                        }, Mh.prototype.isStartVideoMuted = function() {
                            return this.startVideoMuted
                        }, Mh.prototype.getConnectionTimes = function() {
                            return this.room.connectionTimes
                        }, Mh.prototype.setLocalParticipantProperty = function(e, t) {
                            this.sendCommand(`jitsi_participant_${e}`, {
                                value: t
                            })
                        }, Mh.prototype.removeLocalParticipantProperty = function(e) {
                            this.removeCommand(`jitsi_participant_${e}`), this.room.sendPresence()
                        }, Mh.prototype.getLocalParticipantProperty = function(e) {
                            const t = this.room.presMap.nodes.find((t => t.tagName === `jitsi_participant_${e}`));
                            return t ? t.value : void 0
                        }, Mh.prototype.sendFeedback = function(e, t) {
                            return this.statistics.sendFeedback(e, t)
                        }, Mh.prototype.isCallstatsEnabled = function() {
                            return this.statistics.isCallstatsEnabled()
                        }, Mh.prototype.getSsrcByTrack = function(e) {
                            var t;
                            return e.isLocal() ? null === (t = this.getActivePeerConnection()) || void 0 === t ? void 0 : t.getLocalSSRC(e) : e.getSSRC()
                        }, Mh.prototype._onTrackAttach = function(e, t) {
                            const i = e.isLocal();
                            let n = null;
                            const s = e.isP2P,
                                r = s ? e.getParticipantId() : "jitsi",
                                o = s ? this.p2pJingleSession && this.p2pJingleSession.peerconnection : this.jvbJingleSession && this.jvbJingleSession.peerconnection;
                            i ? o && (n = o.getLocalSSRC(e)) : n = e.getSSRC(), t.id && n && o && this.statistics.associateStreamWithVideoTag(o, n, i, r, e.getUsageLabel(), t.id)
                        }, Mh.prototype.sendApplicationLog = function(e) {
                            Tn.sendLog(e)
                        }, Mh.prototype.isFocus = function(e) {
                            return this.room ? this.room.isFocus(e) : null
                        }, Mh.prototype._fireIncompatibleVersionsEvent = function() {
                            this.eventEmitter.emit(X, x)
                        }, Mh.prototype.sendEndpointMessage = function(e, t) {
                            this.rtc.sendChannelMessage(e, t)
                        }, Mh.prototype.sendEndpointStatsMessage = function(e) {
                            this.rtc.sendEndpointStatsMessage(e)
                        }, Mh.prototype.broadcastEndpointMessage = function(e) {
                            this.sendEndpointMessage("", e)
                        }, Mh.prototype.sendMessage = function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                                i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                            const n = typeof e;
                            if ("object" === n || !i && "string" === n)
                                if (i) this.sendEndpointMessage(t, e);
                                else {
                                    let i = e,
                                        s = "body";
                                    if ("object" === n) {
                                        s = "json-message", i.hasOwnProperty(ta) || (i[ta] = "");
                                        try {
                                            i = JSON.stringify(i)
                                        } catch (e) {
                                            return void Dh.error("Can not send a message, stringify failed: ", e)
                                        }
                                    }
                                    t ? this.sendPrivateTextMessage(t, i, s) : this.sendTextMessage(i, s)
                                }
                            else Dh.error(`Can not send a message of type ${n}`)
                        }, Mh.prototype.isConnectionInterrupted = function() {
                            return this.isP2PActive() ? this.isP2PConnectionInterrupted : this.isJvbConnectionInterrupted
                        }, Mh.prototype._onConferenceRestarted = function(e) {
                            !e.isP2P && this.options.config.enableForcedReload && this.eventEmitter.emit(X, I)
                        }, Mh.prototype._onIceConnectionInterrupted = function(e) {
                            e.isP2P ? this.isP2PConnectionInterrupted = !0 : this.isJvbConnectionInterrupted = !0, e.isP2P === this.isP2PActive() && this.eventEmitter.emit(te)
                        }, Mh.prototype._onIceConnectionFailed = function(e) {
                            e.isP2P ? (Tn.analytics.addPermanentProperties({
                                p2pFailed: !0
                            }), this.p2pJingleSession && Tn.sendAnalyticsAndLog(pi(Zt, {
                                initiator: this.p2pJingleSession.isInitiator
                            })), this._stopP2PSession({
                                reason: "connectivity-error",
                                reasonDescription: "ICE FAILED"
                            })) : e && this.jvbJingleSession === e && (this._delayedIceFailed = new Zd(this), this._delayedIceFailed.start(e))
                        }, Mh.prototype._onIceConnectionRestored = function(e) {
                            e.isP2P ? this.isP2PConnectionInterrupted = !1 : (this.isJvbConnectionInterrupted = !1, this._delayedIceFailed && this._delayedIceFailed.cancel()), e.isP2P === this.isP2PActive() && this.eventEmitter.emit(ie)
                        }, Mh.prototype._acceptP2PIncomingCall = function(e, t) {
                            this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = e, this._sendConferenceJoinAnalyticsEvent(), this.p2pJingleSession.initialize(this.room, this.rtc, this._signalingLayer, {
                                ...this.options.config,
                                enableInsertableStreams: this.isE2EEEnabled()
                            }), Dh.info("Starting CallStats for P2P connection...");
                            let i = ut.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);
                            const n = this.participants[i];
                            n && (i = n.getStatsID() || i), this.statistics.startCallStats(this.p2pJingleSession.peerconnection, i);
                            const s = this.getLocalTracks();
                            this.p2pJingleSession.acceptOffer(t, (() => {
                                Dh.debug('Got RESULT for P2P "session-accept"'), this.eventEmitter.emit(_e, e)
                            }), (e => {
                                Dh.error("Failed to accept incoming P2P Jingle session", e)
                            }), s)
                        }, Mh.prototype._addRemoteJVBTracks = function() {
                            this._addRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
                        }, Mh.prototype._addRemoteP2PTracks = function() {
                            this._addRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
                        }, Mh.prototype._addRemoteTracks = function(e, t) {
                            for (const i of t) Dh.info(`Adding remote ${e} track: ${i}`), this.onRemoteTrackAdded(i)
                        }, Mh.prototype._onIceConnectionEstablished = function(e) {
                            null !== this.p2pJingleSession && (this.p2pEstablishmentDuration = this.p2pJingleSession.establishmentDuration), null !== this.jvbJingleSession && (this.jvbEstablishmentDuration = this.jvbJingleSession.establishmentDuration);
                            let t = !1;
                            const i = this.options.config.forceJVB121Ratio;
                            if (e.isP2P ? this.p2pJingleSession !== e ? (Dh.error("CONNECTION_ESTABLISHED - wrong P2P session instance ?!"), t = !0) : !e.isInitiator && "number" == typeof i && Math.random() < i && (Dh.info(`Forcing JVB 121 mode (ratio=${i})...`), Tn.analytics.addPermanentProperties({
                                    forceJvb121: !0
                                }), this._stopP2PSession({
                                    reason: "decline",
                                    reasonDescription: "force JVB121"
                                }), t = !0) : t = !0, !isNaN(this.p2pEstablishmentDuration) && !isNaN(this.jvbEstablishmentDuration)) {
                                const e = this.p2pEstablishmentDuration - this.jvbEstablishmentDuration;
                                Tn.sendAnalytics(ri, {
                                    value: e
                                })
                            }
                            e.isP2P === this.isP2PActive() && this.eventEmitter.emit(ee), t || (this._setP2PStatus(!0), this.jvbJingleSession ? this._removeRemoteJVBTracks() : Dh.info("Not removing remote JVB tracks - no session yet"), this._addRemoteP2PTracks(), this.jvbJingleSession && this._suspendMediaTransferForJvbConnection(), Dh.info("Starting remote stats with p2p connection"), this.statistics.startRemoteStats(this.p2pJingleSession.peerconnection), Tn.sendAnalyticsAndLog(pi(Yt, {
                                initiator: this.p2pJingleSession.isInitiator
                            })))
                        }, Mh.prototype._updateProperties = function() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            const t = !ht()(e, this.properties);
                            if (this.properties = e, t) {
                                this.eventEmitter.emit(De, this.properties);
                                const t = "true" === this.properties["audio-limit-reached"],
                                    i = "true" === this.properties["video-limit-reached"];
                                this._audioSenderLimitReached !== t && (this._audioSenderLimitReached = t, this.eventEmitter.emit(G, t), Dh.info(`Audio unmute permissions set by Jicofo to ${t}`)), this._videoSenderLimitReached !== i && (this._videoSenderLimitReached = i, this.eventEmitter.emit(Xe, i), Dh.info(`Video unmute permissions set by Jicofo to ${i}`)), ["bridge-count", "created-ms"].forEach((t => {
                                    void 0 !== e[t] && Tn.analytics.addPermanentProperties({
                                        [t.replace("-", "_")]: e[t]
                                    })
                                }))
                            }
                        }, Mh.prototype.getProperty = function(e) {
                            return this.properties[e]
                        }, Mh.prototype._maybeClearDeferredStartP2P = function() {
                            this.deferredStartP2PTask && (Dh.info("Cleared deferred start P2P task"), clearTimeout(this.deferredStartP2PTask), this.deferredStartP2PTask = null)
                        }, Mh.prototype._removeRemoteJVBTracks = function() {
                            this._removeRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
                        }, Mh.prototype._removeRemoteP2PTracks = function() {
                            this._removeRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
                        }, Mh.prototype._removeRemoteTracks = function(e, t) {
                            for (const i of t) Dh.info(`Removing remote ${e} track: ${i}`), this.onRemoteTrackRemoved(i)
                        }, Mh.prototype._resumeMediaTransferForJvbConnection = function() {
                            Dh.info("Resuming media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!0, !0).then((() => {
                                Dh.info("Resumed media transfer over the JVB connection!")
                            }), (e => {
                                Dh.error("Failed to resume media transfer over the JVB connection:", e)
                            }))
                        }, Mh.prototype._setP2PStatus = function(e) {
                            if (this.p2p !== e) {
                                if (this.p2p = e, e) {
                                    Dh.info("Peer to peer connection established!"), Tn.analytics.addPermanentProperties({
                                        p2pFailed: !1,
                                        forceJvb121: !1
                                    });
                                    const e = 0 !== this.getLastN();
                                    this.p2pJingleSession.setMediaTransferActive(!0, e).catch((t => {
                                        Dh.error(`Failed to sync up P2P video transfer status(${e})`, t)
                                    }))
                                } else Dh.info("Peer to peer connection closed!");
                                this.jvbJingleSession && this.statistics.sendConnectionResumeOrHoldEvent(this.jvbJingleSession.peerconnection, !e), this.dtmfManager = null, this.eventEmitter.emit(Ie, this, this.p2p), this.eventEmitter.emit(Se, this.getActiveMediaSession()), this.eventEmitter.emit(this.isConnectionInterrupted() ? te : ie)
                            } else Dh.debug(`Called _setP2PStatus with the same status: ${e}`)
                        }, Mh.prototype._startP2PSession = function(e) {
                            if (this._maybeClearDeferredStartP2P(), this.p2pJingleSession) return void Dh.error("P2P session already started!");
                            this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = this.xmpp.connection.jingle.newP2PJingleSession(this.room.myroomjid, e), Dh.info("Created new P2P JingleSession", this.room.myroomjid, e), this._sendConferenceJoinAnalyticsEvent(), this.p2pJingleSession.initialize(this.room, this.rtc, this._signalingLayer, {
                                ...this.options.config,
                                enableInsertableStreams: this.isE2EEEnabled()
                            }), Dh.info("Starting CallStats for P2P connection...");
                            let t = ut.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);
                            const i = this.participants[t];
                            i && (t = i.getStatsID() || t), this.statistics.startCallStats(this.p2pJingleSession.peerconnection, t);
                            const n = this.getLocalTracks();
                            this.p2pJingleSession.invite(n)
                        }, Mh.prototype._suspendMediaTransferForJvbConnection = function() {
                            Dh.info("Suspending media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!1, !1).then((() => {
                                Dh.info("Suspended media transfer over the JVB connection !")
                            }), (e => {
                                Dh.error("Failed to suspend media transfer over the JVB connection:", e)
                            }))
                        }, Mh.prototype._maybeStartOrStopP2P = function(e) {
                            if (!this.isP2PEnabled() || this.isP2PTestModeEnabled() || Ui.isFirefox() || Ui.isWebKitBased() || this.isE2EEEnabled()) return void Dh.info("Auto P2P disabled");
                            const t = this.getParticipants(),
                                i = t.length,
                                n = this._shouldBeInP2PMode();
                            if (!n && this.deferredStartP2PTask && this._maybeClearDeferredStartP2P(), !this.p2pJingleSession && n) {
                                const n = i && t[0],
                                    s = this.myUserId(),
                                    r = n.getId();
                                if (s > r) return void Dh.debug("I'm the bigger peersId - the other peer should start P2P", s, r);
                                if (s === r) return void Dh.error("The same IDs ? ", s, r);
                                const o = n.getJid();
                                if (e) {
                                    if (this.deferredStartP2PTask) return void Dh.error("Deferred start P2P task's been set already!");
                                    Dh.info(`Will start P2P with: ${o} after ${this.backToP2PDelay} seconds...`), this.deferredStartP2PTask = setTimeout(this._startP2PSession.bind(this, o), 1e3 * this.backToP2PDelay)
                                } else Dh.info(`Will start P2P with: ${o}`), this._startP2PSession(o)
                            } else this.p2pJingleSession && !n && (Dh.info(`Will stop P2P with: ${this.p2pJingleSession.remoteJid}`), this.p2pJingleSession.isInitiator && i > 1 && Tn.sendAnalyticsAndLog(pi(ei)), this._stopP2PSession())
                        }, Mh.prototype._shouldBeInP2PMode = function() {
                            const e = this.getParticipants(),
                                t = e.length,
                                i = void 0 !== e.find((e => "poltergeist" === e.getBotType() || e.hasFeature(ia))),
                                n = 1 === t && !i;
                            return Dh.debug(`P2P? peerCount: ${t}, hasBotPeer: ${i} => ${n}`), n
                        }, Mh.prototype._stopP2PSession = function() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            const {
                                reason: t = "success",
                                reasonDescription: i = "Turning off P2P session",
                                requestRestart: n = !1
                            } = e;
                            if (!this.p2pJingleSession) return void Dh.error("No P2P session to be stopped!");
                            const s = this.isP2PActive();
                            s && (this.jvbJingleSession && !n && this._resumeMediaTransferForJvbConnection(), this._removeRemoteP2PTracks()), Dh.info("Stopping remote stats for P2P connection"), this.statistics.stopRemoteStats(this.p2pJingleSession.peerconnection), Dh.info("Stopping CallStats for P2P connection"), this.statistics.stopCallStats(this.p2pJingleSession.peerconnection), this.p2pJingleSession.terminate((() => {
                                Dh.info("P2P session terminate RESULT")
                            }), (e => {
                                "success" !== t && Dh.error("An error occurred while trying to terminate P2P Jingle session", e)
                            }), {
                                reason: t,
                                reasonDescription: i,
                                sendSessionTerminate: this.room && this.getParticipantById(ut.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid))
                            }), this.p2pJingleSession = null, this._setP2PStatus(!1), s && (this.jvbJingleSession && !n ? this._addRemoteJVBTracks() : Dh.info("Not adding remote JVB tracks - no session yet"))
                        }, Mh.prototype._updateRoomPresence = function(e, t) {
                            if (!e) return;
                            if (t) {
                                if (t.skip) return;
                                t.skip = !0
                            }
                            let i, n, s = !1;
                            const r = e.peerconnection.getLocalTracks(),
                                o = r.filter((e => e.getType() === dn.AUDIO)),
                                a = r.filter((e => e.getType() === dn.VIDEO));
                            for (const e of r) i = this._setTrackMuteStatus(e.getType(), e, e.isMuted()), e.getType() === dn.VIDEO && (n = this._setNewVideoType(e)), s = s || i || n;
                            if (!hn.isMultiStreamSupportEnabled()) {
                                let e, t;
                                null != o && o.length || (e = this._setTrackMuteStatus(dn.AUDIO, void 0, !0)), null != a && a.length || (t = this._setTrackMuteStatus(dn.VIDEO, void 0, !0), n = this._setNewVideoType()), s = s || e || t || n
                            }
                            s && this.room.sendPresence()
                        }, Mh.prototype.isP2PActive = function() {
                            return this.p2p
                        }, Mh.prototype.getP2PConnectionState = function() {
                            return this.isP2PActive() ? this.p2pJingleSession.peerconnection.getConnectionState() : null
                        }, Mh.prototype.setDesktopSharingFrameRate = function(e) {
                            return "number" != typeof e || isNaN(e) ? (Dh.error(`Invalid value ${e} specified for desktop capture frame rate`), !1) : (this._desktopSharingFrameRate = e, this.jvbJingleSession && this.jvbJingleSession.peerconnection.setDesktopSharingFrameRate(e), this.rtc.setDesktopSharingFrameRate(e), !0)
                        }, Mh.prototype.startP2PSession = function() {
                            const e = this.getParticipants();
                            if (1 !== e.length) throw new Error("There must be exactly 1 participant to start the P2P session !"); {
                                const t = e[0].getJid();
                                this._startP2PSession(t)
                            }
                        }, Mh.prototype.stopP2PSession = function(e) {
                            this._stopP2PSession(e)
                        }, Mh.prototype.getSpeakerStats = function() {
                            return this.speakerStatsCollector.getStats()
                        }, Mh.prototype.sendFaceLandmarks = function(e) {
                            e.faceExpression && this.xmpp.sendFaceExpressionEvent(this.room.roomjid, e)
                        }, Mh.prototype.setReceiverConstraints = function(e) {
                            this.receiveVideoController.setReceiverConstraints(e)
                        }, Mh.prototype.setReceiverVideoConstraint = function(e) {
                            this.receiveVideoController.setPreferredReceiveMaxFrameHeight(e)
                        }, Mh.prototype.setSenderVideoConstraint = function(e) {
                            return this.sendVideoController.setPreferredSendMaxFrameHeight(e)
                        }, Mh.prototype.createVideoSIPGWSession = function(e, t) {
                            return this.room ? this.videoSIPGWHandler.createVideoSIPGWSession(e, t) : new Error(Eh)
                        }, Mh.prototype._sendConferenceJoinAnalyticsEvent = function() {
                            const e = this.getMeetingUniqueId();
                            !this._conferenceJoinAnalyticsEventSent && e && null !== this.getActivePeerConnection() && (Tn.sendAnalytics(di("joined", {
                                meetingId: e,
                                participantId: `${e}.${this._statsCurrentId}`
                            })), this._conferenceJoinAnalyticsEventSent = Date.now())
                        }, Mh.prototype._sendConferenceLeftAnalyticsEvent = function() {
                            const e = this.getMeetingUniqueId();
                            e && this._conferenceJoinAnalyticsEventSent && Tn.sendAnalytics(di("left", {
                                meetingId: e,
                                participantId: `${e}.${this._statsCurrentId}`,
                                stats: {
                                    duration: Math.floor((Date.now() - this._conferenceJoinAnalyticsEventSent) / 1e3),
                                    perf: this.getPerformanceStats()
                                }
                            }))
                        }, Mh.prototype._restartMediaSessions = function() {
                            this.p2pJingleSession && this._stopP2PSession({
                                reasonDescription: "restart",
                                requestRestart: !0
                            }), this.jvbJingleSession && this.jvbJingleSession.terminate(null, (e => {
                                Dh.warn("An error occurred while trying to terminate the JVB session", e)
                            }), {
                                reason: "success",
                                reasonDescription: "restart required",
                                requestRestart: !0,
                                sendSessionTerminate: !0
                            }), this._maybeStartOrStopP2P(!1)
                        }, Mh.prototype.isE2EEEnabled = function() {
                            return Boolean(this._e2eEncryption && this._e2eEncryption.isEnabled())
                        }, Mh.prototype.isE2EESupported = function() {
                            return Es.isSupported(this.options.config)
                        }, Mh.prototype.toggleE2EE = function(e) {
                            this.isE2EESupported() ? this._e2eEncryption.setEnabled(e) : Dh.warn("Cannot enable / disable E2EE: platform is not supported.")
                        }, Mh.prototype.setMediaEncryptionKey = function(e) {
                            this._e2eEncryption.setEncryptionKey(e)
                        }, Mh.prototype.isLobbySupported = function() {
                            return Boolean(this.room && this.room.getLobby().isSupported())
                        }, Mh.prototype.isMembersOnly = function() {
                            return Boolean(this.room && this.room.membersOnlyEnabled)
                        }, Mh.prototype.enableLobby = function() {
                            return this.room && this.isModerator() ? this.room.getLobby().enable() : Promise.reject(new Error("The conference not started or user is not moderator"))
                        }, Mh.prototype.disableLobby = function() {
                            this.room && this.isModerator() ? this.room.getLobby().disable() : Dh.warn(`Failed to disable lobby, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
                        }, Mh.prototype.joinLobby = function(e, t) {
                            return this.room ? this.room.getLobby().join(e, t) : Promise.reject(new Error("The conference not started"))
                        }, Mh.prototype.myLobbyUserId = function() {
                            if (this.room) return this.room.getLobby().getLocalId()
                        }, Mh.prototype.sendLobbyMessage = function(e, t) {
                            if (this.room) return t ? this.room.getLobby().sendPrivateMessage(t, e) : this.room.getLobby().sendMessage(e)
                        }, Mh.prototype.addLobbyMessageListener = function(e) {
                            if (this.room) return this.room.getLobby().addMessageListener(e)
                        }, Mh.prototype.removeLobbyMessageHandler = function(e) {
                            if (this.room) return this.room.getLobby().removeMessageHandler(e)
                        }, Mh.prototype.lobbyDenyAccess = function(e) {
                            this.room && this.room.getLobby().denyAccess(e)
                        }, Mh.prototype.lobbyApproveAccess = function(e) {
                            this.room && this.room.getLobby().approveAccess(e)
                        }, Mh.prototype.isAVModerationSupported = function() {
                            return Boolean(this.room && this.room.getAVModeration().isSupported())
                        }, Mh.prototype.enableAVModeration = function(e) {
                            this.room && this.isModerator() && (e === dn.AUDIO || e === dn.VIDEO) ? this.room.getAVModeration().enable(!0, e) : Dh.warn(`Failed to enable AV moderation, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
                        }, Mh.prototype.disableAVModeration = function(e) {
                            this.room && this.isModerator() && (e === dn.AUDIO || e === dn.VIDEO) ? this.room.getAVModeration().enable(!1, e) : Dh.warn(`Failed to disable AV moderation, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
                        }, Mh.prototype.avModerationApprove = function(e, t) {
                            if (this.room && this.isModerator() && (e === dn.AUDIO || e === dn.VIDEO)) {
                                const i = this.getParticipantById(t);
                                if (!i) return;
                                this.room.getAVModeration().approve(e, i.getJid())
                            } else Dh.warn(`AV moderation approve skipped , ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
                        }, Mh.prototype.avModerationReject = function(e, t) {
                            if (this.room && this.isModerator() && (e === dn.AUDIO || e === dn.VIDEO)) {
                                const i = this.getParticipantById(t);
                                if (!i) return;
                                this.room.getAVModeration().reject(e, i.getJid())
                            } else Dh.warn(`AV moderation reject skipped , ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
                        }, Mh.prototype.getBreakoutRooms = function() {
                            var e;
                            return null === (e = this.room) || void 0 === e ? void 0 : e.getBreakoutRooms()
                        }, Oh.prototype.connect = function() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            this.xmpp.connect(e.id, e.password)
                        }, Oh.prototype.attach = function(e) {
                            this.xmpp.attach(e)
                        }, Oh.prototype.disconnect = function() {
                            return this.xmpp.disconnect(...arguments)
                        }, Oh.prototype.getJid = function() {
                            return this.xmpp.getJid()
                        }, Oh.prototype.setToken = function(e) {
                            this.token = e
                        }, Oh.prototype.initJitsiConference = function(e, t) {
                            return new Mh({
                                name: e,
                                config: t,
                                connection: this
                            })
                        }, Oh.prototype.addEventListener = function(e, t) {
                            this.xmpp.addListener(e, t)
                        }, Oh.prototype.removeEventListener = function(e, t) {
                            this.xmpp.removeListener(e, t)
                        }, Oh.prototype.getConnectionTimes = function() {
                            return this.xmpp.connectionTimes
                        }, Oh.prototype.addFeature = function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                            this.xmpp.caps.addFeature(e, t, !0)
                        }, Oh.prototype.removeFeature = function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                            this.xmpp.caps.removeFeature(e, t, !0)
                        }, Oh.prototype.getLogs = function() {
                            const e = this.xmpp.getJingleLog(),
                                t = {};
                            t.time = new Date, t.url = window.location.href, t.ua = navigator.userAgent;
                            const i = this.xmpp.getXmppLog();
                            return i && (t.xmpp = i), e.metadata = t, e
                        },
                        function(e) {
                            e.DEVICE_LIST_CHANGED = "mediaDevices.devicechange", e.PERMISSIONS_CHANGED = "rtc.permissions_changed", e.PERMISSION_PROMPT_IS_SHOWN = "mediaDevices.permissionPromptIsShown", e.SLOW_GET_USER_MEDIA = "mediaDevices.slowGetUserMedia"
                        }(wh || (wh = {}));
                    const Lh = wh.DEVICE_LIST_CHANGED,
                        kh = wh.PERMISSIONS_CHANGED,
                        xh = wh.PERMISSION_PROMPT_IS_SHOWN,
                        Fh = wh.SLOW_GET_USER_MEDIA,
                        Vh = "microphone",
                        Uh = "camera",
                        jh = new class {
                            constructor() {
                                this._eventEmitter = new(dt()), this._permissions = {}, Hd.addListener(Rn.default.DEVICE_LIST_CHANGED, (e => this._eventEmitter.emit(Lh, e))), Hd.addListener(Rn.default.DEVICE_LIST_AVAILABLE, (e => this._logOutputDevice(this.getAudioOutputDevice(), e))), Hd.addListener(Rn.default.PERMISSIONS_CHANGED, (e => this._handlePermissionsChange(e))), this._permissionsApiSupported = new Promise((e => {
                                    if (!navigator.permissions) return void e(!1);
                                    const t = this,
                                        i = [];
                                    i.push(navigator.permissions.query({
                                        name: Uh
                                    }).then((e => (this._handlePermissionsChange({
                                        [dn.VIDEO]: this._parsePermissionState(e)
                                    }), e.onchange = function() {
                                        try {
                                            t._handlePermissionsChange({
                                                [dn.VIDEO]: t._parsePermissionState(this)
                                            })
                                        } catch (e) {}
                                    }, !0))).catch((() => !1))), i.push(navigator.permissions.query({
                                        name: Vh
                                    }).then((e => (this._handlePermissionsChange({
                                        [dn.AUDIO]: this._parsePermissionState(e)
                                    }), e.onchange = function() {
                                        try {
                                            t._handlePermissionsChange({
                                                [dn.AUDIO]: t._parsePermissionState(this)
                                            })
                                        } catch (e) {}
                                    }, !0))).catch((() => !1))), Promise.all(i).then((t => e(t.every((e => e)))))
                                }))
                            }
                            _parsePermissionState() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                const t = e.state || e.status;
                                if ("string" != typeof t) throw new TypeError;
                                return "granted" === t
                            }
                            _handlePermissionsChange(e) {
                                [dn.AUDIO, dn.VIDEO].some((t => t in e && e[t] !== this._permissions[t])) && (this._permissions = {
                                    ...this._permissions,
                                    ...e
                                }, this._eventEmitter.emit(kh, this._permissions), (this._permissions[dn.AUDIO] || this._permissions[dn.VIDEO]) && this.enumerateDevices((() => {})))
                            }
                            _logOutputDevice(e, t) {
                                const i = t.find((t => "audiooutput" === t.kind && t.deviceId === e));
                                i && Tn.sendActiveDeviceListEvent(Hd.getEventDataForActiveDevice(i))
                            }
                            enumerateDevices(e) {
                                Hd.enumerateDevices(e)
                            }
                            isDeviceListAvailable() {
                                return Hd.isDeviceListAvailable()
                            }
                            isDeviceChangeAvailable(e) {
                                return Hd.isDeviceChangeAvailable(e)
                            }
                            isDevicePermissionGranted(e) {
                                return new Promise((t => {
                                    e in this._permissions ? t(this._permissions[e]) : this._permissionsApiSupported.then((i => {
                                        if (!i) return void t(!1);
                                        const n = [];
                                        switch (e) {
                                            case dn.VIDEO:
                                                n.push(navigator.permissions.query({
                                                    name: Uh
                                                }));
                                                break;
                                            case dn.AUDIO:
                                                n.push(navigator.permissions.query({
                                                    name: Vh
                                                }));
                                                break;
                                            default:
                                                n.push(navigator.permissions.query({
                                                    name: Uh
                                                })), n.push(navigator.permissions.query({
                                                    name: Vh
                                                }))
                                        }
                                        Promise.all(n).then((e => t(e.every((e => {
                                            try {
                                                return this._parsePermissionState(e)
                                            } catch {
                                                return !1
                                            }
                                        })))), (() => t(!1)))
                                    }))
                                }))
                            }
                            isMultipleAudioInputSupported() {
                                return !(Ui.isFirefox() && Ui.isVersionLessThan("101") || Ui.isIosBrowser())
                            }
                            getAudioOutputDevice() {
                                return Hd.getAudioOutputDevice()
                            }
                            setAudioOutputDevice(e) {
                                return Hd.getCurrentlyAvailableMediaDevices().length > 0 && this._logOutputDevice(e, Hd.getCurrentlyAvailableMediaDevices()), Hd.setAudioOutputDevice(e)
                            }
                            addEventListener(e, t) {
                                this._eventEmitter.addListener(e, t)
                            }
                            removeEventListener(e, t) {
                                this._eventEmitter.removeListener(e, t)
                            }
                            emitEvent(e) {
                                for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];
                                this._eventEmitter.emit(e, ...i)
                            }
                        },
                        $h = (0, v.getLogger)("modules/detection/ActiveDeviceDetector.js");

                    function Hh(e) {
                        for (const t of e) t.stopStream()
                    }
                    let Bh;
                    ! function(e) {
                        e.ACCEPT = "session-accept", e.CONNECTION_ERROR = "connection-error-encountered", e.INITIATE = "session-initiate", e.TERMINATE = "session-terminate", e.TRANSPORT_INFO = "transport-info", e.UNAVAILABLE = "unavailable"
                    }(Bh || (Bh = {}));
                    const Jh = (0, v.getLogger)("modules/proxyconnection/ProxyConnectionPC.js");
                    class Gh {
                        constructor() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            this._options = {
                                pcConfig: {},
                                isInitiator: !1,
                                receiveAudio: !1,
                                receiveVideo: !1,
                                ...e
                            }, this._tracks = [], this._peerConnection = null, this._onError = this._onError.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this), this._onSendMessage = this._onSendMessage.bind(this)
                        }
                        getPeerJid() {
                            return this._options.peerJid
                        }
                        processMessage(e) {
                            switch (e.attr("action")) {
                                case Bh.ACCEPT:
                                    this._onSessionAccept(e);
                                    break;
                                case Bh.INITIATE:
                                    this._onSessionInitiate(e);
                                    break;
                                case Bh.TERMINATE:
                                    this._onSessionTerminate(e);
                                    break;
                                case Bh.TRANSPORT_INFO:
                                    this._onTransportInfo(e)
                            }
                        }
                        start() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                            this._peerConnection || (this._tracks = this._tracks.concat(e), this._peerConnection = this._createPeerConnection(), this._peerConnection.invite(e))
                        }
                        stop() {
                            this._peerConnection && this._peerConnection.terminate(), this._onSessionTerminate()
                        }
                        _createPeerConnection() {
                            const e = {
                                    connected: !0,
                                    jingle: {
                                        terminate: () => {}
                                    },
                                    sendIQ: this._onSendMessage,
                                    addEventListener: () => () => {}
                                },
                                t = {
                                    iceServers: ea,
                                    ...this._options.pcConfig
                                },
                                i = {
                                    addPresenceListener: () => {},
                                    connectionTimes: [],
                                    eventEmitter: {
                                        emit: e => {
                                            switch (e) {
                                                case Nn.XMPPEvents.CONNECTION_ICE_FAILED:
                                                case Nn.XMPPEvents.CONNECTION_FAILED:
                                                    this._onError(Bh.CONNECTION_ERROR, e)
                                            }
                                        }
                                    },
                                    getMediaPresenceInfo: () => ({}),
                                    removePresenceListener: () => {},
                                    supportsRestartByTerminate: () => !1
                                };
                            this._rtc = new Hd({
                                myUserId: () => ""
                            }, {}), this._rtc.addListener(Rn.default.REMOTE_TRACK_ADDED, this._onRemoteStream);
                            const n = new jo(void 0, void 0, this._options.peerJid, e, {
                                    offerToReceiveAudio: this._options.receiveAudio,
                                    offerToReceiveVideo: this._options.receiveVideo
                                }, t, !0, this._options.isInitiator),
                                s = new Nh;
                            return s.setChatRoom(i), n.initialize(i, this._rtc, s, {}), n
                        }
                        _onError(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                            this._options.onError(this._options.peerJid, e, t)
                        }
                        _onRemoteStream(e) {
                            this._tracks.push(e), this._options.onRemoteStream(e)
                        }
                        _onSendMessage(e) {
                            this._options.onSendMessage(this._options.peerJid, e)
                        }
                        _onSessionAccept(e) {
                            this._peerConnection ? this._peerConnection.setAnswer(e) : Jh.error("Received an answer when no peer connection exists.")
                        }
                        _onSessionInitiate(e) {
                            this._peerConnection ? Jh.error("Received an offer when an offer was already sent.") : (this._peerConnection = this._createPeerConnection(), this._peerConnection.acceptOffer(e, (() => {}), (() => this._onError(this._options.peerJid, Bh.CONNECTION_ERROR, "session initiate error"))))
                        }
                        _onSessionTerminate() {
                            this._tracks.forEach((e => e.dispose())), this._tracks = [], this._peerConnection && this._peerConnection.onTerminated(), this._rtc && (this._rtc.removeListener(Rn.default.REMOTE_TRACK_ADDED, this._onRemoteStream), this._rtc.destroy())
                        }
                        _onTransportInfo(e) {
                            this._peerConnection.addIceCandidates(e)
                        }
                    }
                    const Kh = (0, v.getLogger)("modules/proxyconnection/ProxyConnectionService.js"),
                        qh = "preCallTestResults",
                        Wh = new(dt());
                    let Xh = !1,
                        zh = null;
                    const Qh = {
                        init: async function(e) {
                            if (Xh) throw new Error("Precall Test already initialized");
                            const {
                                callStatsID: t,
                                callStatsSecret: i,
                                disableThirdPartyRequests: n
                            } = e;
                            if (!t || !i || n) throw new Error("Callstats is disabled");
                            return await
                            function(e) {
                                if (!Ui.isReactNative()) return new Promise((t => {
                                    $i().loadScript(e.callStatsCustomScriptUrl || pt, !0, !0, void 0, t)
                                }))
                            }(e), zh = new window.callstats,
                                function(e) {
                                    return new Promise(((t, i) => {
                                        const n = e.callStatsID,
                                            s = e.callStatsSecret,
                                            r = e.statisticsId || e.statisticsDisplayName || or.callStatsUserName;
                                        zh.initialize(n, s, r, ((e, n) => {
                                            "success" === e ? (zh.on(qh, (function() {
                                                for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                                                Wh.emit(qh, ...t)
                                            })), Xh = !0, t()) : i({
                                                status: e,
                                                message: n
                                            })
                                        }), null, {
                                            disablePrecalltest: !0
                                        })
                                    }))
                                }(e)
                        },
                        execute: function() {
                            return Xh ? new Promise(((e, t) => {
                                Wh.on(qh, ((i, n) => {
                                    "success" === i ? e(n) : t({
                                        status: i,
                                        payload: n
                                    })
                                })), zh.makePrecallTest()
                            })) : Promise.reject("uninitialized")
                        }
                    };
                    var Yh = i(4424),
                        Zh = i.n(Yh);
                    const eu = (0, v.getLogger)("modules/webaudio/AudioMixer.js");
                    class tu {
                        constructor() {
                            this._started = !1, this._streamsToMix = [], this._streamMSSArray = []
                        }
                        addMediaStream(e) {
                            e.getAudioTracks() || eu.warn("Added MediaStream doesn't contain audio tracks."), this._streamsToMix.push(e)
                        }
                        start() {
                            if (this._started) return this._mixedMSD.stream;
                            if (this._audioContext = ll(), !this._streamsToMix.length) return eu.warn("No MediaStream's added to AudioMixer, nothing will happen."), null;
                            this._started = !0, this._mixedMSD = this._audioContext.createMediaStreamDestination();
                            for (const e of this._streamsToMix) {
                                const t = this._audioContext.createMediaStreamSource(e);
                                t.connect(this._mixedMSD), this._streamMSSArray.push(t)
                            }
                            return this._mixedMSD.stream
                        }
                        reset() {
                            this._started = !1, this._streamsToMix = [];
                            for (const e of this._streamMSSArray) e.disconnect();
                            this._streamMSSArray = [], this._audioContext && (this._audioContext = void 0)
                        }
                    }
                    const iu = E().getLogger("JitsiMeetJS.js");

                    function nu(e) {
                        const t = {
                            audio_requested: e.devices.includes("audio"),
                            video_requested: e.devices.includes("video"),
                            screen_sharing_requested: e.devices.includes("desktop")
                        };
                        return t.video_requested && (t.resolution = e.resolution), t
                    }
                    const su = function(e) {
                        return "object" == typeof window.JitsiMeetJS ? Object.assign({}, window.JitsiMeetJS, e) : e
                    }({
                        version: "6d5ca18b",
                        JitsiConnection: Oh,
                        ProxyConnectionService: class {
                            constructor() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                const {
                                    jitsiConnection: t,
                                    ...i
                                } = e;
                                this._options = {
                                    pcConfig: t && t.xmpp.connection.jingle.p2pIceConfig,
                                    ...i
                                }, this._peerConnection = null, this._onFatalError = this._onFatalError.bind(this), this._onSendMessage = this._onSendMessage.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this)
                            }
                            processMessage(e) {
                                const t = e.from;
                                if (!t) return;
                                if (this._peerConnection && this._peerConnection.getPeerJid() !== t) return void this._onFatalError(t, Bh.CONNECTION_ERROR, "rejected");
                                const i = this._convertStringToXML(e.data.iq),
                                    n = i && i.find("jingle"),
                                    s = n && n.attr("action");
                                s === Bh.INITIATE && (this._peerConnection = this._createPeerConnection(t, {
                                    isInitiator: !1,
                                    receiveVideo: !0
                                })), this._peerConnection && this._peerConnection.processMessage(n), s !== Bh.CONNECTION_ERROR && s !== Bh.UNAVAILABLE && s !== Bh.TERMINATE || this._selfCloseConnection()
                            }
                            start(e) {
                                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                                this._peerConnection = this._createPeerConnection(e, {
                                    isInitiator: !0,
                                    receiveVideo: !1
                                }), this._peerConnection.start(t)
                            }
                            stop() {
                                this._peerConnection && this._peerConnection.stop(), this._peerConnection = null
                            }
                            _convertStringToXML(e) {
                                try {
                                    const t = (new DOMParser).parseFromString(e, "text/xml");
                                    return $(t)
                                } catch (e) {
                                    return Kh.error("Attempted to convert incorrectly formatted xml"), null
                                }
                            }
                            _createPeerConnection(e) {
                                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                if (!e) throw new Error("Cannot create ProxyConnectionPC without a peer.");
                                const i = {
                                    pcConfig: this._options.pcConfig,
                                    onError: this._onFatalError,
                                    onRemoteStream: this._onRemoteStream,
                                    onSendMessage: this._onSendMessage,
                                    peerJid: e,
                                    ...t
                                };
                                return new Gh(i)
                            }
                            _onFatalError(e, t) {
                                let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
                                Kh.error("Received a proxy connection error", e, t, i);
                                const n = (0, ut.$iq)({
                                    to: e,
                                    type: "set"
                                }).c("jingle", {
                                    xmlns: "urn:xmpp:jingle:1",
                                    action: t
                                }).c("details").t(i).up();
                                this._onSendMessage(e, n), this._peerConnection && this._peerConnection.getPeerJid() === e && this._selfCloseConnection()
                            }
                            _onRemoteStream(e) {
                                if (!this._options.onRemoteStream) return Kh.error("Remote track received without callback."), void e.dispose();
                                const t = e.isVideoTrack();
                                let i;
                                t && (i = this._options.convertVideoToDesktop ? An.VideoType.DESKTOP : An.VideoType.CAMERA);
                                const n = e.getOriginalStream(),
                                    s = Hd.createLocalTracks([{
                                        deviceId: `proxy:${this._peerConnection.getPeerJid()}`,
                                        mediaType: t ? dn.VIDEO : dn.AUDIO,
                                        sourceType: "proxy",
                                        stream: n,
                                        track: n.getVideoTracks()[0],
                                        videoType: i
                                    }]);
                                this._options.onRemoteStream(s[0])
                            }
                            _onSendMessage(e, t) {
                                if (this._options.onSendMessage) try {
                                    const i = (new XMLSerializer).serializeToString(t.nodeTree || t);
                                    this._options.onSendMessage(e, {
                                        iq: i
                                    })
                                } catch (e) {
                                    Kh.error("Attempted to send an incorrectly formatted iq.")
                                }
                            }
                            _selfCloseConnection() {
                                this.stop(), this._options.onConnectionClosed && this._options.onConnectionClosed()
                            }
                        },
                        constants: {
                            participantConnectionStatus: wn,
                            recording: {
                                error: {
                                    BUSY: "busy",
                                    ERROR: "error",
                                    RESOURCE_CONSTRAINT: "resource-constraint",
                                    UNEXPECTED_REQUEST: "unexpected-request",
                                    SERVICE_UNAVAILABLE: "service-unavailable"
                                },
                                mode: {
                                    FILE: "file",
                                    STREAM: "stream"
                                },
                                status: {
                                    OFF: "off",
                                    ON: "on",
                                    PENDING: "pending"
                                }
                            },
                            sipVideoGW: _,
                            transcriptionStatus: d,
                            trackStreamingStatus: vd
                        },
                        events: {
                            conference: s,
                            connection: a,
                            detection: f,
                            track: o,
                            mediaDevices: S,
                            connectionQuality: m,
                            e2eping: g
                        },
                        errors: {
                            conference: n,
                            connection: c,
                            track: r
                        },
                        errorTypes: {
                            JitsiTrackError: Nt
                        },
                        logLevels: E().levels,
                        mediaDevices: jh,
                        analytics: Tn.analytics,
                        init() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                            if (or.init(e.externalStorage), Tn.init(e), void 0 !== e.enableUnifiedOnChrome && e.flags && (e.flags.enableUnifiedOnChrome = e.enableUnifiedOnChrome), hn.init(e.flags || {}), window.connectionTimes || (window.connectionTimes = {}), !0 !== e.enableAnalyticsLogging && (iu.warn("Analytics disabled, disposing."), this.analytics.dispose()), e.enableWindowOnErrorHandler && Gi().addHandler(this.getGlobalOnErrorHandler.bind(this)), this.version) {
                                const e = {
                                    id: "component_version",
                                    component: "lib-jitsi-meet",
                                    version: this.version
                                };
                                Tn.sendLog(JSON.stringify(e))
                            }
                            return Hd.init(e)
                        },
                        isDesktopSharingEnabled: () => Hd.isDesktopSharingEnabled(),
                        isWebRtcSupported: () => Hd.isWebRtcSupported(),
                        setLogLevel(e) {
                            E().setLogLevel(e)
                        },
                        setLogLevelById(e, t) {
                            E().setLogLevelById(e, t)
                        },
                        addGlobalLogTransport(e) {
                            E().addGlobalTransport(e)
                        },
                        removeGlobalLogTransport(e) {
                            E().removeGlobalTransport(e)
                        },
                        setGlobalLogOptions(e) {
                            E().setGlobalOptions(e)
                        },
                        createLocalTracks() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                                t = arguments.length > 1 ? arguments[1] : void 0,
                                i = !1;
                            const {
                                firePermissionPromptIsShownEvent: n,
                                fireSlowPromiseEvent: s,
                                ...r
                            } = e;
                            return !n && !t || Hd.arePermissionsGrantedForAvailableDevices() ? s && window.setTimeout((() => {
                                i || jh.emitEvent(Fh)
                            }), 1e3) : jh.emitEvent(xh, Ui.getName()), window.connectionTimes || (window.connectionTimes = {}), window.connectionTimes["obtainPermissions.start"] = window.performance.now(), Hd.obtainAudioAndVideoPermissions(r).then((e => {
                                if (i = !0, window.connectionTimes["obtainPermissions.end"] = window.performance.now(), Tn.sendAnalytics(hi("success", nu(r))), !Hd.options.disableAudioLevels)
                                    for (let t = 0; t < e.length; t++) {
                                        const i = e[t];
                                        i.getType() === dn.AUDIO && Tn.startLocalStats(i, i.setAudioLevel.bind(i))
                                    }
                                const t = Hd.getCurrentlyAvailableMediaDevices();
                                if (t)
                                    for (let i = 0; i < e.length; i++) e[i]._setRealDeviceIdFromDeviceList(t);
                                for (const t of e) t.type === dn.VIDEO && "desktop" === t.videoType && this.setVideoTrackContentHints(t.track, "detail");
                                return e
                            })).catch((t => {
                                if (i = !0, t.name === Tt) {
                                    const e = {
                                        id: "screensharing_user_canceled",
                                        message: t.message
                                    };
                                    Tn.sendLog(JSON.stringify(e)), Tn.sendAnalytics(hi("warning", {
                                        reason: "extension install user canceled"
                                    }))
                                } else if (t.name === vt) {
                                    const i = {
                                        id: "usermedia_missing_device",
                                        status: t.gum.devices
                                    };
                                    Tn.sendLog(JSON.stringify(i));
                                    const n = nu(e);
                                    n.reason = "device not found", n.devices = t.gum.devices.join("."), Tn.sendAnalytics(hi("error", n))
                                } else {
                                    Tn.sendGetUserMediaFailed(t);
                                    const i = nu(e);
                                    i.reason = t.name, Tn.sendAnalytics(hi("error", i))
                                }
                                return window.connectionTimes["obtainPermissions.end"] = window.performance.now(), Promise.reject(t)
                            }))
                        },
                        createTrackVADEmitter: (e, t, i) => hl.create(e, t, i),
                        createAudioMixer: () => new tu,
                        getActiveAudioDevice: () => new Promise((e => {
                            Hd.enumerateDevices((t => {
                                const i = t.filter((e => "audioinput" === e.kind)),
                                    n = [];
                                for (const e of i) {
                                    const t = Hd.obtainAudioAndVideoPermissions({
                                        devices: ["audio"],
                                        micDeviceId: e.deviceId
                                    }).then((e => {
                                        const t = e[0];
                                        return Tn.startLocalStats(t, t.setAudioLevel.bind(t)), t
                                    }));
                                    n.push(t)
                                }
                                Promise.allSettled(n).then((t => {
                                    const i = t.filter((e => "fulfilled" === e.status)),
                                        n = t.filter((e => "rejected" === e.status)),
                                        s = i.map((e => e.value)),
                                        r = n.map((e => e.value));
                                    for (const e of r) $h.error("Failed to acquire audio device with error: ", e);
                                    for (const t of s) t.on(Ot, (i => {
                                        i > .008 && (Hh(s), e({
                                            deviceId: t.deviceId,
                                            deviceLabel: t.track.label
                                        }))
                                    }));
                                    setTimeout((() => {
                                        Hh(s), e({
                                            deviceId: "",
                                            deviceLabel: ""
                                        })
                                    }), 3e3)
                                }))
                            }))
                        })),
                        isDeviceListAvailable() {
                            return iu.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceListAvailable instead"), this.mediaDevices.isDeviceListAvailable()
                        },
                        isDeviceChangeAvailable(e) {
                            return iu.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead"), this.mediaDevices.isDeviceChangeAvailable(e)
                        },
                        isMultipleAudioInputSupported() {
                            return this.mediaDevices.isMultipleAudioInputSupported()
                        },
                        isCollectingLocalStats: () => Tn.audioLevelsEnabled && tn.isLocalStatsSupported(),
                        enumerateDevices(e) {
                            iu.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.enumerateDevices instead"), this.mediaDevices.enumerateDevices(e)
                        },
                        getGlobalOnErrorHandler(e, t, i, n, s) {
                            iu.error(`UnhandledError: ${e}`, `Script: ${t}`, `Line: ${i}`, `Column: ${n}`, "StackTrace: ", s), Tn.reportGlobalError(s)
                        },
                        setNetworkInfo(e) {
                            let {
                                isOnline: t
                            } = e;
                            Ds.updateNetworkInfo({
                                isOnline: t
                            })
                        },
                        setVideoTrackContentHints(e, t) {
                            "contentHint" in e ? (e.contentHint = t, e.contentHint !== t && iu.debug("Invalid video track contentHint")) : iu.debug("MediaStreamTrack contentHint attribute not supported")
                        },
                        precallTest: Qh,
                        util: {
                            AuthUtil: Zh(),
                            ScriptUtil: $i(),
                            browser: Ui
                        }
                    })
                }
            },
            __webpack_module_cache__ = {};

        function __webpack_require__(e) {
            var t = __webpack_module_cache__[e];
            if (void 0 !== t) return t.exports;
            var i = __webpack_module_cache__[e] = {
                id: e,
                loaded: !1,
                exports: {}
            };
            return __webpack_modules__[e].call(i.exports, i, i.exports, __webpack_require__), i.loaded = !0, i.exports
        }
        __webpack_require__.amdO = {}, __webpack_require__.n = e => {
            var t = e && e.__esModule ? () => e.default : () => e;
            return __webpack_require__.d(t, {
                a: t
            }), t
        }, __webpack_require__.d = (e, t) => {
            for (var i in t) __webpack_require__.o(t, i) && !__webpack_require__.o(e, i) && Object.defineProperty(e, i, {
                enumerable: !0,
                get: t[i]
            })
        }, __webpack_require__.g = function() {
            if ("object" == typeof globalThis) return globalThis;
            try {
                return this || new Function("return this")()
            } catch (e) {
                if ("object" == typeof window) return window
            }
        }(), __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), __webpack_require__.r = e => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, __webpack_require__.nmd = e => (e.paths = [], e.children || (e.children = []), e);
        var __webpack_exports__ = __webpack_require__(4449);
        return __webpack_exports__
    })()
}));