! function(e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.JitsiMeetJS = t() : e.JitsiMeetJS = t()
}(window, (function() {
    return function(e) {
        var t = {};

        function n(i) {
            if (t[i]) return t[i].exports;
            var s = t[i] = {
                i: i,
                l: !1,
                exports: {}
            };
            return e[i].call(s.exports, s, s.exports, n), s.l = !0, s.exports
        }
        return n.m = e, n.c = t, n.d = function(e, t, i) {
            n.o(e, t) || Object.defineProperty(e, t, {
                enumerable: !0,
                get: i
            })
        }, n.r = function(e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, n.t = function(e, t) {
            if (1 & t && (e = n(e)), 8 & t) return e;
            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
            var i = Object.create(null);
            if (n.r(i), Object.defineProperty(i, "default", {
                    enumerable: !0,
                    value: e
                }), 2 & t && "string" != typeof e)
                for (var s in e) n.d(i, s, function(t) {
                    return e[t]
                }.bind(null, s));
            return i
        }, n.n = function(e) {
            var t = e && e.__esModule ? function() {
                return e.default
            } : function() {
                return e
            };
            return n.d(t, "a", t), t
        }, n.o = function(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }, n.p = "", n(n.s = 150)
    }([function(e, t) {
        e.exports = {
            ADD_ICE_CANDIDATE_FAILED: "xmpp.add_ice_candidate_failed",
            AUDIO_MUTED_BY_FOCUS: "xmpp.audio_muted_by_focus",
            VIDEO_MUTED_BY_FOCUS: "xmpp.video_muted_by_focus",
            AUTHENTICATION_REQUIRED: "xmpp.authentication_required",
            BRIDGE_DOWN: "xmpp.bridge_down",
            CALL_ACCEPTED: "xmpp.callaccepted.jingle",
            CALL_INCOMING: "xmpp.callincoming.jingle",
            CALL_ENDED: "xmpp.callended.jingle",
            CHAT_ERROR_RECEIVED: "xmpp.chat_error_received",
            CONFERENCE_PROPERTIES_CHANGED: "xmpp.conference_properties_changed",
            CONNECTION_ESTABLISHED: "xmpp.connection.connected",
            CONNECTION_FAILED: "xmpp.connection.failed",
            CONNECTION_INTERRUPTED: "xmpp.connection.interrupted",
            CONNECTION_RESTORED: "xmpp.connection.restored",
            CONNECTION_ICE_FAILED: "xmpp.connection.ice.failed",
            CONNECTION_RESTARTED: "xmpp.connection.restart",
            CONNECTION_STATUS_CHANGED: "xmpp.connection.status.changed",
            DISPLAY_NAME_CHANGED: "xmpp.display_name_changed",
            EMUC_ROOM_ADDED: "xmpp.emuc_room_added",
            EMUC_ROOM_REMOVED: "xmpp.emuc_room_removed",
            ETHERPAD: "xmpp.etherpad",
            FOCUS_DISCONNECTED: "xmpp.focus_disconnected",
            FOCUS_LEFT: "xmpp.focus_left",
            GRACEFUL_SHUTDOWN: "xmpp.graceful_shutdown",
            ICE_RESTARTING: "rtc.ice_restarting",
            ICE_RESTART_SUCCESS: "rtc.ice_restart_success",
            KICKED: "xmpp.kicked",
            LOCAL_ROLE_CHANGED: "xmpp.localrole_changed",
            MEETING_ID_SET: "xmpp.meeting_id_set",
            MESSAGE_RECEIVED: "xmpp.message_received",
            INVITE_MESSAGE_RECEIVED: "xmpp.invite_message_received",
            PRIVATE_MESSAGE_RECEIVED: "xmpp.private_message_received",
            MUC_MEMBER_BOT_TYPE_CHANGED: "xmpp.muc_member_bot_type_changed",
            MUC_DESTROYED: "xmpp.muc_destroyed",
            MUC_JOINED: "xmpp.muc_joined",
            MUC_MEMBER_JOINED: "xmpp.muc_member_joined",
            MUC_MEMBER_LEFT: "xmpp.muc_member_left",
            MUC_LOBBY_MEMBER_JOINED: "xmpp.muc_lobby_member_joined",
            MUC_LOBBY_MEMBER_UPDATED: "xmpp.muc_lobby_member_updated",
            MUC_LOBBY_MEMBER_LEFT: "xmpp.muc_lobby_member_left",
            MUC_DENIED_ACCESS: "xmpp.muc_denied access",
            MUC_LEFT: "xmpp.muc_left",
            MUC_ROLE_CHANGED: "xmpp.muc_role_changed",
            MUC_LOCK_CHANGED: "xmpp.muc_lock_changed",
            MUC_MEMBERS_ONLY_CHANGED: "xmpp.muc_members_only_changed",
            PARTICIPANT_AUDIO_MUTED: "xmpp.audio_muted",
            PARTICIPANT_VIDEO_MUTED: "xmpp.video_muted",
            PARTICIPANT_VIDEO_TYPE_CHANGED: "xmpp.video_type",
            PARTICIPANT_FEATURES_CHANGED: "xmpp.participant_features_changed",
            PASSWORD_REQUIRED: "xmpp.password_required",
            PHONE_NUMBER_CHANGED: "conference.phoneNumberChanged",
            PRESENCE_RECEIVED: "xmpp.presence_received",
            PRESENCE_STATUS: "xmpp.presence_status",
            PROMPT_FOR_LOGIN: "xmpp.prompt_for_login",
            READY_TO_JOIN: "xmpp.ready_to_join",
            RECORDER_STATE_CHANGED: "xmpp.recorderStateChanged",
            REMOTE_STATS: "xmpp.remote_stats",
            RENEGOTIATION_FAILED: "xmpp.renegotiation_failed",
            RESERVATION_ERROR: "xmpp.room_reservation_error",
            ROOM_CONNECT_ERROR: "xmpp.room_connect_error",
            ROOM_CONNECT_NOT_ALLOWED_ERROR: "xmpp.room_connect_error.not_allowed",
            ROOM_JOIN_ERROR: "xmpp.room_join_error",
            ROOM_CONNECT_MEMBERS_ONLY_ERROR: "xmpp.room_connect_error.members_only",
            ROOM_MAX_USERS_ERROR: "xmpp.room_max_users_error",
            SENDING_CHAT_MESSAGE: "xmpp.sending_chat_message",
            SENDING_PRIVATE_CHAT_MESSAGE: "xmpp.sending_private_chat_message",
            SESSION_ACCEPT_TIMEOUT: "xmpp.session_accept_timeout",
            SPEAKER_STATS_RECEIVED: "xmpp.speaker_stats_received",
            CONFERENCE_TIMESTAMP_RECEIVED: "xmpp.conference_timestamp_received",
            AV_MODERATION_APPROVED: "xmpp.av_moderation.approved",
            AV_MODERATION_RECEIVED: "xmpp.av_moderation.received",
            AV_MODERATION_CHANGED: "xmpp.av_moderation.changed",
            AV_MODERATION_PARTICIPANT_APPROVED: "xmpp.av_moderation.participant.approved",
            START_MUTED_FROM_FOCUS: "xmpp.start_muted_from_focus",
            SUBJECT_CHANGED: "xmpp.subject_changed",
            SUSPEND_DETECTED: "xmpp.suspend_detected",
            TRANSCRIPTION_STATUS_CHANGED: "xmpp.transcription_status_changed",
            TRANSPORT_INFO: "xmpp.transportinfo.jingle",
            VIDEO_SIP_GW_AVAILABILITY_CHANGED: "xmpp.videoSIPGWAvailabilityChanged",
            VIDEO_SIP_GW_SESSION_STATE_CHANGED: "xmpp.videoSIPGWSessionStateChanged",
            ICE_CONNECTION_STATE_CHANGED: "xmpp.ice_connection_state_changed",
            JSON_MESSAGE_RECEIVED: "xmmp.json_message_received"
        }
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "AUDIO_INPUT_STATE_CHANGE", (function() {
            return i
        })), n.d(t, "AUTH_STATUS_CHANGED", (function() {
            return s
        })), n.d(t, "BEFORE_STATISTICS_DISPOSED", (function() {
            return r
        })), n.d(t, "CONFERENCE_ERROR", (function() {
            return o
        })), n.d(t, "CONFERENCE_FAILED", (function() {
            return a
        })), n.d(t, "CONFERENCE_JOINED", (function() {
            return c
        })), n.d(t, "CONFERENCE_LEFT", (function() {
            return d
        })), n.d(t, "CONFERENCE_UNIQUE_ID_SET", (function() {
            return u
        })), n.d(t, "CONNECTION_ESTABLISHED", (function() {
            return l
        })), n.d(t, "CONNECTION_INTERRUPTED", (function() {
            return h
        })), n.d(t, "CONNECTION_RESTORED", (function() {
            return p
        })), n.d(t, "DATA_CHANNEL_OPENED", (function() {
            return m
        })), n.d(t, "DISPLAY_NAME_CHANGED", (function() {
            return f
        })), n.d(t, "DOMINANT_SPEAKER_CHANGED", (function() {
            return g
        })), n.d(t, "CONFERENCE_CREATED_TIMESTAMP", (function() {
            return _
        })), n.d(t, "DTMF_SUPPORT_CHANGED", (function() {
            return v
        })), n.d(t, "ENDPOINT_MESSAGE_RECEIVED", (function() {
            return S
        })), n.d(t, "ENDPOINT_STATS_RECEIVED", (function() {
            return y
        })), n.d(t, "JVB121_STATUS", (function() {
            return E
        })), n.d(t, "KICKED", (function() {
            return b
        })), n.d(t, "PARTICIPANT_KICKED", (function() {
            return C
        })), n.d(t, "LAST_N_ENDPOINTS_CHANGED", (function() {
            return T
        })), n.d(t, "LOCK_STATE_CHANGED", (function() {
            return R
        })), n.d(t, "SERVER_REGION_CHANGED", (function() {
            return A
        })), n.d(t, "_MEDIA_SESSION_STARTED", (function() {
            return I
        })), n.d(t, "_MEDIA_SESSION_ACTIVE_CHANGED", (function() {
            return w
        })), n.d(t, "MEMBERS_ONLY_CHANGED", (function() {
            return D
        })), n.d(t, "MESSAGE_RECEIVED", (function() {
            return P
        })), n.d(t, "NO_AUDIO_INPUT", (function() {
            return O
        })), n.d(t, "NOISY_MIC", (function() {
            return N
        })), n.d(t, "PRIVATE_MESSAGE_RECEIVED", (function() {
            return M
        })), n.d(t, "PARTICIPANT_CONN_STATUS_CHANGED", (function() {
            return L
        })), n.d(t, "PARTCIPANT_FEATURES_CHANGED", (function() {
            return k
        })), n.d(t, "PARTICIPANT_PROPERTY_CHANGED", (function() {
            return x
        })), n.d(t, "P2P_STATUS", (function() {
            return F
        })), n.d(t, "PHONE_NUMBER_CHANGED", (function() {
            return j
        })), n.d(t, "PROPERTIES_CHANGED", (function() {
            return U
        })), n.d(t, "RECORDER_STATE_CHANGED", (function() {
            return H
        })), n.d(t, "VIDEO_SIP_GW_AVAILABILITY_CHANGED", (function() {
            return V
        })), n.d(t, "VIDEO_SIP_GW_SESSION_STATE_CHANGED", (function() {
            return B
        })), n.d(t, "START_MUTED_POLICY_CHANGED", (function() {
            return J
        })), n.d(t, "STARTED_MUTED", (function() {
            return G
        })), n.d(t, "SUBJECT_CHANGED", (function() {
            return $
        })), n.d(t, "SUSPEND_DETECTED", (function() {
            return K
        })), n.d(t, "TALK_WHILE_MUTED", (function() {
            return q
        })), n.d(t, "TRACK_ADDED", (function() {
            return W
        })), n.d(t, "TRACK_AUDIO_LEVEL_CHANGED", (function() {
            return z
        })), n.d(t, "TRACK_MUTE_CHANGED", (function() {
            return Q
        })), n.d(t, "TRACK_REMOVED", (function() {
            return Y
        })), n.d(t, "TRANSCRIPTION_STATUS_CHANGED", (function() {
            return X
        })), n.d(t, "USER_JOINED", (function() {
            return Z
        })), n.d(t, "USER_LEFT", (function() {
            return ee
        })), n.d(t, "USER_ROLE_CHANGED", (function() {
            return te
        })), n.d(t, "USER_STATUS_CHANGED", (function() {
            return ne
        })), n.d(t, "BOT_TYPE_CHANGED", (function() {
            return ie
        })), n.d(t, "LOBBY_USER_JOINED", (function() {
            return se
        })), n.d(t, "LOBBY_USER_UPDATED", (function() {
            return re
        })), n.d(t, "LOBBY_USER_LEFT", (function() {
            return oe
        })), n.d(t, "AV_MODERATION_APPROVED", (function() {
            return ae
        })), n.d(t, "AV_MODERATION_CHANGED", (function() {
            return ce
        })), n.d(t, "AV_MODERATION_PARTICIPANT_APPROVED", (function() {
            return de
        }));
        const i = "conference.audio_input_state_changed",
            s = "conference.auth_status_changed",
            r = "conference.beforeStatisticsDisposed",
            o = "conference.error",
            a = "conference.failed",
            c = "conference.joined",
            d = "conference.left",
            u = "conference.unique_id_set",
            l = "conference.connectionEstablished",
            h = "conference.connectionInterrupted",
            p = "conference.connectionRestored",
            m = "conference.dataChannelOpened",
            f = "conference.displayNameChanged",
            g = "conference.dominantSpeaker",
            _ = "conference.createdTimestamp",
            v = "conference.dtmfSupportChanged",
            S = "conference.endpoint_message_received",
            y = "conference.endpoint_stats_received",
            E = "conference.jvb121Status",
            b = "conference.kicked",
            C = "conference.participant_kicked",
            T = "conference.lastNEndpointsChanged",
            R = "conference.lock_state_changed",
            A = "conference.server_region_changed",
            I = "conference.media_session.started",
            w = "conference.media_session.active_changed",
            D = "conference.membersOnlyChanged",
            P = "conference.messageReceived",
            O = "conference.no_audio_input",
            N = "conference.noisy_mic",
            M = "conference.privateMessageReceived",
            L = "conference.participant_conn_status_changed",
            k = "conference.partcipant_features_changed",
            x = "conference.participant_property_changed",
            F = "conference.p2pStatus",
            j = "conference.phoneNumberChanged",
            U = "conference.propertiesChanged",
            H = "conference.recorderStateChanged",
            V = "conference.videoSIPGWAvailabilityChanged",
            B = "conference.videoSIPGWSessionStateChanged",
            J = "conference.start_muted_policy_changed",
            G = "conference.started_muted",
            $ = "conference.subjectChanged",
            K = "conference.suspendDetected",
            q = "conference.talk_while_muted",
            W = "conference.trackAdded",
            z = "conference.audioLevelsChanged",
            Q = "conference.trackMuteChanged",
            Y = "conference.trackRemoved",
            X = "conference.transcriptionStatusChanged",
            Z = "conference.userJoined",
            ee = "conference.userLeft",
            te = "conference.roleChanged",
            ne = "conference.statusChanged",
            ie = "conference.bot_type_changed",
            se = "conference.lobby.userJoined",
            re = "conference.lobby.userUpdated",
            oe = "conference.lobby.userLeft",
            ae = "conference.av_moderation.approved",
            ce = "conference.av_moderation.changed",
            de = "conference.av_moderation.participant.approved"
    }, function(e, t, n) {
        (function(t) {
            var n;
            n = function() {
                "use strict";
                var e = void 0 !== t ? t : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};

                function n(e) {
                    return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    })(e)
                }

                function i(e) {
                    return function(e) {
                        if (Array.isArray(e)) {
                            for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
                            return n
                        }
                    }(e) || function(e) {
                        if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
                    }(e) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance")
                    }()
                }
                var s = function(e, t) {
                        var n = (65535 & e) + (65535 & t);
                        return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                    },
                    r = function(e) {
                        if ("string" != typeof e) throw new Error("str2binl was passed a non-string");
                        for (var t = [], n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << n % 32;
                        return t
                    },
                    o = function(e, t, n, i, r, o) {
                        return s((a = s(s(t, e), s(i, o))) << (c = r) | a >>> 32 - c, n);
                        var a, c
                    },
                    a = function(e, t, n, i, s, r, a) {
                        return o(t & n | ~t & i, e, t, s, r, a)
                    },
                    c = function(e, t, n, i, s, r, a) {
                        return o(t & i | n & ~i, e, t, s, r, a)
                    },
                    d = function(e, t, n, i, s, r, a) {
                        return o(t ^ n ^ i, e, t, s, r, a)
                    },
                    u = function(e, t, n, i, s, r, a) {
                        return o(n ^ (t | ~i), e, t, s, r, a)
                    },
                    l = function(e, t) {
                        e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
                        for (var n, i, r, o, l = 1732584193, h = -271733879, p = -1732584194, m = 271733878, f = 0; f < e.length; f += 16) n = l, i = h, r = p, o = m, l = a(l, h, p, m, e[f + 0], 7, -680876936), m = a(m, l, h, p, e[f + 1], 12, -389564586), p = a(p, m, l, h, e[f + 2], 17, 606105819), h = a(h, p, m, l, e[f + 3], 22, -1044525330), l = a(l, h, p, m, e[f + 4], 7, -176418897), m = a(m, l, h, p, e[f + 5], 12, 1200080426), p = a(p, m, l, h, e[f + 6], 17, -1473231341), h = a(h, p, m, l, e[f + 7], 22, -45705983), l = a(l, h, p, m, e[f + 8], 7, 1770035416), m = a(m, l, h, p, e[f + 9], 12, -1958414417), p = a(p, m, l, h, e[f + 10], 17, -42063), h = a(h, p, m, l, e[f + 11], 22, -1990404162), l = a(l, h, p, m, e[f + 12], 7, 1804603682), m = a(m, l, h, p, e[f + 13], 12, -40341101), p = a(p, m, l, h, e[f + 14], 17, -1502002290), h = a(h, p, m, l, e[f + 15], 22, 1236535329), l = c(l, h, p, m, e[f + 1], 5, -165796510), m = c(m, l, h, p, e[f + 6], 9, -1069501632), p = c(p, m, l, h, e[f + 11], 14, 643717713), h = c(h, p, m, l, e[f + 0], 20, -373897302), l = c(l, h, p, m, e[f + 5], 5, -701558691), m = c(m, l, h, p, e[f + 10], 9, 38016083), p = c(p, m, l, h, e[f + 15], 14, -660478335), h = c(h, p, m, l, e[f + 4], 20, -405537848), l = c(l, h, p, m, e[f + 9], 5, 568446438), m = c(m, l, h, p, e[f + 14], 9, -1019803690), p = c(p, m, l, h, e[f + 3], 14, -187363961), h = c(h, p, m, l, e[f + 8], 20, 1163531501), l = c(l, h, p, m, e[f + 13], 5, -1444681467), m = c(m, l, h, p, e[f + 2], 9, -51403784), p = c(p, m, l, h, e[f + 7], 14, 1735328473), h = c(h, p, m, l, e[f + 12], 20, -1926607734), l = d(l, h, p, m, e[f + 5], 4, -378558), m = d(m, l, h, p, e[f + 8], 11, -2022574463), p = d(p, m, l, h, e[f + 11], 16, 1839030562), h = d(h, p, m, l, e[f + 14], 23, -35309556), l = d(l, h, p, m, e[f + 1], 4, -1530992060), m = d(m, l, h, p, e[f + 4], 11, 1272893353), p = d(p, m, l, h, e[f + 7], 16, -155497632), h = d(h, p, m, l, e[f + 10], 23, -1094730640), l = d(l, h, p, m, e[f + 13], 4, 681279174), m = d(m, l, h, p, e[f + 0], 11, -358537222), p = d(p, m, l, h, e[f + 3], 16, -722521979), h = d(h, p, m, l, e[f + 6], 23, 76029189), l = d(l, h, p, m, e[f + 9], 4, -640364487), m = d(m, l, h, p, e[f + 12], 11, -421815835), p = d(p, m, l, h, e[f + 15], 16, 530742520), h = d(h, p, m, l, e[f + 2], 23, -995338651), l = u(l, h, p, m, e[f + 0], 6, -198630844), m = u(m, l, h, p, e[f + 7], 10, 1126891415), p = u(p, m, l, h, e[f + 14], 15, -1416354905), h = u(h, p, m, l, e[f + 5], 21, -57434055), l = u(l, h, p, m, e[f + 12], 6, 1700485571), m = u(m, l, h, p, e[f + 3], 10, -1894986606), p = u(p, m, l, h, e[f + 10], 15, -1051523), h = u(h, p, m, l, e[f + 1], 21, -2054922799), l = u(l, h, p, m, e[f + 8], 6, 1873313359), m = u(m, l, h, p, e[f + 15], 10, -30611744), p = u(p, m, l, h, e[f + 6], 15, -1560198380), h = u(h, p, m, l, e[f + 13], 21, 1309151649), l = u(l, h, p, m, e[f + 4], 6, -145523070), m = u(m, l, h, p, e[f + 11], 10, -1120210379), p = u(p, m, l, h, e[f + 2], 15, 718787259), h = u(h, p, m, l, e[f + 9], 21, -343485551), l = s(l, n), h = s(h, i), p = s(p, r), m = s(m, o);
                        return [l, h, p, m]
                    },
                    h = {
                        hexdigest: function(e) {
                            return function(e) {
                                for (var t = "", n = 0; n < 4 * e.length; n++) t += "0123456789abcdef".charAt(e[n >> 2] >> n % 4 * 8 + 4 & 15) + "0123456789abcdef".charAt(e[n >> 2] >> n % 4 * 8 & 15);
                                return t
                            }(l(r(e), 8 * e.length))
                        },
                        hash: function(e) {
                            return function(e) {
                                for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> n % 32 & 255);
                                return t
                            }(l(r(e), 8 * e.length))
                        }
                    };

                function p(e, t) {
                    e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;
                    var n, i, s, r, o, a, c, d, u = new Array(80),
                        l = 1732584193,
                        h = -271733879,
                        p = -1732584194,
                        g = 271733878,
                        S = -1009589776;
                    for (n = 0; n < e.length; n += 16) {
                        for (r = l, o = h, a = p, c = g, d = S, i = 0; i < 80; i++) u[i] = i < 16 ? e[n + i] : v(u[i - 3] ^ u[i - 8] ^ u[i - 14] ^ u[i - 16], 1), s = _(_(v(l, 5), m(i, h, p, g)), _(_(S, u[i]), f(i))), S = g, g = p, p = v(h, 30), h = l, l = s;
                        l = _(l, r), h = _(h, o), p = _(p, a), g = _(g, c), S = _(S, d)
                    }
                    return [l, h, p, g, S]
                }

                function m(e, t, n, i) {
                    return e < 20 ? t & n | ~t & i : e < 40 ? t ^ n ^ i : e < 60 ? t & n | t & i | n & i : t ^ n ^ i
                }

                function f(e) {
                    return e < 20 ? 1518500249 : e < 40 ? 1859775393 : e < 60 ? -1894007588 : -899497514
                }

                function g(e, t) {
                    var n = S(e);
                    n.length > 16 && (n = p(n, 8 * e.length));
                    for (var i = new Array(16), s = new Array(16), r = 0; r < 16; r++) i[r] = 909522486 ^ n[r], s[r] = 1549556828 ^ n[r];
                    var o = p(i.concat(S(t)), 512 + 8 * t.length);
                    return p(s.concat(o), 672)
                }

                function _(e, t) {
                    var n = (65535 & e) + (65535 & t);
                    return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                }

                function v(e, t) {
                    return e << t | e >>> 32 - t
                }

                function S(e) {
                    for (var t = [], n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << 24 - n % 32;
                    return t
                }

                function y(e) {
                    for (var t, n, i = "", s = 0; s < 4 * e.length; s += 3)
                        for (t = (e[s >> 2] >> 8 * (3 - s % 4) & 255) << 16 | (e[s + 1 >> 2] >> 8 * (3 - (s + 1) % 4) & 255) << 8 | e[s + 2 >> 2] >> 8 * (3 - (s + 2) % 4) & 255, n = 0; n < 4; n++) 8 * s + 6 * n > 32 * e.length ? i += "=" : i += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(t >> 6 * (3 - n) & 63);
                    return i
                }

                function E(e) {
                    for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> 24 - n % 32 & 255);
                    return t
                }
                var b = {
                        b64_hmac_sha1: function(e, t) {
                            return y(g(e, t))
                        },
                        b64_sha1: function(e) {
                            return y(p(S(e), 8 * e.length))
                        },
                        binb2str: E,
                        core_hmac_sha1: g,
                        str_hmac_sha1: function(e, t) {
                            return E(g(e, t))
                        },
                        str_sha1: function(e) {
                            return E(p(S(e), 8 * e.length))
                        }
                    },
                    C = function(e) {
                        var t, n, i = "",
                            s = e.length;
                        for (t = 0; t < s; t++)(n = e.charCodeAt(t)) >= 0 && n <= 127 ? i += e.charAt(t) : n > 2047 ? (i += String.fromCharCode(224 | n >> 12 & 15), i += String.fromCharCode(128 | n >> 6 & 63), i += String.fromCharCode(128 | n >> 0 & 63)) : (i += String.fromCharCode(192 | n >> 6 & 31), i += String.fromCharCode(128 | n >> 0 & 63));
                        return i
                    },
                    T = function(e) {
                        for (var t in e = e || {})
                            if (Object.prototype.hasOwnProperty.call(e, t)) {
                                var i = "",
                                    s = "",
                                    r = "",
                                    o = e[t],
                                    a = "object" === n(o),
                                    c = escape(unescape(a ? o.value : o));
                                a && (i = o.expires ? ";expires=" + o.expires : "", s = o.domain ? ";domain=" + o.domain : "", r = o.path ? ";path=" + o.path : ""), document.cookie = t + "=" + c + i + s + r
                            }
                    };

                function R(e, t) {
                    return new w.Builder(e, t)
                }

                function A(e) {
                    return new w.Builder("iq", e)
                }

                function I(e) {
                    return new w.Builder("presence", e)
                }
                var w = {
                    VERSION: "@VERSION@",
                    NS: {
                        HTTPBIND: "http://jabber.org/protocol/httpbind",
                        BOSH: "urn:xmpp:xbosh",
                        CLIENT: "jabber:client",
                        AUTH: "jabber:iq:auth",
                        ROSTER: "jabber:iq:roster",
                        PROFILE: "jabber:iq:profile",
                        DISCO_INFO: "http://jabber.org/protocol/disco#info",
                        DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
                        MUC: "http://jabber.org/protocol/muc",
                        SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
                        STREAM: "http://etherx.jabber.org/streams",
                        FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
                        BIND: "urn:ietf:params:xml:ns:xmpp-bind",
                        SESSION: "urn:ietf:params:xml:ns:xmpp-session",
                        VERSION: "jabber:iq:version",
                        STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
                        XHTML_IM: "http://jabber.org/protocol/xhtml-im",
                        XHTML: "http://www.w3.org/1999/xhtml"
                    },
                    XHTML: {
                        tags: ["a", "blockquote", "br", "cite", "em", "img", "li", "ol", "p", "span", "strong", "ul", "body"],
                        attributes: {
                            a: ["href"],
                            blockquote: ["style"],
                            br: [],
                            cite: ["style"],
                            em: [],
                            img: ["src", "alt", "style", "height", "width"],
                            li: ["style"],
                            ol: ["style"],
                            p: ["style"],
                            span: ["style"],
                            strong: [],
                            ul: ["style"],
                            body: []
                        },
                        css: ["background-color", "color", "font-family", "font-size", "font-style", "font-weight", "margin-left", "margin-right", "text-align", "text-decoration"],
                        validTag: function(e) {
                            for (var t = 0; t < w.XHTML.tags.length; t++)
                                if (e === w.XHTML.tags[t]) return !0;
                            return !1
                        },
                        validAttribute: function(e, t) {
                            if (void 0 !== w.XHTML.attributes[e] && w.XHTML.attributes[e].length > 0)
                                for (var n = 0; n < w.XHTML.attributes[e].length; n++)
                                    if (t === w.XHTML.attributes[e][n]) return !0;
                            return !1
                        },
                        validCSS: function(e) {
                            for (var t = 0; t < w.XHTML.css.length; t++)
                                if (e === w.XHTML.css[t]) return !0;
                            return !1
                        }
                    },
                    Status: {
                        ERROR: 0,
                        CONNECTING: 1,
                        CONNFAIL: 2,
                        AUTHENTICATING: 3,
                        AUTHFAIL: 4,
                        CONNECTED: 5,
                        DISCONNECTED: 6,
                        DISCONNECTING: 7,
                        ATTACHED: 8,
                        REDIRECT: 9,
                        CONNTIMEOUT: 10,
                        BINDREQUIRED: 11
                    },
                    ErrorCondition: {
                        BAD_FORMAT: "bad-format",
                        CONFLICT: "conflict",
                        MISSING_JID_NODE: "x-strophe-bad-non-anon-jid",
                        NO_AUTH_MECH: "no-auth-mech",
                        UNKNOWN_REASON: "unknown"
                    },
                    LogLevel: {
                        DEBUG: 0,
                        INFO: 1,
                        WARN: 2,
                        ERROR: 3,
                        FATAL: 4
                    },
                    ElementType: {
                        NORMAL: 1,
                        TEXT: 3,
                        CDATA: 4,
                        FRAGMENT: 11
                    },
                    TIMEOUT: 1.1,
                    SECONDARY_TIMEOUT: .1,
                    addNamespace: function(e, t) {
                        w.NS[e] = t
                    },
                    forEachChild: function(e, t, n) {
                        for (var i = 0; i < e.childNodes.length; i++) {
                            var s = e.childNodes[i];
                            s.nodeType !== w.ElementType.NORMAL || t && !this.isTagEqual(s, t) || n(s)
                        }
                    },
                    isTagEqual: function(e, t) {
                        return e.tagName === t
                    },
                    _xmlGenerator: null,
                    _makeGenerator: function() {
                        var e;
                        return void 0 === document.implementation.createDocument || document.implementation.createDocument && document.documentMode && document.documentMode < 10 ? (e = this._getIEXmlDom()).appendChild(e.createElement("strophe")) : e = document.implementation.createDocument("jabber:client", "strophe", null), e
                    },
                    xmlGenerator: function() {
                        return w._xmlGenerator || (w._xmlGenerator = w._makeGenerator()), w._xmlGenerator
                    },
                    _getIEXmlDom: function() {
                        for (var e = null, t = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"], n = 0; n < t.length && null === e; n++) try {
                            e = new ActiveXObject(t[n])
                        } catch (t) {
                            e = null
                        }
                        return e
                    },
                    xmlElement: function(e) {
                        if (!e) return null;
                        for (var t = w.xmlGenerator().createElement(e), i = 1; i < arguments.length; i++) {
                            var s = arguments[i];
                            if (s)
                                if ("string" == typeof s || "number" == typeof s) t.appendChild(w.xmlTextNode(s));
                                else if ("object" === n(s) && "function" == typeof s.sort)
                                for (var r = 0; r < s.length; r++) {
                                    var o = s[r];
                                    "object" === n(o) && "function" == typeof o.sort && void 0 !== o[1] && null !== o[1] && t.setAttribute(o[0], o[1])
                                } else if ("object" === n(s))
                                    for (var a in s) Object.prototype.hasOwnProperty.call(s, a) && void 0 !== s[a] && null !== s[a] && t.setAttribute(a, s[a])
                        }
                        return t
                    },
                    xmlescape: function(e) {
                        return e = (e = (e = (e = (e = e.replace(/\&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/'/g, "&apos;")).replace(/"/g, "&quot;")
                    },
                    xmlunescape: function(e) {
                        return e = (e = (e = (e = (e = e.replace(/\&amp;/g, "&")).replace(/&lt;/g, "<")).replace(/&gt;/g, ">")).replace(/&apos;/g, "'")).replace(/&quot;/g, '"')
                    },
                    xmlTextNode: function(e) {
                        return w.xmlGenerator().createTextNode(e)
                    },
                    xmlHtmlNode: function(e) {
                        var t;
                        return DOMParser ? t = (new DOMParser).parseFromString(e, "text/xml") : ((t = new ActiveXObject("Microsoft.XMLDOM")).async = "false", t.loadXML(e)), t
                    },
                    getText: function(e) {
                        if (!e) return null;
                        var t = "";
                        0 === e.childNodes.length && e.nodeType === w.ElementType.TEXT && (t += e.nodeValue);
                        for (var n = 0; n < e.childNodes.length; n++) e.childNodes[n].nodeType === w.ElementType.TEXT && (t += e.childNodes[n].nodeValue);
                        return w.xmlescape(t)
                    },
                    copyElement: function(e) {
                        var t;
                        if (e.nodeType === w.ElementType.NORMAL) {
                            t = w.xmlElement(e.tagName);
                            for (var n = 0; n < e.attributes.length; n++) t.setAttribute(e.attributes[n].nodeName, e.attributes[n].value);
                            for (var i = 0; i < e.childNodes.length; i++) t.appendChild(w.copyElement(e.childNodes[i]))
                        } else e.nodeType === w.ElementType.TEXT && (t = w.xmlGenerator().createTextNode(e.nodeValue));
                        return t
                    },
                    createHtml: function(e) {
                        var t;
                        if (e.nodeType === w.ElementType.NORMAL) {
                            var i = e.nodeName.toLowerCase();
                            if (w.XHTML.validTag(i)) try {
                                t = w.xmlElement(i);
                                for (var s = 0; s < w.XHTML.attributes[i].length; s++) {
                                    var r = w.XHTML.attributes[i][s],
                                        o = e.getAttribute(r);
                                    if (null != o && "" !== o && !1 !== o && 0 !== o)
                                        if ("style" === r && "object" === n(o) && void 0 !== o.cssText && (o = o.cssText), "style" === r) {
                                            for (var a = [], c = o.split(";"), d = 0; d < c.length; d++) {
                                                var u = c[d].split(":"),
                                                    l = u[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                                if (w.XHTML.validCSS(l)) {
                                                    var h = u[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                                    a.push(l + ": " + h)
                                                }
                                            }
                                            a.length > 0 && (o = a.join("; "), t.setAttribute(r, o))
                                        } else t.setAttribute(r, o)
                                }
                                for (var p = 0; p < e.childNodes.length; p++) t.appendChild(w.createHtml(e.childNodes[p]))
                            } catch (e) {
                                t = w.xmlTextNode("")
                            } else {
                                t = w.xmlGenerator().createDocumentFragment();
                                for (var m = 0; m < e.childNodes.length; m++) t.appendChild(w.createHtml(e.childNodes[m]))
                            }
                        } else if (e.nodeType === w.ElementType.FRAGMENT) {
                            t = w.xmlGenerator().createDocumentFragment();
                            for (var f = 0; f < e.childNodes.length; f++) t.appendChild(w.createHtml(e.childNodes[f]))
                        } else e.nodeType === w.ElementType.TEXT && (t = w.xmlTextNode(e.nodeValue));
                        return t
                    },
                    escapeNode: function(e) {
                        return "string" != typeof e ? e : e.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40")
                    },
                    unescapeNode: function(e) {
                        return "string" != typeof e ? e : e.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\")
                    },
                    getNodeFromJid: function(e) {
                        return e.indexOf("@") < 0 ? null : e.split("@")[0]
                    },
                    getDomainFromJid: function(e) {
                        var t = w.getBareJidFromJid(e);
                        if (t.indexOf("@") < 0) return t;
                        var n = t.split("@");
                        return n.splice(0, 1), n.join("@")
                    },
                    getResourceFromJid: function(e) {
                        if (!e) return null;
                        var t = e.split("/");
                        return t.length < 2 ? null : (t.splice(0, 1), t.join("/"))
                    },
                    getBareJidFromJid: function(e) {
                        return e ? e.split("/")[0] : null
                    },
                    _handleError: function(e) {
                        void 0 !== e.stack && w.fatal(e.stack), e.sourceURL ? w.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message) : e.fileName ? w.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message) : w.fatal("error: " + e.message)
                    },
                    log: function(e, t) {
                        e === this.LogLevel.FATAL && "object" === n(window.console) && "function" == typeof window.console.error && window.console.error(t)
                    },
                    debug: function(e) {
                        this.log(this.LogLevel.DEBUG, e)
                    },
                    info: function(e) {
                        this.log(this.LogLevel.INFO, e)
                    },
                    warn: function(e) {
                        this.log(this.LogLevel.WARN, e)
                    },
                    error: function(e) {
                        this.log(this.LogLevel.ERROR, e)
                    },
                    fatal: function(e) {
                        this.log(this.LogLevel.FATAL, e)
                    },
                    serialize: function(e) {
                        if (!e) return null;
                        "function" == typeof e.tree && (e = e.tree());
                        var t = i(Array(e.attributes.length).keys()).map((function(t) {
                            return e.attributes[t].nodeName
                        }));
                        t.sort();
                        var n = t.reduce((function(t, n) {
                            return "".concat(t, " ").concat(n, '="').concat(w.xmlescape(e.attributes.getNamedItem(n).value), '"')
                        }), "<".concat(e.nodeName));
                        if (e.childNodes.length > 0) {
                            n += ">";
                            for (var s = 0; s < e.childNodes.length; s++) {
                                var r = e.childNodes[s];
                                switch (r.nodeType) {
                                    case w.ElementType.NORMAL:
                                        n += w.serialize(r);
                                        break;
                                    case w.ElementType.TEXT:
                                        n += w.xmlescape(r.nodeValue);
                                        break;
                                    case w.ElementType.CDATA:
                                        n += "<![CDATA[" + r.nodeValue + "]]>"
                                }
                            }
                            n += "</" + e.nodeName + ">"
                        } else n += "/>";
                        return n
                    },
                    _requestId: 0,
                    _connectionPlugins: {},
                    addConnectionPlugin: function(e, t) {
                        w._connectionPlugins[e] = t
                    },
                    Builder: function(e, t) {
                        "presence" !== e && "message" !== e && "iq" !== e || (t && !t.xmlns ? t.xmlns = w.NS.CLIENT : t || (t = {
                            xmlns: w.NS.CLIENT
                        })), this.nodeTree = w.xmlElement(e, t), this.node = this.nodeTree
                    }
                };
                w.Builder.prototype = {
                    tree: function() {
                        return this.nodeTree
                    },
                    toString: function() {
                        return w.serialize(this.nodeTree)
                    },
                    up: function() {
                        return this.node = this.node.parentNode, this
                    },
                    root: function() {
                        return this.node = this.nodeTree, this
                    },
                    attrs: function(e) {
                        for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (void 0 === e[t] ? this.node.removeAttribute(t) : this.node.setAttribute(t, e[t]));
                        return this
                    },
                    c: function(e, t, n) {
                        var i = w.xmlElement(e, t, n);
                        return this.node.appendChild(i), "string" != typeof n && "number" != typeof n && (this.node = i), this
                    },
                    cnode: function(e) {
                        var t, n = w.xmlGenerator();
                        try {
                            t = void 0 !== n.importNode
                        } catch (e) {
                            t = !1
                        }
                        var i = t ? n.importNode(e, !0) : w.copyElement(e);
                        return this.node.appendChild(i), this.node = i, this
                    },
                    t: function(e) {
                        var t = w.xmlTextNode(e);
                        return this.node.appendChild(t), this
                    },
                    h: function(e) {
                        var t = document.createElement("body");
                        t.innerHTML = e;
                        for (var n = w.createHtml(t); n.childNodes.length > 0;) this.node.appendChild(n.childNodes[0]);
                        return this
                    }
                }, w.Handler = function(e, t, n, i, s, r, o) {
                    this.handler = e, this.ns = t, this.name = n, this.type = i, this.id = s, this.options = o || {
                        matchBareFromJid: !1,
                        ignoreNamespaceFragment: !1
                    }, this.options.matchBare && (w.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.'), this.options.matchBareFromJid = this.options.matchBare, delete this.options.matchBare), this.options.matchBareFromJid ? this.from = r ? w.getBareJidFromJid(r) : null : this.from = r, this.user = !0
                }, w.Handler.prototype = {
                    getNamespace: function(e) {
                        var t = e.getAttribute("xmlns");
                        return t && this.options.ignoreNamespaceFragment && (t = t.split("#")[0]), t
                    },
                    namespaceMatch: function(e) {
                        var t = this,
                            n = !1;
                        return !this.ns || (w.forEachChild(e, null, (function(e) {
                            t.getNamespace(e) === t.ns && (n = !0)
                        })), n || this.getNamespace(e) === this.ns)
                    },
                    isMatch: function(e) {
                        var t = e.getAttribute("from");
                        this.options.matchBareFromJid && (t = w.getBareJidFromJid(t));
                        var n = e.getAttribute("type");
                        return !(!this.namespaceMatch(e) || this.name && !w.isTagEqual(e, this.name) || this.type && (Array.isArray(this.type) ? -1 === this.type.indexOf(n) : n !== this.type) || this.id && e.getAttribute("id") !== this.id || this.from && t !== this.from)
                    },
                    run: function(e) {
                        var t = null;
                        try {
                            t = this.handler(e)
                        } catch (e) {
                            throw w._handleError(e), e
                        }
                        return t
                    },
                    toString: function() {
                        return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}"
                    }
                }, w.TimedHandler = function(e, t) {
                    this.period = e, this.handler = t, this.lastCalled = (new Date).getTime(), this.user = !0
                }, w.TimedHandler.prototype = {
                    run: function() {
                        return this.lastCalled = (new Date).getTime(), this.handler()
                    },
                    reset: function() {
                        this.lastCalled = (new Date).getTime()
                    },
                    toString: function() {
                        return "{TimedHandler: " + this.handler + "(" + this.period + ")}"
                    }
                }, w.Connection = function(e, t) {
                    var n = this;
                    this.service = e, this.options = t || {};
                    var i = this.options.protocol || "";
                    for (var s in 0 === e.indexOf("ws:") || 0 === e.indexOf("wss:") || 0 === i.indexOf("ws") ? this._proto = new w.Websocket(this) : this._proto = new w.Bosh(this), this.jid = "", this.domain = null, this.features = null, this._sasl_data = {}, this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.protocolErrorHandlers = {
                            HTTP: {},
                            websocket: {}
                        }, this._idleTimeout = null, this._disconnectTimeout = null, this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.do_authentication = !0, this.paused = !1, this.restored = !1, this._data = [], this._uniqueId = 0, this._sasl_success_handler = null, this._sasl_failure_handler = null, this._sasl_challenge_handler = null, this.maxRetries = 5, this._idleTimeout = setTimeout((function() {
                            return n._onIdle()
                        }), 100), T(this.options.cookies), this.registerSASLMechanisms(this.options.mechanisms), w._connectionPlugins)
                        if (Object.prototype.hasOwnProperty.call(w._connectionPlugins, s)) {
                            var r = function() {};
                            r.prototype = w._connectionPlugins[s], this[s] = new r, this[s].init(this)
                        }
                }, w.Connection.prototype = {
                    reset: function() {
                        this._proto._reset(), this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.restored = !1, this._data = [], this._requests = [], this._uniqueId = 0
                    },
                    pause: function() {
                        this.paused = !0
                    },
                    resume: function() {
                        this.paused = !1
                    },
                    getUniqueId: function(e) {
                        var t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
                            var t = 16 * Math.random() | 0;
                            return ("x" === e ? t : 3 & t | 8).toString(16)
                        }));
                        return "string" == typeof e || "number" == typeof e ? t + ":" + e : t + ""
                    },
                    addProtocolErrorHandler: function(e, t, n) {
                        this.protocolErrorHandlers[e][t] = n
                    },
                    connect: function(e, t, n, i, s, r, o) {
                        this.jid = e, this.authzid = w.getBareJidFromJid(this.jid), this.authcid = o || w.getNodeFromJid(this.jid), this.pass = t, this.servtype = "xmpp", this.connect_callback = n, this.disconnecting = !1, this.connected = !1, this.authenticated = !1, this.restored = !1, this.domain = w.getDomainFromJid(this.jid), this._changeConnectStatus(w.Status.CONNECTING, null), this._proto._connect(i, s, r)
                    },
                    attach: function(e, t, n, i, s, r, o) {
                        if (!(this._proto instanceof w.Bosh)) {
                            var a = new Error('The "attach" method can only be used with a BOSH connection.');
                            throw a.name = "StropheSessionError", a
                        }
                        this._proto._attach(e, t, n, i, s, r, o)
                    },
                    restore: function(e, t, n, i, s) {
                        if (!this._sessionCachingSupported()) {
                            var r = new Error('The "restore" method can only be used with a BOSH connection.');
                            throw r.name = "StropheSessionError", r
                        }
                        this._proto._restore(e, t, n, i, s)
                    },
                    _sessionCachingSupported: function() {
                        if (this._proto instanceof w.Bosh) {
                            if (!JSON) return !1;
                            try {
                                sessionStorage.setItem("_strophe_", "_strophe_"), sessionStorage.removeItem("_strophe_")
                            } catch (e) {
                                return !1
                            }
                            return !0
                        }
                        return !1
                    },
                    xmlInput: function(e) {},
                    xmlOutput: function(e) {},
                    rawInput: function(e) {},
                    rawOutput: function(e) {},
                    nextValidRid: function(e) {},
                    send: function(e) {
                        if (null !== e) {
                            if ("function" == typeof e.sort)
                                for (var t = 0; t < e.length; t++) this._queueData(e[t]);
                            else "function" == typeof e.tree ? this._queueData(e.tree()) : this._queueData(e);
                            this._proto._send()
                        }
                    },
                    flush: function() {
                        clearTimeout(this._idleTimeout), this._onIdle()
                    },
                    sendPresence: function(e, t, n, i) {
                        var s = this,
                            r = null;
                        "function" == typeof e.tree && (e = e.tree());
                        var o = e.getAttribute("id");
                        if (o || (o = this.getUniqueId("sendPresence"), e.setAttribute("id", o)), "function" == typeof t || "function" == typeof n) {
                            var a = this.addHandler((function(e) {
                                r && s.deleteTimedHandler(r), "error" === e.getAttribute("type") ? n && n(e) : t && t(e)
                            }), null, "presence", null, o);
                            i && (r = this.addTimedHandler(i, (function() {
                                return s.deleteHandler(a), n && n(null), !1
                            })))
                        }
                        return this.send(e), o
                    },
                    sendIQ: function(e, t, n, i) {
                        var s = this,
                            r = null;
                        "function" == typeof e.tree && (e = e.tree());
                        var o = e.getAttribute("id");
                        if (o || (o = this.getUniqueId("sendIQ"), e.setAttribute("id", o)), "function" == typeof t || "function" == typeof n) {
                            var a = this.addHandler((function(e) {
                                r && s.deleteTimedHandler(r);
                                var i = e.getAttribute("type");
                                if ("result" === i) t && t(e);
                                else {
                                    if ("error" !== i) {
                                        var o = new Error("Got bad IQ type of ".concat(i));
                                        throw o.name = "StropheError", o
                                    }
                                    n && n(e)
                                }
                            }), null, "iq", ["error", "result"], o);
                            i && (r = this.addTimedHandler(i, (function() {
                                return s.deleteHandler(a), n && n(null), !1
                            })))
                        }
                        return this.send(e), o
                    },
                    _queueData: function(e) {
                        if (null === e || !e.tagName || !e.childNodes) {
                            var t = new Error("Cannot queue non-DOMElement.");
                            throw t.name = "StropheError", t
                        }
                        this._data.push(e)
                    },
                    _sendRestart: function() {
                        var e = this;
                        this._data.push("restart"), this._proto._sendRestart(), this._idleTimeout = setTimeout((function() {
                            return e._onIdle()
                        }), 100)
                    },
                    addTimedHandler: function(e, t) {
                        var n = new w.TimedHandler(e, t);
                        return this.addTimeds.push(n), n
                    },
                    deleteTimedHandler: function(e) {
                        this.removeTimeds.push(e)
                    },
                    addHandler: function(e, t, n, i, s, r, o) {
                        var a = new w.Handler(e, t, n, i, s, r, o);
                        return this.addHandlers.push(a), a
                    },
                    deleteHandler: function(e) {
                        this.removeHandlers.push(e);
                        var t = this.addHandlers.indexOf(e);
                        t >= 0 && this.addHandlers.splice(t, 1)
                    },
                    registerSASLMechanisms: function(e) {
                        this.mechanisms = {}, (e = e || [w.SASLAnonymous, w.SASLExternal, w.SASLMD5, w.SASLOAuthBearer, w.SASLXOAuth2, w.SASLPlain, w.SASLSHA1]).forEach(this.registerSASLMechanism.bind(this))
                    },
                    registerSASLMechanism: function(e) {
                        this.mechanisms[e.prototype.name] = e
                    },
                    disconnect: function(e) {
                        if (this._changeConnectStatus(w.Status.DISCONNECTING, e), w.warn("Disconnect was called because: " + e), this.connected) {
                            var t = !1;
                            this.disconnecting = !0, this.authenticated && (t = I({
                                xmlns: w.NS.CLIENT,
                                type: "unavailable"
                            })), this._disconnectTimeout = this._addSysTimedHandler(3e3, this._onDisconnectTimeout.bind(this)), this._proto._disconnect(t)
                        } else w.warn("Disconnect was called before Strophe connected to the server"), this._proto._abortAllRequests(), this._doDisconnect()
                    },
                    _changeConnectStatus: function(e, t, n) {
                        for (var i in w._connectionPlugins)
                            if (Object.prototype.hasOwnProperty.call(w._connectionPlugins, i)) {
                                var s = this[i];
                                if (s.statusChanged) try {
                                    s.statusChanged(e, t)
                                } catch (e) {
                                    w.error("".concat(i, " plugin caused an exception changing status: ").concat(e))
                                }
                            } if (this.connect_callback) try {
                            this.connect_callback(e, t, n)
                        } catch (e) {
                            w._handleError(e), w.error("User connection callback caused an exception: ".concat(e))
                        }
                    },
                    _doDisconnect: function(e) {
                        "number" == typeof this._idleTimeout && clearTimeout(this._idleTimeout), null !== this._disconnectTimeout && (this.deleteTimedHandler(this._disconnectTimeout), this._disconnectTimeout = null), w.debug("_doDisconnect was called"), this._proto._doDisconnect(), this.authenticated = !1, this.disconnecting = !1, this.restored = !1, this.handlers = [], this.timedHandlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this._changeConnectStatus(w.Status.DISCONNECTED, e), this.connected = !1
                    },
                    _dataRecv: function(e, t) {
                        var n = this;
                        w.debug("_dataRecv called");
                        var i = this._proto._reqToData(e);
                        if (null !== i) {
                            for (this.xmlInput !== w.Connection.prototype.xmlInput && (i.nodeName === this._proto.strip && i.childNodes.length ? this.xmlInput(i.childNodes[0]) : this.xmlInput(i)), this.rawInput !== w.Connection.prototype.rawInput && (t ? this.rawInput(t) : this.rawInput(w.serialize(i))); this.removeHandlers.length > 0;) {
                                var s = this.removeHandlers.pop(),
                                    r = this.handlers.indexOf(s);
                                r >= 0 && this.handlers.splice(r, 1)
                            }
                            for (; this.addHandlers.length > 0;) this.handlers.push(this.addHandlers.pop());
                            if (this.disconnecting && this._proto._emptyQueue()) this._doDisconnect();
                            else {
                                var o = i.getAttribute("type");
                                if (null !== o && "terminate" === o) {
                                    if (this.disconnecting) return;
                                    var a = i.getAttribute("condition"),
                                        c = i.getElementsByTagName("conflict");
                                    return null !== a ? ("remote-stream-error" === a && c.length > 0 && (a = "conflict"), this._changeConnectStatus(w.Status.CONNFAIL, a)) : this._changeConnectStatus(w.Status.CONNFAIL, w.ErrorCondition.UNKOWN_REASON), void this._doDisconnect(a)
                                }
                                w.forEachChild(i, null, (function(e) {
                                    var t = n.handlers;
                                    n.handlers = [];
                                    for (var i = 0; i < t.length; i++) {
                                        var s = t[i];
                                        try {
                                            (!s.isMatch(e) || !n.authenticated && s.user || s.run(e)) && n.handlers.push(s)
                                        } catch (e) {
                                            w.warn("Removing Strophe handlers due to uncaught exception: " + e.message)
                                        }
                                    }
                                }))
                            }
                        }
                    },
                    mechanisms: {},
                    _connect_cb: function(e, t, n) {
                        var i;
                        w.debug("_connect_cb was called"), this.connected = !0;
                        try {
                            i = this._proto._reqToData(e)
                        } catch (e) {
                            if (e.name !== w.ErrorCondition.BAD_FORMAT) throw e;
                            this._changeConnectStatus(w.Status.CONNFAIL, w.ErrorCondition.BAD_FORMAT), this._doDisconnect(w.ErrorCondition.BAD_FORMAT)
                        }
                        if (i && (this.xmlInput !== w.Connection.prototype.xmlInput && (i.nodeName === this._proto.strip && i.childNodes.length ? this.xmlInput(i.childNodes[0]) : this.xmlInput(i)), this.rawInput !== w.Connection.prototype.rawInput && (n ? this.rawInput(n) : this.rawInput(w.serialize(i))), this._proto._connect_cb(i) !== w.Status.CONNFAIL))
                            if (i.getElementsByTagNameNS ? i.getElementsByTagNameNS(w.NS.STREAM, "features").length > 0 : i.getElementsByTagName("stream:features").length > 0 || i.getElementsByTagName("features").length > 0) {
                                var s = [],
                                    r = i.getElementsByTagName("mechanism");
                                if (r.length > 0)
                                    for (var o = 0; o < r.length; o++) {
                                        var a = w.getText(r[o]);
                                        this.mechanisms[a] && s.push(this.mechanisms[a])
                                    }
                                0 !== s.length || 0 !== i.getElementsByTagName("auth").length ? !1 !== this.do_authentication && this.authenticate(s) : this._proto._no_auth_received(t)
                            } else this._proto._no_auth_received(t)
                    },
                    sortMechanismsByPriority: function(e) {
                        for (var t = 0; t < e.length - 1; ++t) {
                            for (var n = t, i = t + 1; i < e.length; ++i) e[i].prototype.priority > e[n].prototype.priority && (n = i);
                            if (n !== t) {
                                var s = e[t];
                                e[t] = e[n], e[n] = s
                            }
                        }
                        return e
                    },
                    authenticate: function(e) {
                        this._attemptSASLAuth(e) || this._attemptLegacyAuth()
                    },
                    _attemptSASLAuth: function(e) {
                        e = this.sortMechanismsByPriority(e || []);
                        for (var t = !1, n = 0; n < e.length; ++n)
                            if (e[n].prototype.test(this)) {
                                this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null), this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null), this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null), this._sasl_mechanism = new e[n], this._sasl_mechanism.onStart(this);
                                var i = R("auth", {
                                    xmlns: w.NS.SASL,
                                    mechanism: this._sasl_mechanism.name
                                });
                                if (this._sasl_mechanism.isClientFirst) {
                                    var s = this._sasl_mechanism.onChallenge(this, null);
                                    i.t(btoa(s))
                                }
                                this.send(i.tree()), t = !0;
                                break
                            } return t
                    },
                    _sasl_challenge_cb: function(e) {
                        var t = atob(w.getText(e)),
                            n = this._sasl_mechanism.onChallenge(this, t),
                            i = R("response", {
                                xmlns: w.NS.SASL
                            });
                        return "" !== n && i.t(btoa(n)), this.send(i.tree()), !0
                    },
                    _attemptLegacyAuth: function() {
                        null === w.getNodeFromJid(this.jid) ? (this._changeConnectStatus(w.Status.CONNFAIL, w.ErrorCondition.MISSING_JID_NODE), this.disconnect(w.ErrorCondition.MISSING_JID_NODE)) : (this._changeConnectStatus(w.Status.AUTHENTICATING, null), this._addSysHandler(this._onLegacyAuthIQResult.bind(this), null, null, null, "_auth_1"), this.send(A({
                            type: "get",
                            to: this.domain,
                            id: "_auth_1"
                        }).c("query", {
                            xmlns: w.NS.AUTH
                        }).c("username", {}).t(w.getNodeFromJid(this.jid)).tree()))
                    },
                    _onLegacyAuthIQResult: function(e) {
                        var t = A({
                            type: "set",
                            id: "_auth_2"
                        }).c("query", {
                            xmlns: w.NS.AUTH
                        }).c("username", {}).t(w.getNodeFromJid(this.jid)).up().c("password").t(this.pass);
                        return w.getResourceFromJid(this.jid) || (this.jid = w.getBareJidFromJid(this.jid) + "/strophe"), t.up().c("resource", {}).t(w.getResourceFromJid(this.jid)), this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2"), this.send(t.tree()), !1
                    },
                    _sasl_success_cb: function(e) {
                        var t = this;
                        if (this._sasl_data["server-signature"]) {
                            var n, i = atob(w.getText(e)).match(/([a-z]+)=([^,]+)(,|$)/);
                            if ("v" === i[1] && (n = i[2]), n !== this._sasl_data["server-signature"]) return this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_data = {}, this._sasl_failure_cb(null)
                        }
                        w.info("SASL authentication succeeded."), this._sasl_mechanism && this._sasl_mechanism.onSuccess(), this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null);
                        var s = [],
                            r = function(e, n) {
                                for (; e.length;) t.deleteHandler(e.pop());
                                return t._onStreamFeaturesAfterSASL(n), !1
                            };
                        return s.push(this._addSysHandler((function(e) {
                            return r(s, e)
                        }), null, "stream:features", null, null)), s.push(this._addSysHandler((function(e) {
                            return r(s, e)
                        }), w.NS.STREAM, "features", null, null)), this._sendRestart(), !1
                    },
                    _onStreamFeaturesAfterSASL: function(e) {
                        this.features = e;
                        for (var t = 0; t < e.childNodes.length; t++) {
                            var n = e.childNodes[t];
                            "bind" === n.nodeName && (this.do_bind = !0), "session" === n.nodeName && (this.do_session = !0)
                        }
                        return this.do_bind ? (this.options.explicitResourceBinding ? this._changeConnectStatus(w.Status.BINDREQUIRED, null) : this.bind(), !1) : (this._changeConnectStatus(w.Status.AUTHFAIL, null), !1)
                    },
                    bind: function() {
                        if (this.do_bind) {
                            this._addSysHandler(this._onResourceBindResultIQ.bind(this), null, null, null, "_bind_auth_2");
                            var e = w.getResourceFromJid(this.jid);
                            e ? this.send(A({
                                type: "set",
                                id: "_bind_auth_2"
                            }).c("bind", {
                                xmlns: w.NS.BIND
                            }).c("resource", {}).t(e).tree()) : this.send(A({
                                type: "set",
                                id: "_bind_auth_2"
                            }).c("bind", {
                                xmlns: w.NS.BIND
                            }).tree())
                        } else w.log(w.LogLevel.INFO, 'Strophe.Connection.prototype.bind called but "do_bind" is false')
                    },
                    _onResourceBindResultIQ: function(e) {
                        var t;
                        if ("error" === e.getAttribute("type")) return w.warn("Resource binding failed."), e.getElementsByTagName("conflict").length > 0 && (t = w.ErrorCondition.CONFLICT), this._changeConnectStatus(w.Status.AUTHFAIL, t, e), !1;
                        var n = e.getElementsByTagName("bind");
                        if (!(n.length > 0)) return w.warn("Resource binding failed."), this._changeConnectStatus(w.Status.AUTHFAIL, null, e), !1;
                        var i = n[0].getElementsByTagName("jid");
                        i.length > 0 && (this.jid = w.getText(i[0]), this.do_session ? this._establishSession() : (this.authenticated = !0, this._changeConnectStatus(w.Status.CONNECTED, null)))
                    },
                    _establishSession: function() {
                        if (!this.do_session) throw new Error("Strophe.Connection.prototype._establishSession " + "called but apparently ".concat(w.NS.SESSION, " wasn't advertised by the server"));
                        this._addSysHandler(this._onSessionResultIQ.bind(this), null, null, null, "_session_auth_2"), this.send(A({
                            type: "set",
                            id: "_session_auth_2"
                        }).c("session", {
                            xmlns: w.NS.SESSION
                        }).tree())
                    },
                    _onSessionResultIQ: function(e) {
                        if ("result" === e.getAttribute("type")) this.authenticated = !0, this._changeConnectStatus(w.Status.CONNECTED, null);
                        else if ("error" === e.getAttribute("type")) return w.warn("Session creation failed."), this._changeConnectStatus(w.Status.AUTHFAIL, null, e), !1;
                        return !1
                    },
                    _sasl_failure_cb: function(e) {
                        return this._sasl_success_handler && (this.deleteHandler(this._sasl_success_handler), this._sasl_success_handler = null), this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_mechanism && this._sasl_mechanism.onFailure(), this._changeConnectStatus(w.Status.AUTHFAIL, null, e), !1
                    },
                    _auth2_cb: function(e) {
                        return "result" === e.getAttribute("type") ? (this.authenticated = !0, this._changeConnectStatus(w.Status.CONNECTED, null)) : "error" === e.getAttribute("type") && (this._changeConnectStatus(w.Status.AUTHFAIL, null, e), this.disconnect("authentication failed")), !1
                    },
                    _addSysTimedHandler: function(e, t) {
                        var n = new w.TimedHandler(e, t);
                        return n.user = !1, this.addTimeds.push(n), n
                    },
                    _addSysHandler: function(e, t, n, i, s) {
                        var r = new w.Handler(e, t, n, i, s);
                        return r.user = !1, this.addHandlers.push(r), r
                    },
                    _onDisconnectTimeout: function() {
                        return w.debug("_onDisconnectTimeout was called"), this._changeConnectStatus(w.Status.CONNTIMEOUT, null), this._proto._onDisconnectTimeout(), this._doDisconnect(), !1
                    },
                    _onIdle: function() {
                        for (var e = this; this.addTimeds.length > 0;) this.timedHandlers.push(this.addTimeds.pop());
                        for (; this.removeTimeds.length > 0;) {
                            var t = this.removeTimeds.pop(),
                                n = this.timedHandlers.indexOf(t);
                            n >= 0 && this.timedHandlers.splice(n, 1)
                        }
                        for (var i = (new Date).getTime(), s = [], r = 0; r < this.timedHandlers.length; r++) {
                            var o = this.timedHandlers[r];
                            !this.authenticated && o.user || (o.lastCalled + o.period - i <= 0 ? o.run() && s.push(o) : s.push(o))
                        }
                        this.timedHandlers = s, clearTimeout(this._idleTimeout), this._proto._onIdle(), this.connected && (this._idleTimeout = setTimeout((function() {
                            return e._onIdle()
                        }), 100))
                    }
                }, w.SASLMechanism = function(e, t, n) {
                    this.name = e, this.isClientFirst = t, this.priority = n
                }, w.SASLMechanism.prototype = {
                    test: function(e) {
                        return !0
                    },
                    onStart: function(e) {
                        this._connection = e
                    },
                    onChallenge: function(e, t) {
                        throw new Error("You should implement challenge handling!")
                    },
                    onFailure: function() {
                        this._connection = null
                    },
                    onSuccess: function() {
                        this._connection = null
                    }
                }, w.SASLAnonymous = function() {}, w.SASLAnonymous.prototype = new w.SASLMechanism("ANONYMOUS", !1, 20), w.SASLAnonymous.prototype.test = function(e) {
                    return null === e.authcid
                }, w.SASLPlain = function() {}, w.SASLPlain.prototype = new w.SASLMechanism("PLAIN", !0, 50), w.SASLPlain.prototype.test = function(e) {
                    return null !== e.authcid
                }, w.SASLPlain.prototype.onChallenge = function(e) {
                    var t = e.authzid;
                    return t += "\0", t += e.authcid, t += "\0", t += e.pass, C(t)
                }, w.SASLSHA1 = function() {}, w.SASLSHA1.prototype = new w.SASLMechanism("SCRAM-SHA-1", !0, 70), w.SASLSHA1.prototype.test = function(e) {
                    return null !== e.authcid
                }, w.SASLSHA1.prototype.onChallenge = function(e, t, n) {
                    var i = n || h.hexdigest("" + 1234567890 * Math.random()),
                        s = "n=" + C(e.authcid);
                    return s += ",r=", s += i, e._sasl_data.cnonce = i, e._sasl_data["client-first-message-bare"] = s, s = "n,," + s, this.onChallenge = function(e, t) {
                        for (var n, i, s, r, o, a, c, d, u = "c=biws,", l = "".concat(e._sasl_data["client-first-message-bare"], ",").concat(t, ","), h = e._sasl_data.cnonce, p = /([a-z]+)=([^,]+)(,|$)/; t.match(p);) {
                            var m = t.match(p);
                            switch (t = t.replace(m[0], ""), m[1]) {
                                case "r":
                                    n = m[2];
                                    break;
                                case "s":
                                    i = m[2];
                                    break;
                                case "i":
                                    s = m[2]
                            }
                        }
                        if (n.substr(0, h.length) !== h) return e._sasl_data = {}, e._sasl_failure_cb();
                        l += u += "r=" + n, i = atob(i), i += "\0\0\0";
                        var f = C(e.pass);
                        for (r = a = b.core_hmac_sha1(f, i), c = 1; c < s; c++) {
                            for (o = b.core_hmac_sha1(f, b.binb2str(a)), d = 0; d < 5; d++) r[d] ^= o[d];
                            a = o
                        }
                        r = b.binb2str(r);
                        var g = b.core_hmac_sha1(r, "Client Key"),
                            _ = b.str_hmac_sha1(r, "Server Key"),
                            v = b.core_hmac_sha1(b.str_sha1(b.binb2str(g)), l);
                        for (e._sasl_data["server-signature"] = b.b64_hmac_sha1(_, l), d = 0; d < 5; d++) g[d] ^= v[d];
                        return u += ",p=" + btoa(b.binb2str(g))
                    }, s
                }, w.SASLMD5 = function() {}, w.SASLMD5.prototype = new w.SASLMechanism("DIGEST-MD5", !1, 60), w.SASLMD5.prototype.test = function(e) {
                    return null !== e.authcid
                }, w.SASLMD5.prototype._quote = function(e) {
                    return '"' + e.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'
                }, w.SASLMD5.prototype.onChallenge = function(e, t, n) {
                    for (var i = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/, s = n || h.hexdigest("" + 1234567890 * Math.random()), r = "", o = null, a = ""; t.match(i);) {
                        var c = t.match(i);
                        switch (t = t.replace(c[0], ""), c[2] = c[2].replace(/^"(.+)"$/, "$1"), c[1]) {
                            case "realm":
                                r = c[2];
                                break;
                            case "nonce":
                                a = c[2];
                                break;
                            case "qop":
                                c[2];
                                break;
                            case "host":
                                o = c[2]
                        }
                    }
                    var d = e.servtype + "/" + e.domain;
                    null !== o && (d = d + "/" + o);
                    var u = C(e.authcid + ":" + r + ":" + this._connection.pass),
                        l = h.hash(u) + ":" + a + ":" + s,
                        p = "AUTHENTICATE:" + d,
                        m = "";
                    return m += "charset=utf-8,", m += "username=" + this._quote(C(e.authcid)) + ",", m += "realm=" + this._quote(r) + ",", m += "nonce=" + this._quote(a) + ",", m += "nc=00000001,", m += "cnonce=" + this._quote(s) + ",", m += "digest-uri=" + this._quote(d) + ",", m += "response=" + h.hexdigest(h.hexdigest(l) + ":" + a + ":00000001:" + s + ":auth:" + h.hexdigest(p)) + ",", m += "qop=auth", this.onChallenge = function() {
                        return ""
                    }, m
                }, w.SASLOAuthBearer = function() {}, w.SASLOAuthBearer.prototype = new w.SASLMechanism("OAUTHBEARER", !0, 40), w.SASLOAuthBearer.prototype.test = function(e) {
                    return null !== e.pass
                }, w.SASLOAuthBearer.prototype.onChallenge = function(e) {
                    var t = "n,";
                    return null !== e.authcid && (t = t + "a=" + e.authzid), t += ",", t += "", t += "auth=Bearer ", t += e.pass, t += "", C(t += "")
                }, w.SASLExternal = function() {}, w.SASLExternal.prototype = new w.SASLMechanism("EXTERNAL", !0, 10), w.SASLExternal.prototype.onChallenge = function(e) {
                    return e.authcid === e.authzid ? "" : e.authzid
                }, w.SASLXOAuth2 = function() {}, w.SASLXOAuth2.prototype = new w.SASLMechanism("X-OAUTH2", !0, 30), w.SASLXOAuth2.prototype.test = function(e) {
                    return null !== e.pass
                }, w.SASLXOAuth2.prototype.onChallenge = function(e) {
                    var t = "\0";
                    return null !== e.authcid && (t += e.authzid), t += "\0", t += e.pass, C(t)
                };
                var D = {
                        Strophe: w,
                        $build: R,
                        $iq: A,
                        $msg: function(e) {
                            return new w.Builder("message", e)
                        },
                        $pres: I,
                        SHA1: b,
                        MD5: h,
                        b64_hmac_sha1: b.b64_hmac_sha1,
                        b64_sha1: b.b64_sha1,
                        str_hmac_sha1: b.str_hmac_sha1,
                        str_sha1: b.str_sha1
                    },
                    P = D.Strophe,
                    O = D.$build;
                P.Request = function(e, t, n, i) {
                    this.id = ++P._requestId, this.xmlData = e, this.data = P.serialize(e), this.origFunc = t, this.func = t, this.rid = n, this.date = NaN, this.sends = i || 0, this.abort = !1, this.dead = null, this.age = function() {
                        return this.date ? (new Date - this.date) / 1e3 : 0
                    }, this.timeDead = function() {
                        return this.dead ? (new Date - this.dead) / 1e3 : 0
                    }, this.xhr = this._newXHR()
                }, P.Request.prototype = {
                    getResponse: function() {
                        var e = null;
                        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                            if ("parsererror" === (e = this.xhr.responseXML.documentElement).tagName) throw P.error("invalid response received"), P.error("responseText: " + this.xhr.responseText), P.error("responseXML: " + P.serialize(this.xhr.responseXML)), new Error("parsererror")
                        } else if (this.xhr.responseText) {
                            if (P.debug("Got responseText but no responseXML; attempting to parse it with DOMParser..."), !(e = (new DOMParser).parseFromString(this.xhr.responseText, "application/xml").documentElement)) throw new Error("Parsing produced null node");
                            if (e.querySelector("parsererror")) {
                                P.error("invalid response received: " + e.querySelector("parsererror").textContent), P.error("responseText: " + this.xhr.responseText);
                                var t = new Error;
                                throw t.name = P.ErrorCondition.BAD_FORMAT, t
                            }
                        }
                        return e
                    },
                    _newXHR: function() {
                        var e = null;
                        return window.XMLHttpRequest ? (e = new XMLHttpRequest).overrideMimeType && e.overrideMimeType("text/xml; charset=utf-8") : window.ActiveXObject && (e = new ActiveXObject("Microsoft.XMLHTTP")), e.onreadystatechange = this.func.bind(null, this), e
                    }
                }, P.Bosh = function(e) {
                    this._conn = e, this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.hold = 1, this.wait = 60, this.window = 5, this.errors = 0, this.inactivity = null, this.lastResponseHeaders = null, this._requests = []
                }, P.Bosh.prototype = {
                    strip: null,
                    _buildBody: function() {
                        var e = O("body", {
                            rid: this.rid++,
                            xmlns: P.NS.HTTPBIND
                        });
                        return null !== this.sid && e.attrs({
                            sid: this.sid
                        }), this._conn.options.keepalive && this._conn._sessionCachingSupported() && this._cacheSession(), e
                    },
                    _reset: function() {
                        this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.errors = 0, this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                    },
                    _connect: function(e, t, n) {
                        this.wait = e || this.wait, this.hold = t || this.hold, this.errors = 0;
                        var i = this._buildBody().attrs({
                            to: this._conn.domain,
                            "xml:lang": "en",
                            wait: this.wait,
                            hold: this.hold,
                            content: "text/xml; charset=utf-8",
                            ver: "1.6",
                            "xmpp:version": "1.0",
                            "xmlns:xmpp": P.NS.BOSH
                        });
                        n && i.attrs({
                            route: n
                        });
                        var s = this._conn._connect_cb;
                        this._requests.push(new P.Request(i.tree(), this._onRequestStateChange.bind(this, s.bind(this._conn)), i.tree().getAttribute("rid"))), this._throttledRequestHandler()
                    },
                    _attach: function(e, t, n, i, s, r, o) {
                        this._conn.jid = e, this.sid = t, this.rid = n, this._conn.connect_callback = i, this._conn.domain = P.getDomainFromJid(this._conn.jid), this._conn.authenticated = !0, this._conn.connected = !0, this.wait = s || this.wait, this.hold = r || this.hold, this.window = o || this.window, this._conn._changeConnectStatus(P.Status.ATTACHED, null)
                    },
                    _restore: function(e, t, n, i, s) {
                        var r = JSON.parse(window.sessionStorage.getItem("strophe-bosh-session"));
                        if (!(null != r && r.rid && r.sid && r.jid && (null == e || P.getBareJidFromJid(r.jid) === P.getBareJidFromJid(e) || null === P.getNodeFromJid(e) && P.getDomainFromJid(r.jid) === e))) {
                            var o = new Error("_restore: no restoreable session.");
                            throw o.name = "StropheSessionError", o
                        }
                        this._conn.restored = !0, this._attach(r.jid, r.sid, r.rid, t, n, i, s)
                    },
                    _cacheSession: function() {
                        this._conn.authenticated ? this._conn.jid && this.rid && this.sid && window.sessionStorage.setItem("strophe-bosh-session", JSON.stringify({
                            jid: this._conn.jid,
                            rid: this.rid,
                            sid: this.sid
                        })) : window.sessionStorage.removeItem("strophe-bosh-session")
                    },
                    _connect_cb: function(e) {
                        var t = e.getAttribute("type");
                        if (null !== t && "terminate" === t) {
                            var n = e.getAttribute("condition");
                            P.error("BOSH-Connection failed: " + n);
                            var i = e.getElementsByTagName("conflict");
                            return null !== n ? ("remote-stream-error" === n && i.length > 0 && (n = "conflict"), this._conn._changeConnectStatus(P.Status.CONNFAIL, n)) : this._conn._changeConnectStatus(P.Status.CONNFAIL, "unknown"), this._conn._doDisconnect(n), P.Status.CONNFAIL
                        }
                        this.sid || (this.sid = e.getAttribute("sid"));
                        var s = e.getAttribute("requests");
                        s && (this.window = parseInt(s, 10));
                        var r = e.getAttribute("hold");
                        r && (this.hold = parseInt(r, 10));
                        var o = e.getAttribute("wait");
                        o && (this.wait = parseInt(o, 10));
                        var a = e.getAttribute("inactivity");
                        a && (this.inactivity = parseInt(a, 10))
                    },
                    _disconnect: function(e) {
                        this._sendTerminate(e)
                    },
                    _doDisconnect: function() {
                        this.sid = null, this.rid = Math.floor(4294967295 * Math.random()), this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                    },
                    _emptyQueue: function() {
                        return 0 === this._requests.length
                    },
                    _callProtocolErrorHandlers: function(e) {
                        var t = this._getRequestStatus(e),
                            n = this._conn.protocolErrorHandlers.HTTP[t];
                        n && n.call(this, t)
                    },
                    _hitError: function(e) {
                        this.errors++, P.warn("request errored, status: " + e + ", number of errors: " + this.errors), this.errors > 4 && this._conn._onDisconnectTimeout()
                    },
                    _no_auth_received: function(e) {
                        P.warn("Server did not yet offer a supported authentication mechanism. Sending a blank poll request."), e = e ? e.bind(this._conn) : this._conn._connect_cb.bind(this._conn);
                        var t = this._buildBody();
                        this._requests.push(new P.Request(t.tree(), this._onRequestStateChange.bind(this, e), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
                    },
                    _onDisconnectTimeout: function() {
                        this._abortAllRequests()
                    },
                    _abortAllRequests: function() {
                        for (; this._requests.length > 0;) {
                            var e = this._requests.pop();
                            e.abort = !0, e.xhr.abort(), e.xhr.onreadystatechange = function() {}
                        }
                    },
                    _onIdle: function() {
                        var e = this._conn._data;
                        if (this._conn.authenticated && 0 === this._requests.length && 0 === e.length && !this._conn.disconnecting && (P.debug("no requests during idle cycle, sending blank request"), e.push(null)), !this._conn.paused) {
                            if (this._requests.length < 2 && e.length > 0) {
                                for (var t = this._buildBody(), n = 0; n < e.length; n++) null !== e[n] && ("restart" === e[n] ? t.attrs({
                                    to: this._conn.domain,
                                    "xml:lang": "en",
                                    "xmpp:restart": "true",
                                    "xmlns:xmpp": P.NS.BOSH
                                }) : t.cnode(e[n]).up());
                                delete this._conn._data, this._conn._data = [], this._requests.push(new P.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
                            }
                            if (this._requests.length > 0) {
                                var i = this._requests[0].age();
                                null !== this._requests[0].dead && this._requests[0].timeDead() > Math.floor(P.SECONDARY_TIMEOUT * this.wait) && this._throttledRequestHandler(), i > Math.floor(P.TIMEOUT * this.wait) && (P.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(P.TIMEOUT * this.wait) + " seconds since last activity"), this._throttledRequestHandler())
                            }
                        }
                    },
                    _getRequestStatus: function(e, t) {
                        var n;
                        if (4 === e.xhr.readyState) try {
                            n = e.xhr.status
                        } catch (e) {
                            P.error("Caught an error while retrieving a request's status, reqStatus: " + n)
                        }
                        return void 0 === n && (n = "number" == typeof t ? t : 0), n
                    },
                    _onRequestStateChange: function(e, t) {
                        if (P.debug("request id " + t.id + "." + t.sends + " state changed to " + t.xhr.readyState), t.abort) t.abort = !1;
                        else if (4 === t.xhr.readyState) {
                            var n = this._getRequestStatus(t);
                            if (this.lastResponseHeaders = t.xhr.getAllResponseHeaders(), this.disconnecting && n >= 400) return this._hitError(n), void this._callProtocolErrorHandlers(t);
                            var i = n > 0 && n < 500,
                                s = t.sends > this._conn.maxRetries;
                            if ((i || s) && (this._removeRequest(t), P.debug("request id " + t.id + " should now be removed")), 200 === n) {
                                var r = this._requests[0] === t;
                                (this._requests[1] === t || r && this._requests.length > 0 && this._requests[0].age() > Math.floor(P.SECONDARY_TIMEOUT * this.wait)) && this._restartRequest(0), this._conn.nextValidRid(Number(t.rid) + 1), P.debug("request id " + t.id + "." + t.sends + " got 200"), e(t), this.errors = 0
                            } else 0 === n || n >= 400 && n < 600 || n >= 12e3 ? (P.error("request id " + t.id + "." + t.sends + " error " + n + " happened"), this._hitError(n), this._callProtocolErrorHandlers(t), n >= 400 && n < 500 && (this._conn._changeConnectStatus(P.Status.DISCONNECTING, null), this._conn._doDisconnect())) : P.error("request id " + t.id + "." + t.sends + " error " + n + " happened");
                            i || s ? s && !this._conn.connected && this._conn._changeConnectStatus(P.Status.CONNFAIL, "giving-up") : this._throttledRequestHandler()
                        }
                    },
                    _processRequest: function(e) {
                        var t = this,
                            n = this._requests[e],
                            i = this._getRequestStatus(n, -1);
                        if (n.sends > this._conn.maxRetries) this._conn._onDisconnectTimeout();
                        else {
                            var s = n.age(),
                                r = !isNaN(s) && s > Math.floor(P.TIMEOUT * this.wait),
                                o = null !== n.dead && n.timeDead() > Math.floor(P.SECONDARY_TIMEOUT * this.wait),
                                a = 4 === n.xhr.readyState && (i < 1 || i >= 500);
                            if ((r || o || a) && (o && P.error("Request ".concat(this._requests[e].id, " timed out (secondary), restarting")), n.abort = !0, n.xhr.abort(), n.xhr.onreadystatechange = function() {}, this._requests[e] = new P.Request(n.xmlData, n.origFunc, n.rid, n.sends), n = this._requests[e]), 0 === n.xhr.readyState) {
                                P.debug("request id " + n.id + "." + n.sends + " posting");
                                try {
                                    var c = this._conn.options.contentType || "text/xml; charset=utf-8";
                                    n.xhr.open("POST", this._conn.service, !this._conn.options.sync), void 0 !== n.xhr.setRequestHeader && n.xhr.setRequestHeader("Content-Type", c), this._conn.options.withCredentials && (n.xhr.withCredentials = !0)
                                } catch (e) {
                                    return P.error("XHR open failed: " + e.toString()), this._conn.connected || this._conn._changeConnectStatus(P.Status.CONNFAIL, "bad-service"), void this._conn.disconnect()
                                }
                                var d = function() {
                                    if (n.date = new Date, t._conn.options.customHeaders) {
                                        var e = t._conn.options.customHeaders;
                                        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && n.xhr.setRequestHeader(i, e[i])
                                    }
                                    n.xhr.send(n.data)
                                };
                                if (n.sends > 1) {
                                    var u = 1e3 * Math.min(Math.floor(P.TIMEOUT * this.wait), Math.pow(n.sends, 3));
                                    setTimeout((function() {
                                        d()
                                    }), u)
                                } else d();
                                n.sends++, this._conn.xmlOutput !== P.Connection.prototype.xmlOutput && (n.xmlData.nodeName === this.strip && n.xmlData.childNodes.length ? this._conn.xmlOutput(n.xmlData.childNodes[0]) : this._conn.xmlOutput(n.xmlData)), this._conn.rawOutput !== P.Connection.prototype.rawOutput && this._conn.rawOutput(n.data)
                            } else P.debug("_processRequest: " + (0 === e ? "first" : "second") + " request has readyState of " + n.xhr.readyState)
                        }
                    },
                    _removeRequest: function(e) {
                        P.debug("removing request");
                        for (var t = this._requests.length - 1; t >= 0; t--) e === this._requests[t] && this._requests.splice(t, 1);
                        e.xhr.onreadystatechange = function() {}, this._throttledRequestHandler()
                    },
                    _restartRequest: function(e) {
                        var t = this._requests[e];
                        null === t.dead && (t.dead = new Date), this._processRequest(e)
                    },
                    _reqToData: function(e) {
                        try {
                            return e.getResponse()
                        } catch (e) {
                            if ("parsererror" !== e.message) throw e;
                            this._conn.disconnect("strophe-parsererror")
                        }
                    },
                    _sendTerminate: function(e) {
                        P.debug("_sendTerminate was called");
                        var t = this._buildBody().attrs({
                            type: "terminate"
                        });
                        e && t.cnode(e.tree());
                        var n = new P.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"));
                        this._requests.push(n), this._throttledRequestHandler()
                    },
                    _send: function() {
                        var e = this;
                        clearTimeout(this._conn._idleTimeout), this._throttledRequestHandler(), this._conn._idleTimeout = setTimeout((function() {
                            return e._conn._onIdle()
                        }), 100)
                    },
                    _sendRestart: function() {
                        this._throttledRequestHandler(), clearTimeout(this._conn._idleTimeout)
                    },
                    _throttledRequestHandler: function() {
                        this._requests ? P.debug("_throttledRequestHandler called with " + this._requests.length + " requests") : P.debug("_throttledRequestHandler called with undefined requests"), this._requests && 0 !== this._requests.length && (this._requests.length > 0 && this._processRequest(0), this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window && this._processRequest(1))
                    }
                };
                var N = D.Strophe,
                    M = D.$build;
                return N.Websocket = function(e) {
                    this._conn = e, this.strip = "wrapper";
                    var t = e.service;
                    if (0 !== t.indexOf("ws:") && 0 !== t.indexOf("wss:")) {
                        var n = "";
                        "ws" === e.options.protocol && "https:" !== window.location.protocol ? n += "ws" : n += "wss", n += "://" + window.location.host, 0 !== t.indexOf("/") ? n += window.location.pathname + t : n += t, e.service = n
                    }
                }, N.Websocket.prototype = {
                    _buildStream: function() {
                        return M("open", {
                            xmlns: N.NS.FRAMING,
                            to: this._conn.domain,
                            version: "1.0"
                        })
                    },
                    _check_streamerror: function(e, t) {
                        var n;
                        if (0 === (n = e.getElementsByTagNameNS ? e.getElementsByTagNameNS(N.NS.STREAM, "error") : e.getElementsByTagName("stream:error")).length) return !1;
                        for (var i = n[0], s = "", r = "", o = 0; o < i.childNodes.length; o++) {
                            var a = i.childNodes[o];
                            if ("urn:ietf:params:xml:ns:xmpp-streams" !== a.getAttribute("xmlns")) break;
                            "text" === a.nodeName ? r = a.textContent : s = a.nodeName
                        }
                        var c = "WebSocket stream error: ";
                        return c += s || "unknown", r && (c += " - " + r), N.error(c), this._conn._changeConnectStatus(t, s), this._conn._doDisconnect(), !0
                    },
                    _reset: function() {},
                    _connect: function() {
                        this._closeSocket(), this.socket = new WebSocket(this._conn.service, "xmpp"), this.socket.onopen = this._onOpen.bind(this), this.socket.onerror = this._onError.bind(this), this.socket.onclose = this._onClose.bind(this), this.socket.onmessage = this._connect_cb_wrapper.bind(this)
                    },
                    _connect_cb: function(e) {
                        if (this._check_streamerror(e, N.Status.CONNFAIL)) return N.Status.CONNFAIL
                    },
                    _handleStreamStart: function(e) {
                        var t = !1,
                            n = e.getAttribute("xmlns");
                        "string" != typeof n ? t = "Missing xmlns in <open />" : n !== N.NS.FRAMING && (t = "Wrong xmlns in <open />: " + n);
                        var i = e.getAttribute("version");
                        return "string" != typeof i ? t = "Missing version in <open />" : "1.0" !== i && (t = "Wrong version in <open />: " + i), !t || (this._conn._changeConnectStatus(N.Status.CONNFAIL, t), this._conn._doDisconnect(), !1)
                    },
                    _connect_cb_wrapper: function(e) {
                        if (0 === e.data.indexOf("<open ") || 0 === e.data.indexOf("<?xml")) {
                            var t = e.data.replace(/^(<\?.*?\?>\s*)*/, "");
                            if ("" === t) return;
                            var n = (new DOMParser).parseFromString(t, "text/xml").documentElement;
                            this._conn.xmlInput(n), this._conn.rawInput(e.data), this._handleStreamStart(n) && this._connect_cb(n)
                        } else if (0 === e.data.indexOf("<close ")) {
                            var i = (new DOMParser).parseFromString(e.data, "text/xml").documentElement;
                            this._conn.xmlInput(i), this._conn.rawInput(e.data);
                            var s = i.getAttribute("see-other-uri");
                            if (s) {
                                var r = this._conn.service;
                                (r.indexOf("wss:") >= 0 && s.indexOf("wss:") >= 0 || r.indexOf("ws:") >= 0) && (this._conn._changeConnectStatus(N.Status.REDIRECT, "Received see-other-uri, resetting connection"), this._conn.reset(), this._conn.service = s, this._connect())
                            } else this._conn._changeConnectStatus(N.Status.CONNFAIL, "Received closing stream"), this._conn._doDisconnect()
                        } else {
                            var o = this._streamWrap(e.data),
                                a = (new DOMParser).parseFromString(o, "text/xml").documentElement;
                            this.socket.onmessage = this._onMessage.bind(this), this._conn._connect_cb(a, null, e.data)
                        }
                    },
                    _disconnect: function(e) {
                        if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
                            e && this._conn.send(e);
                            var t = M("close", {
                                xmlns: N.NS.FRAMING
                            });
                            this._conn.xmlOutput(t.tree());
                            var n = N.serialize(t);
                            this._conn.rawOutput(n);
                            try {
                                this.socket.send(n)
                            } catch (e) {
                                N.warn("Couldn't send <close /> tag.")
                            }
                        }
                        this._conn._doDisconnect()
                    },
                    _doDisconnect: function() {
                        N.debug("WebSockets _doDisconnect was called"), this._closeSocket()
                    },
                    _streamWrap: function(e) {
                        return "<wrapper>" + e + "</wrapper>"
                    },
                    _closeSocket: function() {
                        if (this.socket) try {
                            this.socket.onclose = null, this.socket.onerror = null, this.socket.onmessage = null, this.socket.close()
                        } catch (e) {
                            N.debug(e.message)
                        }
                        this.socket = null
                    },
                    _emptyQueue: function() {
                        return !0
                    },
                    _onClose: function(e) {
                        this._conn.connected && !this._conn.disconnecting ? (N.error("Websocket closed unexpectedly"), this._conn._doDisconnect()) : e && 1006 === e.code && !this._conn.connected && this.socket ? (N.error("Websocket closed unexcectedly"), this._conn._changeConnectStatus(N.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._conn._doDisconnect()) : N.debug("Websocket closed")
                    },
                    _no_auth_received: function(e) {
                        N.error("Server did not offer a supported authentication mechanism"), this._conn._changeConnectStatus(N.Status.CONNFAIL, N.ErrorCondition.NO_AUTH_MECH), e && e.call(this._conn), this._conn._doDisconnect()
                    },
                    _onDisconnectTimeout: function() {},
                    _abortAllRequests: function() {},
                    _onError: function(e) {
                        N.error("Websocket error " + e), this._conn._changeConnectStatus(N.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._disconnect()
                    },
                    _onIdle: function() {
                        var e = this._conn._data;
                        if (e.length > 0 && !this._conn.paused) {
                            for (var t = 0; t < e.length; t++)
                                if (null !== e[t]) {
                                    var n = void 0;
                                    n = "restart" === e[t] ? this._buildStream().tree() : e[t];
                                    var i = N.serialize(n);
                                    this._conn.xmlOutput(n), this._conn.rawOutput(i), this.socket.send(i)
                                } this._conn._data = []
                        }
                    },
                    _onMessage: function(e) {
                        var t, n = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
                        if (e.data === n) return this._conn.rawInput(n), this._conn.xmlInput(e), void(this._conn.disconnecting || this._conn._doDisconnect());
                        if (0 === e.data.search("<open ")) {
                            if (t = (new DOMParser).parseFromString(e.data, "text/xml").documentElement, !this._handleStreamStart(t)) return
                        } else {
                            var i = this._streamWrap(e.data);
                            t = (new DOMParser).parseFromString(i, "text/xml").documentElement
                        }
                        return this._check_streamerror(t, N.Status.ERROR) ? void 0 : this._conn.disconnecting && "presence" === t.firstChild.nodeName && "unavailable" === t.firstChild.getAttribute("type") ? (this._conn.xmlInput(t), void this._conn.rawInput(N.serialize(t))) : void this._conn._dataRecv(t, e.data)
                    },
                    _onOpen: function() {
                        N.debug("Websocket open");
                        var e = this._buildStream();
                        this._conn.xmlOutput(e.tree());
                        var t = N.serialize(e);
                        this._conn.rawOutput(t), this.socket.send(t)
                    },
                    _reqToData: function(e) {
                        return e
                    },
                    _send: function() {
                        this._conn.flush()
                    },
                    _sendRestart: function() {
                        clearTimeout(this._conn._idleTimeout), this._conn._onIdle.bind(this._conn)()
                    }
                }, e.Strophe = D.Strophe, e.$build = D.$build, e.$iq = D.$iq, e.$msg = D.$msg, e.$pres = D.$pres, D
            }, e.exports = n()
        }).call(this, n(45))
    }, function(e, t, n) {
        "use strict";
        var i = n(87);
        t.a = new i.a
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        })), n.d(t, "b", (function() {
            return s
        })), n.d(t, "c", (function() {
            return r
        }));
        const i = "audio",
            s = "presenter",
            r = "video"
    }, function(e, t, n) {
        var i = n(80),
            s = n(152),
            r = {},
            o = [],
            a = i.levels.TRACE;
        e.exports = {
            addGlobalTransport: function(e) {
                i.addGlobalTransport(e)
            },
            removeGlobalTransport: function(e) {
                i.removeGlobalTransport(e)
            },
            setGlobalOptions: function(e) {
                i.setGlobalOptions(e)
            },
            getLogger: function(e, t, n) {
                var s = new i(a, e, t, n);
                return e ? (r[e] = r[e] || [], r[e].push(s)) : o.push(s), s
            },
            setLogLevelById: function(e, t) {
                for (var n = t ? r[t] || [] : o, i = 0; i < n.length; i++) n[i].setLevel(e)
            },
            setLogLevel: function(e) {
                a = e;
                for (var t = 0; t < o.length; t++) o[t].setLevel(e);
                for (var n in r) {
                    var i = r[n] || [];
                    for (t = 0; t < i.length; t++) i[t].setLevel(e)
                }
            },
            levels: i.levels,
            LogCollector: s
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return b
            }));
            var i = n(19),
                s = n.n(i),
                r = n(1),
                o = n(21),
                a = n(8),
                c = n(28),
                d = n(3),
                u = n(50),
                l = n.n(u),
                h = n(89),
                p = n(36),
                m = n(62),
                f = n(90),
                g = n(91),
                _ = n(43);
            const v = n(5).getLogger(e);
            let S, y = !1;

            function E(e) {
                p.a.isBackendInitialized() || p.a.initBackend({
                    callStatsID: e.callStatsID,
                    callStatsSecret: e.callStatsSecret,
                    userName: e.userName,
                    aliasName: e.aliasName,
                    applicationName: e.applicationName,
                    getWiFiStatsMethod: e.getWiFiStatsMethod,
                    confID: e.confID,
                    siteID: e.siteID
                }) || v.error("CallStats Backend initialization failed bad")
            }

            function b(e, t) {
                this.rtpStatsMap = new Map, this.eventEmitter = new s.a, this.xmpp = e, this.options = t || {}, this.callStatsIntegrationEnabled = this.options.callStatsID && this.options.callStatsSecret && this.options.enableCallStats && !0 !== b.disableThirdPartyRequests, this.callStatsIntegrationEnabled && (this.callStatsApplicationLogsDisabled = this.options.callStatsApplicationLogsDisabled, d.a.isReactNative() ? E(this.options) : function(e) {
                    y || (l.a.loadScript(e.customScriptUrl || _.a, !0, !0, void 0, () => E(e)), y = !0)
                }(this.options), this.options.confID || v.warn('"confID" is not defined')), this.callsStatsInstances = new Map, b.instances.add(this)
            }
            b.init = function(e) {
                b.audioLevelsEnabled = !e.disableAudioLevels, "number" == typeof e.pcStatsInterval && (b.pcStatsInterval = e.pcStatsInterval), "number" == typeof e.audioLevelsInterval && (b.audioLevelsInterval = e.audioLevelsInterval), "number" == typeof e.longTasksStatsInterval && (b.longTasksStatsInterval = e.longTasksStatsInterval), b.disableThirdPartyRequests = e.disableThirdPartyRequests
            }, b.audioLevelsEnabled = !1, b.audioLevelsInterval = 200, b.pcStatsInterval = 1e4, b.disableThirdPartyRequests = !1, b.analytics = h.a, Object.defineProperty(b, "instances", {
                get: () => (S || (S = new Set), S)
            }), b.prototype.startRemoteStats = function(e) {
                this.stopRemoteStats(e);
                try {
                    const t = new g.a(e, b.audioLevelsInterval, b.pcStatsInterval, this.eventEmitter);
                    t.start(b.audioLevelsEnabled), this.rtpStatsMap.set(e.id, t)
                } catch (e) {
                    v.error("Failed to start collecting remote statistics: " + e)
                }
            }, b.localStats = [], b.startLocalStats = function(e, t) {
                if (!b.audioLevelsEnabled) return;
                const n = new m.a(e, b.audioLevelsInterval, t);
                this.localStats.push(n), n.start()
            }, b.prototype.addAudioLevelListener = function(e) {
                b.audioLevelsEnabled && this.eventEmitter.on(c.a, e)
            }, b.prototype.removeAudioLevelListener = function(e) {
                b.audioLevelsEnabled && this.eventEmitter.removeListener(c.a, e)
            }, b.prototype.addBeforeDisposedListener = function(e) {
                this.eventEmitter.on(c.b, e)
            }, b.prototype.removeBeforeDisposedListener = function(e) {
                this.eventEmitter.removeListener(c.b, e)
            }, b.prototype.addConnectionStatsListener = function(e) {
                this.eventEmitter.on(c.d, e)
            }, b.prototype.removeConnectionStatsListener = function(e) {
                this.eventEmitter.removeListener(c.d, e)
            }, b.prototype.addByteSentStatsListener = function(e) {
                this.eventEmitter.on(c.c, e)
            }, b.prototype.removeByteSentStatsListener = function(e) {
                this.eventEmitter.removeListener(c.c, e)
            }, b.prototype.addLongTasksStatsListener = function(e) {
                this.eventEmitter.on(c.e, e)
            }, b.prototype.attachLongTasksStats = function(e) {
                d.a.supportsPerformanceObserver() ? (this.performanceObserverStats = new f.a(this.eventEmitter, b.longTasksStatsInterval), e.on(r.CONFERENCE_JOINED, () => this.performanceObserverStats.startObserver()), e.on(r.CONFERENCE_LEFT, () => this.performanceObserverStats.stopObserver())) : v.warn("Performance observer for long tasks not supported by browser!")
            }, b.prototype.getLongTasksStats = function() {
                return this.performanceObserverStats ? this.performanceObserverStats.getLongTasksStats() : null
            }, b.prototype.removeLongTasksStatsListener = function(e) {
                this.eventEmitter.removeListener(c.e, e)
            }, b.prototype.setSpeakerList = function(e) {
                for (const t of Array.from(this.rtpStatsMap.values())) t.peerconnection.isP2P || t.setSpeakerList(e)
            }, b.prototype.dispose = function() {
                try {
                    this.callsStatsInstances.size || this.eventEmitter.emit(c.b);
                    for (const e of this.callsStatsInstances.values()) this.stopCallStats(e.tpc);
                    for (const e of this.rtpStatsMap.keys()) this._stopRemoteStats(e);
                    this.eventEmitter && this.eventEmitter.removeAllListeners()
                } finally {
                    b.instances.delete(this)
                }
            }, b.stopLocalStats = function(e) {
                if (b.audioLevelsEnabled)
                    for (let t = 0; t < b.localStats.length; t++)
                        if (b.localStats[t].stream === e) {
                            b.localStats.splice(t, 1)[0].stop();
                            break
                        }
            }, b.prototype._stopRemoteStats = function(e) {
                const t = this.rtpStatsMap.get(e);
                t && (t.stop(), this.rtpStatsMap.delete(e))
            }, b.prototype.stopRemoteStats = function(e) {
                this._stopRemoteStats(e.id)
            }, b.prototype.startCallStats = function(e, t) {
                if (!this.callStatsIntegrationEnabled) return;
                if (this.callsStatsInstances.has(e.id)) return void v.error("CallStats instance for ${tpc} exists already");
                v.info(`Starting CallStats for ${e}...`);
                const n = new p.a(e, {
                    confID: this.options.confID,
                    remoteUserID: t
                });
                this.callsStatsInstances.set(e.id, n)
            }, b._getAllCallStatsInstances = function() {
                const e = new Set;
                for (const t of b.instances)
                    for (const n of t.callsStatsInstances.values()) e.add(n);
                return e
            }, b.prototype.stopCallStats = function(e) {
                const t = this.callsStatsInstances.get(e.id);
                t && (1 === this.callsStatsInstances.size && this.eventEmitter.emit(c.b), this.callsStatsInstances.delete(e.id), t.sendTerminateEvent())
            }, b.prototype.isCallstatsEnabled = function() {
                return this.callStatsIntegrationEnabled
            }, b.prototype.sendConnectionResumeOrHoldEvent = function(e, t) {
                const n = this.callsStatsInstances.get(e.id);
                n && n.sendResumeOrHoldEvent(t)
            }, b.prototype.sendIceConnectionFailedEvent = function(e) {
                const t = this.callsStatsInstances.get(e.id);
                t && t.sendIceConnectionFailedEvent()
            }, b.prototype.sendMuteEvent = function(e, t, n) {
                const i = e && this.callsStatsInstances.get(e.id);
                p.a.sendMuteEvent(t, n, i)
            }, b.prototype.sendScreenSharingEvent = function(e, t) {
                for (const n of this.callsStatsInstances.values()) n.sendScreenSharingEvent(e, t)
            }, b.prototype.sendDominantSpeakerEvent = function(e) {
                for (const e of this.callsStatsInstances.values()) e.sendDominantSpeakerEvent();
                this.xmpp.sendDominantSpeakerEvent(e)
            }, b.sendActiveDeviceListEvent = function(e) {
                const t = b._getAllCallStatsInstances();
                if (t.size)
                    for (const n of t) p.a.sendActiveDeviceListEvent(e, n);
                else p.a.sendActiveDeviceListEvent(e, null)
            }, b.prototype.associateStreamWithVideoTag = function(e, t, n, i, s, r) {
                const o = this.callsStatsInstances.get(e.id);
                o && o.associateStreamWithVideoTag(t, n, i, s, r)
            }, b.sendGetUserMediaFailed = function(e) {
                const t = e instanceof o.a ? function(e) {
                        const t = new Error;
                        return t.stack = e.stack, t.name = (e.name || "Unknown error") + (e.gum && e.gum.error && e.gum.error.name ? " - " + e.gum.error.name : ""), t.constraintName = e.gum && e.gum.constraints ? JSON.stringify(e.gum.constraints) : "", t.message = e.message, t
                    }(e) : e,
                    n = b._getAllCallStatsInstances();
                if (n.size)
                    for (const e of n) p.a.sendGetUserMediaFailed(t, e);
                else p.a.sendGetUserMediaFailed(t, null)
            }, b.prototype.sendCreateOfferFailed = function(e, t) {
                const n = this.callsStatsInstances.get(t.id);
                n && n.sendCreateOfferFailed(e)
            }, b.prototype.sendCreateAnswerFailed = function(e, t) {
                const n = this.callsStatsInstances.get(t.id);
                n && n.sendCreateAnswerFailed(e)
            }, b.prototype.sendSetLocalDescFailed = function(e, t) {
                const n = this.callsStatsInstances.get(t.id);
                n && n.sendSetLocalDescFailed(e)
            }, b.prototype.sendSetRemoteDescFailed = function(e, t) {
                const n = this.callsStatsInstances.get(t.id);
                n && n.sendSetRemoteDescFailed(e)
            }, b.prototype.sendAddIceCandidateFailed = function(e, t) {
                const n = this.callsStatsInstances.get(t.id);
                n && n.sendAddIceCandidateFailed(e)
            }, b.sendLog = function(e) {
                const t = new Set;
                for (const e of b.instances) {
                    if (e.callStatsApplicationLogsDisabled) return;
                    e.callsStatsInstances.size && t.add(e.callsStatsInstances.values().next().value)
                }
                if (t.size)
                    for (const n of t) p.a.sendApplicationLog(e, n);
                else p.a.sendApplicationLog(e, null)
            }, b.prototype.sendFeedback = function(e, t) {
                return b.analytics.sendEvent(a.n, {
                    rating: e,
                    comment: t
                }), p.a.sendFeedback(this.options.confID, e, t)
            }, b.LOCAL_JID = n(155).LOCAL_JID, b.reportGlobalError = function(e) {
                e instanceof o.a && e.gum ? b.sendGetUserMediaFailed(e) : b.sendLog(e)
            }, b.sendAnalyticsAndLog = function(e, t = {}) {
                if (!e) return void v.warn("No event or event name given.");
                let n;
                n = "object" == typeof e ? e : {
                    name: e,
                    properties: t
                }, v.log(JSON.stringify(n)), this.analytics.sendEvent(e, t)
            }, b.sendAnalytics = function(e, t = {}) {
                this.analytics.sendEvent(e, t)
            }
        }).call(this, "modules/statistics/statistics.js")
    }, function(e, t) {
        e.exports = {
            CREATE_ANSWER_FAILED: "rtc.create_answer_failed",
            CREATE_OFFER_FAILED: "rtc.create_offer_failed",
            DATA_CHANNEL_OPEN: "rtc.data_channel_open",
            ENDPOINT_CONN_STATUS_CHANGED: "rtc.endpoint_conn_status_changed",
            DOMINANT_SPEAKER_CHANGED: "rtc.dominant_speaker_changed",
            LASTN_ENDPOINT_CHANGED: "rtc.lastn_endpoint_changed",
            PERMISSIONS_CHANGED: "rtc.permissions_changed",
            SENDER_VIDEO_CONSTRAINTS_CHANGED: "rtc.sender_video_constraints_changed",
            LASTN_VALUE_CHANGED: "rtc.lastn_value_changed",
            LOCAL_TRACK_SSRC_UPDATED: "rtc.local_track_ssrc_updated",
            LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED: "rtc.local_track_max_enabled_resolution_changed",
            TRACK_ATTACHED: "rtc.track_attached",
            REMOTE_TRACK_ADDED: "rtc.remote_track_added",
            REMOTE_TRACK_MUTE: "rtc.remote_track_mute",
            REMOTE_TRACK_REMOVED: "rtc.remote_track_removed",
            REMOTE_TRACK_UNMUTE: "rtc.remote_track_unmute",
            SET_LOCAL_DESCRIPTION_FAILED: "rtc.set_local_description_failed",
            SET_REMOTE_DESCRIPTION_FAILED: "rtc.set_remote_description_failed",
            AUDIO_OUTPUT_DEVICE_CHANGED: "rtc.audio_output_device_changed",
            DEVICE_LIST_CHANGED: "rtc.device_list_changed",
            DEVICE_LIST_WILL_CHANGE: "rtc.device_list_will_change",
            DEVICE_LIST_AVAILABLE: "rtc.device_list_available",
            ENDPOINT_MESSAGE_RECEIVED: "rtc.endpoint_message_received",
            ENDPOINT_STATS_RECEIVED: "rtc.endpoint_stats_received",
            LOCAL_UFRAG_CHANGED: "rtc.local_ufrag_changed",
            REMOTE_UFRAG_CHANGED: "rtc.remote_ufrag_changed"
        }
    }, function(e, t, n) {
        "use strict";

        function i(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = null != arguments[t] ? Object(arguments[t]) : {},
                    i = Object.keys(n);
                "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                    return Object.getOwnPropertyDescriptor(n, e).enumerable
                })))), i.forEach((function(t) {
                    s(e, t, n[t])
                }))
            }
            return e
        }

        function s(e, t, n) {
            return t in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n, e
        }
        n.d(t, "t", (function() {
            return r
        })), n.d(t, "u", (function() {
            return o
        })), n.d(t, "v", (function() {
            return a
        })), n.d(t, "w", (function() {
            return c
        })), n.d(t, "a", (function() {
            return d
        })), n.d(t, "b", (function() {
            return u
        })), n.d(t, "c", (function() {
            return l
        })), n.d(t, "d", (function() {
            return h
        })), n.d(t, "e", (function() {
            return p
        })), n.d(t, "f", (function() {
            return m
        })), n.d(t, "g", (function() {
            return f
        })), n.d(t, "h", (function() {
            return g
        })), n.d(t, "i", (function() {
            return _
        })), n.d(t, "j", (function() {
            return v
        })), n.d(t, "k", (function() {
            return S
        })), n.d(t, "l", (function() {
            return y
        })), n.d(t, "m", (function() {
            return E
        })), n.d(t, "n", (function() {
            return b
        })), n.d(t, "o", (function() {
            return C
        })), n.d(t, "p", (function() {
            return T
        })), n.d(t, "q", (function() {
            return R
        })), n.d(t, "r", (function() {
            return A
        })), n.d(t, "s", (function() {
            return I
        })), n.d(t, "z", (function() {
            return w
        })), n.d(t, "B", (function() {
            return D
        })), n.d(t, "A", (function() {
            return P
        })), n.d(t, "C", (function() {
            return O
        })), n.d(t, "D", (function() {
            return N
        })), n.d(t, "E", (function() {
            return M
        })), n.d(t, "F", (function() {
            return L
        })), n.d(t, "J", (function() {
            return k
        })), n.d(t, "G", (function() {
            return x
        })), n.d(t, "H", (function() {
            return F
        })), n.d(t, "I", (function() {
            return j
        })), n.d(t, "K", (function() {
            return U
        })), n.d(t, "L", (function() {
            return H
        })), n.d(t, "M", (function() {
            return V
        })), n.d(t, "x", (function() {
            return B
        })), n.d(t, "y", (function() {
            return J
        })), n.d(t, "N", (function() {
            return G
        }));
        const r = "operational",
            o = "page",
            a = "track",
            c = "ui",
            d = "restart",
            u = "session-accept.timeout",
            l = "session-initiate.received",
            h = "session-initiate.timeout",
            p = "terminate",
            m = "transport-replace.received",
            f = "transport-replace.success",
            g = "decline",
            _ = "established",
            v = "failed",
            S = "switch.to.jvb",
            y = "available.device",
            E = "connection.disconnected",
            b = "feedback",
            C = "ice.duration",
            T = "ice.establishment.duration.diff",
            R = "ice.state.changed",
            A = "track.no-bytes-sent",
            I = "track.unmuted",
            w = function() {
                return {
                    action: "bridge.down",
                    actionSubject: "bridge.down",
                    type: r
                }
            },
            D = function(e, t, n) {
                return {
                    type: r,
                    action: "connection.failed",
                    attributes: i({
                        error_type: e,
                        error_message: t
                    }, n)
                }
            };

        function P(e, t) {
            return {
                action: e,
                attributes: t,
                source: "conference",
                type: r
            }
        }
        const O = function(e, t) {
                const n = "connection.stage.reached";
                return {
                    action: n,
                    actionSubject: e,
                    attributes: t,
                    source: n,
                    type: r
                }
            },
            N = function(e, t, n) {
                return {
                    attributes: {
                        participant_id: e,
                        region: t,
                        rtt: n
                    },
                    name: "e2e_rtt",
                    type: r
                }
            },
            M = function() {
                return {
                    action: "focus.left",
                    actionSubject: "focus.left",
                    type: r
                }
            },
            L = function(e, t = {}) {
                return {
                    type: r,
                    source: "get.user.media",
                    action: e,
                    attributes: t
                }
            },
            k = function(e = {}) {
                return {
                    type: r,
                    source: "peer.conn.status",
                    action: "duration",
                    attributes: e
                }
            },
            x = function(e, t = {}) {
                return {
                    type: r,
                    action: e,
                    source: "jingle",
                    attributes: t
                }
            },
            F = function(e, t) {
                return {
                    attributes: {
                        media_type: e,
                        value: t
                    },
                    action: "track.no.data.from.source",
                    type: r
                }
            },
            j = function(e, t = {}) {
                return {
                    type: r,
                    action: e,
                    source: "p2p",
                    attributes: t
                }
            },
            U = function(e) {
                return {
                    type: r,
                    action: "remotely.muted",
                    mediaType: e
                }
            },
            H = function(e) {
                return {
                    type: r,
                    action: "rtp.stats",
                    attributes: e
                }
            },
            V = function(e) {
                return {
                    type: r,
                    action: "transport.stats",
                    attributes: e
                }
            };

        function B(e, t, n) {
            return {
                type: r,
                action: "audio.output.problem",
                attributes: {
                    userID: e,
                    localAudioLevels: t,
                    remoteAudioLevels: n
                }
            }
        }
        const J = function(e, t) {
                return {
                    type: r,
                    action: "bridge-channel.error",
                    attributes: {
                        code: e,
                        reason: t
                    }
                }
            },
            G = function(e) {
                return O("ttfm", e)
            }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(5),
                s = n(20),
                r = n.n(s),
                o = n(10),
                a = n.n(o),
                c = n(3),
                d = n(37),
                u = n.n(d);
            const l = Object(i.getLogger)(e),
                h = {
                    filterSpecialChars: e => e ? e.replace(/[\\\/\{,\}\+]/g, "") : e,
                    iceparams(e, t) {
                        let n, i, s = null;
                        return (i = h.findLine(e, "a=ice-ufrag:", t)) && (n = h.findLine(e, "a=ice-pwd:", t)) && (s = {
                            ufrag: h.parseICEUfrag(i),
                            pwd: h.parseICEPwd(n)
                        }), s
                    },
                    parseICEUfrag: e => e.substring(12),
                    buildICEUfrag: e => "a=ice-ufrag:" + e,
                    parseICEPwd: e => e.substring(10),
                    buildICEPwd: e => "a=ice-pwd:" + e,
                    parseMID: e => e.substring(6),
                    parseMLine(e) {
                        const t = {},
                            n = e.substring(2).split(" ");
                        return t.media = n.shift(), t.port = n.shift(), t.proto = n.shift(), "" === n[n.length - 1] && n.pop(), t.fmt = n, t
                    },
                    buildMLine: e => `m=${e.media} ${e.port} ${e.proto} ${e.fmt.join(" ")}`,
                    parseRTPMap(e) {
                        const t = {};
                        let n = e.substring(9).split(" ");
                        return t.id = n.shift(), n = n[0].split("/"), t.name = n.shift(), t.clockrate = n.shift(), t.channels = n.length ? n.shift() : "1", t
                    },
                    parseSCTPMap(e) {
                        const t = e.substring(10).split(" ");
                        return [t[0], t[1], t.length > 2 ? t[2] : null]
                    },
                    buildRTPMap(e) {
                        let t = `a=rtpmap:${e.getAttribute("id")} ${e.getAttribute("name")}/${e.getAttribute("clockrate")}`;
                        return e.getAttribute("channels") && "1" !== e.getAttribute("channels") && (t += "/" + e.getAttribute("channels")), t
                    },
                    parseCrypto(e) {
                        const t = {},
                            n = e.substring(9).split(" ");
                        return t.tag = n.shift(), t["crypto-suite"] = n.shift(), t["key-params"] = n.shift(), n.length && (t["session-params"] = n.join(" ")), t
                    },
                    parseFingerprint(e) {
                        const t = {},
                            n = e.substring(14).split(" ");
                        return t.hash = n.shift(), t.fingerprint = n.shift(), t
                    },
                    parseFmtp(e) {
                        const t = [];
                        let n = e.split(" ");
                        n.shift(), n = n.join(" ").split(";");
                        for (let e = 0; e < n.length; e++) {
                            let i = n[e].split("=")[0];
                            for (; i.length && " " === i[0];) i = i.substring(1);
                            const s = n[e].split("=")[1];
                            i && s ? t.push({
                                name: i,
                                value: s
                            }) : i && t.push({
                                name: "",
                                value: i
                            })
                        }
                        return t
                    },
                    parseICECandidate(e) {
                        const t = {},
                            n = e.split(" ");
                        t.foundation = n[0].substring(12), t.component = n[1], t.protocol = n[2].toLowerCase(), t.priority = n[3], t.ip = n[4], t.port = n[5], t.type = n[7], t.generation = 0;
                        for (let e = 8; e < n.length; e += 2) switch (n[e]) {
                            case "raddr":
                                t["rel-addr"] = n[e + 1];
                                break;
                            case "rport":
                                t["rel-port"] = n[e + 1];
                                break;
                            case "generation":
                                t.generation = n[e + 1];
                                break;
                            case "tcptype":
                                t.tcptype = n[e + 1];
                                break;
                            default:
                                l.debug(`parseICECandidate not translating "${n[e]}" = "${n[e+1]}"`)
                        }
                        return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
                    },
                    buildICECandidate(e) {
                        let t = ["a=candidate:" + e.foundation, e.component, e.protocol, e.priority, e.ip, e.port, "typ", e.type].join(" ");
                        switch (t += " ", e.type) {
                            case "srflx":
                            case "prflx":
                            case "relay":
                                e.hasOwnAttribute("rel-addr") && e.hasOwnAttribute("rel-port") && (t += "raddr", t += " ", t += e["rel-addr"], t += " ", t += "rport", t += " ", t += e["rel-port"], t += " ")
                        }
                        return e.hasOwnAttribute("tcptype") && (t += "tcptype", t += " ", t += e.tcptype, t += " "), t += "generation", t += " ", t += e.hasOwnAttribute("generation") ? e.generation : "0", t
                    },
                    parseSSRC(e) {
                        const t = new Map,
                            n = e.split("\r\n");
                        for (let e = 0; e < n.length; e++)
                            if ("a=ssrc:" === n[e].substring(0, 7)) {
                                const i = n[e].split("a=ssrc:")[1].split(" ")[0];
                                t.get(i) || t.set(i, []), t.get(i).push(n[e])
                            } return t
                    },
                    parseRTCPFB(e) {
                        const t = e.substr(10).split(" "),
                            n = {};
                        return n.pt = t.shift(), n.type = t.shift(), n.params = t, n
                    },
                    parseExtmap(e) {
                        const t = e.substr(9).split(" "),
                            n = {};
                        return n.value = t.shift(), -1 === n.value.indexOf("/") ? n.direction = "both" : (n.direction = n.value.substr(n.value.indexOf("/") + 1), n.value = n.value.substr(0, n.value.indexOf("/"))), n.uri = t.shift(), n.params = t, n
                    },
                    findLine(e, t, n) {
                        let i = e.split("\r\n");
                        for (let e = 0; e < i.length; e++)
                            if (i[e].substring(0, t.length) === t) return i[e];
                        if (!n) return !1;
                        i = n.split("\r\n");
                        for (let e = 0; e < i.length; e++)
                            if (i[e].substring(0, t.length) === t) return i[e];
                        return !1
                    },
                    findLines(e, t, n) {
                        let i = e.split("\r\n");
                        const s = [];
                        for (let e = 0; e < i.length; e++) i[e].substring(0, t.length) === t && s.push(i[e]);
                        if (s.length || !n) return s;
                        i = n.split("\r\n");
                        for (let e = 0; e < i.length; e++) i[e].substring(0, t.length) === t && s.push(i[e]);
                        return s
                    },
                    candidateToJingle(e) {
                        if (0 === e.indexOf("candidate:")) e = "a=" + e;
                        else if ("a=candidate:" !== e.substring(0, 12)) return l.warn("parseCandidate called with a line that is not a candidate line"), l.warn(e), null;
                        "\r\n" === e.substring(e.length - 2) && (e = e.substring(0, e.length - 2));
                        const t = {},
                            n = e.split(" ");
                        if ("typ" !== n[6]) return l.warn("did not find typ in the right place"), l.warn(e), null;
                        t.foundation = n[0].substring(12), t.component = n[1], t.protocol = n[2].toLowerCase(), t.priority = n[3], t.ip = n[4], t.port = n[5], t.type = n[7], t.generation = "0";
                        for (let e = 8; e < n.length; e += 2) switch (n[e]) {
                            case "raddr":
                                t["rel-addr"] = n[e + 1];
                                break;
                            case "rport":
                                t["rel-port"] = n[e + 1];
                                break;
                            case "generation":
                                t.generation = n[e + 1];
                                break;
                            case "tcptype":
                                t.tcptype = n[e + 1];
                                break;
                            default:
                                l.debug(`not translating "${n[e]}" = "${n[e+1]}"`)
                        }
                        return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
                    },
                    candidateFromJingle(e) {
                        let t = "a=candidate:";
                        t += e.getAttribute("foundation"), t += " ", t += e.getAttribute("component"), t += " ";
                        let n = e.getAttribute("protocol");
                        switch (c.a.isFirefox() && "ssltcp" === n.toLowerCase() && (n = "tcp"), t += n, t += " ", t += e.getAttribute("priority"), t += " ", t += e.getAttribute("ip"), t += " ", t += e.getAttribute("port"), t += " ", t += "typ", t += " " + e.getAttribute("type"), t += " ", e.getAttribute("type")) {
                            case "srflx":
                            case "prflx":
                            case "relay":
                                e.getAttribute("rel-addr") && e.getAttribute("rel-port") && (t += "raddr", t += " ", t += e.getAttribute("rel-addr"), t += " ", t += "rport", t += " ", t += e.getAttribute("rel-port"), t += " ")
                        }
                        return "tcp" === n.toLowerCase() && (t += "tcptype", t += " ", t += e.getAttribute("tcptype"), t += " "), t += "generation", t += " ", t += e.getAttribute("generation") || "0", t + "\r\n"
                    },
                    parsePrimaryVideoSsrc(e) {
                        const t = e.ssrcs.map(e => e.id).filter((e, t, n) => n.indexOf(e) === t).length,
                            n = e.ssrcGroups && e.ssrcGroups.length || 0;
                        if (t > 1 && 0 === n) return;
                        let i = null;
                        if (1 === t) i = e.ssrcs[0].id;
                        else if (2 === t) {
                            const t = e.ssrcGroups.find(e => "FID" === e.semantics);
                            t && (i = t.ssrcs.split(" ")[0])
                        } else if (t >= 3) {
                            const t = e.ssrcGroups.find(e => "SIM" === e.semantics);
                            t && (i = t.ssrcs.split(" ")[0])
                        }
                        return i
                    },
                    generateSsrc: () => u.a.randomInt(1, 4294967295),
                    getSsrcAttribute(e, t, n) {
                        for (let i = 0; i < e.ssrcs.length; ++i) {
                            const s = e.ssrcs[i];
                            if (s.id === t && s.attribute === n) return s.value
                        }
                    },
                    parseGroupSsrcs: e => e.ssrcs.split(" ").map(e => parseInt(e, 10)),
                    getMedia: (e, t) => e.media.find(e => e.type === t),
                    getUfrag(e) {
                        const t = e.split("\n").filter(e => e.startsWith("a=ice-ufrag:"));
                        if (t.length > 0) return t[0].substr("a=ice-ufrag:".length)
                    },
                    preferCodec(e, t) {
                        if (!e || !t) return;
                        const n = e.rtp.filter(e => e.codec && e.codec.toLowerCase() === t.toLowerCase()).map(e => e.payload);
                        if (n) {
                            const t = e.payloads.toString().split(" ").map(e => parseInt(e, 10));
                            for (const e of n.reverse()) {
                                const n = t.indexOf(e);
                                t.splice(n, 1), t.unshift(e)
                            }
                            e.payloads = t.join(" ")
                        }
                    },
                    stripCodec(e, t, n = !1) {
                        if (!e || !t) return;
                        const i = [];
                        let s = [];
                        const o = t.toLowerCase() === r.a.H264 && n;
                        for (const n of e.rtp) n.codec && n.codec.toLowerCase() === t.toLowerCase() && (o ? i.push(n.payload) : s.push(n.payload));
                        if (o && (s = e.fmtp.filter(e => i.indexOf(e.payload) > -1 && e.config.includes("profile-level-id=64")).map(e => e.payload)), s.length > 0) {
                            const t = s.map(e => "apt=" + e),
                                n = e.fmtp.filter(e => -1 !== t.indexOf(e.config));
                            s.push(...n.map(e => e.payload));
                            const i = e.payloads.toString().split(" ").map(Number).filter(e => -1 === s.indexOf(e));
                            0 === i.length ? (e.port = 0, e.direction = a.a.INACTIVE, e.payloads = "*") : e.payloads = i.join(" "), e.rtp = e.rtp.filter(e => -1 !== i.indexOf(e.payload)), e.fmtp = e.fmtp.filter(e => -1 !== i.indexOf(e.payload)), e.rtcpFb && (e.rtcpFb = e.rtcpFb.filter(e => -1 !== i.indexOf(e.payload)))
                        }
                    }
                };
            t.a = h
        }).call(this, "modules/sdp/SDPUtil.js")
    }, function(e, t) {
        e.exports = {
            INACTIVE: "inactive",
            RECVONLY: "recvonly",
            SENDONLY: "sendonly",
            SENDRECV: "sendrecv"
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(19),
                s = n.n(i),
                r = n(5),
                o = n(44),
                a = n.n(o),
                c = n(21),
                d = n(15),
                u = n(47),
                l = n.n(u),
                h = n(7),
                p = n.n(h),
                m = n(66),
                f = n.n(m),
                g = n(14),
                _ = n.n(g),
                v = n(8),
                S = n(3),
                y = n(9),
                E = n(6),
                b = n(12),
                C = n.n(b),
                T = n(22),
                R = n(39);

            function A(e, t) {
                if (null == e) return {};
                var n, i, s = function(e, t) {
                    if (null == e) return {};
                    var n, i, s = {},
                        r = Object.keys(e);
                    for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || (s[n] = e[n]);
                    return s
                }(e, t);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (s[n] = e[n])
                }
                return s
            }
            const I = Object(r.getLogger)(e);
            S.a.usesAdapter() && n(168);
            const w = new s.a,
                D = {
                    video: {
                        height: {
                            ideal: 720,
                            max: 720,
                            min: 180
                        },
                        width: {
                            ideal: 1280,
                            max: 1280,
                            min: 320
                        }
                    }
                };
            let P = "default",
                O = !1,
                N = !1,
                M = !1,
                L = !1,
                k = !1,
                x = null;
            const F = document.createElement("audio"),
                j = void 0 !== F.setSinkId;
            let U, H = [];

            function V() {}

            function B(e, t) {
                const n = Boolean(t) && t.getAudioTracks().length > 0,
                    i = Boolean(t) && t.getVideoTracks().length > 0,
                    s = {}; - 1 !== e.indexOf("video") && (s.video = i), -1 !== e.indexOf("audio") && (s.audio = n), w.emit(p.a.PERMISSIONS_CHANGED, s)
            }

            function J(e) {
                const t = e.filter(e => "audioinput" === e.kind).length,
                    n = e.filter(e => "audiooutput" === e.kind).length,
                    i = e.filter(e => "videoinput" === e.kind).length,
                    s = e.filter(e => "videooutput" === e.kind).length;
                e.forEach(e => {
                    const r = {
                        audio_input_device_count: t,
                        audio_output_device_count: n,
                        video_input_device_count: i,
                        video_output_device_count: s,
                        device_id: e.deviceId,
                        device_group_id: e.groupId,
                        device_kind: e.kind,
                        device_label: e.label
                    };
                    E.a.sendAnalytics(v.l, r)
                })
            }

            function G(e) {
                (function(e) {
                    return e.length !== H.length || e.map(t).sort().join("") !== H.map(t).sort().join("");

                    function t(e) {
                        return JSON.stringify({
                            kind: e.kind,
                            deviceId: e.deviceId,
                            groupId: e.groupId,
                            label: e.label,
                            facing: e.facing
                        })
                    }
                })(e) && (H = e.slice(0), I.info("list of media devices has changed:", H), J(H), w.emit(p.a.DEVICE_LIST_WILL_CHANGE, H), w.emit(p.a.DEVICE_LIST_CHANGED, H))
            }
            class $ extends T.a {
                constructor() {
                    super(w)
                }
                init(e = {}) {
                    var t, n;
                    "boolean" == typeof e.disableAEC && (M = e.disableAEC, I.info("Disable AEC: " + M)), "boolean" == typeof e.disableNS && (L = e.disableNS, I.info("Disable NS: " + L)), "boolean" == typeof e.disableAP && (N = e.disableAP, I.info("Disable AP: " + N)), "boolean" == typeof e.disableAGC && (k = e.disableAGC, I.info("Disable AGC: " + k)), "boolean" == typeof(null === (t = e.audioQuality) || void 0 === t ? void 0 : t.stereo) && (x = e.audioQuality.stereo, I.info("Stereo: " + x)), window.clearInterval(U), U = void 0, S.a.isReactNative() ? (this.RTCPeerConnectionType = RTCPeerConnection, this.attachMediaStream = void 0, this.getStreamID = function({
                        id: e
                    }) {
                        return "number" == typeof e ? e : y.a.filterSpecialChars(e)
                    }, this.getTrackID = ({
                        id: e
                    }) => e) : (this.RTCPeerConnectionType = RTCPeerConnection, this.attachMediaStream = (n = (e, t) => {
                        e && (e.srcObject = t)
                    }, function(e, t) {
                        const i = n.apply(K, arguments);
                        return t && K.isDeviceChangeAvailable("output") && t.getAudioTracks && t.getAudioTracks().length && O && e.setSinkId(K.getAudioOutputDevice()).catch((function(t) {
                            const n = new c.a(t, null, ["audiooutput"]);
                            C.a.callUnhandledRejectionHandler({
                                promise: this,
                                reason: n
                            }), I.warn("Failed to set audio output device for the element. Default audio output device will be used instead", e, n)
                        })), i
                    }), this.getStreamID = ({
                        id: e
                    }) => e, this.getTrackID = ({
                        id: e
                    }) => e), this.pcConstraints = S.a.isChromiumBased() || S.a.isReactNative() ? {
                        optional: [{
                            googScreencastMinBitrate: 100
                        }, {
                            googCpuOveruseDetection: !0
                        }]
                    } : {}, R.b.init(e), this.isDeviceListAvailable() && this.enumerateDevices(e => {
                        H = e.slice(0), I.debug("Available devices: ", H), J(H), w.emit(p.a.DEVICE_LIST_AVAILABLE, H), S.a.supportsDeviceChangeEvent() ? navigator.mediaDevices.addEventListener("devicechange", () => this.enumerateDevices(V)) : U = window.setInterval(() => this.enumerateDevices(V), 3e3)
                    })
                }
                enumerateDevices(e) {
                    navigator.mediaDevices.enumerateDevices().then(t => {
                        G(t), e(t)
                    }).catch(t => {
                        I.warn("Failed to  enumerate devices. " + t), G([]), e([])
                    })
                }
                _getUserMedia(e, t = {}, n = 0) {
                    return new Promise((i, s) => {
                        let r, o = !1;
                        "number" == typeof n && !isNaN(n) && n > 0 && (r = setTimeout(() => {
                            o = !0, r = void 0, s(new c.a(d.TIMEOUT))
                        }, n)), navigator.mediaDevices.getUserMedia(t).then(t => {
                            I.log("onUserMediaSuccess"), B(e, t), o || (void 0 !== r && clearTimeout(r), i(t))
                        }).catch(n => {
                            I.warn(`Failed to get access to local media. ${n} ${JSON.stringify(t)}`);
                            const i = new c.a(n, t, e);
                            o || (void 0 !== r && clearTimeout(r), s(n)), i.name === d.PERMISSION_DENIED && B(e, void 0)
                        })
                    })
                }
                _getDesktopMedia() {
                    return R.b.isSupported() ? new Promise((e, t) => {
                        R.b.obtainStream(t => {
                            e(t)
                        }, e => {
                            t(e)
                        })
                    }) : Promise.reject(new Error("Desktop sharing is not supported!"))
                }
                _getMissingTracks(e = [], t) {
                    const n = [],
                        i = e.includes("audio"),
                        s = t && t.getAudioTracks().length > 0;
                    i && !s && n.push("audio");
                    const r = e.includes("video"),
                        o = t && t.getVideoTracks().length > 0;
                    return r && !o && n.push("video"), n
                }
                obtainAudioAndVideoPermissions(e) {
                    const {
                        timeout: t
                    } = e, n = A(e, ["timeout"]), i = [], s = function() {
                        if (!(-1 !== (n.devices || []).indexOf("desktop"))) return Promise.resolve();
                        const {
                            desktopSharingSourceDevice: e
                        } = n;
                        if (e) {
                            const n = H && H.find(t => "videoinput" === t.kind && (t.deviceId === e || t.label === e));
                            if (!n) return Promise.reject(new c.a({
                                name: "ConstraintNotSatisfiedError"
                            }, {}, [e]));
                            const i = ["video"],
                                s = {
                                    video: {
                                        deviceId: n.deviceId
                                    }
                                };
                            return this._getUserMedia(i, s, t).then(e => ({
                                sourceType: "device",
                                stream: e
                            }))
                        }
                        return this._getDesktopMedia()
                    }.bind(this), r = function() {
                        const e = (n.devices || ["audio", "video"]).filter(e => "audio" === e || "video" === e);
                        if (!e.length) return Promise.resolve();
                        const i = function(e = [], t = {}) {
                            const n = a()(t.constraints || D);
                            if (e.indexOf("video") >= 0) {
                                if (f.a[t.resolution]) {
                                    const e = f.a[t.resolution];
                                    n.video.height = {
                                        ideal: e.height
                                    }, n.video.width = {
                                        ideal: e.width
                                    }
                                }
                                if (n.video || (n.video = {}), S.a.isWebKitBased() && (n.video.height && n.video.height.ideal ? n.video.height = {
                                        ideal: n.video.height.ideal
                                    } : I.warn("Ideal camera height missing, camera may not start properly"), n.video.width && n.video.width.ideal ? n.video.width = {
                                        ideal: n.video.width.ideal
                                    } : I.warn("Ideal camera width missing, camera may not start properly")), t.cameraDeviceId) n.video.deviceId = t.cameraDeviceId;
                                else {
                                    const e = t.facingMode || l.a.USER;
                                    n.video.facingMode = e
                                }
                            } else n.video = !1;
                            return e.indexOf("audio") >= 0 ? (n.audio && "boolean" != typeof n.audio || (n.audio = {}), n.audio = {
                                autoGainControl: !k && !N,
                                deviceId: t.micDeviceId,
                                echoCancellation: !M && !N,
                                noiseSuppression: !L && !N
                            }, x && Object.assign(n.audio, {
                                channelCount: 2
                            })) : n.audio = !1, n
                        }(e, n);
                        return I.info("Got media constraints: ", JSON.stringify(i)), this._getUserMedia(e, i, t)
                    }.bind(this);
                    return s().then((function(e) {
                        if (!e) return;
                        const {
                            stream: t,
                            sourceId: n,
                            sourceType: s
                        } = e, r = t.getAudioTracks();
                        if (r.length) {
                            const e = new MediaStream(r);
                            i.push({
                                stream: e,
                                sourceId: n,
                                sourceType: s,
                                track: e.getAudioTracks()[0]
                            })
                        }
                        const o = t.getVideoTracks();
                        if (o.length) {
                            const e = new MediaStream(o);
                            i.push({
                                stream: e,
                                sourceId: n,
                                sourceType: s,
                                track: e.getVideoTracks()[0],
                                videoType: _.a.DESKTOP
                            })
                        }
                    })).then(r).then((function(e) {
                        if (!e) return;
                        const t = e.getAudioTracks();
                        if (t.length) {
                            const e = new MediaStream(t);
                            i.push({
                                stream: e,
                                track: e.getAudioTracks()[0],
                                effects: n.effects
                            })
                        }
                        const s = e.getVideoTracks();
                        if (s.length) {
                            const e = new MediaStream(s);
                            i.push({
                                stream: e,
                                track: e.getVideoTracks()[0],
                                videoType: _.a.CAMERA,
                                effects: n.effects
                            })
                        }
                    })).then(() => i).catch(e => (i.forEach(({
                        stream: e
                    }) => {
                        this.stopMediaStream(e)
                    }), Promise.reject(e)))
                }
                isDeviceListAvailable() {
                    return Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices)
                }
                isDeviceChangeAvailable(e) {
                    return "output" !== e && "audiooutput" !== e || j
                }
                stopMediaStream(e) {
                    e && (e.getTracks().forEach(e => {
                        e.stop && e.stop()
                    }), e.stop && e.stop(), e.release && e.release())
                }
                isDesktopSharingEnabled() {
                    return R.b.isSupported()
                }
                setAudioOutputDevice(e) {
                    return this.isDeviceChangeAvailable("output") ? F.setSinkId(e).then(() => {
                        P = e, O = !0, I.log("Audio output device set to " + e), w.emit(p.a.AUDIO_OUTPUT_DEVICE_CHANGED, e)
                    }) : Promise.reject(new Error("Audio output device change is not supported"))
                }
                setDesktopSharingFrameRate(e) {
                    R.b.setDesktopSharingFrameRate(e)
                }
                getAudioOutputDevice() {
                    return P
                }
                getCurrentlyAvailableMediaDevices() {
                    return H
                }
                arePermissionsGrantedForAvailableDevices() {
                    return H.some(e => Boolean(e.label))
                }
                getEventDataForActiveDevice(e) {
                    const t = [],
                        n = {
                            deviceId: e.deviceId,
                            kind: e.kind,
                            label: e.label,
                            groupId: e.groupId
                        };
                    return t.push(n), {
                        deviceList: t
                    }
                }
                setSuspendVideo(e, t) {
                    e.optional || (e.optional = []), e.optional = e.optional.filter(e => !e.hasOwnProperty("googSuspendBelowMinBitrate")), t && e.optional.push({
                        googSuspendBelowMinBitrate: "true"
                    })
                }
            }
            const K = new $;
            t.a = K
        }).call(this, "modules/RTC/RTCUtils.js")
    }, function(e, t) {
        const n = [],
            i = window.onerror;
        const s = window.onunhandledrejection;
        window.onerror = function(...e) {
            n.forEach(t => t(...e)), i && i(...e)
        }, window.onunhandledrejection = function(e) {
            n.forEach(t => t(null, null, null, null, e.reason)), s && s(e)
        };
        const r = {
            addHandler(e) {
                n.push(e)
            },
            callErrorHandler(e) {
                const t = window.onerror;
                t && t(null, null, null, null, e)
            },
            callUnhandledRejectionHandler(e) {
                const t = window.onunhandledrejection;
                t && t(e)
            }
        };
        e.exports = r
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return T
            }));
            var i = n(5),
                s = n(1),
                r = n(4),
                o = n(7),
                a = n.n(o),
                c = n(14),
                d = n.n(c),
                u = n(3),
                l = n(6),
                h = n(12),
                p = n.n(h),
                m = n(22),
                f = n(31),
                g = n(117),
                _ = n(118),
                v = n(11),
                S = n(119);
            const y = Object(i.getLogger)(e);
            let E = 0,
                b = 0;

            function C(e = []) {
                return e.map(e => {
                    const {
                        sourceId: t,
                        sourceType: n,
                        stream: i,
                        track: s,
                        videoType: r,
                        effects: o
                    } = e, {
                        deviceId: a,
                        facingMode: c
                    } = s.getSettings();
                    return b = Object(f.d)(b), new _.a({
                        deviceId: a,
                        facingMode: c,
                        mediaType: s.kind,
                        rtcId: b,
                        sourceId: t,
                        sourceType: n,
                        stream: i,
                        track: s,
                        videoType: r || null,
                        effects: o
                    })
                })
            }
            class T extends m.a {
                constructor(e, t = {}) {
                    super(), this.conference = e, this.peerConnections = new Map, this.localTracks = [], this.options = t, this._channel = null, this._lastN = void 0, this._lastNEndpoints = null, this._maxFrameHeight = void 0, this._selectedEndpoints = null, this._lastNChangeListener = this._onLastNChanged.bind(this), this._onDeviceListChanged = this._onDeviceListChanged.bind(this), this._updateAudioOutputForAudioTracks = this._updateAudioOutputForAudioTracks.bind(this), this._videoType = d.a.NONE, v.a.isDeviceChangeAvailable("output") && (v.a.addListener(a.a.AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), v.a.addListener(a.a.DEVICE_LIST_CHANGED, this._onDeviceListChanged))
                }
                destroy() {
                    v.a.removeListener(a.a.AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), v.a.removeListener(a.a.DEVICE_LIST_CHANGED, this._onDeviceListChanged), this._channelOpenListener && this.removeListener(a.a.DATA_CHANNEL_OPEN, this._channelOpenListener)
                }
                static createLocalTracks(e) {
                    return C(e)
                }
                static obtainAudioAndVideoPermissions(e) {
                    return v.a.obtainAudioAndVideoPermissions(e).then(e => C(e))
                }
                initializeBridgeChannel(e, t) {
                    this._channel = new g.a(e, t, this.eventEmitter), this._channelOpenListener = () => {
                        const e = (e, t, n) => {
                            p.a.callErrorHandler(e), y.error(`Cannot send ${t}(${JSON.stringify(n)}) endpoint message`, e)
                        };
                        if (this._receiverVideoConstraints) try {
                            this._channel.sendNewReceiverVideoConstraintsMessage(this._receiverVideoConstraints)
                        } catch (t) {
                            e(t, "ReceiverVideoConstraints", this._receiverVideoConstraints)
                        }
                        if (this._selectedEndpoints) try {
                            this._channel.sendSelectedEndpointsMessage(this._selectedEndpoints)
                        } catch (t) {
                            e(t, "SelectedEndpointsChangedEvent", this._selectedEndpoint)
                        }
                        if (void 0 !== this._maxFrameHeight) try {
                            this._channel.sendReceiverVideoConstraintMessage(this._maxFrameHeight)
                        } catch (t) {
                            e(t, "ReceiverVideoConstraint", this._maxFrameHeight)
                        }
                        if (void 0 !== this._lastN && -1 !== this._lastN) try {
                            this._channel.sendSetLastNMessage(this._lastN)
                        } catch (t) {
                            e(t, "LastNChangedEvent", this._lastN)
                        }
                        try {
                            this._channel.sendVideoTypeMessage(this._videoType)
                        } catch (t) {
                            e(t, "VideoTypeMessage", this._videoType)
                        }
                        this.removeListener(a.a.DATA_CHANNEL_OPEN, this._channelOpenListener), this._channelOpenListener = null
                    }, this.addListener(a.a.DATA_CHANNEL_OPEN, this._channelOpenListener), this.addListener(a.a.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener)
                }
                _onDeviceListChanged() {
                    this._updateAudioOutputForAudioTracks(v.a.getAudioOutputDevice())
                }
                _onLastNChanged(e = []) {
                    const t = this._lastNEndpoints || [];
                    let n = [],
                        i = [];
                    this._lastNEndpoints = e, n = t.filter(e => !this.isInLastN(e)), i = e.filter(e => -1 === t.indexOf(e)), this.conference.eventEmitter.emit(s.LAST_N_ENDPOINTS_CHANGED, n, i)
                }
                onCallEnded() {
                    this._channel && (this._channel && "websocket" === this._channel.mode && this._channel.close(), this._channel = null)
                }
                setDesktopSharingFrameRate(e) {
                    v.a.setDesktopSharingFrameRate(e)
                }
                setNewReceiverVideoConstraints(e) {
                    this._receiverVideoConstraints = e, this._channel && this._channel.isOpen() && this._channel.sendNewReceiverVideoConstraintsMessage(e)
                }
                setReceiverVideoConstraint(e) {
                    this._maxFrameHeight = e, this._channel && this._channel.isOpen() && this._channel.sendReceiverVideoConstraintMessage(e)
                }
                setVideoType(e) {
                    this._videoType !== e && (this._videoType = e, this._channel && this._channel.isOpen() && this._channel.sendVideoTypeMessage(e))
                }
                selectEndpoints(e) {
                    this._selectedEndpoints = e, this._channel && this._channel.isOpen() && this._channel.sendSelectedEndpointsMessage(e)
                }
                static addListener(e, t) {
                    v.a.addListener(e, t)
                }
                static removeListener(e, t) {
                    v.a.removeListener(e, t)
                }
                static init(e = {}) {
                    return this.options = e, v.a.init(this.options)
                }
                createPeerConnection(e, t, n, i) {
                    const s = JSON.parse(JSON.stringify(v.a.pcConstraints));
                    void 0 !== i.abtestSuspendVideo && (v.a.setSuspendVideo(s, i.abtestSuspendVideo), l.a.analytics.addPermanentProperties({
                        abtestSuspendVideo: i.abtestSuspendVideo
                    })), i.enableInsertableStreams && (y.debug("E2EE - setting insertable streams constraints"), t.encodedInsertableStreams = !0);
                    (u.a.isReactNative() || u.a.isChromiumBased() && !i.usesUnifiedPlan) && (t.sdpSemantics = "plan-b"), i.forceTurnRelay && (t.iceTransportPolicy = "relay"), t.bundlePolicy = "max-bundle", E = Object(f.d)(E);
                    const r = new S.a(this, E, e, t, s, n, i);
                    return this.peerConnections.set(r.id, r), r
                }
                _removePeerConnection(e) {
                    const t = e.id;
                    return !!this.peerConnections.has(t) && (this.peerConnections.delete(t), !0)
                }
                addLocalTrack(e) {
                    if (!e) throw new Error("track must not be null nor undefined");
                    this.localTracks.push(e), e.conference = this.conference
                }
                getLocalVideoTrack() {
                    const e = this.getLocalTracks(r.c);
                    return e.length ? e[0] : void 0
                }
                getLocalAudioTrack() {
                    const e = this.getLocalTracks(r.a);
                    return e.length ? e[0] : void 0
                }
                getLocalEndpointId() {
                    return this.conference.myUserId()
                }
                getLocalTracks(e) {
                    let t = this.localTracks.slice();
                    return void 0 !== e && (t = t.filter(t => t.getType() === e)), t
                }
                getRemoteTracks(e) {
                    let t = [];
                    for (const n of this.peerConnections.values()) {
                        const i = n.getRemoteTracks(void 0, e);
                        i && (t = t.concat(i))
                    }
                    return t
                }
                setAudioMute(e) {
                    const t = [];
                    return this.getLocalTracks(r.a).forEach(n => {
                        t.push(e ? n.mute() : n.unmute())
                    }), Promise.all(t)
                }
                setVideoMute(e) {
                    const t = [];
                    return this.getLocalTracks(r.c).concat(this.getLocalTracks(r.b)).forEach(n => {
                        t.push(e ? n.mute() : n.unmute())
                    }), Promise.all(t)
                }
                removeLocalTrack(e) {
                    const t = this.localTracks.indexOf(e); - 1 !== t && this.localTracks.splice(t, 1)
                }
                static attachMediaStream(e, t) {
                    return v.a.attachMediaStream(e, t)
                }
                static getStreamID(e) {
                    return v.a.getStreamID(e)
                }
                static getTrackID(e) {
                    return v.a.getTrackID(e)
                }
                static isDeviceListAvailable() {
                    return v.a.isDeviceListAvailable()
                }
                static isDeviceChangeAvailable(e) {
                    return v.a.isDeviceChangeAvailable(e)
                }
                static isWebRtcSupported() {
                    return u.a.isSupported()
                }
                static getAudioOutputDevice() {
                    return v.a.getAudioOutputDevice()
                }
                static getCurrentlyAvailableMediaDevices() {
                    return v.a.getCurrentlyAvailableMediaDevices()
                }
                static arePermissionsGrantedForAvailableDevices() {
                    return v.a.arePermissionsGrantedForAvailableDevices()
                }
                static getEventDataForActiveDevice(e) {
                    return v.a.getEventDataForActiveDevice(e)
                }
                static setAudioOutputDevice(e) {
                    return v.a.setAudioOutputDevice(e)
                }
                static isUserStream(e) {
                    return T.isUserStreamById(v.a.getStreamID(e))
                }
                static isUserStreamById(e) {
                    return e && "mixedmslabel" !== e && "default" !== e
                }
                static enumerateDevices(e) {
                    v.a.enumerateDevices(e)
                }
                static stopMediaStream(e) {
                    v.a.stopMediaStream(e)
                }
                static isDesktopSharingEnabled() {
                    return v.a.isDesktopSharingEnabled()
                }
                closeBridgeChannel() {
                    this._channel && (this._channel.close(), this._channel = null, this.removeListener(a.a.LASTN_ENDPOINT_CHANGED, this._lastNChangeListener))
                }
                setAudioLevel(e, t, n, i) {
                    const s = e.getTrackBySSRC(t);
                    s && (s.isAudioTrack() ? (s.isLocal() !== i && y.error(`${s} was expected to ${i?"be":"not be"} local`), s.setAudioLevel(n, e)) : y.warn("Received audio level for non-audio track: " + t))
                }
                sendChannelMessage(e, t) {
                    if (!this._channel) throw new Error("Channel support is disabled!");
                    this._channel.sendMessage(e, t)
                }
                sendEndpointStatsMessage(e) {
                    this._channel && this._channel.isOpen() && this._channel.sendEndpointStatsMessage(e)
                }
                setLastN(e) {
                    this._lastN !== e && (this._lastN = e, this._channel && this._channel.isOpen() && this._channel.sendSetLastNMessage(e), this.eventEmitter.emit(a.a.LASTN_VALUE_CHANGED, e))
                }
                isInLastN(e) {
                    return !this._lastNEndpoints || this._lastNEndpoints.indexOf(e) > -1
                }
                _updateAudioOutputForAudioTracks(e) {
                    const t = this.getRemoteTracks(r.a);
                    for (const n of t) n.setAudioOutput(e)
                }
            }
        }).call(this, "modules/RTC/RTC.js")
    }, function(e, t) {
        e.exports = {
            CAMERA: "camera",
            DESKTOP: "desktop",
            NONE: "none"
        }
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "CONSTRAINT_FAILED", (function() {
            return i
        })), n.d(t, "ELECTRON_DESKTOP_PICKER_ERROR", (function() {
            return s
        })), n.d(t, "ELECTRON_DESKTOP_PICKER_NOT_FOUND", (function() {
            return r
        })), n.d(t, "GENERAL", (function() {
            return o
        })), n.d(t, "NOT_FOUND", (function() {
            return a
        })), n.d(t, "PERMISSION_DENIED", (function() {
            return c
        })), n.d(t, "SCREENSHARING_GENERIC_ERROR", (function() {
            return d
        })), n.d(t, "SCREENSHARING_USER_CANCELED", (function() {
            return u
        })), n.d(t, "TIMEOUT", (function() {
            return l
        })), n.d(t, "TRACK_IS_DISPOSED", (function() {
            return h
        })), n.d(t, "TRACK_NO_STREAM_FOUND", (function() {
            return p
        })), n.d(t, "UNSUPPORTED_RESOLUTION", (function() {
            return m
        }));
        const i = "gum.constraint_failed",
            s = "gum.electron_desktop_picker_error",
            r = "gum.electron_desktop_picker_not_found",
            o = "gum.general",
            a = "gum.not_found",
            c = "gum.permission_denied",
            d = "gum.screensharing_generic_error",
            u = "gum.screensharing_user_canceled",
            l = "gum.timeout",
            h = "track.track_is_disposed",
            p = "track.no_stream_found",
            m = "gum.unsupported_resolution"
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "LOCAL_TRACK_STOPPED", (function() {
            return i
        })), n.d(t, "TRACK_AUDIO_LEVEL_CHANGED", (function() {
            return s
        })), n.d(t, "TRACK_AUDIO_OUTPUT_CHANGED", (function() {
            return r
        })), n.d(t, "TRACK_MUTE_CHANGED", (function() {
            return o
        })), n.d(t, "TRACK_VIDEOTYPE_CHANGED", (function() {
            return a
        })), n.d(t, "NO_DATA_FROM_SOURCE", (function() {
            return c
        })), n.d(t, "NO_AUDIO_INPUT", (function() {
            return d
        }));
        const i = "track.stopped",
            s = "track.audioLevelsChanged",
            r = "track.audioOutputChanged",
            o = "track.trackMuteChanged",
            a = "track.videoTypeChanged",
            c = "track.no_data_from_source",
            d = "track.no_audio_input"
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "AUTHENTICATION_REQUIRED", (function() {
            return i
        })), n.d(t, "CHAT_ERROR", (function() {
            return s
        })), n.d(t, "CONFERENCE_DESTROYED", (function() {
            return r
        })), n.d(t, "CONFERENCE_MAX_USERS", (function() {
            return o
        })), n.d(t, "CONNECTION_ERROR", (function() {
            return a
        })), n.d(t, "CONFERENCE_RESTARTED", (function() {
            return c
        })), n.d(t, "NOT_ALLOWED_ERROR", (function() {
            return d
        })), n.d(t, "MEMBERS_ONLY_ERROR", (function() {
            return u
        })), n.d(t, "CONFERENCE_ACCESS_DENIED", (function() {
            return l
        })), n.d(t, "FOCUS_DISCONNECTED", (function() {
            return h
        })), n.d(t, "FOCUS_LEFT", (function() {
            return p
        })), n.d(t, "GRACEFUL_SHUTDOWN", (function() {
            return m
        })), n.d(t, "ICE_FAILED", (function() {
            return f
        })), n.d(t, "INCOMPATIBLE_SERVER_VERSIONS", (function() {
            return g
        })), n.d(t, "OFFER_ANSWER_FAILED", (function() {
            return _
        })), n.d(t, "PASSWORD_NOT_SUPPORTED", (function() {
            return v
        })), n.d(t, "PASSWORD_REQUIRED", (function() {
            return S
        })), n.d(t, "RESERVATION_ERROR", (function() {
            return y
        })), n.d(t, "VIDEOBRIDGE_NOT_AVAILABLE", (function() {
            return E
        }));
        const i = "conference.authenticationRequired",
            s = "conference.chatError",
            r = "conference.destroyed",
            o = "conference.max_users",
            a = "conference.connectionError",
            c = "conference.restarted",
            d = "conference.connectionError.notAllowed",
            u = "conference.connectionError.membersOnly",
            l = "conference.connectionError.accessDenied",
            h = "conference.focusDisconnected",
            p = "conference.focusLeft",
            m = "conference.gracefulShutdown",
            f = "conference.iceFailed",
            g = "conference.incompatible_server_versions",
            _ = "conference.offerAnswerFailed",
            v = "conference.passwordNotSupported",
            S = "conference.passwordRequired",
            y = "conference.reservationError",
            E = "conference.videobridgeNotAvailable"
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return a
        }));
        var i = n(10),
            s = n.n(i),
            r = n(3),
            o = n(9);

        function a(e) {
            const t = e.split("\r\nm=");
            for (let e = 1, n = t.length; e < n; e++) {
                let i = "m=" + t[e];
                e !== n - 1 && (i += "\r\n"), t[e] = i
            }
            const n = t.shift() + "\r\n";
            this.media = t, this.raw = n + t.join(""), this.session = n
        }
        a.prototype.failICE = !1, a.prototype.removeTcpCandidates = !1, a.prototype.removeUdpCandidates = !1, a.prototype.getMediaSsrcMap = function() {
            const e = {};
            for (let t = 0; t < this.media.length; t++) {
                const n = {
                    mediaindex: t,
                    mid: o.a.parseMID(o.a.findLine(this.media[t], "a=mid:")),
                    ssrcs: {},
                    ssrcGroups: []
                };
                e[t] = n, o.a.findLines(this.media[t], "a=ssrc:").forEach(e => {
                    const t = e.substring(7).split(" ")[0];
                    n.ssrcs[t] || (n.ssrcs[t] = {
                        ssrc: t,
                        lines: []
                    }), n.ssrcs[t].lines.push(e)
                }), o.a.findLines(this.media[t], "a=ssrc-group:").forEach(e => {
                    const t = e.indexOf(" "),
                        i = e.substr(0, t).substr(13),
                        s = e.substr(14 + i.length).split(" ");
                    s.length && n.ssrcGroups.push({
                        semantics: i,
                        ssrcs: s
                    })
                })
            }
            return e
        }, a.prototype.containsSSRC = function(e) {
            const t = this.getMediaSsrcMap();
            let n = !1;
            return Object.keys(t).forEach(i => {
                n || t[i].ssrcs[e] && (n = !0)
            }), n
        }, a.prototype.toJingle = function(e, t) {
            o.a.findLines(this.session, "a=group:").forEach(t => {
                const n = t.split(" "),
                    i = n.shift().substr(8);
                e.c("group", {
                    xmlns: "urn:xmpp:jingle:apps:grouping:0",
                    semantics: i
                });
                for (let t = 0; t < n.length; t++) e.c("content", {
                    name: n[t]
                }).up();
                e.up()
            });
            for (let n = 0; n < this.media.length; n++) {
                const i = o.a.parseMLine(this.media[n].split("\r\n")[0]);
                if ("audio" !== i.media && "video" !== i.media && "application" !== i.media) continue;
                let a;
                const c = o.a.findLine(this.media[n], "a=ssrc:");
                a = !!c && c.substring(7).split(" ")[0], e.c("content", {
                    creator: t,
                    name: i.media
                });
                const d = o.a.findLine(this.media[n], "a=mid:");
                if (d) {
                    const t = o.a.parseMID(d);
                    e.attrs({
                        name: t
                    })
                }
                if ("audio" === i.media || "video" === i.media) {
                    e.c("description", {
                        xmlns: "urn:xmpp:jingle:apps:rtp:1",
                        media: i.media
                    }), a && e.attrs({
                        ssrc: a
                    });
                    for (let t = 0; t < i.fmt.length; t++) {
                        const s = o.a.findLine(this.media[n], "a=rtpmap:" + i.fmt[t]);
                        e.c("payload-type", o.a.parseRTPMap(s));
                        const r = o.a.findLine(this.media[n], "a=fmtp:" + i.fmt[t]);
                        if (r) {
                            const t = o.a.parseFmtp(r);
                            for (let n = 0; n < t.length; n++) e.c("parameter", t[n]).up()
                        }
                        this.rtcpFbToJingle(n, e, i.fmt[t]), e.up()
                    }
                    if (a) {
                        const t = o.a.parseSSRC(this.media[n]);
                        for (const [n, i] of t) e.c("source", {
                            ssrc: n,
                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                        }), i.forEach(t => {
                            const n = t.indexOf(" "),
                                i = t.substr(n + 1);
                            if (e.c("parameter"), -1 === i.indexOf(":")) e.attrs({
                                name: i
                            });
                            else {
                                const t = i.split(":", 2)[0];
                                e.attrs({
                                    name: t
                                });
                                let n = i.split(":", 2)[1];
                                n = o.a.filterSpecialChars(n), e.attrs({
                                    value: n
                                })
                            }
                            e.up()
                        }), e.up();
                        o.a.findLines(this.media[n], "a=ssrc-group:").forEach(t => {
                            const n = t.indexOf(" "),
                                i = t.substr(0, n).substr(13),
                                s = t.substr(14 + i.length).split(" ");
                            s.length && (e.c("ssrc-group", {
                                semantics: i,
                                xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                            }), s.forEach(t => e.c("source", {
                                ssrc: t
                            }).up()), e.up())
                        })
                    }
                    const t = o.a.findLines(this.media[n], "a=rid:");
                    if (t.length && r.a.usesRidsForSimulcast()) {
                        const i = t.map(e => e.split(":")[1]).map(e => e.split(" ")[0]);
                        i.forEach(t => {
                            e.c("source", {
                                rid: t,
                                xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                            }), e.up()
                        });
                        o.a.findLine(this.media[n], "a=simulcast:") && (e.c("rid-group", {
                            semantics: "SIM",
                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                        }), i.forEach(t => {
                            e.c("source", {
                                rid: t
                            }).up()
                        }), e.up())
                    }
                    o.a.findLine(this.media[n], "a=rtcp-mux") && e.c("rtcp-mux").up(), this.rtcpFbToJingle(n, e, "*");
                    const c = o.a.findLines(this.media[n], "a=extmap:");
                    for (let t = 0; t < c.length; t++) {
                        const n = o.a.parseExtmap(c[t]);
                        if (e.c("rtp-hdrext", {
                                xmlns: "urn:xmpp:jingle:apps:rtp:rtp-hdrext:0",
                                uri: n.uri,
                                id: n.value
                            }), n.hasOwnProperty("direction")) switch (n.direction) {
                            case s.a.SENDONLY:
                                e.attrs({
                                    senders: "responder"
                                });
                                break;
                            case s.a.RECVONLY:
                                e.attrs({
                                    senders: "initiator"
                                });
                                break;
                            case s.a.SENDRECV:
                                e.attrs({
                                    senders: "both"
                                });
                                break;
                            case s.a.INACTIVE:
                                e.attrs({
                                    senders: "none"
                                })
                        }
                        e.up()
                    }
                    e.up()
                }
                this.transportToJingle(n, e);
                const u = this.media[n];
                o.a.findLine(u, "a=" + s.a.SENDRECV, this.session) ? e.attrs({
                    senders: "both"
                }) : o.a.findLine(u, "a=" + s.a.SENDONLY, this.session) ? e.attrs({
                    senders: "initiator"
                }) : o.a.findLine(u, "a=" + s.a.RECVONLY, this.session) ? e.attrs({
                    senders: "responder"
                }) : o.a.findLine(u, "a=" + s.a.INACTIVE, this.session) && e.attrs({
                    senders: "none"
                }), "0" !== i.port || o.a.findLine(u, "a=bundle-only", this.session) || e.attrs({
                    senders: "rejected"
                }), e.up()
            }
            return e.up(), e
        }, a.prototype.transportToJingle = function(e, t) {
            t.c("transport");
            const n = o.a.findLine(this.media[e], "a=sctpmap:", this.session);
            if (n) {
                const e = o.a.parseSCTPMap(n);
                t.c("sctpmap", {
                    xmlns: "urn:xmpp:jingle:transports:dtls-sctp:1",
                    number: e[0],
                    protocol: e[1]
                }), e.length > 2 && t.attrs({
                    streams: e[2]
                }), t.up()
            }
            o.a.findLines(this.media[e], "a=fingerprint:", this.session).forEach(n => {
                const i = o.a.parseFingerprint(n);
                i.xmlns = "urn:xmpp:jingle:apps:dtls:0", t.c("fingerprint").t(i.fingerprint), delete i.fingerprint;
                const s = o.a.findLine(this.media[e], "a=setup:", this.session);
                s && (i.setup = s.substr(8)), t.attrs(i), t.up()
            });
            const i = o.a.iceparams(this.media[e], this.session);
            if (i) {
                i.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.attrs(i);
                o.a.findLines(this.media[e], "a=candidate:", this.session).forEach(e => {
                    const n = o.a.candidateToJingle(e);
                    this.failICE && (n.ip = "1.1.1.1");
                    const i = n && "string" == typeof n.protocol ? n.protocol.toLowerCase() : "";
                    this.removeTcpCandidates && ("tcp" === i || "ssltcp" === i) || this.removeUdpCandidates && "udp" === i || t.c("candidate", n).up()
                })
            }
            t.up()
        }, a.prototype.rtcpFbToJingle = function(e, t, n) {
            o.a.findLines(this.media[e], "a=rtcp-fb:" + n).forEach(e => {
                const n = o.a.parseRTCPFB(e);
                "trr-int" === n.type ? (t.c("rtcp-fb-trr-int", {
                    xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
                    value: n.params[0]
                }), t.up()) : (t.c("rtcp-fb", {
                    xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
                    type: n.type
                }), n.params.length > 0 && t.attrs({
                    subtype: n.params[0]
                }), t.up())
            })
        }, a.prototype.rtcpFbFromJingle = function(e, t) {
            let n = "";
            const i = e.find('>rtcp-fb-trr-int[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
            i.length && (n += "a=rtcp-fb:* trr-int ", i.attr("value") ? n += i.attr("value") : n += "0", n += "\r\n");
            return e.find('>rtcp-fb[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]').each((e, i) => {
                n += `a=rtcp-fb:${t} ${i.getAttribute("type")}`, i.hasAttribute("subtype") && (n += " " + i.getAttribute("subtype")), n += "\r\n"
            }), n
        }, a.prototype.fromJingle = function(e) {
            const t = Date.now();
            this.raw = `v=0\r\no=- ${t} 2 IN IP4 0.0.0.0\r\ns=-\r\nt=0 0\r\n`;
            const n = $(e).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]');
            n.length && n.each((e, t) => {
                const n = $(t).find(">content").map((e, t) => t.getAttribute("name")).get();
                n.length > 0 && (this.raw += `a=group:${t.getAttribute("semantics")||t.getAttribute("type")} ${n.join(" ")}\r\n`)
            }), this.session = this.raw, e.find(">content").each((e, t) => {
                const n = this.jingle2media($(t));
                this.media.push(n)
            }), this.raw = this.session + this.media.join("")
        }, a.prototype.jingle2media = function(e) {
            const t = e.find(">description"),
                n = e.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]');
            let i = "";
            const r = n.find('>sctpmap[xmlns="urn:xmpp:jingle:transports:dtls-sctp:1"]'),
                a = {
                    media: t.attr("media"),
                    port: "1"
                };
            if ("rejected" === e.attr("senders") && (a.port = "0"), n.find('>fingerprint[xmlns="urn:xmpp:jingle:apps:dtls:0"]').length ? a.proto = r.length ? "DTLS/SCTP" : "RTP/SAVPF" : a.proto = "RTP/AVPF", r.length) {
                i += `m=application ${a.port} DTLS/SCTP ${r.attr("number")}\r\n`, i += `a=sctpmap:${r.attr("number")} ${r.attr("protocol")}`;
                const e = r.attr("streams");
                i += e ? ` ${e}\r\n` : "\r\n"
            } else a.fmt = t.find(">payload-type").map((e, t) => t.getAttribute("id")).get(), i += o.a.buildMLine(a) + "\r\n";
            switch (i += "c=IN IP4 0.0.0.0\r\n", r.length || (i += "a=rtcp:1 IN IP4 0.0.0.0\r\n"), n.length && (n.attr("ufrag") && (i += o.a.buildICEUfrag(n.attr("ufrag")) + "\r\n"), n.attr("pwd") && (i += o.a.buildICEPwd(n.attr("pwd")) + "\r\n"), n.find('>fingerprint[xmlns="urn:xmpp:jingle:apps:dtls:0"]').each((e, t) => {
                    i += "a=fingerprint:" + t.getAttribute("hash"), i += " " + $(t).text(), i += "\r\n", t.hasAttribute("setup") && (i += `a=setup:${t.getAttribute("setup")}\r\n`)
                })), n.find(">candidate").each((e, t) => {
                    let n = t.getAttribute("protocol");
                    n = "string" == typeof n ? n.toLowerCase() : "", this.removeTcpCandidates && ("tcp" === n || "ssltcp" === n) || this.removeUdpCandidates && "udp" === n || (this.failICE && t.setAttribute("ip", "1.1.1.1"), i += o.a.candidateFromJingle(t))
                }), e.attr("senders")) {
                case "initiator":
                    i += `a=${s.a.SENDONLY}\r\n`;
                    break;
                case "responder":
                    i += `a=${s.a.RECVONLY}\r\n`;
                    break;
                case "none":
                    i += `a=${s.a.INACTIVE}\r\n`;
                    break;
                case "both":
                    i += `a=${s.a.SENDRECV}\r\n`
            }
            return i += `a=mid:${e.attr("name")}\r\n`, t.find(">rtcp-mux").length && (i += "a=rtcp-mux\r\n"), t.find(">payload-type").each((e, t) => {
                i += o.a.buildRTPMap(t) + "\r\n", $(t).find(">parameter").length && (i += `a=fmtp:${t.getAttribute("id")} `, i += $(t).find(">parameter").map((e, t) => {
                    const n = t.getAttribute("name");
                    return (n ? n + "=" : "") + t.getAttribute("value")
                }).get().join("; "), i += "\r\n"), i += this.rtcpFbFromJingle($(t), t.getAttribute("id"))
            }), i += this.rtcpFbFromJingle(t, "*"), t.find('>rtp-hdrext[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]').each((e, t) => {
                i += `a=extmap:${t.getAttribute("id")} ${t.getAttribute("uri")}\r\n`
            }), t.find('>ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((e, t) => {
                const n = t.getAttribute("semantics"),
                    s = $(t).find(">source").map((e, t) => t.getAttribute("ssrc")).get();
                s.length && (i += `a=ssrc-group:${n} ${s.join(" ")}\r\n`)
            }), t.find('>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((e, t) => {
                const n = t.getAttribute("ssrc");
                $(t).find(">parameter").each((e, t) => {
                    const s = t.getAttribute("name");
                    let r = t.getAttribute("value");
                    r = o.a.filterSpecialChars(r), i += `a=ssrc:${n} ${s}`, r && r.length && (i += ":" + r), i += "\r\n"
                })
            }), i
        }
    }, function(e, t, n) {
        "use strict";
        var i, s = "object" == typeof Reflect ? Reflect : null,
            r = s && "function" == typeof s.apply ? s.apply : function(e, t, n) {
                return Function.prototype.apply.call(e, t, n)
            };
        i = s && "function" == typeof s.ownKeys ? s.ownKeys : Object.getOwnPropertySymbols ? function(e) {
            return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
        } : function(e) {
            return Object.getOwnPropertyNames(e)
        };
        var o = Number.isNaN || function(e) {
            return e != e
        };

        function a() {
            a.init.call(this)
        }
        e.exports = a, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0;
        var c = 10;

        function d(e) {
            if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
        }

        function u(e) {
            return void 0 === e._maxListeners ? a.defaultMaxListeners : e._maxListeners
        }

        function l(e, t, n, i) {
            var s, r, o, a;
            if (d(n), void 0 === (r = e._events) ? (r = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== r.newListener && (e.emit("newListener", t, n.listener ? n.listener : n), r = e._events), o = r[t]), void 0 === o) o = r[t] = n, ++e._eventsCount;
            else if ("function" == typeof o ? o = r[t] = i ? [n, o] : [o, n] : i ? o.unshift(n) : o.push(n), (s = u(e)) > 0 && o.length > s && !o.warned) {
                o.warned = !0;
                var c = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                c.name = "MaxListenersExceededWarning", c.emitter = e, c.type = t, c.count = o.length, a = c, console && console.warn && console.warn(a)
            }
            return e
        }

        function h() {
            if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
        }

        function p(e, t, n) {
            var i = {
                    fired: !1,
                    wrapFn: void 0,
                    target: e,
                    type: t,
                    listener: n
                },
                s = h.bind(i);
            return s.listener = n, i.wrapFn = s, s
        }

        function m(e, t, n) {
            var i = e._events;
            if (void 0 === i) return [];
            var s = i[t];
            return void 0 === s ? [] : "function" == typeof s ? n ? [s.listener || s] : [s] : n ? function(e) {
                for (var t = new Array(e.length), n = 0; n < t.length; ++n) t[n] = e[n].listener || e[n];
                return t
            }(s) : g(s, s.length)
        }

        function f(e) {
            var t = this._events;
            if (void 0 !== t) {
                var n = t[e];
                if ("function" == typeof n) return 1;
                if (void 0 !== n) return n.length
            }
            return 0
        }

        function g(e, t) {
            for (var n = new Array(t), i = 0; i < t; ++i) n[i] = e[i];
            return n
        }
        Object.defineProperty(a, "defaultMaxListeners", {
            enumerable: !0,
            get: function() {
                return c
            },
            set: function(e) {
                if ("number" != typeof e || e < 0 || o(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
                c = e
            }
        }), a.init = function() {
            void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
        }, a.prototype.setMaxListeners = function(e) {
            if ("number" != typeof e || e < 0 || o(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
            return this._maxListeners = e, this
        }, a.prototype.getMaxListeners = function() {
            return u(this)
        }, a.prototype.emit = function(e) {
            for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
            var i = "error" === e,
                s = this._events;
            if (void 0 !== s) i = i && void 0 === s.error;
            else if (!i) return !1;
            if (i) {
                var o;
                if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
                var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
                throw a.context = o, a
            }
            var c = s[e];
            if (void 0 === c) return !1;
            if ("function" == typeof c) r(c, this, t);
            else {
                var d = c.length,
                    u = g(c, d);
                for (n = 0; n < d; ++n) r(u[n], this, t)
            }
            return !0
        }, a.prototype.addListener = function(e, t) {
            return l(this, e, t, !1)
        }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function(e, t) {
            return l(this, e, t, !0)
        }, a.prototype.once = function(e, t) {
            return d(t), this.on(e, p(this, e, t)), this
        }, a.prototype.prependOnceListener = function(e, t) {
            return d(t), this.prependListener(e, p(this, e, t)), this
        }, a.prototype.removeListener = function(e, t) {
            var n, i, s, r, o;
            if (d(t), void 0 === (i = this._events)) return this;
            if (void 0 === (n = i[e])) return this;
            if (n === t || n.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || t));
            else if ("function" != typeof n) {
                for (s = -1, r = n.length - 1; r >= 0; r--)
                    if (n[r] === t || n[r].listener === t) {
                        o = n[r].listener, s = r;
                        break
                    } if (s < 0) return this;
                0 === s ? n.shift() : function(e, t) {
                    for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                    e.pop()
                }(n, s), 1 === n.length && (i[e] = n[0]), void 0 !== i.removeListener && this.emit("removeListener", e, o || t)
            }
            return this
        }, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function(e) {
            var t, n, i;
            if (void 0 === (n = this._events)) return this;
            if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[e]), this;
            if (0 === arguments.length) {
                var s, r = Object.keys(n);
                for (i = 0; i < r.length; ++i) "removeListener" !== (s = r[i]) && this.removeAllListeners(s);
                return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
            }
            if ("function" == typeof(t = n[e])) this.removeListener(e, t);
            else if (void 0 !== t)
                for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
            return this
        }, a.prototype.listeners = function(e) {
            return m(this, e, !0)
        }, a.prototype.rawListeners = function(e) {
            return m(this, e, !1)
        }, a.listenerCount = function(e, t) {
            return "function" == typeof e.listenerCount ? e.listenerCount(t) : f.call(e, t)
        }, a.prototype.listenerCount = f, a.prototype.eventNames = function() {
            return this._eventsCount > 0 ? i(this._events) : []
        }
    }, function(e, t) {
        e.exports = {
            H264: "h264",
            OPUS: "opus",
            VP8: "vp8",
            VP9: "vp9"
        }
    }, function(e, t, n) {
        "use strict";
        var i = n(15);
        const s = {};

        function r(e, t, n) {
            if ("object" == typeof e && void 0 !== e.name) switch (this.gum = {
                    error: e,
                    constraints: t,
                    devices: n && Array.isArray(n) ? n.slice(0) : void 0
                }, e.name) {
                case "NotAllowedError":
                case "PermissionDeniedError":
                case "SecurityError":
                    this.name = i.PERMISSION_DENIED, this.message = s[this.name] + (this.gum.devices || []).join(", ");
                    break;
                case "DevicesNotFoundError":
                case "NotFoundError":
                    this.name = i.NOT_FOUND, this.message = s[this.name] + (this.gum.devices || []).join(", ");
                    break;
                case "ConstraintNotSatisfiedError":
                case "OverconstrainedError": {
                    const r = e.constraintName || e.constraint;
                    t && t.video && (!n || n.indexOf("video") > -1) && ("minWidth" === r || "maxWidth" === r || "minHeight" === r || "maxHeight" === r || "width" === r || "height" === r || "deviceId" === r) ? (this.name = i.UNSUPPORTED_RESOLUTION, this.message = s[this.name] + function(e, t) {
                        if (t && t.video && t.video.mandatory) switch (e) {
                            case "width":
                                return t.video.mandatory.minWidth;
                            case "height":
                                return t.video.mandatory.minHeight;
                            default:
                                return t.video.mandatory[e] || ""
                        }
                        return ""
                    }(r, t)) : (this.name = i.CONSTRAINT_FAILED, this.message = s[this.name] + e.constraintName);
                    break
                }
                default:
                    this.name = i.GENERAL, this.message = e.message || s[this.name]
            } else {
                if ("string" != typeof e) throw new Error("Invalid arguments");
                s[e] ? (this.name = e, this.message = t || s[e]) : this.message = e
            }
            this.stack = e.stack || (new Error).stack
        }
        s[i.UNSUPPORTED_RESOLUTION] = "Video resolution is not supported: ", s[i.SCREENSHARING_USER_CANCELED] = "User canceled screen sharing prompt", s[i.SCREENSHARING_GENERIC_ERROR] = "Unknown error from screensharing", s[i.ELECTRON_DESKTOP_PICKER_ERROR] = "Unkown error from desktop picker", s[i.ELECTRON_DESKTOP_PICKER_NOT_FOUND] = "Failed to detect desktop picker", s[i.GENERAL] = "Generic getUserMedia error", s[i.PERMISSION_DENIED] = "User denied permission to use device(s): ", s[i.NOT_FOUND] = "Requested device(s) was/were not found: ", s[i.CONSTRAINT_FAILED] = "Constraint could not be satisfied: ", s[i.TIMEOUT] = "Could not start media source. Timeout occured!", s[i.TRACK_IS_DISPOSED] = "Track has been already disposed", s[i.TRACK_NO_STREAM_FOUND] = "Track does not have an associated Media Stream", r.prototype = Object.create(Error.prototype), r.prototype.constructor = r, t.a = r
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return r
        }));
        var i = n(19),
            s = n.n(i);
        class r {
            constructor(e = new s.a) {
                this.eventEmitter = e, this.addEventListener = this.on = this.addListener, this.removeEventListener = this.off = this.removeListener
            }
            addListener(e, t) {
                return this.eventEmitter.addListener(e, t), () => this.removeEventListener(e, t)
            }
            removeListener(e, t) {
                this.eventEmitter.removeListener(e, t)
            }
        }
    }, function(e, t, n) {
        var i = n(160),
            s = n(161);
        t.write = s, t.parse = i.parse, t.parseFmtpConfig = i.parseFmtpConfig, t.parseParams = i.parseParams, t.parsePayloads = i.parsePayloads, t.parseRemoteCandidates = i.parseRemoteCandidates, t.parseImageAttributes = i.parseImageAttributes, t.parseSimulcastStreamList = i.parseSimulcastStreamList
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "DETECTOR_STATE_CHANGE", (function() {
            return i
        })), n.d(t, "AUDIO_INPUT_STATE_CHANGE", (function() {
            return s
        })), n.d(t, "NO_AUDIO_INPUT", (function() {
            return r
        })), n.d(t, "VAD_NOISY_DEVICE", (function() {
            return o
        })), n.d(t, "VAD_REPORT_PUBLISHED", (function() {
            return a
        })), n.d(t, "VAD_SCORE_PUBLISHED", (function() {
            return c
        })), n.d(t, "VAD_TALK_WHILE_MUTED", (function() {
            return d
        }));
        const i = "detector_state_change",
            s = "audio_input_state_changed",
            r = "no_audio_input_detected",
            o = "detection.vad_noise_device",
            a = "vad-report-published",
            c = "detection.vad_score_published",
            d = "detection.vad_talk_while_muted"
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return R
            })), n.d(t, "d", (function() {
                return A
            })), n.d(t, "c", (function() {
                return I
            })), n.d(t, "b", (function() {
                return w
            })), n.d(t, "e", (function() {
                return D
            }));
            var i = n(5),
                s = n(2),
                r = (n(156), n(40)),
                o = n(27),
                a = n(0),
                c = n.n(a),
                d = n(3),
                u = n(55),
                l = n(12),
                h = n.n(l),
                p = n(22),
                m = n(37),
                f = n.n(m),
                g = n(76),
                _ = n(41),
                v = n(100),
                S = n(106),
                y = n(113),
                E = n(114),
                b = n(115);
            const C = Object(i.getLogger)(e),
                T = /<failure.*><not-allowed\/><text>(.*)<\/text><\/failure>/gi;
            const R = [{
                    urls: "stun:meet-jit-si-turnrelay.jitsi.net:443"
                }],
                A = "type",
                I = "http://jitsi.org/protocol/jigasi",
                w = "https://jitsi.org/meet/e2ee";
            class D extends p.a {
                constructor(e, t) {
                    var n;
                    super(), this.connection = null, this.disconnectInProgress = !1, this.connectionTimes = {}, this.options = e, this.token = t, this.authenticatedUser = !1, Object(b.a)(), Object(y.a)();
                    const i = e.xmppPing || {};
                    i.domain = e.hosts.domain, this.connection = function({
                        enableWebsocketResume: e,
                        serviceUrl: t = "/http-bind",
                        shard: n,
                        token: i,
                        websocketKeepAlive: s,
                        websocketKeepAliveUrl: r,
                        xmppPing: o
                    }) {
                        return i && (t += `${-1===t.indexOf("?")?"?":"&"}token=${i}`), new _.a({
                            enableWebsocketResume: e,
                            serviceUrl: t,
                            websocketKeepAlive: s,
                            websocketKeepAliveUrl: r,
                            xmppPing: o,
                            shard: n
                        })
                    }({
                        enableWebsocketResume: e.enableWebsocketResume,
                        serviceUrl: e.serviceUrl || e.bosh,
                        token: t,
                        websocketKeepAlive: e.websocketKeepAlive,
                        websocketKeepAliveUrl: e.websocketKeepAliveUrl,
                        xmppPing: i,
                        shard: null === (n = e.deploymentInfo) || void 0 === n ? void 0 : n.shard
                    }), this.connection.on(_.a.Events.CONN_SHARD_CHANGED, () => {
                        const e = {
                            shard_changed: !0,
                            suspend_time: this.connection.ping.getPingSuspendTime(),
                            time_since_last_success: this.connection.getTimeSinceLastSuccess()
                        };
                        this.eventEmitter.emit(o.CONNECTION_FAILED, r.OTHER_ERROR, void 0, void 0, e)
                    }), this._initStrophePlugins(), this.caps = new g.a(this.connection, this.options.clientNode), this.initFeaturesList(), $(window).on("beforeunload unload", e => {
                        this.disconnect(e).catch(() => {})
                    })
                }
                initFeaturesList() {
                    this.caps.addFeature("urn:xmpp:jingle:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:1"), this.caps.addFeature("urn:xmpp:jingle:transports:ice-udp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:dtls:0"), this.caps.addFeature("urn:xmpp:jingle:transports:dtls-sctp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:audio"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:video"), this.options.disableRtx || d.a.isFirefox() && d.a.isVersionLessThan(84) || this.caps.addFeature("urn:ietf:rfc:4588"), !0 === this.options.enableOpusRed && d.a.supportsAudioRed() && this.caps.addFeature("http://jitsi.org/opus-red"), (void 0 === this.options.enableRemb || this.options.enableRemb) && this.caps.addFeature("http://jitsi.org/remb"), d.a.isFirefox() || void 0 !== this.options.enableTcc && !this.options.enableTcc || this.caps.addFeature("http://jitsi.org/tcc"), this.caps.addFeature("urn:ietf:rfc:5761"), this.caps.addFeature("urn:ietf:rfc:5888"), d.a.isChromiumBased() && !0 === this.options.enableLipSync && (C.info("Lip-sync enabled !"), this.caps.addFeature("http://jitsi.org/meet/lipsync")), this.connection.rayo && this.caps.addFeature("urn:xmpp:rayo:client:1"), u.a.isSupported(this.options) && this.caps.addFeature(w, !1, !0)
                }
                getConnection() {
                    return this.connection
                }
                connectionHandler(e = {}, t, n) {
                    const i = window.performance.now(),
                        a = s.Strophe.getStatusString(t).toLowerCase();
                    if (this.connectionTimes[a] = i, C.log(`(TIME) Strophe ${a}${n?`[${n}]`:""}:\t`, i), this.eventEmitter.emit(c.a.CONNECTION_STATUS_CHANGED, e, t, n), t === s.Strophe.Status.CONNECTED || t === s.Strophe.Status.ATTACHED) this._sysMessageHandler && (this.connection._stropheConn.deleteHandler(this._sysMessageHandler), this._sysMessageHandler = null), this.sendDiscoInfo && this.connection.jingle.getStunAndTurnCredentials(), C.info("My Jabber ID: " + this.connection.jid), this._resetState(), this.sendDiscoInfo && this.caps.getFeaturesAndIdentities(this.options.hosts.domain).then(({
                        features: e,
                        identities: t
                    }) => {
                        e.has(s.Strophe.NS.PING) || C.error(`Ping NOT supported by ${this.options.hosts.domain} - please enable ping in your XMPP server config`), this._processDiscoInfoIdentities(t, void 0)
                    }).catch(e => {
                        const t = "Feature discovery error";
                        h.a.callErrorHandler(new Error(`${t}: ${e}`)), C.error(t, e)
                    }), this.sendDiscoInfo = !1, e.password && (this.authenticatedUser = !0), this.connection && this.connection.connected && s.Strophe.getResourceFromJid(this.connection.jid) && this.eventEmitter.emit(o.CONNECTION_ESTABLISHED, s.Strophe.getResourceFromJid(this.connection.jid));
                    else if (t === s.Strophe.Status.CONNFAIL) "x-strophe-bad-non-anon-jid" === n ? this.anonymousConnectionFailed = !0 : this.connectionFailed = !0, this.lastErrorMsg = n, "giving-up" === n && this.eventEmitter.emit(o.CONNECTION_FAILED, r.OTHER_ERROR, n);
                    else if (t === s.Strophe.Status.ERROR) this.lastErrorMsg = n;
                    else if (t === s.Strophe.Status.DISCONNECTED) {
                        this.connection.ping.stopInterval();
                        const e = Boolean(this.disconnectInProgress),
                            t = n || this.lastErrorMsg;
                        if (this.anonymousConnectionFailed) this.eventEmitter.emit(o.CONNECTION_FAILED, r.PASSWORD_REQUIRED);
                        else if (this.connectionFailed) this.eventEmitter.emit(o.CONNECTION_FAILED, r.OTHER_ERROR, t, void 0, this._getConnectionFailedReasonDetails());
                        else if (e) this.eventEmitter.emit(o.CONNECTION_DISCONNECTED, t);
                        else {
                            C.error("XMPP connection dropped!");
                            const e = s.Strophe.getLastErrorStatus();
                            e >= 500 && e < 600 ? this.eventEmitter.emit(o.CONNECTION_FAILED, r.SERVER_ERROR, t || "server-error", void 0, this._getConnectionFailedReasonDetails()) : this.eventEmitter.emit(o.CONNECTION_FAILED, r.CONNECTION_DROPPED_ERROR, t || "connection-dropped-error", void 0, this._getConnectionFailedReasonDetails())
                        }
                    } else if (t === s.Strophe.Status.AUTHFAIL) {
                        const t = this.getConnection().getLastFailedMessage();
                        this.eventEmitter.emit(o.CONNECTION_FAILED, r.PASSWORD_REQUIRED, n || this._parseConnectionFailedMessage(t), e)
                    }
                }
                _processDiscoInfoIdentities(e, t) {
                    e.forEach(e => {
                        if ("av_moderation" === e.type && (this.avModerationComponentAddress = e.name), "speakerstats" === e.type && (this.speakerStatsComponentAddress = e.name), "conference_duration" === e.type && (this.conferenceDurationComponentAddress = e.name), "lobbyrooms" === e.type) {
                            this.lobbySupported = !0;
                            const n = e => {
                                e.forEach(e => {
                                    e.endsWith("#displayname_required") && this.eventEmitter.emit(o.DISPLAY_NAME_REQUIRED)
                                })
                            };
                            t ? n(t) : e.name && this.caps.getFeaturesAndIdentities(e.name, e.type).then(({
                                features: e
                            }) => n(e)).catch(e => C.warn("Error getting features from lobby.", e && e.message))
                        }
                    }), (this.avModerationComponentAddress || this.speakerStatsComponentAddress || this.conferenceDurationComponentAddress) && this.connection.addHandler(this._onPrivateMessage.bind(this), null, "message", null, null)
                }
                _parseConnectionFailedMessage(e) {
                    if (!e) return null;
                    const t = T.exec(e);
                    return t ? t[1] : null
                }
                _connect(e, t) {
                    this._resetState(), this.sendDiscoInfo = !0, this.connection._stropheConn && this.connection._stropheConn._addSysHandler ? this._sysMessageHandler = this.connection._stropheConn._addSysHandler(this._onSystemMessage.bind(this), null, "message") : C.warn("Cannot attach strophe system handler, jiconop cannot operate"), this.connection.connect(e, t, this.connectionHandler.bind(this, {
                        jid: e,
                        password: t
                    }))
                }
                _onSystemMessage(e) {
                    if (0 === $(e).find(">services").length && 0 === $(e).find(">query").length) return;
                    this.sendDiscoInfo = !1;
                    const t = this.connection.jingle.onReceiveStunAndTurnCredentials(e),
                        {
                            features: n,
                            identities: i
                        } = Object(g.b)(e);
                    this._processDiscoInfoIdentities(i, n), i.forEach(e => {
                        "shard" === e.type && (this.options.deploymentInfo.shard = e.name)
                    }), (t || i.size > 0 || n.size > 0) && (this.connection._stropheConn.deleteHandler(this._sysMessageHandler), this._sysMessageHandler = null)
                }
                attach(e) {
                    this._resetState(), this.sendDiscoInfo = !0;
                    const t = this.connectionTimes.attaching = window.performance.now();
                    C.log("(TIME) Strophe Attaching:\t", t), this.connection.attach(e.jid, e.sid, parseInt(e.rid, 10) + 1, this.connectionHandler.bind(this, {
                        jid: e.jid,
                        password: e.password
                    }))
                }
                _resetState() {
                    this.anonymousConnectionFailed = !1, this.connectionFailed = !1, this.lastErrorMsg = void 0, this.disconnectInProgress = void 0
                }
                connect(e, t) {
                    if (!e) {
                        const {
                            anonymousdomain: t,
                            domain: n
                        } = this.options.hosts;
                        let i = t || n;
                        const {
                            location: s
                        } = window;
                        if (t) {
                            const e = s && s.search;
                            (e && -1 !== e.indexOf("login=true") || this.token) && (i = n)
                        }
                        e = i || s && s.hostname
                    }
                    return this._connect(e, t)
                }
                createRoom(e, t, n) {
                    let i = `${e}@${t.customDomain?t.customDomain:this.options.hosts.muc.toLowerCase()}/`;
                    const s = n ? n(this.connection.jid, this.authenticatedUser) : f.a.randomHexString(8).toLowerCase();
                    return C.info(`JID ${this.connection.jid} using MUC nickname ${s}`), i += s, this.connection.emuc.createRoom(i, null, t)
                }
                getJid() {
                    return this.connection.jid
                }
                getJingleLog() {
                    const e = this.connection.jingle;
                    return e ? e.getLog() : {}
                }
                getXmppLog() {
                    return (this.connection.logger || {}).log || null
                }
                dial(...e) {
                    this.connection.rayo.dial(...e)
                }
                ping(e) {
                    return new Promise((t, n) => {
                        this.connection.ping.ping(this.connection.pingDomain, t, n, e)
                    })
                }
                getSessions() {
                    return this.connection.jingle.sessions
                }
                disconnect(e) {
                    return this.disconnectInProgress ? this.disconnectInProgress : this.connection ? (this.disconnectInProgress = new Promise(e => {
                        const t = (n, i) => {
                            i === s.Strophe.Status.DISCONNECTED && (e(), this.eventEmitter.removeListener(c.a.CONNECTION_STATUS_CHANGED, t))
                        };
                        this.eventEmitter.on(c.a.CONNECTION_STATUS_CHANGED, t)
                    }), this._cleanupXmppConnection(e), this.disconnectInProgress) : Promise.resolve()
                }
                _cleanupXmppConnection(e) {
                    if (!this.connection.isUsingWebSocket && this.connection.flush(), !this.connection.isUsingWebSocket && null != e) {
                        const t = e.type;
                        if (("beforeunload" === t || "unload" === t) && (this.connection.options.sync = !0, this.connection.sendUnavailableBeacon())) return
                    }
                    this.connection.disconnect(), !0 !== this.connection.options.sync && this.connection.flush()
                }
                _initStrophePlugins() {
                    const e = {
                            jvb: {
                                iceServers: []
                            },
                            p2p: {
                                iceServers: []
                            }
                        },
                        t = this.options.p2p && this.options.p2p.stunServers || R;
                    Array.isArray(t) && (C.info("P2P STUN servers: ", t), e.p2p.iceServers = t), this.options.p2p && this.options.p2p.iceTransportPolicy && (C.info("P2P ICE transport policy: ", this.options.p2p.iceTransportPolicy), e.p2p.iceTransportPolicy = this.options.p2p.iceTransportPolicy), this.connection.addConnectionPlugin("emuc", new v.a(this)), this.connection.addConnectionPlugin("jingle", new S.a(this, this.eventEmitter, e)), this.connection.addConnectionPlugin("rayo", new E.a)
                }
                _getConnectionFailedReasonDetails() {
                    const e = {};
                    if (this.options.deploymentInfo && this.options.deploymentInfo.shard && this.connection.lastResponseHeaders) {
                        const t = this.connection.lastResponseHeaders.trim().split(/[\r\n]+/),
                            n = {};
                        t.forEach(e => {
                            const t = e.split(": "),
                                i = t.shift(),
                                s = t.join(": ");
                            n[i] = s
                        }), e.shard_changed = this.options.deploymentInfo.shard !== n["x-jitsi-shard"]
                    }
                    return e.suspend_time = this.connection.ping.getPingSuspendTime(), e.time_since_last_success = this.connection.getTimeSinceLastSuccess(), e
                }
                sendDominantSpeakerEvent(e) {
                    if (!this.speakerStatsComponentAddress || !e) return;
                    const t = Object(s.$msg)({
                        to: this.speakerStatsComponentAddress
                    });
                    t.c("speakerstats", {
                        xmlns: "http://jitsi.org/jitmeet",
                        room: e
                    }).up(), this.connection.send(t)
                }
                tryParseJSONAndVerify(e) {
                    if (!e) return !1;
                    try {
                        const t = JSON.parse(e);
                        if (t && "object" == typeof t) {
                            const e = t[A];
                            if (void 0 !== e) return t;
                            C.debug("parsing valid json but does not have correct structure", "topic: ", e)
                        }
                    } catch (t) {
                        return C.error("Error parsing json " + e, t), !1
                    }
                    return !1
                }
                _onPrivateMessage(e) {
                    const t = e.getAttribute("from");
                    if (t !== this.speakerStatsComponentAddress && t !== this.conferenceDurationComponentAddress && t !== this.avModerationComponentAddress) return !0;
                    const n = $(e).find(">json-message").text(),
                        i = this.tryParseJSONAndVerify(n);
                    return !i || ("speakerstats" === i[A] && i.users ? this.eventEmitter.emit(c.a.SPEAKER_STATS_RECEIVED, i.users) : "conference_duration" === i[A] && i.created_timestamp ? this.eventEmitter.emit(c.a.CONFERENCE_TIMESTAMP_RECEIVED, i.created_timestamp) : "av_moderation" === i[A] && this.eventEmitter.emit(c.a.AV_MODERATION_RECEIVED, i), !0)
                }
            }
        }).call(this, "modules/xmpp/xmpp.js")
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "STATUS_AVAILABLE", (function() {
            return i
        })), n.d(t, "STATUS_UNDEFINED", (function() {
            return s
        })), n.d(t, "STATUS_BUSY", (function() {
            return r
        })), n.d(t, "STATE_ON", (function() {
            return o
        })), n.d(t, "STATE_OFF", (function() {
            return a
        })), n.d(t, "STATE_PENDING", (function() {
            return c
        })), n.d(t, "STATE_RETRYING", (function() {
            return d
        })), n.d(t, "STATE_FAILED", (function() {
            return u
        })), n.d(t, "ERROR_NO_CONNECTION", (function() {
            return l
        })), n.d(t, "ERROR_SESSION_EXISTS", (function() {
            return h
        }));
        const i = "available",
            s = "undefined",
            r = "busy",
            o = "on",
            a = "off",
            c = "pending",
            d = "retrying",
            u = "failed",
            l = "error_no_connection",
            h = "error_session_already_exists"
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "CONNECTION_DISCONNECTED", (function() {
            return i
        })), n.d(t, "CONNECTION_ESTABLISHED", (function() {
            return s
        })), n.d(t, "CONNECTION_FAILED", (function() {
            return r
        })), n.d(t, "WRONG_STATE", (function() {
            return o
        })), n.d(t, "DISPLAY_NAME_REQUIRED", (function() {
            return a
        }));
        const i = "connection.connectionDisconnected",
            s = "connection.connectionEstablished",
            r = "connection.connectionFailed",
            o = "connection.wrongState",
            a = "connection.display_name_required"
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        })), n.d(t, "b", (function() {
            return s
        })), n.d(t, "c", (function() {
            return r
        })), n.d(t, "d", (function() {
            return o
        })), n.d(t, "e", (function() {
            return a
        }));
        const i = "statistics.audioLevel",
            s = "statistics.before_disposed",
            r = "statistics.byte_sent_stats",
            o = "statistics.connectionstats",
            a = "statistics.long_tasks_stats"
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(57),
                s = n(5),
                r = n(105),
                o = n.n(r);
            const a = Object(s.getLogger)(e);
            let c, d;

            function u() {
                return (Math.random().toString(16) + "000000000").substr(2, 8)
            }
            t.a = {
                _storage: i.b,
                init(e) {
                    this._storage = e || i.b
                },
                get callStatsUserName() {
                    return c || (c = this._storage.getItem("callStatsUserName"), c || (c = function() {
                        const e = o.a.generateUsername();
                        return a.log("generated callstats uid", e), e
                    }(), this._storage.setItem("callStatsUserName", c))), c
                },
                get machineId() {
                    if (!d) {
                        const e = this._storage.getItem("billingId");
                        d = e || this._storage.getItem("jitsiMeetId"), e ? this._storage.setItem("jitsiMeetId", e) : d || (d = function() {
                            const e = u() + u() + u() + u();
                            return a.log("generated id", e), e
                        }(), this._storage.setItem("jitsiMeetId", d))
                    }
                    return d
                },
                get sessionId() {
                    return this._storage.getItem("sessionId")
                },
                set sessionId(e) {
                    e ? this._storage.setItem("sessionId", e) : this._storage.removeItem("sessionId")
                }
            }
        }).call(this, "modules/settings/Settings.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "b", (function() {
            return s
        })), n.d(t, "c", (function() {
            return r
        })), n.d(t, "a", (function() {
            return c
        }));
        var i = n(23);

        function s(e) {
            return parseInt(e.ssrcs.split(" ")[0], 10)
        }

        function r(e) {
            return parseInt(e.ssrcs.split(" ")[1], 10)
        }

        function o(e) {
            return e.ssrcs ? e.ssrcs.map(e => e.id).filter((e, t, n) => n.indexOf(e) === t).length : 0
        }
        class a {
            constructor(e) {
                if (!e) throw new Error("mLine is undefined");
                this.mLine = e
            }
            get ssrcs() {
                return this.mLine.ssrcs || (this.mLine.ssrcs = []), this.mLine.ssrcs
            }
            set ssrcs(e) {
                this.mLine.ssrcs = e
            }
            get direction() {
                return this.mLine.direction
            }
            set direction(e) {
                this.mLine.direction = e
            }
            get ssrcGroups() {
                return this.mLine.ssrcGroups || (this.mLine.ssrcGroups = []), this.mLine.ssrcGroups
            }
            set ssrcGroups(e) {
                this.mLine.ssrcGroups = e
            }
            getSSRCAttrValue(e, t) {
                const n = this.ssrcs.find(n => n.id === e && n.attribute === t);
                return n && n.value
            }
            removeSSRC(e) {
                this.mLine.ssrcs && this.mLine.ssrcs.length && (this.mLine.ssrcs = this.mLine.ssrcs.filter(t => t.id !== e))
            }
            addSSRCAttribute(e) {
                this.ssrcs.push(e)
            }
            findGroup(e, t) {
                return this.ssrcGroups.find(n => n.semantics === e && (!t || t === n.ssrcs))
            }
            findGroups(e) {
                return this.ssrcGroups.filter(t => t.semantics === e)
            }
            findGroupByPrimarySSRC(e, t) {
                return this.ssrcGroups.find(n => n.semantics === e && s(n) === t)
            }
            findSSRCByMSID(e) {
                return this.ssrcs.find(t => "msid" === t.attribute && (null === e || t.value === e))
            }
            getSSRCCount() {
                return o(this.mLine)
            }
            containsAnySSRCGroups() {
                return void 0 !== this.mLine.ssrcGroups
            }
            getPrimaryVideoSsrc() {
                const e = this.mLine.type;
                if ("video" !== e) throw new Error(`getPrimarySsrc doesn't work with '${e}'`);
                if (1 === o(this.mLine)) return this.mLine.ssrcs[0].id;
                if (this.mLine.ssrcGroups) {
                    const e = this.findGroup("SIM");
                    if (e) return s(e);
                    const t = this.findGroup("FID");
                    if (t) return s(t);
                    const n = this.findGroup("FEC-FR");
                    if (n) return s(n)
                }
            }
            getRtxSSRC(e) {
                const t = this.findGroupByPrimarySSRC("FID", e);
                return t && r(t)
            }
            getSSRCs() {
                return this.ssrcs.map(e => e.id).filter((e, t, n) => n.indexOf(e) === t)
            }
            getPrimaryVideoSSRCs() {
                const e = this.mLine.type;
                if ("video" !== e) throw new Error("getPrimaryVideoSSRCs doesn't work with " + e);
                const t = this.getSSRCs();
                for (const e of this.ssrcGroups)
                    if ("FID" === e.semantics || "FEC-FR" === e.semantics) {
                        const n = r(e);
                        t.splice(t.indexOf(n), 1)
                    } return t
            }
            dumpSSRCGroups() {
                return JSON.stringify(this.mLine.ssrcGroups)
            }
            removeGroupsWithSSRC(e) {
                this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter(t => -1 === t.ssrcs.indexOf("" + e)))
            }
            removeGroupsBySemantics(e) {
                this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter(t => t.semantics !== e))
            }
            replaceSSRC(e, t) {
                this.mLine.ssrcs && this.mLine.ssrcs.forEach(n => {
                    n.id === e && (n.id = t)
                })
            }
            addSSRCGroup(e) {
                this.ssrcGroups.push(e)
            }
        }
        class c {
            constructor(e) {
                this.parsedSDP = i.parse(e)
            }
            selectMedia(e) {
                const t = this.parsedSDP.media.find(t => t.type === e);
                return t ? new a(t) : null
            }
            toRawSDP() {
                return i.write(this.parsedSDP)
            }
        }
    }, function(e, t, n) {
        "use strict";

        function i(e) {
            let t = e;
            return e >= Number.MAX_SAFE_INTEGER && (t = 0), t + 1
        }

        function s(e) {
            return e.length > 0 ? e.reduce((e, t) => e + t) / e.length : 0
        }

        function r(e) {
            return e.filter(e => e >= 0)
        }
        n.d(t, "d", (function() {
            return i
        })), n.d(t, "b", (function() {
            return s
        })), n.d(t, "c", (function() {
            return r
        })), n.d(t, "a", (function() {
            return o
        }));
        class o {
            constructor() {
                this.average = 0, this.n = 0
            }
            addNext(e) {
                "number" == typeof e && (this.n += 1, this.average = this.average + (e - this.average) / this.n)
            }
            getAverage() {
                return this.average
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "LOCAL_STATS_UPDATED", (function() {
            return i
        })), n.d(t, "REMOTE_STATS_UPDATED", (function() {
            return s
        }));
        const i = "cq.local_stats_updated",
            s = "cq.remote_stats_updated"
    }, function(e, t, n) {
        (function(e, n) {
            var i = "[object Arguments]",
                s = "[object Map]",
                r = "[object Object]",
                o = "[object Set]",
                a = /^\[object .+?Constructor\]$/,
                c = /^(?:0|[1-9]\d*)$/,
                d = {};
            d["[object Float32Array]"] = d["[object Float64Array]"] = d["[object Int8Array]"] = d["[object Int16Array]"] = d["[object Int32Array]"] = d["[object Uint8Array]"] = d["[object Uint8ClampedArray]"] = d["[object Uint16Array]"] = d["[object Uint32Array]"] = !0, d[i] = d["[object Array]"] = d["[object ArrayBuffer]"] = d["[object Boolean]"] = d["[object DataView]"] = d["[object Date]"] = d["[object Error]"] = d["[object Function]"] = d[s] = d["[object Number]"] = d[r] = d["[object RegExp]"] = d[o] = d["[object String]"] = d["[object WeakMap]"] = !1;
            var u = "object" == typeof e && e && e.Object === Object && e,
                l = "object" == typeof self && self && self.Object === Object && self,
                h = u || l || Function("return this")(),
                p = t && !t.nodeType && t,
                m = p && "object" == typeof n && n && !n.nodeType && n,
                f = m && m.exports === p,
                g = f && u.process,
                _ = function() {
                    try {
                        return g && g.binding && g.binding("util")
                    } catch (e) {}
                }(),
                v = _ && _.isTypedArray;

            function S(e, t) {
                for (var n = -1, i = null == e ? 0 : e.length; ++n < i;)
                    if (t(e[n], n, e)) return !0;
                return !1
            }

            function y(e) {
                var t = -1,
                    n = Array(e.size);
                return e.forEach((function(e, i) {
                    n[++t] = [i, e]
                })), n
            }

            function E(e) {
                var t = -1,
                    n = Array(e.size);
                return e.forEach((function(e) {
                    n[++t] = e
                })), n
            }
            var b, C, T, R = Array.prototype,
                A = Function.prototype,
                I = Object.prototype,
                w = h["__core-js_shared__"],
                D = A.toString,
                P = I.hasOwnProperty,
                O = (b = /[^.]+$/.exec(w && w.keys && w.keys.IE_PROTO || "")) ? "Symbol(src)_1." + b : "",
                N = I.toString,
                M = RegExp("^" + D.call(P).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                L = f ? h.Buffer : void 0,
                k = h.Symbol,
                x = h.Uint8Array,
                F = I.propertyIsEnumerable,
                j = R.splice,
                U = k ? k.toStringTag : void 0,
                H = Object.getOwnPropertySymbols,
                V = L ? L.isBuffer : void 0,
                B = (C = Object.keys, T = Object, function(e) {
                    return C(T(e))
                }),
                J = _e(h, "DataView"),
                G = _e(h, "Map"),
                $ = _e(h, "Promise"),
                K = _e(h, "Set"),
                q = _e(h, "WeakMap"),
                W = _e(Object, "create"),
                z = Ee(J),
                Q = Ee(G),
                Y = Ee($),
                X = Ee(K),
                Z = Ee(q),
                ee = k ? k.prototype : void 0,
                te = ee ? ee.valueOf : void 0;

            function ne(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var i = e[t];
                    this.set(i[0], i[1])
                }
            }

            function ie(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var i = e[t];
                    this.set(i[0], i[1])
                }
            }

            function se(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.clear(); ++t < n;) {
                    var i = e[t];
                    this.set(i[0], i[1])
                }
            }

            function re(e) {
                var t = -1,
                    n = null == e ? 0 : e.length;
                for (this.__data__ = new se; ++t < n;) this.add(e[t])
            }

            function oe(e) {
                var t = this.__data__ = new ie(e);
                this.size = t.size
            }

            function ae(e, t) {
                var n = Te(e),
                    i = !n && Ce(e),
                    s = !n && !i && Re(e),
                    r = !n && !i && !s && Pe(e),
                    o = n || i || s || r,
                    a = o ? function(e, t) {
                        for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
                        return i
                    }(e.length, String) : [],
                    c = a.length;
                for (var d in e) !t && !P.call(e, d) || o && ("length" == d || s && ("offset" == d || "parent" == d) || r && ("buffer" == d || "byteLength" == d || "byteOffset" == d) || ye(d, c)) || a.push(d);
                return a
            }

            function ce(e, t) {
                for (var n = e.length; n--;)
                    if (be(e[n][0], t)) return n;
                return -1
            }

            function de(e) {
                return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : U && U in Object(e) ? function(e) {
                    var t = P.call(e, U),
                        n = e[U];
                    try {
                        e[U] = void 0;
                        var i = !0
                    } catch (e) {}
                    var s = N.call(e);
                    i && (t ? e[U] = n : delete e[U]);
                    return s
                }(e) : function(e) {
                    return N.call(e)
                }(e)
            }

            function ue(e) {
                return De(e) && de(e) == i
            }

            function le(e, t, n, a, c) {
                return e === t || (null == e || null == t || !De(e) && !De(t) ? e != e && t != t : function(e, t, n, a, c, d) {
                    var u = Te(e),
                        l = Te(t),
                        h = u ? "[object Array]" : Se(e),
                        p = l ? "[object Array]" : Se(t),
                        m = (h = h == i ? r : h) == r,
                        f = (p = p == i ? r : p) == r,
                        g = h == p;
                    if (g && Re(e)) {
                        if (!Re(t)) return !1;
                        u = !0, m = !1
                    }
                    if (g && !m) return d || (d = new oe), u || Pe(e) ? me(e, t, n, a, c, d) : function(e, t, n, i, r, a, c) {
                        switch (n) {
                            case "[object DataView]":
                                if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
                                e = e.buffer, t = t.buffer;
                            case "[object ArrayBuffer]":
                                return !(e.byteLength != t.byteLength || !a(new x(e), new x(t)));
                            case "[object Boolean]":
                            case "[object Date]":
                            case "[object Number]":
                                return be(+e, +t);
                            case "[object Error]":
                                return e.name == t.name && e.message == t.message;
                            case "[object RegExp]":
                            case "[object String]":
                                return e == t + "";
                            case s:
                                var d = y;
                            case o:
                                var u = 1 & i;
                                if (d || (d = E), e.size != t.size && !u) return !1;
                                var l = c.get(e);
                                if (l) return l == t;
                                i |= 2, c.set(e, t);
                                var h = me(d(e), d(t), i, r, a, c);
                                return c.delete(e), h;
                            case "[object Symbol]":
                                if (te) return te.call(e) == te.call(t)
                        }
                        return !1
                    }(e, t, h, n, a, c, d);
                    if (!(1 & n)) {
                        var _ = m && P.call(e, "__wrapped__"),
                            v = f && P.call(t, "__wrapped__");
                        if (_ || v) {
                            var S = _ ? e.value() : e,
                                b = v ? t.value() : t;
                            return d || (d = new oe), c(S, b, n, a, d)
                        }
                    }
                    if (!g) return !1;
                    return d || (d = new oe),
                        function(e, t, n, i, s, r) {
                            var o = 1 & n,
                                a = fe(e),
                                c = a.length,
                                d = fe(t).length;
                            if (c != d && !o) return !1;
                            var u = c;
                            for (; u--;) {
                                var l = a[u];
                                if (!(o ? l in t : P.call(t, l))) return !1
                            }
                            var h = r.get(e);
                            if (h && r.get(t)) return h == t;
                            var p = !0;
                            r.set(e, t), r.set(t, e);
                            var m = o;
                            for (; ++u < c;) {
                                l = a[u];
                                var f = e[l],
                                    g = t[l];
                                if (i) var _ = o ? i(g, f, l, t, e, r) : i(f, g, l, e, t, r);
                                if (!(void 0 === _ ? f === g || s(f, g, n, i, r) : _)) {
                                    p = !1;
                                    break
                                }
                                m || (m = "constructor" == l)
                            }
                            if (p && !m) {
                                var v = e.constructor,
                                    S = t.constructor;
                                v == S || !("constructor" in e) || !("constructor" in t) || "function" == typeof v && v instanceof v && "function" == typeof S && S instanceof S || (p = !1)
                            }
                            return r.delete(e), r.delete(t), p
                        }(e, t, n, a, c, d)
                }(e, t, n, a, le, c))
            }

            function he(e) {
                return !(!we(e) || function(e) {
                    return !!O && O in e
                }(e)) && (Ae(e) ? M : a).test(Ee(e))
            }

            function pe(e) {
                if (n = (t = e) && t.constructor, i = "function" == typeof n && n.prototype || I, t !== i) return B(e);
                var t, n, i, s = [];
                for (var r in Object(e)) P.call(e, r) && "constructor" != r && s.push(r);
                return s
            }

            function me(e, t, n, i, s, r) {
                var o = 1 & n,
                    a = e.length,
                    c = t.length;
                if (a != c && !(o && c > a)) return !1;
                var d = r.get(e);
                if (d && r.get(t)) return d == t;
                var u = -1,
                    l = !0,
                    h = 2 & n ? new re : void 0;
                for (r.set(e, t), r.set(t, e); ++u < a;) {
                    var p = e[u],
                        m = t[u];
                    if (i) var f = o ? i(m, p, u, t, e, r) : i(p, m, u, e, t, r);
                    if (void 0 !== f) {
                        if (f) continue;
                        l = !1;
                        break
                    }
                    if (h) {
                        if (!S(t, (function(e, t) {
                                if (o = t, !h.has(o) && (p === e || s(p, e, n, i, r))) return h.push(t);
                                var o
                            }))) {
                            l = !1;
                            break
                        }
                    } else if (p !== m && !s(p, m, n, i, r)) {
                        l = !1;
                        break
                    }
                }
                return r.delete(e), r.delete(t), l
            }

            function fe(e) {
                return function(e, t, n) {
                    var i = t(e);
                    return Te(e) ? i : function(e, t) {
                        for (var n = -1, i = t.length, s = e.length; ++n < i;) e[s + n] = t[n];
                        return e
                    }(i, n(e))
                }(e, Oe, ve)
            }

            function ge(e, t) {
                var n, i, s = e.__data__;
                return ("string" == (i = typeof(n = t)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? s["string" == typeof t ? "string" : "hash"] : s.map
            }

            function _e(e, t) {
                var n = function(e, t) {
                    return null == e ? void 0 : e[t]
                }(e, t);
                return he(n) ? n : void 0
            }
            ne.prototype.clear = function() {
                this.__data__ = W ? W(null) : {}, this.size = 0
            }, ne.prototype.delete = function(e) {
                var t = this.has(e) && delete this.__data__[e];
                return this.size -= t ? 1 : 0, t
            }, ne.prototype.get = function(e) {
                var t = this.__data__;
                if (W) {
                    var n = t[e];
                    return "__lodash_hash_undefined__" === n ? void 0 : n
                }
                return P.call(t, e) ? t[e] : void 0
            }, ne.prototype.has = function(e) {
                var t = this.__data__;
                return W ? void 0 !== t[e] : P.call(t, e)
            }, ne.prototype.set = function(e, t) {
                var n = this.__data__;
                return this.size += this.has(e) ? 0 : 1, n[e] = W && void 0 === t ? "__lodash_hash_undefined__" : t, this
            }, ie.prototype.clear = function() {
                this.__data__ = [], this.size = 0
            }, ie.prototype.delete = function(e) {
                var t = this.__data__,
                    n = ce(t, e);
                return !(n < 0) && (n == t.length - 1 ? t.pop() : j.call(t, n, 1), --this.size, !0)
            }, ie.prototype.get = function(e) {
                var t = this.__data__,
                    n = ce(t, e);
                return n < 0 ? void 0 : t[n][1]
            }, ie.prototype.has = function(e) {
                return ce(this.__data__, e) > -1
            }, ie.prototype.set = function(e, t) {
                var n = this.__data__,
                    i = ce(n, e);
                return i < 0 ? (++this.size, n.push([e, t])) : n[i][1] = t, this
            }, se.prototype.clear = function() {
                this.size = 0, this.__data__ = {
                    hash: new ne,
                    map: new(G || ie),
                    string: new ne
                }
            }, se.prototype.delete = function(e) {
                var t = ge(this, e).delete(e);
                return this.size -= t ? 1 : 0, t
            }, se.prototype.get = function(e) {
                return ge(this, e).get(e)
            }, se.prototype.has = function(e) {
                return ge(this, e).has(e)
            }, se.prototype.set = function(e, t) {
                var n = ge(this, e),
                    i = n.size;
                return n.set(e, t), this.size += n.size == i ? 0 : 1, this
            }, re.prototype.add = re.prototype.push = function(e) {
                return this.__data__.set(e, "__lodash_hash_undefined__"), this
            }, re.prototype.has = function(e) {
                return this.__data__.has(e)
            }, oe.prototype.clear = function() {
                this.__data__ = new ie, this.size = 0
            }, oe.prototype.delete = function(e) {
                var t = this.__data__,
                    n = t.delete(e);
                return this.size = t.size, n
            }, oe.prototype.get = function(e) {
                return this.__data__.get(e)
            }, oe.prototype.has = function(e) {
                return this.__data__.has(e)
            }, oe.prototype.set = function(e, t) {
                var n = this.__data__;
                if (n instanceof ie) {
                    var i = n.__data__;
                    if (!G || i.length < 199) return i.push([e, t]), this.size = ++n.size, this;
                    n = this.__data__ = new se(i)
                }
                return n.set(e, t), this.size = n.size, this
            };
            var ve = H ? function(e) {
                    return null == e ? [] : (e = Object(e), function(e, t) {
                        for (var n = -1, i = null == e ? 0 : e.length, s = 0, r = []; ++n < i;) {
                            var o = e[n];
                            t(o, n, e) && (r[s++] = o)
                        }
                        return r
                    }(H(e), (function(t) {
                        return F.call(e, t)
                    })))
                } : function() {
                    return []
                },
                Se = de;

            function ye(e, t) {
                return !!(t = null == t ? 9007199254740991 : t) && ("number" == typeof e || c.test(e)) && e > -1 && e % 1 == 0 && e < t
            }

            function Ee(e) {
                if (null != e) {
                    try {
                        return D.call(e)
                    } catch (e) {}
                    try {
                        return e + ""
                    } catch (e) {}
                }
                return ""
            }

            function be(e, t) {
                return e === t || e != e && t != t
            }(J && "[object DataView]" != Se(new J(new ArrayBuffer(1))) || G && Se(new G) != s || $ && "[object Promise]" != Se($.resolve()) || K && Se(new K) != o || q && "[object WeakMap]" != Se(new q)) && (Se = function(e) {
                var t = de(e),
                    n = t == r ? e.constructor : void 0,
                    i = n ? Ee(n) : "";
                if (i) switch (i) {
                    case z:
                        return "[object DataView]";
                    case Q:
                        return s;
                    case Y:
                        return "[object Promise]";
                    case X:
                        return o;
                    case Z:
                        return "[object WeakMap]"
                }
                return t
            });
            var Ce = ue(function() {
                    return arguments
                }()) ? ue : function(e) {
                    return De(e) && P.call(e, "callee") && !F.call(e, "callee")
                },
                Te = Array.isArray;
            var Re = V || function() {
                return !1
            };

            function Ae(e) {
                if (!we(e)) return !1;
                var t = de(e);
                return "[object Function]" == t || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t
            }

            function Ie(e) {
                return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991
            }

            function we(e) {
                var t = typeof e;
                return null != e && ("object" == t || "function" == t)
            }

            function De(e) {
                return null != e && "object" == typeof e
            }
            var Pe = v ? function(e) {
                return function(t) {
                    return e(t)
                }
            }(v) : function(e) {
                return De(e) && Ie(e.length) && !!d[de(e)]
            };

            function Oe(e) {
                return null != (t = e) && Ie(t.length) && !Ae(t) ? ae(e) : pe(e);
                var t
            }
            n.exports = function(e, t) {
                return le(e, t)
            }
        }).call(this, n(45), n(81)(e))
    }, function(e, t, n) {
        "use strict";
        n.d(t, "c", (function() {
            return i
        })), n.d(t, "a", (function() {
            return s
        })), n.d(t, "b", (function() {
            return r
        }));
        const i = "pending",
            s = "active",
            r = "ended"
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        }));
        const i = {
            ACCEPT: "session-accept",
            CONNECTION_ERROR: "connection-error-encountered",
            INITIATE: "session-initiate",
            TERMINATE: "session-terminate",
            TRANSPORT_INFO: "transport-info",
            UNAVAILABLE: "unavailable"
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return D
            }));
            var i = n(3),
                s = n(12),
                r = n.n(s);
            const o = n(5).getLogger(e),
                a = "createOffer",
                c = "createAnswer",
                d = "setLocalDescription",
                u = "setRemoteDescription",
                l = "addIceCandidate",
                h = "getUserMedia",
                p = "iceConnectionFailure",
                m = "applicationLog",
                f = "fabricHold",
                g = "fabricResume",
                _ = "audioMute",
                v = "audioUnmute",
                S = "videoPause",
                y = "videoResume",
                E = "screenShareStart",
                b = "screenShareStop",
                C = "dominantSpeaker",
                T = "activeDeviceList",
                R = "error",
                A = "event",
                I = "mstWithUserID";
            let w;
            class D {
                static _addNewFabricCallback(e, t) {
                    D.backend && "success" !== e && o.error(`Monitoring status: ${e} msg: ${t}`)
                }
                static _initCallback(e, t) {
                    if (o.log(`CallStats Status: err=${e} msg=${t}`), "success" !== e) return;
                    D.backendInitialized = !0;
                    let n = !1,
                        i = null;
                    for (const e of D.fabrics.values()) e.hasFabric || (o.debug("addNewFabric - initCallback"), e._addNewFabric() && (n = !0, i || (i = e)));
                    n && D._emptyReportQueue(i)
                }
                static _emptyReportQueue(e) {
                    const t = e.confID,
                        n = e.peerconnection;
                    for (const i of D.reportsQueue)
                        if (i.type === R) {
                            const t = i.data;
                            D._reportError(e, t.type, t.error, t.pc || n)
                        } else if (i.type === A) {
                        const e = i.data;
                        D.backend.sendFabricEvent(i.pc || n, e.event, t, e.eventData)
                    } else if (i.type === I) {
                        const e = i.data;
                        D.backend.associateMstWithUserID(i.pc || n, e.callStatsId, t, e.ssrc, e.usageLabel, e.containerId)
                    }
                    D.reportsQueue.length = 0
                }
                static _reportError(e, t, n, i) {
                    let s = n;
                    s || (o.warn("No error is passed!"), s = new Error("Unknown error")), D.backendInitialized && e ? D.backend.reportError(i, e.confID, t, s) : D.reportsQueue.push({
                        type: R,
                        data: {
                            error: s,
                            pc: i,
                            type: t
                        }
                    })
                }
                static _reportEvent(e, t, n) {
                    const i = e && e.peerconnection,
                        s = e && e.confID;
                    D.backendInitialized && e ? D.backend.sendFabricEvent(i, t, s, n) : D.reportsQueue.push({
                        confID: s,
                        pc: i,
                        type: A,
                        data: {
                            event: t,
                            eventData: n
                        }
                    })
                }
                static _traceAndCatchBackendCalls(e) {
                    const t = ["associateMstWithUserID", "sendFabricEvent", "sendUserFeedback"];
                    for (const n of t) {
                        const t = e[n];
                        e[n] = function(...n) {
                            try {
                                return t.apply(e, n)
                            } catch (e) {
                                r.a.callErrorHandler(e)
                            }
                        }
                    }
                    const n = ["associateMstWithUserID", "sendFabricEvent", "sendUserFeedback"];
                    for (const t of n) {
                        const n = e[t];
                        e[t] = function(...i) {
                            o.debug(t, i), n.apply(e, i)
                        }
                    }
                    const s = e.reportError;
                    e.reportError = function(t, n, a, ...c) {
                        a === m ? i.a.isReactNative() || console && console.debug("reportError", t, n, a) : o.debug("reportError", t, n, a, ...c);
                        try {
                            s.call(e, t, n, a, ...c)
                        } catch (e) {
                            a === m ? console && console.error("reportError", e) : r.a.callErrorHandler(e)
                        }
                    }
                }
                static get fabrics() {
                    return w || (w = new Set), w
                }
                static initBackend(e) {
                    if (D.backend) throw new Error("CallStats backend has been initialized already!");
                    try {
                        const t = callstats;
                        let n;
                        if (D.backend = new t, D._traceAndCatchBackendCalls(D.backend), D.userID = {
                                aliasName: e.aliasName,
                                userName: e.userName
                            }, D.callStatsID = e.callStatsID, D.callStatsSecret = e.callStatsSecret, e.applicationName && (n = {
                                applicationVersion: `${e.applicationName} (${i.a.getName()})`
                            }), e.confID) {
                            const t = e.confID.match(/.*\/(.*)\/.*/);
                            n.siteID = e.siteID || t && t[1] || "/"
                        }
                        D.backend.initialize(D.callStatsID, D.callStatsSecret, D.userID, D._initCallback, void 0, n);
                        const s = e.getWiFiStatsMethod;
                        return s && (D.backend.attachWifiStatsHandler(s), s().then(e => {
                            e && o.info("Reported wifi addresses:", JSON.parse(e).addresses)
                        }).catch(() => {})), !0
                    } catch (e) {
                        return r.a.callErrorHandler(e), D.backend = null, o.error(e), !1
                    }
                }
                static isBackendInitialized() {
                    return Boolean(D.backend)
                }
                static sendActiveDeviceListEvent(e, t) {
                    D._reportEvent(t, T, e)
                }
                static sendApplicationLog(e, t) {
                    try {
                        D._reportError(t, m, e, t && t.peerconnection)
                    } catch (e) {
                        console && "function" == typeof console.error && console.error("sendApplicationLog failed", e)
                    }
                }
                static sendFeedback(e, t, n) {
                    return new Promise((i, s) => {
                        if (D.backend) D.backend.sendUserFeedback(e, {
                            userID: D.userID,
                            overall: t,
                            comment: n
                        }, (e, t) => {
                            "success" === e ? i(t) : s(t)
                        });
                        else {
                            const e = "Failed to submit feedback to CallStats - no backend";
                            o.error(e), s(e)
                        }
                    })
                }
                static sendGetUserMediaFailed(e, t) {
                    D._reportError(t, h, e, null)
                }
                static sendMuteEvent(e, t, n) {
                    let i;
                    i = "video" === t ? e ? S : y : e ? _ : v, D._reportEvent(n, i)
                }
                constructor(e, t) {
                    this.confID = t.confID, this.tpc = e, this.peerconnection = e.peerconnection, this.remoteUserID = t.remoteUserID || "jitsi", this.hasFabric = !1, D.fabrics.add(this), D.backendInitialized && (this._addNewFabric(), 1 === D.fabrics.size && D._emptyReportQueue(this))
                }
                _addNewFabric() {
                    o.info("addNewFabric", this.remoteUserID);
                    try {
                        const e = {
                                remoteEndpointType: this.tpc.isP2P ? D.backend.endpointType.peer : D.backend.endpointType.server
                            },
                            t = D.backend.addNewFabric(this.peerconnection, this.remoteUserID, D.backend.fabricUsage.multiplex, this.confID, e, D._addNewFabricCallback);
                        this.hasFabric = !0;
                        const n = "success" === t.status;
                        return n || o.error("callstats fabric not initilized", t.message), n
                    } catch (e) {
                        return r.a.callErrorHandler(e), !1
                    }
                }
                associateStreamWithVideoTag(e, t, n, i, s) {
                    if (!D.backend) return;
                    const r = t ? D.userID : n;
                    D.backendInitialized ? D.backend.associateMstWithUserID(this.peerconnection, r, this.confID, e, i, s) : D.reportsQueue.push({
                        type: I,
                        pc: this.peerconnection,
                        data: {
                            callStatsId: r,
                            containerId: s,
                            ssrc: e,
                            usageLabel: i
                        }
                    })
                }
                sendDominantSpeakerEvent() {
                    D._reportEvent(this, C)
                }
                sendTerminateEvent() {
                    D.backendInitialized && D.backend.sendFabricEvent(this.peerconnection, D.backend.fabricEvent.fabricTerminated, this.confID), D.fabrics.delete(this)
                }
                sendIceConnectionFailedEvent() {
                    D._reportError(this, p, null, this.peerconnection)
                }
                sendCreateOfferFailed(e) {
                    D._reportError(this, a, e, this.peerconnection)
                }
                sendCreateAnswerFailed(e) {
                    D._reportError(this, c, e, this.peerconnection)
                }
                sendResumeOrHoldEvent(e) {
                    D._reportEvent(this, e ? g : f)
                }
                sendScreenSharingEvent(e, t) {
                    let n;
                    t && (n = {
                        ssrc: t
                    }), D._reportEvent(this, e ? E : b, n)
                }
                sendSetLocalDescFailed(e) {
                    D._reportError(this, d, e, this.peerconnection)
                }
                sendSetRemoteDescFailed(e) {
                    D._reportError(this, u, e, this.peerconnection)
                }
                sendAddIceCandidateFailed(e) {
                    D._reportError(this, l, e, this.peerconnection)
                }
            }
            D.backend = null, D.reportsQueue = [], D.backendInitialized = !1, D.callStatsID = null, D.callStatsSecret = null, D.userID = null
        }).call(this, "modules/statistics/CallStats.js")
    }, function(e, t) {
        function n(e, t) {
            return Math.floor(Math.random() * (t - e + 1)) + e
        }

        function i(e) {
            return e[n(0, e.length - 1)]
        }
        const s = {
            randomHexDigit: () => i("0123456789abcdef"),
            randomHexString(e) {
                let t = "";
                for (; e--;) t += this.randomHexDigit();
                return t
            },
            randomElement: i,
            randomAlphanumStr: function(e) {
                let t = "";
                for (let n = 0; n < e; n += 1) t += i("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
                return t
            },
            randomInt: n
        };
        e.exports = s
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return r
        }));
        var i = n(22);

        function s(e = class {}) {
            return class extends e {
                constructor(...e) {
                    super(...e), this.connection = null
                }
                init(e) {
                    this.connection = e
                }
            }
        }
        t.b = s();
        const r = s(i.a)
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return a
            }));
            var i = n(21),
                s = n(15),
                r = n(3);
            const o = n(5).getLogger(e),
                a = 5,
                c = {
                    obtainStream: null,
                    init(e = {}) {
                        this.options = e, this.obtainStream = this._createObtainStreamMethod(), this.obtainStream || o.info("Desktop sharing disabled")
                    },
                    _createObtainStreamMethod() {
                        return r.a.isNWJS() ? (e, t) => {
                            window.JitsiMeetNW.obtainDesktopStream(e, (e, n) => {
                                let r;
                                r = e && "InvalidStateError" === e.name ? new i.a(s.SCREENSHARING_USER_CANCELED) : new i.a(e, n, ["desktop"]), "function" == typeof t && t(r)
                            })
                        } : r.a.isElectron() ? this.obtainScreenOnElectron : r.a.isReactNative() && r.a.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMediaRN : r.a.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMedia : (o.log("Screen sharing not supported on ", r.a.getName()), null)
                    },
                    _getAudioConstraints() {
                        const {
                            audioQuality: e
                        } = this.options;
                        return !(null == e ? void 0 : e.stereo) || {
                            autoGainControl: !1,
                            channelCount: 2,
                            echoCancellation: !1,
                            noiseSuppression: !1
                        }
                    },
                    isSupported() {
                        return null !== this.obtainStream
                    },
                    obtainScreenOnElectron(e, t) {
                        if (window.JitsiMeetScreenObtainer && window.JitsiMeetScreenObtainer.openDesktopPicker) {
                            const {
                                desktopSharingFrameRate: n,
                                desktopSharingSources: r
                            } = this.options;
                            window.JitsiMeetScreenObtainer.openDesktopPicker({
                                desktopSharingSources: r || ["screen", "window"]
                            }, (r, o, c = !1) => {
                                if (r) {
                                    var d, u;
                                    let i = !1;
                                    if (c) {
                                        i = {};
                                        const e = this._getAudioConstraints();
                                        "boolean" != typeof e && (i = {
                                            optional: e
                                        }), "screen" === o && (i.mandatory = {
                                            chromeMediaSource: "desktop"
                                        })
                                    }
                                    const s = {
                                        audio: i,
                                        video: {
                                            mandatory: {
                                                chromeMediaSource: "desktop",
                                                chromeMediaSourceId: r,
                                                minFrameRate: null !== (d = null == n ? void 0 : n.min) && void 0 !== d ? d : a,
                                                maxFrameRate: null !== (u = null == n ? void 0 : n.max) && void 0 !== u ? u : a,
                                                maxWidth: window.screen.width,
                                                maxHeight: window.screen.height
                                            }
                                        }
                                    };
                                    navigator.mediaDevices.getUserMedia(s).then(t => e({
                                        stream: t,
                                        sourceId: r,
                                        sourceType: o
                                    }), t)
                                } else t(new i.a(s.SCREENSHARING_USER_CANCELED))
                            }, e => t(new i.a(s.ELECTRON_DESKTOP_PICKER_ERROR, e)))
                        } else t(new i.a(s.ELECTRON_DESKTOP_PICKER_NOT_FOUND))
                    },
                    obtainScreenFromGetDisplayMedia(e, t) {
                        let n;
                        n = navigator.getDisplayMedia ? navigator.getDisplayMedia.bind(navigator) : navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices);
                        const {
                            desktopSharingFrameRate: r
                        } = this.options, a = "object" != typeof r || {
                            frameRate: r
                        }, c = this._getAudioConstraints();
                        a.frameRate && delete a.frameRate.min;
                        const d = {
                            video: a,
                            audio: c,
                            cursor: "always"
                        };
                        o.info("Using getDisplayMedia for screen sharing", d), n(d).then(t => {
                            e({
                                stream: t,
                                sourceId: t.id
                            })
                        }).catch(e => {
                            const n = {
                                errorName: e && e.name,
                                errorMsg: e && e.message,
                                errorStack: e && e.stack
                            };
                            o.error("getDisplayMedia error", d, n), n.errorMsg && -1 !== n.errorMsg.indexOf("denied by system") ? t(new i.a(s.PERMISSION_DENIED)) : t(new i.a(s.SCREENSHARING_USER_CANCELED))
                        })
                    },
                    obtainScreenFromGetDisplayMediaRN(e, t) {
                        o.info("Using getDisplayMedia for screen sharing"), navigator.mediaDevices.getDisplayMedia({
                            video: !0
                        }).then(t => {
                            e({
                                stream: t,
                                sourceId: t.id
                            })
                        }).catch(() => {
                            t(new i.a(s.SCREENSHARING_USER_CANCELED))
                        })
                    },
                    setDesktopSharingFrameRate(e) {
                        o.info("Setting the desktop capture rate to " + e), this.options.desktopSharingFrameRate = {
                            min: a,
                            max: e
                        }
                    }
                };
            t.b = c
        }).call(this, "modules/RTC/ScreenObtainer.js")
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "CONNECTION_DROPPED_ERROR", (function() {
            return i
        })), n.d(t, "OTHER_ERROR", (function() {
            return s
        })), n.d(t, "PASSWORD_REQUIRED", (function() {
            return r
        })), n.d(t, "SERVER_ERROR", (function() {
            return o
        }));
        const i = "connection.droppedError",
            s = "connection.otherError",
            r = "connection.passwordRequired",
            o = "connection.serverError"
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return u
            }));
            var i = n(5),
                s = n(2),
                r = (n(157), n(22)),
                o = n(96),
                a = n(98),
                c = n(99);
            const d = Object(i.getLogger)(e);
            class u extends r.a {
                static get Events() {
                    return {
                        CONN_STATUS_CHANGED: "CONN_STATUS_CHANGED",
                        CONN_SHARD_CHANGED: "CONN_SHARD_CHANGED"
                    }
                }
                static get Status() {
                    return s.Strophe.Status
                }
                constructor({
                    enableWebsocketResume: e,
                    websocketKeepAlive: t,
                    websocketKeepAliveUrl: n,
                    serviceUrl: i,
                    shard: r,
                    xmppPing: d
                }) {
                    super(), this._options = {
                        enableWebsocketResume: void 0 === e || e,
                        pingOptions: d,
                        shard: r,
                        websocketKeepAlive: void 0 === t ? 6e4 : Number(t),
                        websocketKeepAliveUrl: n // BAO
                    }, this.$msg = s.$msg, this.$pres = s.$pres, this.$iq = s.$iq, this.Strophe = s.Strophe, this._stropheConn = new s.Strophe.Connection(i), this._usesWebsocket = i.startsWith("ws:") || i.startsWith("wss:"), this._stropheConn.maxRetries = 3, this._rawInputTracker = new a.a, this._rawInputTracker.startTracking(this, this._stropheConn), this._resumeTask = new o.a(this._stropheConn), this._deferredIQs = [], this.addConnectionPlugin("ping", new c.a({
                        getTimeSinceLastServerResponse: () => this.getTimeSinceLastSuccess(),
                        onPingThresholdExceeded: () => this._onPingErrorThresholdExceeded(),
                        pingOptions: d
                    })), this._oneSuccessfulConnect = !1
                }
                get connected() {
                    const e = this._stropheConn && this._stropheConn._proto && this._stropheConn._proto.socket;
                    return (this._status === s.Strophe.Status.CONNECTED || this._status === s.Strophe.Status.ATTACHED) && (!this.isUsingWebSocket || e && e.readyState === WebSocket.OPEN)
                }
                get disco() {
                    return this._stropheConn.disco
                }
                get disconnecting() {
                    return !0 === this._stropheConn.disconnecting
                }
                get domain() {
                    return this._stropheConn.domain
                }
                get isUsingWebSocket() {
                    return this._usesWebsocket
                }
                get jid() {
                    return this._stropheConn.jid
                }
                get lastResponseHeaders() {
                    return this._stropheConn._proto && this._stropheConn._proto.lastResponseHeaders
                }
                get logger() {
                    return this._stropheConn.logger
                }
                get options() {
                    return this._stropheConn.options
                }
                get pingDomain() {
                    var e;
                    return (null === (e = this._options.pingOptions) || void 0 === e ? void 0 : e.domain) || this.domain
                }
                get service() {
                    return this._stropheConn.service
                }
                get status() {
                    return this._status
                }
                addConnectionPlugin(e, t) {
                    this[e] = t, t.init(this)
                }
                addHandler(...e) {
                    this._stropheConn.addHandler(...e)
                }
                attach(e, t, n, i, ...s) {
                    this._stropheConn.attach(e, t, n, this._stropheConnectionCb.bind(this, i), ...s)
                }
                connect(e, t, n, ...i) {
                    this._stropheConn.connect(e, t, this._stropheConnectionCb.bind(this, n), ...i)
                }
                _stropheConnectionCb(e, t, ...n) {
                    this._status = t;
                    let i = !1;
                    var r;
                    t === s.Strophe.Status.CONNECTED || t === s.Strophe.Status.ATTACHED ? (this._maybeEnableStreamResume(), this._usesWebsocket && this._oneSuccessfulConnect && this._keepAliveAndCheckShard(), this._oneSuccessfulConnect = !0, this._maybeStartWSKeepAlive(), this._processDeferredIQs(), this._resumeTask.cancel(), this.ping.startInterval((null === (r = this._options.pingOptions) || void 0 === r ? void 0 : r.domain) || this.domain)) : t === s.Strophe.Status.DISCONNECTED && (this.ping.stopInterval(), i = this._tryResumingConnection(), i || clearTimeout(this._wsKeepAlive));
                    i || (e(t, ...n), this.eventEmitter.emit(u.Events.CONN_STATUS_CHANGED, t))
                }
                _clearDeferredIQs() {
                    for (const e of this._deferredIQs) e.reject(new Error("disconnect"));
                    this._deferredIQs = []
                }
                closeWebsocket() {
                    this._stropheConn && this._stropheConn._proto && (this._stropheConn._proto._closeSocket(), this._stropheConn._proto._onClose(null))
                }
                disconnect(...e) {
                    this._resumeTask.cancel(), clearTimeout(this._wsKeepAlive), this._clearDeferredIQs(), this._stropheConn.disconnect(...e)
                }
                flush(...e) {
                    this._stropheConn.flush(...e)
                }
                getTimeSinceLastSuccess() {
                    return this._rawInputTracker.getTimeSinceLastSuccess()
                }
                getLastFailedMessage() {
                    return this._rawInputTracker.getLastFailedMessage()
                }
                _maybeEnableStreamResume() {
                    if (!this._options.enableWebsocketResume) return;
                    const {
                        streamManagement: e
                    } = this._stropheConn;
                    this.isUsingWebSocket ? e ? e.isSupported() ? e.getResumeToken() || (d.info("Enabling XEP-0198 stream management"), e.enable(!0)) : d.warn("Stream resume enabled, but XEP-0198 is not supported by the server") : d.warn("Stream resume enabled, but Strophe streamManagement plugin is not installed") : d.warn("Stream resume enabled, but WebSockets are not enabled")
                }
                _maybeStartWSKeepAlive() {
                    const {
                        websocketKeepAlive: e
                    } = this._options;
                    if (this._usesWebsocket && e > 0) {
                        this._wsKeepAlive || d.info(`WebSocket keep alive interval: ${e}ms`), clearTimeout(this._wsKeepAlive);
                        const t = e + 60 * Math.random() * 1e3;
                        d.debug(`Scheduling next WebSocket keep-alive in ${t}ms`), this._wsKeepAlive = setTimeout(() => this._keepAliveAndCheckShard().then(() => this._maybeStartWSKeepAlive()), t)
                    }
                }
                _keepAliveAndCheckShard() {
                    const {
                        shard: e,
                        websocketKeepAliveUrl: t
                    } = this._options, n = t || this.service.replace("wss://", "https://").replace("ws://", "http://");
                    return fetch(n).then(t => {
                        if (!e) return;
                        const n = t.headers.get("x-jitsi-shard");
                        n !== e && (d.error(`Detected that shard changed from ${e} to ${n}`), this.eventEmitter.emit(u.Events.CONN_SHARD_CHANGED))
                    }).catch(e => {
                        d.error("Websocket Keep alive failed for url: " + n, {
                            error: e
                        })
                    })
                }
                _processDeferredIQs() {
                    for (const e of this._deferredIQs)
                        if (e.iq) {
                            clearTimeout(e.timeout);
                            const t = Date.now() - e.start;
                            this.sendIQ(e.iq, t => e.resolve(t), t => e.reject(t), t)
                        } this._deferredIQs = []
                }
                send(e) {
                    if (!this.connected) throw new Error("Not connected");
                    this._stropheConn.send(e)
                }
                sendIQ(e, t, n, i) {
                    if (this.connected) return this._stropheConn.sendIQ(e, t, n, i);
                    n("Not connected")
                }
                sendIQ2(e, {
                    timeout: t
                }) {
                    return new Promise((n, i) => {
                        if (this.connected) this.sendIQ(e, e => n(e), e => i(e), t);
                        else {
                            const s = {
                                iq: e,
                                resolve: n,
                                reject: i,
                                start: Date.now(),
                                timeout: setTimeout(() => {
                                    s.iq = void 0, i(void 0)
                                }, t)
                            };
                            this._deferredIQs.push(s)
                        }
                    })
                }
                _onPingErrorThresholdExceeded() {
                    this.isUsingWebSocket && (d.warn("Ping error threshold exceeded - killing the WebSocket"), this.closeWebsocket())
                }
                sendPresence(e, t, n, i) {
                    this.connected ? this._stropheConn.sendPresence(e, t, n, i) : n("Not connected")
                }
                sendUnavailableBeacon() {
                    if (!navigator.sendBeacon || this._stropheConn.disconnecting || !this._stropheConn.connected) return !1;
                    this._stropheConn._changeConnectStatus(s.Strophe.Status.DISCONNECTING), this._stropheConn.disconnecting = !0;
                    const e = this._stropheConn._proto._buildBody().attrs({
                            type: "terminate"
                        }),
                        t = Object(s.$pres)({
                            xmlns: s.Strophe.NS.CLIENT,
                            type: "unavailable"
                        });
                    e.cnode(t.tree());
                    const n = navigator.sendBeacon(-1 === this.service.indexOf("https://") ? "https:" + this.service : this.service, s.Strophe.serialize(e.tree()));
                    return d.info("Successfully send unavailable beacon " + n), this._stropheConn._proto._abortAllRequests(), this._stropheConn._doDisconnect(), !0
                }
                _tryResumingConnection() {
                    const {
                        streamManagement: e
                    } = this._stropheConn;
                    return !(!e || !e.getResumeToken()) && (this._resumeTask.schedule(), !0)
                }
            }
        }).call(this, "modules/xmpp/XmppConnection.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        })), n.d(t, "b", (function() {
            return s
        }));
        const i = "signaling.peerMuted",
            s = "signaling.peerVideoType"
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        })), n.d(t, "b", (function() {
            return s
        }));
        const i = "https://api.callstats.io/static/callstats-ws.min.js",
            s = 5
    }, function(e, t, n) {
        (function(e, n) {
            var i = "[object Arguments]",
                s = "[object Function]",
                r = "[object GeneratorFunction]",
                o = "[object Map]",
                a = "[object Set]",
                c = /\w*$/,
                d = /^\[object .+?Constructor\]$/,
                u = /^(?:0|[1-9]\d*)$/,
                l = {};
            l[i] = l["[object Array]"] = l["[object ArrayBuffer]"] = l["[object DataView]"] = l["[object Boolean]"] = l["[object Date]"] = l["[object Float32Array]"] = l["[object Float64Array]"] = l["[object Int8Array]"] = l["[object Int16Array]"] = l["[object Int32Array]"] = l[o] = l["[object Number]"] = l["[object Object]"] = l["[object RegExp]"] = l[a] = l["[object String]"] = l["[object Symbol]"] = l["[object Uint8Array]"] = l["[object Uint8ClampedArray]"] = l["[object Uint16Array]"] = l["[object Uint32Array]"] = !0, l["[object Error]"] = l[s] = l["[object WeakMap]"] = !1;
            var h = "object" == typeof e && e && e.Object === Object && e,
                p = "object" == typeof self && self && self.Object === Object && self,
                m = h || p || Function("return this")(),
                f = t && !t.nodeType && t,
                g = f && "object" == typeof n && n && !n.nodeType && n,
                _ = g && g.exports === f;

            function v(e, t) {
                return e.set(t[0], t[1]), e
            }

            function S(e, t) {
                return e.add(t), e
            }

            function y(e, t, n, i) {
                var s = -1,
                    r = e ? e.length : 0;
                for (i && r && (n = e[++s]); ++s < r;) n = t(n, e[s], s, e);
                return n
            }

            function E(e) {
                var t = !1;
                if (null != e && "function" != typeof e.toString) try {
                    t = !!(e + "")
                } catch (e) {}
                return t
            }

            function b(e) {
                var t = -1,
                    n = Array(e.size);
                return e.forEach((function(e, i) {
                    n[++t] = [i, e]
                })), n
            }

            function C(e, t) {
                return function(n) {
                    return e(t(n))
                }
            }

            function T(e) {
                var t = -1,
                    n = Array(e.size);
                return e.forEach((function(e) {
                    n[++t] = e
                })), n
            }
            var R, A = Array.prototype,
                I = Function.prototype,
                w = Object.prototype,
                D = m["__core-js_shared__"],
                P = (R = /[^.]+$/.exec(D && D.keys && D.keys.IE_PROTO || "")) ? "Symbol(src)_1." + R : "",
                O = I.toString,
                N = w.hasOwnProperty,
                M = w.toString,
                L = RegExp("^" + O.call(N).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                k = _ ? m.Buffer : void 0,
                x = m.Symbol,
                F = m.Uint8Array,
                j = C(Object.getPrototypeOf, Object),
                U = Object.create,
                H = w.propertyIsEnumerable,
                V = A.splice,
                B = Object.getOwnPropertySymbols,
                J = k ? k.isBuffer : void 0,
                G = C(Object.keys, Object),
                $ = ge(m, "DataView"),
                K = ge(m, "Map"),
                q = ge(m, "Promise"),
                W = ge(m, "Set"),
                z = ge(m, "WeakMap"),
                Q = ge(Object, "create"),
                Y = Ee($),
                X = Ee(K),
                Z = Ee(q),
                ee = Ee(W),
                te = Ee(z),
                ne = x ? x.prototype : void 0,
                ie = ne ? ne.valueOf : void 0;

            function se(e) {
                var t = -1,
                    n = e ? e.length : 0;
                for (this.clear(); ++t < n;) {
                    var i = e[t];
                    this.set(i[0], i[1])
                }
            }

            function re(e) {
                var t = -1,
                    n = e ? e.length : 0;
                for (this.clear(); ++t < n;) {
                    var i = e[t];
                    this.set(i[0], i[1])
                }
            }

            function oe(e) {
                var t = -1,
                    n = e ? e.length : 0;
                for (this.clear(); ++t < n;) {
                    var i = e[t];
                    this.set(i[0], i[1])
                }
            }

            function ae(e) {
                this.__data__ = new re(e)
            }

            function ce(e, t) {
                var n = Ce(e) || function(e) {
                        return function(e) {
                            return function(e) {
                                return !!e && "object" == typeof e
                            }(e) && Te(e)
                        }(e) && N.call(e, "callee") && (!H.call(e, "callee") || M.call(e) == i)
                    }(e) ? function(e, t) {
                        for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
                        return i
                    }(e.length, String) : [],
                    s = n.length,
                    r = !!s;
                for (var o in e) !t && !N.call(e, o) || r && ("length" == o || Se(o, s)) || n.push(o);
                return n
            }

            function de(e, t, n) {
                var i = e[t];
                N.call(e, t) && be(i, n) && (void 0 !== n || t in e) || (e[t] = n)
            }

            function ue(e, t) {
                for (var n = e.length; n--;)
                    if (be(e[n][0], t)) return n;
                return -1
            }

            function le(e, t, n, d, u, h, p) {
                var m;
                if (d && (m = h ? d(e, u, h, p) : d(e)), void 0 !== m) return m;
                if (!Ie(e)) return e;
                var f = Ce(e);
                if (f) {
                    if (m = function(e) {
                            var t = e.length,
                                n = e.constructor(t);
                            t && "string" == typeof e[0] && N.call(e, "index") && (n.index = e.index, n.input = e.input);
                            return n
                        }(e), !t) return function(e, t) {
                        var n = -1,
                            i = e.length;
                        t || (t = Array(i));
                        for (; ++n < i;) t[n] = e[n];
                        return t
                    }(e, m)
                } else {
                    var g = ve(e),
                        _ = g == s || g == r;
                    if (Re(e)) return function(e, t) {
                        if (t) return e.slice();
                        var n = new e.constructor(e.length);
                        return e.copy(n), n
                    }(e, t);
                    if ("[object Object]" == g || g == i || _ && !h) {
                        if (E(e)) return h ? e : {};
                        if (m = function(e) {
                                return "function" != typeof e.constructor || ye(e) ? {} : (t = j(e), Ie(t) ? U(t) : {});
                                var t
                            }(_ ? {} : e), !t) return function(e, t) {
                            return me(e, _e(e), t)
                        }(e, function(e, t) {
                            return e && me(t, we(t), e)
                        }(m, e))
                    } else {
                        if (!l[g]) return h ? e : {};
                        m = function(e, t, n, i) {
                            var s = e.constructor;
                            switch (t) {
                                case "[object ArrayBuffer]":
                                    return pe(e);
                                case "[object Boolean]":
                                case "[object Date]":
                                    return new s(+e);
                                case "[object DataView]":
                                    return function(e, t) {
                                        var n = t ? pe(e.buffer) : e.buffer;
                                        return new e.constructor(n, e.byteOffset, e.byteLength)
                                    }(e, i);
                                case "[object Float32Array]":
                                case "[object Float64Array]":
                                case "[object Int8Array]":
                                case "[object Int16Array]":
                                case "[object Int32Array]":
                                case "[object Uint8Array]":
                                case "[object Uint8ClampedArray]":
                                case "[object Uint16Array]":
                                case "[object Uint32Array]":
                                    return function(e, t) {
                                        var n = t ? pe(e.buffer) : e.buffer;
                                        return new e.constructor(n, e.byteOffset, e.length)
                                    }(e, i);
                                case o:
                                    return function(e, t, n) {
                                        return y(t ? n(b(e), !0) : b(e), v, new e.constructor)
                                    }(e, i, n);
                                case "[object Number]":
                                case "[object String]":
                                    return new s(e);
                                case "[object RegExp]":
                                    return function(e) {
                                        var t = new e.constructor(e.source, c.exec(e));
                                        return t.lastIndex = e.lastIndex, t
                                    }(e);
                                case a:
                                    return function(e, t, n) {
                                        return y(t ? n(T(e), !0) : T(e), S, new e.constructor)
                                    }(e, i, n);
                                case "[object Symbol]":
                                    return r = e, ie ? Object(ie.call(r)) : {}
                            }
                            var r
                        }(e, g, le, t)
                    }
                }
                p || (p = new ae);
                var C = p.get(e);
                if (C) return C;
                if (p.set(e, m), !f) var R = n ? function(e) {
                    return function(e, t, n) {
                        var i = t(e);
                        return Ce(e) ? i : function(e, t) {
                            for (var n = -1, i = t.length, s = e.length; ++n < i;) e[s + n] = t[n];
                            return e
                        }(i, n(e))
                    }(e, we, _e)
                }(e) : we(e);
                return function(e, t) {
                    for (var n = -1, i = e ? e.length : 0; ++n < i && !1 !== t(e[n], n, e););
                }(R || e, (function(i, s) {
                    R && (i = e[s = i]), de(m, s, le(i, t, n, d, s, e, p))
                })), m
            }

            function he(e) {
                return !(!Ie(e) || (t = e, P && P in t)) && (Ae(e) || E(e) ? L : d).test(Ee(e));
                var t
            }

            function pe(e) {
                var t = new e.constructor(e.byteLength);
                return new F(t).set(new F(e)), t
            }

            function me(e, t, n, i) {
                n || (n = {});
                for (var s = -1, r = t.length; ++s < r;) {
                    var o = t[s],
                        a = i ? i(n[o], e[o], o, n, e) : void 0;
                    de(n, o, void 0 === a ? e[o] : a)
                }
                return n
            }

            function fe(e, t) {
                var n, i, s = e.__data__;
                return ("string" == (i = typeof(n = t)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? s["string" == typeof t ? "string" : "hash"] : s.map
            }

            function ge(e, t) {
                var n = function(e, t) {
                    return null == e ? void 0 : e[t]
                }(e, t);
                return he(n) ? n : void 0
            }
            se.prototype.clear = function() {
                this.__data__ = Q ? Q(null) : {}
            }, se.prototype.delete = function(e) {
                return this.has(e) && delete this.__data__[e]
            }, se.prototype.get = function(e) {
                var t = this.__data__;
                if (Q) {
                    var n = t[e];
                    return "__lodash_hash_undefined__" === n ? void 0 : n
                }
                return N.call(t, e) ? t[e] : void 0
            }, se.prototype.has = function(e) {
                var t = this.__data__;
                return Q ? void 0 !== t[e] : N.call(t, e)
            }, se.prototype.set = function(e, t) {
                return this.__data__[e] = Q && void 0 === t ? "__lodash_hash_undefined__" : t, this
            }, re.prototype.clear = function() {
                this.__data__ = []
            }, re.prototype.delete = function(e) {
                var t = this.__data__,
                    n = ue(t, e);
                return !(n < 0) && (n == t.length - 1 ? t.pop() : V.call(t, n, 1), !0)
            }, re.prototype.get = function(e) {
                var t = this.__data__,
                    n = ue(t, e);
                return n < 0 ? void 0 : t[n][1]
            }, re.prototype.has = function(e) {
                return ue(this.__data__, e) > -1
            }, re.prototype.set = function(e, t) {
                var n = this.__data__,
                    i = ue(n, e);
                return i < 0 ? n.push([e, t]) : n[i][1] = t, this
            }, oe.prototype.clear = function() {
                this.__data__ = {
                    hash: new se,
                    map: new(K || re),
                    string: new se
                }
            }, oe.prototype.delete = function(e) {
                return fe(this, e).delete(e)
            }, oe.prototype.get = function(e) {
                return fe(this, e).get(e)
            }, oe.prototype.has = function(e) {
                return fe(this, e).has(e)
            }, oe.prototype.set = function(e, t) {
                return fe(this, e).set(e, t), this
            }, ae.prototype.clear = function() {
                this.__data__ = new re
            }, ae.prototype.delete = function(e) {
                return this.__data__.delete(e)
            }, ae.prototype.get = function(e) {
                return this.__data__.get(e)
            }, ae.prototype.has = function(e) {
                return this.__data__.has(e)
            }, ae.prototype.set = function(e, t) {
                var n = this.__data__;
                if (n instanceof re) {
                    var i = n.__data__;
                    if (!K || i.length < 199) return i.push([e, t]), this;
                    n = this.__data__ = new oe(i)
                }
                return n.set(e, t), this
            };
            var _e = B ? C(B, Object) : function() {
                    return []
                },
                ve = function(e) {
                    return M.call(e)
                };

            function Se(e, t) {
                return !!(t = null == t ? 9007199254740991 : t) && ("number" == typeof e || u.test(e)) && e > -1 && e % 1 == 0 && e < t
            }

            function ye(e) {
                var t = e && e.constructor;
                return e === ("function" == typeof t && t.prototype || w)
            }

            function Ee(e) {
                if (null != e) {
                    try {
                        return O.call(e)
                    } catch (e) {}
                    try {
                        return e + ""
                    } catch (e) {}
                }
                return ""
            }

            function be(e, t) {
                return e === t || e != e && t != t
            }($ && "[object DataView]" != ve(new $(new ArrayBuffer(1))) || K && ve(new K) != o || q && "[object Promise]" != ve(q.resolve()) || W && ve(new W) != a || z && "[object WeakMap]" != ve(new z)) && (ve = function(e) {
                var t = M.call(e),
                    n = "[object Object]" == t ? e.constructor : void 0,
                    i = n ? Ee(n) : void 0;
                if (i) switch (i) {
                    case Y:
                        return "[object DataView]";
                    case X:
                        return o;
                    case Z:
                        return "[object Promise]";
                    case ee:
                        return a;
                    case te:
                        return "[object WeakMap]"
                }
                return t
            });
            var Ce = Array.isArray;

            function Te(e) {
                return null != e && function(e) {
                    return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991
                }(e.length) && !Ae(e)
            }
            var Re = J || function() {
                return !1
            };

            function Ae(e) {
                var t = Ie(e) ? M.call(e) : "";
                return t == s || t == r
            }

            function Ie(e) {
                var t = typeof e;
                return !!e && ("object" == t || "function" == t)
            }

            function we(e) {
                return Te(e) ? ce(e) : function(e) {
                    if (!ye(e)) return G(e);
                    var t = [];
                    for (var n in Object(e)) N.call(e, n) && "constructor" != n && t.push(n);
                    return t
                }(e)
            }
            n.exports = function(e) {
                return le(e, !0, !0)
            }
        }).call(this, n(45), n(81)(e))
    }, function(e, t) {
        var n;
        n = function() {
            return this
        }();
        try {
            n = n || new Function("return this")()
        } catch (e) {
            "object" == typeof window && (n = window)
        }
        e.exports = n
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        }));
        class i {
            constructor() {
                this.promise = new Promise((e, t) => {
                    this.resolve = (...t) => {
                        this.clearRejectTimeout(), e(...t)
                    }, this.reject = (...e) => {
                        this.clearRejectTimeout(), t(...e)
                    }
                }), this.then = this.promise.then.bind(this.promise), this.catch = this.promise.catch.bind(this.promise)
            }
            clearRejectTimeout() {
                clearTimeout(this._timeout)
            }
            setRejectTimeout(e) {
                this._timeout = setTimeout(() => {
                    this.reject(new Error("timeout"))
                }, e)
            }
        }
    }, function(e, t) {
        e.exports = {
            ENVIRONMENT: "environment",
            USER: "user"
        }
    }, function(e, t, n) {
        "use strict";
        const i = {
            generateIdentifier: function() {
                return Math.random().toString(36).substr(2, 10)
            }
        };
        i.localCName = i.generateIdentifier(), i.splitLines = function(e) {
            return e.trim().split("\n").map(e => e.trim())
        }, i.splitSections = function(e) {
            return e.split("\nm=").map((e, t) => (t > 0 ? "m=" + e : e).trim() + "\r\n")
        }, i.getDescription = function(e) {
            const t = i.splitSections(e);
            return t && t[0]
        }, i.getMediaSections = function(e) {
            const t = i.splitSections(e);
            return t.shift(), t
        }, i.matchPrefix = function(e, t) {
            return i.splitLines(e).filter(e => 0 === e.indexOf(t))
        }, i.parseCandidate = function(e) {
            let t;
            t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" ");
            const n = {
                foundation: t[0],
                component: {
                    1: "rtp",
                    2: "rtcp"
                } [t[1]] || t[1],
                protocol: t[2].toLowerCase(),
                priority: parseInt(t[3], 10),
                ip: t[4],
                address: t[4],
                port: parseInt(t[5], 10),
                type: t[7]
            };
            for (let e = 8; e < t.length; e += 2) switch (t[e]) {
                case "raddr":
                    n.relatedAddress = t[e + 1];
                    break;
                case "rport":
                    n.relatedPort = parseInt(t[e + 1], 10);
                    break;
                case "tcptype":
                    n.tcpType = t[e + 1];
                    break;
                case "ufrag":
                    n.ufrag = t[e + 1], n.usernameFragment = t[e + 1];
                    break;
                default:
                    void 0 === n[t[e]] && (n[t[e]] = t[e + 1])
            }
            return n
        }, i.writeCandidate = function(e) {
            const t = [];
            t.push(e.foundation);
            const n = e.component;
            "rtp" === n ? t.push(1) : "rtcp" === n ? t.push(2) : t.push(n), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port);
            const i = e.type;
            return t.push("typ"), t.push(i), "host" !== i && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ")
        }, i.parseIceOptions = function(e) {
            return e.substr(14).split(" ")
        }, i.parseRtpMap = function(e) {
            let t = e.substr(9).split(" ");
            const n = {
                payloadType: parseInt(t.shift(), 10)
            };
            return t = t[0].split("/"), n.name = t[0], n.clockRate = parseInt(t[1], 10), n.channels = 3 === t.length ? parseInt(t[2], 10) : 1, n.numChannels = n.channels, n
        }, i.writeRtpMap = function(e) {
            let t = e.payloadType;
            void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);
            const n = e.channels || e.numChannels || 1;
            return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== n ? "/" + n : "") + "\r\n"
        }, i.parseExtmap = function(e) {
            const t = e.substr(9).split(" ");
            return {
                id: parseInt(t[0], 10),
                direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv",
                uri: t[1]
            }
        }, i.writeExtmap = function(e) {
            return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n"
        }, i.parseFmtp = function(e) {
            const t = {};
            let n;
            const i = e.substr(e.indexOf(" ") + 1).split(";");
            for (let e = 0; e < i.length; e++) n = i[e].trim().split("="), t[n[0].trim()] = n[1];
            return t
        }, i.writeFmtp = function(e) {
            let t = "",
                n = e.payloadType;
            if (void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
                const i = [];
                Object.keys(e.parameters).forEach(t => {
                    void 0 !== e.parameters[t] ? i.push(t + "=" + e.parameters[t]) : i.push(t)
                }), t += "a=fmtp:" + n + " " + i.join(";") + "\r\n"
            }
            return t
        }, i.parseRtcpFb = function(e) {
            const t = e.substr(e.indexOf(" ") + 1).split(" ");
            return {
                type: t.shift(),
                parameter: t.join(" ")
            }
        }, i.writeRtcpFb = function(e) {
            let t = "",
                n = e.payloadType;
            return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(e => {
                t += "a=rtcp-fb:" + n + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n"
            }), t
        }, i.parseSsrcMedia = function(e) {
            const t = e.indexOf(" "),
                n = {
                    ssrc: parseInt(e.substr(7, t - 7), 10)
                },
                i = e.indexOf(":", t);
            return i > -1 ? (n.attribute = e.substr(t + 1, i - t - 1), n.value = e.substr(i + 1)) : n.attribute = e.substr(t + 1), n
        }, i.parseSsrcGroup = function(e) {
            const t = e.substr(13).split(" ");
            return {
                semantics: t.shift(),
                ssrcs: t.map(e => parseInt(e, 10))
            }
        }, i.getMid = function(e) {
            const t = i.matchPrefix(e, "a=mid:")[0];
            if (t) return t.substr(6)
        }, i.parseFingerprint = function(e) {
            const t = e.substr(14).split(" ");
            return {
                algorithm: t[0].toLowerCase(),
                value: t[1].toUpperCase()
            }
        }, i.getDtlsParameters = function(e, t) {
            return {
                role: "auto",
                fingerprints: i.matchPrefix(e + t, "a=fingerprint:").map(i.parseFingerprint)
            }
        }, i.writeDtlsParameters = function(e, t) {
            let n = "a=setup:" + t + "\r\n";
            return e.fingerprints.forEach(e => {
                n += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n"
            }), n
        }, i.parseCryptoLine = function(e) {
            const t = e.substr(9).split(" ");
            return {
                tag: parseInt(t[0], 10),
                cryptoSuite: t[1],
                keyParams: t[2],
                sessionParams: t.slice(3)
            }
        }, i.writeCryptoLine = function(e) {
            return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" == typeof e.keyParams ? i.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n"
        }, i.parseCryptoKeyParams = function(e) {
            if (0 !== e.indexOf("inline:")) return null;
            const t = e.substr(7).split("|");
            return {
                keyMethod: "inline",
                keySalt: t[0],
                lifeTime: t[1],
                mkiValue: t[2] ? t[2].split(":")[0] : void 0,
                mkiLength: t[2] ? t[2].split(":")[1] : void 0
            }
        }, i.writeCryptoKeyParams = function(e) {
            return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "")
        }, i.getCryptoParameters = function(e, t) {
            return i.matchPrefix(e + t, "a=crypto:").map(i.parseCryptoLine)
        }, i.getIceParameters = function(e, t) {
            const n = i.matchPrefix(e + t, "a=ice-ufrag:")[0],
                s = i.matchPrefix(e + t, "a=ice-pwd:")[0];
            return n && s ? {
                usernameFragment: n.substr(12),
                password: s.substr(10)
            } : null
        }, i.writeIceParameters = function(e) {
            let t = "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n";
            return e.iceLite && (t += "a=ice-lite\r\n"), t
        }, i.parseRtpParameters = function(e) {
            const t = {
                    codecs: [],
                    headerExtensions: [],
                    fecMechanisms: [],
                    rtcp: []
                },
                n = i.splitLines(e)[0].split(" ");
            for (let s = 3; s < n.length; s++) {
                const r = n[s],
                    o = i.matchPrefix(e, "a=rtpmap:" + r + " ")[0];
                if (o) {
                    const n = i.parseRtpMap(o),
                        s = i.matchPrefix(e, "a=fmtp:" + r + " ");
                    switch (n.parameters = s.length ? i.parseFmtp(s[0]) : {}, n.rtcpFeedback = i.matchPrefix(e, "a=rtcp-fb:" + r + " ").map(i.parseRtcpFb), t.codecs.push(n), n.name.toUpperCase()) {
                        case "RED":
                        case "ULPFEC":
                            t.fecMechanisms.push(n.name.toUpperCase())
                    }
                }
            }
            return i.matchPrefix(e, "a=extmap:").forEach(e => {
                t.headerExtensions.push(i.parseExtmap(e))
            }), t
        }, i.writeRtpDescription = function(e, t) {
            let n = "";
            n += "m=" + e + " ", n += t.codecs.length > 0 ? "9" : "0", n += " UDP/TLS/RTP/SAVPF ", n += t.codecs.map(e => void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType).join(" ") + "\r\n", n += "c=IN IP4 0.0.0.0\r\n", n += "a=rtcp:9 IN IP4 0.0.0.0\r\n", t.codecs.forEach(e => {
                n += i.writeRtpMap(e), n += i.writeFmtp(e), n += i.writeRtcpFb(e)
            });
            let s = 0;
            return t.codecs.forEach(e => {
                e.maxptime > s && (s = e.maxptime)
            }), s > 0 && (n += "a=maxptime:" + s + "\r\n"), t.headerExtensions && t.headerExtensions.forEach(e => {
                n += i.writeExtmap(e)
            }), n
        }, i.parseRtpEncodingParameters = function(e) {
            const t = [],
                n = i.parseRtpParameters(e),
                s = -1 !== n.fecMechanisms.indexOf("RED"),
                r = -1 !== n.fecMechanisms.indexOf("ULPFEC"),
                o = i.matchPrefix(e, "a=ssrc:").map(e => i.parseSsrcMedia(e)).filter(e => "cname" === e.attribute),
                a = o.length > 0 && o[0].ssrc;
            let c;
            const d = i.matchPrefix(e, "a=ssrc-group:FID").map(e => e.substr(17).split(" ").map(e => parseInt(e, 10)));
            d.length > 0 && d[0].length > 1 && d[0][0] === a && (c = d[0][1]), n.codecs.forEach(e => {
                if ("RTX" === e.name.toUpperCase() && e.parameters.apt) {
                    let n = {
                        ssrc: a,
                        codecPayloadType: parseInt(e.parameters.apt, 10)
                    };
                    a && c && (n.rtx = {
                        ssrc: c
                    }), t.push(n), s && (n = JSON.parse(JSON.stringify(n)), n.fec = {
                        ssrc: a,
                        mechanism: r ? "red+ulpfec" : "red"
                    }, t.push(n))
                }
            }), 0 === t.length && a && t.push({
                ssrc: a
            });
            let u = i.matchPrefix(e, "b=");
            return u.length && (u = 0 === u[0].indexOf("b=TIAS:") ? parseInt(u[0].substr(7), 10) : 0 === u[0].indexOf("b=AS:") ? 1e3 * parseInt(u[0].substr(5), 10) * .95 - 16e3 : void 0, t.forEach(e => {
                e.maxBitrate = u
            })), t
        }, i.parseRtcpParameters = function(e) {
            const t = {},
                n = i.matchPrefix(e, "a=ssrc:").map(e => i.parseSsrcMedia(e)).filter(e => "cname" === e.attribute)[0];
            n && (t.cname = n.value, t.ssrc = n.ssrc);
            const s = i.matchPrefix(e, "a=rtcp-rsize");
            t.reducedSize = s.length > 0, t.compound = 0 === s.length;
            const r = i.matchPrefix(e, "a=rtcp-mux");
            return t.mux = r.length > 0, t
        }, i.writeRtcpParameters = function(e) {
            let t = "";
            return e.reducedSize && (t += "a=rtcp-rsize\r\n"), e.mux && (t += "a=rtcp-mux\r\n"), void 0 !== e.ssrc && e.cname && (t += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"), t
        }, i.parseMsid = function(e) {
            let t;
            const n = i.matchPrefix(e, "a=msid:");
            if (1 === n.length) return t = n[0].substr(7).split(" "), {
                stream: t[0],
                track: t[1]
            };
            const s = i.matchPrefix(e, "a=ssrc:").map(e => i.parseSsrcMedia(e)).filter(e => "msid" === e.attribute);
            return s.length > 0 ? (t = s[0].value.split(" "), {
                stream: t[0],
                track: t[1]
            }) : void 0
        }, i.parseSctpDescription = function(e) {
            const t = i.parseMLine(e),
                n = i.matchPrefix(e, "a=max-message-size:");
            let s;
            n.length > 0 && (s = parseInt(n[0].substr(19), 10)), isNaN(s) && (s = 65536);
            const r = i.matchPrefix(e, "a=sctp-port:");
            if (r.length > 0) return {
                port: parseInt(r[0].substr(12), 10),
                protocol: t.fmt,
                maxMessageSize: s
            };
            const o = i.matchPrefix(e, "a=sctpmap:");
            if (o.length > 0) {
                const e = o[0].substr(10).split(" ");
                return {
                    port: parseInt(e[0], 10),
                    protocol: e[1],
                    maxMessageSize: s
                }
            }
        }, i.writeSctpDescription = function(e, t) {
            let n = [];
            return n = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && n.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), n.join("")
        }, i.generateSessionId = function() {
            return Math.random().toString().substr(2, 21)
        }, i.writeSessionBoilerplate = function(e, t, n) {
            let s;
            const r = void 0 !== t ? t : 2;
            s = e || i.generateSessionId();
            return "v=0\r\no=" + (n || "thisisadapterortc") + " " + s + " " + r + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"
        }, i.getDirection = function(e, t) {
            const n = i.splitLines(e);
            for (let e = 0; e < n.length; e++) switch (n[e]) {
                case "a=sendrecv":
                case "a=sendonly":
                case "a=recvonly":
                case "a=inactive":
                    return n[e].substr(2)
            }
            return t ? i.getDirection(t) : "sendrecv"
        }, i.getKind = function(e) {
            return i.splitLines(e)[0].split(" ")[0].substr(2)
        }, i.isRejected = function(e) {
            return "0" === e.split(" ", 2)[1]
        }, i.parseMLine = function(e) {
            const t = i.splitLines(e)[0].substr(2).split(" ");
            return {
                kind: t[0],
                port: parseInt(t[1], 10),
                protocol: t[2],
                fmt: t.slice(3).join(" ")
            }
        }, i.parseOLine = function(e) {
            const t = i.matchPrefix(e, "o=")[0].substr(2).split(" ");
            return {
                username: t[0],
                sessionId: t[1],
                sessionVersion: parseInt(t[2], 10),
                netType: t[3],
                addressType: t[4],
                address: t[5]
            }
        }, i.isValidSDP = function(e) {
            if ("string" != typeof e || 0 === e.length) return !1;
            const t = i.splitLines(e);
            for (let e = 0; e < t.length; e++)
                if (t[e].length < 2 || "=" !== t[e].charAt(1)) return !1;
            return !0
        }, e.exports = i
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "DEVICE_LIST_CHANGED", (function() {
            return i
        })), n.d(t, "PERMISSIONS_CHANGED", (function() {
            return s
        })), n.d(t, "PERMISSION_PROMPT_IS_SHOWN", (function() {
            return r
        })), n.d(t, "SLOW_GET_USER_MEDIA", (function() {
            return o
        }));
        const i = "mediaDevices.devicechange",
            s = "rtc.permissions_changed",
            r = "mediaDevices.permissionPromptIsShown",
            o = "mediaDevices.slowGetUserMedia"
    }, function(e, t, n) {
        const i = n(154),
            s = {
                loadScript(e, t, n, s, r, o) {
                    const a = document,
                        c = a.createElement("script"),
                        d = a.getElementsByTagName("script")[0];
                    if (c.async = t, s) {
                        const t = i();
                        if (t) {
                            const n = t.src,
                                i = n.substring(0, n.lastIndexOf("/") + 1);
                            n && i && (e = i + e)
                        }
                    }
                    r && (c.onload = r), o && (c.onerror = o), c.src = e, n ? d.parentNode.insertBefore(c, d) : d.parentNode.appendChild(c)
                }
            };
        e.exports = s
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return f
            })), n.d(t, "b", (function() {
                return g
            }));
            var i = n(5),
                s = n(1),
                r = n(16),
                o = n(4),
                a = n(7),
                c = n.n(a),
                d = n(8),
                u = n(3),
                l = n(6);

            function h(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? Object(arguments[t]) : {},
                        i = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), i.forEach((function(t) {
                        p(e, t, n[t])
                    }))
                }
                return e
            }

            function p(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const m = Object(i.getLogger)(e),
                f = {
                    ACTIVE: "active",
                    INACTIVE: "inactive",
                    INTERRUPTED: "interrupted",
                    RESTORING: "restoring"
                };
            class g {
                static _getNewStateForJvbMode(e, t, n, i, s) {
                    return e ? i ? f.ACTIVE : u.a.supportsVideoMuteOnConnInterrupted() ? s ? t ? n ? f.INTERRUPTED : f.RESTORING : f.INACTIVE : f.ACTIVE : t ? f.ACTIVE : f.INACTIVE : f.INTERRUPTED
                }
                static _getNewStateForP2PMode(e, t) {
                    return u.a.supportsVideoMuteOnConnInterrupted() ? e || !t ? f.ACTIVE : f.INTERRUPTED : f.ACTIVE
                }
                constructor(e, t, n) {
                    this.rtc = e, this.conference = t, this.trackTimers = {}, this.connStatusFromJvb = {}, this.outOfLastNTimeout = "number" == typeof n.outOfLastNTimeout ? n.outOfLastNTimeout : 500, this.rtcMuteTimeout = "number" == typeof n.rtcMuteTimeout ? n.rtcMuteTimeout : 1e4, this.rtcMutedTimestamp = {}, m.info("RtcMuteTimeout set to: " + this.rtcMuteTimeout), this.enteredLastNTimestamp = new Map, this.restoringTimers = new Map, this.connectionStatusMap = new Map
                }
                _getVideoFrozenTimeout(e) {
                    return this.rtc.isInLastN(e) ? this.rtcMuteTimeout : this.outOfLastNTimeout
                }
                init() {
                    this._onEndpointConnStatusChanged = this.onEndpointConnStatusChanged.bind(this), this.rtc.addListener(c.a.ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged), this._onP2PStatus = this.refreshConnectionStatusForAll.bind(this), this.conference.on(s.P2P_STATUS, this._onP2PStatus), this._onUserLeft = this.onUserLeft.bind(this), this.conference.on(s.USER_LEFT, this._onUserLeft), u.a.supportsVideoMuteOnConnInterrupted() && (this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this), this.rtc.addListener(c.a.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this), this.rtc.addListener(c.a.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this._onRemoteTrackAdded = this.onRemoteTrackAdded.bind(this), this.conference.on(s.TRACK_ADDED, this._onRemoteTrackAdded), this._onRemoteTrackRemoved = this.onRemoteTrackRemoved.bind(this), this.conference.on(s.TRACK_REMOVED, this._onRemoteTrackRemoved), this._onSignallingMuteChanged = this.onSignallingMuteChanged.bind(this), this._onTrackVideoTypeChanged = this.onTrackVideoTypeChanged.bind(this)), this._onLastNChanged = this._onLastNChanged.bind(this), this.conference.on(s.LAST_N_ENDPOINTS_CHANGED, this._onLastNChanged), this._onLastNValueChanged = this.refreshConnectionStatusForAll.bind(this), this.rtc.on(c.a.LASTN_VALUE_CHANGED, this._onLastNValueChanged)
                }
                dispose() {
                    this.rtc.removeListener(c.a.ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged), u.a.supportsVideoMuteOnConnInterrupted() && (this.rtc.removeListener(c.a.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this.rtc.removeListener(c.a.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this.conference.off(s.TRACK_ADDED, this._onRemoteTrackAdded), this.conference.off(s.TRACK_REMOVED, this._onRemoteTrackRemoved)), this.conference.off(s.LAST_N_ENDPOINTS_CHANGED, this._onLastNChanged), this.rtc.removeListener(c.a.LASTN_VALUE_CHANGED, this._onLastNValueChanged), this.conference.off(s.P2P_STATUS, this._onP2PStatus), this.conference.off(s.USER_LEFT, this._onUserLeft);
                    const e = Object.keys(this.trackTimers);
                    for (const t of e) this.clearTimeout(t), this.clearRtcMutedTimestamp(t);
                    for (const e in this.connectionStatusMap) this.connectionStatusMap.hasOwnProperty(e) && this.onUserLeft(e);
                    this.connStatusFromJvb = {}
                }
                onEndpointConnStatusChanged(e, t) {
                    m.debug(`Detector RTCEvents.ENDPOINT_CONN_STATUS_CHANGED(${Date.now()}): ${e}: ${t}`), e !== this.conference.myUserId() && (this.connStatusFromJvb[e] = t, this.figureOutConnectionStatus(e))
                }
                _changeConnectionStatus(e, t) {
                    if (e.getConnectionStatus() !== t) {
                        const n = e.getId();
                        e._setConnectionStatus(t), m.debug(`Emit endpoint conn status(${Date.now()}) ${n}: ${t}`), l.a.sendLog(JSON.stringify({
                            id: "peer.conn.status",
                            participant: n,
                            status: t
                        })), this.conference.eventEmitter.emit(s.PARTICIPANT_CONN_STATUS_CHANGED, n, t)
                    }
                }
                clearTimeout(e) {
                    this.trackTimers[e] && (window.clearTimeout(this.trackTimers[e]), this.trackTimers[e] = null)
                }
                clearRtcMutedTimestamp(e) {
                    this.rtcMutedTimestamp[e] = null
                }
                onRemoteTrackAdded(e) {
                    e.isLocal() || e.getType() !== o.c || (m.debug("Detector on remote track added for: " + e.getParticipantId()), e.on(r.TRACK_MUTE_CHANGED, this._onSignallingMuteChanged), e.on(r.TRACK_VIDEOTYPE_CHANGED, t => this._onTrackVideoTypeChanged(e, t)))
                }
                onRemoteTrackRemoved(e) {
                    if (!e.isLocal() && e.getType() === o.c) {
                        const t = e.getParticipantId();
                        m.debug("Detector on remote track removed: " + t), e.off(r.TRACK_MUTE_CHANGED, this._onSignallingMuteChanged), this.clearTimeout(t), this.clearRtcMutedTimestamp(t), this.figureOutConnectionStatus(t)
                    }
                }
                isVideoTrackFrozen(e) {
                    if (!u.a.supportsVideoMuteOnConnInterrupted()) return !1;
                    const t = e.getId(),
                        n = e.hasAnyVideoTrackWebRTCMuted(),
                        i = this.rtcMutedTimestamp[t],
                        s = this._getVideoFrozenTimeout(t);
                    return n && "number" == typeof i && Date.now() - i >= s
                }
                refreshConnectionStatusForAll() {
                    const e = this.conference.getParticipants();
                    for (const t of e) this.figureOutConnectionStatus(t.getId())
                }
                figureOutConnectionStatus(e) {
                    const t = this.conference.getParticipantById(e);
                    if (!t) return void m.debug("figure out conn status - no participant for: " + e);
                    const n = this.conference.isP2PActive(),
                        i = this._isRestoringTimedout(e),
                        s = 0 === this.conference.getLastN(),
                        r = t.isVideoMuted() || s,
                        a = this.isVideoTrackFrozen(t),
                        c = this.rtc.isInLastN(e);
                    let d = this.connStatusFromJvb[e];
                    "boolean" != typeof d && (d = !0);
                    const u = n ? g._getNewStateForP2PMode(r, a) : g._getNewStateForJvbMode(d, c, i, r, a);
                    u !== f.RESTORING && this._clearRestoringTimer(e), m.debug(`Figure out conn status for ${e}, is video muted: ${r} is active(jvb): ${d} video track frozen: ${a} p2p mode: ${n} is in last N: ${c} currentStatus => newStatus: ${t.getConnectionStatus()} => ${u}`);
                    const l = this.connectionStatusMap[e] || {};
                    if (!("p2p" in l) || !("connectionStatus" in l) || l.p2p !== n || l.connectionStatus !== u) {
                        const i = Date.now();
                        if (this.maybeSendParticipantConnectionStatusEvent(e, i), this.connectionStatusMap[e] = h({}, l, {
                                connectionStatus: u,
                                p2p: n,
                                startedMs: i
                            }), !("videoType" in this.connectionStatusMap[e])) {
                            const n = t.getTracksByMediaType(o.c);
                            Array.isArray(n) && 0 !== n.length && (this.connectionStatusMap[e].videoType = n[0].videoType)
                        }
                    }
                    this._changeConnectionStatus(t, u)
                }
                maybeSendParticipantConnectionStatusEvent(e, t) {
                    const n = this.connectionStatusMap[e];
                    n && "startedMs" in n && "videoType" in n && "connectionStatus" in n && "p2p" in n && (n.value = t - n.startedMs, l.a.sendAnalytics(Object(d.J)(n)))
                }
                _onLastNChanged(e = [], t = []) {
                    const n = Date.now();
                    m.debug(`LastN endpoints changed leaving=${e}, entering=${t} at ${n}`), u.a.supportsVideoMuteOnConnInterrupted() || this.refreshConnectionStatusForAll();
                    for (const t of e) this.enteredLastNTimestamp.delete(t), this._clearRestoringTimer(t), u.a.supportsVideoMuteOnConnInterrupted() && this.figureOutConnectionStatus(t);
                    for (const e of t) this.enteredLastNTimestamp.set(e, n), u.a.supportsVideoMuteOnConnInterrupted() && this.figureOutConnectionStatus(e)
                }
                _clearRestoringTimer(e) {
                    const t = this.restoringTimers.get(e);
                    t && (clearTimeout(t), this.restoringTimers.delete(e))
                }
                _isRestoringTimedout(e) {
                    const t = this.enteredLastNTimestamp.get(e);
                    if (t && Date.now() - t >= 1e4) return !0;
                    return this.restoringTimers.get(e) || this.restoringTimers.set(e, setTimeout(() => this.figureOutConnectionStatus(e), 1e4)), !1
                }
                onUserLeft(e) {
                    this.maybeSendParticipantConnectionStatusEvent(e, Date.now()), delete this.connectionStatusMap[e]
                }
                onTrackRtcMuted(e) {
                    const t = e.getParticipantId(),
                        n = this.conference.getParticipantById(t);
                    if (m.debug("Detector track RTC muted: " + t, Date.now()), n) {
                        if (this.rtcMutedTimestamp[t] = Date.now(), !n.isVideoMuted()) {
                            this.clearTimeout(t);
                            const e = this._getVideoFrozenTimeout(t);
                            this.trackTimers[t] = window.setTimeout(() => {
                                m.debug(`Set RTC mute timeout for: ${t}                     of ${e} ms`), this.clearTimeout(t), this.figureOutConnectionStatus(t)
                            }, e)
                        }
                    } else m.error("No participant for id: " + t)
                }
                onTrackRtcUnmuted(e) {
                    const t = e.getParticipantId();
                    m.debug("Detector track RTC unmuted: " + t, Date.now()), this.clearTimeout(t), this.clearRtcMutedTimestamp(t), this.figureOutConnectionStatus(t)
                }
                onSignallingMuteChanged(e) {
                    const t = e.getParticipantId();
                    m.debug("Detector on track signalling mute changed: " + t, e.isMuted()), this.figureOutConnectionStatus(t)
                }
                onTrackVideoTypeChanged(e, t) {
                    const n = e.getParticipantId(),
                        i = Date.now();
                    this.maybeSendParticipantConnectionStatusEvent(n, i), this.connectionStatusMap[n] = h({}, this.connectionStatusMap[n] || {}, {
                        videoType: t,
                        startedMs: i
                    })
                }
            }
        }).call(this, "modules/connectivity/ParticipantConnectionStatus.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return r
            }));
            var i = n(5),
                s = n(22);
            const r = "NETWORK_INFO_CHANGED",
                o = Object(i.getLogger)(e);
            class a extends s.a {
                constructor() {
                    super(), this._current = {
                        isOnline: !0
                    }
                }
                updateNetworkInfo({
                    isOnline: e
                }) {
                    o.debug("updateNetworkInfo", {
                        isOnline: e
                    }), this._current = {
                        isOnline: !0 === e
                    }, this.eventEmitter.emit(r, this._current)
                }
                isOnline() {
                    return !0 === this._current.isOnline
                }
            }
            const c = new a;
            t.b = c
        }).call(this, "modules/connectivity/NetworkInfo.js")
    }, function(e, t, n) {
        "use strict";
        t.a = {
            getFocusRecordingUpdate(e) {
                const t = e && e.getElementsByTagName("jibri-recording-status")[0];
                if (t) return {
                    error: t.getAttribute("failure_reason"),
                    initiator: t.getAttribute("initiator"),
                    recordingMode: t.getAttribute("recording_mode"),
                    sessionID: t.getAttribute("session_id"),
                    status: t.getAttribute("status")
                }
            },
            getHiddenDomainUpdate(e) {
                const t = e.getElementsByTagName("live-stream-view-url")[0],
                    n = t && t.textContent,
                    i = e.getElementsByTagName("mode")[0],
                    s = i && i.textContent && i.textContent.toLowerCase(),
                    r = e.getElementsByTagName("session_id")[0];
                return {
                    liveStreamViewURL: n,
                    mode: s,
                    sessionID: r && r.textContent
                }
            },
            getSessionIdFromIq(e) {
                const t = e && e.getElementsByTagName("jibri")[0];
                return t && t.getAttribute("session_id")
            },
            getSessionId(e) {
                const t = e.getElementsByTagName("session_id")[0];
                return t && t.textContent
            },
            isFromFocus: e => e.getAttribute("from").includes("focus")
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return E
            }));
            var i = n(58),
                s = n.n(i),
                r = n(5),
                o = n(33),
                a = n.n(o),
                c = n(79),
                d = n(1),
                u = n(46),
                l = n(22),
                h = n(25);
            const p = Object(r.getLogger)(e),
                m = "error",
                f = "key-info",
                g = "key-info-ack",
                _ = "session-ack",
                v = "session-init",
                S = Symbol("OlmData"),
                y = {
                    OLM_ID_KEY_READY: "olm.id_key_ready",
                    PARTICIPANT_E2EE_CHANNEL_READY: "olm.participant_e2ee_channel_ready",
                    PARTICIPANT_KEY_UPDATED: "olm.partitipant_key_updated"
                };
            class E extends l.a {
                constructor(e) {
                    super(), this._conf = e, this._init = new u.a, this._key = void 0, this._keyIndex = -1, this._reqs = new Map, this._sessionInitialization = void 0, E.isSupported() ? (this._bootstrapOlm(), this._conf.on(d.ENDPOINT_MESSAGE_RECEIVED, this._onEndpointMessageReceived.bind(this)), this._conf.on(d.CONFERENCE_LEFT, this._onConferenceLeft.bind(this)), this._conf.on(d.USER_LEFT, this._onParticipantLeft.bind(this)), this._conf.on(d.PARTICIPANT_PROPERTY_CHANGED, this._onParticipantPropertyChanged.bind(this))) : this._init.reject(new Error("Olm not supported"))
                }
                async initSessions() {
                    if (this._sessionInitialization) throw new Error("OlmAdapter initSessions called multiple times"); {
                        this._sessionInitialization = new u.a, await this._init;
                        const e = [],
                            t = this._conf.myUserId();
                        for (const n of this._conf.getParticipants()) {
                            (await n.getFeatures()).has(h.b) && t < n.getId() && e.push(this._sendSessionInit(n))
                        }
                        await Promise.allSettled(e), this._sessionInitialization.resolve(), this._sessionInitialization = void 0
                    }
                }
                static isSupported() {
                    return void 0 !== window.Olm
                }
                async updateKey(e) {
                    this._key = e, this._keyIndex++;
                    const t = [];
                    for (const e of this._conf.getParticipants()) {
                        const n = e.getId(),
                            i = this._getParticipantOlmData(e);
                        if (!i.session) {
                            p.warn(`Tried to send key to participant ${n} but we have no session`);
                            continue
                        }
                        const s = Object(c.a)(),
                            r = {
                                [h.d]: "olm",
                                olm: {
                                    type: f,
                                    data: {
                                        ciphertext: this._encryptKeyInfo(i.session),
                                        uuid: s
                                    }
                                }
                            },
                            o = new u.a;
                        o.setRejectTimeout(5e3), o.catch(() => {
                            this._reqs.delete(s)
                        }), this._reqs.set(s, o), t.push(o), this._sendMessage(r, n)
                    }
                    return await Promise.allSettled(t), this._keyIndex
                }
                updateCurrentKey(e) {
                    return this._key = e, this._keyIndex
                }
                clearParticipantSession(e) {
                    const t = this._getParticipantOlmData(e);
                    t.session && (t.session.free(), t.session = void 0)
                }
                clearAllParticipantsSessions() {
                    for (const e of this._conf.getParticipants()) this.clearParticipantSession(e)
                }
                async _bootstrapOlm() {
                    p.debug("Initializing Olm...");
                    try {
                        await Olm.init(), this._olmAccount = new Olm.Account, this._olmAccount.create();
                        const e = JSON.parse(this._olmAccount.identity_keys());
                        this._idKey = e.curve25519, p.debug(`Olm ${Olm.get_library_version().join(".")} initialized`), this._init.resolve(), this.eventEmitter.emit(y.OLM_ID_KEY_READY, this._idKey)
                    } catch (e) {
                        p.error("Failed to initialize Olm", e), this._init.reject(e)
                    }
                }
                _encryptKeyInfo(e) {
                    const t = {};
                    return void 0 !== this._key && (t.key = !!this._key && s.a.fromByteArray(this._key), t.keyIndex = this._keyIndex), e.encrypt(JSON.stringify(t))
                }
                _getParticipantOlmData(e) {
                    return e[S] = e[S] || {}, e[S]
                }
                async _onConferenceLeft() {
                    p.debug("Conference left"), await this._init;
                    for (const e of this._conf.getParticipants()) this._onParticipantLeft(e.getId(), e);
                    this._olmAccount && (this._olmAccount.free(), this._olmAccount = void 0)
                }
                async _onEndpointMessageReceived(e, t) {
                    if ("olm" !== t[h.d]) return;
                    if (!t.olm) return void p.warn("Incorrectly formatted message");
                    await this._init;
                    const n = t.olm,
                        i = e.getId(),
                        r = this._getParticipantOlmData(e);
                    switch (n.type) {
                        case v:
                            if (r.session) p.warn(`Participant ${i} already has a session`), this._sendError(e, "Session already established");
                            else {
                                const e = new Olm.Session;
                                e.create_outbound(this._olmAccount, n.data.idKey, n.data.otKey), r.session = e;
                                const t = {
                                    [h.d]: "olm",
                                    olm: {
                                        type: _,
                                        data: {
                                            ciphertext: this._encryptKeyInfo(e),
                                            uuid: n.data.uuid
                                        }
                                    }
                                };
                                this._sendMessage(t, i), this.eventEmitter.emit(y.PARTICIPANT_E2EE_CHANNEL_READY, i)
                            }
                            break;
                        case _:
                            if (r.session) p.warn(`Participant ${i} already has a session`), this._sendError(e, "No session found");
                            else if (n.data.uuid === r.pendingSessionUuid) {
                                const {
                                    ciphertext: e
                                } = n.data, t = this._reqs.get(n.data.uuid), o = new Olm.Session;
                                o.create_inbound(this._olmAccount, e.body), this._olmAccount.remove_one_time_keys(o);
                                const a = o.decrypt(e.type, e.body);
                                r.session = o, r.pendingSessionUuid = void 0, this.eventEmitter.emit(y.PARTICIPANT_E2EE_CHANNEL_READY, i), this._reqs.delete(n.data.uuid), t.resolve();
                                const c = b(a);
                                if (c.key) {
                                    const e = s.a.toByteArray(c.key),
                                        t = c.keyIndex;
                                    r.lastKey = e, this.eventEmitter.emit(y.PARTICIPANT_KEY_UPDATED, i, e, t)
                                }
                            } else p.warn("Received ACK with the wrong UUID"), this._sendError(e, "Invalid UUID");
                            break;
                        case m:
                            p.error(n.data.error);
                            break;
                        case f:
                            if (r.session) {
                                const {
                                    ciphertext: e
                                } = n.data, t = b(r.session.decrypt(e.type, e.body));
                                if (void 0 !== t.key && void 0 !== t.keyIndex) {
                                    const e = !!t.key && s.a.toByteArray(t.key),
                                        o = t.keyIndex;
                                    a()(r.lastKey, e) || (r.lastKey = e, this.eventEmitter.emit(y.PARTICIPANT_KEY_UPDATED, i, e, o));
                                    const c = {
                                        [h.d]: "olm",
                                        olm: {
                                            type: g,
                                            data: {
                                                ciphertext: this._encryptKeyInfo(r.session),
                                                uuid: n.data.uuid
                                            }
                                        }
                                    };
                                    this._sendMessage(c, i)
                                }
                            } else p.debug(`Received key info message from ${i} but we have no session for them!`), this._sendError(e, "No session found while processing key-info");
                            break;
                        case g:
                            if (r.session) {
                                const {
                                    ciphertext: e
                                } = n.data, t = b(r.session.decrypt(e.type, e.body));
                                if (void 0 !== t.key && void 0 !== t.keyIndex) {
                                    const e = !!t.key && s.a.toByteArray(t.key),
                                        n = t.keyIndex;
                                    a()(r.lastKey, e) || (r.lastKey = e, this.eventEmitter.emit(y.PARTICIPANT_KEY_UPDATED, i, e, n))
                                }
                                const o = this._reqs.get(n.data.uuid);
                                this._reqs.delete(n.data.uuid), o.resolve()
                            } else p.debug(`Received key info ack message from ${i} but we have no session for them!`), this._sendError(e, "No session found while processing key-info-ack")
                    }
                }
                _onParticipantLeft(e, t) {
                    p.debug(`Participant ${e} left`), this.clearParticipantSession(t)
                }
                async _onParticipantPropertyChanged(e, t, n, i) {
                    switch (t) {
                        case "e2ee.enabled":
                            if (i && this._conf.isE2EEEnabled()) {
                                const t = this._conf.myUserId(),
                                    n = e.getId();
                                if ((await e.getFeatures()).has(h.b) && t < n) {
                                    this._sessionInitialization && await this._sessionInitialization, await this._sendSessionInit(e);
                                    const t = this._getParticipantOlmData(e),
                                        i = Object(c.a)(),
                                        s = {
                                            [h.d]: "olm",
                                            olm: {
                                                type: f,
                                                data: {
                                                    ciphertext: this._encryptKeyInfo(t.session),
                                                    uuid: i
                                                }
                                            }
                                        };
                                    this._sendMessage(s, n)
                                }
                            }
                    }
                }
                _sendError(e, t) {
                    const n = e.getId(),
                        i = {
                            [h.d]: "olm",
                            olm: {
                                type: m,
                                data: {
                                    error: t
                                }
                            }
                        };
                    this._sendMessage(i, n)
                }
                _sendMessage(e, t) {
                    this._conf.sendMessage(e, t)
                }
                _sendSessionInit(e) {
                    const t = e.getId(),
                        n = this._getParticipantOlmData(e);
                    if (n.session) return p.warn(`Tried to send session-init to ${t} but we already have a session`), Promise.reject();
                    if (void 0 !== n.pendingSessionUuid) return p.warn(`Tried to send session-init to ${t} but we already have a pending session`), Promise.reject();
                    this._olmAccount.generate_one_time_keys(1);
                    const i = JSON.parse(this._olmAccount.one_time_keys()),
                        s = Object.values(i.curve25519)[0];
                    if (!s) return Promise.reject(new Error("No one-time-keys generated"));
                    this._olmAccount.mark_keys_as_published();
                    const r = Object(c.a)(),
                        o = {
                            [h.d]: "olm",
                            olm: {
                                type: v,
                                data: {
                                    idKey: this._idKey,
                                    otKey: s,
                                    uuid: r
                                }
                            }
                        },
                        a = new u.a;
                    return a.setRejectTimeout(5e3), a.catch(() => {
                        this._reqs.delete(r), n.pendingSessionUuid = void 0
                    }), this._reqs.set(r, a), this._sendMessage(o, t), n.pendingSessionUuid = r, a
                }
            }

            function b(e) {
                try {
                    return JSON.parse(e)
                } catch (e) {
                    return {}
                }
            }
            E.events = y
        }).call(this, "modules/e2ee/OlmAdapter.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return f
            }));
            var i = n(5),
                s = n(74),
                r = n.n(s),
                o = n(1),
                a = n(7),
                c = n.n(a),
                d = n(3),
                u = n(46),
                l = n(95),
                h = n(54),
                p = n(75);
            const m = Object(i.getLogger)(e);
            class f {
                constructor(e) {
                    this.conference = e, this._conferenceJoined = !1, this._enabled = !1, this._key = void 0, this._enabling = void 0, this._e2eeCtx = new l.a, this._olmAdapter = new h.a(e), this._ratchetKey = r()(this._ratchetKeyImpl, 5e3), this._rotateKey = r()(this._rotateKeyImpl, 5e3), this.conference.on(o.CONFERENCE_JOINED, () => {
                        this._conferenceJoined = !0
                    }), this.conference.on(o.PARTICIPANT_PROPERTY_CHANGED, this._onParticipantPropertyChanged.bind(this)), this.conference.on(o.USER_JOINED, this._onParticipantJoined.bind(this)), this.conference.on(o.USER_LEFT, this._onParticipantLeft.bind(this)), this.conference.on(o._MEDIA_SESSION_STARTED, this._onMediaSessionStarted.bind(this)), this.conference.on(o.TRACK_ADDED, e => e.isLocal() && this._onLocalTrackAdded(e)), this.conference.rtc.on(c.a.REMOTE_TRACK_ADDED, (e, t) => this._setupReceiverE2EEForTrack(t, e)), this.conference.on(o.TRACK_MUTE_CHANGED, this._trackMuteChanged.bind(this)), this._olmAdapter.on(h.a.events.OLM_ID_KEY_READY, this._onOlmIdKeyReady.bind(this)), this._olmAdapter.on(h.a.events.PARTICIPANT_E2EE_CHANNEL_READY, this._onParticipantE2EEChannelReady.bind(this)), this._olmAdapter.on(h.a.events.PARTICIPANT_KEY_UPDATED, this._onParticipantKeyUpdated.bind(this))
                }
                static isSupported(e) {
                    return d.a.supportsInsertableStreams() && h.a.isSupported() && !(e.testing && e.testing.disableE2EE)
                }
                isEnabled() {
                    return this._enabled
                }
                async setEnabled(e) {
                    if (e === this._enabled) return;
                    if (this._enabling && await this._enabling, this._enabling = new u.a, this._enabled = e, e) await this._olmAdapter.initSessions();
                    else {
                        for (const e of this.conference.getParticipants()) this._e2eeCtx.cleanup(e.getId());
                        this._olmAdapter.clearAllParticipantsSessions()
                    }
                    this.conference.setLocalParticipantProperty("e2ee.enabled", e), this.conference._restartMediaSessions(), this._key = !!e && this._generateKey();
                    const t = await this._olmAdapter.updateKey(this._key);
                    this._e2eeCtx.setKey(this.conference.myUserId(), this._key, t), this._enabling.resolve()
                }
                _generateKey() {
                    return window.crypto.getRandomValues(new Uint8Array(32))
                }
                _onLocalTrackAdded(e) {
                    for (const t of this.conference._getMediaSessions()) this._setupSenderE2EEForTrack(t, e)
                }
                _onMediaSessionStarted(e) {
                    const t = this.conference.getLocalTracks();
                    for (const n of t) this._setupSenderE2EEForTrack(e, n)
                }
                _onOlmIdKeyReady(e) {
                    m.debug("Olm id key ready: " + e), this.conference.setLocalParticipantProperty("e2ee.idKey", e)
                }
                _onParticipantJoined() {
                    this._conferenceJoined && this._enabled && this._ratchetKey()
                }
                _onParticipantLeft(e) {
                    this._e2eeCtx.cleanup(e), this._enabled && this._rotateKey()
                }
                _onParticipantE2EEChannelReady(e) {
                    m.debug(`E2EE channel with participant ${e} is ready`)
                }
                _onParticipantKeyUpdated(e, t, n) {
                    m.debug(`Participant ${e} updated their key`), this._e2eeCtx.setKey(e, t, n)
                }
                async _onParticipantPropertyChanged(e, t, n, i) {
                    switch (t) {
                        case "e2ee.idKey":
                            m.debug(`Participant ${e.getId()} updated their id key: ${i}`);
                            break;
                        case "e2ee.enabled":
                            !i && this._enabled && (this._olmAdapter.clearParticipantSession(e), this._rotateKey())
                    }
                }
                async _ratchetKeyImpl() {
                    m.debug("Ratchetting key");
                    const e = await Object(p.a)(this._key),
                        t = await Object(p.b)(e);
                    this._key = new Uint8Array(t);
                    const n = this._olmAdapter.updateCurrentKey(this._key);
                    this._e2eeCtx.setKey(this.conference.myUserId(), this._key, n)
                }
                async _rotateKeyImpl() {
                    m.debug("Rotating key"), this._key = this._generateKey();
                    const e = await this._olmAdapter.updateKey(this._key);
                    this._e2eeCtx.setKey(this.conference.myUserId(), this._key, e)
                }
                _setupReceiverE2EEForTrack(e, t) {
                    if (!this._enabled) return;
                    const n = e.findReceiverForTrack(t.track);
                    n ? this._e2eeCtx.handleReceiver(n, t.getType(), t.getParticipantId()) : m.warn(`Could not handle E2EE for ${t}: receiver not found in: ${e}`)
                }
                _setupSenderE2EEForTrack(e, t) {
                    if (!this._enabled) return;
                    const n = e.peerconnection,
                        i = n && n.findSenderForTrack(t.track);
                    i ? this._e2eeCtx.handleSender(i, t.getType(), t.getParticipantId()) : m.warn(`Could not handle E2EE for ${t}: sender not found in ${n}`)
                }
                _trackMuteChanged(e) {
                    if (d.a.doesVideoMuteByStreamRemove() && e.isLocal() && e.isVideoTrack() && !e.isMuted())
                        for (const t of this.conference._getMediaSessions()) this._setupSenderE2EEForTrack(t, e)
                }
            }
        }).call(this, "modules/e2ee/E2EEncryption.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return I
            }));
            var i = n(5),
                s = n(2),
                r = n(20),
                o = n(10),
                a = n.n(o),
                c = n(8),
                d = n(0),
                u = n.n(d),
                l = n(39),
                h = n(18),
                p = n(59),
                m = n(9),
                f = n(6),
                g = n(107),
                _ = n(12),
                v = n.n(_),
                S = n(109),
                y = n(3),
                E = n(110),
                b = n(34),
                C = n(64),
                T = n(111),
                R = n(41);
            const A = Object(i.getLogger)(e);
            class I extends E.a {
                static parseVideoSenders(e) {
                    const t = e.find('>content[name="video"]');
                    if (t.length) {
                        const e = t[0].getAttribute("senders");
                        if ("both" === e || "initiator" === e || "responder" === e || "none" === e) return e
                    }
                    return null
                }
                static parseMaxFrameHeight(e) {
                    const t = e.find('>content[name="video"]>max-frame-height');
                    return t.length ? Number(t.text()) : null
                }
                constructor(e, t, n, i, s, r, o, a) {
                    super(e, t, n, i, s, r, a), this._bridgeSessionId = null, this._cachedOldLocalSdp = void 0, this._cachedNewLocalSdp = void 0, this._iceCheckingStartedTimestamp = null, this._gatheringStartedTimestamp = null, this.localRecvMaxFrameHeight = void 0, this._localVideoActive = !0, this._remoteVideoActive = !0, this._gatheringReported = !1, this.lasticecandidate = !1, this.closed = !1, this.isP2P = o, this.remoteRecvMaxFrameHeight = void 0, this.signalingLayer = new T.a, this.modificationQueue = new g.a, this.wasConnected = !1, this.establishmentDuration = void 0, this._xmppListeners = [], this._xmppListeners.push(i.addEventListener(R.a.Events.CONN_STATUS_CHANGED, this.onXmppStatusChanged.bind(this))), this._removeSenderVideoConstraintsChangeListener = void 0
                }
                _assertNotEnded() {
                    return this.state !== b.b
                }
                doInitialize(e) {
                    var t, n, i;
                    this.failICE = Boolean(e.failICE), this.lasticecandidate = !1, this.options = e, this.isReconnect = !1, this.wasstable = !1, this.webrtcIceUdpDisable = Boolean(e.webrtcIceUdpDisable), this.webrtcIceTcpDisable = Boolean(e.webrtcIceTcpDisable);
                    const s = {
                        disableRtx: e.disableRtx
                    };
                    if (e.gatherStats && (s.maxstats = 300), s.capScreenshareBitrate = !1, s.enableInsertableStreams = e.enableInsertableStreams, s.videoQuality = e.videoQuality, s.forceTurnRelay = e.forceTurnRelay, s.audioQuality = e.audioQuality, s.usesUnifiedPlan = this.usesUnifiedPlan = y.a.supportsUnifiedPlan() && (y.a.isFirefox() || y.a.isWebKitBased() || (y.a.isChromiumBased() && this.isP2P ? null === (t = null === (n = e.p2p) || void 0 === n ? void 0 : n.enableUnifiedOnChrome) || void 0 === t || t : null === (i = e.enableUnifiedOnChrome) || void 0 === i || i)), this.isP2P) {
                        s.disableSimulcast = !0;
                        const t = this._abtestSuspendVideoEnabled(e);
                        void 0 !== t && (s.abtestSuspendVideo = t)
                    } else {
                        var o, a;
                        s.disableSimulcast = e.disableSimulcast || e.preferH264 && !e.disableH264 || e.videoQuality && e.videoQuality.preferredCodec === r.H264, s.capScreenshareBitrate = s.disableSimulcast || !("number" == typeof(null === (o = e.desktopSharingFrameRate) || void 0 === o ? void 0 : o.max) && (null === (a = e.desktopSharingFrameRate) || void 0 === a ? void 0 : a.max) > l.a), f.a.analytics.addPermanentProperties({
                            capScreenshareBitrate: s.capScreenshareBitrate
                        })
                    }
                    e.startSilent && (s.startSilent = !0), this.peerconnection = this.rtc.createPeerConnection(this.signalingLayer, this.iceConfig, this.isP2P, s), this.peerconnection.onicecandidate = e => {
                        if (!e) return;
                        const t = e.candidate,
                            n = window.performance.now();
                        if (t) {
                            null === this._gatheringStartedTimestamp && (this._gatheringStartedTimestamp = n);
                            let e = t.protocol;
                            if ("string" == typeof e)
                                if (e = e.toLowerCase(), "tcp" === e || "ssltcp" === e) {
                                    if (this.webrtcIceTcpDisable) return
                                } else if ("udp" === e && this.webrtcIceUdpDisable) return
                        } else this._gatheringReported || (f.a.sendAnalytics(c.o, {
                            phase: "gathering",
                            value: n - this._gatheringStartedTimestamp,
                            p2p: this.isP2P,
                            initiator: this.isInitiator
                        }), this._gatheringReported = !0);
                        this.sendIceCandidate(t)
                    }, this.peerconnection.onsignalingstatechange = () => {
                        "stable" === this.peerconnection.signalingState ? this.wasstable = !0 : "closed" !== this.peerconnection.signalingState && "closed" !== this.peerconnection.connectionState || this.room.eventEmitter.emit(u.a.SUSPEND_DETECTED, this)
                    }, this.peerconnection.oniceconnectionstatechange = () => {
                        const e = window.performance.now();
                        let t = !1;
                        switch (this.isP2P || (this.room.connectionTimes["ice.state." + this.peerconnection.iceConnectionState] = e), A.log(`(TIME) ICE ${this.peerconnection.iceConnectionState} ${this.isP2P?"P2P":"JVB"}:\t`, e), f.a.sendAnalytics(c.q, {
                                p2p: this.isP2P,
                                state: this.peerconnection.iceConnectionState,
                                signaling_state: this.peerconnection.signalingState,
                                reconnect: this.isReconnect,
                                value: e
                            }), this.room.eventEmitter.emit(u.a.ICE_CONNECTION_STATE_CHANGED, this, this.peerconnection.iceConnectionState), this.peerconnection.iceConnectionState) {
                            case "checking":
                                this._iceCheckingStartedTimestamp = e;
                                break;
                            case "connected":
                                if ("stable" === this.peerconnection.signalingState) {
                                    t = !0;
                                    const e = !this.options.enableIceRestart && this.room.supportsRestartByTerminate();
                                    (this.isReconnect || e) && this.room.eventEmitter.emit(u.a.CONNECTION_RESTORED, this)
                                }
                                if (!this.wasConnected && (this.wasstable || t || this.usesUnifiedPlan && this.isInitiator && y.a.isChromiumBased())) {
                                    f.a.sendAnalytics(c.o, {
                                        phase: "checking",
                                        value: e - this._iceCheckingStartedTimestamp,
                                        p2p: this.isP2P,
                                        initiator: this.isInitiator
                                    });
                                    const t = Math.min(this._iceCheckingStartedTimestamp, this._gatheringStartedTimestamp);
                                    this.establishmentDuration = e - t, f.a.sendAnalytics(c.o, {
                                        phase: "establishment",
                                        value: this.establishmentDuration,
                                        p2p: this.isP2P,
                                        initiator: this.isInitiator
                                    }), this.wasConnected = !0, this.room.eventEmitter.emit(u.a.CONNECTION_ESTABLISHED, this)
                                }
                                this.isReconnect = !1;
                                break;
                            case "disconnected":
                                this.isReconnect = !0, this.wasstable && this.room.eventEmitter.emit(u.a.CONNECTION_INTERRUPTED, this);
                                break;
                            case "failed":
                                this.room.eventEmitter.emit(u.a.CONNECTION_ICE_FAILED, this)
                        }
                    }, this.peerconnection.onnegotiationneeded = () => {
                        const e = this.peerconnection.signalingState,
                            t = this.peerconnection.remoteDescription;
                        if (this.usesUnifiedPlan && "stable" === e && t && "string" == typeof t.sdp) {
                            A.debug(`${this} onnegotiationneeded fired on ${this.peerconnection} in state: ${e}`);
                            const t = e => {
                                const t = new h.a(this.peerconnection.localDescription.sdp);
                                this._renegotiate().then(() => {
                                    const n = new h.a(this.peerconnection.localDescription.sdp);
                                    this.notifyMySSRCUpdate(t, n), e()
                                }, e)
                            };
                            this.modificationQueue.push(t, e => {
                                e ? A.error(this + " onnegotiationneeded error", e) : A.debug(this + " onnegotiationneeded executed - OK")
                            })
                        }
                    }, this.signalingLayer.setChatRoom(this.room)
                }
                getRemoteRecvMaxFrameHeight() {
                    if (this.isP2P) return this.remoteRecvMaxFrameHeight
                }
                sendIceCandidate(e) {
                    const t = new h.a(this.peerconnection.localDescription.sdp);
                    if (e && e.candidate.length && !this.lasticecandidate) {
                        const n = m.a.iceparams(t.media[e.sdpMLineIndex], t.session),
                            i = m.a.candidateToJingle(e.candidate);
                        if (!n || !i) {
                            const e = "failed to get ice && jcand";
                            return v.a.callErrorHandler(new Error(e)), void A.error(e)
                        }
                        n.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", this.usedrip ? (0 === this.dripContainer.length && setTimeout(() => {
                            0 !== this.dripContainer.length && (this.sendIceCandidates(this.dripContainer), this.dripContainer = [])
                        }, 150), this.dripContainer.push(e)) : this.sendIceCandidates([e])
                    } else A.log(this + " sendIceCandidate: last candidate"), this.lasticecandidate = !0
                }
                sendIceCandidates(e) {
                    if (!this._assertNotEnded("sendIceCandidates")) return;
                    A.log(`${this} sendIceCandidates ${JSON.stringify(e)}`);
                    const t = Object(s.$iq)({
                            to: this.remoteJid,
                            type: "set"
                        }).c("jingle", {
                            xmlns: "urn:xmpp:jingle:1",
                            action: "transport-info",
                            initiator: this.initiatorJid,
                            sid: this.sid
                        }),
                        n = new h.a(this.peerconnection.localDescription.sdp);
                    for (let i = 0; i < n.media.length; i++) {
                        const s = e.filter(e => e.sdpMLineIndex === i),
                            r = m.a.parseMLine(n.media[i].split("\r\n")[0]);
                        if (s.length > 0) {
                            const e = m.a.iceparams(n.media[i], n.session);
                            e.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.c("content", {
                                creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
                                name: s[0].sdpMid ? s[0].sdpMid : r.media
                            }).c("transport", e);
                            for (let e = 0; e < s.length; e++) {
                                const n = m.a.candidateToJingle(s[e].candidate);
                                this.failICE && (n.ip = "1.1.1.1"), t.c("candidate", n).up()
                            }
                            const o = m.a.findLine(n.media[i], "a=fingerprint:", n.session);
                            if (o) {
                                const e = m.a.parseFingerprint(o);
                                e.required = !0, t.c("fingerprint", {
                                    xmlns: "urn:xmpp:jingle:apps:dtls:0"
                                }).t(e.fingerprint), delete e.fingerprint, t.attrs(e), t.up()
                            }
                            t.up(), t.up()
                        }
                    }
                    this.connection.sendIQ(t, null, this.newJingleErrorHandler(t), 1e4)
                }
                sendIceFailedNotification() {
                    const e = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "session-info",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    }).c("ice-state", {
                        xmlns: "http://jitsi.org/protocol/focus"
                    }).t("failed").up();
                    this._bridgeSessionId && e.c("bridge-session", {
                        xmlns: "http://jitsi.org/protocol/focus",
                        id: this._bridgeSessionId
                    }), this.connection.sendIQ2(e, {
                        timeout: 65
                    }).catch(this.newJingleErrorHandler(e))
                }
                addIceCandidates(e) {
                    if ("closed" === this.peerconnection.signalingState) return void A.warn(this + " Ignored add ICE candidate when in closed state");
                    const t = [];
                    if (e.find(">content>transport>candidate").each((e, n) => {
                            let i = m.a.candidateFromJingle(n);
                            i = i.replace("\r\n", "").replace("a=", "");
                            const s = new RTCIceCandidate({
                                sdpMLineIndex: 0,
                                sdpMid: "",
                                candidate: i
                            });
                            t.push(s)
                        }), !t.length) return void A.error(this + " No ICE candidates to add ?", e[0] && e[0].outerHTML);
                    A.debug(`${this} Queued add (${t.length}) ICE candidates task`), this.modificationQueue.push(e => {
                        for (const e of t) this.peerconnection.addIceCandidate(e).then(() => A.debug(this + " addIceCandidate ok!"), e => A.error(this + " addIceCandidate failed!", e));
                        e(), A.debug(this + " ICE candidates task finished")
                    })
                }
                readSsrcInfo(e) {
                    $(e).find('>description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((e, t) => {
                        const n = Number(t.getAttribute("ssrc"));
                        this.isP2P ? this.signalingLayer.setSSRCOwner(n, s.Strophe.getResourceFromJid(this.remoteJid)) : $(t).find('>ssrc-info[xmlns="http://jitsi.org/jitmeet"]').each((e, t) => {
                            const i = t.getAttribute("owner");
                            i && i.length && (isNaN(n) || n < 0 ? A.warn(`${this} Invalid SSRC ${n} value received for ${i}`) : this.signalingLayer.setSSRCOwner(n, s.Strophe.getResourceFromJid(i)))
                        })
                    })
                }
                generateRecvonlySsrc() {
                    this.peerconnection ? this.peerconnection.generateRecvonlySsrc() : A.error(this + " Unable to generate recvonly SSRC - no peerconnection")
                }
                getConfiguredVideoCodec() {
                    return this.peerconnection.getConfiguredVideoCodec()
                }
                acceptOffer(e, t, n, i) {
                    this.setOfferAnswerCycle(e, () => {
                        this.sendSessionAccept(t, n)
                    }, n, i)
                }
                invite(e = []) {
                    if (!this.isInitiator) throw new Error("Trying to invite from the responder session");
                    A.debug(this + " Queued invite task"), this.modificationQueue.push(t => {
                        const n = [];
                        for (const t of e) n.push(this.peerconnection.addTrack(t, this.isInitiator));
                        Promise.all(n).then(() => this.peerconnection.createOffer(this.mediaConstraints)).then(e => this.peerconnection.setLocalDescription(e)).then(() => {
                            this.sendSessionInitiate(this.peerconnection.localDescription.sdp)
                        }).then(() => t(), e => t(e))
                    }, e => {
                        e ? A.error(this + " invite error", e) : A.debug(this + " invite executed - OK")
                    })
                }
                sendSessionInitiate(e) {
                    let t = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "session-initiate",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    });
                    new h.a(e).toJingle(t, this.isInitiator ? "initiator" : "responder"), t = t.tree(), A.debug(this + " Session-initiate: ", t), this.connection.sendIQ(t, () => {
                        A.info(this + ' Got RESULT for "session-initiate"')
                    }, e => {
                        A.error(this + ' "session-initiate" error', e)
                    }, 1e4)
                }
                setAnswer(e) {
                    if (!this.isInitiator) throw new Error("Trying to set an answer on the responder session");
                    this.setOfferAnswerCycle(e, () => {
                        if (A.info(this + " setAnswer - succeeded"), this.usesUnifiedPlan && y.a.isChromiumBased()) {
                            const e = this.peerconnection.remoteDescription.sdp,
                                t = new RTCSessionDescription({
                                    type: "offer",
                                    sdp: e
                                });
                            this._responderRenegotiate(t)
                        }
                    }, e => {
                        A.error(this + " setAnswer failed: ", e)
                    })
                }
                setOfferAnswerCycle(e, t, n, i = []) {
                    A.debug(this + " Queued setOfferAnswerCycle task"), this.modificationQueue.push(t => {
                        const n = [];
                        for (const e of i) n.push(this.peerconnection.addTrack(e, this.isInitiator));
                        const s = this._processNewJingleOfferIq(e),
                            r = this.peerconnection.localDescription.sdp,
                            o = $(e).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("id");
                        o !== this._bridgeSessionId && (this._bridgeSessionId = o), Promise.all(n).then(() => this._renegotiate(s.raw)).then(() => {
                            if (this.state === b.c && (this.state = b.a, !this.isP2P || this._localVideoActive && !this.localRecvMaxFrameHeight || this.sendContentModify()), r) {
                                const e = new h.a(this.peerconnection.localDescription.sdp);
                                this.notifyMySSRCUpdate(new h.a(r), e)
                            }
                        }).then(() => t(), e => t(e))
                    }, e => {
                        e ? (A.error(`${this} setOfferAnswerCycle task failed: ${e}`), n(e)) : (A.debug(this + " setOfferAnswerCycle task done"), t())
                    })
                }
                setVideoCodecs(e = null, t = null) {
                    const n = this.peerconnection.getConfiguredVideoCodec();
                    if (this._assertNotEnded() && e !== n) {
                        A.info(`${this} Switching video codec from ${n} to ${e}`), this.peerconnection.setVideoCodecs(e, t);
                        const i = e => {
                            this._renegotiate().then(() => (A.debug(this + " setVideoCodecs task is done"), e()), t => (A.error(`${this} setVideoCodecs task failed: ${t}`), e(t)))
                        };
                        A.debug(this + " Queued setVideoCodecs task"), this.modificationQueue.push(i)
                    }
                }
                replaceTransport(e, t, n) {
                    if (this.options.enableForcedReload) {
                        const e = new h.a(this.peerconnection.localDescription.sdp);
                        return this.sendTransportAccept(e, t, n), void this.room.eventEmitter.emit(u.a.CONNECTION_RESTARTED, this)
                    }
                    this.room.eventEmitter.emit(u.a.ICE_RESTARTING, this);
                    const i = e.clone();
                    e.find(">content[name='data']").attr("senders", "rejected"), e.find(">content>description>source").remove(), e.find(">content>description>ssrc-group").remove();
                    const s = e.find(">content>transport>fingerprint");
                    s.attr("hash", "sha-1"), s.text("00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00"), this.setOfferAnswerCycle(e, () => {
                        this.setOfferAnswerCycle(i, () => {
                            const e = new h.a(this.peerconnection.localDescription.sdp);
                            this.sendTransportAccept(e, t, n), this.room.eventEmitter.emit(u.a.ICE_RESTART_SUCCESS, this, i)
                        }, n)
                    }, n)
                }
                sendSessionAccept(e, t) {
                    const n = new h.a(this.peerconnection.localDescription.sdp);
                    let i = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "session-accept",
                        initiator: this.initiatorJid,
                        responder: this.responderJid,
                        sid: this.sid
                    });
                    this.webrtcIceTcpDisable && (n.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (n.removeUdpCandidates = !0), this.failICE && (n.failICE = !0), n.toJingle(i, this.initiatorJid === this.localJid ? "initiator" : "responder"), i = i.tree(), A.debug(this + " Sending session-accept", i), this.connection.sendIQ(i, e, this.newJingleErrorHandler(i, e => {
                        t(e), this.room.eventEmitter.emit(u.a.SESSION_ACCEPT_TIMEOUT, this)
                    }), 1e4)
                }
                sendContentModify() {
                    const e = this.localRecvMaxFrameHeight,
                        t = this._localVideoActive ? "both" : "none";
                    let n = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "content-modify",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    }).c("content", {
                        name: "video",
                        senders: t
                    });
                    void 0 !== e && (n = n.c("max-frame-height", {
                        xmlns: "http://jitsi.org/jitmeet/video"
                    }).t(e)), A.info(`${this} sending content-modify, video senders: ${t}, max frame height: ${e}`), this.connection.sendIQ(n, null, this.newJingleErrorHandler(n), 1e4)
                }
                setReceiverVideoConstraint(e) {
                    A.info(`${this} setReceiverVideoConstraint - max frame height: ${e}`), this.localRecvMaxFrameHeight = e, this.isP2P ? this.state === b.a && this.sendContentModify() : this.rtc.setReceiverVideoConstraint(e)
                }
                sendTransportAccept(e, t, n) {
                    let i = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "transport-accept",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    });
                    e.media.forEach((t, n) => {
                        const s = m.a.parseMLine(t.split("\r\n")[0]);
                        i.c("content", {
                            creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
                            name: s.media
                        }), e.transportToJingle(n, i), i.up()
                    }), i = i.tree(), A.info(this + " Sending transport-accept: ", i), this.connection.sendIQ(i, t, this.newJingleErrorHandler(i, n), 1e4)
                }
                sendTransportReject(e, t) {
                    let n = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "transport-reject",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    });
                    n = n.tree(), A.info(this + " Sending 'transport-reject'", n), this.connection.sendIQ(n, e, this.newJingleErrorHandler(n, t), 1e4)
                }
                setSenderMaxBitrates() {
                    return this._assertNotEnded() ? this.peerconnection.setMaxBitRate() : Promise.resolve()
                }
                setSenderVideoConstraint(e) {
                    if (this._assertNotEnded()) {
                        if (A.info(`${this} setSenderVideoConstraint: ${e}`), !this.isP2P && y.a.isReactNative() && void 0 !== e) {
                            const t = e > 0;
                            return this.setMediaTransferActive(!0, t)
                        }
                        return this.peerconnection.setSenderVideoConstraint(e)
                    }
                    return Promise.resolve()
                }
                setSenderVideoDegradationPreference() {
                    return this._assertNotEnded() ? this.peerconnection.setSenderVideoDegradationPreference() : Promise.resolve()
                }
                terminate(e, t, n) {
                    if (this.state !== b.b) {
                        if (!n || Boolean(n.sendSessionTerminate)) {
                            let i = Object(s.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "session-terminate",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            }).c("reason").c(n && n.reason || "success").up();
                            n && n.reasonDescription ? i.c("text").t(n.reasonDescription).up().up() : i.up(), this._bridgeSessionId && i.c("bridge-session", {
                                xmlns: "http://jitsi.org/protocol/focus",
                                id: this._bridgeSessionId,
                                restart: n && !0 === n.requestRestart
                            }).up(), i = i.tree(), A.info(this + " Sending session-terminate", i), this.connection.sendIQ(i, e, this.newJingleErrorHandler(i, t), 1e4)
                        } else A.info(this + " Skipped sending session-terminate");
                        this.connection.jingle.terminate(this.sid)
                    }
                }
                onTerminated(e, t) {
                    A.info(this + " Session terminated", e, t), this._xmppListeners.forEach(e => e()), this._xmppListeners = [], this._removeSenderVideoConstraintsChangeListener && this._removeSenderVideoConstraintsChangeListener(), this.close()
                }
                onXmppStatusChanged(e) {
                    e === R.a.Status.CONNECTED && this._cachedOldLocalSdp && (A.info(this + " Sending SSRC update on reconnect"), this.notifyMySSRCUpdate(this._cachedOldLocalSdp, this._cachedNewLocalSdp))
                }
                _parseSsrcInfoFromSourceAdd(e, t) {
                    const n = [],
                        i = this;
                    return $(e).each((e, s) => {
                        const r = $(s).attr("name");
                        let o = "";
                        $(s).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                            const e = this.getAttribute("semantics"),
                                t = $(this).find(">source").map((function() {
                                    return this.getAttribute("ssrc")
                                })).get();
                            t.length && (o += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
                        }));
                        $(s).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                            const e = $(this).attr("ssrc");
                            t.containsSSRC(e) ? (!i.usesUnifiedPlan || !i.isP2P) && A.warn(`${i} Source-add request for existing SSRC: ${e}`) : $(this).find(">parameter").each((function() {
                                o += `a=ssrc:${e} ${$(this).attr("name")}`, $(this).attr("value") && $(this).attr("value").length && (o += ":" + $(this).attr("value")), o += "\r\n"
                            }))
                        })), t.media.forEach((e, t) => {
                            m.a.findLine(e, "a=mid:" + r) && (n[t] || (n[t] = ""), n[t] += o)
                        })
                    }), n
                }
                addRemoteStream(e) {
                    this._addOrRemoveRemoteStream(!0, e)
                }
                removeRemoteStream(e) {
                    this._addOrRemoveRemoteStream(!1, e)
                }
                removeRemoteStreamsOnLeave(e) {
                    let t = [];
                    const n = n => {
                        const i = this.peerconnection.getRemoteSourceInfoByParticipant(e);
                        if (i.length) {
                            const s = new h.a(this.peerconnection.localDescription.sdp),
                                r = this._processRemoteRemoveSource(i);
                            t = this.peerconnection.removeRemoteTracks(e), this._renegotiate(r.raw).then(() => {
                                const e = new h.a(this.peerconnection.localDescription.sdp);
                                this.notifyMySSRCUpdate(s, e), n()
                            }).catch(e => n(e))
                        } else n()
                    };
                    return new Promise((i, s) => {
                        A.debug(`${this} Queued removeRemoteStreamsOnLeave task for participant ${e}`), this.modificationQueue.push(n, e => {
                            e ? (A.error(this + " removeRemoteStreamsOnLeave error:", e), s(e)) : (A.info(this + " removeRemoteStreamsOnLeave done!"), i(t))
                        })
                    })
                }
                _addOrRemoveRemoteStream(e, t) {
                    const n = e ? "addRemoteStream" : "removeRemoteStream";
                    e && this.readSsrcInfo(t);
                    A.debug(`${this} Queued ${n} task`), this.modificationQueue.push(i => {
                        if (!this.peerconnection.localDescription || !this.peerconnection.localDescription.sdp) {
                            const e = n + " - localDescription not ready yet";
                            return A.error(e), void i(e)
                        }
                        A.log(`${this} Processing ${n}`);
                        const s = new h.a(this.peerconnection.localDescription.sdp),
                            r = new h.a(this.peerconnection.remoteDescription.sdp),
                            o = e ? this._parseSsrcInfoFromSourceAdd(t, r) : this._parseSsrcInfoFromSourceRemove(t, r),
                            a = e ? this._processRemoteAddSource(o) : this._processRemoteRemoveSource(o),
                            c = new RTCSessionDescription({
                                type: "offer",
                                sdp: a.raw
                            });
                        (e && this.usesUnifiedPlan && this.isP2P && y.a.isChromiumBased() ? this._responderRenegotiate(c) : this._renegotiate(a.raw)).then(() => {
                            const e = new h.a(this.peerconnection.localDescription.sdp);
                            A.log(`${this} ${n} - OK`), this.notifyMySSRCUpdate(s, e), i()
                        }, e => {
                            A.error(`${this} ${n} failed:`, e), i(e)
                        })
                    })
                }
                _processNewJingleOfferIq(e) {
                    const t = new h.a("");
                    return this.webrtcIceTcpDisable && (t.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (t.removeUdpCandidates = !0), this.failICE && (t.failICE = !0), t.fromJingle(e), this.readSsrcInfo($(e).find(">content")), t
                }
                _processRemoteRemoveSource(e) {
                    const t = this.usesUnifiedPlan ? new h.a(this.peerconnection.peerconnection.remoteDescription.sdp) : new h.a(this.peerconnection.remoteDescription.sdp);
                    return e.forEach((e, n) => {
                        (e = e.split("\r\n")).pop(), this.usesUnifiedPlan ? e.forEach(e => {
                            const n = t.media.findIndex(t => t.includes(e));
                            if (n > -1)
                                if ((!this.usesUnifiedPlan || this.usesUnifiedPlan && !this.isP2P) && (t.media[n] = t.media[n].replace(e + "\r\n", "")), this.isP2P) {
                                    var i;
                                    const e = null === (i = m.a.parseMLine(t.media[n].split("\r\n")[0])) || void 0 === i ? void 0 : i.media,
                                        s = this.peerconnection.getDesiredMediaDirection(e, !1);
                                    [a.a.SENDRECV, a.a.SENDONLY].forEach(e => {
                                        t.media[n] = t.media[n].replace("a=" + e, "a=" + s)
                                    })
                                } else t.media[n] = t.media[n].replace("a=" + a.a.SENDONLY, "a=" + a.a.INACTIVE)
                        }) : e.forEach(e => {
                            t.media[n] = t.media[n].replace(e + "\r\n", "")
                        })
                    }), t.raw = t.session + t.media.join(""), t
                }
                _processRemoteAddSource(e) {
                    const t = new h.a(this.peerconnection.remoteDescription.sdp);
                    return e.forEach((e, n) => {
                        if (t.media[n] += e, this.isP2P && this.usesUnifiedPlan) {
                            var i;
                            const e = null === (i = m.a.parseMLine(t.media[n].split("\r\n")[0])) || void 0 === i ? void 0 : i.media,
                                s = this.peerconnection.getDesiredMediaDirection(e, !0);
                            [a.a.RECVONLY, a.a.INACTIVE].forEach(e => {
                                t.media[n] = t.media[n].replace("a=" + e, "a=" + s)
                            })
                        }
                    }), t.raw = t.session + t.media.join(""), t
                }
                _renegotiate(e) {
                    if ("closed" === this.peerconnection.signalingState) {
                        const e = new Error("Attempted to renegotiate in state closed");
                        return this.room.eventEmitter.emit(u.a.RENEGOTIATION_FAILED, e, this), Promise.reject(e)
                    }
                    const t = e || this.peerconnection.remoteDescription.sdp;
                    if (!t) {
                        const e = new Error("Can not renegotiate without remote description, current state: " + this.state);
                        return this.room.eventEmitter.emit(u.a.RENEGOTIATION_FAILED, e, this), Promise.reject(e)
                    }
                    const n = new RTCSessionDescription({
                        type: this.isInitiator ? "answer" : "offer",
                        sdp: t
                    });
                    return this.isInitiator ? this._initiatorRenegotiate(n) : this._responderRenegotiate(n)
                }
                _responderRenegotiate(e) {
                    return A.debug(this + " Renegotiate: setting remote description"), this.peerconnection.setRemoteDescription(e).then(() => (A.debug(this + " Renegotiate: creating answer"), this.peerconnection.createAnswer(this.mediaConstraints).then(e => (A.debug(this + " Renegotiate: setting local description"), this.peerconnection.setLocalDescription(e)))))
                }
                _initiatorRenegotiate(e) {
                    return A.debug(this + " Renegotiate: creating offer"), this.peerconnection.createOffer(this.mediaConstraints).then(t => (A.debug(this + " Renegotiate: setting local description"), this.peerconnection.setLocalDescription(t).then(() => (A.debug(this + " Renegotiate: setting remote description"), this.peerconnection.setRemoteDescription(e)))))
                }
                replaceTrack(e, t) {
                    const n = n => {
                        A.debug(`${this} replaceTrack worker started. oldTrack = ${e}, newTrack = ${t}`);
                        const i = this.peerconnection.localDescription.sdp;
                        this.usesUnifiedPlan || (this.peerconnection.options.capScreenshareBitrate && e && t && t.isVideoTrack() && this.peerconnection.clearRecvonlySsrc(), !e && t && t.isVideoTrack() ? this.peerconnection.clearRecvonlySsrc() : e && e.isVideoTrack() && !t && (this.peerconnection.clearRecvonlySsrc(), this.peerconnection.generateRecvonlySsrc())), this.peerconnection.replaceTrack(e, t).then(n => {
                            let s = Promise.resolve();
                            return A.debug(`${this} TPC.replaceTrack finished. shouldRenegotiate = ${n}, JingleSessionState = ${this.state}`), n && (e || t) && this.state === b.a && (s = this._renegotiate().then(() => {
                                const e = new h.a(this.peerconnection.localDescription.sdp);
                                this.notifyMySSRCUpdate(new h.a(i), e)
                            })), s.then(() => {
                                if (t && t.isVideoTrack()) return A.debug(this + " replaceTrack worker: configuring video stream"), this.peerconnection.setSenderVideoDegradationPreference().then(() => this.peerconnection.setSenderVideoConstraint()).then(() => this.peerconnection.setMaxBitRate())
                            })
                        }).then(() => n(), e => n(e))
                    };
                    return new Promise((i, s) => {
                        A.debug(`${this} Queued replaceTrack task. Old track = ${e}, new track = ${t}`), this.modificationQueue.push(n, e => {
                            e ? (A.error(this + " Replace track error:", e), s(e)) : (A.info(this + "  Replace track done!"), i())
                        })
                    })
                }
                _parseSsrcInfoFromSourceRemove(e, t) {
                    const n = [];
                    return $(e).each((e, i) => {
                        const s = $(i).attr("name");
                        let r = "";
                        $(i).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                            const e = this.getAttribute("semantics"),
                                t = $(this).find(">source").map((function() {
                                    return this.getAttribute("ssrc")
                                })).get();
                            t.length && (r += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
                        }));
                        const o = [];
                        $(i).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                            const e = $(this).attr("ssrc");
                            o.push(e)
                        })), t.media.forEach((e, t) => {
                            m.a.findLine(e, "a=mid:" + s) && (n[t] || (n[t] = ""), o.forEach(i => {
                                const s = m.a.findLines(e, "a=ssrc:" + i);
                                s.length && (n[t] += s.join("\r\n") + "\r\n")
                            }), n[t] += r)
                        })
                    }), n
                }
                _verifyNoSSRCChanged(e, t) {
                    const n = new h.a(this.peerconnection.localDescription.sdp);
                    let i = new p.a(t, n);
                    const s = i.getNewMedia();
                    if (Object.keys(s).length) return A.error(`${this} - some SSRC were added on ${e}`, s), !1;
                    i = new p.a(n, t);
                    const r = i.getNewMedia();
                    return !Object.keys(r).length || (A.error(`${this} - some SSRCs were removed on ${e}`, r), !1)
                }
                addTrackAsUnmute(e) {
                    return this._addRemoveTrackAsMuteUnmute(!1, e).then(() => {
                        if (e.isVideoTrack() && y.a.doesVideoMuteByStreamRemove()) return this.setSenderMaxBitrates().then(() => this.setSenderVideoDegradationPreference()).then(() => this.setSenderVideoConstraint())
                    })
                }
                removeTrackAsMute(e) {
                    return this._addRemoveTrackAsMuteUnmute(!0, e)
                }
                _addRemoveTrackAsMuteUnmute(e, t) {
                    if (!t) return Promise.reject('invalid "track" argument value');
                    const n = e ? "removeTrackMute" : "addTrackUnmute",
                        i = i => {
                            const s = this.peerconnection;
                            if (!s) return void i(`Error:  tried ${n} track with no active peerconnection`);
                            const r = s.localDescription.sdp;
                            (e ? s.removeTrackMute(t) : s.addTrackUnmute(t)).then(e => {
                                e && r && s.remoteDescription.sdp ? this._renegotiate().then(() => {
                                    this._verifyNoSSRCChanged(n, new h.a(r)), i()
                                }) : i()
                            }, i)
                        };
                    return A.debug(`${this} Queued ${n} task`), new Promise((e, t) => {
                        this.modificationQueue.push(i, i => {
                            i ? (A.error(`${this} ${n} failed`), t(i)) : (A.debug(`${this} ${n} done`), e())
                        })
                    })
                }
                setMediaTransferActive(e, t) {
                    if (!this.peerconnection) return Promise.reject('Can not modify transfer active state, before "initialize" is called');
                    const n = e ? "audio active" : "audio inactive",
                        i = t ? "video active" : "video inactive";
                    A.info(`${this} Queued make ${i}, ${n} task`);
                    const s = n => {
                        const i = this.state === b.a,
                            s = this.peerconnection.setAudioTransferActive(e);
                        this._localVideoActive !== t && (this._localVideoActive = t, this.isP2P && i && this.sendContentModify());
                        const r = this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive);
                        i && (s || r) ? this._renegotiate().then(n, n) : n()
                    };
                    return new Promise((e, t) => {
                        this.modificationQueue.push(s, s => {
                            s ? (A.error(`${this} Make ${i}, ${n} task failed!`), t(s)) : (A.debug(`${this} Make ${i}, ${n} task done!`), e())
                        })
                    })
                }
                modifyContents(e) {
                    const t = I.parseVideoSenders(e),
                        n = I.parseMaxFrameHeight(e);
                    if (n && (A.info(`${this} received remote max frame height: ${n}`), this.remoteRecvMaxFrameHeight = n, this.eventEmitter.emit(C.a.REMOTE_VIDEO_CONSTRAINTS_CHANGED, this)), null === t) return void A.error(this + ' - failed to parse video "senders" attribute in"content-modify" action');
                    A.debug(`${this} queued "content-modify" task(video senders="${t}")`), this.modificationQueue.push(e => {
                        this._assertNotEnded("content-modify") && this._modifyRemoteVideoActive(t) ? this._renegotiate().then(e, e) : e()
                    }, e => {
                        e ? A.error(this + ' "content-modify" failed', e) : A.debug(`${this} "content-modify" task(video senders="${t}") done`)
                    })
                }
                _modifyRemoteVideoActive(e) {
                    const t = "both" === e || "initiator" === e && this.isInitiator || "responder" === e && !this.isInitiator;
                    return t !== this._remoteVideoActive && (A.debug(`${this} new remote video active: ${t}`), this._remoteVideoActive = t), this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive)
                }
                notifyMySSRCUpdate(e, t) {
                    if (this.state !== b.a) return void A.warn(`${this} Skipping SSRC update in '${this.state} ' state.`);
                    if (!this.connection.connected) return this._cachedOldLocalSdp || (this._cachedOldLocalSdp = e), this._cachedNewLocalSdp = t, void A.warn(this + " Not sending SSRC update while the signaling is disconnected");
                    this._cachedOldLocalSdp = void 0, this._cachedNewLocalSdp = void 0;
                    let n = new p.a(t, e);
                    const i = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "source-remove",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    });
                    n.toJingle(i) && (A.info(this + " Sending source-remove", i.tree()), this.connection.sendIQ(i, null, this.newJingleErrorHandler(i), 1e4)), n = new p.a(e, t);
                    const r = Object(s.$iq)({
                        to: this.remoteJid,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: "source-add",
                        initiator: this.initiatorJid,
                        sid: this.sid
                    });
                    n.toJingle(r) && (A.info(this + " Sending source-add", r.tree()), this.connection.sendIQ(r, null, this.newJingleErrorHandler(r), 1e4))
                }
                newJingleErrorHandler(e, t) {
                    return e => {
                        const n = {},
                            i = $(e).find("error");
                        if (i.length) {
                            n.code = i.attr("code");
                            const t = $(e).find("error :first");
                            t.length && (n.reason = t[0].tagName);
                            const s = i.find(">text");
                            s.length && (n.msg = s.text())
                        }
                        e || (n.reason = "timeout"), n.session = this.toString(), t ? t(n) : this.state === b.b && "item-not-found" === n.reason ? A.debug(`${this} Jingle error: ${JSON.stringify(n)}`) : v.a.callErrorHandler(new Error("Jingle error: " + JSON.stringify(n)))
                    }
                }
                getIceConnectionState() {
                    return this.peerconnection.getConnectionState()
                }
                close() {
                    this.state = b.b, this.establishmentDuration = void 0, this.peerconnection && (this.peerconnection.onicecandidate = null, this.peerconnection.oniceconnectionstatechange = null, this.peerconnection.onnegotiationneeded = null, this.peerconnection.onsignalingstatechange = null), A.debug(this + " Clearing modificationQueue"), this.modificationQueue.clear(), A.debug(this + " Queued PC close task"), this.modificationQueue.push(e => {
                        this.signalingLayer.setChatRoom(null), this.peerconnection && this.peerconnection.close(), e(), A.debug(this + " PC close task done!")
                    }), A.debug(this + " Shutdown modificationQueue!"), this.modificationQueue.shutdown()
                }
                toString() {
                    return `JingleSessionPC[session=${this.isP2P?"P2P":"JVB"},initiator=${this.isInitiator},sid=${this.sid}]`
                }
                _abtestSuspendVideoEnabled({
                    abTesting: e
                }) {
                    if (!e || !e.enableSuspendVideoTest) return;
                    const t = this._getInitiatorJid();
                    return Object(S.integerHash)(t) % 2 == 0
                }
            }
        }).call(this, "modules/xmpp/JingleSessionPC.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return u
        })), n.d(t, "b", (function() {
            return f
        }));
        n(73);
        var i = n(88),
            s = n.n(i);
        const r = {
            Chrome: "chrome",
            Chromium: "chrome",
            Opera: "opera",
            Firefox: "firefox",
            "Internet Explorer": "iexplorer",
            Safari: "safari"
        };

        function o() {
            const e = navigator.userAgent;
            if (e.match(/Electron/)) {
                return {
                    name: "electron",
                    version: e.match(/Electron\/([\d.]+)/)[1]
                }
            }
        }

        function a() {
            const e = navigator.userAgent;
            if (e.match(/JitsiMeetNW/)) {
                return {
                    name: "nwjs",
                    version: e.match(/JitsiMeetNW\/([\d.]+)/)[1]
                }
            }
        }

        function c() {
            const e = navigator.userAgent.match(/\b(react[ \t_-]*native)(?:\/(\S+))?/i);
            let t;
            if (e || "ReactNative" === navigator.product) {
                let n;
                return e && e.length > 2 && (n = e[1], t = e[2]), n || (n = "react-native"), t || (t = "unknown"), {
                    name: "react-native",
                    version: t
                }
            }
        }

        function d(e) {
            let t;
            const n = [c, o, a];
            for (let e = 0; e < n.length; e++)
                if (t = n[e](), t) return t;
            const i = e.getBrowserName();
            return i in r ? {
                name: r[i],
                version: e.getBrowserVersion()
            } : (t = function() {
                const e = navigator.userAgent,
                    t = {
                        name: "unknown",
                        version: void 0
                    };
                if (e.match(/Chrome/) && !e.match(/Edge/))
                    if (e.match(/Edg(A?)/)) {
                        const n = e.match(/Chrome\/([\d.]+)/)[1];
                        Number.parseInt(n, 10) > 72 && (t.name = "chrome", t.version = n)
                    } else t.name = "chrome", t.version = e.match(/Chrome\/([\d.]+)/)[1];
                return t
            }(), t || {
                name: "unknown",
                version: void 0
            })
        }
        class u {
            constructor(e) {
                let t, n;
                if (this._bowser = s.a.getParser(navigator.userAgent), void 0 === e) {
                    const e = d(this._bowser);
                    t = e.name, n = e.version
                } else e.name in r ? (t = r[e.name], n = e.version) : (t = "unknown", n = void 0);
                this._name = t, this._version = n
            }
            getName() {
                return this._name
            }
            isChrome() {
                return "chrome" === this._name
            }
            isOpera() {
                return "opera" === this._name
            }
            isFirefox() {
                return "firefox" === this._name
            }
            isIExplorer() {
                return "iexplorer" === this._name
            }
            isSafari() {
                return "safari" === this._name
            }
            isNWJS() {
                return "nwjs" === this._name
            }
            isElectron() {
                return "electron" === this._name
            }
            isReactNative() {
                return "react-native" === this._name
            }
            getVersion() {
                return this._version
            }
            _checkCondition(e) {
                if (this._version) return this._bowser.satisfies(e)
            }
            isVersionGreaterThan(e) {
                return this._checkCondition({
                    [this._name]: ">" + e
                })
            }
            isVersionLessThan(e) {
                return this._checkCondition({
                    [this._name]: "<" + e
                })
            }
            isVersionEqualTo(e) {
                return this._checkCondition({
                    [this._name]: "~" + e
                })
            }
        }
        var l = n(19),
            h = n.n(l);
        class p extends h.a {
            constructor(...e) {
                var t, n, i;
                super(...e), i = {}, (n = "_storage") in (t = this) ? Object.defineProperty(t, n, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[n] = i
            }
            clear() {
                this._storage = {}
            }
            get length() {
                return Object.keys(this._storage).length
            }
            getItem(e) {
                return this._storage[e]
            }
            setItem(e, t) {
                this._storage[e] = t
            }
            removeItem(e) {
                delete this._storage[e]
            }
            key(e) {
                const t = Object.keys(this._storage);
                if (!(t.length <= e)) return t[e]
            }
            serialize() {
                return JSON.stringify(this._storage)
            }
        }
        class m extends h.a {
            constructor() {
                super();
                try {
                    this._storage = window.localStorage, this._localStorageDisabled = !1
                } catch (e) {}
                this._storage || (console.warn("Local storage is disabled."), this._storage = new p, this._localStorageDisabled = !0)
            }
            isLocalStorageDisabled() {
                return this._localStorageDisabled
            }
            clear() {
                this._storage.clear(), this.emit("changed")
            }
            get length() {
                return this._storage.length
            }
            getItem(e) {
                return this._storage.getItem(e)
            }
            setItem(e, t, n = !1) {
                this._storage.setItem(e, t), n || this.emit("changed")
            }
            removeItem(e) {
                this._storage.removeItem(e), this.emit("changed")
            }
            key(e) {
                return this._storage.key(e)
            }
            serialize() {
                if (this.isLocalStorageDisabled) return this._storage.serialize();
                const e = this._storage.length,
                    t = {};
                for (let n = 0; n < e; n++) {
                    const e = this._storage.key(n);
                    t[e] = this._storage.getItem(e)
                }
                return JSON.stringify(t)
            }
        }
        const f = new m
    }, function(e, t, n) {
        "use strict";
        t.byteLength = function(e) {
            var t = d(e),
                n = t[0],
                i = t[1];
            return 3 * (n + i) / 4 - i
        }, t.toByteArray = function(e) {
            var t, n, i = d(e),
                o = i[0],
                a = i[1],
                c = new r(function(e, t, n) {
                    return 3 * (t + n) / 4 - n
                }(0, o, a)),
                u = 0,
                l = a > 0 ? o - 4 : o;
            for (n = 0; n < l; n += 4) t = s[e.charCodeAt(n)] << 18 | s[e.charCodeAt(n + 1)] << 12 | s[e.charCodeAt(n + 2)] << 6 | s[e.charCodeAt(n + 3)], c[u++] = t >> 16 & 255, c[u++] = t >> 8 & 255, c[u++] = 255 & t;
            2 === a && (t = s[e.charCodeAt(n)] << 2 | s[e.charCodeAt(n + 1)] >> 4, c[u++] = 255 & t);
            1 === a && (t = s[e.charCodeAt(n)] << 10 | s[e.charCodeAt(n + 1)] << 4 | s[e.charCodeAt(n + 2)] >> 2, c[u++] = t >> 8 & 255, c[u++] = 255 & t);
            return c
        }, t.fromByteArray = function(e) {
            for (var t, n = e.length, s = n % 3, r = [], o = 0, a = n - s; o < a; o += 16383) r.push(u(e, o, o + 16383 > a ? a : o + 16383));
            1 === s ? (t = e[n - 1], r.push(i[t >> 2] + i[t << 4 & 63] + "==")) : 2 === s && (t = (e[n - 2] << 8) + e[n - 1], r.push(i[t >> 10] + i[t >> 4 & 63] + i[t << 2 & 63] + "="));
            return r.join("")
        };
        for (var i = [], s = [], r = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, c = o.length; a < c; ++a) i[a] = o[a], s[o.charCodeAt(a)] = a;

        function d(e) {
            var t = e.length;
            if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
            var n = e.indexOf("=");
            return -1 === n && (n = t), [n, n === t ? 0 : 4 - n % 4]
        }

        function u(e, t, n) {
            for (var s, r, o = [], a = t; a < n; a += 3) s = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), o.push(i[(r = s) >> 18 & 63] + i[r >> 12 & 63] + i[r >> 6 & 63] + i[63 & r]);
            return o.join("")
        }
        s["-".charCodeAt(0)] = 62, s["_".charCodeAt(0)] = 63
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return r
        }));
        var i = n(9);

        function s(e, t) {
            if (!t) return !1;
            if (e.length !== t.length) return !1;
            for (let n = 0, i = e.length; n < i; n++)
                if (e[n] instanceof Array && t[n] instanceof Array) {
                    if (!e[n].equals(t[n])) return !1
                } else if (e[n] !== t[n]) return !1;
            return !0
        }

        function r(e, t) {
            if (this.mySDP = e, this.otherSDP = t, !e) throw new Error('"mySDP" is undefined!');
            if (!t) throw new Error('"otherSDP" is undefined!')
        }
        r.prototype.getNewMedia = function() {
            const e = this.mySDP.getMediaSsrcMap(),
                t = this.otherSDP.getMediaSsrcMap(),
                n = {};
            return Object.keys(t).forEach(i => {
                const r = e[i],
                    o = t[i];
                r || !o ? (Object.keys(o.ssrcs).forEach(e => {
                    if (-1 === Object.keys(r.ssrcs).indexOf(e)) n[i] || (n[i] = {
                        mediaindex: o.mediaindex,
                        mid: o.mid,
                        ssrcs: {},
                        ssrcGroups: []
                    }), n[i].ssrcs[e] = o.ssrcs[e];
                    else if (o.ssrcs[e].lines && r.ssrcs[e].lines) {
                        void 0 !== r.ssrcs[e].lines.find(e => -1 !== e.indexOf("msid")) !== (void 0 !== o.ssrcs[e].lines.find(e => -1 !== e.indexOf("msid"))) && (n[i] || (n[i] = {
                            mediaindex: o.mediaindex,
                            mid: o.mid,
                            ssrcs: {},
                            ssrcGroups: []
                        }), n[i].ssrcs[e] = o.ssrcs[e])
                    }
                }), o.ssrcGroups.forEach(e => {
                    let t = !1;
                    for (let n = 0; n < r.ssrcGroups.length; n++) {
                        const i = r.ssrcGroups[n];
                        if (e.semantics === i.semantics && s(e.ssrcs, i.ssrcs)) {
                            t = !0;
                            break
                        }
                    }
                    t || (n[i] || (n[i] = {
                        mediaindex: o.mediaindex,
                        mid: o.mid,
                        ssrcs: {},
                        ssrcGroups: []
                    }), n[i].ssrcGroups.push(e))
                })) : n[i] = o
            }), n
        }, r.prototype.toJingle = function(e) {
            const t = this.getNewMedia();
            let n = !1;
            return Object.keys(t).forEach(s => {
                n = !0;
                const r = t[s];
                e.c("content", {
                    name: r.mid
                }), e.c("description", {
                    xmlns: "urn:xmpp:jingle:apps:rtp:1",
                    media: r.mid
                }), Object.keys(r.ssrcs).forEach(t => {
                    const n = r.ssrcs[t];
                    e.c("source", {
                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                    }), e.attrs({
                        ssrc: n.ssrc
                    }), n.lines.forEach(t => {
                        const n = t.indexOf(" "),
                            s = t.substr(n + 1);
                        if (e.c("parameter"), -1 === s.indexOf(":")) e.attrs({
                            name: s
                        });
                        else {
                            const t = s.split(":", 2),
                                n = t[0],
                                r = i.a.filterSpecialChars(t[1]);
                            e.attrs({
                                name: n
                            }), e.attrs({
                                value: r
                            })
                        }
                        e.up()
                    }), e.up()
                }), r.ssrcGroups.forEach(t => {
                    t.ssrcs.length && (e.c("ssrc-group", {
                        semantics: t.semantics,
                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                    }), t.ssrcs.forEach(t => {
                        e.c("source", {
                            ssrc: t
                        }).up()
                    }), e.up())
                }), e.up(), e.up()
            }), n
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return l
            })), n.d(t, "b", (function() {
                return h
            }));
            var i = n(5),
                s = n(23),
                r = n.n(s),
                o = n(10),
                a = n.n(o),
                c = n(4),
                d = n(3);
            const u = Object(i.getLogger)(e),
                l = ["1", "2", "3"];
            class h {
                constructor(e, t) {
                    this.pc = e, this.videoBitrates = t.VP8 || t, this.localStreamEncodingsConfig = [{
                        active: !0,
                        maxBitrate: d.a.isFirefox() ? this.videoBitrates.high : this.videoBitrates.low,
                        rid: "1",
                        scaleResolutionDownBy: d.a.isFirefox() ? 1 : 4
                    }, {
                        active: !0,
                        maxBitrate: this.videoBitrates.standard,
                        rid: "2",
                        scaleResolutionDownBy: 2
                    }, {
                        active: !0,
                        maxBitrate: d.a.isFirefox() ? this.videoBitrates.low : this.videoBitrates.high,
                        rid: "3",
                        scaleResolutionDownBy: d.a.isFirefox() ? 4 : 1
                    }]
                }
                _findTransceiver(e, t = null) {
                    let n = null;
                    return !t || t && d.a.doesVideoMuteByStreamRemove() && t.isVideoTrack() && t.isMuted() ? n = this.pc.peerconnection.getTransceivers().find(t => {
                        var n, i;
                        return (null === (n = t.receiver) || void 0 === n || null === (i = n.track) || void 0 === i ? void 0 : i.kind) === e
                    }) : t && (n = this.pc.peerconnection.getTransceivers().find(e => {
                        var n, i;
                        return (null === (n = e.sender) || void 0 === n || null === (i = n.track) || void 0 === i ? void 0 : i.id) === t.getTrackId()
                    })), n
                }
                _getStreamEncodings(e) {
                    return this.pc.isSimulcastOn() && e.isVideoTrack() ? this.localStreamEncodingsConfig : e.isVideoTrack() ? [{
                        active: !0,
                        maxBitrate: this.videoBitrates.high
                    }] : [{
                        active: !0
                    }]
                }
                ensureCorrectOrderOfSsrcs(e) {
                    const t = r.a.parse(e.sdp);
                    return t.media.forEach(e => {
                        if (e.type === c.a) return;
                        if (!e.ssrcGroups || !e.ssrcGroups.length) return;
                        let t = [];
                        const n = new Set;
                        e.ssrcGroups.map(e => e.ssrcs.split(" ").filter(Boolean).forEach(e => n.add(e))), n.forEach(n => {
                            const i = e.ssrcs.filter(e => e.id.toString() === n);
                            t = t.concat(i)
                        }), e.ssrcs = t
                    }), new RTCSessionDescription({
                        type: e.type,
                        sdp: r.a.write(t)
                    })
                }
                insertUnifiedPlanSimulcastReceive(e) {
                    if (d.a.usesSdpMungingForSimulcast()) return e;
                    const t = r.a.parse(e.sdp),
                        n = t.media.findIndex(e => e.type === c.c);
                    if (t.media[n].rids && (t.media[n].simulcast_03 || t.media[n].simulcast)) return t.media.forEach((e, i) => {
                        e.type === c.c && i !== n && (t.media[i].rids = void 0, t.media[i].simulcast = void 0, t.media[i].simulcast_03 = void 0)
                    }), new RTCSessionDescription({
                        type: e.type,
                        sdp: r.a.write(t)
                    });
                    t.media[n].rids = [{
                        id: "1",
                        direction: "recv"
                    }, {
                        id: "2",
                        direction: "recv"
                    }, {
                        id: "3",
                        direction: "recv"
                    }];
                    const i = d.a.isFirefox() && d.a.isVersionGreaterThan(71) ? "recv " + l.join(";") : "recv rid=" + l.join(";");
                    return t.media[n].simulcast_03 = {
                        value: i
                    }, new RTCSessionDescription({
                        type: e.type,
                        sdp: r.a.write(t)
                    })
                }
                addTrack(e, t) {
                    const n = e.getTrack();
                    if (t) {
                        const t = {
                            direction: a.a.SENDRECV,
                            streams: [e.getOriginalStream()],
                            sendEncodings: []
                        };
                        d.a.isFirefox() || (t.sendEncodings = this._getStreamEncodings(e)), this.pc.peerconnection.addTransceiver(n, t)
                    } else this.pc.peerconnection.addTrack(n)
                }
                addTrackUnmute(e) {
                    const t = e.getType(),
                        n = e.getTrack(),
                        i = this._findTransceiver(t);
                    return i ? (u.debug(`${this.pc} Adding ${e}`), i.sender.replaceTrack(n)) : Promise.reject(new Error(`RTCRtpTransceiver for ${t} not found`))
                }
                getLocalStreamHeightConstraints(e) {
                    if (d.a.isReactNative()) return null;
                    const t = [],
                        {
                            height: n = 720
                        } = e.getSettings();
                    for (const e of this.localStreamEncodingsConfig) t.push(n / e.scaleResolutionDownBy);
                    return t
                }
                removeTrackMute(e) {
                    const t = e.getType(),
                        n = this._findTransceiver(t, e);
                    return n ? (u.debug(`${this.pc} Removing ${e}`), n.sender.replaceTrack(null)) : Promise.reject(new Error(`RTCRtpTransceiver for ${t} not found`))
                }
                replaceTrack(e, t) {
                    if (e && t) {
                        const n = t.getType(),
                            i = t.getOriginalStream();
                        if (!i) return this.pc.localTracks.delete(e.rtcId), this.pc.localTracks.set(t.rtcId, t), Promise.resolve();
                        const s = this._findTransceiver(n, e),
                            r = t.getTrack();
                        return s ? (u.debug(`${this.pc} Replacing ${e} with ${t}`), s.sender.replaceTrack(r).then(() => {
                            const n = this.pc.localSSRCs.get(e.rtcId);
                            this.pc.localTracks.delete(e.rtcId), this.pc.localSSRCs.delete(e.rtcId), this.pc._addedStreams = this.pc._addedStreams.filter(e => e !== i), this.pc.localTracks.set(t.rtcId, t), this.pc._addedStreams.push(i), this.pc.localSSRCs.set(t.rtcId, n)
                        })) : Promise.reject(new Error("replace track failed"))
                    }
                    return e && !t ? this.removeTrackMute(e).then(() => {
                        const t = e.getType(),
                            n = this._findTransceiver(t);
                        n && (n.direction = a.a.RECVONLY), this.pc.localTracks.delete(e.rtcId), this.pc.localSSRCs.delete(e.rtcId)
                    }) : t && !e ? this.addTrackUnmute(t).then(() => {
                        const e = t.getType(),
                            n = this._findTransceiver(e, t);
                        n && (n.direction = a.a.SENDRECV);
                        return (d.a.usesSdpMungingForSimulcast() ? Promise.resolve() : this.setEncodings(t)).then(() => {
                            this.pc.localTracks.set(t.rtcId, t)
                        })
                    }) : (u.info(this.pc + " TPCUtils.replaceTrack called with no new track and no old track"), Promise.resolve())
                }
                setAudioTransferActive(e) {
                    this.setMediaTransferActive(c.a, e)
                }
                setEncodings(e) {
                    var t, n;
                    const i = e.getType(),
                        s = this._findTransceiver(i, e),
                        r = null == s || null === (t = s.sender) || void 0 === t ? void 0 : t.getParameters();
                    return (null == r || null === (n = r.encodings) || void 0 === n ? void 0 : n.length) ? (r.encodings = this._getStreamEncodings(e), s.sender.setParameters(r)) : Promise.resolve()
                }
                setMediaTransferActive(e, t) {
                    const n = this.pc.peerconnection.getTransceivers().filter(t => t.receiver && t.receiver.track && t.receiver.track.kind === e),
                        i = this.pc.getLocalTracks(e);
                    u.info(`${this.pc} ${t?"Enabling":"Suspending"} ${e} media transfer.`), n.forEach((e, n) => {
                        t ? 0 === n && i.length ? e.direction = a.a.SENDRECV : e.direction = a.a.RECVONLY : e.direction = a.a.INACTIVE
                    })
                }
                setVideoTransferActive(e) {
                    this.setMediaTransferActive(c.c, e)
                }
                updateEncodingsResolution(e) {
                    if (!(d.a.isWebKitBased() && e.encodings && Array.isArray(e.encodings))) return;
                    var t;
                    (t = e.encodings).every(e => void 0 !== e.scaleResolutionDownBy && e.scaleResolutionDownBy === t[0].scaleResolutionDownBy) && e.encodings.forEach((e, t) => {
                        e.scaleResolutionDownBy = this.localStreamEncodingsConfig[t].scaleResolutionDownBy
                    })
                }
            }
        }).call(this, "modules/RTC/TPCUtils.js")
    }, function(e, t) {
        var n, i, s = e.exports = {};

        function r() {
            throw new Error("setTimeout has not been defined")
        }

        function o() {
            throw new Error("clearTimeout has not been defined")
        }

        function a(e) {
            if (n === setTimeout) return setTimeout(e, 0);
            if ((n === r || !n) && setTimeout) return n = setTimeout, setTimeout(e, 0);
            try {
                return n(e, 0)
            } catch (t) {
                try {
                    return n.call(null, e, 0)
                } catch (t) {
                    return n.call(this, e, 0)
                }
            }
        }! function() {
            try {
                n = "function" == typeof setTimeout ? setTimeout : r
            } catch (e) {
                n = r
            }
            try {
                i = "function" == typeof clearTimeout ? clearTimeout : o
            } catch (e) {
                i = o
            }
        }();
        var c, d = [],
            u = !1,
            l = -1;

        function h() {
            u && c && (u = !1, c.length ? d = c.concat(d) : l = -1, d.length && p())
        }

        function p() {
            if (!u) {
                var e = a(h);
                u = !0;
                for (var t = d.length; t;) {
                    for (c = d, d = []; ++l < t;) c && c[l].run();
                    l = -1, t = d.length
                }
                c = null, u = !1,
                    function(e) {
                        if (i === clearTimeout) return clearTimeout(e);
                        if ((i === o || !i) && clearTimeout) return i = clearTimeout, clearTimeout(e);
                        try {
                            i(e)
                        } catch (t) {
                            try {
                                return i.call(null, e)
                            } catch (t) {
                                return i.call(this, e)
                            }
                        }
                    }(e)
            }
        }

        function m(e, t) {
            this.fun = e, this.array = t
        }

        function f() {}
        s.nextTick = function(e) {
            var t = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
            d.push(new m(e, t)), 1 !== d.length || u || a(p)
        }, m.prototype.run = function() {
            this.fun.apply(null, this.array)
        }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {}, s.on = f, s.addListener = f, s.once = f, s.off = f, s.removeListener = f, s.removeAllListeners = f, s.emit = f, s.prependListener = f, s.prependOnceListener = f, s.listeners = function(e) {
            return []
        }, s.binding = function(e) {
            throw new Error("process.binding is not supported")
        }, s.cwd = function() {
            return "/"
        }, s.chdir = function(e) {
            throw new Error("process.chdir is not supported")
        }, s.umask = function() {
            return 0
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return s
        }));
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        let i = null;

        function s(e, t, n) {
            this.stream = e, this.intervalId = null, this.intervalMilis = t, this.audioLevel = 0, this.callback = n
        }
        window.AudioContext && (i = new AudioContext, i.suspend && i.suspend()), s.prototype.start = function() {
            if (!s.isLocalStatsSupported()) return;
            i.resume();
            const e = i.createAnalyser();
            e.smoothingTimeConstant = .8, e.fftSize = 2048;
            i.createMediaStreamSource(this.stream).connect(e), this.intervalId = setInterval(() => {
                const t = new Uint8Array(e.frequencyBinCount);
                e.getByteTimeDomainData(t);
                const n = function(e) {
                    let t = 0;
                    const n = e.length;
                    for (let i = 0; i < n; i++) t < e[i] && (t = e[i]);
                    return parseFloat(((t - 127) / 128).toFixed(3))
                }(t);
                this.audioLevel = function(e, t) {
                    let n = 0;
                    const i = t - e;
                    return n = i > .2 ? t - .2 : i < -.4 ? t + .4 : e, parseFloat(n.toFixed(3))
                }(n, this.audioLevel), this.callback(this.audioLevel)
            }, this.intervalMilis)
        }, s.prototype.stop = function() {
            this.intervalId && (clearInterval(this.intervalId), this.intervalId = null)
        }, s.isLocalStatsSupported = function() {
            return Boolean(i)
        }
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "ON", (function() {
            return i
        })), n.d(t, "OFF", (function() {
            return s
        }));
        const i = "on",
            s = "off"
    }, function(e, t, n) {
        "use strict";
        t.a = {
            REMOTE_VIDEO_CONSTRAINTS_CHANGED: "media_session.REMOTE_VIDEO_CONSTRAINTS_CHANGED"
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return h
            }));
            var i = n(19),
                s = n.n(i),
                r = n(5),
                o = n(16),
                a = n(4),
                c = n(3),
                d = n(11);
            const u = Object(r.getLogger)(e),
                l = {
                    track_mute: "onmute",
                    track_unmute: "onunmute",
                    track_ended: "onended"
                };
            class h extends s.a {
                constructor(e, t, n, i, s, r) {
                    super(), this.addEventListener = this.addListener, this.removeEventListener = this.off = this.removeListener, this.containers = [], this.conference = e, this.audioLevel = -1, this.type = s, this.track = n, this.videoType = r, this.handlers = new Map, this.disposed = !1, this._streamInactiveHandler = i, this._setStream(t)
                }
                _addMediaStreamInactiveHandler(e) {
                    c.a.isFirefox() ? this.track.onended = e : this.stream.oninactive = e
                }
                _setHandler(e, t) {
                    if (l.hasOwnProperty(e)) {
                        if (t ? this.handlers.set(e, t) : this.handlers.delete(e), this.stream)
                            for (const n of this.stream.getTracks()) n[l[e]] = t
                    } else u.error("Invalid handler type " + e)
                }
                _unregisterHandlers() {
                    if (this.stream) {
                        for (const e of this.handlers.keys())
                            for (const t of this.stream.getVideoTracks()) t[l[e]] = void 0;
                        this._streamInactiveHandler && this._addMediaStreamInactiveHandler(void 0)
                    } else u.warn(this + ": unable to unregister handlers - no stream object")
                }
                _setStream(e) {
                    if (this.stream !== e && (this.stream = e, this.stream)) {
                        for (const e of this.handlers.keys()) this._setHandler(e, this.handlers.get(e));
                        this._streamInactiveHandler && this._addMediaStreamInactiveHandler(this._streamInactiveHandler)
                    }
                }
                getVideoType() {
                    return this.videoType
                }
                getType() {
                    return this.type
                }
                isAudioTrack() {
                    return this.getType() === a.a
                }
                isWebRTCTrackMuted() {
                    return this.track && this.track.muted
                }
                isVideoTrack() {
                    return this.getType() === a.c
                }
                isLocal() {
                    throw new Error("Not implemented by subclass")
                }
                isLocalAudioTrack() {
                    return this.isAudioTrack() && this.isLocal()
                }
                getOriginalStream() {
                    return this.stream
                }
                getStreamId() {
                    return this.stream ? this.stream.id : null
                }
                getTrack() {
                    return this.track
                }
                getTrackLabel() {
                    return this.track.label
                }
                getTrackId() {
                    return this.track ? this.track.id : null
                }
                getUsageLabel() {
                    return this.isAudioTrack() ? "mic" : this.videoType ? this.videoType : "default"
                }
                _maybeFireTrackAttached(e) {
                    this.conference && e && this.conference._onTrackAttach(this, e)
                }
                attach(e) {
                    this.stream && (this._onTrackAttach(e), d.a.attachMediaStream(e, this.stream)), this.containers.push(e), this._maybeFireTrackAttached(e), this._attachTTFMTracker(e)
                }
                detach(e) {
                    for (let t = this.containers, n = t.length - 1; n >= 0; --n) {
                        const i = t[n];
                        e || (this._onTrackDetach(i), d.a.attachMediaStream(i, null)), e && i !== e || t.splice(n, 1)
                    }
                    e && (this._onTrackDetach(e), d.a.attachMediaStream(e, null))
                }
                _onTrackAttach(e) {}
                _onTrackDetach(e) {}
                _attachTTFMTracker(e) {}
                dispose() {
                    return this.removeAllListeners(), this.disposed = !0, Promise.resolve()
                }
                isScreenSharing() {}
                getId() {
                    return this.stream ? d.a.getStreamID(this.stream) : null
                }
                isActive() {
                    return void 0 === this.stream.active || this.stream.active
                }
                setAudioLevel(e, t) {
                    let n = e;
                    c.a.supportsReceiverStats() && void 0 !== t && this.isMuted() && (n = 0), this.audioLevel !== n ? (this.audioLevel = n, this.emit(o.TRACK_AUDIO_LEVEL_CHANGED, n, t)) : 0 === this.audioLevel && 0 === n && this.isLocal() && !this.isWebRTCTrackMuted() && this.emit(o.NO_AUDIO_INPUT, n)
                }
                getMSID() {
                    const e = this.getStreamId(),
                        t = this.getTrackId();
                    return e && t ? `${e} ${t}` : null
                }
                setAudioOutput(e) {
                    return d.a.isDeviceChangeAvailable("output") ? this.isVideoTrack() ? Promise.resolve() : Promise.all(this.containers.map(t => t.setSinkId(e).catch(e => {
                        throw u.warn("Failed to change audio output device on element. Default or previously set audio output device will be used.", t, e), e
                    }))).then(() => {
                        this.emit(o.TRACK_AUDIO_OUTPUT_CHANGED, e)
                    }) : Promise.reject(new Error("Audio output device change is not supported"))
                }
            }
        }).call(this, "modules/RTC/JitsiTrack.js")
    }, function(e, t) {
        e.exports = {
            2160: {
                width: 3840,
                height: 2160
            },
            "4k": {
                width: 3840,
                height: 2160
            },
            1080: {
                width: 1920,
                height: 1080
            },
            fullhd: {
                width: 1920,
                height: 1080
            },
            720: {
                width: 1280,
                height: 720
            },
            hd: {
                width: 1280,
                height: 720
            },
            540: {
                width: 960,
                height: 540
            },
            qhd: {
                width: 960,
                height: 540
            },
            480: {
                width: 640,
                height: 480
            },
            vga: {
                width: 640,
                height: 480
            },
            360: {
                width: 640,
                height: 360
            },
            240: {
                width: 320,
                height: 240
            },
            180: {
                width: 320,
                height: 180
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return c
        }));
        var i = n(19),
            s = n.n(i),
            r = n(13),
            o = n(68),
            a = n(24);
        class c extends s.a {
            constructor(e, t, n) {
                super(), this._procNodeSampleRate = e, this._vadProcessor = t, this._localTrack = n, this._bufferResidue = new Float32Array([]), this._audioContext = Object(o.a)({
                    sampleRate: t.getRequiredPCMFrequency()
                }), this._vadSampleSize = t.getSampleLength(), this._onAudioProcess = this._onAudioProcess.bind(this), this._initializeAudioContext()
            }
            static create(e, t, n) {
                return r.a.obtainAudioAndVideoPermissions({
                    devices: ["audio"],
                    micDeviceId: e
                }).then(i => {
                    if (!i[0]) throw new Error("Failed to create jitsi local track for device id: " + e);
                    return new c(t, n, i[0])
                })
            }
            _initializeAudioContext() {
                this._audioSource = this._audioContext.createMediaStreamSource(this._localTrack.stream), this._audioProcessingNode = this._audioContext.createScriptProcessor(this._procNodeSampleRate, 1, 1)
            }
            _onAudioProcess(e) {
                const t = e.inputBuffer.getChannelData(0),
                    n = [...this._bufferResidue, ...t],
                    i = Date.now();
                let s = 0;
                for (; s + this._vadSampleSize < n.length; s += this._vadSampleSize) {
                    const e = n.slice(s, s + this._vadSampleSize),
                        t = this._vadProcessor.calculateAudioFrameVAD(e.slice());
                    this.emit(a.VAD_SCORE_PUBLISHED, {
                        timestamp: i,
                        score: t,
                        pcmData: e,
                        deviceId: this._localTrack.getDeviceId()
                    })
                }
                this._bufferResidue = n.slice(s, n.length)
            }
            _connectAudioGraph() {
                this._audioProcessingNode.onaudioprocess = this._onAudioProcess, this._audioSource.connect(this._audioProcessingNode), this._audioProcessingNode.connect(this._audioContext.destination)
            }
            _disconnectAudioGraph() {
                this._audioProcessingNode.onaudioprocess = () => {}, this._audioProcessingNode.disconnect(), this._audioSource.disconnect()
            }
            _cleanupResources() {
                this._disconnectAudioGraph(), this._localTrack.stopStream()
            }
            getDeviceId() {
                return this._localTrack.getDeviceId()
            }
            getTrackLabel() {
                return this._localTrack.getDeviceLabel()
            }
            start() {
                this._connectAudioGraph()
            }
            stop() {
                this._disconnectAudioGraph(), this._bufferResidue = []
            }
            destroy() {
                this._destroyed || (this._cleanupResources(), this._destroyed = !0)
            }
        }
    }, function(e, t, n) {
        "use strict";

        function i(e) {
            const t = window.AudioContext || window.webkitAudioContext;
            if (t) return new t(e)
        }
        n.d(t, "a", (function() {
            return i
        }))
    }, function(e, t, n) {
        "use strict";
        n.r(t), n.d(t, "E2E_RTT_CHANGED", (function() {
            return i
        }));
        const i = "e2eping.e2e_rtt_changed"
    }, function(e, t) {
        e.exports = class {
            constructor(e, t, n) {
                this._userId = e, this.setDisplayName(t), this._isLocalStats = n || !1, this.setDominantSpeaker(!1), this.totalDominantSpeakerTime = 0, this._dominantSpeakerStart = 0, this._hasLeft = !1
            }
            getUserId() {
                return this._userId
            }
            getDisplayName() {
                return this.displayName
            }
            setDisplayName(e) {
                this.displayName = e
            }
            isLocalStats() {
                return this._isLocalStats
            }
            isDominantSpeaker() {
                return this._dominantSpeakerStart > 0
            }
            setDominantSpeaker(e) {
                if (!this.isDominantSpeaker() && e) this._dominantSpeakerStart = Date.now();
                else if (this.isDominantSpeaker() && !e) {
                    const e = Date.now() - this._dominantSpeakerStart;
                    this.totalDominantSpeakerTime += e, this._dominantSpeakerStart = 0
                }
            }
            getTotalDominantSpeakerTime() {
                let e = this.totalDominantSpeakerTime;
                return this.isDominantSpeaker() && (e += Date.now() - this._dominantSpeakerStart), e
            }
            hasLeft() {
                return this._hasLeft
            }
            markAsHasLeft() {
                this._hasLeft = !0, this.setDominantSpeaker(!1)
            }
        }
    }, function(e, t, n) {
        "use strict";
        var i = n(19),
            s = n.n(i),
            r = n(49),
            o = n(13),
            a = n(3),
            c = n(6),
            d = n(4),
            u = n(7),
            l = n.n(u);

        function h(e, t, n) {
            return t in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n, e
        }
        t.a = new class {
            constructor() {
                this._eventEmitter = new s.a, this._permissions = {}, o.a.addListener(l.a.DEVICE_LIST_CHANGED, e => this._eventEmitter.emit(r.DEVICE_LIST_CHANGED, e)), o.a.addListener(l.a.DEVICE_LIST_AVAILABLE, e => this._logOutputDevice(this.getAudioOutputDevice(), e)), o.a.addListener(l.a.PERMISSIONS_CHANGED, e => this._handlePermissionsChange(e)), this._permissionsApiSupported = new Promise(e => {
                    if (!navigator.permissions) return void e(!1);
                    const t = this,
                        n = [];
                    n.push(navigator.permissions.query({
                        name: "camera"
                    }).then(e => (this._handlePermissionsChange({
                        [d.c]: this._parsePermissionState(e)
                    }), e.onchange = function() {
                        try {
                            t._handlePermissionsChange({
                                [d.c]: t._parsePermissionState(this)
                            })
                        } catch (e) {}
                    }, !0)).catch(() => !1)), n.push(navigator.permissions.query({
                        name: "microphone"
                    }).then(e => (this._handlePermissionsChange({
                        [d.a]: this._parsePermissionState(e)
                    }), e.onchange = function() {
                        try {
                            t._handlePermissionsChange({
                                [d.a]: t._parsePermissionState(this)
                            })
                        } catch (e) {}
                    }, !0)).catch(() => !1)), Promise.all(n).then(t => e(t.every(e => e)))
                })
            }
            _parsePermissionState(e = {}) {
                const t = e.state || e.status;
                if ("string" != typeof t) throw new TypeError;
                return "granted" === t
            }
            _handlePermissionsChange(e) {
                [d.a, d.c].some(t => t in e && e[t] !== this._permissions[t]) && (this._permissions = function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = null != arguments[t] ? Object(arguments[t]) : {},
                            i = Object.keys(n);
                        "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                            return Object.getOwnPropertyDescriptor(n, e).enumerable
                        })))), i.forEach((function(t) {
                            h(e, t, n[t])
                        }))
                    }
                    return e
                }({}, this._permissions, e), this._eventEmitter.emit(r.PERMISSIONS_CHANGED, this._permissions), (this._permissions[d.a] || this._permissions[d.c]) && this.enumerateDevices(() => {}))
            }
            _logOutputDevice(e, t) {
                const n = t.find(t => "audiooutput" === t.kind && t.deviceId === e);
                n && c.a.sendActiveDeviceListEvent(o.a.getEventDataForActiveDevice(n))
            }
            enumerateDevices(e) {
                o.a.enumerateDevices(e)
            }
            isDeviceListAvailable() {
                return o.a.isDeviceListAvailable()
            }
            isDeviceChangeAvailable(e) {
                return o.a.isDeviceChangeAvailable(e)
            }
            isDevicePermissionGranted(e) {
                return new Promise(t => {
                    e in this._permissions ? t(this._permissions[e]) : this._permissionsApiSupported.then(n => {
                        if (!n) return void t(!1);
                        const i = [];
                        switch (e) {
                            case d.c:
                                i.push(navigator.permissions.query({
                                    name: "camera"
                                }));
                                break;
                            case d.a:
                                i.push(navigator.permissions.query({
                                    name: "microphone"
                                }));
                                break;
                            default:
                                i.push(navigator.permissions.query({
                                    name: "camera"
                                })), i.push(navigator.permissions.query({
                                    name: "microphone"
                                }))
                        }
                        Promise.all(i).then(e => t(e.every(e => {
                            try {
                                return this._parsePermissionState(e)
                            } catch (e) {
                                return !1
                            }
                        })), () => t(!1))
                    })
                })
            }
            isMultipleAudioInputSupported() {
                return !a.a.isFirefox()
            }
            getAudioOutputDevice() {
                return o.a.getAudioOutputDevice()
            }
            setAudioOutputDevice(e) {
                return o.a.getCurrentlyAvailableMediaDevices().length > 0 && this._logOutputDevice(e, o.a.getCurrentlyAvailableMediaDevices()), o.a.setAudioOutputDevice(e)
            }
            addEventListener(e, t) {
                this._eventEmitter.addListener(e, t)
            }
            removeEventListener(e, t) {
                this._eventEmitter.removeListener(e, t)
            }
            emitEvent(e, ...t) {
                this._eventEmitter.emit(e, ...t)
            }
        }
    }, function(e, t) {
        e.exports = {
            IDENTITY_UPDATED: "authentication.identity_updated"
        }
    }, function(module, exports, __webpack_require__) {
        (function(process, global) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            /**
             * [js-md5]{@link https://github.com/emn178/js-md5}
             *
             * @namespace md5
             * @version 0.7.3
             * @author Chen, Yi-Cyuan [emn178@gmail.com]
             * @copyright Chen, Yi-Cyuan 2014-2017
             * @license MIT
             */
            ! function() {
                "use strict";
                var ERROR = "input is invalid type",
                    WINDOW = "object" == typeof window,
                    root = WINDOW ? window : {};
                root.JS_MD5_NO_WINDOW && (WINDOW = !1);
                var WEB_WORKER = !WINDOW && "object" == typeof self,
                    NODE_JS = !root.JS_MD5_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node;
                NODE_JS ? root = global : WEB_WORKER && (root = self);
                var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && "object" == typeof module && module.exports,
                    AMD = __webpack_require__(153),
                    ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer,
                    HEX_CHARS = "0123456789abcdef".split(""),
                    EXTRA = [128, 32768, 8388608, -2147483648],
                    SHIFT = [0, 8, 16, 24],
                    OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"],
                    BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),
                    blocks = [],
                    buffer8;
                if (ARRAY_BUFFER) {
                    var buffer = new ArrayBuffer(68);
                    buffer8 = new Uint8Array(buffer), blocks = new Uint32Array(buffer)
                }!root.JS_MD5_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
                    return "[object Array]" === Object.prototype.toString.call(e)
                }), !ARRAY_BUFFER || !root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
                    return "object" == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
                });
                var createOutputMethod = function(e) {
                        return function(t) {
                            return new Md5(!0).update(t)[e]()
                        }
                    },
                    createMethod = function() {
                        var e = createOutputMethod("hex");
                        NODE_JS && (e = nodeWrap(e)), e.create = function() {
                            return new Md5
                        }, e.update = function(t) {
                            return e.create().update(t)
                        };
                        for (var t = 0; t < OUTPUT_TYPES.length; ++t) {
                            var n = OUTPUT_TYPES[t];
                            e[n] = createOutputMethod(n)
                        }
                        return e
                    },
                    nodeWrap = function(method) {
                        var crypto = eval("require('crypto')"),
                            Buffer = eval("require('buffer').Buffer"),
                            nodeMethod = function(e) {
                                if ("string" == typeof e) return crypto.createHash("md5").update(e, "utf8").digest("hex");
                                if (null == e) throw ERROR;
                                return e.constructor === ArrayBuffer && (e = new Uint8Array(e)), Array.isArray(e) || ArrayBuffer.isView(e) || e.constructor === Buffer ? crypto.createHash("md5").update(new Buffer(e)).digest("hex") : method(e)
                            };
                        return nodeMethod
                    };

                function Md5(e) {
                    if (e) blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks, this.buffer8 = buffer8;
                    else if (ARRAY_BUFFER) {
                        var t = new ArrayBuffer(68);
                        this.buffer8 = new Uint8Array(t), this.blocks = new Uint32Array(t)
                    } else this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0
                }
                Md5.prototype.update = function(e) {
                    if (!this.finalized) {
                        var t, n = typeof e;
                        if ("string" !== n) {
                            if ("object" !== n) throw ERROR;
                            if (null === e) throw ERROR;
                            if (ARRAY_BUFFER && e.constructor === ArrayBuffer) e = new Uint8Array(e);
                            else if (!(Array.isArray(e) || ARRAY_BUFFER && ArrayBuffer.isView(e))) throw ERROR;
                            t = !0
                        }
                        for (var i, s, r = 0, o = e.length, a = this.blocks, c = this.buffer8; r < o;) {
                            if (this.hashed && (this.hashed = !1, a[0] = a[16], a[16] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = a[9] = a[10] = a[11] = a[12] = a[13] = a[14] = a[15] = 0), t)
                                if (ARRAY_BUFFER)
                                    for (s = this.start; r < o && s < 64; ++r) c[s++] = e[r];
                                else
                                    for (s = this.start; r < o && s < 64; ++r) a[s >> 2] |= e[r] << SHIFT[3 & s++];
                            else if (ARRAY_BUFFER)
                                for (s = this.start; r < o && s < 64; ++r)(i = e.charCodeAt(r)) < 128 ? c[s++] = i : i < 2048 ? (c[s++] = 192 | i >> 6, c[s++] = 128 | 63 & i) : i < 55296 || i >= 57344 ? (c[s++] = 224 | i >> 12, c[s++] = 128 | i >> 6 & 63, c[s++] = 128 | 63 & i) : (i = 65536 + ((1023 & i) << 10 | 1023 & e.charCodeAt(++r)), c[s++] = 240 | i >> 18, c[s++] = 128 | i >> 12 & 63, c[s++] = 128 | i >> 6 & 63, c[s++] = 128 | 63 & i);
                            else
                                for (s = this.start; r < o && s < 64; ++r)(i = e.charCodeAt(r)) < 128 ? a[s >> 2] |= i << SHIFT[3 & s++] : i < 2048 ? (a[s >> 2] |= (192 | i >> 6) << SHIFT[3 & s++], a[s >> 2] |= (128 | 63 & i) << SHIFT[3 & s++]) : i < 55296 || i >= 57344 ? (a[s >> 2] |= (224 | i >> 12) << SHIFT[3 & s++], a[s >> 2] |= (128 | i >> 6 & 63) << SHIFT[3 & s++], a[s >> 2] |= (128 | 63 & i) << SHIFT[3 & s++]) : (i = 65536 + ((1023 & i) << 10 | 1023 & e.charCodeAt(++r)), a[s >> 2] |= (240 | i >> 18) << SHIFT[3 & s++], a[s >> 2] |= (128 | i >> 12 & 63) << SHIFT[3 & s++], a[s >> 2] |= (128 | i >> 6 & 63) << SHIFT[3 & s++], a[s >> 2] |= (128 | 63 & i) << SHIFT[3 & s++]);
                            this.lastByteIndex = s, this.bytes += s - this.start, s >= 64 ? (this.start = s - 64, this.hash(), this.hashed = !0) : this.start = s
                        }
                        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this
                    }
                }, Md5.prototype.finalize = function() {
                    if (!this.finalized) {
                        this.finalized = !0;
                        var e = this.blocks,
                            t = this.lastByteIndex;
                        e[t >> 2] |= EXTRA[3 & t], t >= 56 && (this.hashed || this.hash(), e[0] = e[16], e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0), e[14] = this.bytes << 3, e[15] = this.hBytes << 3 | this.bytes >>> 29, this.hash()
                    }
                }, Md5.prototype.hash = function() {
                    var e, t, n, i, s, r, o = this.blocks;
                    this.first ? t = ((t = ((e = ((e = o[0] - 680876937) << 7 | e >>> 25) - 271733879 << 0) ^ (n = ((n = (-271733879 ^ (i = ((i = (-1732584194 ^ 2004318071 & e) + o[1] - 117830708) << 12 | i >>> 20) + e << 0) & (-271733879 ^ e)) + o[2] - 1126478375) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[3] - 1316259209) << 22 | t >>> 10) + n << 0 : (e = this.h0, t = this.h1, n = this.h2, t = ((t += ((e = ((e += ((i = this.h3) ^ t & (n ^ i)) + o[0] - 680876936) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[1] - 389564586) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[2] + 606105819) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[3] - 1044525330) << 22 | t >>> 10) + n << 0), t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + o[4] - 176418897) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[5] + 1200080426) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[6] - 1473231341) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[7] - 45705983) << 22 | t >>> 10) + n << 0, t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + o[8] + 1770035416) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[9] - 1958414417) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[10] - 42063) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[11] - 1990404162) << 22 | t >>> 10) + n << 0, t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + o[12] + 1804603682) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[13] - 40341101) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[14] - 1502002290) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[15] + 1236535329) << 22 | t >>> 10) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[1] - 165796510) << 5 | e >>> 27) + t << 0) ^ t)) + o[6] - 1069501632) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[11] + 643717713) << 14 | n >>> 18) + i << 0) ^ i)) + o[0] - 373897302) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[5] - 701558691) << 5 | e >>> 27) + t << 0) ^ t)) + o[10] + 38016083) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[15] - 660478335) << 14 | n >>> 18) + i << 0) ^ i)) + o[4] - 405537848) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[9] + 568446438) << 5 | e >>> 27) + t << 0) ^ t)) + o[14] - 1019803690) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[3] - 187363961) << 14 | n >>> 18) + i << 0) ^ i)) + o[8] + 1163531501) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[13] - 1444681467) << 5 | e >>> 27) + t << 0) ^ t)) + o[2] - 51403784) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[7] + 1735328473) << 14 | n >>> 18) + i << 0) ^ i)) + o[12] - 1926607734) << 20 | t >>> 12) + n << 0, t = ((t += ((r = (i = ((i += ((s = t ^ n) ^ (e = ((e += (s ^ i) + o[5] - 378558) << 4 | e >>> 28) + t << 0)) + o[8] - 2022574463) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (r ^ t) + o[11] + 1839030562) << 16 | n >>> 16) + i << 0)) + o[14] - 35309556) << 23 | t >>> 9) + n << 0, t = ((t += ((r = (i = ((i += ((s = t ^ n) ^ (e = ((e += (s ^ i) + o[1] - 1530992060) << 4 | e >>> 28) + t << 0)) + o[4] + 1272893353) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (r ^ t) + o[7] - 155497632) << 16 | n >>> 16) + i << 0)) + o[10] - 1094730640) << 23 | t >>> 9) + n << 0, t = ((t += ((r = (i = ((i += ((s = t ^ n) ^ (e = ((e += (s ^ i) + o[13] + 681279174) << 4 | e >>> 28) + t << 0)) + o[0] - 358537222) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (r ^ t) + o[3] - 722521979) << 16 | n >>> 16) + i << 0)) + o[6] + 76029189) << 23 | t >>> 9) + n << 0, t = ((t += ((r = (i = ((i += ((s = t ^ n) ^ (e = ((e += (s ^ i) + o[9] - 640364487) << 4 | e >>> 28) + t << 0)) + o[12] - 421815835) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (r ^ t) + o[15] + 530742520) << 16 | n >>> 16) + i << 0)) + o[2] - 995338651) << 23 | t >>> 9) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[0] - 198630844) << 6 | e >>> 26) + t << 0) | ~n)) + o[7] + 1126891415) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[14] - 1416354905) << 15 | n >>> 17) + i << 0) | ~e)) + o[5] - 57434055) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[12] + 1700485571) << 6 | e >>> 26) + t << 0) | ~n)) + o[3] - 1894986606) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[10] - 1051523) << 15 | n >>> 17) + i << 0) | ~e)) + o[1] - 2054922799) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[8] + 1873313359) << 6 | e >>> 26) + t << 0) | ~n)) + o[15] - 30611744) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[6] - 1560198380) << 15 | n >>> 17) + i << 0) | ~e)) + o[13] + 1309151649) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[4] - 145523070) << 6 | e >>> 26) + t << 0) | ~n)) + o[11] - 1120210379) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[2] + 718787259) << 15 | n >>> 17) + i << 0) | ~e)) + o[9] - 343485551) << 21 | t >>> 11) + n << 0, this.first ? (this.h0 = e + 1732584193 << 0, this.h1 = t - 271733879 << 0, this.h2 = n - 1732584194 << 0, this.h3 = i + 271733878 << 0, this.first = !1) : (this.h0 = this.h0 + e << 0, this.h1 = this.h1 + t << 0, this.h2 = this.h2 + n << 0, this.h3 = this.h3 + i << 0)
                }, Md5.prototype.hex = function() {
                    this.finalize();
                    var e = this.h0,
                        t = this.h1,
                        n = this.h2,
                        i = this.h3;
                    return HEX_CHARS[e >> 4 & 15] + HEX_CHARS[15 & e] + HEX_CHARS[e >> 12 & 15] + HEX_CHARS[e >> 8 & 15] + HEX_CHARS[e >> 20 & 15] + HEX_CHARS[e >> 16 & 15] + HEX_CHARS[e >> 28 & 15] + HEX_CHARS[e >> 24 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[15 & t] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[15 & n] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[i >> 4 & 15] + HEX_CHARS[15 & i] + HEX_CHARS[i >> 12 & 15] + HEX_CHARS[i >> 8 & 15] + HEX_CHARS[i >> 20 & 15] + HEX_CHARS[i >> 16 & 15] + HEX_CHARS[i >> 28 & 15] + HEX_CHARS[i >> 24 & 15]
                }, Md5.prototype.toString = Md5.prototype.hex, Md5.prototype.digest = function() {
                    this.finalize();
                    var e = this.h0,
                        t = this.h1,
                        n = this.h2,
                        i = this.h3;
                    return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255, 255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255, 255 & n, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255, 255 & i, i >> 8 & 255, i >> 16 & 255, i >> 24 & 255]
                }, Md5.prototype.array = Md5.prototype.digest, Md5.prototype.arrayBuffer = function() {
                    this.finalize();
                    var e = new ArrayBuffer(16),
                        t = new Uint32Array(e);
                    return t[0] = this.h0, t[1] = this.h1, t[2] = this.h2, t[3] = this.h3, e
                }, Md5.prototype.buffer = Md5.prototype.arrayBuffer, Md5.prototype.base64 = function() {
                    for (var e, t, n, i = "", s = this.array(), r = 0; r < 15;) e = s[r++], t = s[r++], n = s[r++], i += BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[63 & (e << 4 | t >>> 4)] + BASE64_ENCODE_CHAR[63 & (t << 2 | n >>> 6)] + BASE64_ENCODE_CHAR[63 & n];
                    return e = s[r], i += BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[e << 4 & 63] + "=="
                };
                var exports = createMethod();
                COMMON_JS ? module.exports = exports : (root.md5 = exports, AMD && (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return exports
                }.call(exports, __webpack_require__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)))
            }()
        }).call(this, __webpack_require__(61), __webpack_require__(45))
    }, function(e, t, n) {
        (function(t) {
            var n = /^\s+|\s+$/g,
                i = /^[-+]0x[0-9a-f]+$/i,
                s = /^0b[01]+$/i,
                r = /^0o[0-7]+$/i,
                o = parseInt,
                a = "object" == typeof t && t && t.Object === Object && t,
                c = "object" == typeof self && self && self.Object === Object && self,
                d = a || c || Function("return this")(),
                u = Object.prototype.toString,
                l = Math.max,
                h = Math.min,
                p = function() {
                    return d.Date.now()
                };

            function m(e) {
                var t = typeof e;
                return !!e && ("object" == t || "function" == t)
            }

            function f(e) {
                if ("number" == typeof e) return e;
                if (function(e) {
                        return "symbol" == typeof e || function(e) {
                            return !!e && "object" == typeof e
                        }(e) && "[object Symbol]" == u.call(e)
                    }(e)) return NaN;
                if (m(e)) {
                    var t = "function" == typeof e.valueOf ? e.valueOf() : e;
                    e = m(t) ? t + "" : t
                }
                if ("string" != typeof e) return 0 === e ? e : +e;
                e = e.replace(n, "");
                var a = s.test(e);
                return a || r.test(e) ? o(e.slice(2), a ? 2 : 8) : i.test(e) ? NaN : +e
            }
            e.exports = function(e, t, n) {
                var i, s, r, o, a, c, d = 0,
                    u = !1,
                    g = !1,
                    _ = !0;
                if ("function" != typeof e) throw new TypeError("Expected a function");

                function v(t) {
                    var n = i,
                        r = s;
                    return i = s = void 0, d = t, o = e.apply(r, n)
                }

                function S(e) {
                    return d = e, a = setTimeout(E, t), u ? v(e) : o
                }

                function y(e) {
                    var n = e - c;
                    return void 0 === c || n >= t || n < 0 || g && e - d >= r
                }

                function E() {
                    var e = p();
                    if (y(e)) return b(e);
                    a = setTimeout(E, function(e) {
                        var n = t - (e - c);
                        return g ? h(n, r - (e - d)) : n
                    }(e))
                }

                function b(e) {
                    return a = void 0, _ && i ? v(e) : (i = s = void 0, o)
                }

                function C() {
                    var e = p(),
                        n = y(e);
                    if (i = arguments, s = this, c = e, n) {
                        if (void 0 === a) return S(c);
                        if (g) return a = setTimeout(E, t), v(c)
                    }
                    return void 0 === a && (a = setTimeout(E, t)), o
                }
                return t = f(t) || 0, m(n) && (u = !!n.leading, r = (g = "maxWait" in n) ? l(f(n.maxWait) || 0, t) : r, _ = "trailing" in n ? !!n.trailing : _), C.cancel = function() {
                    void 0 !== a && clearTimeout(a), d = 0, i = c = s = a = void 0
                }, C.flush = function() {
                    return void 0 === a ? o : b(p())
                }, C
            }
        }).call(this, n(45))
    }, function(e, t, n) {
        "use strict";
        async function i(e) {
            const t = new TextEncoder;
            return crypto.subtle.deriveBits({
                name: "HKDF",
                salt: t.encode("JFrameRatchetKey"),
                hash: "SHA-256",
                info: new ArrayBuffer
            }, e, 256)
        }
        async function s(e) {
            return crypto.subtle.importKey("raw", e, "HKDF", !1, ["deriveBits", "deriveKey"])
        }
        n.d(t, "b", (function() {
            return i
        })), n.d(t, "a", (function() {
            return s
        }))
    }, function(e, t, n) {
        "use strict";
        n.d(t, "b", (function() {
            return u
        })), n.d(t, "a", (function() {
            return l
        }));
        var i = n(2),
            s = n(0),
            r = n.n(s),
            o = n(22);
        const a = ["category", "type", "lang", "name"],
            c = ["category", "type", "lang"];

        function d(e, t) {
            let n = 0;
            return c.some(i => 0 !== (n = e[i] > t[i] ? 1 : e[i] < t[i] && -1)), n
        }

        function u(e) {
            const t = new Set,
                n = new Set;
            return $(e).find(">query>feature").each((e, n) => t.add(n.getAttribute("var"))), $(e).find(">query>identity").each((e, t) => n.add({
                type: t.getAttribute("type"),
                name: t.getAttribute("name"),
                category: t.getAttribute("category")
            })), {
                features: t,
                identities: n
            }
        }
        class l extends o.a {
            constructor(e = {}, t = "http://jitsi.org/jitsimeet") {
                if (super(), this.node = t, this.disco = e.disco, !this.disco) throw new Error("Missing strophe-plugins (disco plugin is required)!");
                this.version = "", this.rooms = new Set, this.externalFeatures = new Set;
                const n = e.emuc;
                n.addListener(r.a.EMUC_ROOM_ADDED, e => this._addChatRoom(e)), n.addListener(r.a.EMUC_ROOM_REMOVED, e => this._removeChatRoom(e)), Object.keys(n.rooms).forEach(e => {
                    this._addChatRoom(n.rooms[e])
                }), i.Strophe.addNamespace("CAPS", "http://jabber.org/protocol/caps"), this.disco.addFeature(i.Strophe.NS.CAPS)
            }
            addFeature(e, t = !1, n = !1) {
                this.disco.addFeature(e), this._generateVersion(), n && !this.externalFeatures.has(e) && (this.externalFeatures.add(e), this.rooms.forEach(e => this._updateRoomWithExternalFeatures(e))), t && this.submit()
            }
            removeFeature(e, t = !1, n = !1) {
                this.disco.removeFeature(e), this._generateVersion(), n && this.externalFeatures.has(e) && (this.externalFeatures.delete(e), this.rooms.forEach(e => this._updateRoomWithExternalFeatures(e))), t && this.submit()
            }
            submit() {
                this.rooms.forEach(e => e.sendPresence())
            }
            _updateRoomWithExternalFeatures(e) {
                if (0 === this.externalFeatures.size) e.removeFromPresence("features");
                else {
                    const t = [];
                    this.externalFeatures.forEach(e => {
                        t.push({
                            tagName: "feature",
                            attributes: {
                                var: e
                            }
                        })
                    }), e.addOrReplaceInPresence("features", {
                        children: t
                    })
                }
            }
            getFeaturesAndIdentities(e, t, n = 5e3) {
                return this._getDiscoInfo(e, t, n)
            }
            _getDiscoInfo(e, t, n) {
                return new Promise((i, s) => this.disco.info(e, t, e => {
                    i(u(e))
                }, s, n))
            }
            _addChatRoom(e) {
                this.rooms.add(e), this._fixChatRoomPresenceMap(e), this._updateRoomWithExternalFeatures(e)
            }
            _removeChatRoom(e) {
                this.rooms.delete(e)
            }
            _fixChatRoomPresenceMap(e) {
                e.addOrReplaceInPresence("c", {
                    attributes: {
                        xmlns: i.Strophe.NS.CAPS,
                        hash: "sha-1",
                        node: this.node,
                        ver: this.version
                    }
                })
            }
            _notifyVersionChanged() {
                this.rooms.forEach(e => this._fixChatRoomPresenceMap(e))
            }
            _generateVersion() {
                this.version = function(e, t) {
                    const n = e.sort(d).reduce((e, t) => a.reduce((e, n, i) => e + (0 === i ? "" : "/") + (t[n] ? t[n] : ""), "") + "<", ""),
                        s = t.sort().reduce((e, t) => e + t + "<", "");
                    return Object(i.b64_sha1)(n + s)
                }(this.disco._identities, this.disco._features), this._notifyVersionChanged()
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var i = n(19),
                s = n(5),
                r = n(1),
                o = n(24),
                a = n(67);
            const c = Object(s.getLogger)(e);
            class d extends i.EventEmitter {
                constructor(e, t) {
                    super(), this._createVADProcessor = t, this._vadEmitter = null, this._isVADEmitterRunning = !1, this._detectionServices = [], this._vadInitTracker = Promise.resolve(), this._processVADScore = this._processVADScore.bind(this), e.on(r.TRACK_ADDED, this._trackAdded.bind(this)), e.on(r.TRACK_REMOVED, this._trackRemoved.bind(this)), e.on(r.TRACK_MUTE_CHANGED, this._trackMuteChanged.bind(this))
                }
                addVADDetectionService(e) {
                    this._detectionServices.push(e), e.on(o.DETECTOR_STATE_CHANGE, () => {
                        !this._detectionServices.filter(e => !0 === e.isActive()).length && this._isVADEmitterRunning ? this._stopVADEmitter() : this._isVADEmitterRunning || this._startVADEmitter()
                    })
                }
                _startVADEmitter() {
                    this._vadEmitter && (this._vadEmitter.on(o.VAD_SCORE_PUBLISHED, this._processVADScore), this._vadEmitter.start(), this._isVADEmitterRunning = !0)
                }
                _stopVADEmitter() {
                    this._vadEmitter && (this._vadEmitter.removeListener(o.VAD_SCORE_PUBLISHED, this._processVADScore), this._vadEmitter.stop()), this._isVADEmitterRunning = !1
                }
                _processVADScore(e) {
                    for (const t of this._detectionServices) t.processVADScore(e)
                }
                _changeDetectorsMuteState(e) {
                    for (const t of this._detectionServices) t.changeMuteState(e)
                }
                _trackAdded(e) {
                    e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then(() => this._createVADProcessor()).then(t => a.a.create(e.getDeviceId(), 4096, t)).then(t => {
                        c.debug("Created VAD emitter for track: ", e.getTrackLabel()), this._vadEmitter = t, this._changeDetectorsMuteState(e.isMuted())
                    }).catch(e => {
                        c.warn("Failed to start VADAudioAnalyser", e)
                    }))
                }
                _trackMuteChanged(e) {
                    e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then(() => {
                        this._changeDetectorsMuteState(e.isMuted())
                    }))
                }
                _trackRemoved(e) {
                    e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then(() => {
                        c.debug("Removing track from VAD detection - ", e.getTrackLabel()), this._vadEmitter && (this._stopVADEmitter(), this._vadEmitter.destroy(), this._vadEmitter = null);
                        for (const e of this._detectionServices) e.reset()
                    }))
                }
            }
        }).call(this, "modules/detection/VADAudioAnalyser.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return r
        }));
        var i = n(2),
            s = n(53);
        class r {
            constructor(e = {}) {
                this._connection = e.connection, this._mode = e.mode, this._setSessionID(e.sessionID), this.setStatus(e.status)
            }
            getError() {
                return this._error
            }
            getID() {
                return this._sessionID
            }
            getInitiator() {
                return this._initiator
            }
            getLiveStreamViewURL() {
                return this._liveStreamViewURL
            }
            getStatus() {
                return this._status
            }
            getTerminator() {
                return this._terminator
            }
            getMode() {
                return this._mode
            }
            setError(e) {
                this._error = e
            }
            setLiveStreamViewURL(e) {
                this._liveStreamViewURL = e
            }
            setStatus(e) {
                this._status = e
            }
            setInitiator(e) {
                this._initiator = e
            }
            setTerminator(e) {
                this._terminator = e
            }
            start({
                appData: e,
                broadcastId: t,
                focusMucJid: n,
                streamId: i
            }) {
                return new Promise((r, o) => {
                    this._connection.sendIQ(this._createIQ({
                        action: "start",
                        appData: e,
                        focusMucJid: n,
                        broadcastId: t,
                        streamId: i
                    }), e => {
                        this.setStatus("pending"), this._setSessionID(s.a.getSessionIdFromIq(e)), r()
                    }, e => {
                        this._setErrorFromIq(e), o(e)
                    })
                })
            }
            stop({
                focusMucJid: e
            }) {
                return new Promise((t, n) => {
                    this._connection.sendIQ(this._createIQ({
                        action: "stop",
                        focusMucJid: e
                    }), t, n)
                })
            }
            _createIQ({
                action: e,
                appData: t,
                broadcastId: n,
                focusMucJid: s,
                streamId: r
            }) {
                return Object(i.$iq)({
                    to: s,
                    type: "set"
                }).c("jibri", {
                    xmlns: "http://jitsi.org/protocol/jibri",
                    action: e,
                    app_data: t,
                    recording_mode: this._mode,
                    streamid: r,
                    you_tube_broadcast_id: n
                }).up()
            }
            _setErrorFromIq(e) {
                const t = e.getElementsByTagName("error")[0];
                this.setError(t.children[0].tagName)
            }
            _setSessionID(e) {
                this._sessionID = e
            }
        }
    }, function(e, t, n) {
        "use strict";
        var i = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto),
            s = new Uint8Array(16);

        function r() {
            if (!i) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
            return i(s)
        }
        for (var o = [], a = 0; a < 256; ++a) o.push((a + 256).toString(16).substr(1));
        var c = function(e, t) {
            var n = t || 0,
                i = o;
            return (i[e[n + 0]] + i[e[n + 1]] + i[e[n + 2]] + i[e[n + 3]] + "-" + i[e[n + 4]] + i[e[n + 5]] + "-" + i[e[n + 6]] + i[e[n + 7]] + "-" + i[e[n + 8]] + i[e[n + 9]] + "-" + i[e[n + 10]] + i[e[n + 11]] + i[e[n + 12]] + i[e[n + 13]] + i[e[n + 14]] + i[e[n + 15]]).toLowerCase()
        };
        t.a = function(e, t, n) {
            "string" == typeof e && (t = "binary" === e ? new Uint8Array(16) : null, e = null);
            var i = (e = e || {}).random || (e.rng || r)();
            if (i[6] = 15 & i[6] | 64, i[8] = 63 & i[8] | 128, t) {
                for (var s = n || 0, o = 0; o < 16; ++o) t[s + o] = i[o];
                return t
            }
            return c(i)
        }
    }, function(e, t) {
        var n = {
            trace: 0,
            debug: 1,
            info: 2,
            log: 3,
            warn: 4,
            error: 5
        };
        a.consoleTransport = console;
        var i = [a.consoleTransport];
        a.addGlobalTransport = function(e) {
            -1 === i.indexOf(e) && i.push(e)
        }, a.removeGlobalTransport = function(e) {
            var t = i.indexOf(e); - 1 !== t && i.splice(t, 1)
        };
        var s = {};

        function r() {
            var e = {
                    methodName: "",
                    fileLocation: "",
                    line: null,
                    column: null
                },
                t = new Error,
                n = t.stack ? t.stack.split("\n") : [];
            if (!n || n.length < 3) return e;
            var i = null;
            return n[3] && (i = n[3].match(/\s*at\s*(.+?)\s*\((\S*)\s*:(\d*)\s*:(\d*)\)/)), !i || i.length <= 4 ? (0 === n[2].indexOf("log@") ? e.methodName = n[3].substr(0, n[3].indexOf("@")) : e.methodName = n[2].substr(0, n[2].indexOf("@")), e) : (e.methodName = i[1], e.fileLocation = i[2], e.line = i[3], e.column = i[4], e)
        }

        function o() {
            var e = arguments[0],
                t = arguments[1],
                o = Array.prototype.slice.call(arguments, 2);
            if (!(n[t] < e.level))
                for (var a = !(e.options.disableCallerInfo || s.disableCallerInfo) && r(), c = i.concat(e.transports), d = 0; d < c.length; d++) {
                    var u = c[d],
                        l = u[t];
                    if (l && "function" == typeof l) {
                        var h = [];
                        h.push((new Date).toISOString()), e.id && h.push("[" + e.id + "]"), a && a.methodName.length > 1 && h.push("<" + a.methodName + ">: ");
                        var p = h.concat(o);
                        l.bind(u).apply(u, p)
                    }
                }
        }

        function a(e, t, i, s) {
            this.id = t, this.options = s || {}, this.transports = i, this.transports || (this.transports = []), this.level = n[e];
            for (var r = Object.keys(n), a = 0; a < r.length; a++) this[r[a]] = o.bind(null, this, r[a])
        }
        a.setGlobalOptions = function(e) {
            s = e || {}
        }, a.prototype.setLevel = function(e) {
            this.level = n[e]
        }, e.exports = a, a.levels = {
            TRACE: "trace",
            DEBUG: "debug",
            INFO: "info",
            LOG: "log",
            WARN: "warn",
            ERROR: "error"
        }
    }, function(e, t) {
        e.exports = function(e) {
            return e.webpackPolyfill || (e.deprecate = function() {}, e.paths = [], e.children || (e.children = []), Object.defineProperty(e, "loaded", {
                enumerable: !0,
                get: function() {
                    return e.l
                }
            }), Object.defineProperty(e, "id", {
                enumerable: !0,
                get: function() {
                    return e.i
                }
            }), e.webpackPolyfill = 1), e
        }
    }, function(e, t) {
        var n = e.exports = {
            v: [{
                name: "version",
                reg: /^(\d*)$/
            }],
            o: [{
                name: "origin",
                reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
                names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
                format: "%s %s %d %s IP%d %s"
            }],
            s: [{
                name: "name"
            }],
            i: [{
                name: "description"
            }],
            u: [{
                name: "uri"
            }],
            e: [{
                name: "email"
            }],
            p: [{
                name: "phone"
            }],
            z: [{
                name: "timezones"
            }],
            r: [{
                name: "repeats"
            }],
            t: [{
                name: "timing",
                reg: /^(\d*) (\d*)/,
                names: ["start", "stop"],
                format: "%d %d"
            }],
            c: [{
                name: "connection",
                reg: /^IN IP(\d) (\S*)/,
                names: ["version", "ip"],
                format: "IN IP%d %s"
            }],
            b: [{
                push: "bandwidth",
                reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
                names: ["type", "limit"],
                format: "%s:%s"
            }],
            m: [{
                reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
                names: ["type", "port", "protocol", "payloads"],
                format: "%s %d %s %s"
            }],
            a: [{
                push: "rtp",
                reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
                names: ["payload", "codec", "rate", "encoding"],
                format: function(e) {
                    return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
                }
            }, {
                push: "fmtp",
                reg: /^fmtp:(\d*) ([\S| ]*)/,
                names: ["payload", "config"],
                format: "fmtp:%d %s"
            }, {
                name: "control",
                reg: /^control:(.*)/,
                format: "control:%s"
            }, {
                name: "rtcp",
                reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                names: ["port", "netType", "ipVer", "address"],
                format: function(e) {
                    return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
                }
            }, {
                push: "rtcpFbTrrInt",
                reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                names: ["payload", "value"],
                format: "rtcp-fb:%d trr-int %d"
            }, {
                push: "rtcpFb",
                reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                names: ["payload", "type", "subtype"],
                format: function(e) {
                    return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
                }
            }, {
                push: "ext",
                reg: /^extmap:(\d+)(?:\/(\w+))? (\S*)(?: (\S*))?/,
                names: ["value", "direction", "uri", "config"],
                format: function(e) {
                    return "extmap:%d" + (e.direction ? "/%s" : "%v") + " %s" + (e.config ? " %s" : "")
                }
            }, {
                push: "crypto",
                reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                names: ["id", "suite", "config", "sessionConfig"],
                format: function(e) {
                    return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
                }
            }, {
                name: "setup",
                reg: /^setup:(\w*)/,
                format: "setup:%s"
            }, {
                name: "mid",
                reg: /^mid:([^\s]*)/,
                format: "mid:%s"
            }, {
                name: "msid",
                reg: /^msid:(.*)/,
                format: "msid:%s"
            }, {
                name: "ptime",
                reg: /^ptime:(\d*)/,
                format: "ptime:%d"
            }, {
                name: "maxptime",
                reg: /^maxptime:(\d*)/,
                format: "maxptime:%d"
            }, {
                name: "direction",
                reg: /^(sendrecv|recvonly|sendonly|inactive)/
            }, {
                name: "icelite",
                reg: /^(ice-lite)/
            }, {
                name: "iceUfrag",
                reg: /^ice-ufrag:(\S*)/,
                format: "ice-ufrag:%s"
            }, {
                name: "icePwd",
                reg: /^ice-pwd:(\S*)/,
                format: "ice-pwd:%s"
            }, {
                name: "fingerprint",
                reg: /^fingerprint:(\S*) (\S*)/,
                names: ["type", "hash"],
                format: "fingerprint:%s %s"
            }, {
                push: "candidates",
                reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
                names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
                format: function(e) {
                    var t = "candidate:%s %d %s %d %s %d typ %s";
                    return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), t += null != e["network-id"] ? " network-id %d" : "%v", t += null != e["network-cost"] ? " network-cost %d" : "%v"
                }
            }, {
                name: "endOfCandidates",
                reg: /^(end-of-candidates)/
            }, {
                name: "remoteCandidates",
                reg: /^remote-candidates:(.*)/,
                format: "remote-candidates:%s"
            }, {
                name: "iceOptions",
                reg: /^ice-options:(\S*)/,
                format: "ice-options:%s"
            }, {
                push: "ssrcs",
                reg: /^ssrc:(\d*) ([\w_]*)(?::(.*))?/,
                names: ["id", "attribute", "value"],
                format: function(e) {
                    var t = "ssrc:%d";
                    return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
                }
            }, {
                push: "ssrcGroups",
                reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
                names: ["semantics", "ssrcs"],
                format: "ssrc-group:%s %s"
            }, {
                name: "msidSemantic",
                reg: /^msid-semantic:\s?(\w*) (\S*)/,
                names: ["semantic", "token"],
                format: "msid-semantic: %s %s"
            }, {
                push: "groups",
                reg: /^group:(\w*) (.*)/,
                names: ["type", "mids"],
                format: "group:%s %s"
            }, {
                name: "rtcpMux",
                reg: /^(rtcp-mux)/
            }, {
                name: "rtcpRsize",
                reg: /^(rtcp-rsize)/
            }, {
                name: "sctpmap",
                reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
                names: ["sctpmapNumber", "app", "maxMessageSize"],
                format: function(e) {
                    return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
                }
            }, {
                name: "xGoogleFlag",
                reg: /^x-google-flag:([^\s]*)/,
                format: "x-google-flag:%s"
            }, {
                push: "rids",
                reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
                names: ["id", "direction", "params"],
                format: function(e) {
                    return e.params ? "rid:%s %s %s" : "rid:%s %s"
                }
            }, {
                push: "imageattrs",
                reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
                names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
                format: function(e) {
                    return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
                }
            }, {
                name: "simulcast",
                reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
                names: ["dir1", "list1", "dir2", "list2"],
                format: function(e) {
                    return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
                }
            }, {
                name: "simulcast_03",
                reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
                names: ["value"],
                format: "simulcast: %s"
            }, {
                name: "framerate",
                reg: /^framerate:(\d+(?:$|\.\d+))/,
                format: "framerate:%s"
            }, {
                push: "invalid",
                names: ["value"]
            }]
        };
        Object.keys(n).forEach((function(e) {
            n[e].forEach((function(e) {
                e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
            }))
        }))
    }, function(e, t, n) {
        const i = n(164),
            s = function(e) {
                this.track = e, this.recorder = null, this.data = null, this.name = null, this.startTime = null
            };

        function r(e) {
            if (void 0 === e.recorder) throw new Error("Passed an object to startRecorder which is not a TrackRecorder object");
            e.recorder.start(), e.startTime = new Date
        }

        function o(e) {
            if (void 0 === e.recorder) throw new Error("Passed an object to stopRecorder which is not a TrackRecorder object");
            e.recorder.stop()
        }

        function a() {
            if (MediaRecorder.isTypeSupported("audio/webm")) return "audio/webm";
            if (MediaRecorder.isTypeSupported("audio/ogg")) return "audio/ogg";
            throw new Error("unable to create a MediaRecorder with the right mimetype!")
        }

        function c(e) {
            this.recorders = [], this.fileType = a(), this.isRecording = !1, this.jitsiConference = e
        }
        c.determineCorrectFileType = a, c.prototype.addTrack = function(e) {
            if (e.isAudioTrack()) {
                const t = this.instantiateTrackRecorder(e);
                this.recorders.push(t), this.updateNames(), this.isRecording && r(t)
            }
        }, c.prototype.instantiateTrackRecorder = function(e) {
            const t = new s(e),
                n = t.track.getOriginalStream(),
                i = new MediaStream;
            return n.getAudioTracks().forEach(e => i.addTrack(e)), t.recorder = new MediaRecorder(i, {
                mimeType: this.fileType
            }), t.data = [], t.recorder.ondataavailable = function(e) {
                e.data.size > 0 && t.data.push(e.data)
            }, t
        }, c.prototype.removeTrack = function(e) {
            if (e.isVideoTrack()) return;
            const t = this.recorders;
            let n;
            for (n = 0; n < t.length; n++)
                if (t[n].track.getParticipantId() === e.getParticipantId()) {
                    const e = t[n];
                    this.isRecording ? o(e) : t.splice(n, 1)
                } this.updateNames()
        }, c.prototype.updateNames = function() {
            const e = this.jitsiConference;
            this.recorders.forEach(t => {
                if (t.track.isLocal()) t.name = "the transcriber";
                else {
                    const n = t.track.getParticipantId(),
                        i = e.getParticipantById(n).getDisplayName();
                    "undefined" !== i && (t.name = i)
                }
            })
        }, c.prototype.start = function() {
            if (this.isRecording) throw new Error("audiorecorder is already recording");
            this.isRecording = !0, this.recorders.forEach(e => r(e)), console.log(`Started the recording of the audio. There are currently ${this.recorders.length} recorders active.`)
        }, c.prototype.stop = function() {
            this.isRecording = !1, this.recorders.forEach(e => o(e)), console.log("stopped recording")
        }, c.prototype.download = function() {
            this.recorders.forEach(e => {
                const t = new Blob(e.data, {
                        type: this.fileType
                    }),
                    n = URL.createObjectURL(t),
                    i = document.createElement("a");
                document.body.appendChild(i), i.style = "display: none", i.href = n, i.download = "test." + this.fileType.split("/")[1], i.click(), window.URL.revokeObjectURL(n)
            })
        }, c.prototype.getRecordingResults = function() {
            if (this.isRecording) throw new Error("cannot get blobs because the AudioRecorder is still recording!");
            this.updateNames();
            const e = [];
            return this.recorders.forEach(t => e.push(new i(new Blob(t.data, {
                type: this.fileType
            }), t.name, t.startTime))), e
        }, c.prototype.getFileType = function() {
            return this.fileType
        }, e.exports = c
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return c
        }));
        var i = n(85),
            s = n(27),
            r = n(6),
            o = n(25),
            a = n(8);

        function c(e, t, n) {
            this.appID = e, this.token = t, this.options = n, this.xmpp = new o.e(n, t), this.addEventListener(s.CONNECTION_FAILED, (e, t, n, i) => {
                r.a.sendAnalyticsAndLog(Object(a.B)(e, t, i))
            }), this.addEventListener(s.CONNECTION_DISCONNECTED, e => {
                e && r.a.sendAnalytics(a.m, {
                    message: e
                }), r.a.sendLog(JSON.stringify({
                    id: a.m,
                    msg: e
                }))
            })
        }
        c.prototype.connect = function(e = {}) {
            this.xmpp.connect(e.id, e.password)
        }, c.prototype.attach = function(e) {
            this.xmpp.attach(e)
        }, c.prototype.disconnect = function(...e) {
            return this.xmpp.disconnect(...e)
        }, c.prototype.getJid = function() {
            return this.xmpp.getJid()
        }, c.prototype.setToken = function(e) {
            this.token = e
        }, c.prototype.initJitsiConference = function(e, t) {
            return new i.a({
                name: e,
                config: t,
                connection: this
            })
        }, c.prototype.addEventListener = function(e, t) {
            this.xmpp.addListener(e, t)
        }, c.prototype.removeEventListener = function(e, t) {
            this.xmpp.removeListener(e, t)
        }, c.prototype.getConnectionTimes = function() {
            return this.xmpp.connectionTimes
        }, c.prototype.addFeature = function(e, t = !1) {
            this.xmpp.caps.addFeature(e, t, !0)
        }, c.prototype.removeFeature = function(e, t = !1) {
            this.xmpp.caps.removeFeature(e, t, !0)
        }, c.prototype.getLogs = function() {
            const e = this.xmpp.getJingleLog(),
                t = {};
            t.time = new Date, t.url = window.location.href, t.ua = navigator.userAgent;
            const n = this.xmpp.getXmppLog();
            return n && (t.xmpp = n), e.metadata = t, e
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return ae
            }));
            var i = n(19),
                s = n.n(i),
                r = n(5),
                o = n(33),
                a = n.n(o),
                c = n(2),
                d = n(17),
                u = n(86),
                l = n(1),
                h = n(93),
                p = n(21),
                m = n(15),
                f = n(16),
                g = n(94),
                _ = n(116),
                v = n(13),
                S = n(3),
                y = n(124),
                E = n(125),
                b = n(51),
                C = n(24),
                T = n(126),
                R = n(127),
                A = n(77),
                I = n(128),
                w = n(129),
                D = n(55),
                P = n(130),
                O = n(131),
                N = n(132),
                M = n(133),
                L = n(134),
                k = n(29),
                x = n(135),
                F = n(136),
                j = n(137),
                U = n(6),
                H = n(138),
                V = n.n(H),
                B = n(12),
                J = n.n(B),
                G = n(37),
                K = n.n(G),
                q = n(139),
                W = n(140),
                z = n(26),
                Q = n(25),
                Y = n(20),
                X = n.n(Y),
                Z = n(4),
                ee = n(14),
                te = n.n(ee),
                ne = n(8),
                ie = n(0);

            function se(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? Object(arguments[t]) : {},
                        i = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), i.forEach((function(t) {
                        re(e, t, n[t])
                    }))
                }
                return e
            }

            function re(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const oe = Object(r.getLogger)(e);

            function ae(e) {
                if (!e.name || e.name.toLowerCase() !== e.name) {
                    const e = "Invalid conference name (no conference name passed or it contains invalid characters like capital letters)!";
                    throw oe.error(e), new Error(e)
                }
                this.eventEmitter = new s.a, this.options = e, this.eventManager = new u.a(this), this.participants = {}, this._init(e), this.componentsVersions = new q.a(this), this.jvbJingleSession = null, this.lastDominantSpeaker = null, this.dtmfManager = null, this.somebodySupportsDTMF = !1, this.authEnabled = !1, this.startAudioMuted = !1, this.startVideoMuted = !1, this.startMutedPolicy = {
                    audio: !1,
                    video: !1
                }, this.isMutedByFocus = !1, this.mutedByFocusActor = null, this.isVideoMutedByFocus = !1, this.mutedVideoByFocusActor = null, this.wasStopped = !1, this.properties = {}, this.connectionQuality = new y.a(this, this.eventEmitter, e), this.avgRtpStatsReporter = new F.a(this, e.config.avgRtpStatsN || 15), this._audioOutputProblemDetector = new x.a(this), this.isJvbConnectionInterrupted = !1, this.speakerStatsCollector = new j.a(this), this.deferredStartP2PTask = null;
                const t = parseInt(e.config.p2p && e.config.p2p.backToP2PDelay, 10);
                this.backToP2PDelay = isNaN(t) ? 5 : t, oe.info("backToP2PDelay: " + this.backToP2PDelay), this.isP2PConnectionInterrupted = !1, this.p2p = !1, this.p2pJingleSession = null, this.videoSIPGWHandler = new W.a(this.room), this.recordingManager = new L.a(this.room), this._conferenceJoinAnalyticsEventSent = void 0, this.isE2EESupported() && (oe.info("End-to-End Encryprtion is supported"), this._e2eEncryption = new D.a(this))
            }
            ae.prototype.constructor = ae, ae.resourceCreator = function(e, t) {
                let n;
                if (t) n = K.a.randomHexString(8).toLowerCase();
                else {
                    n = c.Strophe.getNodeFromJid(e).substr(0, 8).toLowerCase();
                    /[0-9a-f]{8}/g.test(n) || (n = K.a.randomHexString(8).toLowerCase())
                }
                return n
            }, ae.prototype._init = function(e = {}) {
                e.connection && (this.connection = e.connection, this.xmpp = this.connection.xmpp, this.eventManager.setupXMPPListeners());
                const {
                    config: t
                } = this.options, n = {
                    disabledCodec: t.videoQuality ? t.videoQuality.disabledCodec : t.p2p && t.p2p.disableH264 && X.a.H264,
                    enforcePreferredCodec: t.videoQuality && t.videoQuality.enforcePreferredCodec,
                    jvbCodec: t.videoQuality && t.videoQuality.preferredCodec || t.preferH264 && X.a.H264,
                    p2pCodec: t.p2p ? t.p2p.preferredCodec || t.p2p.preferH264 && X.a.H264 : X.a.VP8
                };
                this.codecSelection = new _.a(this, n), this._statsCurrentId = t.statisticsId ? t.statisticsId : k.a.callStatsUserName, this.room = this.xmpp.createRoom(this.options.name, se({}, t, {
                    statsId: this._statsCurrentId
                }), ae.resourceCreator), this._onIceConnectionInterrupted = this._onIceConnectionInterrupted.bind(this), this.room.addListener(ie.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), this._onIceConnectionRestored = this._onIceConnectionRestored.bind(this), this.room.addListener(ie.CONNECTION_RESTORED, this._onIceConnectionRestored), this._onIceConnectionEstablished = this._onIceConnectionEstablished.bind(this), this.room.addListener(ie.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), this._updateProperties = this._updateProperties.bind(this), this.room.addListener(ie.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), this._sendConferenceJoinAnalyticsEvent = this._sendConferenceJoinAnalyticsEvent.bind(this), this.room.addListener(ie.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent), this.e2eping = new P.a(this, t, (e, t) => {
                    try {
                        this.sendMessage(e, t, !0)
                    } catch (e) {
                        oe.warn("Failed to send E2E ping request or response.", e && e.msg)
                    }
                }), this.rtc || (this.rtc = new v.a(this, e), this.eventManager.setupRTCListeners()), this.receiveVideoController = new N.a(this, this.rtc), this.sendVideoController = new M.a(this, this.rtc), this.participantConnectionStatus = new b.b(this.rtc, this, {
                    rtcMuteTimeout: t._peerConnStatusRtcMuteTimeout,
                    outOfLastNTimeout: t._peerConnStatusOutOfLastNTimeout
                }), this.participantConnectionStatus.init();
                let i = !0;
                if (t.testing && t.testing.callStatsThreshold && (i = 100 * Math.random() <= t.testing.callStatsThreshold), this.statistics || (this.statistics = new U.a(this.xmpp, {
                        aliasName: this._statsCurrentId,
                        userName: t.statisticsDisplayName ? t.statisticsDisplayName : this.myUserId(),
                        confID: t.confID || `${this.connection.options.hosts.domain}/${this.options.name}`,
                        siteID: t.siteID,
                        customScriptUrl: t.callStatsCustomScriptUrl,
                        callStatsID: t.callStatsID,
                        callStatsSecret: t.callStatsSecret,
                        callStatsApplicationLogsDisabled: t.callStatsApplicationLogsDisabled,
                        enableCallStats: i,
                        roomName: this.options.name,
                        applicationName: t.applicationName,
                        getWiFiStatsMethod: t.getWiFiStatsMethod
                    }), U.a.analytics.addPermanentProperties({
                        callstats_name: this._statsCurrentId
                    }), t.longTasksStatsInterval && this.statistics.attachLongTasksStats(this)), this.eventManager.setupChatRoomListeners(), this.eventManager.setupStatisticsListeners(), t.enableTalkWhileMuted && S.a.supportsVADDetection())
                    if (t.createVADProcessor) {
                        oe.info("Using VAD detection for generating talk while muted events"), this._audioAnalyser || (this._audioAnalyser = new A.a(this, t.createVADProcessor));
                        const e = new w.a;
                        e.on(C.VAD_TALK_WHILE_MUTED, () => this.eventEmitter.emit(l.TALK_WHILE_MUTED)), this._audioAnalyser.addVADDetectionService(e)
                    } else oe.warn("No VAD Processor was provided. Talk while muted detection service was not initialized!");
                if (t.enableNoisyMicDetection && S.a.supportsVADDetection())
                    if (t.createVADProcessor) {
                        this._audioAnalyser || (this._audioAnalyser = new A.a(this, t.createVADProcessor));
                        const e = new I.a;
                        e.on(C.VAD_NOISY_DEVICE, () => this.eventEmitter.emit(l.NOISY_MIC)), this._audioAnalyser.addVADDetectionService(e)
                    } else oe.warn("No VAD Processor was provided. Noisy microphone detection service was not initialized!");
                t.enableNoAudioDetection && (this._noAudioSignalDetection = new T.a(this), this._noAudioSignalDetection.on(C.NO_AUDIO_INPUT, () => {
                    this.eventEmitter.emit(l.NO_AUDIO_INPUT)
                }), this._noAudioSignalDetection.on(C.AUDIO_INPUT_STATE_CHANGE, e => {
                    this.eventEmitter.emit(l.AUDIO_INPUT_STATE_CHANGE, e)
                })), "channelLastN" in t && this.setLastN(t.channelLastN), this.jvb121Status = new O.a(this), this.p2pDominantSpeakerDetection = new R.a(this), t && t.deploymentInfo && t.deploymentInfo.userRegion && this.setLocalParticipantProperty("region", t.deploymentInfo.userRegion), this.setLocalParticipantProperty("codecType", this.codecSelection.getPreferredCodec())
            }, ae.prototype.join = function(e, t = !1) {
                this.room && this.room.join(e, t).then(() => this._maybeSetSITimeout())
            }, ae.prototype.authenticateAndUpgradeRole = function(e) {
                return g.a.call(this, se({}, e, {
                    onCreateResource: ae.resourceCreator
                }))
            }, ae.prototype.isJoined = function() {
                return this.room && this.room.joined
            }, ae.prototype.isP2PEnabled = function() {
                return Boolean(this.options.config.p2p && this.options.config.p2p.enabled) || void 0 === this.options.config.p2p
            }, ae.prototype.isP2PTestModeEnabled = function() {
                return Boolean(this.options.config.testing && this.options.config.testing.p2pTestMode)
            }, ae.prototype.leave = function() {
                if (this.participantConnectionStatus && (this.participantConnectionStatus.dispose(), this.participantConnectionStatus = null), this.avgRtpStatsReporter && (this.avgRtpStatsReporter.dispose(), this.avgRtpStatsReporter = null), this._audioOutputProblemDetector && (this._audioOutputProblemDetector.dispose(), this._audioOutputProblemDetector = null), this.e2eping && (this.e2eping.stop(), this.e2eping = null), this.getLocalTracks().forEach(e => this.onLocalTrackRemoved(e)), this.rtc.closeBridgeChannel(), this._sendConferenceLeftAnalyticsEvent(), this.statistics && this.statistics.dispose(), this._delayedIceFailed && this._delayedIceFailed.cancel(), this.jvbJingleSession && (this.jvbJingleSession.close(), this.jvbJingleSession = null), this.p2pJingleSession && (this.p2pJingleSession.close(), this.p2pJingleSession = null), this.room) {
                    const e = this.room;
                    return e.removeListener(ie.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), e.removeListener(ie.CONNECTION_RESTORED, this._onIceConnectionRestored), e.removeListener(ie.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), e.removeListener(ie.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), e.removeListener(ie.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent), this.eventManager.removeXMPPListeners(), this.room = null, e.leave().then(() => {
                        this.rtc && this.rtc.destroy()
                    }).catch(e => {
                        throw this.getParticipants().forEach(e => this.onMemberLeft(e.getJid())), e
                    })
                }
                return Promise.reject(new Error("The conference is has been already left"))
            }, ae.prototype._getActiveMediaSession = function() {
                return this.isP2PActive() ? this.p2pJingleSession : this.jvbJingleSession
            }, ae.prototype._getMediaSessions = function() {
                const e = [];
                return this.jvbJingleSession && e.push(this.jvbJingleSession), this.p2pJingleSession && e.push(this.p2pJingleSession), e
            }, ae.prototype.getName = function() {
                return this.options.name
            }, ae.prototype.getConnection = function() {
                return this.connection
            }, ae.prototype.isAuthEnabled = function() {
                return this.authEnabled
            }, ae.prototype.isLoggedIn = function() {
                return Boolean(this.authIdentity)
            }, ae.prototype.getAuthLogin = function() {
                return this.authIdentity
            }, ae.prototype.isExternalAuthEnabled = function() {
                return this.room && this.room.moderator.isExternalAuthEnabled()
            }, ae.prototype.getExternalAuthUrl = function(e) {
                return new Promise((t, n) => {
                    this.isExternalAuthEnabled() ? e ? this.room.moderator.getPopupLoginUrl(t, n) : this.room.moderator.getLoginUrl(t, n) : n()
                })
            }, ae.prototype.getLocalTracks = function(e) {
                let t = [];
                return this.rtc && (t = this.rtc.getLocalTracks(e)), t
            }, ae.prototype.getLocalAudioTrack = function() {
                return this.rtc ? this.rtc.getLocalAudioTrack() : null
            }, ae.prototype.getLocalVideoTrack = function() {
                return this.rtc ? this.rtc.getLocalVideoTrack() : null
            }, ae.prototype.getPerformanceStats = function() {
                return {
                    longTasksStats: this.statistics.getLongTasksStats()
                }
            }, ae.prototype.on = function(e, t) {
                this.eventEmitter && this.eventEmitter.on(e, t)
            }, ae.prototype.off = function(e, t) {
                this.eventEmitter && this.eventEmitter.removeListener(e, t)
            }, ae.prototype.addEventListener = ae.prototype.on, ae.prototype.removeEventListener = ae.prototype.off, ae.prototype.addCommandListener = function(e, t) {
                this.room && this.room.addPresenceListener(e, t)
            }, ae.prototype.removeCommandListener = function(e, t) {
                this.room && this.room.removePresenceListener(e, t)
            }, ae.prototype.sendTextMessage = function(e, t = "body") {
                this.room && this.room.sendMessage(e, t)
            }, ae.prototype.sendPrivateTextMessage = function(e, t, n = "body") {
                this.room && this.room.sendPrivateMessage(e, t, n)
            }, ae.prototype.sendCommand = function(e, t) {
                this.room ? this.room.addOrReplaceInPresence(e, t) && this.room.sendPresence() : oe.warn("Not sending a command, room not initialized.")
            }, ae.prototype.sendCommandOnce = function(e, t) {
                this.sendCommand(e, t), this.removeCommand(e)
            }, ae.prototype.removeCommand = function(e) {
                this.room && this.room.removeFromPresence(e)
            }, ae.prototype.setDisplayName = function(e) {
                this.room && this.room.addOrReplaceInPresence("nick", {
                    attributes: {
                        xmlns: "http://jabber.org/protocol/nick"
                    },
                    value: e
                }) && this.room.sendPresence()
            }, ae.prototype.setSubject = function(e) {
                this.room && this.isModerator() ? this.room.setSubject(e) : oe.warn(`Failed to set subject, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
            }, ae.prototype.getTranscriber = function() {
                if (void 0 === this.transcriber) {
                    this.transcriber = new V.a;
                    const e = this.getLocalTracks(Z.a);
                    for (const t of e) this.transcriber.addTrack(t);
                    const t = this.rtc.getRemoteTracks(Z.a);
                    for (const e of t) this.transcriber.addTrack(e)
                }
                return this.transcriber
            }, ae.prototype.getTranscriptionStatus = function() {
                return this.room.transcriptionStatus
            }, ae.prototype.addTrack = function(e) {
                const t = e.getType(),
                    n = this.rtc.getLocalTracks(t);
                return n.length > 0 ? e === n[0] ? Promise.resolve(e) : Promise.reject(new Error(`Cannot add second ${t} track to the conference`)) : this.replaceTrack(null, e)
            }, ae.prototype._fireAudioLevelChangeEvent = function(e, t) {
                const n = this.getActivePeerConnection();
                t && n !== t || this.eventEmitter.emit(l.TRACK_AUDIO_LEVEL_CHANGED, this.myUserId(), e)
            }, ae.prototype._fireMuteChangeEvent = function(e) {
                let t;
                if (this.isMutedByFocus && e.isAudioTrack() && !e.isMuted() ? (this.isMutedByFocus = !1, this.room.muteParticipant(this.room.myroomjid, !1, Z.a)) : this.isVideoMutedByFocus && e.isVideoTrack() && !e.isMuted() && (this.isVideoMutedByFocus = !1, this.room.muteParticipant(this.room.myroomjid, !1, Z.c)), this.mutedByFocusActor && e.isAudioTrack()) {
                    const e = c.Strophe.getResourceFromJid(this.mutedByFocusActor);
                    t = this.participants[e]
                } else if (this.mutedVideoByFocusActor && e.isVideoTrack()) {
                    const e = c.Strophe.getResourceFromJid(this.mutedVideoByFocusActor);
                    t = this.participants[e]
                }
                if (e.isVideoTrack() && !S.a.doesVideoMuteByStreamRemove()) {
                    const t = e.isMuted() ? te.a.NONE : e.getVideoType();
                    this.rtc.setVideoType(t)
                }
                this.eventEmitter.emit(l.TRACK_MUTE_CHANGED, e, t)
            }, ae.prototype._getInitialLocalTracks = function() {
                return this.getLocalTracks().filter(e => e.getType() === Z.a && !this.isStartAudioMuted() || e.getType() === Z.c && !this.isStartVideoMuted())
            }, ae.prototype.onLocalTrackRemoved = function(e) {
                e._setConference(null), this.rtc.removeLocalTrack(e), e.removeEventListener(f.TRACK_MUTE_CHANGED, e.muteHandler), e.removeEventListener(f.TRACK_AUDIO_LEVEL_CHANGED, e.audioLevelHandler), e.isVideoTrack() && e.videoType === te.a.DESKTOP && this.statistics.sendScreenSharingEvent(!1), this.eventEmitter.emit(l.TRACK_REMOVED, e)
            }, ae.prototype.removeTrack = function(e) {
                return this.replaceTrack(e, null)
            }, ae.prototype.replaceTrack = function(e, t) {
                return e && e.disposed || t && t.disposed ? Promise.reject(new p.a(m.TRACK_IS_DISPOSED)) : this._doReplaceTrack(e, t).then(() => (e && this.onLocalTrackRemoved(e), t ? (this._setupNewTrack(t), t.isVideoTrack() && this.rtc.setVideoType(t.getVideoType())) : e && e.isVideoTrack() && this.rtc.setVideoType(te.a.NONE), (this.isMutedByFocus || this.isVideoMutedByFocus) && this._fireMuteChangeEvent(t), Promise.resolve())).catch(e => Promise.reject(new Error(e)))
            }, ae.prototype._doReplaceTrack = function(e, t) {
                const n = [];
                return this.jvbJingleSession ? n.push(this.jvbJingleSession.replaceTrack(e, t)) : oe.info("_doReplaceTrack - no JVB JingleSession"), this.p2pJingleSession ? n.push(this.p2pJingleSession.replaceTrack(e, t)) : oe.info("_doReplaceTrack - no P2P JingleSession"), Promise.all(n)
            }, ae.prototype._setupNewTrack = function(e) {
                if (e.isAudioTrack() || e.isVideoTrack() && e.videoType !== te.a.DESKTOP) {
                    const t = v.a.getCurrentlyAvailableMediaDevices().find(t => t.kind === e.getTrack().kind + "input" && t.label === e.getTrack().label);
                    t && U.a.sendActiveDeviceListEvent(v.a.getEventDataForActiveDevice(t))
                }
                if (e.isVideoTrack()) {
                    const t = "videoType";
                    (e.videoType !== te.a.CAMERA || this.room.getFromPresence(t)) && this.sendCommand(t, {
                        value: e.videoType
                    })
                }
                this.rtc.addLocalTrack(e), e.isAudioTrack() ? this.room.setAudioMute(e.isMuted()) : this.room.setVideoMute(e.isMuted()), e.muteHandler = this._fireMuteChangeEvent.bind(this, e), e.audioLevelHandler = this._fireAudioLevelChangeEvent.bind(this), e.addEventListener(f.TRACK_MUTE_CHANGED, e.muteHandler), e.addEventListener(f.TRACK_AUDIO_LEVEL_CHANGED, e.audioLevelHandler), e._setConference(this), this.eventEmitter.emit(l.TRACK_ADDED, e)
            }, ae.prototype._addLocalTrackAsUnmute = function(e) {
                const t = [];
                return this.jvbJingleSession ? t.push(this.jvbJingleSession.addTrackAsUnmute(e)) : oe.debug("Add local MediaStream as unmute - no JVB Jingle session started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.addTrackAsUnmute(e)) : oe.debug("Add local MediaStream as unmute - no P2P Jingle session started yet"), Promise.allSettled(t).then(() => {
                    e.isVideoTrack() && this.rtc.setVideoType(e.getVideoType())
                })
            }, ae.prototype._removeLocalTrackAsMute = function(e) {
                const t = [];
                return this.jvbJingleSession ? t.push(this.jvbJingleSession.removeTrackAsMute(e)) : oe.debug("Remove local MediaStream - no JVB JingleSession started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.removeTrackAsMute(e)) : oe.debug("Remove local MediaStream - no P2P JingleSession started yet"), Promise.allSettled(t).then(() => {
                    e.isVideoTrack() && this.rtc.setVideoType(te.a.NONE)
                })
            }, ae.prototype.getRole = function() {
                return this.room.role
            }, ae.prototype.isHidden = function() {
                return this.connection ? c.Strophe.getDomainFromJid(this.connection.getJid()) === this.options.config.hiddenDomain : null
            }, ae.prototype.isModerator = function() {
                return this.room ? this.room.isModerator() : null
            }, ae.prototype.lock = function(e) {
                return this.isModerator() ? new Promise((t, n) => {
                    this.room.lockRoom(e || "", () => t(), e => n(e), () => n(d.PASSWORD_NOT_SUPPORTED))
                }) : Promise.reject(new Error("You are not moderator."))
            }, ae.prototype.unlock = function() {
                return this.lock()
            }, ae.prototype.selectParticipant = function(e) {
                this.selectParticipants([e])
            }, ae.prototype.selectParticipants = function(e) {
                if (!Array.isArray(e)) throw new Error("Invalid argument; participantIds must be an array.");
                this.receiveVideoController.selectEndpoints(e)
            }, ae.prototype.getLastN = function() {
                return this.receiveVideoController.getLastN()
            }, ae.prototype.setLastN = function(e) {
                if (!Number.isInteger(e) && !Number.parseInt(e, 10)) throw new Error("Invalid value for lastN: " + e);
                const t = Number(e);
                if (t < -1) throw new RangeError("lastN cannot be smaller than -1");
                if (this.receiveVideoController.setLastN(t), this.p2pJingleSession) {
                    const e = 0 !== t;
                    this.p2pJingleSession.setMediaTransferActive(!0, e).catch(t => {
                        oe.error(`Failed to adjust video transfer status (${e})`, t)
                    })
                }
            }, ae.prototype.isInLastN = function(e) {
                return this.rtc.isInLastN(e)
            }, ae.prototype.getParticipants = function() {
                return Object.values(this.participants)
            }, ae.prototype.getParticipantCount = function(e = !1) {
                let t = this.getParticipants();
                return e || (t = t.filter(e => !e.isHidden())), t.length + 1
            }, ae.prototype.getParticipantById = function(e) {
                return this.participants[e]
            }, ae.prototype.grantOwner = function(e) {
                const t = this.getParticipantById(e);
                t && this.room.setAffiliation(t.getJid(), "owner")
            }, ae.prototype.revokeOwner = function(e) {
                const t = this.getParticipantById(e),
                    n = this.myUserId() === e,
                    i = this.isMembersOnly() ? "member" : "none";
                n ? this.room.setAffiliation(this.room.myroomjid, i) : t && this.room.setAffiliation(t.getJid(), i)
            }, ae.prototype.kickParticipant = function(e, t) {
                const n = this.getParticipantById(e);
                n && this.room.kick(n.getJid(), t)
            }, ae.prototype._maybeClearSITimeout = function() {
                this._sessionInitiateTimeout && (this.jvbJingleSession || this.getParticipantCount() < 2) && (window.clearTimeout(this._sessionInitiateTimeout), this._sessionInitiateTimeout = null)
            }, ae.prototype._maybeSetSITimeout = function() {
                !this.jvbJingleSession && this.getParticipantCount() >= 2 && !this._sessionInitiateTimeout && (this._sessionInitiateTimeout = window.setTimeout(() => {
                    this._sessionInitiateTimeout = null, U.a.sendAnalytics(Object(ne.G)(ne.d, {
                        p2p: !1,
                        value: 5e3
                    }))
                }, 5e3))
            }, ae.prototype.muteParticipant = function(e, t) {
                const n = t || Z.a;
                if (n !== Z.a && n !== Z.c) return void oe.error("Unsupported media type: " + n);
                const i = this.getParticipantById(e);
                i && this.room.muteParticipant(i.getJid(), !0, n)
            }, ae.prototype.onMemberJoined = function(e, t, n, i, s, r, o, a, d, u, p) {
                const m = c.Strophe.getResourceFromJid(e);
                if ("focus" === m || this.myUserId() === m) return;
                const f = new h.a(e, this, t, i, s, r, o);
                f.setRole(n), f.setBotType(a), f.setFeatures(u), f.setIsReplacing(p), this.participants[m] = f, this.eventEmitter.emit(l.USER_JOINED, m, f), this._updateFeatures(f), this.isJoined() && this._maybeStartOrStopP2P(), this._maybeSetSITimeout()
            }, ae.prototype._onMucJoined = function() {
                this._maybeStartOrStopP2P()
            }, ae.prototype._updateFeatures = function(e) {
                e.getFeatures().then(t => {
                    e._supportsDTMF = t.has("urn:xmpp:jingle:dtmf:0"), this.updateDTMFSupport(), t.has(Q.c) && e.setProperty("features_jigasi", !0), t.has(Q.b) && e.setProperty("features_e2ee", !0)
                }).catch(() => !1)
            }, ae.prototype._onMemberBotTypeChanged = function(e, t) {
                const n = this.getParticipants().find(t => t.getJid() === e);
                if (n) {
                    n.setBotType(t);
                    const i = c.Strophe.getResourceFromJid(e);
                    this.eventEmitter.emit(l.BOT_TYPE_CHANGED, i, t)
                }
                n.getBotType() || this._maybeStartOrStopP2P()
            }, ae.prototype.onMemberLeft = function(e) {
                const t = c.Strophe.getResourceFromJid(e);
                if ("focus" === t || this.myUserId() === t) return;
                const n = this.participants[t];
                delete this.participants[t];
                const i = this._getMediaSessions(),
                    s = [];
                for (const e of i) s.push(e.removeRemoteStreamsOnLeave(t));
                Promise.allSettled(s).then(e => {
                    let i = [];
                    e.map(e => e.value).forEach(e => {
                        e && (i = i.concat(e))
                    }), i.forEach(e => {
                        this.eventEmitter.emit(l.TRACK_REMOVED, e)
                    }), n && this.eventEmitter.emit(l.USER_LEFT, t, n), this._maybeStartOrStopP2P(!0), this._maybeClearSITimeout()
                })
            }, ae.prototype.onMemberKicked = function(e, t, n, i, s) {
                if (t === this.myUserId()) return;
                const r = this.participants[t];
                if (e) return this.eventEmitter.emit(l.KICKED, r, i, s), void this.leave();
                const o = this.participants[n];
                o.setIsReplaced(s), this.eventEmitter.emit(l.PARTICIPANT_KICKED, r, o, i)
            }, ae.prototype.onLocalRoleChanged = function(e) {
                this.eventEmitter.emit(l.USER_ROLE_CHANGED, this.myUserId(), e)
            }, ae.prototype.onUserRoleChanged = function(e, t) {
                const n = c.Strophe.getResourceFromJid(e),
                    i = this.getParticipantById(n);
                i && (i.setRole(t), this.eventEmitter.emit(l.USER_ROLE_CHANGED, n, t))
            }, ae.prototype.onDisplayNameChanged = function(e, t) {
                const n = c.Strophe.getResourceFromJid(e),
                    i = this.getParticipantById(n);
                i && i._displayName !== t && (i._displayName = t, this.eventEmitter.emit(l.DISPLAY_NAME_CHANGED, n, t))
            }, ae.prototype.onRemoteTrackAdded = function(e) {
                if (e.isP2P && !this.isP2PActive()) return void oe.info("Trying to add remote P2P track, when not in P2P - IGNORED");
                if (!e.isP2P && this.isP2PActive()) return void oe.info("Trying to add remote JVB track, when in P2P - IGNORED");
                const t = e.getParticipantId(),
                    n = this.getParticipantById(t);
                if (!n) return void oe.error("No participant found for id: " + t);
                n._tracks.push(e), this.transcriber && this.transcriber.addTrack(e);
                const i = this.eventEmitter;
                e.addEventListener(f.TRACK_MUTE_CHANGED, () => i.emit(l.TRACK_MUTE_CHANGED, e)), e.addEventListener(f.TRACK_AUDIO_LEVEL_CHANGED, (e, n) => {
                    this.getActivePeerConnection() === n && i.emit(l.TRACK_AUDIO_LEVEL_CHANGED, t, e)
                }), i.emit(l.TRACK_ADDED, e)
            }, ae.prototype.onCallAccepted = function(e, t) {
                this.p2pJingleSession === e && (oe.info("P2P setAnswer"), this.p2pJingleSession.setAnswer(t), this.eventEmitter.emit(l._MEDIA_SESSION_STARTED, this.p2pJingleSession))
            }, ae.prototype.onTransportInfo = function(e, t) {
                this.p2pJingleSession === e && (oe.info("P2P addIceCandidates"), this.p2pJingleSession.addIceCandidates(t))
            }, ae.prototype.onRemoteTrackRemoved = function(e) {
                this.getParticipants().forEach(t => {
                    const n = t.getTracks();
                    for (let i = 0; i < n.length; i++)
                        if (n[i] === e) {
                            t._tracks.splice(i, 1), this.eventEmitter.emit(l.TRACK_REMOVED, e), this.transcriber && this.transcriber.removeTrack(e);
                            break
                        }
                }, this)
            }, ae.prototype._onIncomingCallP2P = function(e, t) {
                let n;
                !this.isP2PEnabled() && !this.isP2PTestModeEnabled() || S.a.isFirefox() || S.a.isWebKitBased() ? n = {
                    reason: "decline",
                    reasonDescription: "P2P disabled",
                    errorMsg: "P2P mode disabled in the configuration"
                } : this.p2pJingleSession ? n = {
                    reason: "busy",
                    reasonDescription: "P2P already in progress",
                    errorMsg: 'Duplicated P2P "session-initiate"'
                } : this._shouldBeInP2PMode() || (n = {
                    reason: "decline",
                    reasonDescription: "P2P requirements not met",
                    errorMsg: 'Received P2P "session-initiate" when should not be in P2P mode'
                }, U.a.sendAnalytics(Object(ne.G)(ne.h))), n ? this._rejectIncomingCall(e, n) : this._acceptP2PIncomingCall(e, t)
            }, ae.prototype.onIncomingCall = function(e, t, n) {
                if (e.isP2P) this._onIncomingCallP2P(e, t);
                else {
                    if (!this.room.isFocus(e.remoteJid)) {
                        const t = "Rejecting session-initiate from non-focus.";
                        return void this._rejectIncomingCall(e, {
                            reason: "security-error",
                            reasonDescription: t,
                            errorMsg: t
                        })
                    }
                    this._acceptJvbIncomingCall(e, t, n)
                }
            }, ae.prototype._acceptJvbIncomingCall = function(e, t, n) {
                this.jvbJingleSession = e, this.room.connectionTimes["session.initiate"] = n, this._sendConferenceJoinAnalyticsEvent(), this.wasStopped && U.a.sendAnalyticsAndLog(Object(ne.G)(ne.a, {
                    p2p: !1
                }));
                const i = $(t).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("region");
                this.eventEmitter.emit(l.SERVER_REGION_CHANGED, i), this._maybeClearSITimeout(), U.a.sendAnalytics(Object(ne.G)(ne.c, {
                    p2p: !1,
                    value: n
                }));
                try {
                    e.initialize(this.room, this.rtc, se({}, this.options.config, {
                        enableInsertableStreams: this.isE2EEEnabled()
                    }))
                } catch (e) {
                    return J.a.callErrorHandler(e), void oe.error(e)
                }
                this._setBridgeChannel(t, e.peerconnection);
                const s = this._getInitialLocalTracks();
                try {
                    e.acceptOffer(t, () => {
                        this.isP2PActive() && this.jvbJingleSession && this._suspendMediaTransferForJvbConnection(), this.eventEmitter.emit(l._MEDIA_SESSION_STARTED, e), this.isP2PActive() || this.eventEmitter.emit(l._MEDIA_SESSION_ACTIVE_CHANGED, e)
                    }, e => {
                        J.a.callErrorHandler(e), oe.error("Failed to accept incoming Jingle session", e)
                    }, s), this._desktopSharingFrameRate && e.peerconnection.setDesktopSharingFrameRate(this._desktopSharingFrameRate), oe.info("Starting CallStats for JVB connection..."), this.statistics.startCallStats(this.jvbJingleSession.peerconnection, "jitsi"), this.statistics.startRemoteStats(this.jvbJingleSession.peerconnection)
                } catch (e) {
                    J.a.callErrorHandler(e), oe.error(e)
                }
            }, ae.prototype._setBridgeChannel = function(e, t) {
                let n = null;
                const i = $(e).find(">content>transport>web-socket").first();
                1 === i.length && (n = i[0].getAttribute("url")), n ? this.rtc.initializeBridgeChannel(null, n) : this.rtc.initializeBridgeChannel(t, null)
            }, ae.prototype._rejectIncomingCall = function(e, t) {
                t && t.errorMsg && J.a.callErrorHandler(new Error(t.errorMsg)), e.terminate(null, e => {
                    oe.warn("An error occurred while trying to terminate invalid Jingle session", e)
                }, {
                    reason: t && t.reason,
                    reasonDescription: t && t.reasonDescription,
                    sendSessionTerminate: !0
                })
            }, ae.prototype.onCallEnded = function(e, t, n) {
                oe.info(`Call ended: ${t} - ${n} P2P ?${e.isP2P}`), e === this.jvbJingleSession ? (this.wasStopped = !0, U.a.sendAnalytics(Object(ne.G)(ne.e, {
                    p2p: !1
                })), this.statistics && (this.statistics.stopRemoteStats(this.jvbJingleSession.peerconnection), oe.info("Stopping JVB CallStats"), this.statistics.stopCallStats(this.jvbJingleSession.peerconnection)), this.jvbJingleSession = null, this.rtc.onCallEnded()) : e === this.p2pJingleSession ? ("decline" === t && "force JVB121" === n ? (oe.info("In forced JVB 121 mode..."), U.a.analytics.addPermanentProperties({
                    forceJvb121: !0
                })) : "connectivity-error" === t && "ICE FAILED" === n && U.a.analytics.addPermanentProperties({
                    p2pFailed: !0
                }), this._stopP2PSession()) : oe.error("Received onCallEnded for invalid session", e.sid, e.remoteJid, t, n)
            }, ae.prototype.onSuspendDetected = function(e) {
                e.isP2P || (this.leave(), this.eventEmitter.emit(l.SUSPEND_DETECTED))
            }, ae.prototype.updateDTMFSupport = function() {
                let e = !1;
                const t = this.getParticipants();
                for (let n = 0; n < t.length; n += 1)
                    if (t[n].supportsDTMF()) {
                        e = !0;
                        break
                    } e !== this.somebodySupportsDTMF && (this.somebodySupportsDTMF = e, this.eventEmitter.emit(l.DTMF_SUPPORT_CHANGED, e))
            }, ae.prototype.isDTMFSupported = function() {
                return this.somebodySupportsDTMF
            }, ae.prototype.myUserId = function() {
                return this.room && this.room.myroomjid ? c.Strophe.getResourceFromJid(this.room.myroomjid) : null
            }, ae.prototype.sendTones = function(e, t, n) {
                const i = this.getActivePeerConnection();
                i ? i.sendTones(e, t, n) : oe.warn("cannot sendTones: no peer connection")
            }, ae.prototype.startRecording = function(e) {
                return this.room ? this.recordingManager.startRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
            }, ae.prototype.stopRecording = function(e) {
                return this.room ? this.recordingManager.stopRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
            }, ae.prototype.isSIPCallingSupported = function() {
                return !!this.room && this.room.isSIPCallingSupported()
            }, ae.prototype.dial = function(e) {
                return this.room ? this.room.dial(e) : new Promise((e, t) => {
                    t(new Error("The conference is not created yet!"))
                })
            }, ae.prototype.hangup = function() {
                return this.room ? this.room.hangup() : new Promise((e, t) => {
                    t(new Error("The conference is not created yet!"))
                })
            }, ae.prototype.startTranscriber = function() {
                return this.dial("jitsi_meet_transcribe")
            }, ae.prototype.stopTranscriber = ae.prototype.hangup, ae.prototype.getPhoneNumber = function() {
                return this.room ? this.room.getPhoneNumber() : null
            }, ae.prototype.getPhonePin = function() {
                return this.room ? this.room.getPhonePin() : null
            }, ae.prototype.getMeetingUniqueId = function() {
                if (this.room) return this.room.getMeetingId()
            }, ae.prototype.getActivePeerConnection = function() {
                const e = this.isP2PActive() ? this.p2pJingleSession : this.jvbJingleSession;
                return e ? e.peerconnection : null
            }, ae.prototype.getConnectionState = function() {
                const e = this.getActivePeerConnection();
                return e ? e.getConnectionState() : null
            }, ae.prototype.setStartMutedPolicy = function(e) {
                this.isModerator() ? (this.startMutedPolicy = e, this.room.addOrReplaceInPresence("startmuted", {
                    attributes: {
                        audio: e.audio,
                        video: e.video,
                        xmlns: "http://jitsi.org/jitmeet/start-muted"
                    }
                }) && this.room.sendPresence()) : oe.warn(`Failed to set start muted policy, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
            }, ae.prototype.getStartMutedPolicy = function() {
                return this.startMutedPolicy
            }, ae.prototype.isStartAudioMuted = function() {
                return this.startAudioMuted
            }, ae.prototype.isStartVideoMuted = function() {
                return this.startVideoMuted
            }, ae.prototype.getConnectionTimes = function() {
                return this.room.connectionTimes
            }, ae.prototype.setLocalParticipantProperty = function(e, t) {
                this.sendCommand("jitsi_participant_" + e, {
                    value: t
                })
            }, ae.prototype.removeLocalParticipantProperty = function(e) {
                this.removeCommand("jitsi_participant_" + e), this.room.sendPresence()
            }, ae.prototype.getLocalParticipantProperty = function(e) {
                const t = this.room.presMap.nodes.find(t => t.tagName === "jitsi_participant_" + e);
                return t ? t.value : void 0
            }, ae.prototype.sendFeedback = function(e, t) {
                return this.statistics.sendFeedback(e, t)
            }, ae.prototype.isCallstatsEnabled = function() {
                return this.statistics.isCallstatsEnabled()
            }, ae.prototype.getSsrcByTrack = function(e) {
                var t;
                return e.isLocal() ? null === (t = this.getActivePeerConnection()) || void 0 === t ? void 0 : t.getLocalSSRC(e) : e.getSSRC()
            }, ae.prototype._onTrackAttach = function(e, t) {
                const n = e.isLocal();
                let i = null;
                const s = e.isP2P,
                    r = s ? e.getParticipantId() : "jitsi",
                    o = s ? this.p2pJingleSession && this.p2pJingleSession.peerconnection : this.jvbJingleSession && this.jvbJingleSession.peerconnection;
                n ? o && (i = o.getLocalSSRC(e)) : i = e.getSSRC(), t.id && i && o && this.statistics.associateStreamWithVideoTag(o, i, n, r, e.getUsageLabel(), t.id)
            }, ae.prototype.sendApplicationLog = function(e) {
                U.a.sendLog(e)
            }, ae.prototype._isFocus = function(e) {
                return this.room ? this.room.isFocus(e) : null
            }, ae.prototype._fireIncompatibleVersionsEvent = function() {
                this.eventEmitter.emit(l.CONFERENCE_FAILED, d.INCOMPATIBLE_SERVER_VERSIONS)
            }, ae.prototype.sendEndpointMessage = function(e, t) {
                this.rtc.sendChannelMessage(e, t)
            }, ae.prototype.sendEndpointStatsMessage = function(e) {
                this.rtc.sendEndpointStatsMessage(e)
            }, ae.prototype.broadcastEndpointMessage = function(e) {
                this.sendEndpointMessage("", e)
            }, ae.prototype.sendMessage = function(e, t = "", n = !1) {
                const i = typeof e;
                if ("object" === i || !n && "string" === i)
                    if (n) this.sendEndpointMessage(t, e);
                    else {
                        let n = e,
                            s = "body";
                        if ("object" === i) {
                            s = "json-message", n.hasOwnProperty(Q.d) || (n[Q.d] = "");
                            try {
                                n = JSON.stringify(n)
                            } catch (e) {
                                return void oe.error("Can not send a message, stringify failed: ", e)
                            }
                        }
                        t ? this.sendPrivateTextMessage(t, n, s) : this.sendTextMessage(n, s)
                    }
                else oe.error("Can not send a message of type " + i)
            }, ae.prototype.isConnectionInterrupted = function() {
                return this.isP2PActive() ? this.isP2PConnectionInterrupted : this.isJvbConnectionInterrupted
            }, ae.prototype._onConferenceRestarted = function(e) {
                !e.isP2P && this.options.config.enableForcedReload && (this.restartInProgress = !0, this.eventEmitter.emit(l.CONFERENCE_FAILED, d.CONFERENCE_RESTARTED))
            }, ae.prototype._onIceConnectionInterrupted = function(e) {
                e.isP2P ? this.isP2PConnectionInterrupted = !0 : this.isJvbConnectionInterrupted = !0, e.isP2P === this.isP2PActive() && this.eventEmitter.emit(l.CONNECTION_INTERRUPTED)
            }, ae.prototype._onIceConnectionFailed = function(e) {
                e.isP2P ? (U.a.analytics.addPermanentProperties({
                    p2pFailed: !0
                }), this.p2pJingleSession && U.a.sendAnalyticsAndLog(Object(ne.I)(ne.j, {
                    initiator: this.p2pJingleSession.isInitiator
                })), this._stopP2PSession("connectivity-error", "ICE FAILED")) : e && this.jvbJingleSession === e && (this._delayedIceFailed = new E.a(this), this._delayedIceFailed.start(e))
            }, ae.prototype._onIceConnectionRestored = function(e) {
                e.isP2P ? this.isP2PConnectionInterrupted = !1 : (this.isJvbConnectionInterrupted = !1, this._delayedIceFailed && this._delayedIceFailed.cancel()), e.isP2P === this.isP2PActive() && this.eventEmitter.emit(l.CONNECTION_RESTORED)
            }, ae.prototype._acceptP2PIncomingCall = function(e, t) {
                this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = e, this._sendConferenceJoinAnalyticsEvent(), this.p2pJingleSession.initialize(this.room, this.rtc, se({}, this.options.config, {
                    enableInsertableStreams: this.isE2EEEnabled()
                })), oe.info("Starting CallStats for P2P connection...");
                let n = c.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);
                const i = this.participants[n];
                i && (n = i.getStatsID() || n), this.statistics.startCallStats(this.p2pJingleSession.peerconnection, n);
                const s = this.getLocalTracks();
                this.p2pJingleSession.acceptOffer(t, () => {
                    oe.debug('Got RESULT for P2P "session-accept"'), this.eventEmitter.emit(l._MEDIA_SESSION_STARTED, this.p2pJingleSession)
                }, e => {
                    oe.error("Failed to accept incoming P2P Jingle session", e)
                }, s)
            }, ae.prototype._addRemoteJVBTracks = function() {
                this._addRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
            }, ae.prototype._addRemoteP2PTracks = function() {
                this._addRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
            }, ae.prototype._addRemoteTracks = function(e, t) {
                for (const n of t) oe.info(`Adding remote ${e} track: ${n}`), this.onRemoteTrackAdded(n)
            }, ae.prototype._onIceConnectionEstablished = function(e) {
                null !== this.p2pJingleSession && (this.p2pEstablishmentDuration = this.p2pJingleSession.establishmentDuration), null !== this.jvbJingleSession && (this.jvbEstablishmentDuration = this.jvbJingleSession.establishmentDuration);
                let t = !1;
                const n = this.options.config.forceJVB121Ratio;
                if (e.isP2P ? this.p2pJingleSession !== e ? (oe.error("CONNECTION_ESTABLISHED - wrong P2P session instance ?!"), t = !0) : !e.isInitiator && "number" == typeof n && Math.random() < n && (oe.info(`Forcing JVB 121 mode (ratio=${n})...`), U.a.analytics.addPermanentProperties({
                        forceJvb121: !0
                    }), this._stopP2PSession("decline", "force JVB121"), t = !0) : t = !0, !isNaN(this.p2pEstablishmentDuration) && !isNaN(this.jvbEstablishmentDuration)) {
                    const e = this.p2pEstablishmentDuration - this.jvbEstablishmentDuration;
                    U.a.sendAnalytics(ne.p, {
                        value: e
                    })
                }
                e.isP2P === this.isP2PActive() && this.eventEmitter.emit(l.CONNECTION_ESTABLISHED), t || (this._setP2PStatus(!0), this.jvbJingleSession ? this._removeRemoteJVBTracks() : oe.info("Not removing remote JVB tracks - no session yet"), this._addRemoteP2PTracks(), this.jvbJingleSession && this._suspendMediaTransferForJvbConnection(), oe.info("Starting remote stats with p2p connection"), this.statistics.startRemoteStats(this.p2pJingleSession.peerconnection), U.a.sendAnalyticsAndLog(Object(ne.I)(ne.i, {
                    initiator: this.p2pJingleSession.isInitiator
                })))
            }, ae.prototype._updateProperties = function(e = {}) {
                const t = !a()(e, this.properties);
                if (this.properties = e, t) {
                    this.eventEmitter.emit(l.PROPERTIES_CHANGED, this.properties);
                    ["bridge-count", "created-ms"].forEach(t => {
                        void 0 !== e[t] && U.a.analytics.addPermanentProperties({
                            [t.replace("-", "_")]: e[t]
                        })
                    })
                }
            }, ae.prototype.getProperty = function(e) {
                return this.properties[e]
            }, ae.prototype._maybeClearDeferredStartP2P = function() {
                this.deferredStartP2PTask && (oe.info("Cleared deferred start P2P task"), clearTimeout(this.deferredStartP2PTask), this.deferredStartP2PTask = null)
            }, ae.prototype._removeRemoteJVBTracks = function() {
                this._removeRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
            }, ae.prototype._removeRemoteP2PTracks = function() {
                this._removeRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
            }, ae.prototype._removeRemoteTracks = function(e, t) {
                for (const n of t) oe.info(`Removing remote ${e} track: ${n}`), this.onRemoteTrackRemoved(n)
            }, ae.prototype._resumeMediaTransferForJvbConnection = function() {
                oe.info("Resuming media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!0, !0).then(() => {
                    oe.info("Resumed media transfer over the JVB connection!")
                }, e => {
                    oe.error("Failed to resume media transfer over the JVB connection:", e)
                })
            }, ae.prototype._setP2PStatus = function(e) {
                if (this.p2p !== e) {
                    if (this.p2p = e, e) {
                        oe.info("Peer to peer connection established!"), U.a.analytics.addPermanentProperties({
                            p2pFailed: !1,
                            forceJvb121: !1
                        });
                        const e = 0 !== this.getLastN();
                        this.p2pJingleSession.setMediaTransferActive(!0, e).catch(t => {
                            oe.error(`Failed to sync up P2P video transfer status(${e})`, t)
                        })
                    } else oe.info("Peer to peer connection closed!");
                    this.jvbJingleSession && this.statistics.sendConnectionResumeOrHoldEvent(this.jvbJingleSession.peerconnection, !e), this.dtmfManager = null, this.eventEmitter.emit(l.P2P_STATUS, this, this.p2p), this.eventEmitter.emit(l._MEDIA_SESSION_ACTIVE_CHANGED, this._getActiveMediaSession()), this.eventEmitter.emit(this.isConnectionInterrupted() ? l.CONNECTION_INTERRUPTED : l.CONNECTION_RESTORED)
                } else oe.debug("Called _setP2PStatus with the same status: " + e)
            }, ae.prototype._startP2PSession = function(e) {
                if (this._maybeClearDeferredStartP2P(), this.p2pJingleSession) return void oe.error("P2P session already started!");
                this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = this.xmpp.connection.jingle.newP2PJingleSession(this.room.myroomjid, e), oe.info("Created new P2P JingleSession", this.room.myroomjid, e), this._sendConferenceJoinAnalyticsEvent(), this.p2pJingleSession.initialize(this.room, this.rtc, se({}, this.options.config, {
                    enableInsertableStreams: this.isE2EEEnabled()
                })), oe.info("Starting CallStats for P2P connection...");
                let t = c.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);
                const n = this.participants[t];
                n && (t = n.getStatsID() || t), this.statistics.startCallStats(this.p2pJingleSession.peerconnection, t);
                const i = this.getLocalTracks();
                this.p2pJingleSession.invite(i)
            }, ae.prototype._suspendMediaTransferForJvbConnection = function() {
                oe.info("Suspending media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!1, !1).then(() => {
                    oe.info("Suspended media transfer over the JVB connection !")
                }, e => {
                    oe.error("Failed to suspend media transfer over the JVB connection:", e)
                })
            }, ae.prototype._maybeStartOrStopP2P = function(e) {
                if (!this.isP2PEnabled() || this.isP2PTestModeEnabled() || S.a.isFirefox() || S.a.isWebKitBased()) return void oe.info("Auto P2P disabled");
                const t = this.getParticipants(),
                    n = t.length,
                    i = this._shouldBeInP2PMode();
                if (!i && this.deferredStartP2PTask && this._maybeClearDeferredStartP2P(), !this.p2pJingleSession && i) {
                    const i = n && t[0],
                        s = this.myUserId(),
                        r = i.getId();
                    if (s > r) return void oe.debug("I'm the bigger peersId - the other peer should start P2P", s, r);
                    if (s === r) return void oe.error("The same IDs ? ", s, r);
                    const o = i.getJid();
                    if (e) {
                        if (this.deferredStartP2PTask) return void oe.error("Deferred start P2P task's been set already!");
                        oe.info(`Will start P2P with: ${o} after ${this.backToP2PDelay} seconds...`), this.deferredStartP2PTask = setTimeout(this._startP2PSession.bind(this, o), 1e3 * this.backToP2PDelay)
                    } else oe.info("Will start P2P with: " + o), this._startP2PSession(o)
                } else this.p2pJingleSession && !i && (oe.info("Will stop P2P with: " + this.p2pJingleSession.remoteJid), this.p2pJingleSession.isInitiator && n > 1 && U.a.sendAnalyticsAndLog(Object(ne.I)(ne.k)), this._stopP2PSession())
            }, ae.prototype._shouldBeInP2PMode = function() {
                const e = this.getParticipants(),
                    t = e.length,
                    n = void 0 !== e.find(e => "poltergeist" === e.getBotType() || e.hasFeature(Q.c)),
                    i = 1 === t && !n;
                return oe.debug(`P2P? peerCount: ${t}, hasBotPeer: ${n} => ${i}`), i
            }, ae.prototype._stopP2PSession = function(e, t) {
                if (!this.p2pJingleSession) return void oe.error("No P2P session to be stopped!");
                const n = this.isP2PActive();
                n && (this.jvbJingleSession && this._resumeMediaTransferForJvbConnection(), this._removeRemoteP2PTracks()), oe.info("Stopping remote stats for P2P connection"), this.statistics.stopRemoteStats(this.p2pJingleSession.peerconnection), oe.info("Stopping CallStats for P2P connection"), this.statistics.stopCallStats(this.p2pJingleSession.peerconnection), this.p2pJingleSession.terminate(() => {
                    oe.info("P2P session terminate RESULT")
                }, t => {
                    e && oe.error("An error occurred while trying to terminate P2P Jingle session", t)
                }, {
                    reason: e || "success",
                    reasonDescription: t || "Turing off P2P session",
                    sendSessionTerminate: this.room && this.getParticipantById(c.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid))
                }), this.p2pJingleSession = null, this._setP2PStatus(!1), n && (this.jvbJingleSession ? this._addRemoteJVBTracks() : oe.info("Not adding remote JVB tracks - no session yet"))
            }, ae.prototype.isP2PActive = function() {
                return this.p2p
            }, ae.prototype.getP2PConnectionState = function() {
                return this.isP2PActive() ? this.p2pJingleSession.peerconnection.getConnectionState() : null
            }, ae.prototype.setDesktopSharingFrameRate = function(e) {
                return "number" != typeof e || isNaN(e) ? (oe.error(`Invalid value ${e} specified for desktop capture frame rate`), !1) : (this._desktopSharingFrameRate = e, this.jvbJingleSession && this.jvbJingleSession.peerconnection.setDesktopSharingFrameRate(e), this.rtc.setDesktopSharingFrameRate(e), !0)
            }, ae.prototype.startP2PSession = function() {
                const e = this.getParticipants();
                if (1 !== e.length) throw new Error("There must be exactly 1 participant to start the P2P session !"); {
                    const t = e[0].getJid();
                    this._startP2PSession(t)
                }
            }, ae.prototype.stopP2PSession = function() {
                this._stopP2PSession()
            }, ae.prototype.getSpeakerStats = function() {
                return this.speakerStatsCollector.getStats()
            }, ae.prototype.setReceiverConstraints = function(e) {
                this.receiveVideoController.setReceiverConstraints(e)
            }, ae.prototype.setReceiverVideoConstraint = function(e) {
                this.receiveVideoController.setPreferredReceiveMaxFrameHeight(e)
            }, ae.prototype.setSenderVideoConstraint = function(e) {
                return this.sendVideoController.setPreferredSendMaxFrameHeight(e)
            }, ae.prototype.createVideoSIPGWSession = function(e, t) {
                return this.room ? this.videoSIPGWHandler.createVideoSIPGWSession(e, t) : new Error(z.ERROR_NO_CONNECTION)
            }, ae.prototype._sendConferenceJoinAnalyticsEvent = function() {
                const e = this.getMeetingUniqueId();
                !this._conferenceJoinAnalyticsEventSent && e && null !== this.getActivePeerConnection() && (U.a.sendAnalytics(Object(ne.A)("joined", {
                    meetingId: e,
                    participantId: `${e}.${this._statsCurrentId}`
                })), this._conferenceJoinAnalyticsEventSent = Date.now())
            }, ae.prototype._sendConferenceLeftAnalyticsEvent = function() {
                const e = this.getMeetingUniqueId();
                e && this._conferenceJoinAnalyticsEventSent && U.a.sendAnalytics(Object(ne.A)("left", {
                    meetingId: e,
                    participantId: `${e}.${this._statsCurrentId}`,
                    stats: {
                        duration: Math.floor((Date.now() - this._conferenceJoinAnalyticsEventSent) / 1e3),
                        perf: this.getPerformanceStats()
                    }
                }))
            }, ae.prototype._restartMediaSessions = function() {
                this.p2pJingleSession && this.stopP2PSession(), this.jvbJingleSession && this.jvbJingleSession.terminate(null, e => {
                    oe.warn("An error occurred while trying to terminate the JVB session", e)
                }, {
                    reason: "success",
                    reasonDescription: "restart required",
                    requestRestart: !0,
                    sendSessionTerminate: !0
                }), this._maybeStartOrStopP2P(!1)
            }, ae.prototype.isE2EEEnabled = function() {
                return this._e2eEncryption && this._e2eEncryption.isEnabled()
            }, ae.prototype.isE2EESupported = function() {
                return D.a.isSupported(this.options.config)
            }, ae.prototype.toggleE2EE = function(e) {
                this.isE2EESupported() ? this._e2eEncryption.setEnabled(e) : oe.warn("Cannot enable / disable E2EE: platform is not supported.")
            }, ae.prototype.isLobbySupported = function() {
                return Boolean(this.room && this.room.getLobby().isSupported())
            }, ae.prototype.isMembersOnly = function() {
                return Boolean(this.room && this.room.membersOnlyEnabled)
            }, ae.prototype.enableLobby = function() {
                return this.room && this.isModerator() ? this.room.getLobby().enable() : Promise.reject(new Error("The conference not started or user is not moderator"))
            }, ae.prototype.disableLobby = function() {
                this.room && this.isModerator() ? this.room.getLobby().disable() : oe.warn(`Failed to disable lobby, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
            }, ae.prototype.joinLobby = function(e, t) {
                return this.room ? this.room.getLobby().join(e, t) : Promise.reject(new Error("The conference not started"))
            }, ae.prototype.lobbyDenyAccess = function(e) {
                this.room && this.room.getLobby().denyAccess(e)
            }, ae.prototype.lobbyApproveAccess = function(e) {
                this.room && this.room.getLobby().approveAccess(e)
            }, ae.prototype.isAVModerationSupported = function() {
                return Boolean(this.room && this.room.getAVModeration().isSupported())
            }, ae.prototype.enableAVModeration = function(e) {
                this.room && this.isModerator() && (e === Z.a || e === Z.c) ? this.room.getAVModeration().enable(!0, e) : oe.warn(`Failed to enable AV moderation, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
            }, ae.prototype.disableAVModeration = function(e) {
                this.room && this.isModerator() && (e === Z.a || e === Z.c) ? this.room.getAVModeration().enable(!1, e) : oe.warn(`Failed to disable AV moderation, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
            }, ae.prototype.avModerationApprove = function(e, t) {
                if (this.room && this.isModerator() && (e === Z.a || e === Z.c)) {
                    const n = this.getParticipantById(t);
                    if (!n) return;
                    this.room.getAVModeration().approve(e, n.getJid())
                } else oe.warn(`AV moderation skipped , ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
            }
        }).call(this, "JitsiConference.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return b
            }));
            var i = n(5),
                s = n(2),
                r = n(17),
                o = n(1),
                a = n(43),
                c = n(6),
                d = n(92),
                u = n.n(d),
                l = n(4),
                h = n(7),
                p = n.n(h),
                m = n(14),
                f = n.n(m),
                g = n(72),
                _ = n.n(g),
                v = n(8),
                S = n(0),
                y = n.n(S);
            const E = Object(i.getLogger)(e);

            function b(e) {
                this.conference = e, this.xmppListeners = {}, e.on(o.TRACK_MUTE_CHANGED, t => {
                    if (!t.isLocal() || !e.statistics) return;
                    const n = t.isP2P ? e.p2pJingleSession : e.jvbJingleSession,
                        i = n && n.peerconnection || null;
                    e.statistics.sendMuteEvent(i, t.isMuted(), t.getType())
                })
            }
            b.prototype.setupChatRoomListeners = function() {
                const e = this.conference,
                    t = e.room;
                this.chatRoomForwarder = new u.a(t, this.conference.eventEmitter), t.addListener(y.a.ICE_RESTARTING, t => {
                    t.isP2P || e.rtc.closeBridgeChannel()
                }), t.addListener(y.a.PARTICIPANT_FEATURES_CHANGED, (t, n) => {
                    const i = e.getParticipantById(s.Strophe.getResourceFromJid(t));
                    i && (i.setFeatures(n), e.eventEmitter.emit(o.PARTCIPANT_FEATURES_CHANGED, i))
                }), t.addListener(y.a.ICE_RESTART_SUCCESS, (t, n) => {
                    !t.isP2P && e._setBridgeChannel(n, t.peerconnection)
                }), t.addListener(y.a.AUDIO_MUTED_BY_FOCUS, t => {
                    c.a.sendAnalytics(Object(v.K)(l.a)), e.mutedByFocusActor = t, e.rtc.setAudioMute(!0).then(() => {
                        e.isMutedByFocus = !0, e.mutedByFocusActor = null
                    }).catch(t => {
                        e.mutedByFocusActor = null, E.warn("Error while audio muting due to focus request", t)
                    })
                }), t.addListener(y.a.VIDEO_MUTED_BY_FOCUS, t => {
                    c.a.sendAnalytics(Object(v.K)(l.c)), e.mutedVideoByFocusActor = t, e.rtc.setVideoMute(!0).then(() => {
                        e.isVideoMutedByFocus = !0, e.mutedVideoByFocusActor = null
                    }).catch(t => {
                        e.mutedVideoByFocusActor = null, E.warn("Error while video muting due to focus request", t)
                    })
                }), this.chatRoomForwarder.forward(y.a.SUBJECT_CHANGED, o.SUBJECT_CHANGED), this.chatRoomForwarder.forward(y.a.MUC_JOINED, o.CONFERENCE_JOINED), this.chatRoomForwarder.forward(y.a.MEETING_ID_SET, o.CONFERENCE_UNIQUE_ID_SET), t.addListener(y.a.MUC_JOINED, () => {
                    this.conference._onMucJoined(), this.conference.isJvbConnectionInterrupted = !1, Object.keys(t.connectionTimes).forEach(e => {
                        const n = Object(v.C)("conference_" + e, {
                            value: t.connectionTimes[e]
                        });
                        c.a.sendAnalytics(n)
                    }), Object.keys(t.xmpp.connectionTimes).forEach(e => {
                        const n = Object(v.C)("xmpp_" + e, {
                            value: t.xmpp.connectionTimes[e]
                        });
                        c.a.sendAnalytics(n)
                    })
                }), t.addListener(y.a.RENEGOTIATION_FAILED, (t, n) => {
                    n.isP2P || e.eventEmitter.emit(o.CONFERENCE_FAILED, r.OFFER_ANSWER_FAILED, t)
                }), this.chatRoomForwarder.forward(y.a.ROOM_JOIN_ERROR, o.CONFERENCE_FAILED, r.CONNECTION_ERROR), this.chatRoomForwarder.forward(y.a.ROOM_CONNECT_ERROR, o.CONFERENCE_FAILED, r.CONNECTION_ERROR), this.chatRoomForwarder.forward(y.a.ROOM_CONNECT_NOT_ALLOWED_ERROR, o.CONFERENCE_FAILED, r.NOT_ALLOWED_ERROR), this.chatRoomForwarder.forward(y.a.ROOM_CONNECT_MEMBERS_ONLY_ERROR, o.CONFERENCE_FAILED, r.MEMBERS_ONLY_ERROR), this.chatRoomForwarder.forward(y.a.ROOM_MAX_USERS_ERROR, o.CONFERENCE_FAILED, r.CONFERENCE_MAX_USERS), this.chatRoomForwarder.forward(y.a.PASSWORD_REQUIRED, o.CONFERENCE_FAILED, r.PASSWORD_REQUIRED), this.chatRoomForwarder.forward(y.a.AUTHENTICATION_REQUIRED, o.CONFERENCE_FAILED, r.AUTHENTICATION_REQUIRED), this.chatRoomForwarder.forward(y.a.BRIDGE_DOWN, o.CONFERENCE_FAILED, r.VIDEOBRIDGE_NOT_AVAILABLE), t.addListener(y.a.BRIDGE_DOWN, () => c.a.sendAnalytics(Object(v.z)())), t.addListener(y.a.CONNECTION_RESTARTED, t => {
                    e._onConferenceRestarted(t)
                }), this.chatRoomForwarder.forward(y.a.RESERVATION_ERROR, o.CONFERENCE_FAILED, r.RESERVATION_ERROR), this.chatRoomForwarder.forward(y.a.GRACEFUL_SHUTDOWN, o.CONFERENCE_FAILED, r.GRACEFUL_SHUTDOWN), t.addListener(y.a.CONNECTION_ICE_FAILED, t => {
                    e._onIceConnectionFailed(t)
                }), this.chatRoomForwarder.forward(y.a.MUC_DESTROYED, o.CONFERENCE_FAILED, r.CONFERENCE_DESTROYED), this.chatRoomForwarder.forward(y.a.CHAT_ERROR_RECEIVED, o.CONFERENCE_ERROR, r.CHAT_ERROR), this.chatRoomForwarder.forward(y.a.FOCUS_DISCONNECTED, o.CONFERENCE_FAILED, r.FOCUS_DISCONNECTED), t.addListener(y.a.FOCUS_LEFT, () => {
                    c.a.sendAnalytics(Object(v.E)()), e.eventEmitter.emit(o.CONFERENCE_FAILED, r.FOCUS_LEFT)
                }), t.addListener(y.a.SESSION_ACCEPT_TIMEOUT, e => {
                    c.a.sendAnalyticsAndLog(Object(v.G)(v.b, {
                        p2p: e.isP2P
                    }))
                }), t.addListener(y.a.RECORDER_STATE_CHANGED, (t, n) => {
                    if (n) {
                        const i = s.Strophe.getResourceFromJid(n),
                            r = e.getParticipantById(i) || i;
                        "off" === t.getStatus() ? t.setTerminator(r) : "on" === t.getStatus() && t.setInitiator(r)
                    }
                    e.eventEmitter.emit(o.RECORDER_STATE_CHANGED, t)
                }), this.chatRoomForwarder.forward(y.a.TRANSCRIPTION_STATUS_CHANGED, o.TRANSCRIPTION_STATUS_CHANGED), this.chatRoomForwarder.forward(y.a.VIDEO_SIP_GW_AVAILABILITY_CHANGED, o.VIDEO_SIP_GW_AVAILABILITY_CHANGED), this.chatRoomForwarder.forward(y.a.VIDEO_SIP_GW_SESSION_STATE_CHANGED, o.VIDEO_SIP_GW_SESSION_STATE_CHANGED), this.chatRoomForwarder.forward(y.a.PHONE_NUMBER_CHANGED, o.PHONE_NUMBER_CHANGED), t.setParticipantPropertyListener((t, n) => {
                    const i = e.getParticipantById(n);
                    i && i.setProperty(t.tagName.substring("jitsi_participant_".length), t.value)
                }), t.addListener(y.a.KICKED, e.onMemberKicked.bind(e)), t.addListener(y.a.SUSPEND_DETECTED, e.onSuspendDetected.bind(e)), this.chatRoomForwarder.forward(y.a.MUC_LOCK_CHANGED, o.LOCK_STATE_CHANGED), this.chatRoomForwarder.forward(y.a.MUC_MEMBERS_ONLY_CHANGED, o.MEMBERS_ONLY_CHANGED), t.addListener(y.a.MUC_MEMBER_JOINED, e.onMemberJoined.bind(e)), this.chatRoomForwarder.forward(y.a.MUC_LOBBY_MEMBER_JOINED, o.LOBBY_USER_JOINED), this.chatRoomForwarder.forward(y.a.MUC_LOBBY_MEMBER_UPDATED, o.LOBBY_USER_UPDATED), this.chatRoomForwarder.forward(y.a.MUC_LOBBY_MEMBER_LEFT, o.LOBBY_USER_LEFT), t.addListener(y.a.MUC_MEMBER_BOT_TYPE_CHANGED, e._onMemberBotTypeChanged.bind(e)), t.addListener(y.a.MUC_MEMBER_LEFT, e.onMemberLeft.bind(e)), this.chatRoomForwarder.forward(y.a.MUC_LEFT, o.CONFERENCE_LEFT), this.chatRoomForwarder.forward(y.a.MUC_DENIED_ACCESS, o.CONFERENCE_FAILED, r.CONFERENCE_ACCESS_DENIED), t.addListener(y.a.DISPLAY_NAME_CHANGED, e.onDisplayNameChanged.bind(e)), t.addListener(y.a.LOCAL_ROLE_CHANGED, t => {
                    e.onLocalRoleChanged(t), e.statistics && e.isModerator() && e.on(o.RECORDER_STATE_CHANGED, e => {
                        const t = {
                            error: e.getError(),
                            id: "recorder_status",
                            status: e.getStatus()
                        };
                        c.a.sendLog(JSON.stringify(t))
                    })
                }), t.addListener(y.a.MUC_ROLE_CHANGED, e.onUserRoleChanged.bind(e)), t.addListener(_.a.IDENTITY_UPDATED, (t, n) => {
                    e.authEnabled = t, e.authIdentity = n, e.eventEmitter.emit(o.AUTH_STATUS_CHANGED, t, n)
                }), t.addListener(y.a.MESSAGE_RECEIVED, (t, n, i, r) => {
                    const a = s.Strophe.getResourceFromJid(t);
                    e.eventEmitter.emit(o.MESSAGE_RECEIVED, a, n, r)
                }), t.addListener(y.a.PRIVATE_MESSAGE_RECEIVED, (t, n, i, r) => {
                    const a = s.Strophe.getResourceFromJid(t);
                    e.eventEmitter.emit(o.PRIVATE_MESSAGE_RECEIVED, a, n, r)
                }), t.addListener(y.a.PRESENCE_STATUS, (t, n) => {
                    const i = s.Strophe.getResourceFromJid(t),
                        r = e.getParticipantById(i);
                    r && r._status !== n && (r._status = n, e.eventEmitter.emit(o.USER_STATUS_CHANGED, i, n))
                }), t.addListener(y.a.JSON_MESSAGE_RECEIVED, (t, n) => {
                    const i = s.Strophe.getResourceFromJid(t),
                        r = e.getParticipantById(i);
                    r ? e.eventEmitter.emit(o.ENDPOINT_MESSAGE_RECEIVED, r, n) : E.warn("Ignored XMPPEvents.JSON_MESSAGE_RECEIVED for not existing participant: " + t, n)
                }), t.addPresenceListener("startmuted", (t, n) => {
                    let i = !1;
                    if (e.myUserId() === n && e.isModerator()) i = !0;
                    else {
                        const t = e.getParticipantById(n);
                        t && t.isModerator() && (i = !0)
                    }
                    if (!i) return;
                    const s = "true" === t.attributes.audio,
                        r = "true" === t.attributes.video;
                    let a = !1;
                    s !== e.startMutedPolicy.audio && (e.startMutedPolicy.audio = s, a = !0), r !== e.startMutedPolicy.video && (e.startMutedPolicy.video = r, a = !0), a && e.eventEmitter.emit(o.START_MUTED_POLICY_CHANGED, e.startMutedPolicy)
                }), e.statistics && (t.addListener(y.a.CONNECTION_ICE_FAILED, t => {
                    e.statistics.sendIceConnectionFailedEvent(t.peerconnection)
                }), t.addListener(y.a.ADD_ICE_CANDIDATE_FAILED, (t, n) => {
                    e.statistics.sendAddIceCandidateFailed(t, n)
                }))
            }, b.prototype.setupRTCListeners = function() {
                const e = this.conference,
                    t = e.rtc;
                t.addListener(p.a.REMOTE_TRACK_ADDED, e.onRemoteTrackAdded.bind(e)), t.addListener(p.a.REMOTE_TRACK_REMOVED, e.onRemoteTrackRemoved.bind(e)), t.addListener(p.a.DOMINANT_SPEAKER_CHANGED, (t, n) => {
                    if (e.lastDominantSpeaker !== t && e.room) {
                        if (e.lastDominantSpeaker = t, e.eventEmitter.emit(o.DOMINANT_SPEAKER_CHANGED, t, n), n && n.length) {
                            const i = n.slice(0);
                            e.myUserId !== t && i.splice(0, 0, t), i.length > a.b && i.splice(a.b, i.length - a.b), e.statistics && e.statistics.setSpeakerList(i)
                        }
                        e.statistics && e.myUserId() === t && e.statistics.sendDominantSpeakerEvent(e.room.roomjid)
                    }
                }), t.addListener(p.a.DATA_CHANNEL_OPEN, () => {
                    const t = window.performance.now(),
                        n = "data.channel.opened";
                    E.log(`(TIME) ${n}:\t`, t), e.room.connectionTimes[n] = t, c.a.sendAnalytics(Object(v.C)(n, {
                        value: t
                    })), e.eventEmitter.emit(o.DATA_CHANNEL_OPENED)
                }), t.addListener(p.a.ENDPOINT_MESSAGE_RECEIVED, (t, n) => {
                    const i = e.getParticipantById(t);
                    i ? e.eventEmitter.emit(o.ENDPOINT_MESSAGE_RECEIVED, i, n) : E.warn("Ignored ENDPOINT_MESSAGE_RECEIVED for not existing participant: " + t, n)
                }), t.addListener(p.a.ENDPOINT_STATS_RECEIVED, (t, n) => {
                    const i = e.getParticipantById(t);
                    i ? e.eventEmitter.emit(o.ENDPOINT_STATS_RECEIVED, i, n) : E.warn("Ignoring ENDPOINT_STATS_RECEIVED for a non-existant participant: " + t)
                }), t.addListener(p.a.LOCAL_UFRAG_CHANGED, (e, t) => {
                    e.isP2P || c.a.sendLog(JSON.stringify({
                        id: "local_ufrag",
                        value: t
                    }))
                }), t.addListener(p.a.REMOTE_UFRAG_CHANGED, (e, t) => {
                    e.isP2P || c.a.sendLog(JSON.stringify({
                        id: "remote_ufrag",
                        value: t
                    }))
                }), t.addListener(p.a.CREATE_ANSWER_FAILED, (t, n) => {
                    e.statistics.sendCreateAnswerFailed(t, n), n.isP2P || e.eventEmitter.emit(o.CONFERENCE_FAILED, r.OFFER_ANSWER_FAILED, t)
                }), t.addListener(p.a.CREATE_OFFER_FAILED, (t, n) => {
                    e.statistics.sendCreateOfferFailed(t, n), n.isP2P || e.eventEmitter.emit(o.CONFERENCE_FAILED, r.OFFER_ANSWER_FAILED, t)
                }), t.addListener(p.a.SET_LOCAL_DESCRIPTION_FAILED, (t, n) => {
                    e.statistics.sendSetLocalDescFailed(t, n), n.isP2P || e.eventEmitter.emit(o.CONFERENCE_FAILED, r.OFFER_ANSWER_FAILED, t)
                }), t.addListener(p.a.SET_REMOTE_DESCRIPTION_FAILED, (t, n) => {
                    e.statistics.sendSetRemoteDescFailed(t, n), n.isP2P || e.eventEmitter.emit(o.CONFERENCE_FAILED, r.OFFER_ANSWER_FAILED, t)
                }), t.addListener(p.a.LOCAL_TRACK_SSRC_UPDATED, (t, n) => {
                    t.isVideoTrack() && t.videoType === f.a.DESKTOP && e.statistics.sendScreenSharingEvent(!0, n)
                })
            }, b.prototype.removeXMPPListeners = function() {
                const e = this.conference;
                Object.keys(this.xmppListeners).forEach(t => {
                    e.xmpp.removeListener(t, this.xmppListeners[t])
                }), this.xmppListeners = {}
            }, b.prototype.setupXMPPListeners = function() {
                const e = this.conference;
                this._addConferenceXMPPListener(y.a.CALL_INCOMING, e.onIncomingCall.bind(e)), this._addConferenceXMPPListener(y.a.CALL_ACCEPTED, e.onCallAccepted.bind(e)), this._addConferenceXMPPListener(y.a.TRANSPORT_INFO, e.onTransportInfo.bind(e)), this._addConferenceXMPPListener(y.a.CALL_ENDED, e.onCallEnded.bind(e)), this._addConferenceXMPPListener(y.a.START_MUTED_FROM_FOCUS, (t, n) => {
                    e.options.config.ignoreStartMuted || (e.startAudioMuted = t, e.startVideoMuted = n, e.getLocalTracks().forEach(t => {
                        switch (t.getType()) {
                            case l.a:
                                e.startAudioMuted && t.mute();
                                break;
                            case l.c:
                                e.startVideoMuted && t.mute()
                        }
                    }), e.eventEmitter.emit(o.STARTED_MUTED))
                }), this._addConferenceXMPPListener(y.a.CONFERENCE_TIMESTAMP_RECEIVED, t => {
                    e.eventEmitter.emit(o.CONFERENCE_CREATED_TIMESTAMP, t)
                }), this._addConferenceXMPPListener(y.a.AV_MODERATION_CHANGED, (t, n, i) => {
                    const s = e.getParticipants().find(e => e.getJid() === i);
                    e.eventEmitter.emit(o.AV_MODERATION_CHANGED, {
                        enabled: t,
                        mediaType: n,
                        actor: s
                    })
                }), this._addConferenceXMPPListener(y.a.AV_MODERATION_PARTICIPANT_APPROVED, (t, n) => {
                    const i = e.getParticipantById(s.Strophe.getResourceFromJid(n));
                    i && e.eventEmitter.emit(o.AV_MODERATION_PARTICIPANT_APPROVED, {
                        participant: i,
                        mediaType: t
                    })
                }), this._addConferenceXMPPListener(y.a.AV_MODERATION_APPROVED, t => e.eventEmitter.emit(o.AV_MODERATION_APPROVED, {
                    mediaType: t
                }))
            }, b.prototype._addConferenceXMPPListener = function(e, t) {
                this.xmppListeners[e] = t, this.conference.xmpp.addListener(e, t)
            }, b.prototype.setupStatisticsListeners = function() {
                const e = this.conference;
                e.statistics && (e.statistics.addAudioLevelListener((t, n, i, s) => {
                    e.rtc.setAudioLevel(t, n, i, s)
                }), e.statistics.addBeforeDisposedListener(() => {
                    e.eventEmitter.emit(o.BEFORE_STATISTICS_DISPOSED)
                }), e.options.config.startSilent || e.statistics.addByteSentStatsListener((t, n) => {
                    e.getLocalTracks(l.a).forEach(e => {
                        const i = t.getLocalSSRC(e);
                        i && n.hasOwnProperty(i) && e._onByteSentStatsReceived(t, n[i])
                    })
                }))
            }
        }).call(this, "JitsiConferenceEventManager.js")
    }, function(e, t, n) {
        "use strict";
        (function(e, i) {
            n.d(t, "a", (function() {
                return a
            }));
            var s = n(57),
                r = n(5);
            const o = Object(r.getLogger)(e);
            class a extends s.a {
                constructor() {
                    super(), o.info(`This appears to be ${this.getName()}, ver: ${this.getVersion()}`)
                }
                doesVideoMuteByStreamRemove() {
                    return this.isChromiumBased() || this.isWebKitBased()
                }
                isChromiumBased() {
                    return (this.isChrome() || this.isElectron() || this.isNWJS() || this.isOpera()) && !this.isWebKitBased()
                }
                isWebKitBased() {
                    return this._bowser.isEngine("webkit") && void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getUserMedia && void 0 !== window.RTCRtpTransceiver && Object.keys(RTCRtpTransceiver.prototype).indexOf("currentDirection") > -1
                }
                isTwa() {
                    return "matchMedia" in window && window.matchMedia("(display-mode:standalone)").matches
                }
                isSupported() {
                    return this.isChromiumBased() && this._getChromiumBasedVersion() >= 72 || this.isFirefox() || this.isReactNative() || this.isWebKitBased()
                }
                isUserInteractionRequiredForUnmute() {
                    return this.isFirefox() && this.isVersionLessThan("68")
                }
                supportsVideoMuteOnConnInterrupted() {
                    return this.isChromiumBased() || this.isReactNative()
                }
                supportsBandwidthStatistics() {
                    return !this.isFirefox() && !this.isWebKitBased()
                }
                supportsCodecPreferences() {
                    return Boolean(window.RTCRtpTransceiver && "setCodecPreferences" in window.RTCRtpTransceiver.prototype && window.RTCRtpReceiver && void 0 !== window.RTCRtpReceiver.getCapabilities) && !this.isWebKitBased()
                }
                supportsDeviceChangeEvent() {
                    return navigator.mediaDevices && void 0 !== navigator.mediaDevices.ondevicechange && void 0 !== navigator.mediaDevices.addEventListener
                }
                supportsLocalCandidateRttStatistics() {
                    return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased()
                }
                supportsPerformanceObserver() {
                    return void 0 !== window.PerformanceObserver && PerformanceObserver.supportedEntryTypes.indexOf("longtask") > -1
                }
                supportsReceiverStats() {
                    return void 0 !== window.RTCRtpReceiver && Object.keys(RTCRtpReceiver.prototype).indexOf("getSynchronizationSources") > -1 && !this.isWebKitBased()
                }
                supportsRTTStatistics() {
                    return !this.isFirefox()
                }
                usesSdpMungingForSimulcast() {
                    return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased()
                }
                usesAdapter() {
                    return !this.isReactNative()
                }
                usesRidsForSimulcast() {
                    return !1
                }
                supportsGetDisplayMedia() {
                    return void 0 !== navigator.getDisplayMedia || void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getDisplayMedia
                }
                supportsInsertableStreams() {
                    if (void 0 === window.RTCRtpSender || !window.RTCRtpSender.prototype.createEncodedStreams) return !1;
                    const e = new ReadableStream;
                    try {
                        return window.postMessage(e, "*", [e]), !0
                    } catch (e) {
                        return !1
                    }
                }
                supportsAudioRed() {
                    return Boolean(window.RTCRtpSender && window.RTCRtpSender.getCapabilities && window.RTCRtpSender.getCapabilities("audio").codecs.some(e => "audio/red" === e.mimeType) && window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("audio").codecs.some(e => "audio/red" === e.mimeType))
                }
                supportsUnifiedPlan() {
                    return !this.isReactNative()
                }
                supportsVADDetection() {
                    return this.isChromiumBased()
                }
                _getChromiumBasedVersion() {
                    if (this.isChromiumBased()) {
                        if (this.isNWJS()) return Number.parseInt(i.versions.chromium, 10);
                        const e = navigator.userAgent;
                        if (e.match(/Chrome/)) {
                            return Number.parseInt(e.match(/Chrome\/([\d.]+)/)[1], 10)
                        }
                    }
                    return -1
                }
            }
        }).call(this, "modules/browser/BrowserCapabilities.js", n(61))
    }, function(e, t, n) {
        e.exports = function(e) {
            var t = {};

            function n(i) {
                if (t[i]) return t[i].exports;
                var s = t[i] = {
                    i: i,
                    l: !1,
                    exports: {}
                };
                return e[i].call(s.exports, s, s.exports, n), s.l = !0, s.exports
            }
            return n.m = e, n.c = t, n.d = function(e, t, i) {
                n.o(e, t) || Object.defineProperty(e, t, {
                    enumerable: !0,
                    get: i
                })
            }, n.r = function(e) {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                }), Object.defineProperty(e, "__esModule", {
                    value: !0
                })
            }, n.t = function(e, t) {
                if (1 & t && (e = n(e)), 8 & t) return e;
                if (4 & t && "object" == typeof e && e && e.__esModule) return e;
                var i = Object.create(null);
                if (n.r(i), Object.defineProperty(i, "default", {
                        enumerable: !0,
                        value: e
                    }), 2 & t && "string" != typeof e)
                    for (var s in e) n.d(i, s, function(t) {
                        return e[t]
                    }.bind(null, s));
                return i
            }, n.n = function(e) {
                var t = e && e.__esModule ? function() {
                    return e.default
                } : function() {
                    return e
                };
                return n.d(t, "a", t), t
            }, n.o = function(e, t) {
                return Object.prototype.hasOwnProperty.call(e, t)
            }, n.p = "", n(n.s = 90)
        }({
            17: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i = n(18),
                    s = function() {
                        function e() {}
                        return e.getFirstMatch = function(e, t) {
                            var n = t.match(e);
                            return n && n.length > 0 && n[1] || ""
                        }, e.getSecondMatch = function(e, t) {
                            var n = t.match(e);
                            return n && n.length > 1 && n[2] || ""
                        }, e.matchAndReturnConst = function(e, t, n) {
                            if (e.test(t)) return n
                        }, e.getWindowsVersionName = function(e) {
                            switch (e) {
                                case "NT":
                                    return "NT";
                                case "XP":
                                    return "XP";
                                case "NT 5.0":
                                    return "2000";
                                case "NT 5.1":
                                    return "XP";
                                case "NT 5.2":
                                    return "2003";
                                case "NT 6.0":
                                    return "Vista";
                                case "NT 6.1":
                                    return "7";
                                case "NT 6.2":
                                    return "8";
                                case "NT 6.3":
                                    return "8.1";
                                case "NT 10.0":
                                    return "10";
                                default:
                                    return
                            }
                        }, e.getMacOSVersionName = function(e) {
                            var t = e.split(".").splice(0, 2).map((function(e) {
                                return parseInt(e, 10) || 0
                            }));
                            if (t.push(0), 10 === t[0]) switch (t[1]) {
                                case 5:
                                    return "Leopard";
                                case 6:
                                    return "Snow Leopard";
                                case 7:
                                    return "Lion";
                                case 8:
                                    return "Mountain Lion";
                                case 9:
                                    return "Mavericks";
                                case 10:
                                    return "Yosemite";
                                case 11:
                                    return "El Capitan";
                                case 12:
                                    return "Sierra";
                                case 13:
                                    return "High Sierra";
                                case 14:
                                    return "Mojave";
                                case 15:
                                    return "Catalina";
                                default:
                                    return
                            }
                        }, e.getAndroidVersionName = function(e) {
                            var t = e.split(".").splice(0, 2).map((function(e) {
                                return parseInt(e, 10) || 0
                            }));
                            if (t.push(0), !(1 === t[0] && t[1] < 5)) return 1 === t[0] && t[1] < 6 ? "Cupcake" : 1 === t[0] && t[1] >= 6 ? "Donut" : 2 === t[0] && t[1] < 2 ? "Eclair" : 2 === t[0] && 2 === t[1] ? "Froyo" : 2 === t[0] && t[1] > 2 ? "Gingerbread" : 3 === t[0] ? "Honeycomb" : 4 === t[0] && t[1] < 1 ? "Ice Cream Sandwich" : 4 === t[0] && t[1] < 4 ? "Jelly Bean" : 4 === t[0] && t[1] >= 4 ? "KitKat" : 5 === t[0] ? "Lollipop" : 6 === t[0] ? "Marshmallow" : 7 === t[0] ? "Nougat" : 8 === t[0] ? "Oreo" : 9 === t[0] ? "Pie" : void 0
                        }, e.getVersionPrecision = function(e) {
                            return e.split(".").length
                        }, e.compareVersions = function(t, n, i) {
                            void 0 === i && (i = !1);
                            var s = e.getVersionPrecision(t),
                                r = e.getVersionPrecision(n),
                                o = Math.max(s, r),
                                a = 0,
                                c = e.map([t, n], (function(t) {
                                    var n = o - e.getVersionPrecision(t),
                                        i = t + new Array(n + 1).join(".0");
                                    return e.map(i.split("."), (function(e) {
                                        return new Array(20 - e.length).join("0") + e
                                    })).reverse()
                                }));
                            for (i && (a = o - Math.min(s, r)), o -= 1; o >= a;) {
                                if (c[0][o] > c[1][o]) return 1;
                                if (c[0][o] === c[1][o]) {
                                    if (o === a) return 0;
                                    o -= 1
                                } else if (c[0][o] < c[1][o]) return -1
                            }
                        }, e.map = function(e, t) {
                            var n, i = [];
                            if (Array.prototype.map) return Array.prototype.map.call(e, t);
                            for (n = 0; n < e.length; n += 1) i.push(t(e[n]));
                            return i
                        }, e.getBrowserAlias = function(e) {
                            return i.BROWSER_ALIASES_MAP[e]
                        }, e.getBrowserTypeByAlias = function(e) {
                            return i.BROWSER_MAP[e] || ""
                        }, e
                    }();
                t.default = s, e.exports = t.default
            },
            18: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0, t.BROWSER_ALIASES_MAP = {
                    "Amazon Silk": "amazon_silk",
                    "Android Browser": "android",
                    Bada: "bada",
                    BlackBerry: "blackberry",
                    Chrome: "chrome",
                    Chromium: "chromium",
                    Epiphany: "epiphany",
                    Firefox: "firefox",
                    Focus: "focus",
                    Generic: "generic",
                    "Google Search": "google_search",
                    Googlebot: "googlebot",
                    "Internet Explorer": "ie",
                    "K-Meleon": "k_meleon",
                    Maxthon: "maxthon",
                    "Microsoft Edge": "edge",
                    "MZ Browser": "mz",
                    "NAVER Whale Browser": "naver",
                    Opera: "opera",
                    "Opera Coast": "opera_coast",
                    PhantomJS: "phantomjs",
                    Puffin: "puffin",
                    QupZilla: "qupzilla",
                    QQ: "qq",
                    QQLite: "qqlite",
                    Safari: "safari",
                    Sailfish: "sailfish",
                    "Samsung Internet for Android": "samsung_internet",
                    SeaMonkey: "seamonkey",
                    Sleipnir: "sleipnir",
                    Swing: "swing",
                    Tizen: "tizen",
                    "UC Browser": "uc",
                    Vivaldi: "vivaldi",
                    "WebOS Browser": "webos",
                    WeChat: "wechat",
                    "Yandex Browser": "yandex",
                    Roku: "roku"
                }, t.BROWSER_MAP = {
                    amazon_silk: "Amazon Silk",
                    android: "Android Browser",
                    bada: "Bada",
                    blackberry: "BlackBerry",
                    chrome: "Chrome",
                    chromium: "Chromium",
                    epiphany: "Epiphany",
                    firefox: "Firefox",
                    focus: "Focus",
                    generic: "Generic",
                    googlebot: "Googlebot",
                    google_search: "Google Search",
                    ie: "Internet Explorer",
                    k_meleon: "K-Meleon",
                    maxthon: "Maxthon",
                    edge: "Microsoft Edge",
                    mz: "MZ Browser",
                    naver: "NAVER Whale Browser",
                    opera: "Opera",
                    opera_coast: "Opera Coast",
                    phantomjs: "PhantomJS",
                    puffin: "Puffin",
                    qupzilla: "QupZilla",
                    qq: "QQ Browser",
                    qqlite: "QQ Browser Lite",
                    safari: "Safari",
                    sailfish: "Sailfish",
                    samsung_internet: "Samsung Internet for Android",
                    seamonkey: "SeaMonkey",
                    sleipnir: "Sleipnir",
                    swing: "Swing",
                    tizen: "Tizen",
                    uc: "UC Browser",
                    vivaldi: "Vivaldi",
                    webos: "WebOS Browser",
                    wechat: "WeChat",
                    yandex: "Yandex Browser"
                }, t.PLATFORMS_MAP = {
                    tablet: "tablet",
                    mobile: "mobile",
                    desktop: "desktop",
                    tv: "tv"
                }, t.OS_MAP = {
                    WindowsPhone: "Windows Phone",
                    Windows: "Windows",
                    MacOS: "macOS",
                    iOS: "iOS",
                    Android: "Android",
                    WebOS: "WebOS",
                    BlackBerry: "BlackBerry",
                    Bada: "Bada",
                    Tizen: "Tizen",
                    Linux: "Linux",
                    ChromeOS: "Chrome OS",
                    PlayStation4: "PlayStation 4",
                    Roku: "Roku"
                }, t.ENGINE_MAP = {
                    EdgeHTML: "EdgeHTML",
                    Blink: "Blink",
                    Trident: "Trident",
                    Presto: "Presto",
                    Gecko: "Gecko",
                    WebKit: "WebKit"
                }
            },
            90: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i, s = (i = n(91)) && i.__esModule ? i : {
                        default: i
                    },
                    r = n(18);

                function o(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                var a = function() {
                    function e() {}
                    var t, n;
                    return e.getParser = function(e, t) {
                        if (void 0 === t && (t = !1), "string" != typeof e) throw new Error("UserAgent should be a string");
                        return new s.default(e, t)
                    }, e.parse = function(e) {
                        return new s.default(e).getResult()
                    }, t = e, (n = [{
                        key: "BROWSER_MAP",
                        get: function() {
                            return r.BROWSER_MAP
                        }
                    }, {
                        key: "ENGINE_MAP",
                        get: function() {
                            return r.ENGINE_MAP
                        }
                    }, {
                        key: "OS_MAP",
                        get: function() {
                            return r.OS_MAP
                        }
                    }, {
                        key: "PLATFORMS_MAP",
                        get: function() {
                            return r.PLATFORMS_MAP
                        }
                    }]) && o(t, n), e
                }();
                t.default = a, e.exports = t.default
            },
            91: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i = c(n(92)),
                    s = c(n(93)),
                    r = c(n(94)),
                    o = c(n(95)),
                    a = c(n(17));

                function c(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                var d = function() {
                    function e(e, t) {
                        if (void 0 === t && (t = !1), null == e || "" === e) throw new Error("UserAgent parameter can't be empty");
                        this._ua = e, this.parsedResult = {}, !0 !== t && this.parse()
                    }
                    var t = e.prototype;
                    return t.getUA = function() {
                        return this._ua
                    }, t.test = function(e) {
                        return e.test(this._ua)
                    }, t.parseBrowser = function() {
                        var e = this;
                        this.parsedResult.browser = {};
                        var t = i.default.find((function(t) {
                            if ("function" == typeof t.test) return t.test(e);
                            if (t.test instanceof Array) return t.test.some((function(t) {
                                return e.test(t)
                            }));
                            throw new Error("Browser's test function is not valid")
                        }));
                        return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser
                    }, t.getBrowser = function() {
                        return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser()
                    }, t.getBrowserName = function(e) {
                        return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || ""
                    }, t.getBrowserVersion = function() {
                        return this.getBrowser().version
                    }, t.getOS = function() {
                        return this.parsedResult.os ? this.parsedResult.os : this.parseOS()
                    }, t.parseOS = function() {
                        var e = this;
                        this.parsedResult.os = {};
                        var t = s.default.find((function(t) {
                            if ("function" == typeof t.test) return t.test(e);
                            if (t.test instanceof Array) return t.test.some((function(t) {
                                return e.test(t)
                            }));
                            throw new Error("Browser's test function is not valid")
                        }));
                        return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os
                    }, t.getOSName = function(e) {
                        var t = this.getOS().name;
                        return e ? String(t).toLowerCase() || "" : t || ""
                    }, t.getOSVersion = function() {
                        return this.getOS().version
                    }, t.getPlatform = function() {
                        return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform()
                    }, t.getPlatformType = function(e) {
                        void 0 === e && (e = !1);
                        var t = this.getPlatform().type;
                        return e ? String(t).toLowerCase() || "" : t || ""
                    }, t.parsePlatform = function() {
                        var e = this;
                        this.parsedResult.platform = {};
                        var t = r.default.find((function(t) {
                            if ("function" == typeof t.test) return t.test(e);
                            if (t.test instanceof Array) return t.test.some((function(t) {
                                return e.test(t)
                            }));
                            throw new Error("Browser's test function is not valid")
                        }));
                        return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform
                    }, t.getEngine = function() {
                        return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine()
                    }, t.getEngineName = function(e) {
                        return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || ""
                    }, t.parseEngine = function() {
                        var e = this;
                        this.parsedResult.engine = {};
                        var t = o.default.find((function(t) {
                            if ("function" == typeof t.test) return t.test(e);
                            if (t.test instanceof Array) return t.test.some((function(t) {
                                return e.test(t)
                            }));
                            throw new Error("Browser's test function is not valid")
                        }));
                        return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine
                    }, t.parse = function() {
                        return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this
                    }, t.getResult = function() {
                        return Object.assign({}, this.parsedResult)
                    }, t.satisfies = function(e) {
                        var t = this,
                            n = {},
                            i = 0,
                            s = {},
                            r = 0;
                        if (Object.keys(e).forEach((function(t) {
                                var o = e[t];
                                "string" == typeof o ? (s[t] = o, r += 1) : "object" == typeof o && (n[t] = o, i += 1)
                            })), i > 0) {
                            var o = Object.keys(n),
                                a = o.find((function(e) {
                                    return t.isOS(e)
                                }));
                            if (a) {
                                var c = this.satisfies(n[a]);
                                if (void 0 !== c) return c
                            }
                            var d = o.find((function(e) {
                                return t.isPlatform(e)
                            }));
                            if (d) {
                                var u = this.satisfies(n[d]);
                                if (void 0 !== u) return u
                            }
                        }
                        if (r > 0) {
                            var l = Object.keys(s).find((function(e) {
                                return t.isBrowser(e, !0)
                            }));
                            if (void 0 !== l) return this.compareVersion(s[l])
                        }
                    }, t.isBrowser = function(e, t) {
                        void 0 === t && (t = !1);
                        var n = this.getBrowserName().toLowerCase(),
                            i = e.toLowerCase(),
                            s = a.default.getBrowserTypeByAlias(i);
                        return t && s && (i = s.toLowerCase()), i === n
                    }, t.compareVersion = function(e) {
                        var t = [0],
                            n = e,
                            i = !1,
                            s = this.getBrowserVersion();
                        if ("string" == typeof s) return ">" === e[0] || "<" === e[0] ? (n = e.substr(1), "=" === e[1] ? (i = !0, n = e.substr(2)) : t = [], ">" === e[0] ? t.push(1) : t.push(-1)) : "=" === e[0] ? n = e.substr(1) : "~" === e[0] && (i = !0, n = e.substr(1)), t.indexOf(a.default.compareVersions(s, n, i)) > -1
                    }, t.isOS = function(e) {
                        return this.getOSName(!0) === String(e).toLowerCase()
                    }, t.isPlatform = function(e) {
                        return this.getPlatformType(!0) === String(e).toLowerCase()
                    }, t.isEngine = function(e) {
                        return this.getEngineName(!0) === String(e).toLowerCase()
                    }, t.is = function(e) {
                        return this.isBrowser(e) || this.isOS(e) || this.isPlatform(e)
                    }, t.some = function(e) {
                        var t = this;
                        return void 0 === e && (e = []), e.some((function(e) {
                            return t.is(e)
                        }))
                    }, e
                }();
                t.default = d, e.exports = t.default
            },
            92: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i, s = (i = n(17)) && i.__esModule ? i : {
                        default: i
                    },
                    r = /version\/(\d+(\.?_?\d+)+)/i,
                    o = [{
                        test: [/googlebot/i],
                        describe: function(e) {
                            var t = {
                                    name: "Googlebot"
                                },
                                n = s.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/opera/i],
                        describe: function(e) {
                            var t = {
                                    name: "Opera"
                                },
                                n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/opr\/|opios/i],
                        describe: function(e) {
                            var t = {
                                    name: "Opera"
                                },
                                n = s.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/SamsungBrowser/i],
                        describe: function(e) {
                            var t = {
                                    name: "Samsung Internet for Android"
                                },
                                n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/Whale/i],
                        describe: function(e) {
                            var t = {
                                    name: "NAVER Whale Browser"
                                },
                                n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/MZBrowser/i],
                        describe: function(e) {
                            var t = {
                                    name: "MZ Browser"
                                },
                                n = s.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/focus/i],
                        describe: function(e) {
                            var t = {
                                    name: "Focus"
                                },
                                n = s.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/swing/i],
                        describe: function(e) {
                            var t = {
                                    name: "Swing"
                                },
                                n = s.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/coast/i],
                        describe: function(e) {
                            var t = {
                                    name: "Opera Coast"
                                },
                                n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/yabrowser/i],
                        describe: function(e) {
                            var t = {
                                    name: "Yandex Browser"
                                },
                                n = s.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/ucbrowser/i],
                        describe: function(e) {
                            var t = {
                                    name: "UC Browser"
                                },
                                n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/Maxthon|mxios/i],
                        describe: function(e) {
                            var t = {
                                    name: "Maxthon"
                                },
                                n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/epiphany/i],
                        describe: function(e) {
                            var t = {
                                    name: "Epiphany"
                                },
                                n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/puffin/i],
                        describe: function(e) {
                            var t = {
                                    name: "Puffin"
                                },
                                n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/sleipnir/i],
                        describe: function(e) {
                            var t = {
                                    name: "Sleipnir"
                                },
                                n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/k-meleon/i],
                        describe: function(e) {
                            var t = {
                                    name: "K-Meleon"
                                },
                                n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/micromessenger/i],
                        describe: function(e) {
                            var t = {
                                    name: "WeChat"
                                },
                                n = s.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/qqbrowser/i],
                        describe: function(e) {
                            var t = {
                                    name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
                                },
                                n = s.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/msie|trident/i],
                        describe: function(e) {
                            var t = {
                                    name: "Internet Explorer"
                                },
                                n = s.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/\sedg\//i],
                        describe: function(e) {
                            var t = {
                                    name: "Microsoft Edge"
                                },
                                n = s.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/edg([ea]|ios)/i],
                        describe: function(e) {
                            var t = {
                                    name: "Microsoft Edge"
                                },
                                n = s.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/vivaldi/i],
                        describe: function(e) {
                            var t = {
                                    name: "Vivaldi"
                                },
                                n = s.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/seamonkey/i],
                        describe: function(e) {
                            var t = {
                                    name: "SeaMonkey"
                                },
                                n = s.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/sailfish/i],
                        describe: function(e) {
                            var t = {
                                    name: "Sailfish"
                                },
                                n = s.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/silk/i],
                        describe: function(e) {
                            var t = {
                                    name: "Amazon Silk"
                                },
                                n = s.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/phantom/i],
                        describe: function(e) {
                            var t = {
                                    name: "PhantomJS"
                                },
                                n = s.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/slimerjs/i],
                        describe: function(e) {
                            var t = {
                                    name: "SlimerJS"
                                },
                                n = s.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
                        describe: function(e) {
                            var t = {
                                    name: "BlackBerry"
                                },
                                n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/(web|hpw)[o0]s/i],
                        describe: function(e) {
                            var t = {
                                    name: "WebOS Browser"
                                },
                                n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/bada/i],
                        describe: function(e) {
                            var t = {
                                    name: "Bada"
                                },
                                n = s.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/tizen/i],
                        describe: function(e) {
                            var t = {
                                    name: "Tizen"
                                },
                                n = s.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/qupzilla/i],
                        describe: function(e) {
                            var t = {
                                    name: "QupZilla"
                                },
                                n = s.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/firefox|iceweasel|fxios/i],
                        describe: function(e) {
                            var t = {
                                    name: "Firefox"
                                },
                                n = s.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/chromium/i],
                        describe: function(e) {
                            var t = {
                                    name: "Chromium"
                                },
                                n = s.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/chrome|crios|crmo/i],
                        describe: function(e) {
                            var t = {
                                    name: "Chrome"
                                },
                                n = s.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/GSA/i],
                        describe: function(e) {
                            var t = {
                                    name: "Google Search"
                                },
                                n = s.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: function(e) {
                            var t = !e.test(/like android/i),
                                n = e.test(/android/i);
                            return t && n
                        },
                        describe: function(e) {
                            var t = {
                                    name: "Android Browser"
                                },
                                n = s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/playstation 4/i],
                        describe: function(e) {
                            var t = {
                                    name: "PlayStation 4"
                                },
                                n = s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/safari|applewebkit/i],
                        describe: function(e) {
                            var t = {
                                    name: "Safari"
                                },
                                n = s.default.getFirstMatch(r, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/.*/i],
                        describe: function(e) {
                            var t = -1 !== e.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
                            return {
                                name: s.default.getFirstMatch(t, e),
                                version: s.default.getSecondMatch(t, e)
                            }
                        }
                    }];
                t.default = o, e.exports = t.default
            },
            93: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i, s = (i = n(17)) && i.__esModule ? i : {
                        default: i
                    },
                    r = n(18),
                    o = [{
                        test: [/Roku\/DVP/],
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
                            return {
                                name: r.OS_MAP.Roku,
                                version: t
                            }
                        }
                    }, {
                        test: [/windows phone/i],
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
                            return {
                                name: r.OS_MAP.WindowsPhone,
                                version: t
                            }
                        }
                    }, {
                        test: [/windows/i],
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e),
                                n = s.default.getWindowsVersionName(t);
                            return {
                                name: r.OS_MAP.Windows,
                                version: t,
                                versionName: n
                            }
                        }
                    }, {
                        test: [/macintosh/i],
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."),
                                n = s.default.getMacOSVersionName(t),
                                i = {
                                    name: r.OS_MAP.MacOS,
                                    version: t
                                };
                            return n && (i.versionName = n), i
                        }
                    }, {
                        test: [/(ipod|iphone|ipad)/i],
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
                            return {
                                name: r.OS_MAP.iOS,
                                version: t
                            }
                        }
                    }, {
                        test: function(e) {
                            var t = !e.test(/like android/i),
                                n = e.test(/android/i);
                            return t && n
                        },
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e),
                                n = s.default.getAndroidVersionName(t),
                                i = {
                                    name: r.OS_MAP.Android,
                                    version: t
                                };
                            return n && (i.versionName = n), i
                        }
                    }, {
                        test: [/(web|hpw)[o0]s/i],
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e),
                                n = {
                                    name: r.OS_MAP.WebOS
                                };
                            return t && t.length && (n.version = t), n
                        }
                    }, {
                        test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || s.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || s.default.getFirstMatch(/\bbb(\d+)/i, e);
                            return {
                                name: r.OS_MAP.BlackBerry,
                                version: t
                            }
                        }
                    }, {
                        test: [/bada/i],
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
                            return {
                                name: r.OS_MAP.Bada,
                                version: t
                            }
                        }
                    }, {
                        test: [/tizen/i],
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
                            return {
                                name: r.OS_MAP.Tizen,
                                version: t
                            }
                        }
                    }, {
                        test: [/linux/i],
                        describe: function() {
                            return {
                                name: r.OS_MAP.Linux
                            }
                        }
                    }, {
                        test: [/CrOS/],
                        describe: function() {
                            return {
                                name: r.OS_MAP.ChromeOS
                            }
                        }
                    }, {
                        test: [/PlayStation 4/],
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
                            return {
                                name: r.OS_MAP.PlayStation4,
                                version: t
                            }
                        }
                    }];
                t.default = o, e.exports = t.default
            },
            94: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i, s = (i = n(17)) && i.__esModule ? i : {
                        default: i
                    },
                    r = n(18),
                    o = [{
                        test: [/googlebot/i],
                        describe: function() {
                            return {
                                type: "bot",
                                vendor: "Google"
                            }
                        }
                    }, {
                        test: [/huawei/i],
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/(can-l01)/i, e) && "Nova",
                                n = {
                                    type: r.PLATFORMS_MAP.mobile,
                                    vendor: "Huawei"
                                };
                            return t && (n.model = t), n
                        }
                    }, {
                        test: [/nexus\s*(?:7|8|9|10).*/i],
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.tablet,
                                vendor: "Nexus"
                            }
                        }
                    }, {
                        test: [/ipad/i],
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.tablet,
                                vendor: "Apple",
                                model: "iPad"
                            }
                        }
                    }, {
                        test: [/kftt build/i],
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.tablet,
                                vendor: "Amazon",
                                model: "Kindle Fire HD 7"
                            }
                        }
                    }, {
                        test: [/silk/i],
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.tablet,
                                vendor: "Amazon"
                            }
                        }
                    }, {
                        test: [/tablet(?! pc)/i],
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.tablet
                            }
                        }
                    }, {
                        test: function(e) {
                            var t = e.test(/ipod|iphone/i),
                                n = e.test(/like (ipod|iphone)/i);
                            return t && !n
                        },
                        describe: function(e) {
                            var t = s.default.getFirstMatch(/(ipod|iphone)/i, e);
                            return {
                                type: r.PLATFORMS_MAP.mobile,
                                vendor: "Apple",
                                model: t
                            }
                        }
                    }, {
                        test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.mobile,
                                vendor: "Nexus"
                            }
                        }
                    }, {
                        test: [/[^-]mobi/i],
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.mobile
                            }
                        }
                    }, {
                        test: function(e) {
                            return "blackberry" === e.getBrowserName(!0)
                        },
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.mobile,
                                vendor: "BlackBerry"
                            }
                        }
                    }, {
                        test: function(e) {
                            return "bada" === e.getBrowserName(!0)
                        },
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.mobile
                            }
                        }
                    }, {
                        test: function(e) {
                            return "windows phone" === e.getBrowserName()
                        },
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.mobile,
                                vendor: "Microsoft"
                            }
                        }
                    }, {
                        test: function(e) {
                            var t = Number(String(e.getOSVersion()).split(".")[0]);
                            return "android" === e.getOSName(!0) && t >= 3
                        },
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.tablet
                            }
                        }
                    }, {
                        test: function(e) {
                            return "android" === e.getOSName(!0)
                        },
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.mobile
                            }
                        }
                    }, {
                        test: function(e) {
                            return "macos" === e.getOSName(!0)
                        },
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.desktop,
                                vendor: "Apple"
                            }
                        }
                    }, {
                        test: function(e) {
                            return "windows" === e.getOSName(!0)
                        },
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.desktop
                            }
                        }
                    }, {
                        test: function(e) {
                            return "linux" === e.getOSName(!0)
                        },
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.desktop
                            }
                        }
                    }, {
                        test: function(e) {
                            return "playstation 4" === e.getOSName(!0)
                        },
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.tv
                            }
                        }
                    }, {
                        test: function(e) {
                            return "roku" === e.getOSName(!0)
                        },
                        describe: function() {
                            return {
                                type: r.PLATFORMS_MAP.tv
                            }
                        }
                    }];
                t.default = o, e.exports = t.default
            },
            95: function(e, t, n) {
                "use strict";
                t.__esModule = !0, t.default = void 0;
                var i, s = (i = n(17)) && i.__esModule ? i : {
                        default: i
                    },
                    r = n(18),
                    o = [{
                        test: function(e) {
                            return "microsoft edge" === e.getBrowserName(!0)
                        },
                        describe: function(e) {
                            if (/\sedg\//i.test(e)) return {
                                name: r.ENGINE_MAP.Blink
                            };
                            var t = s.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
                            return {
                                name: r.ENGINE_MAP.EdgeHTML,
                                version: t
                            }
                        }
                    }, {
                        test: [/trident/i],
                        describe: function(e) {
                            var t = {
                                    name: r.ENGINE_MAP.Trident
                                },
                                n = s.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: function(e) {
                            return e.test(/presto/i)
                        },
                        describe: function(e) {
                            var t = {
                                    name: r.ENGINE_MAP.Presto
                                },
                                n = s.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: function(e) {
                            var t = e.test(/gecko/i),
                                n = e.test(/like gecko/i);
                            return t && !n
                        },
                        describe: function(e) {
                            var t = {
                                    name: r.ENGINE_MAP.Gecko
                                },
                                n = s.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }, {
                        test: [/(apple)?webkit\/537\.36/i],
                        describe: function() {
                            return {
                                name: r.ENGINE_MAP.Blink
                            }
                        }
                    }, {
                        test: [/(apple)?webkit/i],
                        describe: function(e) {
                            var t = {
                                    name: r.ENGINE_MAP.WebKit
                                },
                                n = s.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
                            return n && (t.version = n), t
                        }
                    }];
                t.default = o, e.exports = t.default
            }
        })
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(5),
                s = n(8),
                r = n(3);

            function o(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const a = Object(i.getLogger)(e);
            t.a = new class {
                constructor() {
                    this.reset()
                }
                reset() {
                    this.disposed = !1, this.analyticsHandlers = new Set, this.cache = [], this.permanentProperties = {}, this.conferenceName = "", this.addPermanentProperties({
                        user_agent: navigator.userAgent,
                        browser_name: r.a.getName()
                    })
                }
                dispose() {
                    a.warn("Disposing of analytics adapter."), this.analyticsHandlers && this.analyticsHandlers.size > 0 && this.analyticsHandlers.forEach(e => {
                        "function" == typeof e.dispose && e.dispose()
                    }), this.setAnalyticsHandlers([]), this.disposed = !0
                }
                setAnalyticsHandlers(e) {
                    if (this.disposed) return;
                    this.analyticsHandlers = new Set(e), this._setUserProperties();
                    const t = this.cache;
                    this.cache = null, t && t.forEach(e => this._sendEvent(e))
                }
                _setUserProperties() {
                    this.analyticsHandlers.forEach(e => {
                        try {
                            e.setUserProperties(this.permanentProperties)
                        } catch (e) {
                            a.warn("Error in setUserProperties method of one of the analytics handlers: " + e)
                        }
                    })
                }
                addPermanentProperties(e) {
                    this.permanentProperties = function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? Object(arguments[t]) : {},
                                i = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), i.forEach((function(t) {
                                o(e, t, n[t])
                            }))
                        }
                        return e
                    }({}, this.permanentProperties, e), this._setUserProperties()
                }
                setConferenceName(e) {
                    this.conferenceName = e, this.addPermanentProperties({
                        conference_name: e
                    })
                }
                sendEvent(e, t = {}) {
                    if (this.disposed) return;
                    let n = null;
                    "string" == typeof e ? n = {
                        type: s.t,
                        action: e,
                        actionSubject: e,
                        source: e,
                        attributes: t
                    } : "object" == typeof e && (n = e), this._verifyRequiredFields(n) ? this._sendEvent(n) : a.error("Dropping a mis-formatted event: " + JSON.stringify(n))
                }
                _verifyRequiredFields(e) {
                    if (!e) return !1;
                    e.type || (e.type = s.t);
                    const t = e.type;
                    return t !== s.t && t !== s.u && t !== s.w && t !== s.v ? (a.error("Unknown event type: " + t), !1) : t === s.u ? Boolean(e.name) : (e.action = e.action || e.name || e.actionSubject, e.actionSubject = e.actionSubject || e.name || e.action, e.source = e.source || e.name || e.action || e.actionSubject, e.action && e.actionSubject && e.source ? !!(t !== s.v || (e.objectType = e.objectType || "generic-object-type", e.containerType = e.containerType || "conference", "conference" !== e.containerType || e.containerId || (e.containerId = this.conferenceName), e.objectType && e.objectId && e.containerType && e.containerId)) || (a.error("Required field missing (containerId, containerType, objectId or objectType)"), !1) : (a.error("Required field missing (action, actionSubject or source)"), !1))
                }
                _maybeCacheEvent(e) {
                    return !!this.cache && (this.cache.push(e), this.cache.length > 100 && this.cache.splice(0, 1), !0)
                }
                _sendEvent(e) {
                    this._maybeCacheEvent(e) || this.analyticsHandlers.forEach(t => {
                        try {
                            t.sendEvent(e)
                        } catch (e) {
                            a.warn("Error sending analytics event: " + e)
                        }
                    })
                }
            }
        }).call(this, "modules/statistics/AnalyticsAdapter.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return a
            }));
            var i = n(5),
                s = n(28),
                r = n(31);
            const o = Object(i.getLogger)(e);
            class a {
                constructor(e, t) {
                    this.eventEmitter = e, this.longTasks = 0, this.maxDuration = 0, this.performanceStatsInterval = t, this.stats = new r.a
                }
                getLongTasksStats() {
                    return {
                        avgRatePerMinute: (60 * this.stats.getAverage()).toFixed(2),
                        maxDurationMs: this.maxDuration
                    }
                }
                startObserver() {
                    this.longTaskEventHandler = e => {
                        const t = e.getEntries();
                        for (const e of t) this.longTasks++, this.maxDuration = Math.max(this.maxDuration, e.duration).toFixed(3)
                    }, o.info("Creating a Performance Observer for monitoring Long Tasks"), this.observer = new PerformanceObserver(this.longTaskEventHandler), this.observer.observe({
                        type: "longtask",
                        buffered: !0
                    });
                    const e = Date.now();
                    this.longTasksIntervalId = setInterval(() => {
                        const t = Date.now(),
                            n = this._lastTimeStamp ? (t - this._lastTimeStamp) / 1e3 : (t - e) / 1e3,
                            i = this.longTasks / n;
                        this.stats.addNext(i), this.eventEmitter.emit(s.e, this.getLongTasksStats()), this.longTasks = 0, this._lastTimeStamp = Date.now()
                    }, this.performanceStatsInterval)
                }
                stopObserver() {
                    this.observer && this.observer.disconnect(), this.longTaskEventHandler = null, this.longTasksIntervalId && (clearInterval(this.longTasksIntervalId), this.longTasksIntervalId = null)
                }
            }
        }).call(this, "modules/statistics/PerformanceObserverStats.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return h
            }));
            var i = n(5),
                s = n(4),
                r = n(28),
                o = n(3);
            const a = n(12),
                c = Object(i.getLogger)(e);

            function d(e, t) {
                return !t || t <= 0 || !e || e <= 0 ? 0 : Math.round(e / t * 100)
            }

            function u() {
                this.loss = {}, this.bitrate = {
                    download: 0,
                    upload: 0
                }, this.resolution = {}, this.framerate = 0, this.codec = ""
            }

            function l() {
                this.bandwidth = {}, this.bitrate = {}, this.packetLoss = null, this.transport = []
            }

            function h(e, t, n, i) {
                this.peerconnection = e, this.baselineAudioLevelsReport = null, this.currentAudioLevelsReport = null, this.currentStatsReport = null, this.previousStatsReport = null, this.audioLevelReportHistory = {}, this.audioLevelsIntervalId = null, this.eventEmitter = i, this.conferenceStats = new l, this.audioLevelsIntervalMilis = t, this.speakerList = [], this.statsIntervalId = null, this.statsIntervalMilis = n, this.ssrc2stats = new Map
            }
            u.prototype.setLoss = function(e) {
                this.loss = e || {}
            }, u.prototype.setResolution = function(e) {
                this.resolution = e || {}
            }, u.prototype.addBitrate = function(e) {
                this.bitrate.download += e.download, this.bitrate.upload += e.upload
            }, u.prototype.resetBitrate = function() {
                this.bitrate.download = 0, this.bitrate.upload = 0
            }, u.prototype.setFramerate = function(e) {
                this.framerate = e || 0
            }, u.prototype.setCodec = function(e) {
                this.codec = e || ""
            }, h.prototype.setSpeakerList = function(e) {
                this.speakerList = e
            }, h.prototype.stop = function() {
                this.audioLevelsIntervalId && (clearInterval(this.audioLevelsIntervalId), this.audioLevelsIntervalId = null), this.statsIntervalId && (clearInterval(this.statsIntervalId), this.statsIntervalId = null)
            }, h.prototype.errorCallback = function(e) {
                a.callErrorHandler(e), c.error("Get stats error", e), this.stop()
            }, h.prototype.start = function(e) {
                e && (o.a.supportsReceiverStats() && c.info("Using RTCRtpSynchronizationSource for remote audio levels"), this.audioLevelsIntervalId = setInterval(() => {
                    if (o.a.supportsReceiverStats()) {
                        const e = this.peerconnection.getAudioLevels(this.speakerList);
                        for (const t in e)
                            if (e.hasOwnProperty(t)) {
                                const n = 2.5 * e[t];
                                this.eventEmitter.emit(r.a, this.peerconnection, Number.parseInt(t, 10), n, !1)
                            }
                    } else this.peerconnection.getStats().then(e => {
                        this.currentAudioLevelsReport = "function" == typeof(null == e ? void 0 : e.result) ? e.result() : e, this.processAudioLevelReport(), this.baselineAudioLevelsReport = this.currentAudioLevelsReport
                    }).catch(e => this.errorCallback(e))
                }, this.audioLevelsIntervalMilis));
                const t = () => {
                    this.peerconnection.getStats().then(e => {
                        this.currentStatsReport = "function" == typeof(null == e ? void 0 : e.result) ? e.result() : e;
                        try {
                            this.processStatsReport()
                        } catch (e) {
                            a.callErrorHandler(e), c.error("Processing of RTP stats failed:", e)
                        }
                        this.previousStatsReport = this.currentStatsReport
                    }).catch(e => this.errorCallback(e))
                };
                t(), this.statsIntervalId = setInterval(t, this.statsIntervalMilis)
            }, h.prototype._processAndEmitReport = function() {
                const e = {
                        download: 0,
                        upload: 0
                    },
                    t = {
                        download: 0,
                        upload: 0
                    };
                let n = 0,
                    i = 0;
                const s = {},
                    o = {},
                    a = {};
                let u, l, h = 0,
                    p = 0,
                    m = 0,
                    f = 0;
                for (const [r, d] of this.ssrc2stats) {
                    const g = d.loss,
                        _ = g.isDownloadStream ? "download" : "upload";
                    e[_] += g.packetsTotal, t[_] += g.packetsLost, n += d.bitrate.download, i += d.bitrate.upload;
                    const v = this.peerconnection.getTrackBySSRC(r);
                    if (v) {
                        v.isAudioTrack() ? (h += d.bitrate.download, p += d.bitrate.upload, u = d.codec) : (m += d.bitrate.download, f += d.bitrate.upload, l = d.codec);
                        const e = v.getParticipantId();
                        if (e) {
                            const t = d.resolution;
                            if (t.width && t.height && -1 !== t.width && -1 !== t.height) {
                                const n = s[e] || {};
                                n[r] = t, s[e] = n
                            }
                            if (0 !== d.framerate) {
                                const t = o[e] || {};
                                t[r] = d.framerate, o[e] = t
                            }
                            if (u && l) {
                                const t = {
                                        audio: u,
                                        video: l
                                    },
                                    n = a[e] || {};
                                n[r] = t, a[e] = n
                            }
                        } else c.error("No participant ID returned by " + v)
                    }
                    d.resetBitrate()
                }
                this.conferenceStats.bitrate = {
                    upload: i,
                    download: n
                }, this.conferenceStats.bitrate.audio = {
                    upload: p,
                    download: h
                }, this.conferenceStats.bitrate.video = {
                    upload: f,
                    download: m
                }, this.conferenceStats.packetLoss = {
                    total: d(t.download + t.upload, e.download + e.upload),
                    download: d(t.download, e.download),
                    upload: d(t.upload, e.upload)
                };
                const g = {};
                let _;
                Object.keys(this.audioLevelReportHistory).forEach(e => {
                    const {
                        data: t,
                        isLocal: n
                    } = this.audioLevelReportHistory[e], i = t.reduce((e, t) => e + t) / t.length;
                    if (n) _ = i;
                    else {
                        const t = this.peerconnection.getTrackBySSRC(Number(e));
                        if (t) {
                            const e = t.getParticipantId();
                            e && (g[e] = i)
                        }
                    }
                }), this.audioLevelReportHistory = {}, this.eventEmitter.emit(r.d, this.peerconnection, {
                    bandwidth: this.conferenceStats.bandwidth,
                    bitrate: this.conferenceStats.bitrate,
                    packetLoss: this.conferenceStats.packetLoss,
                    resolution: s,
                    framerate: o,
                    codec: a,
                    transport: this.conferenceStats.transport,
                    localAvgAudioLevels: _,
                    avgAudioLevels: g
                }), this.conferenceStats.transport = []
            }, h.prototype.getNonNegativeValue = function(e) {
                let t = e;
                return "number" != typeof t && (t = Number(t)), isNaN(t) ? 0 : Math.max(0, t)
            }, h.prototype._calculateBitrate = function(e, t, n) {
                const i = this.getNonNegativeValue(e[n]),
                    s = this.getNonNegativeValue(t[n]),
                    r = Math.max(0, i - s),
                    o = e.timestamp - t.timestamp;
                let a = 0;
                return o > 0 && (a = Math.round(8 * r / o)), a
            }, h.prototype.processStatsReport = function() {
                if (!this.previousStatsReport) return;
                const e = {};
                this.currentStatsReport.forEach(t => {
                    if ("candidate-pair" === t.type && t.nominated && "succeeded" === t.state) {
                        const e = t.availableIncomingBitrate,
                            n = t.availableOutgoingBitrate;
                        (e || n) && (this.conferenceStats.bandwidth = {
                            download: Math.round(e / 1e3),
                            upload: Math.round(n / 1e3)
                        });
                        const i = this.currentStatsReport.get(t.remoteCandidateId),
                            s = this.currentStatsReport.get(t.localCandidateId);
                        if (i && s) {
                            const e = `${o.a.isChromiumBased()?i.ip:i.address}:${i.port}`,
                                n = `${o.a.isChromiumBased()?s.ip:s.address}:${s.port}`,
                                r = i.protocol,
                                a = this.conferenceStats.transport;
                            a.some(t => t.ip === e && t.type === r && t.localip === n) || a.push({
                                ip: e,
                                type: r,
                                localip: n,
                                p2p: this.peerconnection.isP2P,
                                localCandidateType: s.candidateType,
                                remoteCandidateType: i.candidateType,
                                networkType: s.networkType,
                                rtt: 1e3 * t.currentRoundTripTime
                            })
                        }
                    } else if ("inbound-rtp" === t.type || "outbound-rtp" === t.type) {
                        const n = this.previousStatsReport.get(t.id),
                            i = this.getNonNegativeValue(t.ssrc);
                        if (!n || !i) return;
                        let s = this.ssrc2stats.get(i);
                        s || (s = new u, this.ssrc2stats.set(i, s));
                        let r = !0,
                            o = "packetsReceived";
                        "outbound-rtp" === t.type && (r = !1, o = "packetsSent");
                        let a = t[o];
                        (!a || a < 0) && (a = 0);
                        const c = this.getNonNegativeValue(n[o]),
                            d = Math.max(0, a - c),
                            l = this.getNonNegativeValue(t.packetsLost),
                            h = this.getNonNegativeValue(n.packetsLost),
                            p = Math.max(0, l - h);
                        if (s.setLoss({
                                packetsTotal: d + p,
                                packetsLost: p,
                                isDownloadStream: r
                            }), "inbound-rtp" === t.type) {
                            const e = {
                                    height: t.frameHeight,
                                    width: t.frameWidth
                                },
                                i = t.framesPerSecond;
                            e.height && e.width && s.setResolution(e), s.setFramerate(Math.round(i || 0)), s.addBitrate({
                                download: this._calculateBitrate(t, n, "bytesReceived"),
                                upload: 0
                            })
                        } else e[i] = this.getNonNegativeValue(t.bytesSent), s.addBitrate({
                            download: 0,
                            upload: this._calculateBitrate(t, n, "bytesSent")
                        });
                        const m = this.currentStatsReport.get(t.codecId);
                        if (m) {
                            const e = m.mimeType.split("/")[1];
                            e && s.setCodec(e)
                        }
                    } else if ("track" === t.type && t.kind === s.c && !t.remoteSource) {
                        const e = {
                                height: t.frameHeight,
                                width: t.frameWidth
                            },
                            n = this.peerconnection.getLocalTracks(s.c);
                        if (!(null == n ? void 0 : n.length)) return;
                        const i = this.peerconnection.getLocalSSRC(n[0]);
                        if (!i) return;
                        let r = this.ssrc2stats.get(i);
                        r || (r = new u, this.ssrc2stats.set(i, r)), e.height && e.width && r.setResolution(e);
                        let o = t.framesPerSecond;
                        if (!o) {
                            const e = this.previousStatsReport.get(t.id);
                            if (e) {
                                const n = t.timestamp - e.timestamp;
                                if (n > 0 && t.framesSent) {
                                    o = (t.framesSent - e.framesSent) / n * 1e3
                                }
                            }
                            if (!o) return
                        }
                        const a = this.peerconnection.getActiveSimulcastStreams();
                        o = a ? Math.round(o / a) : 0, r.setFramerate(o)
                    }
                }), this.eventEmitter.emit(r.c, this.peerconnection, e), this._processAndEmitReport()
            }, h.prototype.processAudioLevelReport = function() {
                this.baselineAudioLevelsReport && this.currentAudioLevelsReport.forEach(e => {
                    if ("track" !== e.type) return;
                    const t = e.audioLevel;
                    if (!t) return;
                    const n = e.trackIdentifier,
                        i = this.peerconnection.getSsrcByTrackId(n);
                    if (i) {
                        const e = i === this.peerconnection.getLocalSSRC(this.peerconnection.getLocalTracks(s.a));
                        this.eventEmitter.emit(r.a, this.peerconnection, i, t, e)
                    }
                })
            }
        }).call(this, "modules/statistics/RTPStatsCollector.js")
    }, function(e, t) {
        function n(e, t) {
            if (!e || !t || "function" != typeof e.addListener || "function" != typeof t.emit) throw new Error("Invalid arguments passed to EventEmitterForwarder");
            this.src = e, this.dest = t
        }
        n.prototype.forward = function(...e) {
            const t = e[0];
            e[0] = this.dest, this.src.addListener(t, Function.prototype.bind.apply(this.dest.emit, e))
        }, e.exports = n
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return a
        }));
        var i = n(2),
            s = n(1),
            r = n(51),
            o = n(4);
        class a {
            constructor(e, t, n, s, o, a, c, d, u) {
                this._jid = e, this._id = i.Strophe.getResourceFromJid(e), this._conference = t, this._displayName = n, this._supportsDTMF = !1, this._tracks = [], this._role = "none", this._status = a, this._hidden = s, this._statsID = o, this._connectionStatus = r.a.ACTIVE, this._properties = {}, this._identity = c, this._isReplacing = d, this._isReplaced = u, this._features = new Set
            }
            getConference() {
                return this._conference
            }
            getProperty(e) {
                return this._properties[e]
            }
            hasAnyVideoTrackWebRTCMuted() {
                return this.getTracks().some(e => e.getType() === o.c && e.isWebRTCTrackMuted())
            }
            _setConnectionStatus(e) {
                this._connectionStatus = e
            }
            getConnectionStatus() {
                return this._connectionStatus
            }
            setProperty(e, t) {
                const n = this._properties[e];
                t !== n && (this._properties[e] = t, this._conference.eventEmitter.emit(s.PARTICIPANT_PROPERTY_CHANGED, this, e, n, t))
            }
            getTracks() {
                return this._tracks.slice()
            }
            getTracksByMediaType(e) {
                return this.getTracks().filter(t => t.getType() === e)
            }
            getId() {
                return this._id
            }
            getJid() {
                return this._jid
            }
            getDisplayName() {
                return this._displayName
            }
            getStatsID() {
                return this._statsID
            }
            getStatus() {
                return this._status
            }
            isModerator() {
                return "moderator" === this._role
            }
            isHidden() {
                return this._hidden
            }
            isReplacing() {
                return this._isReplacing
            }
            isReplaced() {
                return this._isReplaced
            }
            isAudioMuted() {
                return this._isMediaTypeMuted(o.a)
            }
            _isMediaTypeMuted(e) {
                return this.getTracks().reduce((t, n) => t && (n.getType() !== e || n.isMuted()), !0)
            }
            isVideoMuted() {
                return this._isMediaTypeMuted(o.c)
            }
            getRole() {
                return this._role
            }
            setRole(e) {
                this._role = e
            }
            setIsReplacing(e) {
                this._isReplacing = e
            }
            setIsReplaced(e) {
                this._isReplaced = e
            }
            supportsDTMF() {
                return this._supportsDTMF
            }
            getFeatures() {
                return Promise.resolve(this._features)
            }
            hasFeature(e) {
                return this._features.has(e)
            }
            setFeatures(e) {
                this._features = e || new Set
            }
            getBotType() {
                return this._botType
            }
            setBotType(e) {
                this._botType = e
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return r
        }));
        var i = n(27),
            s = n(25);

        function r({
            id: e,
            password: t,
            onCreateResource: n,
            onLoginSuccessful: r,
            roomPassword: o
        }) {
            let a, c = !1,
                d = new s.e(this.connection.options);
            const u = new Promise((s, u) => {
                a = u, d.addListener(i.CONNECTION_DISCONNECTED, () => {
                    d = void 0
                }), d.addListener(i.CONNECTION_ESTABLISHED, () => {
                    if (c) return;
                    r && r();
                    d.createRoom(this.options.name, this.options.config, n).moderator.authenticate().then(() => {
                        d && d.disconnect(), c || (this.join(o), s())
                    }).catch(({
                        error: e,
                        message: t
                    }) => {
                        d.disconnect(), u({
                            authenticationError: e,
                            message: t
                        })
                    })
                }), d.addListener(i.CONNECTION_FAILED, (e, t, n) => {
                    u({
                        connectionError: e,
                        credentials: n,
                        message: t
                    }), d = void 0
                }), c || d.connect(e, t)
            });
            return u.cancel = () => {
                c = !0, a({}), d && d.disconnect()
            }, u
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return o
            }));
            var i = n(5);
            const s = Object(i.getLogger)(e),
                r = Symbol("kJitsiE2EE");
            class o {
                constructor() {
                    let e = "";
                    const t = document.querySelector('script[src*="lib-jitsi-meet"]');
                    if (t) {
                        const n = t.src.lastIndexOf("/");
                        e = t.src.substring(0, n) + "/"
                    }
                    const n = new Blob([`importScripts("${e+"lib-jitsi-meet.e2ee-worker.js"}");`], {
                            type: "application/javascript"
                        }),
                        i = window.URL.createObjectURL(n);
                    this._worker = new Worker(i, {
                        name: "E2EE Worker"
                    }), this._worker.onerror = e => s.onerror(e)
                }
                cleanup(e) {
                    this._worker.postMessage({
                        operation: "cleanup",
                        participantId: e
                    })
                }
                handleReceiver(e, t, n) {
                    if (e[r]) return;
                    e[r] = !0;
                    const i = e.createEncodedStreams();
                    this._worker.postMessage({
                        operation: "decode",
                        readableStream: i.readable,
                        writableStream: i.writable,
                        participantId: n
                    }, [i.readable, i.writable])
                }
                handleSender(e, t, n) {
                    if (e[r]) return;
                    e[r] = !0;
                    const i = e.createEncodedStreams();
                    this._worker.postMessage({
                        operation: "encode",
                        readableStream: i.readable,
                        writableStream: i.writable,
                        participantId: n
                    }, [i.readable, i.writable])
                }
                setKey(e, t, n) {
                    this._worker.postMessage({
                        operation: "setKey",
                        participantId: e,
                        key: t,
                        keyIndex: n
                    })
                }
            }
        }).call(this, "modules/e2ee/E2EEContext.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return a
            }));
            var i = n(5),
                s = n(52),
                r = n(97);
            const o = Object(i.getLogger)(e);
            class a {
                constructor(e) {
                    this._stropheConn = e, this._resumeRetryN = 0, this._retryDelay = void 0
                }
                get retryDelay() {
                    return this._retryDelay
                }
                schedule() {
                    this._cancelResume(), this._resumeRetryN += 1, this._networkOnlineListener = s.b.addEventListener(s.a, ({
                        isOnline: e
                    }) => {
                        e ? this._scheduleResume() : this._cancelResume()
                    }), s.b.isOnline() && this._scheduleResume()
                }
                _scheduleResume() {
                    this._resumeTimeout || (this._resumeRetryN = Math.min(3, this._resumeRetryN), this._retryDelay = Object(r.a)(this._resumeRetryN, 1500 * this._resumeRetryN, 3), o.info(`Will try to resume the XMPP connection in ${this.retryDelay}ms`), this._resumeTimeout = setTimeout(() => this._resumeConnection(), this.retryDelay))
                }
                _cancelResume() {
                    this._resumeTimeout && (o.info("Canceling connection resume task"), clearTimeout(this._resumeTimeout), this._resumeTimeout = void 0, this._retryDelay = void 0)
                }
                _resumeConnection() {
                    const {
                        streamManagement: e
                    } = this._stropheConn, t = e.getResumeToken();
                    if (!t) return;
                    o.info("Trying to resume the XMPP connection");
                    const n = new URL(this._stropheConn.service);
                    let {
                        search: i
                    } = n;
                    const s = /(previd=)([\w-]+)/,
                        r = i.match(s);
                    r && -1 === r.indexOf(t) ? i = i.replace(s, "$1" + t) : r || (i += -1 === i.indexOf("?") ? "?previd=" + t : "&previd=" + t), n.search = i, this._stropheConn.service = n.toString(), e.resume()
                }
                cancel() {
                    this._cancelResume(), this._resumeRetryN = 0, this._networkOnlineListener && (this._networkOnlineListener(), this._networkOnlineListener = null)
                }
            }
        }).call(this, "modules/xmpp/ResumeTask.js")
    }, function(e, t, n) {
        "use strict";

        function i(e, t = 500, n = 2) {
            return Math.floor(Math.random() * (1e3 * Math.pow(n, e) - t) + t)
        }
        n.d(t, "a", (function() {
            return i
        }))
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return i
        }));
        class i {
            constructor() {
                this._lastSuccess = null, this._lastFailedMessage = null
            }
            startTracking(e, t) {
                const n = t.rawInput;
                t.rawInput = (...i) => {
                    const s = i[0];
                    s.includes("failure") && (this._lastFailedMessage = s), e.connected && (this._lastSuccess = Date.now()), n.apply(t, i)
                }
            }
            getLastFailedMessage() {
                return this._lastFailedMessage
            }
            getTimeSinceLastSuccess() {
                return this._lastSuccess ? Date.now() - this._lastSuccess : null
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var i = n(5),
                s = n(2),
                r = n(12),
                o = n.n(r),
                a = n(38);
            const c = Object(i.getLogger)(e);
            class d extends a.b {
                constructor({
                    getTimeSinceLastServerResponse: e,
                    onPingThresholdExceeded: t,
                    pingOptions: n = {}
                }) {
                    super(), this.failedPings = 0, this._onPingThresholdExceeded = t, this._getTimeSinceLastServerResponse = e, this.pingInterval = "number" == typeof n.interval ? n.interval : 1e4, this.pingTimeout = "number" == typeof n.timeout ? n.timeout : 5e3, this.pingThreshold = "number" == typeof n.threshold ? n.threshold : 2, this.pingTimestampsToKeep = Math.round(12e4 / this.pingInterval), this.pingExecIntervals = new Array(this.pingTimestampsToKeep)
                }
                init(e) {
                    super.init(e), s.Strophe.addNamespace("PING", "urn:xmpp:ping")
                }
                ping(e, t, n, i) {
                    this._addPingExecutionTimestamp();
                    const r = Object(s.$iq)({
                        type: "get",
                        to: e
                    });
                    r.c("ping", {
                        xmlns: s.Strophe.NS.PING
                    }), this.connection.sendIQ2(r, {
                        timeout: i
                    }).then(t, n)
                }
                startInterval(e) {
                    clearInterval(this.intervalId), this.intervalId = window.setInterval(() => {
                        const t = Date.now();
                        if (this._getTimeSinceLastServerResponse() < t - this._lastServerCheck) return this._addPingExecutionTimestamp(), this._lastServerCheck = t, void(this.failedPings = 0);
                        this.ping(e, () => {
                            this._lastServerCheck = this._getTimeSinceLastServerResponse() + Date.now(), this.failedPings = 0
                        }, e => {
                            this.failedPings += 1;
                            const t = "Ping " + (e ? "error" : "timeout");
                            this.failedPings >= this.pingThreshold ? (o.a.callErrorHandler(new Error(t)), c.error(t, e), this._onPingThresholdExceeded && this._onPingThresholdExceeded()) : c.warn(t, e)
                        }, this.pingTimeout)
                    }, this.pingInterval), c.info(`XMPP pings will be sent every ${this.pingInterval} ms`)
                }
                stopInterval() {
                    this.intervalId && (window.clearInterval(this.intervalId), this.intervalId = null, this.failedPings = 0, c.info("Ping interval cleared"))
                }
                _addPingExecutionTimestamp() {
                    this.pingExecIntervals.push((new Date).getTime()), this.pingExecIntervals.length > this.pingTimestampsToKeep && this.pingExecIntervals.shift()
                }
                getPingSuspendTime() {
                    const e = this.pingExecIntervals.slice();
                    e.push((new Date).getTime());
                    let t = 0,
                        n = e[0];
                    return e.forEach(e => {
                        const i = e - n;
                        i > t && (t = i), n = e
                    }), t -= this.pingInterval, Math.max(t, 0)
                }
            }
        }).call(this, "modules/xmpp/strophe.ping.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return u
            }));
            var i = n(5),
                s = n(2),
                r = n(0),
                o = n.n(r),
                a = n(101),
                c = n(38);
            const d = Object(i.getLogger)(e);
            class u extends c.a {
                constructor(e) {
                    super(), this.xmpp = e, this.rooms = {}
                }
                init(e) {
                    super.init(e), this.connection.addHandler(this.onPresence.bind(this), null, "presence", null, null, null, null), this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, "presence", "unavailable", null), this.connection.addHandler(this.onPresenceError.bind(this), null, "presence", "error", null), this.connection.addHandler(this.onMessage.bind(this), null, "message", null, null), this.connection.addHandler(this.onMute.bind(this), "http://jitsi.org/jitmeet/audio", "iq", "set", null, null), this.connection.addHandler(this.onMuteVideo.bind(this), "http://jitsi.org/jitmeet/video", "iq", "set", null, null)
                }
                createRoom(e, t, n) {
                    const i = s.Strophe.getBareJidFromJid(e);
                    if (this.rooms[i]) {
                        const e = "You are already in the room!";
                        throw d.error(e), new Error(e)
                    }
                    return this.rooms[i] = new a.a(this.connection, e, t, this.xmpp, n), this.eventEmitter.emit(o.a.EMUC_ROOM_ADDED, this.rooms[i]), this.rooms[i]
                }
                doLeave(e) {
                    this.eventEmitter.emit(o.a.EMUC_ROOM_REMOVED, this.rooms[e]), delete this.rooms[e]
                }
                onPresence(e) {
                    const t = e.getAttribute("from");
                    if (e.getAttribute("type")) return !0;
                    const n = this.rooms[s.Strophe.getBareJidFromJid(t)];
                    return !n || ($(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="201"]').length && n.createNonAnonymousRoom(), n.onPresence(e), !0)
                }
                onPresenceUnavailable(e) {
                    const t = e.getAttribute("from"),
                        n = this.rooms[s.Strophe.getBareJidFromJid(t)];
                    return !n || (n.onPresenceUnavailable(e, t), !0)
                }
                onPresenceError(e) {
                    const t = e.getAttribute("from"),
                        n = this.rooms[s.Strophe.getBareJidFromJid(t)];
                    return !n || (n.onPresenceError(e, t), !0)
                }
                onMessage(e) {
                    const t = e.getAttribute("from"),
                        n = this.rooms[s.Strophe.getBareJidFromJid(t)];
                    return !n || (n.onMessage(e, t), !0)
                }
                onMute(e) {
                    const t = e.getAttribute("from"),
                        n = this.rooms[s.Strophe.getBareJidFromJid(t)];
                    return !n || (n.onMute(e), !0)
                }
                onMuteVideo(e) {
                    const t = e.getAttribute("from"),
                        n = this.rooms[s.Strophe.getBareJidFromJid(t)];
                    return !n || (n.onMuteVideo(e), !0)
                }
            }
        }).call(this, "modules/xmpp/strophe.emuc.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return b
            }));
            var i = n(5),
                s = n(33),
                r = n.n(s),
                o = n(2),
                a = n(63),
                c = n(4),
                d = n(0),
                u = n.n(d),
                l = n(12),
                h = n.n(l),
                p = n(22),
                m = n(102),
                f = n(103),
                g = n(41),
                _ = n(104);
            const v = Object(i.getLogger)(e),
                S = {
                    packet2JSON(e, t) {
                        for (const n of Array.from(e.children)) {
                            const e = {
                                attributes: {},
                                children: [],
                                tagName: n.tagName
                            };
                            for (const t of Array.from(n.attributes)) e.attributes[t.name] = t.value;
                            const i = o.Strophe.getText(n);
                            i && (e.value = o.Strophe.xmlunescape(i)), t.push(e), this.packet2JSON(n, e.children)
                        }
                    },
                    json2packet(e, t) {
                        for (let n = 0; n < e.length; n++) {
                            const i = e[n];
                            i && (t.c(i.tagName, i.attributes), i.value && t.t(i.value), i.children && this.json2packet(i.children, t), t.up())
                        }
                    }
                };

            function y(e, t) {
                const n = [];
                for (let i = 0; i < e.length; i++) e[i].tagName === t && n.push(e[i]);
                return n
            }
            const E = ["owner", "admin", "member"];
            class b extends p.a {
                constructor(e, t, n, i, s) {
                    super(), this.xmpp = i, this.connection = e, this.roomjid = o.Strophe.getBareJidFromJid(t), this.myroomjid = t, this.password = n, this.replaceParticipant = !1, v.info("Joined MUC as " + this.myroomjid), this.members = {}, this.presMap = {}, this.presHandlers = {}, this._removeConnListeners = [], this.joined = !1, this.role = null, this.focusMucJid = null, this.noBridgeAvailable = !1, this.options = s || {}, this.moderator = new _.a(this.roomjid, this.xmpp, this.eventEmitter, {
                        connection: this.xmpp.options,
                        conference: this.options
                    }), (void 0 === this.options.enableLobby || this.options.enableLobby) && (this.lobby = new f.a(this)), this.avModeration = new m.a(this), this.initPresenceMap(s), this.lastPresences = {}, this.phoneNumber = null, this.phonePin = null, this.connectionTimes = {}, this.participantPropertyListener = null, this.locked = !1, this.transcriptionStatus = a.OFF
                }
                initPresenceMap(e = {}) {
                    this.presMap.to = this.myroomjid, this.presMap.xns = "http://jabber.org/protocol/muc", this.presMap.nodes = [], e.statsId && this.presMap.nodes.push({
                        tagName: "stats-id",
                        value: e.statsId
                    }), e.deploymentInfo && e.deploymentInfo.userRegion && this.presMap.nodes.push({
                        tagName: "region",
                        attributes: {
                            id: e.deploymentInfo.userRegion,
                            xmlns: "http://jitsi.org/jitsi-meet"
                        }
                    }), this.presenceUpdateTime = Date.now()
                }
                join(e, t) {
                    return this.password = e, this.replaceParticipant = t, new Promise(e => {
                        this.options.disableFocus && v.info("Conference focus disabled for " + this.roomjid);
                        (this.options.disableFocus ? Promise.resolve() : this.moderator.allocateConferenceFocus()).then(() => {
                            this.sendPresence(!0), this._removeConnListeners.push(this.connection.addEventListener(g.a.Events.CONN_STATUS_CHANGED, this.onConnStatusChanged.bind(this))), e()
                        })
                    })
                }
                sendPresence(e) {
                    const t = this.presMap.to;
                    if (!this.connection || !this.connection.connected || !t || !this.joined && !e) return;
                    const n = Object(o.$pres)({
                        to: t
                    });
                    e && (this.replaceParticipant && n.c("flip_device").up(), n.c("x", {
                        xmlns: this.presMap.xns
                    }), this.password && n.c("password").t(this.password).up(), this.options.billingId && n.c("billingid").t(this.options.billingId).up(), n.up()), S.json2packet(this.presMap.nodes, n), this.presenceSyncTime = Date.now(), this.connection.send(n), e && this.connection.flush()
                }
                doLeave() {
                    v.log("do leave", this.myroomjid);
                    const e = Object(o.$pres)({
                        to: this.myroomjid,
                        type: "unavailable"
                    });
                    this.presMap.length = 0, !this.connection.isUsingWebSocket && this.connection.flush(), this.connection.send(e), this.connection.flush()
                }
                discoRoomInfo() {
                    const e = Object(o.$iq)({
                        type: "get",
                        to: this.roomjid
                    }).c("query", {
                        xmlns: o.Strophe.NS.DISCO_INFO
                    });
                    this.connection.sendIQ(e, e => {
                        const t = 1 === $(e).find('>query>feature[var="muc_passwordprotected"]').length;
                        t !== this.locked && (this.eventEmitter.emit(u.a.MUC_LOCK_CHANGED, t), this.locked = t);
                        const n = $(e).find('>query>x[type="result"]>field[var="muc#roominfo_meetingId"]>value');
                        n.length ? this.setMeetingId(n.text()) : v.warn("No meeting ID from backend");
                        const i = 1 === $(e).find('>query>feature[var="muc_membersonly"]').length,
                            s = $(e).find('>query>x[type="result"]>field[var="muc#roominfo_lobbyroom"]>value');
                        this.lobby && this.lobby.setLobbyRoomJid(s && s.length ? s.text() : void 0), i !== this.membersOnlyEnabled && (this.membersOnlyEnabled = i, this.eventEmitter.emit(u.a.MUC_MEMBERS_ONLY_CHANGED, i))
                    }, e => {
                        h.a.callErrorHandler(e), v.error("Error getting room info: ", e)
                    })
                }
                setMeetingId(e) {
                    this.meetingId !== e && (this.meetingId && v.warn(`Meeting Id changed from:${this.meetingId} to:${e}`), this.meetingId = e, this.eventEmitter.emit(u.a.MEETING_ID_SET, e))
                }
                createNonAnonymousRoom() {
                    if (this.options.disableDiscoInfo) return;
                    const e = Object(o.$iq)({
                        type: "get",
                        to: this.roomjid
                    }).c("query", {
                        xmlns: "http://jabber.org/protocol/muc#owner"
                    }).c("x", {
                        xmlns: "jabber:x:data",
                        type: "submit"
                    });
                    this.connection.sendIQ(e, e => {
                        if (!$(e).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_whois"]').length) {
                            const e = "non-anonymous rooms not supported";
                            return h.a.callErrorHandler(new Error(e)), void v.error(e)
                        }
                        const t = Object(o.$iq)({
                            to: this.roomjid,
                            type: "set"
                        }).c("query", {
                            xmlns: "http://jabber.org/protocol/muc#owner"
                        });
                        t.c("x", {
                            xmlns: "jabber:x:data",
                            type: "submit"
                        }), t.c("field", {
                            var: "FORM_TYPE"
                        }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), t.c("field", {
                            var: "muc#roomconfig_whois"
                        }).c("value").t("anyone").up().up(), this.connection.sendIQ(t)
                    }, e => {
                        h.a.callErrorHandler(e), v.error("Error getting room configuration form: ", e)
                    })
                }
                onConnStatusChanged(e) {
                    e === g.a.Status.CONNECTED && this.sendPresence()
                }
                onPresence(e) {
                    const t = e.getAttribute("from"),
                        n = {},
                        i = e.getElementsByTagName("status")[0];
                    i && (n.status = i.textContent || "");
                    let s = !1,
                        a = !1;
                    const c = e.getElementsByTagNameNS("http://jabber.org/protocol/muc#user", "x")[0],
                        d = c && c.getElementsByTagName("item")[0];
                    n.isReplaceParticipant = e.getElementsByTagName("flip_device").length, n.affiliation = d && d.getAttribute("affiliation"), n.role = d && d.getAttribute("role");
                    const l = d && d.getAttribute("jid");
                    n.jid = l, n.isFocus = l && 0 === l.indexOf(this.moderator.getFocusUserJid() + "/"), n.isHiddenDomain = l && l.indexOf("@") > 0 && this.options.hiddenDomain === l.substring(l.indexOf("@") + 1, l.indexOf("/")), this.eventEmitter.emit(u.a.PRESENCE_RECEIVED, {
                        fromHiddenDomain: n.isHiddenDomain,
                        presence: e
                    });
                    const h = e.querySelector("x");
                    h && h.remove();
                    const p = [];
                    S.packet2JSON(e, p), this.lastPresences[t] = p;
                    const m = e => {
                        const t = {},
                            n = e.children.find(e => "user" === e.tagName);
                        if (n) {
                            t.user = {};
                            for (const e of ["id", "name", "avatar"]) {
                                const i = n.children.find(t => t.tagName === e);
                                i && (t.user[e] = i.value)
                            }
                        }
                        const i = e.children.find(e => "group" === e.tagName);
                        return i && (t.group = i.value), t
                    };
                    for (let e = 0; e < p.length; e++) {
                        const t = p[e];
                        switch (t.tagName) {
                            case "bot": {
                                const {
                                    attributes: e
                                } = t;
                                if (!e) break;
                                const {
                                    type: i
                                } = e;
                                n.botType = i;
                                break
                            }
                            case "nick":
                                n.nick = t.value;
                                break;
                            case "userId":
                                n.id = t.value;
                                break;
                            case "stats-id":
                                n.statsID = t.value;
                                break;
                            case "identity":
                                n.identity = m(t);
                                break;
                            case "features":
                                n.features = this._extractFeatures(t);
                                break;
                            case "stat": {
                                const {
                                    attributes: e
                                } = t;
                                if (!e) break;
                                const {
                                    name: i
                                } = e;
                                "version" === i && (n.version = e.value);
                                break
                            }
                        }
                    }
                    if (t === this.myroomjid) {
                        const e = "owner" === n.affiliation ? n.role : "none";
                        if (this.role !== e && (this.role = e, this.eventEmitter.emit(u.a.LOCAL_ROLE_CHANGED, this.role)), !this.joined) {
                            this.joined = !0;
                            const e = this.connectionTimes["muc.joined"] = window.performance.now();
                            v.log("(TIME) MUC joined:\t", e), this.password && (this.locked = !0), this.presenceUpdateTime >= this.presenceSyncTime && this.sendPresence(), this.eventEmitter.emit(u.a.MUC_JOINED), !this.options.disableDiscoInfo && this.discoRoomInfo()
                        }
                    } else if (void 0 === l) v.info("Ignoring member with undefined JID");
                    else if (void 0 === this.members[t]) this.members[t] = n, v.log("entered", t, n), s = void 0 !== n.status, a = void 0 !== n.version, n.isFocus ? this._initFocus(t, n.features) : (this.eventEmitter.emit(u.a.MUC_MEMBER_JOINED, t, n.nick, n.role, n.isHiddenDomain, n.statsID, n.status, n.identity, n.botType, n.jid, n.features, n.isReplaceParticipant), s = !1);
                    else {
                        const e = this.members[t];
                        e.role !== n.role && (e.role = n.role, this.eventEmitter.emit(u.a.MUC_ROLE_CHANGED, t, n.role)), e.affiliation !== n.affiliation && (e.affiliation = n.affiliation), e.botType !== n.botType && (e.botType = n.botType, this.eventEmitter.emit(u.a.MUC_MEMBER_BOT_TYPE_CHANGED, t, n.botType)), n.isFocus && (e.isFocus = !0, this._initFocus(t, n.features)), n.displayName && (e.displayName = n.displayName), e.status !== n.status && (s = !0, e.status = n.status), e.version !== n.version && (a = !0, e.version = n.version), r()(e.features, n.features) || (e.features = n.features, this.eventEmitter.emit(u.a.PARTICIPANT_FEATURES_CHANGED, t, n.features))
                    }
                    for (let e = 0; e < p.length; e++) {
                        const i = p[e];
                        switch (i.tagName) {
                            case "nick":
                                if (!n.isFocus) {
                                    const e = this.xmpp.options.displayJids ? o.Strophe.getResourceFromJid(t) : n.nick;
                                    this.eventEmitter.emit(u.a.DISPLAY_NAME_CHANGED, t, e)
                                }
                                break;
                            case "bridgeNotAvailable":
                                n.isFocus && !this.noBridgeAvailable && (this.noBridgeAvailable = !0, this.eventEmitter.emit(u.a.BRIDGE_DOWN));
                                break;
                            case "conference-properties":
                                if (n.isFocus) {
                                    const e = {};
                                    for (let t = 0; t < i.children.length; t++) {
                                        const {
                                            attributes: n
                                        } = i.children[t];
                                        n && n.key && (e[n.key] = n.value)
                                    }
                                    this.eventEmitter.emit(u.a.CONFERENCE_PROPERTIES_CHANGED, e), this.restartByTerminateSupported = "true" === e["support-terminate-restart"], v.info("Jicofo supports restart by terminate: " + this.supportsRestartByTerminate())
                                }
                                break;
                            case "transcription-status": {
                                const {
                                    attributes: e
                                } = i;
                                if (!e) break;
                                const {
                                    status: t
                                } = e;
                                t && t !== this.transcriptionStatus && (this.transcriptionStatus = t, this.eventEmitter.emit(u.a.TRANSCRIPTION_STATUS_CHANGED, t));
                                break
                            }
                            case "call-control": {
                                const e = i.attributes;
                                if (!e) break;
                                this.phoneNumber = e.phone || null, this.phonePin = e.pin || null, this.eventEmitter.emit(u.a.PHONE_NUMBER_CHANGED);
                                break
                            }
                            default:
                                this.processNode(i, t)
                        }
                    }
                    s && this.eventEmitter.emit(u.a.PRESENCE_STATUS, t, n.status), a && v.info(`Received version for ${l}: ${n.version}`)
                }
                _extractFeatures(e) {
                    const t = new Set;
                    for (let n = 0; n < e.children.length; n++) {
                        const {
                            attributes: i
                        } = e.children[n];
                        i && i.var && t.add(i.var)
                    }
                    return t
                }
                _initFocus(e, t) {
                    this.focusMucJid = e, this.focusFeatures = t
                }
                setParticipantPropertyListener(e) {
                    this.participantPropertyListener = e
                }
                supportsRestartByTerminate() {
                    return this.restartByTerminateSupported
                }
                processNode(e, t) {
                    try {
                        let n = this.presHandlers[e.tagName];
                        e.tagName.startsWith("jitsi_participant_") && (n = [this.participantPropertyListener]), n && n.forEach(n => {
                            n(e, o.Strophe.getResourceFromJid(t), t)
                        })
                    } catch (t) {
                        h.a.callErrorHandler(t), v.error(`Error processing:${e.tagName} node.`, t)
                    }
                }
                sendMessage(e, t) {
                    const n = Object(o.$msg)({
                        to: this.roomjid,
                        type: "groupchat"
                    });
                    "body" === t ? n.c(t, {}, e) : n.c(t, {
                        xmlns: "http://jitsi.org/jitmeet"
                    }, e), this.connection.send(n), this.eventEmitter.emit(u.a.SENDING_CHAT_MESSAGE, e)
                }
                sendPrivateMessage(e, t, n) {
                    const i = Object(o.$msg)({
                        to: `${this.roomjid}/${e}`,
                        type: "chat"
                    });
                    "body" === n ? i.c(n, t).up() : i.c(n, {
                        xmlns: "http://jitsi.org/jitmeet"
                    }, t).up(), this.connection.send(i), this.eventEmitter.emit(u.a.SENDING_PRIVATE_CHAT_MESSAGE, t)
                }
                setSubject(e) {
                    const t = Object(o.$msg)({
                        to: this.roomjid,
                        type: "groupchat"
                    });
                    t.c("subject", e), this.connection.send(t)
                }
                onParticipantLeft(e, t) {
                    delete this.lastPresences[e], t || (this.eventEmitter.emit(u.a.MUC_MEMBER_LEFT, e), this.moderator.onMucMemberLeft(e))
                }
                onPresenceUnavailable(e, t) {
                    if ($(e).find('>ignore[xmlns="http://jitsi.org/jitmeet/"]').length) return !0;
                    const n = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy');
                    if (n.length) {
                        let t;
                        const i = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy>reason');
                        return i.length && (t = i.text()), this.eventEmitter.emit(u.a.MUC_DESTROYED, t, n.attr("jid")), this.connection.emuc.doLeave(this.roomjid), !0
                    }
                    const i = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="110"]').length,
                        s = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="307"]').length,
                        r = Object.keys(this.members),
                        a = $(e).find("flip_device").length;
                    if (s) {
                        const n = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>actor');
                        let s, r;
                        n.length && (s = n.attr("nick"));
                        const c = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>reason');
                        c.length && (r = c.text()), this.eventEmitter.emit(u.a.KICKED, i, s, o.Strophe.getResourceFromJid(t), r, a)
                    }
                    i ? (r.forEach(e => {
                        const t = this.members[e];
                        delete this.members[e], this.onParticipantLeft(e, t.isFocus)
                    }), this.connection.emuc.doLeave(this.roomjid), s || this.eventEmitter.emit(u.a.MUC_LEFT)) : (delete this.members[t], this.onParticipantLeft(t, !1))
                }
                onMessage(e, t) {
                    const n = e.getAttribute("type");
                    if ("error" === n) {
                        const t = $(e).find(">error>text").text();
                        return this.eventEmitter.emit(u.a.CHAT_ERROR_RECEIVED, t), !0
                    }
                    const i = $(e).find(">body").text(),
                        s = $(e).find(">subject");
                    if (s.length) {
                        const e = s.text();
                        (e || "" === e) && (this.eventEmitter.emit(u.a.SUBJECT_CHANGED, e), v.log("Subject is changed to " + e))
                    }
                    let r = $(e).find(">delay").attr("stamp");
                    if (!r && (r = $(e).find('>[xmlns="jabber:x:delay"]').attr("stamp"), r)) {
                        const e = r.match(/(\d{4})(\d{2})(\d{2}T\d{2}:\d{2}:\d{2})/);
                        r = `${e[1]}-${e[2]}-${e[3]}Z`
                    }
                    if (t === this.roomjid) {
                        let n;
                        if ($(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="104"]').length) this.discoRoomInfo();
                        else if ((n = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>invite')) && n.length) {
                            const s = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>password');
                            let r;
                            s && s.length && (r = s.text()), this.eventEmitter.emit(u.a.INVITE_MESSAGE_RECEIVED, t, n.attr("from"), i, r)
                        }
                    }
                    const o = $(e).find(">json-message").text();
                    if (o) {
                        const e = this.xmpp.tryParseJSONAndVerify(o);
                        if (e && void 0 === r) return void this.eventEmitter.emit(u.a.JSON_MESSAGE_RECEIVED, t, e)
                    }
                    i && ("chat" === n ? this.eventEmitter.emit(u.a.PRIVATE_MESSAGE_RECEIVED, t, i, this.myroomjid, r) : "groupchat" === n && this.eventEmitter.emit(u.a.MESSAGE_RECEIVED, t, i, this.myroomjid, r))
                }
                onPresenceError(e, t) {
                    if ($(e).find('>error[type="auth"]>not-authorized[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) v.log("on password required", t), this.eventEmitter.emit(u.a.PASSWORD_REQUIRED);
                    else if ($(e).find('>error[type="cancel"]>not-allowed[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
                        o.Strophe.getDomainFromJid(e.getAttribute("to")) === this.xmpp.options.hosts.anonymousdomain ? this.eventEmitter.emit(u.a.ROOM_JOIN_ERROR) : (v.warn("onPresError ", e), this.eventEmitter.emit(u.a.ROOM_CONNECT_NOT_ALLOWED_ERROR))
                    } else if ($(e).find(">error>service-unavailable").length) v.warn("Maximum users limit for the room has been reached", e), this.eventEmitter.emit(u.a.ROOM_MAX_USERS_ERROR);
                    else if ($(e).find('>error[type="auth"]>registration-required[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
                        const t = $(e).find(">lobbyroom");
                        let n;
                        t.length && (n = t.text()), this.eventEmitter.emit(u.a.ROOM_CONNECT_MEMBERS_ONLY_ERROR, n)
                    } else v.warn("onPresError ", e), this.eventEmitter.emit(u.a.ROOM_CONNECT_ERROR)
                }
                setAffiliation(e, t) {
                    const n = Object(o.$iq)({
                        to: this.roomjid,
                        type: "set"
                    }).c("query", {
                        xmlns: "http://jabber.org/protocol/muc#admin"
                    }).c("item", {
                        affiliation: t,
                        nick: o.Strophe.getResourceFromJid(e)
                    }).c("reason").t(`Your affiliation has been changed to '${t}'.`).up().up().up();
                    this.connection.sendIQ(n, n => v.log("Set affiliation of participant with jid: ", e, "to", t, n), e => v.log("Set affiliation of participant error: ", e))
                }
                kick(e, t = "You have been kicked.") {
                    const n = Object(o.$iq)({
                        to: this.roomjid,
                        type: "set"
                    }).c("query", {
                        xmlns: "http://jabber.org/protocol/muc#admin"
                    }).c("item", {
                        nick: o.Strophe.getResourceFromJid(e),
                        role: "none"
                    }).c("reason").t(t).up().up().up();
                    this.connection.sendIQ(n, t => v.log("Kick participant with jid: ", e, t), e => v.log("Kick participant error: ", e))
                }
                lockRoom(e, t, n, i) {
                    this.connection.sendIQ(Object(o.$iq)({
                        to: this.roomjid,
                        type: "get"
                    }).c("query", {
                        xmlns: "http://jabber.org/protocol/muc#owner"
                    }), s => {
                        if ($(s).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_roomsecret"]').length) {
                            const i = Object(o.$iq)({
                                to: this.roomjid,
                                type: "set"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#owner"
                            });
                            i.c("x", {
                                xmlns: "jabber:x:data",
                                type: "submit"
                            }), i.c("field", {
                                var: "FORM_TYPE"
                            }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), i.c("field", {
                                var: "muc#roomconfig_roomsecret"
                            }).c("value").t(e).up().up(), i.c("field", {
                                var: "muc#roomconfig_passwordprotectedroom"
                            }).c("value").t(null === e || 0 === e.length ? "0" : "1").up().up(), this.membersOnlyEnabled && i.c("field", {
                                var: "muc#roomconfig_membersonly"
                            }).c("value").t("true").up().up(), i.c("field", {
                                var: "muc#roomconfig_whois"
                            }).c("value").t("anyone").up().up(), this.connection.sendIQ(i, () => {
                                this.password = e, t()
                            }, n)
                        } else i()
                    }, n)
                }
                setMembersOnly(e, t, n) {
                    e && Object.values(this.members).filter(e => !e.isFocus).length && Object.values(this.members).forEach(e => {
                        e.jid && !E.includes(e.affiliation) && this.xmpp.connection.sendIQ(Object(o.$iq)({
                            to: this.roomjid,
                            type: "set"
                        }).c("query", {
                            xmlns: "http://jabber.org/protocol/muc#admin"
                        }).c("item", {
                            affiliation: "member",
                            jid: e.jid
                        }).up().up())
                    });
                    const i = n || (() => {});
                    this.xmpp.connection.sendIQ(Object(o.$iq)({
                        to: this.roomjid,
                        type: "get"
                    }).c("query", {
                        xmlns: "http://jabber.org/protocol/muc#owner"
                    }), n => {
                        if ($(n).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_membersonly"]').length) {
                            const n = Object(o.$iq)({
                                to: this.roomjid,
                                type: "set"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#owner"
                            });
                            n.c("x", {
                                xmlns: "jabber:x:data",
                                type: "submit"
                            }), n.c("field", {
                                var: "FORM_TYPE"
                            }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), n.c("field", {
                                var: "muc#roomconfig_membersonly"
                            }).c("value").t(e ? "true" : "false").up().up(), this.locked && n.c("field", {
                                var: "muc#roomconfig_passwordprotectedroom"
                            }).c("value").t("1").up().up(), this.xmpp.connection.sendIQ(n, t, i)
                        } else i(new Error("Setting members only room not supported!"))
                    }, i)
                }
                addToPresence(e, t) {
                    return this.addOrReplaceInPresence(e, t)
                }
                addOrReplaceInPresence(e, t) {
                    t.tagName = e;
                    const n = this.presMap.nodes.filter(t => e === t.tagName);
                    return (1 !== n.length || !r()(n[0], t)) && (this.removeFromPresence(e), this.presMap.nodes.push(t), this.presenceUpdateTime = Date.now(), !0)
                }
                getFromPresence(e) {
                    return this.presMap.nodes.find(t => e === t.tagName)
                }
                removeFromPresence(e) {
                    const t = this.presMap.nodes.filter(t => e !== t.tagName);
                    this.presMap.nodes = t, this.presenceUpdateTime = Date.now()
                }
                addPresenceListener(e, t) {
                    if ("function" != typeof t) throw new Error('"handler" is not a function');
                    let n = this.presHandlers[e];
                    n || (this.presHandlers[e] = n = []), -1 === n.indexOf(t) ? n.push(t) : v.warn("Trying to add the same handler more than once for: " + e)
                }
                removePresenceListener(e, t) {
                    const n = this.presHandlers[e],
                        i = n ? n.indexOf(t) : -1; - 1 !== i ? n.splice(i, 1) : v.warn(`Handler for: ${e} was not registered`)
                }
                isFocus(e) {
                    const t = this.members[e];
                    return t ? t.isFocus : null
                }
                isModerator() {
                    return "moderator" === this.role
                }
                getMemberRole(e) {
                    return this.members[e] ? this.members[e].role : null
                }
                setVideoMute(e, t) {
                    this.sendVideoInfoPresence(e), t && t(e)
                }
                setAudioMute(e, t) {
                    return this.sendAudioInfoPresence(e, t)
                }
                addAudioInfoToPresence(e) {
                    return !(e && !this.getFromPresence("audiomuted")) && this.addOrReplaceInPresence("audiomuted", {
                        value: e.toString()
                    })
                }
                sendAudioInfoPresence(e, t) {
                    this.addAudioInfoToPresence(e) && this.sendPresence(), t && t()
                }
                addVideoInfoToPresence(e) {
                    return !(e && !this.getFromPresence("videomuted")) && this.addOrReplaceInPresence("videomuted", {
                        value: e.toString()
                    })
                }
                sendVideoInfoPresence(e) {
                    this.addVideoInfoToPresence(e) && this.sendPresence()
                }
                getMediaPresenceInfo(e, t) {
                    const n = this.lastPresences[`${this.roomjid}/${e}`];
                    if (!n) return null;
                    const i = {
                        muted: !0,
                        videoType: void 0
                    };
                    let s = null;
                    if (t === c.a) s = y(n, "audiomuted");
                    else {
                        if (t !== c.c) return v.error("Unsupported media type: " + t), null; {
                            s = y(n, "videomuted");
                            const e = y(n, "jitsi_participant_codecType"),
                                t = y(n, "videoType");
                            t.length > 0 && (i.videoType = t[0].value), e.length > 0 && (i.codecType = e[0].value)
                        }
                    }
                    return s.length > 0 && (i.muted = "true" === s[0].value), i
                }
                isSIPCallingSupported() {
                    return !!this.moderator && this.moderator.isSipGatewayEnabled()
                }
                dial(e) {
                    return this.connection.rayo.dial(e, "fromnumber", o.Strophe.getBareJidFromJid(this.myroomjid), this.password, this.focusMucJid)
                }
                hangup() {
                    return this.connection.rayo.hangup()
                }
                getLobby() {
                    return this.lobby
                }
                getAVModeration() {
                    return this.avModeration
                }
                getPhoneNumber() {
                    return this.phoneNumber
                }
                getPhonePin() {
                    return this.phonePin
                }
                getMeetingId() {
                    return this.meetingId
                }
                muteParticipant(e, t, n) {
                    v.info("set mute", t);
                    const i = Object(o.$iq)({
                        to: this.focusMucJid,
                        type: "set"
                    }).c("mute", {
                        xmlns: "http://jitsi.org/jitmeet/" + n,
                        jid: e
                    }).t(t.toString()).up();
                    this.connection.sendIQ(i, e => v.log("set mute", e), e => v.log("set mute error", e))
                }
                onMute(e) {
                    if (e.getAttribute("from") !== this.focusMucJid) return void v.warn("Ignored mute from non focus peer");
                    const t = $(e).find("mute");
                    t.length && "true" === t.text() ? this.eventEmitter.emit(u.a.AUDIO_MUTED_BY_FOCUS, t.attr("actor")) : v.warn("Ignoring a mute request which does not explicitly specify a positive mute command.")
                }
                onMuteVideo(e) {
                    if (e.getAttribute("from") !== this.focusMucJid) return void v.warn("Ignored mute from non focus peer");
                    const t = $(e).find("mute");
                    t.length && "true" === t.text() ? this.eventEmitter.emit(u.a.VIDEO_MUTED_BY_FOCUS, t.attr("actor")) : v.warn("Ignoring a mute request which does not explicitly specify a positive mute command.")
                }
                clean() {
                    this._removeConnListeners.forEach(e => e()), this._removeConnListeners = [], this.joined = !1
                }
                leave() {
                    return new Promise((e, t) => {
                        const n = setTimeout(() => s(!0), 5e3),
                            i = this.eventEmitter;

                        function s(r = !1) {
                            i.removeListener(u.a.MUC_LEFT, s), clearTimeout(n), r ? t(new Error("The timeout for the confirmation about leaving the room expired.")) : e()
                        }
                        this.clean(), i.on(u.a.MUC_LEFT, s), this.doLeave()
                    })
                }
            }
        }).call(this, "modules/xmpp/ChatRoom.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var i = n(5),
                s = n(2),
                r = n(4),
                o = n(0),
                a = n.n(o);
            const c = Object(i.getLogger)(e);
            class d {
                constructor(e) {
                    this._xmpp = e.xmpp, this._mainRoom = e, this._momderationEnabledByType = {
                        [r.a]: !1,
                        [r.c]: !1
                    }, this._whitelistAudio = [], this._whitelistVideo = [], this._xmpp.addListener(a.a.AV_MODERATION_RECEIVED, this._onMessage.bind(this))
                }
                isSupported() {
                    return Boolean(this._xmpp.avModerationComponentAddress)
                }
                enable(e, t) {
                    if (!this.isSupported() || !this._mainRoom.isModerator()) return void c.error(`Cannot enable:${e} AV moderation supported:${this.isSupported()}, \n                moderator:${this._mainRoom.isModerator()}`);
                    if (e === this._momderationEnabledByType[t]) return void c.warn(`Moderation already in state:${e} for mediaType:${t}`);
                    const n = Object(s.$msg)({
                        to: this._xmpp.avModerationComponentAddress
                    });
                    n.c("av_moderation", {
                        enable: e,
                        mediaType: t
                    }).up(), this._xmpp.connection.send(n)
                }
                approve(e, t) {
                    if (!this.isSupported() || !this._mainRoom.isModerator()) return void c.error(`Cannot approve in AV moderation supported:${this.isSupported()}, \n                moderator:${this._mainRoom.isModerator()}`);
                    const n = Object(s.$msg)({
                        to: this._xmpp.avModerationComponentAddress
                    });
                    n.c("av_moderation", {
                        mediaType: e,
                        jidToWhitelist: t
                    }).up(), this._xmpp.connection.send(n)
                }
                _onMessage(e) {
                    const t = e.whitelists;
                    if (t) {
                        const e = (e, t, n) => {
                            n.filter(e => !t.includes(e)).forEach(t => this._xmpp.eventEmitter.emit(a.a.AV_MODERATION_PARTICIPANT_APPROVED, e, t))
                        };
                        t[r.a] && e(r.a, this._whitelistAudio, t[r.a]), t[r.c] && e(r.c, this._whitelistVideo, t[r.c])
                    } else void 0 !== e.enabled && this._momderationEnabledByType[e.mediaType] !== e.enabled ? (this._momderationEnabledByType[e.mediaType] = e.enabled, this._xmpp.eventEmitter.emit(a.a.AV_MODERATION_CHANGED, e.enabled, e.mediaType, e.actor)) : e.approved && this._xmpp.eventEmitter.emit(a.a.AV_MODERATION_APPROVED, e.mediaType)
                }
            }
        }).call(this, "modules/xmpp/AVModeration.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return c
            }));
            var i = n(5),
                s = n(2),
                r = n(0),
                o = n.n(r);
            const a = Object(i.getLogger)(e);
            class c {
                constructor(e) {
                    this.xmpp = e.xmpp, this.mainRoom = e;
                    const t = this._maybeJoinLobbyRoom.bind(this);
                    this.mainRoom.addEventListener(o.a.LOCAL_ROLE_CHANGED, t), this.mainRoom.addEventListener(o.a.MUC_MEMBERS_ONLY_CHANGED, t), this.mainRoom.addEventListener(o.a.ROOM_CONNECT_MEMBERS_ONLY_ERROR, e => {
                        this.lobbyRoomJid = e
                    })
                }
                isSupported() {
                    return this.xmpp.lobbySupported
                }
                enable() {
                    return this.isSupported() ? new Promise((e, t) => {
                        this.mainRoom.setMembersOnly(!0, e, t)
                    }) : Promise.reject(new Error("Lobby not supported!"))
                }
                disable() {
                    this.isSupported() && this.mainRoom.isModerator() && this.lobbyRoom && this.mainRoom.membersOnlyEnabled && this.mainRoom.setMembersOnly(!1)
                }
                _leaveLobbyRoom() {
                    this.lobbyRoom && this.lobbyRoom.leave().then(() => {
                        this.lobbyRoom = void 0, a.info("Lobby room left!")
                    }).catch(() => {})
                }
                setLobbyRoomJid(e) {
                    this.lobbyRoomJid = e
                }
                _maybeJoinLobbyRoom() {
                    if (!this.isSupported()) return;
                    this.mainRoom.joined && this.mainRoom.isModerator() && this.mainRoom.membersOnlyEnabled && !this.lobbyRoom && this.join().then(() => a.info("Joined lobby room")).catch(e => a.error("Failed joining lobby", e))
                }
                join(e, t) {
                    const n = this.mainRoom.joined && this.mainRoom.isModerator();
                    if (!this.lobbyRoomJid) return Promise.reject(new Error("Missing lobbyRoomJid, cannot join lobby room."));
                    const i = s.Strophe.getNodeFromJid(this.lobbyRoomJid),
                        r = s.Strophe.getDomainFromJid(this.lobbyRoomJid);
                    return this.lobbyRoom = this.xmpp.createRoom(i, {
                        customDomain: r,
                        disableDiscoInfo: !0,
                        disableFocus: !0,
                        enableLobby: !1
                    }), e && this.lobbyRoom.addOrReplaceInPresence("nick", {
                        attributes: {
                            xmlns: "http://jabber.org/protocol/nick"
                        },
                        value: e
                    }), n ? (this.lobbyRoom.addPresenceListener("email", (e, t) => {
                        this.mainRoom.eventEmitter.emit(o.a.MUC_LOBBY_MEMBER_UPDATED, t, {
                            email: e.value
                        })
                    }), this.lobbyRoom.addEventListener(o.a.MUC_MEMBER_JOINED, (e, t, n, i, r, a, c, d, u) => {
                        Object.values(this.mainRoom.members).find(e => e.jid === u) || this.mainRoom.eventEmitter.emit(o.a.MUC_LOBBY_MEMBER_JOINED, s.Strophe.getResourceFromJid(e), t, c ? c.avatar : void 0)
                    }), this.lobbyRoom.addEventListener(o.a.MUC_MEMBER_LEFT, e => {
                        this.mainRoom.eventEmitter.emit(o.a.MUC_LOBBY_MEMBER_LEFT, s.Strophe.getResourceFromJid(e))
                    }), this.lobbyRoom.addEventListener(o.a.MUC_DESTROYED, () => {
                        Object.keys(this.lobbyRoom.members).forEach(e => this.mainRoom.eventEmitter.emit(o.a.MUC_LOBBY_MEMBER_LEFT, s.Strophe.getResourceFromJid(e))), this.lobbyRoom.clean(), this.lobbyRoom = void 0, a.info("Lobby room left(destroyed)!")
                    })) : (this.lobbyRoom.addEventListener(o.a.KICKED, e => {
                        /* if (e) BAO */return this.mainRoom.eventEmitter.emit(o.a.MUC_DENIED_ACCESS), void this.lobbyRoom.clean()
                    }), this.mainRoom.addEventListener(o.a.INVITE_MESSAGE_RECEIVED, (e, t, n, i) => {
                        a.debug(`Received approval to join ${e} ${t} ${n}`), e === this.mainRoom.roomjid && (this.mainRoom.join(i), this._leaveLobbyRoom())
                    }), this.lobbyRoom.addEventListener(o.a.MUC_DESTROYED, (e, t) => {
                        t ? this.mainRoom.join() : (this.lobbyRoom.clean(), this.mainRoom.eventEmitter.emit(o.a.MUC_DESTROYED, e))
                    }), this.mainRoom.addEventListener(o.a.MUC_JOINED, () => {
                        this._leaveLobbyRoom()
                    })), new Promise((e, i) => {
                        this.lobbyRoom.addEventListener(o.a.MUC_JOINED, () => {
                            e(), t && !n && this.lobbyRoom.addOrReplaceInPresence("email", {
                                value: t
                            }) && this.lobbyRoom.sendPresence()
                        }), this.lobbyRoom.addEventListener(o.a.ROOM_JOIN_ERROR, i), this.lobbyRoom.addEventListener(o.a.ROOM_CONNECT_NOT_ALLOWED_ERROR, i), this.lobbyRoom.addEventListener(o.a.ROOM_CONNECT_ERROR, i), this.lobbyRoom.join()
                    })
                }
                denyAccess(e) {
                    if (!this.isSupported() || !this.mainRoom.isModerator()) return;
                    const t = Object.keys(this.lobbyRoom.members).find(t => s.Strophe.getResourceFromJid(t) === e);
                    t ? this.lobbyRoom.kick(t) : a.error(`Not found member for ${e} in lobby room.`)
                }
                approveAccess(e) {
                    if (!this.isSupported() || !this.mainRoom.isModerator()) return;
                    const t = Object.keys(this.lobbyRoom.members).find(t => s.Strophe.getResourceFromJid(t) === e);
                    if (t) {
                        const e = this.lobbyRoom.members[t].jid,
                            n = Object(s.$msg)({
                                to: this.mainRoom.roomjid
                            }).c("x", {
                                xmlns: "http://jabber.org/protocol/muc#user"
                            }).c("invite", {
                                to: e
                            });
                        this.xmpp.connection.sendIQ(n, () => {}, t => {
                            a.error("Error sending invite for " + e, t)
                        })
                    } else a.error(`Not found member for ${t} in lobby room.`)
                }
            }
        }).call(this, "modules/xmpp/Lobby.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return l
            }));
            var i = n(5),
                s = n(2),
                r = n(29);
            const o = n(72),
                a = n(0),
                c = n(12),
                d = Object(i.getLogger)(e);

            function u(e) {
                let t = 1;
                return function(n) {
                    if (n) return void(t = 1);
                    const i = Math.pow(2, t - 1);
                    return t += 1, i * e
                }
            }

            function l(e, t, n, i) {
                function s(e) {
                    if (e.data && e.data.sessionId) {
                        if (e.origin !== window.location.origin) return void d.warn("Ignoring sessionId from different origin: " + e.origin);
                        r.a.sessionId = e.data.sessionId
                    }
                }
                this.roomName = e, this.xmppService = t, this.getNextTimeout = u(1e3), this.getNextErrorTimeout = u(1e3), this.externalAuthEnabled = !1, this.options = i, this.sipGatewayEnabled = !1, this.eventEmitter = n, this.connection = this.xmppService.connection, window.addEventListener ? window.addEventListener("message", s, !1) : window.attachEvent("onmessage", s)
            }
            l.prototype.isExternalAuthEnabled = function() {
                return this.externalAuthEnabled
            }, l.prototype.isSipGatewayEnabled = function() {
                return this.sipGatewayEnabled
            }, l.prototype.onMucMemberLeft = function(e) {
                d.info("Someone left is it focus ? " + e);
                "focus" === s.Strophe.getResourceFromJid(e) && (d.info("Focus has left the room - leaving conference"), this.eventEmitter.emit(a.FOCUS_LEFT))
            }, l.prototype.setFocusUserJid = function(e) {
                this.focusUserJid || (this.focusUserJid = e, d.info("Focus jid set to:  " + this.focusUserJid))
            }, l.prototype.getFocusUserJid = function() {
                return this.focusUserJid
            }, l.prototype.getFocusComponent = function() {
                let e = this.options.connection.hosts.focus;
                return e || (e = "focus." + this.options.connection.hosts.domain), e
            }, l.prototype.createConferenceIq = function() {
                const e = Object(s.$iq)({
                        to: this.getFocusComponent(),
                        type: "set"
                    }),
                    {
                        sessionId: t
                    } = r.a,
                    n = r.a.machineId,
                    i = this.options.conference;
                return d.info(`Session ID: ${t} machine UID: ${n}`), e.c("conference", {
                    xmlns: "http://jitsi.org/protocol/focus",
                    room: this.roomName,
                    "machine-uid": n
                }), t && e.attrs({
                    "session-id": t
                }), e.c("property", {
                    name: "disableRtx",
                    value: Boolean(i.disableRtx)
                }).up(), void 0 !== i.audioPacketDelay && e.c("property", {
                    name: "audioPacketDelay",
                    value: i.audioPacketDelay
                }).up(), i.startBitrate && e.c("property", {
                    name: "startBitrate",
                    value: i.startBitrate
                }).up(), i.minBitrate && e.c("property", {
                    name: "minBitrate",
                    value: i.minBitrate
                }).up(), void 0 !== this.options.conference.startAudioMuted && e.c("property", {
                    name: "startAudioMuted",
                    value: this.options.conference.startAudioMuted
                }).up(), void 0 !== this.options.conference.startVideoMuted && e.c("property", {
                    name: "startVideoMuted",
                    value: this.options.conference.startVideoMuted
                }).up(), e.up(), e
            }, l.prototype.parseSessionId = function(e) {
                const t = $(e).find("conference").attr("session-id");
                t && (d.info("Received sessionId:  " + t), r.a.sessionId = t)
            }, l.prototype.parseConfigOptions = function(e) {
                this.setFocusUserJid($(e).find("conference").attr("focusjid"));
                const t = $(e).find(">conference>property[name='authentication'][value='true']").length > 0;
                d.info("Authentication enabled: " + t), this.externalAuthEnabled = $(e).find(">conference>property[name='externalAuth'][value='true']").length > 0, d.info("External authentication enabled: " + this.externalAuthEnabled), this.externalAuthEnabled || this.parseSessionId(e);
                const n = $(e).find(">conference").attr("identity");
                this.eventEmitter.emit(o.IDENTITY_UPDATED, t, n), $(e).find(">conference>property[name='sipGatewayEnabled'][value='true']").length && (this.sipGatewayEnabled = !0), d.info("Sip gateway enabled:  " + this.sipGatewayEnabled)
            }, l.prototype.allocateConferenceFocus = function() {
                return new Promise(e => {
                    this.setFocusUserJid(this.options.connection.focusUserJid), this.connection.sendIQ(this.createConferenceIq(), t => this._allocateConferenceFocusSuccess(t, e), t => this._allocateConferenceFocusError(t, e)), this.connection.flush()
                })
            }, l.prototype._allocateConferenceFocusError = function(e, t) {
                const n = $(e).find(">error>session-invalid").length || $(e).find(">error>not-acceptable").length;
                if (n && (d.info("Session expired! - removing"), r.a.sessionId = void 0), $(e).find(">error>graceful-shutdown").length) return void this.eventEmitter.emit(a.GRACEFUL_SHUTDOWN);
                const i = $(e).find(">error>reservation-error");
                if (i.length) {
                    const t = i.attr("error-code"),
                        n = $(e).find(">error>text");
                    let s;
                    return n && (s = n.text()), void this.eventEmitter.emit(a.RESERVATION_ERROR, t, s)
                }
                if ($(e).find(">error>not-authorized").length) {
                    d.warn("Unauthorized to start the conference", e);
                    return s.Strophe.getDomainFromJid(e.getAttribute("to")) !== this.options.connection.hosts.anonymousdomain && (this.externalAuthEnabled = !0), void this.eventEmitter.emit(a.AUTHENTICATION_REQUIRED)
                }
                const o = this.getNextErrorTimeout(),
                    u = "Focus error, retry after " + o;
                c.callErrorHandler(new Error(u)), d.error(u, e);
                const l = this.getFocusComponent(),
                    h = o / 1e3;
                n || this.eventEmitter.emit(a.FOCUS_DISCONNECTED, l, h), this.getNextTimeout(!0), window.setTimeout(() => this.allocateConferenceFocus().then(t), o)
            }, l.prototype._allocateConferenceFocusSuccess = function(e, t) {
                if (this.parseConfigOptions(e), this.getNextErrorTimeout(!0), "true" === $(e).find("conference").attr("ready")) this.getNextTimeout(!0), t();
                else {
                    const e = this.getNextTimeout();
                    d.info("Waiting for the focus... " + e), window.setTimeout(() => this.allocateConferenceFocus().then(t), e)
                }
            }, l.prototype.authenticate = function() {
                return new Promise((e, t) => {
                    this.connection.sendIQ(this.createConferenceIq(), t => {
                        this.parseSessionId(t), e()
                    }, e => t({
                        error: $(e).find("iq>error :first").prop("tagName"),
                        message: $(e).find("iq>error>text").text()
                    }))
                })
            }, l.prototype.getLoginUrl = function(e, t) {
                this._getLoginUrl(!1, e, t)
            }, l.prototype._getLoginUrl = function(e, t, n) {
                const i = Object(s.$iq)({
                        to: this.getFocusComponent(),
                        type: "get"
                    }),
                    o = {
                        xmlns: "http://jitsi.org/protocol/focus",
                        room: this.roomName,
                        "machine-uid": r.a.machineId
                    };
                let a = "auth url";

                function u(e, t) {
                    c.callErrorHandler(new Error(e)), d.error(e, t), n(t)
                }
                e && (o.popup = !0, a = "POPUP " + a), i.c("login-url", o), this.connection.sendIQ(i, e => {
                    let n = $(e).find("login-url").attr("url");
                    n = decodeURIComponent(n), n ? (d.info(`Got ${a}: ${n}`), t(n)) : u(`Failed to get ${a} from the focus`, e)
                }, u.bind(void 0, `Get ${a} error`))
            }, l.prototype.getPopupLoginUrl = function(e, t) {
                this._getLoginUrl(!0, e, t)
            }, l.prototype.logout = function(e) {
                const t = Object(s.$iq)({
                        to: this.getFocusComponent(),
                        type: "set"
                    }),
                    {
                        sessionId: n
                    } = r.a;
                n ? (t.c("logout", {
                    xmlns: "http://jitsi.org/protocol/focus",
                    "session-id": n
                }), this.connection.sendIQ(t, t => {
                    let n = $(t).find("logout").attr("logout-url");
                    n && (n = decodeURIComponent(n)), d.info("Log out OK, url: " + n, t), r.a.sessionId = void 0, e(n)
                }, e => {
                    c.callErrorHandler(new Error("Logout error")), d.error("Logout error", e)
                })) : e()
            }
        }).call(this, "modules/xmpp/moderator.js")
    }, function(e, t, n) {
        const i = n(37),
            s = ["Aaliyah", "Aaron", "Abagail", "Abbey", "Abbie", "Abbigail", "Abby", "Abdiel", "Abdul", "Abdullah", "Abe", "Abel", "Abelardo", "Abigail", "Abigale", "Abigayle", "Abner", "Abraham", "Ada", "Adah", "Adalberto", "Adaline", "Adam", "Adan", "Addie", "Addison", "Adela", "Adelbert", "Adele", "Adelia", "Adeline", "Adell", "Adella", "Adelle", "Aditya", "Adolf", "Adolfo", "Adolph", "Adolphus", "Adonis", "Adrain", "Adrian", "Adriana", "Adrianna", "Adriel", "Adrien", "Adrienne", "Afton", "Aglae", "Agnes", "Agustin", "Agustina", "Ahmad", "Ahmed", "Aida", "Aidan", "Aiden", "Aileen", "Aisha", "Aiyana", "Akeem", "Al", "Alaina", "Alan", "Alana", "Alanis", "Alanna", "Alayna", "Alba", "Albert", "Alberta", "Albertha", "Alberto", "Albin", "Albina", "Alda", "Alden", "Alec", "Aleen", "Alejandra", "Alejandrin", "Alek", "Alena", "Alene", "Alessandra", "Alessandro", "Alessia", "Aletha", "Alex", "Alexa", "Alexander", "Alexandra", "Alexandre", "Alexandrea", "Alexandria", "Alexandrine", "Alexandro", "Alexane", "Alexanne", "Alexie", "Alexis", "Alexys", "Alexzander", "Alf", "Alfonso", "Alfonzo", "Alford", "Alfred", "Alfreda", "Alfredo", "Ali", "Alia", "Alice", "Alicia", "Alisa", "Alisha", "Alison", "Alivia", "Aliya", "Aliyah", "Aliza", "Alize", "Allan", "Allen", "Allene", "Allie", "Allison", "Ally", "Alphonso", "Alta", "Althea", "Alva", "Alvah", "Alvena", "Alvera", "Alverta", "Alvina", "Alvis", "Alyce", "Alycia", "Alysa", "Alysha", "Alyson", "Alysson", "Amalia", "Amanda", "Amani", "Amara", "Amari", "Amaya", "Amber", "Ambrose", "Amelia", "Amelie", "Amely", "America", "Americo", "Amie", "Amina", "Amir", "Amira", "Amiya", "Amos", "Amparo", "Amy", "Amya", "Ana", "Anabel", "Anabelle", "Anahi", "Anais", "Anastacio", "Anastasia", "Anderson", "Andre", "Andreane", "Andreanne", "Andres", "Andrew", "Andy", "Angel", "Angela", "Angelica", "Angelina", "Angeline", "Angelita", "Angelo", "Angie", "Angus", "Anibal", "Anika", "Anissa", "Anita", "Aniya", "Aniyah", "Anjali", "Anna", "Annabel", "Annabell", "Annabelle", "Annalise", "Annamae", "Annamarie", "Anne", "Annetta", "Annette", "Annie", "Ansel", "Ansley", "Anthony", "Antoinette", "Antone", "Antonetta", "Antonette", "Antonia", "Antonietta", "Antonina", "Antonio", "Antwan", "Antwon", "Anya", "April", "Ara", "Araceli", "Aracely", "Arch", "Archibald", "Ardella", "Arden", "Ardith", "Arely", "Ari", "Ariane", "Arianna", "Aric", "Ariel", "Arielle", "Arjun", "Arlene", "Arlie", "Arlo", "Armand", "Armando", "Armani", "Arnaldo", "Arne", "Arno", "Arnold", "Arnoldo", "Arnulfo", "Aron", "Art", "Arthur", "Arturo", "Arvel", "Arvid", "Arvilla", "Aryanna", "Asa", "Asha", "Ashlee", "Ashleigh", "Ashley", "Ashly", "Ashlynn", "Ashton", "Ashtyn", "Asia", "Assunta", "Astrid", "Athena", "Aubree", "Aubrey", "Audie", "Audra", "Audreanne", "Audrey", "August", "Augusta", "Augustine", "Augustus", "Aurelia", "Aurelie", "Aurelio", "Aurore", "Austen", "Austin", "Austyn", "Autumn", "Ava", "Avery", "Avis", "Axel", "Ayana", "Ayden", "Ayla", "Aylin", "Baby", "Bailee", "Bailey", "Barbara", "Barney", "Baron", "Barrett", "Barry", "Bart", "Bartholome", "Barton", "Baylee", "Beatrice", "Beau", "Beaulah", "Bell", "Bella", "Belle", "Ben", "Benedict", "Benjamin", "Bennett", "Bennie", "Benny", "Benton", "Berenice", "Bernadette", "Bernadine", "Bernard", "Bernardo", "Berneice", "Bernhard", "Bernice", "Bernie", "Berniece", "Bernita", "Berry", "Bert", "Berta", "Bertha", "Bertram", "Bertrand", "Beryl", "Bessie", "Beth", "Bethany", "Bethel", "Betsy", "Bette", "Bettie", "Betty", "Bettye", "Beulah", "Beverly", "Bianka", "Bill", "Billie", "Billy", "Birdie", "Blair", "Blaise", "Blake", "Blanca", "Blanche", "Blaze", "Bo", "Bobbie", "Bobby", "Bonita", "Bonnie", "Boris", "Boyd", "Brad", "Braden", "Bradford", "Bradley", "Bradly", "Brady", "Braeden", "Brain", "Brandi", "Brando", "Brandon", "Brandt", "Brandy", "Brandyn", "Brannon", "Branson", "Brant", "Braulio", "Braxton", "Brayan", "Breana", "Breanna", "Breanne", "Brenda", "Brendan", "Brenden", "Brendon", "Brenna", "Brennan", "Brennon", "Brent", "Bret", "Brett", "Bria", "Brian", "Briana", "Brianne", "Brice", "Bridget", "Bridgette", "Bridie", "Brielle", "Brigitte", "Brionna", "Brisa", "Britney", "Brittany", "Brock", "Broderick", "Brody", "Brook", "Brooke", "Brooklyn", "Brooks", "Brown", "Bruce", "Bryana", "Bryce", "Brycen", "Bryon", "Buck", "Bud", "Buddy", "Buford", "Bulah", "Burdette", "Burley", "Burnice", "Buster", "Cade", "Caden", "Caesar", "Caitlyn", "Cale", "Caleb", "Caleigh", "Cali", "Calista", "Callie", "Camden", "Cameron", "Camila", "Camilla", "Camille", "Camren", "Camron", "Camryn", "Camylle", "Candace", "Candelario", "Candice", "Candida", "Candido", "Cara", "Carey", "Carissa", "Carlee", "Carleton", "Carley", "Carli", "Carlie", "Carlo", "Carlos", "Carlotta", "Carmel", "Carmela", "Carmella", "Carmelo", "Carmen", "Carmine", "Carol", "Carolanne", "Carole", "Carolina", "Caroline", "Carolyn", "Carolyne", "Carrie", "Carroll", "Carson", "Carter", "Cary", "Casandra", "Casey", "Casimer", "Casimir", "Casper", "Cassandra", "Cassandre", "Cassidy", "Cassie", "Catalina", "Caterina", "Catharine", "Catherine", "Cathrine", "Cathryn", "Cathy", "Cayla", "Ceasar", "Cecelia", "Cecil", "Cecile", "Cecilia", "Cedrick", "Celestine", "Celestino", "Celia", "Celine", "Cesar", "Chad", "Chadd", "Chadrick", "Chaim", "Chance", "Chandler", "Chanel", "Chanelle", "Charity", "Charlene", "Charles", "Charley", "Charlie", "Charlotte", "Chase", "Chasity", "Chauncey", "Chaya", "Chaz", "Chelsea", "Chelsey", "Chelsie", "Chesley", "Chester", "Chet", "Cheyanne", "Cheyenne", "Chloe", "Chris", "Christ", "Christa", "Christelle", "Christian", "Christiana", "Christina", "Christine", "Christop", "Christophe", "Christopher", "Christy", "Chyna", "Ciara", "Cicero", "Cielo", "Cierra", "Cindy", "Citlalli", "Clair", "Claire", "Clara", "Clarabelle", "Clare", "Clarissa", "Clark", "Claud", "Claude", "Claudia", "Claudie", "Claudine", "Clay", "Clemens", "Clement", "Clementina", "Clementine", "Clemmie", "Cleo", "Cleora", "Cleta", "Cletus", "Cleve", "Cleveland", "Clifford", "Clifton", "Clint", "Clinton", "Clotilde", "Clovis", "Cloyd", "Clyde", "Coby", "Cody", "Colby", "Cole", "Coleman", "Colin", "Colleen", "Collin", "Colt", "Colten", "Colton", "Columbus", "Concepcion", "Conner", "Connie", "Connor", "Conor", "Conrad", "Constance", "Constantin", "Consuelo", "Cooper", "Cora", "Coralie", "Corbin", "Cordelia", "Cordell", "Cordia", "Cordie", "Corene", "Corine", "Cornelius", "Cornell", "Corrine", "Cortez", "Cortney", "Cory", "Coty", "Courtney", "Coy", "Craig", "Crawford", "Creola", "Cristal", "Cristian", "Cristina", "Cristobal", "Cristopher", "Cruz", "Crystal", "Crystel", "Cullen", "Curt", "Curtis", "Cydney", "Cynthia", "Cyril", "Cyrus", "Dagmar", "Dahlia", "Daija", "Daisha", "Daisy", "Dakota", "Dale", "Dallas", "Dallin", "Dalton", "Damaris", "Dameon", "Damian", "Damien", "Damion", "Damon", "Dan", "Dana", "Dandre", "Dane", "D'angelo", "Dangelo", "Danial", "Daniela", "Daniella", "Danielle", "Danika", "Dannie", "Danny", "Dante", "Danyka", "Daphne", "Daphnee", "Daphney", "Darby", "Daren", "Darian", "Dariana", "Darien", "Dario", "Darion", "Darius", "Darlene", "Daron", "Darrel", "Darrell", "Darren", "Darrick", "Darrin", "Darrion", "Darron", "Darryl", "Darwin", "Daryl", "Dashawn", "Dasia", "Dave", "David", "Davin", "Davion", "Davon", "Davonte", "Dawn", "Dawson", "Dax", "Dayana", "Dayna", "Dayne", "Dayton", "Dean", "Deangelo", "Deanna", "Deborah", "Declan", "Dedric", "Dedrick", "Dee", "Deion", "Deja", "Dejah", "Dejon", "Dejuan", "Delaney", "Delbert", "Delfina", "Delia", "Delilah", "Dell", "Della", "Delmer", "Delores", "Delpha", "Delphia", "Delphine", "Delta", "Demarco", "Demarcus", "Demario", "Demetris", "Demetrius", "Demond", "Dena", "Denis", "Dennis", "Deon", "Deondre", "Deontae", "Deonte", "Dereck", "Derek", "Derick", "Deron", "Derrick", "Deshaun", "Deshawn", "Desiree", "Desmond", "Dessie", "Destany", "Destin", "Destinee", "Destiney", "Destini", "Destiny", "Devan", "Devante", "Deven", "Devin", "Devon", "Devonte", "Devyn", "Dewayne", "Dewitt", "Dexter", "Diamond", "Diana", "Dianna", "Diego", "Dillan", "Dillon", "Dimitri", "Dina", "Dino", "Dion", "Dixie", "Dock", "Dolly", "Dolores", "Domenic", "Domenica", "Domenick", "Domenico", "Domingo", "Dominic", "Dominique", "Don", "Donald", "Donato", "Donavon", "Donna", "Donnell", "Donnie", "Donny", "Dora", "Dorcas", "Dorian", "Doris", "Dorothea", "Dorothy", "Dorris", "Dortha", "Dorthy", "Doug", "Douglas", "Dovie", "Doyle", "Drake", "Drew", "Duane", "Dudley", "Dulce", "Duncan", "Durward", "Dustin", "Dusty", "Dwight", "Dylan", "Earl", "Earlene", "Earline", "Earnest", "Earnestine", "Easter", "Easton", "Ebba", "Ebony", "Ed", "Eda", "Edd", "Eddie", "Eden", "Edgar", "Edgardo", "Edison", "Edmond", "Edmund", "Edna", "Eduardo", "Edward", "Edwardo", "Edwin", "Edwina", "Edyth", "Edythe", "Effie", "Efrain", "Efren", "Eileen", "Einar", "Eino", "Eladio", "Elaina", "Elbert", "Elda", "Eldon", "Eldora", "Eldred", "Eldridge", "Eleanora", "Eleanore", "Eleazar", "Electa", "Elena", "Elenor", "Elenora", "Eleonore", "Elfrieda", "Eli", "Elian", "Eliane", "Elias", "Eliezer", "Elijah", "Elinor", "Elinore", "Elisa", "Elisabeth", "Elise", "Eliseo", "Elisha", "Elissa", "Eliza", "Elizabeth", "Ella", "Ellen", "Ellie", "Elliot", "Elliott", "Ellis", "Ellsworth", "Elmer", "Elmira", "Elmo", "Elmore", "Elna", "Elnora", "Elody", "Eloisa", "Eloise", "Elouise", "Eloy", "Elroy", "Elsa", "Else", "Elsie", "Elta", "Elton", "Elva", "Elvera", "Elvie", "Elvis", "Elwin", "Elwyn", "Elyse", "Elyssa", "Elza", "Emanuel", "Emelia", "Emelie", "Emely", "Emerald", "Emerson", "Emery", "Emie", "Emil", "Emile", "Emilia", "Emiliano", "Emilie", "Emilio", "Emily", "Emma", "Emmalee", "Emmanuel", "Emmanuelle", "Emmet", "Emmett", "Emmie", "Emmitt", "Emmy", "Emory", "Ena", "Enid", "Enoch", "Enola", "Enos", "Enrico", "Enrique", "Ephraim", "Era", "Eriberto", "Eric", "Erica", "Erich", "Erick", "Ericka", "Erik", "Erika", "Erin", "Erling", "Erna", "Ernest", "Ernestina", "Ernestine", "Ernesto", "Ernie", "Ervin", "Erwin", "Eryn", "Esmeralda", "Esperanza", "Esta", "Esteban", "Estefania", "Estel", "Estell", "Estella", "Estelle", "Estevan", "Esther", "Estrella", "Etha", "Ethan", "Ethel", "Ethelyn", "Ethyl", "Ettie", "Eudora", "Eugene", "Eugenia", "Eula", "Eulah", "Eulalia", "Euna", "Eunice", "Eusebio", "Eva", "Evalyn", "Evan", "Evangeline", "Evans", "Eve", "Eveline", "Evelyn", "Everardo", "Everett", "Everette", "Evert", "Evie", "Ewald", "Ewell", "Ezekiel", "Ezequiel", "Ezra", "Fabian", "Fabiola", "Fae", "Fannie", "Fanny", "Fatima", "Faustino", "Fausto", "Favian", "Fay", "Faye", "Federico", "Felicia", "Felicita", "Felicity", "Felipa", "Felipe", "Felix", "Felton", "Fermin", "Fern", "Fernando", "Ferne", "Fidel", "Filiberto", "Filomena", "Finn", "Fiona", "Flavie", "Flavio", "Fleta", "Fletcher", "Flo", "Florence", "Florencio", "Florian", "Florida", "Florine", "Flossie", "Floy", "Floyd", "Ford", "Forest", "Forrest", "Foster", "Frances", "Francesca", "Francesco", "Francis", "Francisca", "Francisco", "Franco", "Frank", "Frankie", "Franz", "Fred", "Freda", "Freddie", "Freddy", "Frederic", "Frederick", "Frederik", "Frederique", "Fredrick", "Fredy", "Freeda", "Freeman", "Freida", "Frida", "Frieda", "Friedrich", "Fritz", "Furman", "Gabe", "Gabriel", "Gabriella", "Gabrielle", "Gaetano", "Gage", "Gail", "Gardner", "Garett", "Garfield", "Garland", "Garnet", "Garnett", "Garret", "Garrett", "Garrick", "Garrison", "Garry", "Garth", "Gaston", "Gavin", "Gay", "Gayle", "Gaylord", "Gene", "General", "Genesis", "Genevieve", "Gennaro", "Genoveva", "Geo", "Geoffrey", "George", "Georgette", "Georgiana", "Georgianna", "Geovanni", "Geovanny", "Geovany", "Gerald", "Geraldine", "Gerard", "Gerardo", "Gerda", "Gerhard", "Germaine", "German", "Gerry", "Gerson", "Gertrude", "Gia", "Gianni", "Gideon", "Gilbert", "Gilberto", "Gilda", "Giles", "Gillian", "Gina", "Gino", "Giovani", "Giovanna", "Giovanni", "Giovanny", "Gisselle", "Giuseppe", "Gladyce", "Gladys", "Glen", "Glenda", "Glenna", "Glennie", "Gloria", "Godfrey", "Golda", "Golden", "Gonzalo", "Gordon", "Grace", "Gracie", "Graciela", "Grady", "Graham", "Grant", "Granville", "Grayce", "Grayson", "Green", "Greg", "Gregg", "Gregoria", "Gregorio", "Gregory", "Greta", "Gretchen", "Greyson", "Griffin", "Grover", "Guadalupe", "Gudrun", "Guido", "Guillermo", "Guiseppe", "Gunnar", "Gunner", "Gus", "Gussie", "Gust", "Gustave", "Guy", "Gwen", "Gwendolyn", "Hadley", "Hailee", "Hailey", "Hailie", "Hal", "Haleigh", "Haley", "Halie", "Halle", "Hallie", "Hank", "Hanna", "Hannah", "Hans", "Hardy", "Harley", "Harmon", "Harmony", "Harold", "Harrison", "Harry", "Harvey", "Haskell", "Hassan", "Hassie", "Hattie", "Haven", "Hayden", "Haylee", "Hayley", "Haylie", "Hazel", "Hazle", "Heath", "Heather", "Heaven", "Heber", "Hector", "Heidi", "Helen", "Helena", "Helene", "Helga", "Hellen", "Helmer", "Heloise", "Henderson", "Henri", "Henriette", "Henry", "Herbert", "Herman", "Hermann", "Hermina", "Herminia", "Herminio", "Hershel", "Herta", "Hertha", "Hester", "Hettie", "Hilario", "Hilbert", "Hilda", "Hildegard", "Hillard", "Hillary", "Hilma", "Hilton", "Hipolito", "Hiram", "Hobart", "Holden", "Hollie", "Hollis", "Holly", "Hope", "Horace", "Horacio", "Hortense", "Hosea", "Houston", "Howard", "Howell", "Hoyt", "Hubert", "Hudson", "Hugh", "Hulda", "Humberto", "Hunter", "Hyman", "Ian", "Ibrahim", "Icie", "Ida", "Idell", "Idella", "Ignacio", "Ignatius", "Ike", "Ila", "Ilene", "Iliana", "Ima", "Imani", "Imelda", "Immanuel", "Imogene", "Ines", "Irma", "Irving", "Irwin", "Isaac", "Isabel", "Isabell", "Isabella", "Isabelle", "Isac", "Isadore", "Isai", "Isaiah", "Isaias", "Isidro", "Ismael", "Isobel", "Isom", "Israel", "Issac", "Itzel", "Iva", "Ivah", "Ivory", "Ivy", "Izabella", "Izaiah", "Jabari", "Jace", "Jacey", "Jacinthe", "Jacinto", "Jack", "Jackeline", "Jackie", "Jacklyn", "Jackson", "Jacky", "Jaclyn", "Jacquelyn", "Jacques", "Jacynthe", "Jada", "Jade", "Jaden", "Jadon", "Jadyn", "Jaeden", "Jaida", "Jaiden", "Jailyn", "Jaime", "Jairo", "Jakayla", "Jake", "Jakob", "Jaleel", "Jalen", "Jalon", "Jalyn", "Jamaal", "Jamal", "Jamar", "Jamarcus", "Jamel", "Jameson", "Jamey", "Jamie", "Jamil", "Jamir", "Jamison", "Jammie", "Jan", "Jana", "Janae", "Jane", "Janelle", "Janessa", "Janet", "Janice", "Janick", "Janie", "Janis", "Janiya", "Jannie", "Jany", "Jaquan", "Jaquelin", "Jaqueline", "Jared", "Jaren", "Jarod", "Jaron", "Jarred", "Jarrell", "Jarret", "Jarrett", "Jarrod", "Jarvis", "Jasen", "Jasmin", "Jason", "Jasper", "Jaunita", "Javier", "Javon", "Javonte", "Jay", "Jayce", "Jaycee", "Jayda", "Jayde", "Jayden", "Jaydon", "Jaylan", "Jaylen", "Jaylin", "Jaylon", "Jayme", "Jayne", "Jayson", "Jazlyn", "Jazmin", "Jazmyn", "Jazmyne", "Jean", "Jeanette", "Jeanie", "Jeanne", "Jed", "Jedediah", "Jedidiah", "Jeff", "Jefferey", "Jeffery", "Jeffrey", "Jeffry", "Jena", "Jenifer", "Jennie", "Jennifer", "Jennings", "Jennyfer", "Jensen", "Jerad", "Jerald", "Jeramie", "Jeramy", "Jerel", "Jeremie", "Jeremy", "Jermain", "Jermaine", "Jermey", "Jerod", "Jerome", "Jeromy", "Jerrell", "Jerrod", "Jerrold", "Jerry", "Jess", "Jesse", "Jessica", "Jessie", "Jessika", "Jessy", "Jessyca", "Jesus", "Jett", "Jettie", "Jevon", "Jewel", "Jewell", "Jillian", "Jimmie", "Jimmy", "Jo", "Joan", "Joana", "Joanie", "Joanne", "Joannie", "Joanny", "Joany", "Joaquin", "Jocelyn", "Jodie", "Jody", "Joe", "Joel", "Joelle", "Joesph", "Joey", "Johan", "Johann", "Johanna", "Johathan", "John", "Johnathan", "Johnathon", "Johnnie", "Johnny", "Johnpaul", "Johnson", "Jolie", "Jon", "Jonas", "Jonatan", "Jonathan", "Jonathon", "Jordan", "Jordane", "Jordi", "Jordon", "Jordy", "Jordyn", "Jorge", "Jose", "Josefa", "Josefina", "Joseph", "Josephine", "Josh", "Joshua", "Joshuah", "Josiah", "Josiane", "Josianne", "Josie", "Josue", "Jovan", "Jovani", "Jovanny", "Jovany", "Joy", "Joyce", "Juana", "Juanita", "Judah", "Judd", "Jude", "Judge", "Judson", "Judy", "Jules", "Julia", "Julian", "Juliana", "Julianne", "Julie", "Julien", "Juliet", "Julio", "Julius", "June", "Junior", "Junius", "Justen", "Justice", "Justina", "Justine", "Juston", "Justus", "Justyn", "Juvenal", "Juwan", "Kacey", "Kaci", "Kacie", "Kade", "Kaden", "Kadin", "Kaela", "Kaelyn", "Kaia", "Kailee", "Kailey", "Kailyn", "Kaitlin", "Kaitlyn", "Kale", "Kaleb", "Kaleigh", "Kaley", "Kali", "Kallie", "Kameron", "Kamille", "Kamren", "Kamron", "Kamryn", "Kane", "Kara", "Kareem", "Karelle", "Karen", "Kari", "Kariane", "Karianne", "Karina", "Karine", "Karl", "Karlee", "Karley", "Karli", "Karlie", "Karolann", "Karson", "Kasandra", "Kasey", "Kassandra", "Katarina", "Katelin", "Katelyn", "Katelynn", "Katharina", "Katherine", "Katheryn", "Kathleen", "Kathlyn", "Kathryn", "Kathryne", "Katlyn", "Katlynn", "Katrina", "Katrine", "Kattie", "Kavon", "Kay", "Kaya", "Kaycee", "Kayden", "Kayla", "Kaylah", "Kaylee", "Kayleigh", "Kayley", "Kayli", "Kaylie", "Kaylin", "Keagan", "Keanu", "Keara", "Keaton", "Keegan", "Keeley", "Keely", "Keenan", "Keira", "Keith", "Kellen", "Kelley", "Kelli", "Kellie", "Kelly", "Kelsi", "Kelsie", "Kelton", "Kelvin", "Ken", "Kendall", "Kendra", "Kendrick", "Kenna", "Kennedi", "Kennedy", "Kenneth", "Kennith", "Kenny", "Kenton", "Kenya", "Kenyatta", "Kenyon", "Keon", "Keshaun", "Keshawn", "Keven", "Kevin", "Kevon", "Keyon", "Keyshawn", "Khalid", "Khalil", "Kian", "Kiana", "Kianna", "Kiara", "Kiarra", "Kiel", "Kiera", "Kieran", "Kiley", "Kim", "Kimberly", "King", "Kip", "Kira", "Kirk", "Kirsten", "Kirstin", "Kitty", "Kobe", "Koby", "Kody", "Kolby", "Kole", "Korbin", "Korey", "Kory", "Kraig", "Kris", "Krista", "Kristian", "Kristin", "Kristina", "Kristofer", "Kristoffer", "Kristopher", "Kristy", "Krystal", "Krystel", "Krystina", "Kurt", "Kurtis", "Kyla", "Kyle", "Kylee", "Kyleigh", "Kyler", "Kylie", "Kyra", "Lacey", "Lacy", "Ladarius", "Lafayette", "Laila", "Laisha", "Lamar", "Lambert", "Lamont", "Lance", "Landen", "Lane", "Laney", "Larissa", "Laron", "Larry", "Larue", "Laura", "Laurel", "Lauren", "Laurence", "Lauretta", "Lauriane", "Laurianne", "Laurie", "Laurine", "Laury", "Lauryn", "Lavada", "Lavern", "Laverna", "Laverne", "Lavina", "Lavinia", "Lavon", "Lavonne", "Lawrence", "Lawson", "Layla", "Layne", "Lazaro", "Lea", "Leann", "Leanna", "Leanne", "Leatha", "Leda", "Lee", "Leif", "Leila", "Leilani", "Lela", "Lelah", "Leland", "Lelia", "Lempi", "Lemuel", "Lenna", "Lennie", "Lenny", "Lenora", "Lenore", "Leo", "Leola", "Leon", "Leonard", "Leonardo", "Leone", "Leonel", "Leonie", "Leonor", "Leonora", "Leopold", "Leopoldo", "Leora", "Lera", "Lesley", "Leslie", "Lesly", "Lessie", "Lester", "Leta", "Letha", "Letitia", "Levi", "Lew", "Lewis", "Lexi", "Lexie", "Lexus", "Lia", "Liam", "Liana", "Libbie", "Libby", "Lila", "Lilian", "Liliana", "Liliane", "Lilla", "Lillian", "Lilliana", "Lillie", "Lilly", "Lily", "Lilyan", "Lina", "Lincoln", "Linda", "Lindsay", "Lindsey", "Linnea", "Linnie", "Linwood", "Lionel", "Lisa", "Lisandro", "Lisette", "Litzy", "Liza", "Lizeth", "Lizzie", "Llewellyn", "Lloyd", "Logan", "Lois", "Lola", "Lolita", "Loma", "Lon", "London", "Lonie", "Lonnie", "Lonny", "Lonzo", "Lora", "Loraine", "Loren", "Lorena", "Lorenz", "Lorenza", "Lorenzo", "Lori", "Lorine", "Lorna", "Lottie", "Lou", "Louie", "Louisa", "Lourdes", "Louvenia", "Lowell", "Loy", "Loyal", "Loyce", "Lucas", "Luciano", "Lucie", "Lucienne", "Lucile", "Lucinda", "Lucio", "Lucious", "Lucius", "Lucy", "Ludie", "Ludwig", "Lue", "Luella", "Luigi", "Luis", "Luisa", "Lukas", "Lula", "Lulu", "Luna", "Lupe", "Lura", "Lurline", "Luther", "Luz", "Lyda", "Lydia", "Lyla", "Lynn", "Lyric", "Lysanne", "Mabel", "Mabelle", "Mable", "Mac", "Macey", "Maci", "Macie", "Mack", "Mackenzie", "Macy", "Madaline", "Madalyn", "Maddison", "Madeline", "Madelyn", "Madelynn", "Madge", "Madie", "Madilyn", "Madisen", "Madison", "Madisyn", "Madonna", "Madyson", "Mae", "Maegan", "Maeve", "Mafalda", "Magali", "Magdalen", "Magdalena", "Maggie", "Magnolia", "Magnus", "Maia", "Maida", "Maiya", "Major", "Makayla", "Makenna", "Makenzie", "Malachi", "Malcolm", "Malika", "Malinda", "Mallie", "Mallory", "Malvina", "Mandy", "Manley", "Manuel", "Manuela", "Mara", "Marc", "Marcel", "Marcelina", "Marcelino", "Marcella", "Marcelle", "Marcellus", "Marcelo", "Marcia", "Marco", "Marcos", "Marcus", "Margaret", "Margarete", "Margarett", "Margaretta", "Margarette", "Margarita", "Marge", "Margie", "Margot", "Margret", "Marguerite", "Maria", "Mariah", "Mariam", "Marian", "Mariana", "Mariane", "Marianna", "Marianne", "Mariano", "Maribel", "Marie", "Mariela", "Marielle", "Marietta", "Marilie", "Marilou", "Marilyne", "Marina", "Mario", "Marion", "Marisa", "Marisol", "Maritza", "Marjolaine", "Marjorie", "Marjory", "Mark", "Markus", "Marlee", "Marlen", "Marlene", "Marley", "Marlin", "Marlon", "Marques", "Marquis", "Marquise", "Marshall", "Marta", "Martin", "Martina", "Martine", "Marty", "Marvin", "Mary", "Maryam", "Maryjane", "Maryse", "Mason", "Mateo", "Mathew", "Mathias", "Mathilde", "Matilda", "Matilde", "Matt", "Matteo", "Mattie", "Maud", "Maude", "Maudie", "Maureen", "Maurice", "Mauricio", "Maurine", "Maverick", "Mavis", "Max", "Maxie", "Maxime", "Maximilian", "Maximillia", "Maximillian", "Maximo", "Maximus", "Maxine", "Maxwell", "May", "Maya", "Maybell", "Maybelle", "Maye", "Maymie", "Maynard", "Mayra", "Mazie", "Mckayla", "Mckenna", "Mckenzie", "Meagan", "Meaghan", "Meda", "Megane", "Meggie", "Meghan", "Mekhi", "Melany", "Melba", "Melisa", "Melissa", "Mellie", "Melody", "Melvin", "Melvina", "Melyna", "Melyssa", "Mercedes", "Meredith", "Merl", "Merle", "Merlin", "Merritt", "Mertie", "Mervin", "Meta", "Mia", "Micaela", "Micah", "Michael", "Michaela", "Michale", "Micheal", "Michel", "Michele", "Michelle", "Miguel", "Mikayla", "Mike", "Mikel", "Milan", "Miles", "Milford", "Miller", "Millie", "Milo", "Milton", "Mina", "Minerva", "Minnie", "Miracle", "Mireille", "Mireya", "Misael", "Missouri", "Misty", "Mitchel", "Mitchell", "Mittie", "Modesta", "Modesto", "Mohamed", "Mohammad", "Mohammed", "Moises", "Mollie", "Molly", "Mona", "Monica", "Monique", "Monroe", "Monserrat", "Monserrate", "Montana", "Monte", "Monty", "Morgan", "Moriah", "Morris", "Mortimer", "Morton", "Mose", "Moses", "Moshe", "Mossie", "Mozell", "Mozelle", "Muhammad", "Muriel", "Murl", "Murphy", "Murray", "Mustafa", "Mya", "Myah", "Mylene", "Myles", "Myra", "Myriam", "Myrl", "Myrna", "Myron", "Myrtice", "Myrtie", "Myrtis", "Myrtle", "Nadia", "Nakia", "Name", "Nannie", "Naomi", "Naomie", "Napoleon", "Narciso", "Nash", "Nasir", "Nat", "Natalia", "Natalie", "Natasha", "Nathan", "Nathanael", "Nathanial", "Nathaniel", "Nathen", "Nayeli", "Neal", "Ned", "Nedra", "Neha", "Neil", "Nelda", "Nella", "Nelle", "Nellie", "Nels", "Nelson", "Neoma", "Nestor", "Nettie", "Neva", "Newell", "Newton", "Nia", "Nicholas", "Nicholaus", "Nichole", "Nick", "Nicklaus", "Nickolas", "Nico", "Nicola", "Nicolas", "Nicole", "Nicolette", "Nigel", "Nikita", "Nikki", "Nikko", "Niko", "Nikolas", "Nils", "Nina", "Noah", "Noble", "Noe", "Noel", "Noelia", "Noemi", "Noemie", "Noemy", "Nola", "Nolan", "Nona", "Nora", "Norbert", "Norberto", "Norene", "Norma", "Norris", "Norval", "Norwood", "Nova", "Novella", "Nya", "Nyah", "Nyasia", "Obie", "Oceane", "Ocie", "Octavia", "Oda", "Odell", "Odessa", "Odie", "Ofelia", "Okey", "Ola", "Olaf", "Ole", "Olen", "Oleta", "Olga", "Olin", "Oliver", "Ollie", "Oma", "Omari", "Omer", "Ona", "Onie", "Opal", "Ophelia", "Ora", "Oral", "Oran", "Oren", "Orie", "Orin", "Orion", "Orland", "Orlando", "Orlo", "Orpha", "Orrin", "Orval", "Orville", "Osbaldo", "Osborne", "Oscar", "Osvaldo", "Oswald", "Oswaldo", "Otha", "Otho", "Otilia", "Otis", "Ottilie", "Ottis", "Otto", "Ova", "Owen", "Ozella", "Pablo", "Paige", "Palma", "Pamela", "Pansy", "Paolo", "Paris", "Parker", "Pascale", "Pasquale", "Pat", "Patience", "Patricia", "Patrick", "Patsy", "Pattie", "Paul", "Paula", "Pauline", "Paxton", "Payton", "Pearl", "Pearlie", "Pearline", "Pedro", "Peggie", "Penelope", "Percival", "Percy", "Perry", "Pete", "Peter", "Petra", "Peyton", "Philip", "Phoebe", "Phyllis", "Pierce", "Pierre", "Pietro", "Pink", "Pinkie", "Piper", "Polly", "Porter", "Precious", "Presley", "Preston", "Price", "Prince", "Princess", "Priscilla", "Providenci", "Prudence", "Queen", "Queenie", "Quentin", "Quincy", "Quinn", "Quinten", "Quinton", "Rachael", "Rachel", "Rachelle", "Rae", "Raegan", "Rafael", "Rafaela", "Raheem", "Rahsaan", "Rahul", "Raina", "Raleigh", "Ralph", "Ramiro", "Ramon", "Ramona", "Randal", "Randall", "Randi", "Randy", "Ransom", "Raoul", "Raphael", "Raphaelle", "Raquel", "Rashad", "Rashawn", "Rasheed", "Raul", "Raven", "Ray", "Raymond", "Raymundo", "Reagan", "Reanna", "Reba", "Rebeca", "Rebecca", "Rebeka", "Rebekah", "Reece", "Reed", "Reese", "Regan", "Reggie", "Reginald", "Reid", "Reilly", "Reina", "Reinhold", "Remington", "Rene", "Renee", "Ressie", "Reta", "Retha", "Retta", "Reuben", "Reva", "Rex", "Rey", "Reyes", "Reymundo", "Reyna", "Reynold", "Rhea", "Rhett", "Rhianna", "Rhiannon", "Rhoda", "Ricardo", "Richard", "Richie", "Richmond", "Rick", "Rickey", "Rickie", "Ricky", "Rico", "Rigoberto", "Riley", "Rita", "River", "Robb", "Robbie", "Robert", "Roberta", "Roberto", "Robin", "Robyn", "Rocio", "Rocky", "Rod", "Roderick", "Rodger", "Rodolfo", "Rodrick", "Rodrigo", "Roel", "Rogelio", "Roger", "Rogers", "Rolando", "Rollin", "Roma", "Romaine", "Roman", "Ron", "Ronaldo", "Ronny", "Roosevelt", "Rory", "Rosa", "Rosalee", "Rosalia", "Rosalind", "Rosalinda", "Rosalyn", "Rosamond", "Rosanna", "Rosario", "Roscoe", "Rose", "Rosella", "Roselyn", "Rosemarie", "Rosemary", "Rosendo", "Rosetta", "Rosie", "Rosina", "Roslyn", "Ross", "Rossie", "Rowan", "Rowena", "Rowland", "Roxane", "Roxanne", "Roy", "Royal", "Royce", "Rozella", "Ruben", "Rubie", "Ruby", "Rubye", "Rudolph", "Rudy", "Rupert", "Russ", "Russel", "Russell", "Rusty", "Ruth", "Ruthe", "Ruthie", "Ryan", "Ryann", "Ryder", "Rylan", "Rylee", "Ryleigh", "Ryley", "Sabina", "Sabrina", "Sabryna", "Sadie", "Sadye", "Sage", "Saige", "Sallie", "Sally", "Salma", "Salvador", "Salvatore", "Sam", "Samanta", "Samantha", "Samara", "Samir", "Sammie", "Sammy", "Samson", "Sandra", "Sandrine", "Sandy", "Sanford", "Santa", "Santiago", "Santina", "Santino", "Santos", "Sarah", "Sarai", "Sarina", "Sasha", "Saul", "Savanah", "Savanna", "Savannah", "Savion", "Scarlett", "Schuyler", "Scot", "Scottie", "Scotty", "Seamus", "Sean", "Sebastian", "Sedrick", "Selena", "Selina", "Selmer", "Serena", "Serenity", "Seth", "Shad", "Shaina", "Shakira", "Shana", "Shane", "Shanel", "Shanelle", "Shania", "Shanie", "Shaniya", "Shanna", "Shannon", "Shanny", "Shanon", "Shany", "Sharon", "Shaun", "Shawn", "Shawna", "Shaylee", "Shayna", "Shayne", "Shea", "Sheila", "Sheldon", "Shemar", "Sheridan", "Sherman", "Sherwood", "Shirley", "Shyann", "Shyanne", "Sibyl", "Sid", "Sidney", "Sienna", "Sierra", "Sigmund", "Sigrid", "Sigurd", "Silas", "Sim", "Simeon", "Simone", "Sincere", "Sister", "Skye", "Skyla", "Skylar", "Sofia", "Soledad", "Solon", "Sonia", "Sonny", "Sonya", "Sophia", "Sophie", "Spencer", "Stacey", "Stacy", "Stan", "Stanford", "Stanley", "Stanton", "Stefan", "Stefanie", "Stella", "Stephan", "Stephania", "Stephanie", "Stephany", "Stephen", "Stephon", "Sterling", "Steve", "Stevie", "Stewart", "Stone", "Stuart", "Summer", "Sunny", "Susan", "Susana", "Susanna", "Susie", "Suzanne", "Sven", "Syble", "Sydnee", "Sydney", "Sydni", "Sydnie", "Sylvan", "Sylvester", "Sylvia", "Tabitha", "Tad", "Talia", "Talon", "Tamara", "Tamia", "Tania", "Tanner", "Tanya", "Tara", "Taryn", "Tate", "Tatum", "Tatyana", "Taurean", "Tavares", "Taya", "Taylor", "Teagan", "Ted", "Telly", "Terence", "Teresa", "Terrance", "Terrell", "Terrence", "Terrill", "Terry", "Tess", "Tessie", "Tevin", "Thad", "Thaddeus", "Thalia", "Thea", "Thelma", "Theo", "Theodora", "Theodore", "Theresa", "Therese", "Theresia", "Theron", "Thomas", "Thora", "Thurman", "Tia", "Tiana", "Tianna", "Tiara", "Tierra", "Tiffany", "Tillman", "Timmothy", "Timmy", "Timothy", "Tina", "Tito", "Titus", "Tobin", "Toby", "Tod", "Tom", "Tomas", "Tomasa", "Tommie", "Toney", "Toni", "Tony", "Torey", "Torrance", "Torrey", "Toy", "Trace", "Tracey", "Tracy", "Travis", "Travon", "Tre", "Tremaine", "Tremayne", "Trent", "Trenton", "Tressa", "Tressie", "Treva", "Trever", "Trevion", "Trevor", "Trey", "Trinity", "Trisha", "Tristian", "Tristin", "Triston", "Troy", "Trudie", "Trycia", "Trystan", "Turner", "Twila", "Tyler", "Tyra", "Tyree", "Tyreek", "Tyrel", "Tyrell", "Tyrese", "Tyrique", "Tyshawn", "Tyson", "Ubaldo", "Ulices", "Ulises", "Una", "Unique", "Urban", "Uriah", "Uriel", "Ursula", "Vada", "Valentin", "Valentina", "Valentine", "Valerie", "Vallie", "Van", "Vance", "Vanessa", "Vaughn", "Veda", "Velda", "Vella", "Velma", "Velva", "Vena", "Verda", "Verdie", "Vergie", "Verla", "Verlie", "Vern", "Verna", "Verner", "Vernice", "Vernie", "Vernon", "Verona", "Veronica", "Vesta", "Vicenta", "Vicente", "Vickie", "Vicky", "Victor", "Victoria", "Vida", "Vidal", "Vilma", "Vince", "Vincent", "Vincenza", "Vincenzo", "Vinnie", "Viola", "Violet", "Violette", "Virgie", "Virgil", "Virginia", "Virginie", "Vita", "Vito", "Viva", "Vivian", "Viviane", "Vivianne", "Vivien", "Vivienne", "Vladimir", "Wade", "Waino", "Waldo", "Walker", "Wallace", "Walter", "Walton", "Wanda", "Ward", "Warren", "Watson", "Wava", "Waylon", "Wayne", "Webster", "Weldon", "Wellington", "Wendell", "Wendy", "Werner", "Westley", "Weston", "Whitney", "Wilber", "Wilbert", "Wilburn", "Wiley", "Wilford", "Wilfred", "Wilfredo", "Wilfrid", "Wilhelm", "Wilhelmine", "Will", "Willa", "Willard", "William", "Willie", "Willis", "Willow", "Willy", "Wilma", "Wilmer", "Wilson", "Wilton", "Winfield", "Winifred", "Winnifred", "Winona", "Winston", "Woodrow", "Wyatt", "Wyman", "Xander", "Xavier", "Xzavier", "Yadira", "Yasmeen", "Yasmin", "Yasmine", "Yazmin", "Yesenia", "Yessenia", "Yolanda", "Yoshiko", "Yvette", "Yvonne", "Zachariah", "Zachary", "Zachery", "Zack", "Zackary", "Zackery", "Zakary", "Zander", "Zane", "Zaria", "Zechariah", "Zelda", "Zella", "Zelma", "Zena", "Zetta", "Zion", "Zita", "Zoe", "Zoey", "Zoie", "Zoila", "Zola", "Zora", "Zula"];
        e.exports = {
            generateUsername: function() {
                return `${i.randomElement(s)}-${i.randomAlphanumStr(3)}`
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return g
            }));
            var i = n(5),
                s = n(2),
                r = n(8),
                o = n(0),
                a = n.n(o),
                c = n(6),
                d = n(12),
                u = n.n(d),
                l = n(37),
                h = n.n(l),
                p = n(38),
                m = n(56);
            const f = Object(i.getLogger)(e);
            class g extends p.b {
                constructor(e, t, n) {
                    super(), this.xmpp = e, this.eventEmitter = t, this.sessions = {}, this.jvbIceConfig = n.jvb, this.p2pIceConfig = n.p2p, this.mediaConstraints = {
                        offerToReceiveAudio: !0,
                        offerToReceiveVideo: !0
                    }
                }
                init(e) {
                    super.init(e), this.connection.addHandler(this.onJingle.bind(this), "urn:xmpp:jingle:1", "iq", "set", null, null)
                }
                onJingle(e) {
                    const t = $(e).find("jingle").attr("sid"),
                        n = $(e).find("jingle").attr("action"),
                        i = e.getAttribute("from"),
                        o = Object(s.$iq)({
                            type: "result",
                            to: i,
                            id: e.getAttribute("id")
                        });
                    f.debug(`on jingle ${n} from ${i}`, e);
                    let d = this.sessions[t];
                    if ("session-initiate" !== n) {
                        if (!d) return o.attrs({
                            type: "error"
                        }), o.c("error", {
                            type: "cancel"
                        }).c("item-not-found", {
                            xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                        }).up().c("unknown-session", {
                            xmlns: "urn:xmpp:jingle:errors:1"
                        })/*, f.warn("invalid session id", e), this.connection.send(o), !0 BAO */;
                        if (i !== d.remoteJid) return f.warn("jid mismatch for session id", t, d.remoteJid, e), o.attrs({
                            type: "error"
                        }), o.c("error", {
                            type: "cancel"
                        }).c("item-not-found", {
                            xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                        }).up().c("unknown-session", {
                            xmlns: "urn:xmpp:jingle:errors:1"
                        }), this.connection.send(o), !0
                    } else if (void 0 !== d) return o.attrs({
                        type: "error"
                    }), o.c("error", {
                        type: "cancel"
                    }).c("service-unavailable", {
                        xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                    }).up(), f.warn("duplicate session id", t, e), this.connection.send(o), !0;
                    const l = window.performance.now(),
                        h = "focus" !== s.Strophe.getResourceFromJid(i);
                    switch (n) {
                        case "session-initiate": {
                            f.log("(TIME) received session-initiate:\t", l);
                            const t = $(e).find("jingle>startmuted");
                            if (t && t.length > 0) {
                                const e = t.attr("audio"),
                                    n = t.attr("video");
                                this.eventEmitter.emit(a.a.START_MUTED_FROM_FOCUS, "true" === e, "true" === n)
                            }
                            f.info(`Marking session from ${i} as ${h?"":"*not*"} P2P`);
                            const n = h ? this.p2pIceConfig : this.jvbIceConfig;
                            d = new m.a($(e).find("jingle").attr("sid"), $(e).attr("to"), i, this.connection, this.mediaConstraints, JSON.parse(JSON.stringify(n)), h, !1), this.sessions[d.sid] = d, this.eventEmitter.emit(a.a.CALL_INCOMING, d, $(e).find(">jingle"), l);
                            break
                        }
                        case "session-accept":
                            this.eventEmitter.emit(a.a.CALL_ACCEPTED, d, $(e).find(">jingle"));
                            break;
                        case "content-modify":
                            d.modifyContents($(e).find(">jingle"));
                            break;
                        case "transport-info":
                            this.eventEmitter.emit(a.a.TRANSPORT_INFO, d, $(e).find(">jingle"));
                            break;
                        case "session-terminate": {
                            f.log("terminating...", d.sid);
                            let t = null,
                                n = null;
                            $(e).find(">jingle>reason").length && (t = $(e).find(">jingle>reason>:first")[0].tagName, n = $(e).find(">jingle>reason>text").text()), this.terminate(d.sid, t, n), this.eventEmitter.emit(a.a.CALL_ENDED, d, t, n);
                            break
                        }
                        case "transport-replace":
                            f.info("(TIME) Start transport replace:\t", l), c.a.sendAnalytics(Object(r.G)(r.f, {
                                p2p: h,
                                value: l
                            })), d.replaceTransport($(e).find(">jingle"), () => {
                                const e = window.performance.now();
                                f.info("(TIME) Transport replace success:\t", e), c.a.sendAnalytics(Object(r.G)(r.g, {
                                    p2p: h,
                                    value: e
                                }))
                            }, e => {
                                u.a.callErrorHandler(e), f.error("Transport replace failed", e), d.sendTransportReject()
                            });
                            break;
                        case "addsource":
                        case "source-add":
                            d.addRemoteStream($(e).find(">jingle>content"));
                            break;
                        case "removesource":
                        case "source-remove":
                            d.removeRemoteStream($(e).find(">jingle>content"));
                            break;
                        default:
                            f.warn("jingle action not implemented", n), o.attrs({
                                type: "error"
                            }), o.c("error", {
                                type: "cancel"
                            }).c("bad-request", {
                                xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                            }).up()
                    }
                    return this.connection.send(o), !0
                }
                newP2PJingleSession(e, t) {
                    const n = new m.a(h.a.randomHexString(12), e, t, this.connection, this.mediaConstraints, this.p2pIceConfig, !0, !0);
                    return this.sessions[n.sid] = n, n
                }
                terminate(e, t, n) {
                    this.sessions.hasOwnProperty(e) && ("ended" !== this.sessions[e].state && this.sessions[e].onTerminated(t, n), delete this.sessions[e])
                }
                getStunAndTurnCredentials() {
                    this.connection.sendIQ(Object(s.$iq)({
                        type: "get",
                        to: this.xmpp.options.hosts.domain
                    }).c("services", {
                        xmlns: "urn:xmpp:extdisco:2"
                    }), e => this.onReceiveStunAndTurnCredentials(e), e => {
                        f.warn("getting turn credentials with extdisco:2 failed, trying extdisco:1", e), this.connection.sendIQ(Object(s.$iq)({
                            type: "get",
                            to: this.xmpp.options.hosts.domain
                        }).c("services", {
                            xmlns: "urn:xmpp:extdisco:1"
                        }), e => this.onReceiveStunAndTurnCredentials(e), e => {
                            f.warn("getting turn credentials failed", e), f.warn("is mod_turncredentials or similar installed and configured?")
                        })
                    })
                }
                onReceiveStunAndTurnCredentials(e) {
                    const t = [];
                    $(e).find(">services>service").each((e, n) => {
                        const i = {},
                            s = (n = $(n)).attr("type");
                        switch (s) {
                            case "stun":
                                i.urls = "stun:" + n.attr("host"), n.attr("port") && (i.urls += ":" + n.attr("port")), t.push(i);
                                break;
                            case "turn":
                            case "turns": {
                                i.urls = s + ":", i.username = n.attr("username"), i.urls += n.attr("host");
                                n.attr("port") && (i.urls += ":" + n.attr("port"));
                                const e = n.attr("transport");
                                e && "udp" !== e && (i.urls += "?transport=" + e), i.credential = n.attr("password") || i.credential, t.push(i);
                                break
                            }
                        }
                    });
                    const n = this.xmpp.options;
                    for (let e = t.length - 1; e > 0; e--) {
                        const n = Math.floor(Math.random() * (e + 1)),
                            i = t[e];
                        t[e] = t[n], t[n] = i
                    }
                    let i;
                    return i = n.useTurnUdp ? e => e.urls.startsWith("turn") : e => e.urls.startsWith("turn") && e.urls.indexOf("transport=tcp") >= 0, this.jvbIceConfig.iceServers = t.filter(i), this.p2pIceConfig.iceServers = t, t.length > 0
                }
                getLog() {
                    const e = {};
                    return Object.keys(this.sessions).forEach(t => {
                        const n = this.sessions[t].peerconnection;
                        n && n.updateLog && (e["jingle_" + t] = {
                            updateLog: n.updateLog,
                            stats: n.stats,
                            url: window.location.href
                        })
                    }), e
                }
            }
        }).call(this, "modules/xmpp/strophe.jingle.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return a
            }));
            var i = n(108),
                s = n.n(i),
                r = n(5);
            const o = Object(r.getLogger)(e);
            class a {
                constructor() {
                    this._queue = s.a.queue(this._processQueueTasks.bind(this), 1), this._stopped = !1
                }
                clear() {
                    this._queue.kill()
                }
                _processQueueTasks(e, t) {
                    try {
                        e(t)
                    } catch (e) {
                        o.error("Task failed: " + e), t(e)
                    }
                }
                push(e, t) {
                    this._stopped ? t && t(new Error("The queue has been stopped")) : this._queue.push(e, t)
                }
                shutdown() {
                    this._stopped = !0
                }
            }
        }).call(this, "modules/util/AsyncQueue.js")
    }, function(e, t, n) {
        (function(n, i) {
            var s;
            /*!
             * async
             * https://github.com/caolan/async
             *
             * Copyright 2010-2014 Caolan McMahon
             * Released under the MIT license
             */
            ! function() {
                var r, o, a = {};

                function c(e) {
                    var t = !1;
                    return function() {
                        if (t) throw new Error("Callback was already called.");
                        t = !0, e.apply(r, arguments)
                    }
                }
                null != (r = this) && (o = r.async), a.noConflict = function() {
                    return r.async = o, a
                };
                var d = Object.prototype.toString,
                    u = Array.isArray || function(e) {
                        return "[object Array]" === d.call(e)
                    },
                    l = function(e, t) {
                        if (e.forEach) return e.forEach(t);
                        for (var n = 0; n < e.length; n += 1) t(e[n], n, e)
                    },
                    h = function(e, t) {
                        if (e.map) return e.map(t);
                        var n = [];
                        return l(e, (function(e, i, s) {
                            n.push(t(e, i, s))
                        })), n
                    },
                    p = function(e) {
                        if (Object.keys) return Object.keys(e);
                        var t = [];
                        for (var n in e) e.hasOwnProperty(n) && t.push(n);
                        return t
                    };
                void 0 !== n && n.nextTick ? (a.nextTick = n.nextTick, a.setImmediate = void 0 !== i ? function(e) {
                    i(e)
                } : a.nextTick) : "function" == typeof i ? (a.nextTick = function(e) {
                    i(e)
                }, a.setImmediate = a.nextTick) : (a.nextTick = function(e) {
                    setTimeout(e, 0)
                }, a.setImmediate = a.nextTick), a.each = function(e, t, n) {
                    if (n = n || function() {}, !e.length) return n();
                    var i = 0;

                    function s(t) {
                        t ? (n(t), n = function() {}) : (i += 1) >= e.length && n()
                    }
                    l(e, (function(e) {
                        t(e, c(s))
                    }))
                }, a.forEach = a.each, a.eachSeries = function(e, t, n) {
                    if (n = n || function() {}, !e.length) return n();
                    var i = 0,
                        s = function() {
                            t(e[i], (function(t) {
                                t ? (n(t), n = function() {}) : (i += 1) >= e.length ? n() : s()
                            }))
                        };
                    s()
                }, a.forEachSeries = a.eachSeries, a.eachLimit = function(e, t, n, i) {
                    m(t).apply(null, [e, n, i])
                }, a.forEachLimit = a.eachLimit;
                var m = function(e) {
                        return function(t, n, i) {
                            if (i = i || function() {}, !t.length || e <= 0) return i();
                            var s = 0,
                                r = 0,
                                o = 0;
                            ! function a() {
                                if (s >= t.length) return i();
                                for (; o < e && r < t.length;) o += 1, n(t[(r += 1) - 1], (function(e) {
                                    e ? (i(e), i = function() {}) : (o -= 1, (s += 1) >= t.length ? i() : a())
                                }))
                            }()
                        }
                    },
                    f = function(e) {
                        return function() {
                            var t = Array.prototype.slice.call(arguments);
                            return e.apply(null, [a.each].concat(t))
                        }
                    },
                    g = function(e) {
                        return function() {
                            var t = Array.prototype.slice.call(arguments);
                            return e.apply(null, [a.eachSeries].concat(t))
                        }
                    },
                    _ = function(e, t, n, i) {
                        if (t = h(t, (function(e, t) {
                                return {
                                    index: t,
                                    value: e
                                }
                            })), i) {
                            var s = [];
                            e(t, (function(e, t) {
                                n(e.value, (function(n, i) {
                                    s[e.index] = i, t(n)
                                }))
                            }), (function(e) {
                                i(e, s)
                            }))
                        } else e(t, (function(e, t) {
                            n(e.value, (function(e) {
                                t(e)
                            }))
                        }))
                    };
                a.map = f(_), a.mapSeries = g(_), a.mapLimit = function(e, t, n, i) {
                    return v(t)(e, n, i)
                };
                var v = function(e) {
                    return function(e, t) {
                        return function() {
                            var n = Array.prototype.slice.call(arguments);
                            return t.apply(null, [m(e)].concat(n))
                        }
                    }(e, _)
                };
                a.reduce = function(e, t, n, i) {
                    a.eachSeries(e, (function(e, i) {
                        n(t, e, (function(e, n) {
                            t = n, i(e)
                        }))
                    }), (function(e) {
                        i(e, t)
                    }))
                }, a.inject = a.reduce, a.foldl = a.reduce, a.reduceRight = function(e, t, n, i) {
                    var s = h(e, (function(e) {
                        return e
                    })).reverse();
                    a.reduce(s, t, n, i)
                }, a.foldr = a.reduceRight;
                var S = function(e, t, n, i) {
                    var s = [];
                    e(t = h(t, (function(e, t) {
                        return {
                            index: t,
                            value: e
                        }
                    })), (function(e, t) {
                        n(e.value, (function(n) {
                            n && s.push(e), t()
                        }))
                    }), (function(e) {
                        i(h(s.sort((function(e, t) {
                            return e.index - t.index
                        })), (function(e) {
                            return e.value
                        })))
                    }))
                };
                a.filter = f(S), a.filterSeries = g(S), a.select = a.filter, a.selectSeries = a.filterSeries;
                var y = function(e, t, n, i) {
                    var s = [];
                    e(t = h(t, (function(e, t) {
                        return {
                            index: t,
                            value: e
                        }
                    })), (function(e, t) {
                        n(e.value, (function(n) {
                            n || s.push(e), t()
                        }))
                    }), (function(e) {
                        i(h(s.sort((function(e, t) {
                            return e.index - t.index
                        })), (function(e) {
                            return e.value
                        })))
                    }))
                };
                a.reject = f(y), a.rejectSeries = g(y);
                var E = function(e, t, n, i) {
                    e(t, (function(e, t) {
                        n(e, (function(n) {
                            n ? (i(e), i = function() {}) : t()
                        }))
                    }), (function(e) {
                        i()
                    }))
                };
                a.detect = f(E), a.detectSeries = g(E), a.some = function(e, t, n) {
                    a.each(e, (function(e, i) {
                        t(e, (function(e) {
                            e && (n(!0), n = function() {}), i()
                        }))
                    }), (function(e) {
                        n(!1)
                    }))
                }, a.any = a.some, a.every = function(e, t, n) {
                    a.each(e, (function(e, i) {
                        t(e, (function(e) {
                            e || (n(!1), n = function() {}), i()
                        }))
                    }), (function(e) {
                        n(!0)
                    }))
                }, a.all = a.every, a.sortBy = function(e, t, n) {
                    a.map(e, (function(e, n) {
                        t(e, (function(t, i) {
                            t ? n(t) : n(null, {
                                value: e,
                                criteria: i
                            })
                        }))
                    }), (function(e, t) {
                        if (e) return n(e);
                        n(null, h(t.sort((function(e, t) {
                            var n = e.criteria,
                                i = t.criteria;
                            return n < i ? -1 : n > i ? 1 : 0
                        })), (function(e) {
                            return e.value
                        })))
                    }))
                }, a.auto = function(e, t) {
                    t = t || function() {};
                    var n = p(e),
                        i = n.length;
                    if (!i) return t();
                    var s = {},
                        r = [],
                        o = function(e) {
                            r.unshift(e)
                        },
                        c = function() {
                            i--, l(r.slice(0), (function(e) {
                                e()
                            }))
                        };
                    o((function() {
                        if (!i) {
                            var e = t;
                            t = function() {}, e(null, s)
                        }
                    })), l(n, (function(n) {
                        var i = u(e[n]) ? e[n] : [e[n]],
                            d = function(e) {
                                var i = Array.prototype.slice.call(arguments, 1);
                                if (i.length <= 1 && (i = i[0]), e) {
                                    var r = {};
                                    l(p(s), (function(e) {
                                        r[e] = s[e]
                                    })), r[n] = i, t(e, r), t = function() {}
                                } else s[n] = i, a.setImmediate(c)
                            },
                            h = i.slice(0, Math.abs(i.length - 1)) || [],
                            m = function() {
                                return t = function(e, t) {
                                    return e && s.hasOwnProperty(t)
                                }, i = !0, ((e = h).reduce ? e.reduce(t, i) : (l(e, (function(e, n, s) {
                                    i = t(i, e, n, s)
                                })), i)) && !s.hasOwnProperty(n);
                                var e, t, i
                            };
                        if (m()) i[i.length - 1](d, s);
                        else {
                            var f = function() {
                                m() && (! function(e) {
                                    for (var t = 0; t < r.length; t += 1)
                                        if (r[t] === e) return void r.splice(t, 1)
                                }(f), i[i.length - 1](d, s))
                            };
                            o(f)
                        }
                    }))
                }, a.retry = function(e, t, n) {
                    var i = [];
                    "function" == typeof e && (n = t, t = e, e = 5), e = parseInt(e, 10) || 5;
                    var s = function(s, r) {
                        for (var o = function(e, t) {
                                return function(n) {
                                    e((function(e, i) {
                                        n(!e || t, {
                                            err: e,
                                            result: i
                                        })
                                    }), r)
                                }
                            }; e;) i.push(o(t, !(e -= 1)));
                        a.series(i, (function(e, t) {
                            t = t[t.length - 1], (s || n)(t.err, t.result)
                        }))
                    };
                    return n ? s() : s
                }, a.waterfall = function(e, t) {
                    if (t = t || function() {}, !u(e)) {
                        var n = new Error("First argument to waterfall must be an array of functions");
                        return t(n)
                    }
                    if (!e.length) return t();
                    var i = function(e) {
                        return function(n) {
                            if (n) t.apply(null, arguments), t = function() {};
                            else {
                                var s = Array.prototype.slice.call(arguments, 1),
                                    r = e.next();
                                r ? s.push(i(r)) : s.push(t), a.setImmediate((function() {
                                    e.apply(null, s)
                                }))
                            }
                        }
                    };
                    i(a.iterator(e))()
                };
                var b = function(e, t, n) {
                    if (n = n || function() {}, u(t)) e.map(t, (function(e, t) {
                        e && e((function(e) {
                            var n = Array.prototype.slice.call(arguments, 1);
                            n.length <= 1 && (n = n[0]), t.call(null, e, n)
                        }))
                    }), n);
                    else {
                        var i = {};
                        e.each(p(t), (function(e, n) {
                            t[e]((function(t) {
                                var s = Array.prototype.slice.call(arguments, 1);
                                s.length <= 1 && (s = s[0]), i[e] = s, n(t)
                            }))
                        }), (function(e) {
                            n(e, i)
                        }))
                    }
                };
                a.parallel = function(e, t) {
                    b({
                        map: a.map,
                        each: a.each
                    }, e, t)
                }, a.parallelLimit = function(e, t, n) {
                    b({
                        map: v(t),
                        each: m(t)
                    }, e, n)
                }, a.series = function(e, t) {
                    if (t = t || function() {}, u(e)) a.mapSeries(e, (function(e, t) {
                        e && e((function(e) {
                            var n = Array.prototype.slice.call(arguments, 1);
                            n.length <= 1 && (n = n[0]), t.call(null, e, n)
                        }))
                    }), t);
                    else {
                        var n = {};
                        a.eachSeries(p(e), (function(t, i) {
                            e[t]((function(e) {
                                var s = Array.prototype.slice.call(arguments, 1);
                                s.length <= 1 && (s = s[0]), n[t] = s, i(e)
                            }))
                        }), (function(e) {
                            t(e, n)
                        }))
                    }
                }, a.iterator = function(e) {
                    var t = function(n) {
                        var i = function() {
                            return e.length && e[n].apply(null, arguments), i.next()
                        };
                        return i.next = function() {
                            return n < e.length - 1 ? t(n + 1) : null
                        }, i
                    };
                    return t(0)
                }, a.apply = function(e) {
                    var t = Array.prototype.slice.call(arguments, 1);
                    return function() {
                        return e.apply(null, t.concat(Array.prototype.slice.call(arguments)))
                    }
                };
                var C = function(e, t, n, i) {
                    var s = [];
                    e(t, (function(e, t) {
                        n(e, (function(e, n) {
                            s = s.concat(n || []), t(e)
                        }))
                    }), (function(e) {
                        i(e, s)
                    }))
                };
                a.concat = f(C), a.concatSeries = g(C), a.whilst = function(e, t, n) {
                    e() ? t((function(i) {
                        if (i) return n(i);
                        a.whilst(e, t, n)
                    })) : n()
                }, a.doWhilst = function(e, t, n) {
                    e((function(i) {
                        if (i) return n(i);
                        var s = Array.prototype.slice.call(arguments, 1);
                        t.apply(null, s) ? a.doWhilst(e, t, n) : n()
                    }))
                }, a.until = function(e, t, n) {
                    e() ? n() : t((function(i) {
                        if (i) return n(i);
                        a.until(e, t, n)
                    }))
                }, a.doUntil = function(e, t, n) {
                    e((function(i) {
                        if (i) return n(i);
                        var s = Array.prototype.slice.call(arguments, 1);
                        t.apply(null, s) ? n() : a.doUntil(e, t, n)
                    }))
                }, a.queue = function(e, t) {
                    function n(e, t, n, i) {
                        if (e.started || (e.started = !0), u(t) || (t = [t]), 0 == t.length) return a.setImmediate((function() {
                            e.drain && e.drain()
                        }));
                        l(t, (function(t) {
                            var s = {
                                data: t,
                                callback: "function" == typeof i ? i : null
                            };
                            n ? e.tasks.unshift(s) : e.tasks.push(s), e.saturated && e.tasks.length === e.concurrency && e.saturated(), a.setImmediate(e.process)
                        }))
                    }
                    void 0 === t && (t = 1);
                    var i = 0,
                        s = {
                            tasks: [],
                            concurrency: t,
                            saturated: null,
                            empty: null,
                            drain: null,
                            started: !1,
                            paused: !1,
                            push: function(e, t) {
                                n(s, e, !1, t)
                            },
                            kill: function() {
                                s.drain = null, s.tasks = []
                            },
                            unshift: function(e, t) {
                                n(s, e, !0, t)
                            },
                            process: function() {
                                if (!s.paused && i < s.concurrency && s.tasks.length) {
                                    var t = s.tasks.shift();
                                    s.empty && 0 === s.tasks.length && s.empty(), i += 1;
                                    var n = c((function() {
                                        i -= 1, t.callback && t.callback.apply(t, arguments), s.drain && s.tasks.length + i === 0 && s.drain(), s.process()
                                    }));
                                    e(t.data, n)
                                }
                            },
                            length: function() {
                                return s.tasks.length
                            },
                            running: function() {
                                return i
                            },
                            idle: function() {
                                return s.tasks.length + i === 0
                            },
                            pause: function() {
                                !0 !== s.paused && (s.paused = !0, s.process())
                            },
                            resume: function() {
                                !1 !== s.paused && (s.paused = !1, s.process())
                            }
                        };
                    return s
                }, a.priorityQueue = function(e, t) {
                    function n(e, t) {
                        return e.priority - t.priority
                    }
                    var i = a.queue(e, t);
                    return i.push = function(e, t, s) {
                        ! function(e, t, i, s) {
                            if (e.started || (e.started = !0), u(t) || (t = [t]), 0 == t.length) return a.setImmediate((function() {
                                e.drain && e.drain()
                            }));
                            l(t, (function(t) {
                                var r = {
                                    data: t,
                                    priority: i,
                                    callback: "function" == typeof s ? s : null
                                };
                                e.tasks.splice(function(e, t, n) {
                                    for (var i = -1, s = e.length - 1; i < s;) {
                                        var r = i + (s - i + 1 >>> 1);
                                        n(t, e[r]) >= 0 ? i = r : s = r - 1
                                    }
                                    return i
                                }(e.tasks, r, n) + 1, 0, r), e.saturated && e.tasks.length === e.concurrency && e.saturated(), a.setImmediate(e.process)
                            }))
                        }(i, e, t, s)
                    }, delete i.unshift, i
                }, a.cargo = function(e, t) {
                    var n = !1,
                        i = [],
                        s = {
                            tasks: i,
                            payload: t,
                            saturated: null,
                            empty: null,
                            drain: null,
                            drained: !0,
                            push: function(e, n) {
                                u(e) || (e = [e]), l(e, (function(e) {
                                    i.push({
                                        data: e,
                                        callback: "function" == typeof n ? n : null
                                    }), s.drained = !1, s.saturated && i.length === t && s.saturated()
                                })), a.setImmediate(s.process)
                            },
                            process: function r() {
                                if (!n) {
                                    if (0 === i.length) return s.drain && !s.drained && s.drain(), void(s.drained = !0);
                                    var o = "number" == typeof t ? i.splice(0, t) : i.splice(0, i.length),
                                        a = h(o, (function(e) {
                                            return e.data
                                        }));
                                    s.empty && s.empty(), n = !0, e(a, (function() {
                                        n = !1;
                                        var e = arguments;
                                        l(o, (function(t) {
                                            t.callback && t.callback.apply(null, e)
                                        })), r()
                                    }))
                                }
                            },
                            length: function() {
                                return i.length
                            },
                            running: function() {
                                return n
                            }
                        };
                    return s
                };
                var T = function(e) {
                    return function(t) {
                        var n = Array.prototype.slice.call(arguments, 1);
                        t.apply(null, n.concat([function(t) {
                            var n = Array.prototype.slice.call(arguments, 1);
                            "undefined" != typeof console && (t ? console.error && console.error(t) : console[e] && l(n, (function(t) {
                                console[e](t)
                            })))
                        }]))
                    }
                };
                a.log = T("log"), a.dir = T("dir"), a.memoize = function(e, t) {
                    var n = {},
                        i = {};
                    t = t || function(e) {
                        return e
                    };
                    var s = function() {
                        var s = Array.prototype.slice.call(arguments),
                            r = s.pop(),
                            o = t.apply(null, s);
                        o in n ? a.nextTick((function() {
                            r.apply(null, n[o])
                        })) : o in i ? i[o].push(r) : (i[o] = [r], e.apply(null, s.concat([function() {
                            n[o] = arguments;
                            var e = i[o];
                            delete i[o];
                            for (var t = 0, s = e.length; t < s; t++) e[t].apply(null, arguments)
                        }])))
                    };
                    return s.memo = n, s.unmemoized = e, s
                }, a.unmemoize = function(e) {
                    return function() {
                        return (e.unmemoized || e).apply(null, arguments)
                    }
                }, a.times = function(e, t, n) {
                    for (var i = [], s = 0; s < e; s++) i.push(s);
                    return a.map(i, t, n)
                }, a.timesSeries = function(e, t, n) {
                    for (var i = [], s = 0; s < e; s++) i.push(s);
                    return a.mapSeries(i, t, n)
                }, a.seq = function() {
                    var e = arguments;
                    return function() {
                        var t = this,
                            n = Array.prototype.slice.call(arguments),
                            i = n.pop();
                        a.reduce(e, n, (function(e, n, i) {
                            n.apply(t, e.concat([function() {
                                var e = arguments[0],
                                    t = Array.prototype.slice.call(arguments, 1);
                                i(e, t)
                            }]))
                        }), (function(e, n) {
                            i.apply(t, [e].concat(n))
                        }))
                    }
                }, a.compose = function() {
                    return a.seq.apply(null, Array.prototype.reverse.call(arguments))
                };
                var R = function(e, t) {
                    var n = function() {
                        var n = this,
                            i = Array.prototype.slice.call(arguments),
                            s = i.pop();
                        return e(t, (function(e, t) {
                            e.apply(n, i.concat([t]))
                        }), s)
                    };
                    if (arguments.length > 2) {
                        var i = Array.prototype.slice.call(arguments, 2);
                        return n.apply(this, i)
                    }
                    return n
                };
                a.applyEach = f(R), a.applyEachSeries = g(R), a.forever = function(e, t) {
                    ! function n(i) {
                        if (i) {
                            if (t) return t(i);
                            throw i
                        }
                        e(n)
                    }()
                }, e.exports ? e.exports = a : void 0 === (s = function() {
                    return a
                }.apply(t, [])) || (e.exports = s)
            }()
        }).call(this, n(61), n(158).setImmediate)
    }, function(e, t) {
        e.exports = {
            integerHash: function(e) {
                if (!e) return 0;
                let t, n, i = 0;
                for (n = 0; n < e.length; n++) t = e.charCodeAt(n), i += t * Math.pow(31, e.length - 1 - n), i = Math.abs(0 | i);
                return i
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return a
            }));
            var i = n(5),
                s = n(22),
                r = n(34);
            const o = Object(i.getLogger)(e);
            class a extends s.a {
                constructor(e, t, n, i, s, r, o) {
                    super(), this.sid = e, this.localJid = t, this.remoteJid = n, this.connection = i, this.mediaConstraints = s, this.iceConfig = r, this.isInitiator = o, this.usedrip = !0, this.dripContainer = [], this.room = null, this.state = null, this.rtc = null
                }
                get initiatorJid() {
                    return this.isInitiator ? this.localJid : this.remoteJid
                }
                get responderJid() {
                    return this.isInitiator ? this.remoteJid : this.localJid
                }
                initialize(e, t, n) {
                    if (null !== this.state) {
                        const e = `attempt to initiate on session ${this.sid}\n                   in state ${this.state}`;
                        throw o.error(e), new Error(e)
                    }
                    this.room = e, this.rtc = t, this.state = r.c, this.doInitialize(n)
                }
                doInitialize(e) {}
                addIceCandidates(e) {}
                getState() {
                    return this.state
                }
                addSources(e) {}
                removeSources(e) {}
                terminate(e, t, n) {}
                acceptOffer(e, t, n) {}
                _getInitiatorJid() {
                    return this.isInitiator ? this.localJid : this.remoteJid
                }
            }
        }).call(this, "modules/xmpp/JingleSession.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return c
            }));
            var i = n(5),
                s = n(4),
                r = n(42),
                o = n(112);
            const a = Object(i.getLogger)(e);
            class c extends o.a {
                constructor() {
                    super(), this.ssrcOwners = new Map, this.chatRoom = null
                }
                setChatRoom(e) {
                    const t = this.chatRoom;
                    this.chatRoom = e, t && (t.removePresenceListener("audiomuted", this._audioMuteHandler), t.removePresenceListener("videomuted", this._videoMuteHandler), t.removePresenceListener("videoType", this._videoTypeHandler)), e && (this._audioMuteHandler = (e, t) => {
                        this.eventEmitter.emit(r.a, t, s.a, "true" === e.value)
                    }, e.addPresenceListener("audiomuted", this._audioMuteHandler), this._videoMuteHandler = (e, t) => {
                        this.eventEmitter.emit(r.a, t, s.c, "true" === e.value)
                    }, e.addPresenceListener("videomuted", this._videoMuteHandler), this._videoTypeHandler = (e, t) => {
                        this.eventEmitter.emit(r.b, t, e.value)
                    }, e.addPresenceListener("videoType", this._videoTypeHandler))
                }
                getPeerMediaInfo(e, t) {
                    if (this.chatRoom) return this.chatRoom.getMediaPresenceInfo(e, t);
                    a.error("Requested peer media info, before room was set")
                }
                getSSRCOwner(e) {
                    return this.ssrcOwners.get(e)
                }
                setSSRCOwner(e, t) {
                    if ("number" != typeof e) throw new TypeError(`SSRC(${e}) must be a number`);
                    this.ssrcOwners.set(e, t)
                }
            }
        }).call(this, "modules/xmpp/SignalingLayerImpl.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return s
        }));
        var i = n(22);
        class s extends i.a {
            getSSRCOwner(e) {
                throw new Error("not implemented")
            }
            getPeerMediaInfo(e, t) {
                throw new Error("not implemented")
            }
        }
    }, function(e, t, n) {
        "use strict";
        var i = n(2),
            s = n(38);
        class r extends s.b {
            constructor() {
                super(), this.log = []
            }
            init(e) {
                super.init(e), this.connection.rawInput = this.logIncoming.bind(this), this.connection.rawOutput = this.logOutgoing.bind(this)
            }
            logIncoming(e) {
                this.log.push([(new Date).getTime(), "incoming", e])
            }
            logOutgoing(e) {
                this.log.push([(new Date).getTime(), "outgoing", e])
            }
        }
        t.a = function() {
            i.Strophe.addConnectionPlugin("logger", new r)
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return a
            }));
            var i = n(5),
                s = n(2),
                r = n(38);
            const o = Object(i.getLogger)(e);
            class a extends r.b {
                init(e) {
                    super.init(e), this.connection.addHandler(this.onRayo.bind(this), "urn:xmpp:rayo:1", "iq", "set", null, null)
                }
                onRayo(e) {
                    o.info("Rayo IQ", e)
                }
                dial(e, t, n, i, r) {
                    return new Promise((a, c) => {
                        if (!r) return void c(new Error("Internal error!"));
                        const d = Object(s.$iq)({
                            type: "set",
                            to: r
                        });
                        d.c("dial", {
                            xmlns: "urn:xmpp:rayo:1",
                            to: e,
                            from: t
                        }), d.c("header", {
                            name: "JvbRoomName",
                            value: n
                        }).up(), i && i.length && d.c("header", {
                            name: "JvbRoomPassword",
                            value: i
                        }).up(), this.connection.sendIQ(d, e => {
                            o.info("Dial result ", e);
                            const t = $(e).find("ref").attr("uri");
                            this.callResource = t.substr("xmpp:".length), o.info("Received call resource: " + this.callResource), a()
                        }, e => {
                            o.info("Dial error ", e), c(e)
                        })
                    })
                }
                hangup() {
                    return new Promise((e, t) => {
                        if (!this.callResource) return t(new Error("No call in progress")), void o.warn("No call in progress");
                        const n = Object(s.$iq)({
                            type: "set",
                            to: this.callResource
                        });
                        n.c("hangup", {
                            xmlns: "urn:xmpp:rayo:1"
                        }), this.connection.sendIQ(n, t => {
                            o.info("Hangup result ", t), this.callResource = null, e()
                        }, e => {
                            o.info("Hangup error ", e), this.callResource = null, t(new Error("Hangup error "))
                        })
                    })
                }
            }
        }).call(this, "modules/xmpp/strophe.rayo.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(5),
                s = n(2),
                r = n(12),
                o = n.n(r);
            const a = Object(i.getLogger)(e);
            let c = -1;
            const d = /request id \d+.\d+ got 200/,
                u = /request errored, status: (\d+), number of errors: \d+/;
            t.a = function() {
                s.Strophe.log = function(e, t) {
                    switch (a.trace("Strophe", e, t), "string" == typeof t && -1 !== t.indexOf("Request ") && -1 !== t.indexOf("timed out (secondary), restarting") && (e = s.Strophe.LogLevel.WARN), e) {
                        case s.Strophe.LogLevel.DEBUG:
                            -1 !== c && d.test(t) && (a.debug("Reset lastErrorStatus"), c = -1);
                            break;
                        case s.Strophe.LogLevel.WARN:
                            a.warn("Strophe: " + t);
                            const e = u.exec(t);
                            e && 2 === e.length && (c = parseInt(e[1], 10), a.debug("lastErrorStatus set to: " + c));
                            break;
                        case s.Strophe.LogLevel.ERROR:
                        case s.Strophe.LogLevel.FATAL:
                            t = "Strophe: " + t, o.a.callErrorHandler(new Error(t)), a.error(t)
                    }
                }, s.Strophe.getLastErrorStatus = function() {
                    return c
                }, s.Strophe.getStatusString = function(e) {
                    switch (e) {
                        case s.Strophe.Status.BINDREQUIRED:
                            return "BINDREQUIRED";
                        case s.Strophe.Status.ERROR:
                            return "ERROR";
                        case s.Strophe.Status.CONNECTING:
                            return "CONNECTING";
                        case s.Strophe.Status.CONNFAIL:
                            return "CONNFAIL";
                        case s.Strophe.Status.AUTHENTICATING:
                            return "AUTHENTICATING";
                        case s.Strophe.Status.AUTHFAIL:
                            return "AUTHFAIL";
                        case s.Strophe.Status.CONNECTED:
                            return "CONNECTED";
                        case s.Strophe.Status.DISCONNECTED:
                            return "DISCONNECTED";
                        case s.Strophe.Status.DISCONNECTING:
                            return "DISCONNECTING";
                        case s.Strophe.Status.ATTACHED:
                            return "ATTACHED";
                        default:
                            return "unknown"
                    }
                }
            }
        }).call(this, "modules/xmpp/strophe.util.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return u
            }));
            var i = n(5),
                s = n(1),
                r = n(20),
                o = n.n(r),
                a = n(4),
                c = n(3);
            const d = Object(i.getLogger)(e);
            class u {
                constructor(e, t) {
                    this.conference = e, this.options = t, this.disabledCodec = t.disabledCodec === o.a.VP8 ? void 0 : this._getCodecMimeType(t.disabledCodec);
                    const n = this._getCodecMimeType(t.jvbCodec),
                        i = this._getCodecMimeType(t.p2pCodec);
                    this.jvbPreferredCodec = n && this._isCodecSupported(n) ? n : o.a.VP8, this.p2pPreferredCodec = i && this._isCodecSupported(i) ? i : o.a.VP8, d.debug(`Codec preferences for the conference are JVB: ${this.jvbPreferredCodec},\n            P2P: ${this.p2pPreferredCodec}`), c.a.isFirefox() && this.jvbPreferredCodec === o.a.VP9 && (this.jvbPreferredCodec = o.a.VP8), this.conference.on(s.USER_JOINED, () => this._selectPreferredCodec()), this.conference.on(s.USER_LEFT, () => this._selectPreferredCodec()), this.conference.on(s._MEDIA_SESSION_STARTED, e => this._onMediaSessionStared(e))
                }
                _getCodecMimeType(e) {
                    return "string" == typeof e ? Object.values(o.a).find(t => t === e.toLowerCase()) : null
                }
                _isCodecSupported(e) {
                    return !(!c.a.isFirefox() && !c.a.isReactNative()) || window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("video").codecs.some(t => t.mimeType.toLowerCase() === "video/" + e)
                }
                _onMediaSessionStared(e) {
                    const t = e.isP2P ? this.p2pPreferredCodec : this.jvbPreferredCodec,
                        n = this.disabledCodec && this._isCodecSupported(this.disabledCodec) ? this.disabledCodec : null;
                    this._selectPreferredCodec(e, t, n)
                }
                _selectPreferredCodec(e = null, t = null, n = null) {
                    const i = e || this.conference.jvbJingleSession,
                        s = t || this.jvbPreferredCodec;
                    let r = s;
                    if (i && !i.isP2P && !this.options.enforcePreferredCodec) {
                        const e = this.conference.getParticipants().map(e => e.getId());
                        for (const t of e) {
                            const e = i.signalingLayer.getPeerMediaInfo(t, a.c),
                                n = null == e ? void 0 : e.codecType;
                            !n || n === s || c.a.isFirefox() && n === o.a.VP9 || (r = n)
                        }
                    }
                    i && i.setVideoCodecs(r, n)
                }
                getPreferredCodec() {
                    return this.jvbPreferredCodec
                }
            }
        }).call(this, "modules/RTC/CodecSelection.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return p
            }));
            var i = n(5),
                s = n(7),
                r = n.n(s),
                o = n(8),
                a = n(6),
                c = n(12),
                d = n.n(c);

            function u(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? Object(arguments[t]) : {},
                        i = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), i.forEach((function(t) {
                        l(e, t, n[t])
                    }))
                }
                return e
            }

            function l(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const h = Object(i.getLogger)(e);
            class p {
                constructor(e, t, n) {
                    if (!e && !t) throw new TypeError("At least peerconnection or wsUrl must be given");
                    if (e && t) throw new TypeError("Just one of peerconnection or wsUrl must be given");
                    if (e ? h.debug("constructor() with peerconnection") : h.debug(`constructor() with wsUrl:"${t}"`), this._channel = null, this._eventEmitter = n, this._mode = null, this._areRetriesEnabled = !1, this._closedFromClient = !1, e) {
                        const t = e.createDataChannel("JVB data channel", {
                            protocol: "http://jitsi.org/protocols/colibri"
                        });
                        this._handleChannel(t), this._mode = "datachannel"
                    } else t && (this._areRetriesEnabled = !0, this._wsUrl = t, this._initWebSocket())
                }
                _initWebSocket() {
                    const e = new WebSocket(this._wsUrl);
                    this._handleChannel(e), this._mode = "websocket"
                }
                _startConnectionRetries() {
                    let e = 1;
                    const t = () => {
                        this.isOpen() || (this._initWebSocket(this._wsUrl), e = Math.min(2 * e, 60), this._retryTimeout = setTimeout(t, 1e3 * e))
                    };
                    this._retryTimeout = setTimeout(t, 1e3 * e)
                }
                _stopConnectionRetries() {
                    this._retryTimeout && (clearTimeout(this._retryTimeout), this._retryTimeout = void 0)
                }
                _retryWebSocketConnection(e) {
                    if (!this._areRetriesEnabled) return;
                    const {
                        code: t,
                        reason: n
                    } = e;
                    a.a.sendAnalytics(Object(o.y)(t, n)), this._areRetriesEnabled = !1, this._eventEmitter.once(r.a.DATA_CHANNEL_OPEN, () => {
                        this._stopConnectionRetries(), this._areRetriesEnabled = !0
                    }), this._startConnectionRetries()
                }
                get mode() {
                    return this._mode
                }
                close() {
                    if (this._closedFromClient = !0, this._stopConnectionRetries(), this._areRetriesEnabled = !1, this._channel) {
                        try {
                            this._channel.close()
                        } catch (e) {}
                        this._channel = null
                    }
                }
                isOpen() {
                    return this._channel && ("open" === this._channel.readyState || this._channel.readyState === WebSocket.OPEN)
                }
                sendEndpointStatsMessage(e) {
                    this._send(u({
                        colibriClass: "EndpointStats"
                    }, e))
                }
                sendMessage(e, t) {
                    this._send({
                        colibriClass: "EndpointMessage",
                        msgPayload: t,
                        to: e
                    })
                }
                sendSetLastNMessage(e) {
                    h.log(`Sending lastN=${e}.`), this._send({
                        colibriClass: "LastNChangedEvent",
                        lastN: e
                    })
                }
                sendSelectedEndpointsMessage(e) {
                    h.log(`Sending selected endpoints: ${e}.`), this._send({
                        colibriClass: "SelectedEndpointsChangedEvent",
                        selectedEndpoints: e
                    })
                }
                sendReceiverVideoConstraintMessage(e) {
                    h.log(`Sending ReceiverVideoConstraint with maxFrameHeight=${e}px`), this._send({
                        colibriClass: "ReceiverVideoConstraint",
                        maxFrameHeight: e
                    })
                }
                sendNewReceiverVideoConstraintsMessage(e) {
                    h.log("Sending ReceiverVideoConstraints with " + JSON.stringify(e)), this._send(u({
                        colibriClass: "ReceiverVideoConstraints"
                    }, e))
                }
                sendVideoTypeMessage(e) {
                    h.debug("Sending VideoTypeMessage with video type as " + e), this._send({
                        colibriClass: "VideoTypeMessage",
                        videoType: e
                    })
                }
                _handleChannel(e) {
                    const t = this._eventEmitter;
                    e.onopen = () => {
                        h.info(this._mode + " channel opened"), t.emit(r.a.DATA_CHANNEL_OPEN)
                    }, e.onerror = e => {
                        "websocket" !== this._mode && h.error("Channel error: " + e.message)
                    }, e.onmessage = ({
                        data: e
                    }) => {
                        let n;
                        try {
                            n = JSON.parse(e)
                        } catch (t) {
                            return d.a.callErrorHandler(t), void h.error("Failed to parse channel message as JSON: ", e, t)
                        }
                        const i = n.colibriClass;
                        switch (i) {
                            case "DominantSpeakerEndpointChangeEvent": {
                                const {
                                    dominantSpeakerEndpoint: e,
                                    previousSpeakers: i = []
                                } = n;
                                h.debug(`Dominant speaker: ${e}, previous speakers: ${i}`), t.emit(r.a.DOMINANT_SPEAKER_CHANGED, e, i);
                                break
                            }
                            case "EndpointConnectivityStatusChangeEvent": {
                                const e = n.endpoint,
                                    i = "true" === n.active;
                                h.info(`Endpoint connection status changed: ${e} active=${i}`), t.emit(r.a.ENDPOINT_CONN_STATUS_CHANGED, e, i);
                                break
                            }
                            case "EndpointMessage":
                                t.emit(r.a.ENDPOINT_MESSAGE_RECEIVED, n.from, n.msgPayload);
                                break;
                            case "EndpointStats":
                                t.emit(r.a.ENDPOINT_STATS_RECEIVED, n.from, n);
                                break;
                            case "LastNEndpointsChangeEvent": {
                                const e = n.lastNEndpoints;
                                h.info("New forwarded endpoints: " + e), t.emit(r.a.LASTN_ENDPOINT_CHANGED, e);
                                break
                            }
                            case "SenderVideoConstraints": {
                                const e = n.videoConstraints;
                                e && (h.info("SenderVideoConstraints: " + JSON.stringify(e)), t.emit(r.a.SENDER_VIDEO_CONSTRAINTS_CHANGED, e));
                                break
                            }
                            case "ServerHello":
                                h.info(`Received ServerHello, version=${n.version}.`);
                                break;
                            default:
                                h.debug("Channel JSON-formatted message: ", n), t.emit("rtc.datachannel." + i, n)
                        }
                    }, e.onclose = e => {
                        h.info("Channel closed by " + (this._closedFromClient ? "client" : "server")), "websocket" === this._mode && (this._closedFromClient || (h.error(`Channel closed: ${e.code} ${e.reason}`), this._retryWebSocketConnection(e))), this._channel = null
                    }, this._channel = e
                }
                _send(e) {
                    const t = this._channel;
                    if (!this.isOpen()) throw h.error("Bridge Channel send: no opened channel."), new Error("No opened channel");
                    t.send(JSON.stringify(e))
                }
            }
        }).call(this, "modules/RTC/BridgeChannel.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return y
            }));
            var i = n(5),
                s = n(21),
                r = n(15),
                o = n(16),
                a = n(47),
                c = n.n(a),
                d = n(4),
                u = n(7),
                l = n.n(u),
                h = n(14),
                p = n.n(h),
                m = n(8),
                f = n(3),
                g = n(6),
                _ = n(65),
                v = n(11);
            const S = Object(i.getLogger)(e);
            class y extends _.a {
                constructor({
                    deviceId: e,
                    facingMode: t,
                    mediaType: n,
                    resolution: i,
                    rtcId: s,
                    sourceId: r,
                    sourceType: a,
                    stream: c,
                    track: d,
                    videoType: u,
                    effects: h = []
                }) {
                    super(null, c, d, () => this.emit(o.LOCAL_TRACK_STOPPED), n, u), this._setEffectInProgress = !1;
                    const m = h.find(e => e.isEnabled(this));
                    m && this._startStreamEffect(m), this.rtcId = s, this.sourceId = r, this.sourceType = a, this.resolution = d.getSettings().height, this.maxEnabledResolution = i, this._constraints = d.getConstraints(), Object.keys(this._constraints).length || u !== p.a.CAMERA || (this._constraints = {
                        height: d.getSettings().height,
                        width: d.getSettings().width
                    }), this.deviceId = e, this._prevSetMuted = Promise.resolve(), this._facingMode = t, this._trackEnded = !1, this._hasSentData = !1, this._testDataSent = !0, this._realDeviceId = "" === this.deviceId ? void 0 : this.deviceId, this._trackMutedTS = 0, this._onDeviceListWillChange = e => {
                        const t = this._realDeviceId;
                        this._setRealDeviceIdFromDeviceList(e), (void 0 === this.getTrack().readyState && void 0 !== this._realDeviceId && !e.find(e => e.deviceId === this._realDeviceId) || void 0 !== t && void 0 === this._realDeviceId) && (this._trackEnded = !0)
                    }, this.isAudioTrack() && v.a.isDeviceChangeAvailable("output") && (this._onAudioOutputDeviceChanged = this.setAudioOutput.bind(this), v.a.addListener(l.a.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged)), v.a.addListener(l.a.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._initNoDataFromSourceHandlers()
                }
                isEnded() {
                    return this.isVideoTrack() && this.isMuted() ? this._trackEnded : "ended" === this.getTrack().readyState || this._trackEnded
                }
                _initNoDataFromSourceHandlers() {
                    this._isNoDataFromSourceEventsEnabled() && (this._setHandler("track_mute", () => {
                        this._trackMutedTS = window.performance.now(), this._fireNoDataFromSourceEvent()
                    }), this._setHandler("track_unmute", () => {
                        this._fireNoDataFromSourceEvent(), g.a.sendAnalyticsAndLog(m.s, {
                            media_type: this.getType(),
                            track_type: "local",
                            value: window.performance.now() - this._trackMutedTS
                        })
                    }), this.isVideoTrack() && this.videoType === p.a.CAMERA && this._setHandler("track_ended", () => {
                        this.isReceivingData() || this._fireNoDataFromSourceEvent()
                    }))
                }
                _isNoDataFromSourceEventsEnabled() {
                    return !this.isVideoTrack() || this.videoType !== p.a.DESKTOP
                }
                _fireNoDataFromSourceEvent() {
                    const e = !this.isReceivingData();
                    this.emit(o.NO_DATA_FROM_SOURCE, e), g.a.sendAnalytics(Object(m.H)(this.getType(), e)), g.a.sendLog(JSON.stringify({
                        name: o.NO_DATA_FROM_SOURCE,
                        log: e
                    }))
                }
                _setRealDeviceIdFromDeviceList(e) {
                    const t = this.getTrack(),
                        n = t.kind + "input";
                    let i = e.find(e => e.kind === n && e.label === t.label);
                    if (!i && "default" === this._realDeviceId) {
                        const s = (t.label || "").replace("Default - ", "");
                        i = e.find(e => e.kind === n && e.label === s)
                    }
                    this._realDeviceId = i ? i.deviceId : void 0
                }
                _setStream(e) {
                    super._setStream(e), e ? (this.storedMSID = this.getMSID(), S.debug(`Setting new MSID: ${this.storedMSID} on ${this}`)) : S.debug("Setting 'null' stream on " + this)
                }
                _startStreamEffect(e) {
                    this._streamEffect = e, this._originalStream = this.stream, this._setStream(this._streamEffect.startEffect(this._originalStream)), this.track = this.stream.getTracks()[0]
                }
                _stopStreamEffect() {
                    this._streamEffect && (this._streamEffect.stopEffect(), this._setStream(this._originalStream), this._originalStream = null, this.track = this.stream ? this.stream.getTracks()[0] : null)
                }
                _switchStreamEffect(e) {
                    this._streamEffect && (this._stopStreamEffect(), this._streamEffect = void 0), e && this._startStreamEffect(e)
                }
                setEffect(e) {
                    if (void 0 === this._streamEffect && void 0 === e) return Promise.resolve();
                    if (void 0 !== e && !e.isEnabled(this)) return Promise.reject(new Error("Incompatible effect instance!"));
                    if (!0 === this._setEffectInProgress) return Promise.reject(new Error("setEffect already in progress!"));
                    if (this.isMuted() && !this.isAudioTrack()) return this._streamEffect = e, Promise.resolve();
                    const t = this.conference;
                    return t ? (this._setEffectInProgress = !0, t.removeTrack(this).then(() => (this._switchStreamEffect(e), this.isVideoTrack() && this.containers.forEach(e => v.a.attachMediaStream(e, this.stream)), t.addTrack(this))).then(() => {
                        this._setEffectInProgress = !1
                    }).catch(e => {
                        throw this._setEffectInProgress = !1, this._switchStreamEffect(), S.error("Failed to switch to the new stream!", e), e
                    })) : (this._switchStreamEffect(e), this.isVideoTrack() && this.containers.forEach(e => v.a.attachMediaStream(e, this.stream)), Promise.resolve())
                }
                mute() {
                    return this._queueSetMuted(!0)
                }
                unmute() {
                    return this._queueSetMuted(!1)
                }
                _queueSetMuted(e) {
                    const t = this._setMuted.bind(this, e);
                    return this._prevSetMuted = this._prevSetMuted.then(t, t), this._prevSetMuted
                }
                _setMuted(e) {
                    if (this.isMuted() === e) return Promise.resolve();
                    if (this.disposed) return Promise.reject(new s.a(r.TRACK_IS_DISPOSED));
                    let t = Promise.resolve();
                    const n = () => S.info(`Mute ${this}: ${e}`);
                    if (this.isAudioTrack() || this.videoType === p.a.DESKTOP || !f.a.doesVideoMuteByStreamRemove()) n(), this._streamEffect && this._streamEffect.setMuted ? this._streamEffect.setMuted(e) : this.track && (this.track.enabled = !e);
                    else if (e) t = new Promise((e, t) => {
                        n(), this._removeStreamFromConferenceAsMute(() => {
                            this._streamEffect && this._stopStreamEffect(), this._unregisterHandlers(), this.stopStream(), this._setStream(null), e()
                        }, t)
                    });
                    else {
                        n();
                        const e = {
                            cameraDeviceId: this.getDeviceId(),
                            devices: [d.c],
                            effects: this._streamEffect ? [this._streamEffect] : [],
                            facingMode: this.getCameraFacingMode()
                        };
                        t = v.a.obtainAudioAndVideoPermissions(Object.assign({}, e, {
                            constraints: {
                                video: this._constraints
                            }
                        })), t = t.then(e => {
                            const t = this.getType() === d.b ? d.c : this.getType(),
                                n = e.find(e => e.track.kind === t);
                            if (!n) throw new s.a(r.TRACK_NO_STREAM_FOUND);
                            return this._setStream(n.stream), this.track = n.track, this.videoType !== n.videoType && (S.warn(this + ": video type has changed after unmute!", this.videoType, n.videoType), this.videoType = n.videoType), this._streamEffect && this._startStreamEffect(this._streamEffect), this.containers.map(e => v.a.attachMediaStream(e, this.stream)), this._addStreamToConferenceAsUnmute()
                        })
                    }
                    return t.then(() => this._sendMuteStatus(e)).then(() => this.emit(o.TRACK_MUTE_CHANGED, this))
                }
                _addStreamToConferenceAsUnmute() {
                    return this.conference ? new Promise((e, t) => {
                        this.conference._addLocalTrackAsUnmute(this).then(e, e => t(new Error(e)))
                    }) : Promise.resolve()
                }
                _removeStreamFromConferenceAsMute(e, t) {
                    this.conference ? this.conference._removeLocalTrackAsMute(this).then(e, e => t(new Error(e))) : e()
                }
                _sendMuteStatus(e) {
                    return this.conference && this.conference.room ? new Promise(t => {
                        this.conference.room[this.isAudioTrack() ? "setAudioMute" : "setVideoMute"](e, t)
                    }) : Promise.resolve()
                }
                dispose() {
                    let e = Promise.resolve();
                    return this._streamEffect && (e = this.setEffect()), this.conference && (e = e.then(() => this.conference.removeTrack(this))), this.stream && (this.stopStream(), this.detach()), v.a.removeListener(l.a.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._onAudioOutputDeviceChanged && v.a.removeListener(l.a.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged), e.then(() => super.dispose())
                }
                isMuted() {
                    return !this.stream || (!(!this.isVideoTrack() || this.isActive()) || (this._streamEffect && this._streamEffect.isMuted ? this._streamEffect.isMuted() : !this.track || !this.track.enabled))
                }
                _setConference(e) {
                    this.conference = e;
                    for (let e = 0; e < this.containers.length; e++) this._maybeFireTrackAttached(this.containers[e])
                }
                isLocal() {
                    return !0
                }
                getDeviceId() {
                    return this._realDeviceId || this.deviceId
                }
                getParticipantId() {
                    return this.conference && this.conference.myUserId()
                }
                _onByteSentStatsReceived(e, t) {
                    t > 0 && (this._hasSentData = !0);
                    const n = e.getConnectionState();
                    this._testDataSent && "connected" === n && (setTimeout(() => {
                        this._hasSentData || (S.warn(`${this} 'bytes sent' <= 0:                         ${t}`), g.a.analytics.sendEvent(m.r, {
                            media_type: this.getType()
                        }))
                    }, 3e3), this._testDataSent = !1)
                }
                getCameraFacingMode() {
                    if (this.isVideoTrack() && this.videoType === p.a.CAMERA) {
                        var e, t;
                        const n = null === (e = (t = this.track).getSettings) || void 0 === e ? void 0 : e.call(t);
                        return n && "facingMode" in n ? n.facingMode : void 0 !== this._facingMode ? this._facingMode : c.a.USER
                    }
                }
                stopStream() {
                    this._stopStreamInProgress = !0;
                    try {
                        v.a.stopMediaStream(this.stream)
                    } finally {
                        this._stopStreamInProgress = !1
                    }
                }
                _switchCamera() {
                    this.isVideoTrack() && this.videoType === p.a.CAMERA && "function" == typeof this.track._switchCamera && (this.track._switchCamera(), this._facingMode = this._facingMode === c.a.ENVIRONMENT ? c.a.USER : c.a.ENVIRONMENT)
                }
                isReceivingData() {
                    if (this.isVideoTrack() && (this.isMuted() || this._stopStreamInProgress || this.videoType === p.a.DESKTOP)) return !0;
                    if (!this.stream) return !1;
                    return (this._effectEnabled ? this._originalStream : this.stream).getTracks().some(e => !("readyState" in e && "live" !== e.readyState || "muted" in e && !0 === e.muted))
                }
                toString() {
                    return `LocalTrack[${this.rtcId},${this.getType()}]`
                }
            }
        }).call(this, "modules/RTC/JitsiLocalTrack.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return D
            }));
            var i = n(149),
                s = n(5),
                r = n(23),
                o = n.n(r),
                a = n(20),
                c = n(10),
                d = n.n(c),
                u = n(4),
                l = n(7),
                h = n.n(l),
                p = n(42),
                m = n(14),
                f = n(39),
                g = n(3),
                _ = n(120),
                v = n(121),
                S = n(18),
                y = n(9),
                E = n(122),
                b = n(30),
                C = n(12),
                T = n(123),
                R = n(13),
                A = n(11),
                I = n(60);
            const w = Object(s.getLogger)(e);

            function D(e, t, s, r, o, a, c) {
                this.audioTransferActive = !(!0 === c.startSilent), this._dtmfSender = void 0, this._dtmfTonesQueue = [], this.videoTransferActive = !0, this.rtc = e, this.id = t, this.isP2P = a, this.remoteTracks = new Map, this.localTracks = new Map, this._addedStreams = [], this.localSSRCs = new Map, this.localUfrag = null, this.remoteUfrag = null, this.signalingLayer = s, this._peerVideoTypeChanged = this._peerVideoTypeChanged.bind(this), this.signalingLayer.on(p.b, this._peerVideoTypeChanged), this._peerMutedChanged = this._peerMutedChanged.bind(this), this.signalingLayer.on(p.a, this._peerMutedChanged), this.options = c;
                const d = o || {};
                d.optional = d.optional || [], Array.isArray(d.optional) ? d.optional.push({
                    rtcStatsSFUP2P: this.isP2P
                }) : w.warn("Optional param is not an array, rtcstats p2p data is omitted."), this.peerconnection = new A.a.RTCPeerConnectionType(r, d);
                const u = {
                    low: 2e5,
                    standard: 7e5,
                    high: 25e5
                };
                this.videoBitrates = this.options.videoQuality && this.options.videoQuality.maxBitratesVideo ? this.options.videoQuality.maxBitratesVideo : u, this.tpcUtils = new I.b(this, this.videoBitrates), this.updateLog = [], this.stats = {}, this.statsinterval = null, this._capScreenshareBitrate = this.options.capScreenshareBitrate, this._usesUnifiedPlan = c.usesUnifiedPlan, this._usesTransceiverCodecPreferences = g.a.supportsCodecPreferences() && this._usesUnifiedPlan, this._usesTransceiverCodecPreferences && w.info("Using RTCRtpTransceiver#setCodecPreferences for codec selection"), this.maxstats = c.maxstats, this.interop = new i.a;
                const l = n(162);
                this.simulcast = new l({
                    numOfLayers: I.a.length,
                    explodeRemoteSimulcast: !1,
                    usesUnifiedPlan: this._usesUnifiedPlan
                }), this.sdpConsistency = new E.a(this.toString()), this.localSdpMunger = new _.a(this, this.rtc.getLocalEndpointId()), this.eventEmitter = e.eventEmitter, this.rtxModifier = new v.a, this.senderVideoMaxHeight = null, this.trace = (e, t) => {
                    w.debug(e, t), this.updateLog.push({
                        time: new Date,
                        type: e,
                        value: t || ""
                    })
                }, this.onicecandidate = null, this.peerconnection.onicecandidate = e => {
                    this.trace("onicecandidate", JSON.stringify(e.candidate, null, " ")), null !== this.onicecandidate && this.onicecandidate(e)
                }, this._usesUnifiedPlan ? (this.onTrack = e => {
                    const t = e.streams[0];
                    this._remoteTrackAdded(t, e.track, e.transceiver), t.addEventListener("removetrack", e => {
                        this._remoteTrackRemoved(t, e.track)
                    })
                }, this.peerconnection.addEventListener("track", this.onTrack)) : (this.peerconnection.onaddstream = e => this._remoteStreamAdded(e.stream), this.peerconnection.onremovestream = e => this._remoteStreamRemoved(e.stream)), this.onsignalingstatechange = null, this.peerconnection.onsignalingstatechange = e => {
                    this.trace("onsignalingstatechange", this.signalingState), null !== this.onsignalingstatechange && this.onsignalingstatechange(e)
                }, this.oniceconnectionstatechange = null, this.peerconnection.oniceconnectionstatechange = e => {
                    this.trace("oniceconnectionstatechange", this.iceConnectionState), null !== this.oniceconnectionstatechange && this.oniceconnectionstatechange(e)
                }, this.onnegotiationneeded = null, this.peerconnection.onnegotiationneeded = e => {
                    this.trace("onnegotiationneeded"), null !== this.onnegotiationneeded && this.onnegotiationneeded(e)
                }, this.ondatachannel = null, this.peerconnection.ondatachannel = e => {
                    this.trace("ondatachannel"), null !== this.ondatachannel && this.ondatachannel(e)
                }, this.maxstats && (this.statsinterval = window.setInterval(() => {
                    this.getStats().then(e => {
                        if ("function" == typeof(null == e ? void 0 : e.result)) {
                            const t = e.result();
                            for (let e = 0; e < t.length; ++e) {
                                const n = t[e];
                                n.names().forEach(e => {
                                    this._processStat(n, e, n.stat(e))
                                })
                            }
                        } else e.forEach(e => this._processStat(e, "", e))
                    })
                }, 1e3)), w.info("Create new " + this)
            }
            D.prototype._processStat = function(e, t, n) {
                const i = `${e.id}-${t}`;
                let s = this.stats[i];
                const r = new Date;
                s || (this.stats[i] = s = {
                    startTime: r,
                    endTime: r,
                    values: [],
                    times: []
                }), s.values.push(n), s.times.push(r.getTime()), s.values.length > this.maxstats && (s.values.shift(), s.times.shift()), s.endTime = r
            };
            const P = function(e) {
                return null == e ? "" : `type: ${e.type}\r\n${e.sdp}`
            };
            D.prototype.getConnectionState = function() {
                const e = this.peerconnection.iceConnectionState;
                return "completed" === e ? "connected" : e
            }, D.prototype.getDesiredMediaDirection = function(e, t = !1) {
                const n = this.hasAnyTracksOfType(e);
                if (this._usesUnifiedPlan) return t ? n ? d.a.SENDRECV : d.a.SENDONLY : n ? d.a.RECVONLY : d.a.INACTIVE;
                return (e === u.a ? this.audioTransferActive : this.videoTransferActive) ? n ? d.a.SENDRECV : d.a.RECVONLY : d.a.INACTIVE
            }, D.prototype._getReceiversByEndpointIds = function(e, t) {
                let n = [],
                    i = [];
                for (const i of e) n = n.concat(this.getRemoteTracks(i, t));
                const s = n.map(e => {
                    var t;
                    return null === (t = e.track) || void 0 === t ? void 0 : t.id
                });
                return i = this.peerconnection.getReceivers().filter(e => e.track && e.track.kind === t && s.find(t => t === e.track.id)), i
            }, D.prototype.isSimulcastOn = function() {
                return !this.options.disableSimulcast
            }, D.prototype._peerVideoTypeChanged = function(e, t) {
                if (!e) return void w.error(this + " No endpointID on peerVideoTypeChanged");
                const n = this.getRemoteTracks(e, u.c);
                n.length && n[0]._setVideoType(t)
            }, D.prototype._peerMutedChanged = function(e, t, n) {
                if (!e) return void w.error(this + " On peerMuteChanged - no endpoint ID");
                const i = this.getRemoteTracks(e, t);
                i.length && i[0].setMute(n)
            }, D.prototype.getAudioLevels = function(e = []) {
                const t = {};
                return (e.length ? this._getReceiversByEndpointIds(e, u.a) : this.peerconnection.getReceivers().filter(e => e.track && e.track.kind === u.a && e.track.enabled)).forEach(e => {
                    const n = e.getSynchronizationSources();
                    n && n.length && (t[n[0].source] = n[0].audioLevel)
                }), t
            }, D.prototype.getLocalTracks = function(e) {
                let t = Array.from(this.localTracks.values());
                return void 0 !== e && (t = t.filter(t => t.getType() === e)), t
            }, D.prototype.getLocalVideoTrack = function() {
                return this.getLocalTracks(u.c)[0]
            }, D.prototype.hasAnyTracksOfType = function(e) {
                if (!e) throw new Error('"mediaType" is required');
                return this.getLocalTracks(e).length > 0
            }, D.prototype.getRemoteTracks = function(e, t) {
                const n = [],
                    i = e ? [e] : this.remoteTracks.keys();
                for (const e of i) {
                    const i = this.remoteTracks.get(e);
                    if (i)
                        for (const e of i.keys())
                            if (!t || t === e) {
                                const t = i.get(e);
                                t && n.push(t)
                            }
                }
                return n
            }, D.prototype.getRemoteSourceInfoByParticipant = function(e) {
                const t = [],
                    n = this.getRemoteTracks(e);
                if (!(null == n ? void 0 : n.length)) return t;
                const i = n.map(e => e.getSSRC()),
                    s = new S.a(this.remoteDescription.sdp);
                return i.forEach((e, n) => {
                    for (const i of s.media) {
                        let s = "",
                            r = y.a.findLines(i, "a=ssrc:" + e);
                        if (r.length) {
                            t[n] || (t[n] = "");
                            const o = y.a.findLines(i, "a=ssrc-group:FID " + e);
                            if (o.length) {
                                const e = o[0].split(" ")[2];
                                s += o[0] + "\r\n", r = r.concat(y.a.findLines(i, "a=ssrc:" + e))
                            }
                            t[n] += r.join("\r\n") + "\r\n", t[n] += s
                        }
                    }
                }), t
            }, D.prototype.getTargetVideoBitrates = function() {
                const e = this.getConfiguredVideoCodec();
                return this.videoBitrates[e.toUpperCase()] || this.videoBitrates
            }, D.prototype.getTrackBySSRC = function(e) {
                if ("number" != typeof e) throw new Error(`SSRC ${e} is not a number`);
                for (const t of this.localTracks.values())
                    if (this.getLocalSSRC(t) === e) return t;
                for (const t of this.getRemoteTracks())
                    if (t.getSSRC() === e) return t;
                return null
            }, D.prototype.getSsrcByTrackId = function(e) {
                const t = t => t.getTrack().id === e,
                    n = this.getLocalTracks().find(t);
                if (n) return this.getLocalSSRC(n);
                const i = this.getRemoteTracks().find(t);
                return i ? i.getSSRC() : null
            }, D.prototype._remoteStreamAdded = function(e) {
                const t = R.a.getStreamID(e);
                if (!R.a.isUserStreamById(t)) return void w.info(`${this} ignored remote 'stream added' event for non-user stream[id=${t}]`);
                g.a.isChromiumBased() && (e.onaddtrack = t => {
                    this._remoteTrackAdded(e, t.track)
                }, e.onremovetrack = t => {
                    this._remoteTrackRemoved(e, t.track)
                });
                const n = e.getAudioTracks();
                for (const t of n) this._remoteTrackAdded(e, t);
                const i = e.getVideoTracks();
                for (const t of i) this._remoteTrackAdded(e, t)
            }, D.prototype._remoteTrackAdded = function(e, t, n = null) {
                const i = R.a.getStreamID(e),
                    s = t.kind;
                if (!this.isP2P && !R.a.isUserStreamById(i)) return void w.info(`${this} ignored remote 'stream added' event for non-user stream[id=${i}]`);
                if (w.info(`${this} adding remote track for stream[id=${i},type=${s}]`), !s) return void C.callErrorHandler(new Error("MediaType undefined for remote track, stream id: " + i));
                const r = this._usesUnifiedPlan ? new S.a(this.peerconnection.remoteDescription.sdp) : new S.a(this.remoteDescription.sdp);
                let o;
                if (this._usesUnifiedPlan)
                    if (n && n.mid) {
                        const e = n.mid;
                        o = r.media.filter(t => y.a.findLine(t, "a=mid:" + e))
                    } else o = r.media.filter(e => {
                        const t = y.a.findLine(e, "a=msid:");
                        return void 0 !== t && i === t.substring(7).split(" ")[0]
                    });
                else o = r.media.filter(e => e.startsWith("m=" + s));
                if (!o.length) return void C.callErrorHandler(new Error(`No media lines found in remote SDP for remote stream[id=${i},type=${s}]`));
                let a = y.a.findLines(o[0], "a=ssrc:");
                if (a = a.filter(e => -1 !== e.indexOf("msid:" + i)), !a.length) return void C.callErrorHandler(new Error(`No SSRC lines found in remote SDP for remote stream[msid=${i},type=${s}]`));
                const c = a[0].substring(7).split(" ")[0],
                    d = Number(c),
                    u = this.signalingLayer.getSSRCOwner(d);
                if (isNaN(d) || d < 0) return void C.callErrorHandler(new Error(`Invalid SSRC for remote stream[ssrc=${d},id=${i},type=${s}]`));
                if (!u) return void C.callErrorHandler(new Error(`No SSRC owner known for remote stream[ssrc=${d},id=${i},type=${s}]`));
                w.info(`${this} creating remote track[endpoint=${u},ssrc=${d},type=${s}]`);
                const l = this.signalingLayer.getPeerMediaInfo(u, s);
                if (!l) return void C.callErrorHandler(new Error(`${this}: no peer media info available for ${u}`));
                const h = l.muted,
                    p = l.videoType;
                this._createRemoteTrack(u, e, t, s, p, d, h)
            }, D.prototype._createRemoteTrack = function(e, t, n, i, s, r, o) {
                let a = this.remoteTracks.get(e);
                a || (a = new Map, this.remoteTracks.set(e, a));
                const c = a.get(i);
                if (c && c.getTrack() === n) return void w.info(`${this} ignored duplicated track event for track[endpoint=${e},type=${i}]`);
                c && (w.error(`${this} received a second remote track for track[endpoint=${e},type=${i}]deleting the existing track`), this._remoteTrackRemoved(c.getOriginalStream(), c.getTrack()));
                const d = new T.a(this.rtc, this.rtc.conference, e, t, n, i, s, r, o, this.isP2P);
                a.set(i, d), this.eventEmitter.emit(h.a.REMOTE_TRACK_ADDED, d, this)
            }, D.prototype._remoteStreamRemoved = function(e) {
                if (!R.a.isUserStream(e)) {
                    const t = R.a.getStreamID(e);
                    return void w.info(`Ignored remote 'stream removed' event for stream[id=${t}]`)
                }
                const t = e.getVideoTracks();
                for (const n of t) this._remoteTrackRemoved(e, n);
                const n = e.getAudioTracks();
                for (const t of n) this._remoteTrackRemoved(e, t)
            }, D.prototype._remoteTrackRemoved = function(e, t) {
                const n = R.a.getStreamID(e),
                    i = t && R.a.getTrackID(t);
                R.a.isUserStreamById(n) ? (w.info(`${this} remote track removed stream[id=${n},trackId=${i}]`), n ? i ? this._removeRemoteTrackById(n, i) || w.warn(`${this} Removed track not found for stream[id=${n},trackId=${i}]`) : C.callErrorHandler(new Error(this + " remote track removal failed - no track ID")) : C.callErrorHandler(new Error(this + " remote track removal failed - no stream ID"))) : w.info(`${this} ignored remote 'stream removed' event for non-user stream[id=${n}]`)
            }, D.prototype._getRemoteTrackById = function(e, t) {
                for (const n of this.remoteTracks.values())
                    for (const i of n.values())
                        if (i.getStreamId() == e && i.getTrackId() == t) return i
            }, D.prototype.removeRemoteTracks = function(e) {
                const t = [],
                    n = this.remoteTracks.get(e);
                if (n) {
                    const i = n.get(u.a),
                        s = n.get(u.c);
                    i && t.push(i), s && t.push(s), this.remoteTracks.delete(e)
                }
                return w.debug(`${this} removed remote tracks[endpoint=${e},count=${t.length}`), t
            }, D.prototype._removeRemoteTrack = function(e) {
                e.dispose();
                const t = e.getParticipantId(),
                    n = this.remoteTracks.get(t);
                n ? n.delete(e.getType()) || w.error(`${this} Failed to remove ${e} - type mapping messed up ?`) : w.error(`${this} removeRemoteTrack: no remote tracks map for endpoint=${t}`), this.eventEmitter.emit(h.a.REMOTE_TRACK_REMOVED, e)
            }, D.prototype._removeRemoteTrackById = function(e, t) {
                const n = this._getRemoteTrackById(e, t);
                return n && this._removeRemoteTrack(n), n
            }, D.prototype._extractSSRCMap = function(e) {
                const t = new Map,
                    n = new Map;
                if ("object" != typeof e || null === e || "string" != typeof e.sdp) return w.warn("An empty description was passed as an argument"), t;
                const i = o.a.parse(e.sdp);
                if (!Array.isArray(i.media)) return t;
                let s = i.media;
                this._usesUnifiedPlan && (s = [], [u.a, u.c].forEach(e => {
                    s.push(i.media.find(t => t.type === e))
                }));
                for (const e of s) {
                    if (!Array.isArray(e.ssrcs)) continue;
                    if (Array.isArray(e.ssrcGroups))
                        for (const t of e.ssrcGroups)
                            if (void 0 !== t.semantics && void 0 !== t.ssrcs) {
                                const e = t.ssrcs.split(" ").map(e => parseInt(e, 10)),
                                    i = e[0];
                                t.ssrcs = e, n.has(i) || n.set(i, []), n.get(i).push(t)
                            } let i = e.ssrcs;
                    i = this._usesUnifiedPlan ? i.filter(e => "cname" === e.attribute) : i.filter(e => "msid" === e.attribute);
                    for (const s of i) {
                        const i = this._usesUnifiedPlan ? e.type : s.value,
                            r = s.id;
                        let o = t.get(i);
                        if (o || (o = {
                                ssrcs: [],
                                groups: [],
                                msid: i
                            }, t.set(i, o)), o.ssrcs.push(r), n.has(r)) {
                            const e = n.get(r);
                            for (const t of e) o.groups.push(t)
                        }
                    }
                }
                return t
            };
            const O = function(e) {
                if ("object" != typeof e || null === e || "string" != typeof e.sdp) return w.warn("An empty description was passed as an argument"), e;
                const t = n(23),
                    i = t.parse(e.sdp);
                void 0 !== i && void 0 !== i.media && Array.isArray(i.media) && i.media.forEach(e => {
                    const t = [],
                        n = [];
                    if (void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach(e => {
                            void 0 !== e.semantics && "FID" === e.semantics && void 0 !== e.ssrcs && t.push(Number(e.ssrcs.split(" ")[0]))
                        }), Array.isArray(e.ssrcs)) {
                        let i;
                        for (i = 0; i < e.ssrcs.length; i++) "object" == typeof e.ssrcs[i] && void 0 !== e.ssrcs[i].id && t.indexOf(e.ssrcs[i].id) >= 0 && (n.push(e.ssrcs[i]), delete e.ssrcs[i]);
                        for (i = 0; i < e.ssrcs.length; i++) void 0 !== e.ssrcs[i] && n.push(e.ssrcs[i]);
                        e.ssrcs = function(e = []) {
                            if (!g.a.isChrome() || !g.a.isVersionGreaterThan(70)) return e;
                            let t = [...e];
                            return e.filter(e => e.attribute === "mslabel" && e.value === "-").map(e => e.id).forEach(e => {
                                const n = t.find(t => t.id === e && "cname" === t.attribute);
                                n.value = `${d.a.RECVONLY}-${e}`, t = t.filter(t => t.id !== e), t.push(n)
                            }), t
                        }(n)
                    }
                });
                const s = t.write(i);
                return new RTCSessionDescription({
                    type: e.type,
                    sdp: s
                })
            };
            D.prototype.getLocalSSRC = function(e) {
                const t = this._getSSRC(e.rtcId);
                return t && t.ssrcs[0]
            }, D.prototype._injectSsrcGroupForUnifiedSimulcast = function(e) {
                const t = o.a.parse(e.sdp),
                    n = t.media.find(e => "video" === e.type);
                n.ssrcGroups = n.ssrcGroups || [];
                const i = n.ssrcGroups.filter(e => "FID" === e.semantics);
                if (n.simulcast || n.simulcast_03) {
                    const t = [];
                    if (i && i.length ? i.forEach(e => {
                            t.push(e.ssrcs.split(" ")[0])
                        }) : n.ssrcs.forEach(e => {
                            "msid" === e.attribute && t.push(e.id)
                        }), n.ssrcGroups.find(e => "SIM" === e.semantics)) return e;
                    n.ssrcGroups.push({
                        semantics: "SIM",
                        ssrcs: t.join(" ")
                    })
                }
                return new RTCSessionDescription({
                    type: e.type,
                    sdp: o.a.write(t)
                })
            };
            const N = {
                signalingState() {
                    return this.peerconnection.signalingState
                },
                iceConnectionState() {
                    return this.peerconnection.iceConnectionState
                },
                localDescription() {
                    let e = this.peerconnection.localDescription;
                    return e ? (this.trace("getLocalDescription::preTransform", P(e)), this._usesUnifiedPlan && !this.isP2P ? (e = this.interop.toPlanB(e), this.trace("getLocalDescription::postTransform (Plan B)", P(e)), e = this._injectSsrcGroupForUnifiedSimulcast(e), this.trace("getLocalDescription::postTransform (inject ssrc group)", P(e))) : this._usesUnifiedPlan || (g.a.doesVideoMuteByStreamRemove() && (e = this.localSdpMunger.maybeAddMutedLocalVideoTracksToSDP(e), w.debug("getLocalDescription::postTransform (munge local SDP)", e)), e = function(e, t) {
                        if (!e) throw new Error("No local description passed in.");
                        const n = new b.a(e.sdp),
                            i = n.selectMedia(u.a);
                        let s = !1;
                        i && i.direction !== d.a.SENDRECV && (t.startSilent ? i.direction = d.a.INACTIVE : i.direction = d.a.SENDRECV, s = !0);
                        const r = n.selectMedia(u.c);
                        return r && r.direction !== d.a.SENDRECV && (r.direction = d.a.SENDRECV, s = !0), s ? new RTCSessionDescription({
                            type: e.type,
                            sdp: n.toRawSDP()
                        }) : e
                    }(e, this.options)), e = this.localSdpMunger.transformStreamIdentifiers(e), e) : (w.debug(this + " getLocalDescription no localDescription found"), {})
                },
                remoteDescription() {
                    let e = this.peerconnection.remoteDescription;
                    return e ? (this.trace("getRemoteDescription::preTransform", P(e)), this._usesUnifiedPlan && (this.isP2P ? e = this._adjustRemoteMediaDirection(e) : (e = this.interop.toPlanB(e), this.trace("getRemoteDescription::postTransform (Plan B)", P(e)))), e) : (w.debug(this + " getRemoteDescription no remoteDescription found"), {})
                }
            };
            Object.keys(N).forEach(e => {
                Object.defineProperty(D.prototype, e, {
                    get: N[e]
                })
            }), D.prototype._getSSRC = function(e) {
                return this.localSSRCs.get(e)
            }, D.prototype._isSharingLowFpsScreen = function() {
                return this._isSharingScreen() && this._capScreenshareBitrate
            }, D.prototype._isSharingScreen = function() {
                const e = this.getLocalVideoTrack();
                return e && e.videoType === m.DESKTOP
            }, D.prototype._mungeCodecOrder = function(e) {
                if (!this.codecPreference) return e;
                const t = o.a.parse(e.sdp),
                    n = t.media.find(e => e.type === this.codecPreference.mediaType);
                if (!n) return e;
                if (this.codecPreference.enable)
                    if (y.a.preferCodec(n, this.codecPreference.mimeType), this.codecPreference.mimeType === a.H264 && g.a.isReactNative() && this.isP2P && y.a.stripCodec(n, this.codecPreference.mimeType, !0), this.codecPreference.mimeType === a.VP9) {
                        const e = this.videoBitrates.VP9 || this.videoBitrates,
                            t = e.high ? e.high : 25e5,
                            i = Math.floor((this._isSharingScreen() ? 25e5 : t) / 1e3);
                        n.bandwidth = [{
                            type: "AS",
                            limit: i
                        }]
                    } else n.bandwidth = void 0;
                else y.a.stripCodec(n, this.codecPreference.mimeType);
                return new RTCSessionDescription({
                    type: e.type,
                    sdp: o.a.write(t)
                })
            }, D.prototype.containsTrack = function(e) {
                if (e.isLocal()) return this.localTracks.has(e.rtcId);
                const t = e.getParticipantId(),
                    n = this.remoteTracks.get(t);
                return Boolean(n && n.get(e.getType()) === e)
            }, D.prototype.addTrack = function(e, t = !1) {
                const n = e.rtcId;
                if (w.info(`${this} adding ${e}`), this.localTracks.has(n)) return Promise.reject(new Error(`${e} is already in ${this}`));
                if (this.localTracks.set(n, e), this._usesUnifiedPlan) try {
                    this.tpcUtils.addTrack(e, t)
                } catch (t) {
                    return w.error(`${this} Adding track=${e} failed: ${null==t?void 0:t.message}`), Promise.reject(t)
                } else {
                    const t = e.getOriginalStream();
                    if (t) this._addStream(t);
                    else if (!g.a.doesVideoMuteByStreamRemove() || e.isAudioTrack() || e.isVideoTrack() && !e.isMuted()) return Promise.reject(new Error(`${this} no WebRTC stream for track=${e}`));
                    if (g.a.doesVideoMuteByStreamRemove() && e.isVideoTrack() && e.isMuted()) {
                        const t = this.generateNewStreamSSRCInfo(e);
                        this.sdpConsistency.setPrimarySsrc(t.ssrcs[0]);
                        const n = t.groups.find(e => "SIM" === e.semantics);
                        n && this.simulcast.setSsrcCache(n.ssrcs);
                        const i = t.groups.filter(e => "FID" === e.semantics);
                        if (i) {
                            const e = new Map;
                            i.forEach(t => {
                                const n = t.ssrcs[0],
                                    i = t.ssrcs[1];
                                e.set(n, i)
                            }), this.rtxModifier.setSsrcCache(e)
                        }
                    }
                }
                let i = Promise.resolve();
                return g.a.isFirefox() && (i = i.then(() => this.tpcUtils.setEncodings(e))), i
            }, D.prototype.addTrackUnmute = function(e) {
                if (!this._assertTrackBelongs("addTrackUnmute", e)) return Promise.reject("Track not found on the peerconnection");
                w.info(`${this} Adding track=${e} as unmute`);
                const t = e.getOriginalStream();
                return t ? this._usesUnifiedPlan ? this.tpcUtils.addTrackUnmute(e) : (this._addStream(t), Promise.resolve(!0)) : (w.error(`${this} Unable to add track=${e} as unmute - no WebRTC stream`), Promise.reject("Stream not found"))
            }, D.prototype._addStream = function(e) {
                this.peerconnection.addStream(e), this._addedStreams.push(e)
            }, D.prototype._removeStream = function(e) {
                this.peerconnection.removeStream(e), this._addedStreams = this._addedStreams.filter(t => t !== e)
            }, D.prototype._assertTrackBelongs = function(e, t) {
                const n = this.localTracks.has(t.rtcId);
                return n || w.error(`${this} ${e}: track=${t} does not belong to pc`), n
            }, D.prototype.getConfiguredVideoCodec = function() {
                var e;
                const t = null === (e = this.peerconnection.localDescription) || void 0 === e ? void 0 : e.sdp,
                    n = a.VP8;
                if (!t) return n;
                const i = o.a.parse(t).media.find(e => e.type === u.c).rtp[0].codec;
                return i ? Object.values(a).find(e => e === i.toLowerCase()) : n
            }, D.prototype.setDesktopSharingFrameRate = function(e) {
                const t = e <= f.a;
                this._capScreenshareBitrate = this.isSimulcastOn() && t
            }, D.prototype.setVideoCodecs = function(e = null, t = null) {
                const n = null === t,
                    i = t || e;
                this.codecPreference && (e || t) ? (this.codecPreference.enable = n, this.codecPreference.mimeType = i) : e || t ? this.codecPreference = {
                    enable: n,
                    mediaType: u.c,
                    mimeType: i
                } : w.warn(`${this} Invalid codec settings[preferred=${e},disabled=${t}],\n            atleast one value is needed`)
            }, D.prototype.isMediaStreamInPc = function(e) {
                return this._addedStreams.indexOf(e) > -1
            }, D.prototype.removeTrack = function(e) {
                const t = e.getOriginalStream();
                this.trace("removeStream", e.rtcId, t ? t.id : void 0), this._assertTrackBelongs("removeStream", e) && (this.localTracks.delete(e.rtcId), this.localSSRCs.delete(e.rtcId), t && this.peerconnection.removeStream(t))
            }, D.prototype.findSenderByKind = function(e) {
                return this.peerconnection.getSenders().find(t => t.track && t.track.kind === e)
            }, D.prototype.findReceiverForTrack = function(e) {
                return this.peerconnection.getReceivers().find(t => t.track === e)
            }, D.prototype.findSenderForTrack = function(e) {
                return this.peerconnection.getSenders().find(t => t.track === e)
            }, D.prototype.replaceTrack = function(e, t) {
                if (this._usesUnifiedPlan) return w.debug(this + " TPC.replaceTrack using unified plan"), this.tpcUtils.replaceTrack(e, t).then(() => this.isSimulcastOn() && g.a.usesSdpMungingForSimulcast() || this.isP2P);
                w.debug(this + " TPC.replaceTrack using plan B");
                let n = Promise.resolve();
                return e && this.removeTrack(e), t && (n = this.addTrack(t)), n.then(() => !0)
            }, D.prototype.removeTrackMute = function(e) {
                const t = e.getOriginalStream();
                return this.trace("removeStreamMute", e.rtcId, t ? t.id : null), this._assertTrackBelongs("removeStreamMute", e) ? this._usesUnifiedPlan ? this.tpcUtils.removeTrackMute(e) : t ? (w.info(`${this} Removing track=${e} as mute`), this._removeStream(t), Promise.resolve(!0)) : (w.error(`${this} removeStreamMute - no WebRTC stream for track=${e}`), Promise.reject("Stream not found")) : Promise.reject("Track not found in the peerconnection")
            }, D.prototype.createDataChannel = function(e, t) {
                return this.trace("createDataChannel", e, t), this.peerconnection.createDataChannel(e, t)
            }, D.prototype._ensureSimulcastGroupIsLast = function(e) {
                let t = e.sdp;
                const n = t.indexOf("m=video"),
                    i = t.indexOf("a=ssrc-group:SIM", n);
                let s = t.lastIndexOf("a=ssrc-group");
                if (-1 === i || -1 === s || s === i) return e;
                const r = t.indexOf("\r\n", i),
                    o = t.substring(i, r + 2);
                t = t.replace(o, ""), s = t.lastIndexOf("a=ssrc-group");
                const a = t.indexOf("\r\n", s),
                    c = t.slice(0, a),
                    d = o.trim(),
                    u = t.slice(a);
                return t = `${c}\r\n${d}${u}`, new RTCSessionDescription({
                    type: e.type,
                    sdp: t
                })
            }, D.prototype._adjustLocalMediaDirection = function(e) {
                const t = new b.a(e.sdp);
                let n = !1;
                const i = t.selectMedia(u.a);
                if (i) {
                    const e = this.getDesiredMediaDirection(u.a);
                    i.direction !== e && (i.direction = e, w.info(`${this} Adjusted local audio direction to ${e}`), n = !0)
                } else w.warn(this + ' No "audio" media found in the local description');
                const s = t.selectMedia(u.c);
                if (s) {
                    const e = this.getDesiredMediaDirection(u.c);
                    s.direction !== e && (s.direction = e, w.info(`${this} Adjusted local video direction to ${e}`), n = !0)
                } else w.warn(this + ' No "video" media found in the local description');
                return n ? new RTCSessionDescription({
                    type: e.type,
                    sdp: t.toRawSDP()
                }) : e
            }, D.prototype._adjustRemoteMediaDirection = function(e) {
                const t = new b.a(e.sdp);
                return [u.a, u.c].forEach(e => {
                    const n = t.selectMedia(e),
                        i = this.hasAnyTracksOfType(e),
                        s = this.getRemoteTracks(null, e).length > 0;
                    n.direction = i && s ? d.a.SENDRECV : i ? d.a.RECVONLY : s ? d.a.SENDONLY : d.a.INACTIVE
                }), new RTCSessionDescription({
                    type: e.type,
                    sdp: t.toRawSDP()
                })
            }, D.prototype._mungeOpus = function(e) {
                const {
                    audioQuality: t
                } = this.options;
                if (!(null == t ? void 0 : t.stereo) && !(null == t ? void 0 : t.opusMaxAverageBitrate)) return e;
                const n = o.a.parse(e.sdp),
                    i = n.media;
                for (const e of i)
                    if ("audio" === e.type) {
                        const {
                            payload: n
                        } = e.rtp.find(e => e.codec === a.OPUS);
                        if (!n) continue;
                        let i = e.fmtp.find(e => e.payload === n);
                        i || (i = {
                            payload: n,
                            config: ""
                        });
                        const s = o.a.parseParams(i.config);
                        let r = !1;
                        if ((null == t ? void 0 : t.stereo) && (s.stereo = 1, r = !0), (null == t ? void 0 : t.opusMaxAverageBitrate) && (s.maxaveragebitrate = t.opusMaxAverageBitrate, r = !0), !r) continue;
                        let c = "";
                        for (const e of Object.keys(s)) c += `${e}=${s[e]}; `;
                        i.config = c.trim()
                    } return new RTCSessionDescription({
                    type: e.type,
                    sdp: o.a.write(n)
                })
            }, D.prototype.setLocalDescription = function(e) {
                let t = e;
                return this.trace("setLocalDescription::preTransform", P(t)), t = this._mungeOpus(t), this._usesUnifiedPlan ? this.isP2P || (t = this.interop.toUnifiedPlan(t), this.trace("setLocalDescription::postTransform (Unified Plan)", P(t))) : (t = this._adjustLocalMediaDirection(t), t = this._ensureSimulcastGroupIsLast(t)), this._usesTransceiverCodecPreferences || (t = this._mungeCodecOrder(t)), new Promise((e, n) => {
                    this.peerconnection.setLocalDescription(t).then(() => {
                        this.trace("setLocalDescriptionOnSuccess");
                        const n = y.a.getUfrag(t.sdp);
                        n !== this.localUfrag && (this.localUfrag = n, this.eventEmitter.emit(h.a.LOCAL_UFRAG_CHANGED, this, n)), e()
                    }, e => {
                        this.trace("setLocalDescriptionOnFailure", e), this.eventEmitter.emit(h.a.SET_LOCAL_DESCRIPTION_FAILED, e, this), n(e)
                    })
                })
            }, D.prototype.setAudioTransferActive = function(e) {
                w.debug(`${this} audio transfer active: ${e}`);
                const t = this.audioTransferActive !== e;
                return this.audioTransferActive = e, this._usesUnifiedPlan ? (this.tpcUtils.setAudioTransferActive(e), !1) : t
            }, D.prototype.setSenderVideoDegradationPreference = function() {
                if (!this.peerconnection.getSenders) return w.debug(this + " Browser does not support RTCRtpSender"), Promise.resolve();
                const e = this.getLocalVideoTrack(),
                    t = this.findSenderByKind(u.c);
                if (!t) return Promise.resolve();
                const n = t.getParameters(),
                    i = this._isSharingLowFpsScreen() ? "maintain-resolution" : "maintain-framerate";
                return w.info(`${this} Setting a degradation preference [preference=${i},track=${e}`), n.degradationPreference = i, this.tpcUtils.updateEncodingsResolution(n), t.setParameters(n)
            }, D.prototype.setMaxBitRate = function() {
                var e, t, n;
                if (this.getConfiguredVideoCodec() === a.VP9 || !window.RTCRtpSender) return Promise.resolve();
                const i = this.getLocalVideoTrack();
                if (!i) return Promise.resolve();
                const s = i.getVideoType();
                if (!((null === (e = this.options) || void 0 === e || null === (t = e.videoQuality) || void 0 === t ? void 0 : t.maxBitratesVideo) || this._isSharingLowFpsScreen() || this._usesUnifiedPlan)) return Promise.resolve();
                const r = i._originalStream && i._originalStream.id !== i.getStreamId(),
                    o = this.findSenderByKind(u.c);
                if (!o) return Promise.resolve();
                const c = o.getParameters();
                if (!(null === (n = c.encodings) || void 0 === n ? void 0 : n.length)) return Promise.resolve();
                if (this.isSimulcastOn()) {
                    for (const e in c.encodings)
                        if (c.encodings.hasOwnProperty(e)) {
                            const t = this._isSharingLowFpsScreen() ? r ? 25e5 : 5e5 : s === m.DESKTOP && g.a.isChromiumBased() ? void 0 : this.tpcUtils.localStreamEncodingsConfig[e].maxBitrate;
                            w.info(`${this} Setting a max bitrate of ${t} bps on layer ` + this.tpcUtils.localStreamEncodingsConfig[e].rid), c.encodings[e].maxBitrate = t
                        }
                } else {
                    var d;
                    let e = null === (d = this.getTargetVideoBitrates()) || void 0 === d ? void 0 : d.high;
                    if (s === m.CAMERA) {
                        const t = this.senderVideoMaxHeight ? Math.floor(i.resolution / this.senderVideoMaxHeight) : 1,
                            n = this.tpcUtils.localStreamEncodingsConfig.find(e => e.scaleResolutionDownBy === t);
                        n && (w.info(`${this} Setting max bitrate=${n.maxBitrate} bps on track=${i}`), e = n.maxBitrate)
                    }
                    c.encodings[0].maxBitrate = e
                }
                return this.tpcUtils.updateEncodingsResolution(c), o.setParameters(c)
            }, D.prototype.setRemoteDescription = function(e) {
                if (this.trace("setRemoteDescription::preTransform", P(e)), e = this._mungeOpus(e), this._usesUnifiedPlan) {
                    if (!this.isP2P) {
                        const t = this.peerconnection.remoteDescription;
                        e = this.interop.toUnifiedPlan(e, t), this.trace("setRemoteDescription::postTransform (Unified)", P(e)), this.isSimulcastOn() && (e = this.simulcast.mungeRemoteDescription(e), e = this.tpcUtils.insertUnifiedPlanSimulcastReceive(e), this.trace("setRemoteDescription::postTransform (sim receive)", P(e)))
                    }
                } else this.isSimulcastOn() && (e = this.simulcast.mungeRemoteDescription(e, !0), this.trace("setRemoteDescription::postTransform (simulcast)", P(e))), e = O(e);
                return e = this._mungeCodecOrder(e), this._usesUnifiedPlan && (e = this.tpcUtils.ensureCorrectOrderOfSsrcs(e)), new Promise((t, n) => {
                    this.peerconnection.setRemoteDescription(e).then(() => {
                        this.trace("setRemoteDescriptionOnSuccess");
                        const n = y.a.getUfrag(e.sdp);
                        n !== this.remoteUfrag && (this.remoteUfrag = n, this.eventEmitter.emit(h.a.REMOTE_UFRAG_CHANGED, this, n)), t()
                    }, e => {
                        this.trace("setRemoteDescriptionOnFailure", e), this.eventEmitter.emit(h.a.SET_REMOTE_DESCRIPTION_FAILED, e, this), n(e)
                    })
                })
            }, D.prototype.setSenderVideoConstraint = function(e = null) {
                var t;
                if (e < 0) throw new Error("Invalid frameHeight: " + e);
                if (g.a.isReactNative()) return Promise.resolve();
                const n = null === e ? this.senderVideoMaxHeight : e;
                if (this.senderVideoMaxHeight = n, null === n) return Promise.resolve();
                w.log(`${this} senderVideoMaxHeight: ${n}`);
                const i = this.getLocalVideoTrack();
                if (!i || i.isMuted()) return Promise.resolve();
                const s = this.findSenderByKind(u.c);
                if (!s) return Promise.resolve();
                const r = s.getParameters();
                if (!(null == r || null === (t = r.encodings) || void 0 === t ? void 0 : t.length)) return Promise.resolve();
                if (this.isSimulcastOn()) {
                    this.encodingsEnabledState = this.tpcUtils.getLocalStreamHeightConstraints(i.track).map(e => e <= n);
                    const e = this.tpcUtils.localStreamEncodingsConfig.findIndex(e => 4 === e.scaleResolutionDownBy);
                    if (n > 0 && -1 !== e && (this.encodingsEnabledState[e] = !0), this._isSharingLowFpsScreen() && this._usesUnifiedPlan && !g.a.isWebKitBased()) {
                        const e = g.a.isFirefox() ? 0 : this.encodingsEnabledState.length - 1;
                        this.encodingsEnabledState = this.encodingsEnabledState.map((t, n) => n === e)
                    }
                    for (const e in r.encodings) r.encodings.hasOwnProperty(e) && (r.encodings[e].active = this.encodingsEnabledState[e]);
                    this.tpcUtils.updateEncodingsResolution(r)
                } else n > 0 ? (r.encodings[0].scaleResolutionDownBy = i.videoType === m.DESKTOP || i.resolution <= n ? 1 : Math.floor(i.resolution / n), r.encodings[0].active = !0) : (r.encodings[0].scaleResolutionDownBy = void 0, r.encodings[0].active = !1);
                return w.info(`${this} setting max height=${n},encodings=${JSON.stringify(r.encodings)}`), s.setParameters(r).then(() => {
                    if (i.maxEnabledResolution = n, this.eventEmitter.emit(h.a.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED, i), this.isP2P || !this.isSimulcastOn()) return this.setMaxBitRate()
                })
            }, D.prototype.setVideoTransferActive = function(e) {
                w.debug(`${this} video transfer active: ${e}`);
                const t = this.videoTransferActive !== e;
                return this.videoTransferActive = e, this._usesUnifiedPlan ? (this.tpcUtils.setVideoTransferActive(e), !1) : t
            }, D.prototype.sendTones = function(e, t = 200, n = 200) {
                if (!this._dtmfSender) {
                    if (this.peerconnection.getSenders) {
                        const e = this.peerconnection.getSenders().find(e => e.dtmf);
                        this._dtmfSender = e && e.dtmf, this._dtmfSender && w.info(this + " initialized DTMFSender using getSenders")
                    }
                    if (!this._dtmfSender) {
                        const e = Array.from(this.localTracks.values()).find(e => e.isAudioTrack());
                        this.peerconnection.createDTMFSender && e && (this._dtmfSender = this.peerconnection.createDTMFSender(e.getTrack())), this._dtmfSender && w.info(this + " initialized DTMFSender using deprecated createDTMFSender")
                    }
                    this._dtmfSender && (this._dtmfSender.ontonechange = this._onToneChange.bind(this))
                }
                if (this._dtmfSender) {
                    if (this._dtmfSender.toneBuffer) return void this._dtmfTonesQueue.push({
                        tones: e,
                        duration: t,
                        interToneGap: n
                    });
                    this._dtmfSender.insertDTMF(e, t, n)
                } else w.warn(this + " sendTones - failed to select DTMFSender")
            }, D.prototype._onToneChange = function(e) {
                if (this._dtmfSender && "" === e.tone && this._dtmfTonesQueue.length) {
                    const {
                        tones: e,
                        duration: t,
                        interToneGap: n
                    } = this._dtmfTonesQueue.shift();
                    this._dtmfSender.insertDTMF(e, t, n)
                }
            }, D.prototype.generateRecvonlySsrc = function() {
                const e = y.a.generateSsrc();
                w.info(`${this} generated new recvonly SSRC=${e}`), this.sdpConsistency.setPrimarySsrc(e)
            }, D.prototype.clearRecvonlySsrc = function() {
                w.info(this + " Clearing primary video SSRC!"), this.sdpConsistency.clearVideoSsrcCache()
            }, D.prototype.close = function() {
                this.trace("stop"), this.signalingLayer.off(p.a, this._peerMutedChanged), this.signalingLayer.off(p.b, this._peerVideoTypeChanged), this._usesUnifiedPlan && this.peerconnection.removeEventListener("track", this.onTrack);
                for (const e of this.remoteTracks.values())
                    for (const t of e.values()) this._removeRemoteTrack(t);
                this.remoteTracks.clear(), this._addedStreams = [], this._dtmfSender = null, this._dtmfTonesQueue = [], this.rtc._removePeerConnection(this) || w.error(this + " RTC._removePeerConnection returned false"), null !== this.statsinterval && (window.clearInterval(this.statsinterval), this.statsinterval = null), w.info(this + " Closing peerconnection"), this.peerconnection.close()
            }, D.prototype.createAnswer = function(e) {
                return this._createOfferOrAnswer(!1, e)
            }, D.prototype.createOffer = function(e) {
                return this._createOfferOrAnswer(!0, e)
            }, D.prototype._createOfferOrAnswer = function(e, t) {
                const n = e ? "Offer" : "Answer";
                this.trace("create" + n, JSON.stringify(t, null, " "));
                const i = (e, t, i) => {
                        try {
                            this.trace(`create${n}OnSuccess::preTransform`, P(e)), this._usesUnifiedPlan || (this.hasAnyTracksOfType(u.c) || this.sdpConsistency.hasPrimarySsrcCached() || this.generateRecvonlySsrc(), e = new RTCSessionDescription({
                                type: e.type,
                                sdp: this.sdpConsistency.makeVideoPrimarySsrcsConsistent(e.sdp)
                            }), this.trace(`create${n}OnSuccess::postTransform (make primary audio/video ssrcs consistent)`, P(e)));
                            const i = this.getLocalVideoTrack();
                            this.isSimulcastOn() && g.a.usesSdpMungingForSimulcast() && ((null == i ? void 0 : i.getVideoType()) === m.CAMERA || this._usesUnifiedPlan || !this._isSharingLowFpsScreen()) && (e = this.simulcast.mungeLocalDescription(e), this.trace("create" + n + "OnSuccess::postTransform (simulcast)", P(e))), !this.options.disableRtx && g.a.usesSdpMungingForSimulcast() && (e = new RTCSessionDescription({
                                type: e.type,
                                sdp: this.rtxModifier.modifyRtxSsrcs(e.sdp)
                            }), this.trace("create" + n + "OnSuccess::postTransform (rtx modifier)", P(e)));
                            const s = this._extractSSRCMap(e);
                            this._processLocalSSRCsMap(s), t(e)
                        } catch (t) {
                            this.trace(`create${n}OnError`, t), this.trace(`create${n}OnError`, P(e)), w.error(`${this} create${n}OnError`, t, P(e)), i(t)
                        }
                    },
                    s = (t, i) => {
                        this.trace(`create${n}OnFailure`, t);
                        const s = e ? h.a.CREATE_OFFER_FAILED : h.a.CREATE_ANSWER_FAILED;
                        this.eventEmitter.emit(s, t, this), i(t)
                    };
                if (this._usesTransceiverCodecPreferences) {
                    const e = this.peerconnection.getTransceivers().find(e => {
                        var t, n;
                        return e.receiver && (null === (t = e.receiver) || void 0 === t || null === (n = t.track) || void 0 === n ? void 0 : n.kind) === u.c
                    });
                    if (e) {
                        var r, o, a;
                        let t = null === (r = RTCRtpReceiver.getCapabilities(u.c)) || void 0 === r ? void 0 : r.codecs;
                        const n = null === (o = this.codecPreference) || void 0 === o ? void 0 : o.mimeType,
                            i = null === (a = this.codecPreference) || void 0 === a ? void 0 : a.enable;
                        t && n && i ? t.sort(e => e.mimeType.toLowerCase() === `${u.c}/${n}` ? -1 : 1) : t && n && (t = t.filter(e => e.mimeType.toLowerCase() !== `${u.c}/${n}`));
                        try {
                            e.setCodecPreferences(t)
                        } catch (e) {
                            w.warn(`${this} Setting codec[preference=${n},enable=${i}] failed`, e)
                        }
                    }
                }
                return new Promise((n, r) => {
                    let o;
                    o = e ? this.peerconnection.createOffer(t) : this.peerconnection.createAnswer(t), o.then(e => i(e, n, r), e => s(e, r))
                })
            }, D.prototype._extractPrimarySSRC = function(e) {
                return e && e.groups && e.groups.length ? e.groups[0].ssrcs[0] : e && e.ssrcs && e.ssrcs.length ? e.ssrcs[0] : null
            }, D.prototype._processLocalSSRCsMap = function(e) {
                for (const t of this.localTracks.values()) {
                    const n = this._usesUnifiedPlan ? t.getType() : t.storedMSID;
                    if (e.has(n)) {
                        const i = e.get(n);
                        if (!i) return void w.error(`${this} No SSRC found for stream=${n}`);
                        const s = this.localSSRCs.get(t.rtcId),
                            r = this._extractPrimarySSRC(i),
                            o = this._extractPrimarySSRC(s);
                        r !== o && (o && w.error(`${this} Overwriting SSRC for track=${t}] with ssrc=${i}`), this.localSSRCs.set(t.rtcId, i), this.eventEmitter.emit(h.a.LOCAL_TRACK_SSRC_UPDATED, t, r))
                    } else t.isVideoTrack() || t.isMuted() || w.warn(`${this} No SSRCs found in the local SDP for track=${t}, stream=${n}`)
                }
            }, D.prototype.addIceCandidate = function(e) {
                return this.trace("addIceCandidate", JSON.stringify({
                    candidate: e.candidate,
                    sdpMid: e.sdpMid,
                    sdpMLineIndex: e.sdpMLineIndex,
                    usernameFragment: e.usernameFragment
                }, null, " ")), this.peerconnection.addIceCandidate(e)
            }, D.prototype.getActiveSimulcastStreams = function() {
                let e = 1;
                var t;
                this.isSimulcastOn() && this.encodingsEnabledState ? e = null === (t = this.encodingsEnabledState.filter(e => Boolean(e))) || void 0 === t ? void 0 : t.length : this.isSimulcastOn() && (e = I.a.length);
                return e
            }, D.prototype.getStats = function() {
                return this.peerconnection.getStats()
            }, D.prototype.generateNewStreamSSRCInfo = function(e) {
                const t = e.rtcId;
                let n = this._getSSRC(t);
                if (n && w.error(`${this} Overwriting local SSRCs for track id=${t}`), !this.isSimulcastOn() || e.getVideoType() !== m.CAMERA && this._isSharingLowFpsScreen()) n = {
                    ssrcs: [y.a.generateSsrc()],
                    groups: []
                };
                else {
                    n = {
                        ssrcs: [],
                        groups: []
                    };
                    for (let e = 0; e < I.a.length; e++) n.ssrcs.push(y.a.generateSsrc());
                    n.groups.push({
                        ssrcs: n.ssrcs.slice(),
                        semantics: "SIM"
                    })
                }
                if (!this.options.disableRtx) {
                    const e = n.ssrcs.length;
                    for (let t = 0; t < e; ++t) {
                        const e = n.ssrcs[t],
                            i = y.a.generateSsrc();
                        n.ssrcs.push(i), n.groups.push({
                            ssrcs: [e, i],
                            semantics: "FID"
                        })
                    }
                }
                return n.msid = e.storedMSID, this.localSSRCs.set(t, n), n
            }, D.prototype.usesUnifiedPlan = function() {
                return this._usesUnifiedPlan
            }, D.prototype.toString = function() {
                return `TPC[id=${this.id},type=${this.isP2P?"P2P":"JVB"}]`
            }
        }).call(this, "modules/RTC/TraceablePeerConnection.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var i = n(5),
                s = n(10),
                r = n.n(s),
                o = n(4),
                a = n(30);
            const c = Object(i.getLogger)(e);
            class d {
                constructor(e, t) {
                    this.tpc = e, this.localEndpointId = t
                }
                _addMutedLocalVideoTracksToSDP(e) {
                    const t = this.tpc.getLocalTracks(o.c);
                    if (!t.length) return !1;
                    1 !== t.length && c.error(this.tpc + " there is more than 1 video track ! Strange things may happen !", t);
                    const n = e.selectMedia("video");
                    if (!n) return c.debug(this.tpc + ' unable to hack local video track SDP- no "video" media'), !1;
                    let i = !1;
                    for (const e of t) {
                        const t = e.isMuted(),
                            s = e.getOriginalStream(),
                            o = s && this.tpc.isMediaStreamInPc(s);
                        if (!(t || !o)) continue;
                        const a = this.tpc.isSimulcastOn() ? this.tpc.simulcast.ssrcCache : [this.tpc.sdpConsistency.cachedPrimarySsrc];
                        if (!a.length) {
                            c.error(`No SSRCs stored for: ${e} in ${this.tpc}`);
                            continue
                        }
                        i = !0, n.direction = r.a.SENDRECV;
                        const d = "injected-" + a[0];
                        for (const t of a) n.removeSSRC(t), n.addSSRCAttribute({
                            id: t,
                            attribute: "cname",
                            value: d
                        }), n.addSSRCAttribute({
                            id: t,
                            attribute: "msid",
                            value: e.storedMSID
                        });
                        if (a.length > 1) {
                            const e = {
                                ssrcs: a.join(" "),
                                semantics: "SIM"
                            };
                            n.findGroup(e.semantics, e.ssrcs) || n.addSSRCGroup(e)
                        }
                        this.tpc.options.disableRtx || this.tpc.rtxModifier.modifyRtxSsrcs2(n)
                    }
                    return i
                }
                _generateMsidAttribute(e, t, n = null) {
                    if (!e || !t) return c.warn(`Unable to munge local MSID - track id=${t} or media type=${e} is missing`), null;
                    const i = this.tpc.id;
                    return "-" !== n && n ? `${n}-${i} ${t}-${i}` : `${this.localEndpointId}-${e}-${i} ${t}-${i}`
                }
                _transformMediaIdentifiers(e) {
                    var t;
                    const n = this.tpc.id;
                    for (const t of e.ssrcs) switch (t.attribute) {
                        case "cname":
                        case "label":
                        case "mslabel":
                            t.value = t.value && `${t.value}-${n}`;
                            break;
                        case "msid":
                            if (t.value) {
                                const n = t.value.split(" ");
                                var i;
                                if (2 === n.length) t.value = this._generateMsidAttribute(null === (i = e.mLine) || void 0 === i ? void 0 : i.type, n[1], n[0]);
                                else c.warn("Unable to munge local MSID - weird format detected: " + t.value)
                            }
                    }
                    if (!this.tpc.usesUnifiedPlan()) return;
                    const s = null === (t = e.mLine) || void 0 === t ? void 0 : t.direction;
                    if (s === r.a.RECVONLY || s === r.a.INACTIVE) e.ssrcs = void 0, e.ssrcGroups = void 0;
                    else {
                        var o, a, d;
                        const t = null === (o = e.mLine) || void 0 === o ? void 0 : o.msid,
                            n = t && t.split(" ")[1],
                            i = [...new Set(null === (a = e.mLine) || void 0 === a || null === (d = a.ssrcs) || void 0 === d ? void 0 : d.map(e => e.id))];
                        for (const t of i) {
                            if (!e.ssrcs.find(e => e.id === t && "msid" === e.attribute)) {
                                var u;
                                const i = this._generateMsidAttribute(null === (u = e.mLine) || void 0 === u ? void 0 : u.type, n);
                                e.ssrcs.push({
                                    id: t,
                                    attribute: "msid",
                                    value: i
                                })
                            }
                        }
                    }
                }
                maybeAddMutedLocalVideoTracksToSDP(e) {
                    if (!e) throw new Error("No local description passed in.");
                    const t = new a.a(e.sdp);
                    return this._addMutedLocalVideoTracksToSDP(t) ? new RTCSessionDescription({
                        type: e.type,
                        sdp: t.toRawSDP()
                    }) : e
                }
                transformStreamIdentifiers(e) {
                    if (!e || !e.sdp || !e.type) return e;
                    const t = new a.a(e.sdp),
                        n = t.selectMedia("audio");
                    n && this._transformMediaIdentifiers(n);
                    const i = t.selectMedia("video");
                    return i && this._transformMediaIdentifiers(i), new RTCSessionDescription({
                        type: e.type,
                        sdp: t.toRawSDP()
                    })
                }
            }
        }).call(this, "modules/sdp/LocalSdpMunger.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return c
            }));
            var i = n(5),
                s = n(9),
                r = n(30);
            const o = Object(i.getLogger)(e);

            function a(e, t, n) {
                const i = t.id,
                    s = t.msid,
                    r = t.cname,
                    o = e.getRtxSSRC(i);
                o !== n && (o && (e.removeSSRC(o), e.removeGroupsWithSSRC(o)), e.addSSRCAttribute({
                    id: n,
                    attribute: "cname",
                    value: r
                }), e.addSSRCAttribute({
                    id: n,
                    attribute: "msid",
                    value: s
                }), e.addSSRCGroup({
                    semantics: "FID",
                    ssrcs: `${i} ${n}`
                }))
            }
            class c {
                constructor() {
                    this.correspondingRtxSsrcs = new Map
                }
                clearSsrcCache() {
                    this.correspondingRtxSsrcs.clear()
                }
                setSsrcCache(e) {
                    o.debug("Setting ssrc cache to ", e), this.correspondingRtxSsrcs = e
                }
                modifyRtxSsrcs(e) {
                    const t = new r.a(e),
                        n = t.selectMedia("video");
                    return n ? this.modifyRtxSsrcs2(n) ? t.toRawSDP() : e : (o.debug("No 'video' media found in the sdp: " + e), e)
                }
                modifyRtxSsrcs2(e) {
                    if ("recvonly" === e.direction) return !1;
                    if (e.getSSRCCount() < 1) return !1;
                    const t = e.getPrimaryVideoSSRCs();
                    for (const n of t) {
                        const t = e.getSSRCAttrValue(n, "msid"),
                            i = e.getSSRCAttrValue(n, "cname");
                        let r = this.correspondingRtxSsrcs.get(n);
                        if (!r) {
                            const t = e.getRtxSSRC(n);
                            r = t || s.a.generateSsrc(), this.correspondingRtxSsrcs.set(n, r)
                        }
                        a(e, {
                            id: n,
                            cname: i,
                            msid: t
                        }, r)
                    }
                    return !0
                }
                stripRtx(e) {
                    const t = new r.a(e),
                        n = t.selectMedia("video");
                    if (!n) return o.debug("No 'video' media found in the sdp: " + e), e;
                    if ("recvonly" === n.direction) return o.debug("RtxModifier doing nothing, video m line is recvonly"), e;
                    if (n.getSSRCCount() < 1) return o.debug("RtxModifier doing nothing, no video ssrcs present"), e;
                    if (!n.containsAnySSRCGroups()) return o.debug("RtxModifier doing nothing, no video ssrcGroups present"), e;
                    const i = n.findGroups("FID");
                    n.removeGroupsBySemantics("FID");
                    for (const e of i) {
                        const t = Object(r.c)(e);
                        n.removeSSRC(t)
                    }
                    return t.toRawSDP()
                }
            }
        }).call(this, "modules/sdp/RtxModifier.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return o
            }));
            var i = n(5),
                s = n(30);
            const r = Object(i.getLogger)(e);
            class o {
                constructor(e) {
                    this.clearVideoSsrcCache(), this.logPrefix = e
                }
                clearVideoSsrcCache() {
                    this.cachedPrimarySsrc = null, this.injectRecvOnly = !1
                }
                setPrimarySsrc(e) {
                    if ("number" != typeof e) throw new Error("Primary SSRC must be a number!");
                    this.cachedPrimarySsrc = e
                }
                hasPrimarySsrcCached() {
                    return Boolean(this.cachedPrimarySsrc)
                }
                makeVideoPrimarySsrcsConsistent(e) {
                    const t = new s.a(e),
                        n = t.selectMedia("video");
                    if (!n) return r.debug(`${this.logPrefix} no 'video' media found in the sdp: ${e}`), e;
                    if ("recvonly" === n.direction) this.cachedPrimarySsrc && this.injectRecvOnly ? n.addSSRCAttribute({
                        id: this.cachedPrimarySsrc,
                        attribute: "cname",
                        value: "recvonly-" + this.cachedPrimarySsrc
                    }) : r.info(this.logPrefix + " no SSRC found for the recvonly video stream!");
                    else {
                        const t = n.getPrimaryVideoSsrc();
                        if (!t) return r.info(this.logPrefix + " sdp-consistency couldn't parse new primary ssrc"), e;
                        if (this.cachedPrimarySsrc) {
                            n.replaceSSRC(t, this.cachedPrimarySsrc);
                            for (const e of n.ssrcGroups)
                                if ("FID" === e.semantics) {
                                    const n = Object(s.b)(e),
                                        i = Object(s.c)(e);
                                    n === t && (e.ssrcs = `${this.cachedPrimarySsrc} ${i}`)
                                }
                        } else this.cachedPrimarySsrc = t;
                        this.injectRecvOnly = !0
                    }
                    return t.toRawSDP()
                }
            }
        }).call(this, "modules/sdp/SdpConsistency.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return h
            }));
            var i = n(16),
                s = n(8),
                r = n(6),
                o = n(65);
            const a = n(5).getLogger(e),
                c = n(7);
            let d = !1,
                u = !1;
            const l = ["abort", "canplay", "canplaythrough", "emptied", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "ratechange", "stalled", "suspend", "waiting"];
            class h extends o.a {
                constructor(e, t, n, i, s, r, o, c, d, u) {
                    if (super(t, i, s, () => {}, r, o), this.rtc = e, "number" != typeof c) throw new TypeError(`SSRC ${c} is not a number`);
                    this.ssrc = c, this.ownerEndpointId = n, this.muted = d, this.isP2P = u, a.debug("New remote track added: " + this), this.hasBeenMuted = d, this.rtc && this.track && this._bindTrackHandlers(), this._containerHandlers = {}, l.forEach(e => {
                        this._containerHandlers[e] = this._containerEventHandler.bind(this, e)
                    })
                }
                _bindTrackHandlers() {
                    this.track.addEventListener("mute", () => this._onTrackMute()), this.track.addEventListener("unmute", () => this._onTrackUnmute()), this.track.addEventListener("ended", () => {
                        a.debug(`"onended" event(${Date.now()}): ${this}`)
                    })
                }
                _onTrackMute() {
                    a.debug(`"onmute" event(${Date.now()}): ${this}`), this.rtc.eventEmitter.emit(c.REMOTE_TRACK_MUTE, this)
                }
                _onTrackUnmute() {
                    a.debug(`"onunmute" event(${Date.now()}): ${this}`), this.rtc.eventEmitter.emit(c.REMOTE_TRACK_UNMUTE, this)
                }
                setMute(e) {
                    this.muted !== e && (e && (this.hasBeenMuted = !0), this.stream && (this.stream.muted = e), this.muted = e, this.emit(i.TRACK_MUTE_CHANGED, this))
                }
                isMuted() {
                    return this.muted
                }
                getParticipantId() {
                    return this.ownerEndpointId
                }
                isLocal() {
                    return !1
                }
                getSSRC() {
                    return this.ssrc
                }
                _setVideoType(e) {
                    this.videoType !== e && (this.videoType = e, this.emit(i.TRACK_VIDEOTYPE_CHANGED, e))
                }
                _playCallback() {
                    const e = this.isVideoTrack() ? "video" : "audio",
                        t = window.performance.now();
                    console.log(`(TIME) Render ${e}:\t`, t), this.conference.getConnectionTimes()[e + ".render"] = t;
                    const n = window.connectionTimes["obtainPermissions.start"],
                        i = window.connectionTimes["obtainPermissions.end"],
                        o = isNaN(i) || isNaN(n) ? 0 : i - n,
                        a = t - (this.conference.getConnectionTimes()["session.initiate"] - this.conference.getConnectionTimes()["muc.joined"]) - o;
                    this.conference.getConnectionTimes()[e + ".ttfm"] = a, console.log(`(TIME) TTFM ${e}:\t`, a), r.a.sendAnalytics(Object(s.N)({
                        media_type: e,
                        muted: this.hasBeenMuted,
                        value: a
                    }))
                }
                _attachTTFMTracker(e) {
                    d && this.isAudioTrack() || u && this.isVideoTrack() || (this.isAudioTrack() && (d = !0), this.isVideoTrack() && (u = !0), e.addEventListener("canplay", this._playCallback.bind(this)))
                }
                _onTrackAttach(e) {
                    a.debug("Track has been attached to a container: " + this), l.forEach(t => {
                        e.addEventListener(t, this._containerHandlers[t])
                    })
                }
                _onTrackDetach(e) {
                    a.debug("Track has been detached from a container: " + this), l.forEach(t => {
                        e.removeEventListener(t, this._containerHandlers[t])
                    })
                }
                _containerEventHandler(e) {
                    a.debug(`${e} handler was called for a container with attached ${this}`)
                }
                _getStatus() {
                    const {
                        enabled: e,
                        muted: t,
                        readyState: n
                    } = this.track;
                    return `readyState: ${n}, muted: ${t}, enabled: ${e}`
                }
                toString() {
                    return `RemoteTrack[userID: ${this.getParticipantId()}, type: ${this.getType()}, ssrc: ${this.getSSRC()}, p2p: ${this.isP2P}, status: ${this._getStatus()}]`
                }
            }
        }).call(this, "modules/RTC/JitsiRemoteTrack.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return _
            }));
            var i = n(5),
                s = n(1),
                r = n(20),
                o = n.n(r),
                a = n(7),
                c = n(32),
                d = n(3);
            const u = n(66),
                l = n(14),
                h = n(0),
                p = Object(i.getLogger)(e),
                m = [{
                    width: 1920,
                    height: 1080,
                    layers: 3,
                    target: "high",
                    targetRN: 4e6
                }, {
                    width: 1280,
                    height: 720,
                    layers: 3,
                    target: "high",
                    targetRN: 25e5
                }, {
                    width: 960,
                    height: 540,
                    layers: 3,
                    target: "standard",
                    targetRN: 9e5
                }, {
                    width: 640,
                    height: 360,
                    layers: 2,
                    target: "standard",
                    targetRN: 5e5
                }, {
                    width: 480,
                    height: 270,
                    layers: 2,
                    target: "low",
                    targetRN: 35e4
                }, {
                    width: 320,
                    height: 180,
                    layers: 1,
                    target: "low",
                    targetRN: 15e4
                }];
            let f = 800;

            function g(e, t, n, i) {
                if (n < 15e3) return 1;
                let s = 0,
                    r = Math.min(t.height, t.width),
                    a = m.find(e => e.height <= r);
                if (a && e && i.codec === o.a.VP8)
                    for (r = a.height; r >= 180; r /= 2) {
                        const e = r;
                        if (a = m.find(t => t.height === e), !a) break;
                        s += d.a.isReactNative() ? a.targetRN : i[a.target]
                    } else a && (s = d.a.isReactNative() ? a.targetRN : i[a.target]);
                return Math.min(s / 1e3, function(e) {
                    if (e > 6e4) return Number.MAX_SAFE_INTEGER;
                    return f * Math.pow(1.08, e / 1e3)
                }(Math.max(0, n - 1e3)))
            }
            class _ {
                constructor(e, t, n) {
                    this.eventEmitter = t, this._conference = e, this._localStats = {
                        connectionQuality: 100,
                        jvbRTT: void 0
                    }, this._lastConnectionQualityUpdate = -1, this._remoteStats = {}, this._timeIceConnected = -1, this._timeVideoUnmuted = -1, n.config.startBitrate && n.config.startBitrate > 0 && (f = n.config.startBitrate), e.on(s.CONNECTION_INTERRUPTED, () => {
                        this._updateLocalConnectionQuality(0), this.eventEmitter.emit(c.LOCAL_STATS_UPDATED, this._localStats), this._broadcastLocalStats()
                    }), e.room.addListener(h.ICE_CONNECTION_STATE_CHANGED, (e, t) => {
                        e.isP2P || "connected" !== t || (this._timeIceConnected = window.performance.now())
                    }), e.on(s.ENDPOINT_MESSAGE_RECEIVED, (e, t) => {
                        "stats" === t.type && this._updateRemoteStats(e.getId(), t.values)
                    }), e.on(s.ENDPOINT_STATS_RECEIVED, (e, t) => {
                        this._updateRemoteStats(e.getId(), t)
                    }), e.statistics.addConnectionStatsListener(this._updateLocalStats.bind(this)), e.on(s.TRACK_MUTE_CHANGED, e => {
                        e.isVideoTrack() && (e.isMuted() ? this._timeVideoUnmuted = -1 : this._maybeUpdateUnmuteTime())
                    }), e.on(s.TRACK_ADDED, e => {
                        e.isVideoTrack() && !e.isMuted() && this._maybeUpdateUnmuteTime()
                    }), e.rtc.on(a.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED, e => {
                        this._localStats.maxEnabledResolution = e.maxEnabledResolution
                    }), e.on(s.SERVER_REGION_CHANGED, e => {
                        this._localStats.serverRegion = e
                    }), e.on(s.PROPERTIES_CHANGED, e => {
                        this._localStats.bridgeCount = Number((e || {})["bridge-count"])
                    })
                }
                _maybeUpdateUnmuteTime() {
                    this._timeVideoUnmuted < 0 && (this._timeVideoUnmuted = window.performance.now())
                }
                _calculateConnectionQuality(e, t, n) {
                    const i = u[n];
                    let s, r = 100;
                    if (this._localStats.packetLoss && (s = this._localStats.packetLoss.upload, t && (s *= .5)), t || !i || e === l.DESKTOP || this._timeIceConnected < 0 || this._timeVideoUnmuted < 0) void 0 === s ? (p.error("Cannot calculate connection quality, unknown packet loss."), r = 100) : r = s <= 2 ? 100 : s <= 4 ? 70 : s <= 6 ? 50 : s <= 8 ? 30 : s <= 12 ? 10 : 0;
                    else {
                        const e = this._conference.getActivePeerConnection();
                        if (e) {
                            const t = e.isSimulcastOn(),
                                n = e.getTargetVideoBitrates();
                            n.codec = e.getConfiguredVideoCodec();
                            let s = g(t, i, window.performance.now() - Math.max(this._timeVideoUnmuted, this._timeIceConnected), n);
                            s = Math.min(s, 2500), r = 100 * this._localStats.bitrate.upload / s
                        }
                        s && s >= 10 && (r = Math.min(r, 30))
                    }
                    if (this._lastConnectionQualityUpdate > 0) {
                        const e = 2,
                            t = this._localStats.connectionQuality,
                            n = (window.performance.now() - this._lastConnectionQualityUpdate) / 1e3;
                        r = Math.min(r, t + n * e)
                    }
                    return Math.min(100, r)
                }
                _updateLocalConnectionQuality(e) {
                    this._localStats.connectionQuality = e, this._lastConnectionQualityUpdate = window.performance.now()
                }
                _broadcastLocalStats() {
                    const e = {
                        bitrate: this._localStats.bitrate,
                        packetLoss: this._localStats.packetLoss,
                        connectionQuality: this._localStats.connectionQuality,
                        jvbRTT: this._localStats.jvbRTT,
                        serverRegion: this._localStats.serverRegion,
                        maxEnabledResolution: this._localStats.maxEnabledResolution,
                        avgAudioLevels: this._localStats.localAvgAudioLevels
                    };
                    try {
                        this._conference.sendEndpointStatsMessage(e)
                    } catch (e) {}
                }
                _updateLocalStats(e, t) {
                    if (!e.isP2P) {
                        const e = t.transport && t.transport.length && t.transport[0].rtt;
                        this._localStats.jvbRTT = e || void 0
                    }
                    if (e !== this._conference.getActivePeerConnection()) return;
                    let n;
                    const i = !this._conference.isConnectionInterrupted(),
                        s = this._conference.getLocalVideoTrack(),
                        r = s ? s.videoType : void 0,
                        o = !s || s.isMuted(),
                        a = s ? Math.min(s.resolution, s.maxEnabledResolution) : null;
                    for (n in o || this._maybeUpdateUnmuteTime(), t) t.hasOwnProperty(n) && (this._localStats[n] = t[n]);
                    i && this._updateLocalConnectionQuality(this._calculateConnectionQuality(r, o, a)), this.eventEmitter.emit(c.LOCAL_STATS_UPDATED, this._localStats), this._broadcastLocalStats()
                }
                _updateRemoteStats(e, t) {
                    this._remoteStats[e] = {
                        bitrate: t.bitrate,
                        packetLoss: t.packetLoss,
                        connectionQuality: t.connectionQuality,
                        jvbRTT: t.jvbRTT,
                        serverRegion: t.serverRegion,
                        maxEnabledResolution: t.maxEnabledResolution,
                        avgAudioLevels: t.avgAudioLevels
                    }, this.eventEmitter.emit(c.REMOTE_STATS_UPDATED, e, this._remoteStats[e])
                }
                getStats() {
                    return this._localStats
                }
            }
        }).call(this, "modules/connectivity/ConnectionQuality.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return a
            }));
            var i = n(5),
                s = n(17),
                r = n(1);
            const o = Object(i.getLogger)(e);
            class a {
                constructor(e) {
                    this._conference = e
                }
                _actOnIceFailed() {
                    const {
                        enableForcedReload: e,
                        enableIceRestart: t
                    } = this._conference.options.config, n = void 0 !== t && !t, i = this._conference.room.supportsRestartByTerminate(), a = i && !t, c = this._conference.restartInProgress && e;
                    if (o.info(`ICE failed, enableForcedReload: ${e}, enableIceRestart: ${t}, restartInProgress: ${this._conference.restartInProgress}, supports restart by terminate: ` + i), n || !t && !i || c) return o.info("ICE failed, but ICE restarts are disabled"), void this._conference.eventEmitter.emit(r.CONFERENCE_FAILED, s.ICE_FAILED);
                    const d = this._conference.jvbJingleSession,
                        u = d && d.getIceConnectionState();
                    d ? "connected" === u ? o.info("ICE connection restored - not sending ICE failed") : (o.info(`Sending ICE failed - the connection did not recover, ICE state: ${u}, use 'session-terminate': ` + a), a ? this._conference.jvbJingleSession.terminate(() => {
                        o.info("session-terminate for ice restart - done")
                    }, e => {
                        o.error("session-terminate for ice restart - error: " + e.message)
                    }, {
                        reason: "connectivity-error",
                        reasonDescription: "ICE FAILED",
                        requestRestart: !0,
                        sendSessionTerminate: !0
                    }) : this._conference.jvbJingleSession.sendIceFailedNotification()) : o.warn("Not sending ICE failed - no JVB connection")
                }
                start() {
                    this._conference.xmpp.ping(65e3).then(() => {
                        this._canceled || (this._iceFailedTimeout = window.setTimeout(() => {
                            this._iceFailedTimeout = void 0, this._actOnIceFailed()
                        }, 2e3))
                    }, e => {
                        o.error("PING error/timeout - not sending ICE failed", e)
                    })
                }
                cancel() {
                    this._canceled = !0, window.clearTimeout(this._iceFailedTimeout)
                }
            }
        }).call(this, "modules/connectivity/IceFailedHandling.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return d
        }));
        var i = n(19),
            s = n.n(i),
            r = n(1),
            o = n(16),
            a = n(3),
            c = n(24);
        class d extends s.a {
            constructor(e) {
                super(), this._conference = e, this._timeoutTrigger = null, this._hasAudioInput = null, a.a.supportsReceiverStats() || e.statistics.addAudioLevelListener(this._audioLevel.bind(this)), e.on(r.TRACK_ADDED, this._trackAdded.bind(this))
            }
            _clearTriggerTimeout() {
                clearTimeout(this._timeoutTrigger), this._timeoutTrigger = null
            }
            _handleAudioInputStateChange(e) {
                const t = 0 !== e;
                null !== this._hasAudioInput && this._hasAudioInput === t || (this._hasAudioInput = t, this.emit(c.AUDIO_INPUT_STATE_CHANGE, this._hasAudioInput))
            }
            _handleNoAudioInputDetection(e) {
                this._eventFired || (0 !== e || this._timeoutTrigger ? 0 !== e && this._timeoutTrigger && this._clearTriggerTimeout() : this._timeoutTrigger = setTimeout(() => {
                    this._eventFired = !0, this.emit(c.NO_AUDIO_INPUT)
                }, 4e3))
            }
            _audioLevel(e, t, n, i) {
                if (!i || !this._audioTrack) return;
                const s = e.localSSRCs.get(this._audioTrack.rtcId);
                s && s.ssrcs.includes(t) && (this._handleAudioInputStateChange(n), this._handleNoAudioInputDetection(n))
            }
            _trackAdded(e) {
                e.isLocalAudioTrack() && (this._audioTrack = e, this._eventFired = !1, this._clearTriggerTimeout(), a.a.supportsReceiverStats() && (e.on(o.NO_AUDIO_INPUT, e => {
                    this._handleNoAudioInputDetection(e)
                }), e.on(o.TRACK_AUDIO_LEVEL_CHANGED, e => {
                    this._handleNoAudioInputDetection(e), this._handleAudioInputStateChange(e)
                })))
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return o
        }));
        var i = n(1),
            s = n(7),
            r = n.n(s);
        class o {
            constructor(e) {
                this.conference = e, e.addEventListener(i.TRACK_AUDIO_LEVEL_CHANGED, this._audioLevel.bind(this)), this.myUserID = this.conference.myUserId()
            }
            _audioLevel(e, t) {
                !this.conference.isP2PActive() || t <= .6 || e === this.myUserID && this.conference.getLocalAudioTrack().isMuted() || this.conference.rtc.eventEmitter.emit(r.a.DOMINANT_SPEAKER_CHANGED, e)
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return o
        }));
        var i = n(19),
            s = n(31),
            r = n(24);
        class o extends i.EventEmitter {
            constructor() {
                super(), this._processing = !1, this._scoreArray = [], this._audioLvlArray = [], this._active = !1, this._calculateNoisyScore = this._calculateNoisyScore.bind(this)
            }
            _calculateNoisyScore() {
                const e = Object(s.b)(this._scoreArray),
                    t = Object(s.b)(this._audioLvlArray);
                e < .2 && t > .04 && (this.emit(r.VAD_NOISY_DEVICE), this._setActiveState(!1)), this.reset()
            }
            _recordValues(e, t) {
                this._scoreArray.push(e), this._audioLvlArray.push(t)
            }
            _setActiveState(e) {
                this._active = e, this.emit(r.DETECTOR_STATE_CHANGE, this._active)
            }
            changeMuteState(e) {
                this._setActiveState(!e), this.reset()
            }
            isActive() {
                return this._active
            }
            reset() {
                this._processing = !1, this._scoreArray = [], this._audioLvlArray = [], clearTimeout(this._processTimeout)
            }
            processVADScore(e) {
                if (this._active)
                    if (this._processing) {
                        const t = Object(s.c)(e.pcmData);
                        this._recordValues(e.score, Object(s.b)(t))
                    } else if (e.score < .2) {
                    const t = Object(s.c)(e.pcmData),
                        n = Object(s.b)(t);
                    n > .02 && (this._processing = !0, this._recordValues(e.score, n), this._processTimeout = setTimeout(this._calculateNoisyScore, 1500))
                }
            }
        }
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return o
        }));
        var i = n(19),
            s = n(31),
            r = n(24);
        class o extends i.EventEmitter {
            constructor() {
                super(), this._processing = !1, this._scoreArray = [], this._active = !1, this._calculateVADScore = this._calculateVADScore.bind(this)
            }
            _calculateVADScore() {
                Object(s.b)(this._scoreArray) > .6 && (this.emit(r.VAD_TALK_WHILE_MUTED), this._setActiveState(!1)), this.reset()
            }
            _setActiveState(e) {
                this._active = e, this.emit(r.DETECTOR_STATE_CHANGE, this._active)
            }
            changeMuteState(e) {
                this._setActiveState(e), this.reset()
            }
            isActive() {
                return this._active
            }
            processVADScore(e) {
                this._active && (this._processing ? this._scoreArray.push(e.score) : e.score > .9 && (this._processing = !0, this._scoreArray.push(e.score), this._processTimeout = setTimeout(this._calculateVADScore, 700)))
            }
            reset() {
                this._processing = !1, this._scoreArray = [], clearTimeout(this._processTimeout)
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return u
            }));
            var i = n(5),
                s = n(1),
                r = n(69),
                o = n(8),
                a = n(6);
            const c = Object(i.getLogger)(e);
            class d {
                constructor(e, t) {
                    this.participant = e, this.e2eping = t, this.id = e.getId(), this.requests = {}, this.lastRequestId = 1, this.clearIntervals = this.clearIntervals.bind(this), this.sendRequest = this.sendRequest.bind(this), this.handleResponse = this.handleResponse.bind(this), this.maybeSendAnalytics = this.maybeSendAnalytics.bind(this), this.sendAnalytics = this.sendAnalytics.bind(this), t.isDataChannelOpen && this.sendRequest(), this.pingInterval = window.setInterval(this.sendRequest, t.pingIntervalMs), this.analyticsInterval = window.setTimeout(this.maybeSendAnalytics, this.e2eping.analyticsIntervalMs)
                }
                clearIntervals() {
                    this.pingInterval && window.clearInterval(this.pingInterval), this.analyticsInterval && window.clearInterval(this.analyticsInterval)
                }
                sendRequest() {
                    const e = this.lastRequestId++,
                        t = {
                            type: "e2e-ping-request",
                            id: e
                        };
                    this.e2eping.sendMessage(t, this.id), this.requests[e] = {
                        id: e,
                        timeSent: window.performance.now()
                    }
                }
                handleResponse(e) {
                    const t = this.requests[e.id];
                    t && (t.rtt = window.performance.now() - t.timeSent, this.e2eping.eventEmitter.emit(r.E2E_RTT_CHANGED, this.participant, t.rtt)), this.maybeSendAnalytics()
                }
                maybeSendAnalytics() {
                    const e = window.performance.now();
                    let t, n, i = 1 / 0;
                    for (n in this.requests) this.requests.hasOwnProperty(n) && (t = this.requests[n], t.timeSent < e - this.e2eping.analyticsIntervalMs ? delete this.requests[n] : t.rtt && (i = Math.min(i, t.rtt)));
                    i < 1 / 0 && this.sendAnalytics(i)
                }
                sendAnalytics(e) {
                    a.a.sendAnalytics(Object(o.D)(this.id, this.participant.getProperty("region"), e))
                }
            }
            class u {
                constructor(e, t, n) {
                    this.conference = e, this.eventEmitter = e.eventEmitter, this.sendMessage = n, this.pingIntervalMs = 1e4, this.analyticsIntervalMs = 6e4, this.participants = {}, this.isDataChannelOpen = !1, t && t.e2eping && ("number" == typeof t.e2eping.pingInterval && (this.pingIntervalMs = t.e2eping.pingInterval), "number" == typeof t.e2eping.analyticsInterval && (this.analyticsIntervalMs = t.e2eping.analyticsInterval), this.analyticsIntervalMs > 0 && this.analyticsIntervalMs < this.pingIntervalMs && (this.analyticsIntervalMs = this.pingIntervalMs)), c.info(`Initializing e2e ping; pingInterval=${this.pingIntervalMs}, analyticsInterval=${this.analyticsIntervalMs}.`), this.participantJoined = this.participantJoined.bind(this), e.on(s.USER_JOINED, this.participantJoined), this.participantLeft = this.participantLeft.bind(this), e.on(s.USER_LEFT, this.participantLeft), this.messageReceived = this.messageReceived.bind(this), e.on(s.ENDPOINT_MESSAGE_RECEIVED, this.messageReceived), this.dataChannelOpened = this.dataChannelOpened.bind(this), e.on(s.DATA_CHANNEL_OPENED, this.dataChannelOpened)
                }
                dataChannelOpened() {
                    this.isDataChannelOpen = !0;
                    for (const e in this.participants)
                        if (this.participants.hasOwnProperty(e)) {
                            const t = this.participants[e];
                            window.setTimeout(t.sendRequest, 200)
                        }
                }
                messageReceived(e, t) {
                    "e2e-ping-request" === t.type ? this.handleRequest(e.getId(), t) : "e2e-ping-response" === t.type && this.handleResponse(e.getId(), t)
                }
                participantJoined(e, t) {
                    this.pingIntervalMs <= 0 || (this.participants[e] && (c.info(`Participant wrapper already exists for ${e}. Clearing.`), this.participants[e].clearIntervals(), delete this.participants[e]), this.participants[e] = new d(t, this))
                }
                participantLeft(e) {
                    this.pingIntervalMs <= 0 || this.participants[e] && (this.participants[e].clearIntervals(), delete this.participants[e])
                }
                handleRequest(e, t) {
                    if (t && t.id) {
                        const n = {
                            type: "e2e-ping-response",
                            id: t.id
                        };
                        this.sendMessage(n, e)
                    } else c.info(`Received an invalid e2e ping request from ${e}.`)
                }
                handleResponse(e, t) {
                    const n = this.participants[e];
                    n && n.handleResponse(t)
                }
                stop() {
                    c.info("Stopping e2eping"), this.conference.off(s.USER_JOINED, this.participantJoined), this.conference.off(s.USER_LEFT, this.participantLeft), this.conference.off(s.ENDPOINT_MESSAGE_RECEIVED, this.messageReceived), this.conference.off(s.DATA_CHANNEL_OPENED, this.dataChannelOpened);
                    for (const e in this.participants) this.participants.hasOwnProperty(e) && this.participants[e].clearIntervals();
                    this.participants = {}
                }
            }
        }).call(this, "modules/e2eping/e2eping.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return o
            }));
            var i = n(5),
                s = n(1);
            const r = Object(i.getLogger)(e);
            class o {
                constructor(e) {
                    this._conference = e, this._jvb121 = !0, this._conference.addEventListener(s.USER_JOINED, () => this.evaluateStatus()), this._conference.addEventListener(s.USER_LEFT, () => this.evaluateStatus()), this._conference.addEventListener(s.P2P_STATUS, () => this.evaluateStatus())
                }
                evaluateStatus() {
                    const e = this._jvb121,
                        t = !this._conference.isP2PActive() && this._conference.getParticipantCount() <= 2;
                    e !== t && (this._jvb121 = t, r.debug(`JVB121 status ${e} => ${t}`), this._conference.eventEmitter.emit(s.JVB121_STATUS, e, t))
                }
            }
        }).call(this, "modules/event/Jvb121EventGenerator.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var i = n(5),
                s = n(33),
                r = n.n(s),
                o = n(1);
            const a = Object(i.getLogger)(e);
            class c {
                constructor() {
                    this._defaultConstraints = {
                        maxHeight: 180
                    }, this._lastN = -1, this._maxFrameHeight = 2160, this._selectedEndpoints = [], this._receiverVideoConstraints = {
                        constraints: {},
                        defaultConstraints: this.defaultConstraints,
                        lastN: this._lastN,
                        onStageEndpoints: [],
                        selectedEndpoints: this._selectedEndpoints
                    }
                }
                get constraints() {
                    return this._receiverVideoConstraints.lastN = this._lastN, this._selectedEndpoints.length ? (this._receiverVideoConstraints.constraints = {}, this._selectedEndpoints.length > 1 ? (this._receiverVideoConstraints.defaultConstraints = {
                        maxHeight: this._maxFrameHeight
                    }, this._receiverVideoConstraints.onStageEndpoints = [], this._receiverVideoConstraints.selectedEndpoints = []) : (this._receiverVideoConstraints.constraints[this._selectedEndpoints[0]] = {
                        maxHeight: this._maxFrameHeight
                    }, this._receiverVideoConstraints.defaultConstraints = this._defaultConstraints, this._receiverVideoConstraints.onStageEndpoints = this._selectedEndpoints, this._receiverVideoConstraints.selectedEndpoints = []), this._receiverVideoConstraints) : this._receiverVideoConstraints
                }
                updateLastN(e) {
                    const t = this._lastN !== e;
                    return t && (this._lastN = e, a.debug(`Updating ReceiverVideoConstraints lastN(${e})`)), t
                }
                updateReceiveResolution(e) {
                    const t = this._maxFrameHeight !== e;
                    return t && (this._maxFrameHeight = e, a.debug("Updating receive maxFrameHeight: " + e)), t
                }
                updateReceiverVideoConstraints(e) {
                    const t = !r()(this._receiverVideoConstraints, e);
                    return t && (this._receiverVideoConstraints = e, a.debug("Updating ReceiverVideoConstraints " + JSON.stringify(e))), t
                }
                updateSelectedEndpoints(e) {
                    a.debug("Updating selected endpoints: " + JSON.stringify(e)), this._selectedEndpoints = e
                }
            }
            class d {
                constructor(e, t) {
                    var n, i;
                    this._conference = e, this._rtc = t;
                    const {
                        config: s
                    } = e.options;
                    this._lastN = null !== (n = null == s ? void 0 : s.startLastN) && void 0 !== n ? n : (null == s ? void 0 : s.channelLastN) || -1, this._maxFrameHeight = 2160;
                    if (null === (i = null == s ? void 0 : s.useNewBandwidthAllocationStrategy) || void 0 === i || i) {
                        this._receiverVideoConstraints = new c;
                        this._receiverVideoConstraints.updateLastN(this._lastN) && this._rtc.setNewReceiverVideoConstraints(this._receiverVideoConstraints.constraints)
                    } else this._rtc.setLastN(this._lastN);
                    this._selectedEndpoints = [], this._conference.on(o._MEDIA_SESSION_STARTED, e => this._onMediaSessionStarted(e))
                }
                _onMediaSessionStarted(e) {
                    e.isP2P || !this._receiverVideoConstraints ? e.setReceiverVideoConstraint(this._maxFrameHeight) : (this._receiverVideoConstraints.updateReceiveResolution(this._maxFrameHeight), this._rtc.setNewReceiverVideoConstraints(this._receiverVideoConstraints.constraints))
                }
                getLastN() {
                    return this._lastN
                }
                selectEndpoints(e) {
                    if (this._selectedEndpoints = e, this._receiverVideoConstraints) {
                        const t = e.filter(e => e !== this._conference.myUserId()),
                            n = JSON.parse(JSON.stringify(this._receiverVideoConstraints.constraints));
                        t.length && this._receiverVideoConstraints.updateSelectedEndpoints(t);
                        const i = this._receiverVideoConstraints.constraints;
                        r()(i, n) || this._rtc.setNewReceiverVideoConstraints(i)
                    } else this._rtc.selectEndpoints(e)
                }
                setLastN(e) {
                    if (this._lastN !== e) {
                        if (this._lastN = e, this._receiverVideoConstraints) {
                            return void(this._receiverVideoConstraints.updateLastN(e) && this._rtc.setNewReceiverVideoConstraints(this._receiverVideoConstraints.constraints))
                        }
                        this._rtc.setLastN(e)
                    }
                }
                setPreferredReceiveMaxFrameHeight(e) {
                    this._maxFrameHeight = e;
                    for (const t of this._conference._getMediaSessions())
                        if (t.isP2P || !this._receiverVideoConstraints) e && t.setReceiverVideoConstraint(e);
                        else {
                            this._receiverVideoConstraints.updateReceiveResolution(e) && this._rtc.setNewReceiverVideoConstraints(this._receiverVideoConstraints.constraints)
                        }
                }
                setReceiverConstraints(e) {
                    this._receiverVideoConstraints || (this._receiverVideoConstraints = new c);
                    if (this._receiverVideoConstraints.updateReceiverVideoConstraints(e)) {
                        var t, n;
                        this._lastN = null !== (t = e.lastN) && void 0 !== t ? t : this._lastN, this._selectedEndpoints = null !== (n = e.selectedEndpoints) && void 0 !== n ? n : this._selectedEndpoints, this._rtc.setNewReceiverVideoConstraints(e);
                        const r = this._conference._getMediaSessions().find(e => e.isP2P);
                        if (r) {
                            var i;
                            let t = null === (i = Object.values(e.constraints)[0]) || void 0 === i ? void 0 : i.maxHeight;
                            var s;
                            if (!t) t = null === (s = e.defaultConstraints) || void 0 === s ? void 0 : s.maxHeight;
                            t && r.setReceiverVideoConstraint(t)
                        }
                    }
                }
            }
        }).call(this, "modules/qualitycontrol/ReceiveVideoController.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return a
        }));
        var i = n(1),
            s = n(7),
            r = n.n(s),
            o = n(64);
        class a {
            constructor(e, t) {
                var n, s;
                this.conference = e, this.layerSuspensionEnabled = null === (n = e.options) || void 0 === n || null === (s = n.config) || void 0 === s ? void 0 : s.enableLayerSuspension, this.rtc = t, this.conference.on(i._MEDIA_SESSION_STARTED, e => this._onMediaSessionStarted(e)), this.conference.on(i._MEDIA_SESSION_ACTIVE_CHANGED, () => this._propagateSendMaxFrameHeight()), this.rtc.on(r.a.SENDER_VIDEO_CONSTRAINTS_CHANGED, e => {
                    var t;
                    (null === (t = this._senderVideoConstraints) || void 0 === t ? void 0 : t.idealHeight) !== e.idealHeight && (this._senderVideoConstraints = e, this._propagateSendMaxFrameHeight())
                })
            }
            _onMediaSessionStarted(e) {
                e.addListener(o.a.REMOTE_VIDEO_CONSTRAINTS_CHANGED, e => {
                    e === this.conference._getActiveMediaSession() && this._propagateSendMaxFrameHeight()
                }), e.setSenderVideoDegradationPreference(), e.setSenderMaxBitrates()
            }
            _propagateSendMaxFrameHeight() {
                const e = this.selectSendMaxFrameHeight(),
                    t = [];
                if (e >= 0)
                    for (const n of this.conference._getMediaSessions()) t.push(n.setSenderVideoConstraint(e));
                return Promise.all(t)
            }
            selectSendMaxFrameHeight() {
                var e;
                const t = this.conference._getActiveMediaSession(),
                    n = t ? t.isP2P ? t.getRemoteRecvMaxFrameHeight() : this.layerSuspensionEnabled ? null === (e = this._senderVideoConstraints) || void 0 === e ? void 0 : e.idealHeight : void 0 : void 0;
                return this.preferredSendMaxFrameHeight >= 0 && n >= 0 ? Math.min(this.preferredSendMaxFrameHeight, n) : n >= 0 ? n : this.preferredSendMaxFrameHeight
            }
            setPreferredSendMaxFrameHeight(e) {
                return this.preferredSendMaxFrameHeight = e, this._propagateSendMaxFrameHeight()
            }
        }
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            var i = n(5),
                s = n(0),
                r = n.n(s),
                o = n(78),
                a = n(53);

            function c(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const d = Object(i.getLogger)(e);
            t.a = class {
                constructor(e) {
                    this._sessions = {}, this._chatRoom = e, this.onPresence = this.onPresence.bind(this), this._chatRoom.eventEmitter.addListener(r.a.PRESENCE_RECEIVED, this.onPresence)
                }
                getSession(e) {
                    return this._sessions[e]
                }
                onPresence({
                    fromHiddenDomain: e,
                    presence: t
                }) {
                    a.a.isFromFocus(t) ? this._handleFocusPresence(t) : e && this._handleJibriPresence(t)
                }
                startRecording(e) {
                    const t = new o.a(function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? Object(arguments[t]) : {},
                                i = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), i.forEach((function(t) {
                                c(e, t, n[t])
                            }))
                        }
                        return e
                    }({}, e, {
                        connection: this._chatRoom.connection
                    }));
                    return t.start({
                        appData: e.appData,
                        broadcastId: e.broadcastId,
                        focusMucJid: this._chatRoom.focusMucJid,
                        streamId: e.streamId
                    }).then(() => (this.getSession(t.getID()) || (this._addSession(t), this._emitSessionUpdate(t)), t)).catch(e => (this._emitSessionUpdate(t), Promise.reject(e)))
                }
                stopRecording(e) {
                    const t = this.getSession(e);
                    return t ? t.stop({
                        focusMucJid: this._chatRoom.focusMucJid
                    }) : Promise.reject(new Error("Could not find session"))
                }
                _addSession(e) {
                    this._sessions[e.getID()] = e
                }
                _createSession(e, t, n) {
                    const i = new o.a({
                        connection: this._chatRoom.connection,
                        focusMucJid: this._chatRoom.focusMucJid,
                        mode: n,
                        sessionID: e,
                        status: t
                    });
                    return this._addSession(i), i
                }
                _emitSessionUpdate(e, t) {
                    this._chatRoom.eventEmitter.emit(r.a.RECORDER_STATE_CHANGED, e, t)
                }
                _handleFocusPresence(e) {
                    const t = a.a.getFocusRecordingUpdate(e);
                    if (!t) return;
                    const {
                        error: n,
                        initiator: i,
                        recordingMode: s,
                        sessionID: r,
                        status: o
                    } = t;
                    let c = this.getSession(r);
                    c || "off" !== o ? c && c.getStatus() === o && c.getError() === n ? d.warn("Ignoring duplicate presence update: ", JSON.stringify(t)) : (c || (c = this._createSession(r, o, s)), c.setStatus(o), n && c.setError(n), this._emitSessionUpdate(c, i)) : d.warn("Ignoring recording presence update", "Received a new session with status off.")
                }
                _handleJibriPresence(e) {
                    const {
                        liveStreamViewURL: t,
                        mode: n,
                        sessionID: i
                    } = a.a.getHiddenDomainUpdate(e);
                    if (!i) return void d.warn("Ignoring potential jibri presence due to no session id.");
                    let s = this.getSession(i);
                    s || (s = this._createSession(i, "", n)), s.setLiveStreamViewURL(t), this._emitSessionUpdate(s)
                }
            }
        }).call(this, "modules/recording/RecordingManager.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return u
            }));
            var i = n(5),
                s = n(1),
                r = n(4),
                o = n(32),
                a = n(8),
                c = n(6);
            const d = Object(i.getLogger)(e);
            class u {
                constructor(e) {
                    this._conference = e, this._localAudioLevelCache = {}, this._reportedParticipants = [], this._audioProblemCandidates = {}, this._numberOfRemoteAudioLevelsReceived = {}, this._onLocalAudioLevelsReport = this._onLocalAudioLevelsReport.bind(this), this._onRemoteAudioLevelReceived = this._onRemoteAudioLevelReceived.bind(this), this._clearUserData = this._clearUserData.bind(this), this._conference.on(o.REMOTE_STATS_UPDATED, this._onRemoteAudioLevelReceived), this._conference.statistics.addConnectionStatsListener(this._onLocalAudioLevelsReport), this._conference.on(s.USER_LEFT, this._clearUserData)
                }
                _onRemoteAudioLevelReceived(e, {
                    avgAudioLevels: t
                }) {
                    const n = this._numberOfRemoteAudioLevelsReceived[e] + 1 || 0;
                    if (this._numberOfRemoteAudioLevelsReceived[e] = n, -1 !== this._reportedParticipants.indexOf(e) || e in this._audioProblemCandidates || t <= 0 || n < 3) return;
                    const i = this._conference.getParticipantById(e);
                    if (i) {
                        if (i.getTracksByMediaType(r.a).length > 0 && i.isAudioMuted()) return
                    }
                    const s = this._localAudioLevelCache[e];
                    Array.isArray(s) && !s.every(e => 0 === e) || (this._audioProblemCandidates[e] = {
                        remoteAudioLevels: t,
                        localAudioLevels: []
                    })
                }
                _onLocalAudioLevelsReport(e, {
                    avgAudioLevels: t
                }) {
                    e === this._conference.getActivePeerConnection() && (Object.keys(t).forEach(e => {
                        if (-1 !== this._reportedParticipants.indexOf(e)) return;
                        const n = this._localAudioLevelCache[e];
                        Array.isArray(n) ? n.length >= 2 && n.shift() : this._localAudioLevelCache[e] = [], this._localAudioLevelCache[e].push(t[e])
                    }), Object.keys(this._audioProblemCandidates).forEach(e => {
                        const {
                            localAudioLevels: n,
                            remoteAudioLevels: i
                        } = this._audioProblemCandidates[e];
                        if (n.push(t[e]), 2 === n.length) {
                            if (n.every(e => void 0 === e || 0 === e)) {
                                const t = JSON.stringify(n);
                                c.a.sendAnalytics(Object(a.x)(e, t, i)), d.warn(`A potential problem is detected with the audio output for participant ${e}, local audio levels: ${t}, remote audio levels: ${i}`), this._reportedParticipants.push(e), this._clearUserData(e)
                            }
                            delete this._audioProblemCandidates[e]
                        }
                    }))
                }
                _clearUserData(e) {
                    delete this._localAudioLevelCache[e]
                }
                dispose() {
                    this._conference.off(o.REMOTE_STATS_UPDATED, this._onRemoteAudioLevelReceived), this._conference.off(s.USER_LEFT, this._clearUserData), this._conference.statistics.removeConnectionStatsListener(this._onLocalAudioLevelsReport), this._localAudioLevelCache = void 0, this._audioProblemCandidates = void 0, this._reportedParticipants = void 0, this._numberOfRemoteAudioLevelsReceived = void 0, this._conference = void 0
                }
            }
        }).call(this, "modules/statistics/AudioOutputProblemDetector.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return g
            }));
            var i = n(5),
                s = n(33),
                r = n.n(s),
                o = n(1),
                a = n(4),
                c = n(14),
                d = n(32),
                u = n(8),
                l = n(3),
                h = n(6);
            const p = Object(i.getLogger)(e);
            class m {
                constructor(e) {
                    this.name = e, this.count = 0, this.sum = 0, this.samples = []
                }
                addNext(e) {
                    "number" != typeof e ? p.error(`${this.name} - invalid value for idx: ${this.count}`, e) : isNaN(e) || (this.sum += e, this.samples.push(e), this.count += 1)
                }
                calculate() {
                    return this.sum / this.count
                }
                appendReport(e) {
                    e[this.name + "_avg"] = this.calculate(), e[this.name + "_samples"] = JSON.stringify(this.samples)
                }
                reset() {
                    this.samples = [], this.sum = 0, this.count = 0
                }
            }
            class f {
                constructor(e, t, n) {
                    this.isP2P = t, this._n = n, this._sampleIdx = 0, this._avgRTT = new m("rtt"), this._avgRemoteRTTMap = new Map, this._avgRtpStatsReporter = e, this._avgEnd2EndRTT = void 0, this._onConnectionStats = (e, t) => {
                        this.isP2P === e.isP2P && this._calculateAvgStats(t)
                    };
                    const i = e._conference;
                    i.statistics.addConnectionStatsListener(this._onConnectionStats), this.isP2P || (this._onUserLeft = e => this._avgRemoteRTTMap.delete(e), i.on(o.USER_LEFT, this._onUserLeft), this._onRemoteStatsUpdated = (e, t) => this._processRemoteStats(e, t), i.on(d.REMOTE_STATS_UPDATED, this._onRemoteStatsUpdated))
                }
                _calculateAvgStats(e) {
                    if (e) {
                        if (l.a.supportsRTTStatistics() && e.transport && e.transport.length && this._avgRTT.addNext(e.transport[0].rtt), this._sampleIdx += 1, this._sampleIdx >= this._n) {
                            if (l.a.supportsRTTStatistics()) {
                                const t = this._avgRtpStatsReporter._conference,
                                    n = {
                                        p2p: this.isP2P,
                                        conference_size: t.getParticipantCount()
                                    };
                                if (e.transport && e.transport.length && Object.assign(n, {
                                        local_candidate_type: e.transport[0].localCandidateType,
                                        remote_candidate_type: e.transport[0].remoteCandidateType,
                                        transport_type: e.transport[0].type
                                    }), this._avgRTT.appendReport(n), this.isP2P) {
                                    const e = this._avgRtpStatsReporter.jvbStatsMonitor._avgEnd2EndRTT;
                                    isNaN(e) || (n.rtt_diff = this._avgRTT.calculate() - e)
                                } else {
                                    const e = this._calculateAvgRemoteRTT(),
                                        t = this._avgRTT.calculate();
                                    this._avgEnd2EndRTT = t + e, isNaN(t) || isNaN(e) || (n.end2end_rtt_avg = this._avgEnd2EndRTT)
                                }
                                h.a.sendAnalytics(Object(u.L)(n))
                            }
                            this._resetAvgStats()
                        }
                    } else p.error("No stats")
                }
                _calculateAvgRemoteRTT() {
                    let e = 0,
                        t = 0;
                    for (const n of this._avgRemoteRTTMap.values()) {
                        const i = n.calculate();
                        isNaN(i) || (t += i, e += 1, n.reset())
                    }
                    return t / e
                }
                _processRemoteStats(e, t) {
                    const n = "number" == typeof t.jvbRTT;
                    let i = this._avgRemoteRTTMap.get(e);
                    !i && n && (i = new m(e + "_stat_rtt"), this._avgRemoteRTTMap.set(e, i)), n ? i.addNext(t.jvbRTT) : i && this._avgRemoteRTTMap.delete(e)
                }
                _resetAvgStats() {
                    this._avgRTT.reset(), this._avgRemoteRTTMap && this._avgRemoteRTTMap.clear(), this._sampleIdx = 0
                }
                dispose() {
                    const e = this._avgRtpStatsReporter._conference;
                    e.statistics.removeConnectionStatsListener(this._onConnectionStats), this.isP2P || (e.off(d.REMOTE_STATS_UPDATED, this._onRemoteStatsUpdated), e.off(o.USER_LEFT, this._onUserLeft))
                }
            }
            class g {
                constructor(e, t) {
                    this._n = t, t > 0 ? (p.info(`Avg RTP stats will be calculated every ${t} samples`), this._sampleIdx = 0, this._conference = e, this._avgAudioBitrateUp = new m("bitrate_audio_upload"), this._avgAudioBitrateDown = new m("bitrate_audio_download"), this._avgVideoBitrateUp = new m("bitrate_video_upload"), this._avgVideoBitrateDown = new m("bitrate_video_download"), this._avgBandwidthUp = new m("bandwidth_upload"), this._avgBandwidthDown = new m("bandwidth_download"), this._avgPacketLossTotal = new m("packet_loss_total"), this._avgPacketLossUp = new m("packet_loss_upload"), this._avgPacketLossDown = new m("packet_loss_download"), this._avgRemoteFPS = new m("framerate_remote"), this._avgRemoteScreenFPS = new m("framerate_screen_remote"), this._avgLocalFPS = new m("framerate_local"), this._avgLocalScreenFPS = new m("framerate_screen_local"), this._avgRemoteCameraPixels = new m("pixels_remote"), this._avgRemoteScreenPixels = new m("pixels_screen_remote"), this._avgLocalCameraPixels = new m("pixels_local"), this._avgLocalScreenPixels = new m("pixels_screen_local"), this._avgCQ = new m("connection_quality"), this._cachedTransportStats = void 0, this._onLocalStatsUpdated = e => {
                        this._calculateAvgStats(e), this._maybeSendTransportAnalyticsEvent(e)
                    }, e.on(d.LOCAL_STATS_UPDATED, this._onLocalStatsUpdated), this._onP2PStatusChanged = () => {
                        p.debug("Resetting average stats calculation"), this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats(), this.p2pStatsMonitor._resetAvgStats()
                    }, e.on(o.P2P_STATUS, this._onP2PStatusChanged), this._onJvb121StatusChanged = (e, t) => {
                        !0 === t && (p.info("Resetting JVB avg RTP stats"), this._resetAvgJvbStats())
                    }, e.on(o.JVB121_STATUS, this._onJvb121StatusChanged), this.jvbStatsMonitor = new f(this, !1, t), this.p2pStatsMonitor = new f(this, !0, t)) : p.info("Avg RTP stats reports are disabled.")
                }
                _calculateAvgStats(e) {
                    if (!e) return void p.error("No stats");
                    const t = this._conference.isP2PActive(),
                        n = this._conference.getParticipantCount();
                    if (!t && n < 2) return;
                    const i = e.bitrate,
                        s = e.bandwidth,
                        r = e.packetLoss,
                        o = e.framerate,
                        a = e.resolution;
                    if (i)
                        if (s)
                            if (r)
                                if (o)
                                    if (a) {
                                        if (this._avgAudioBitrateUp.addNext(i.audio.upload), this._avgAudioBitrateDown.addNext(i.audio.download), this._avgVideoBitrateUp.addNext(i.video.upload), this._avgVideoBitrateDown.addNext(i.video.download), l.a.supportsBandwidthStatistics() && (this._avgBandwidthUp.addNext(s.upload), this._avgBandwidthDown.addNext(s.download)), this._avgPacketLossUp.addNext(r.upload), this._avgPacketLossDown.addNext(r.download), this._avgPacketLossTotal.addNext(r.total), this._avgCQ.addNext(e.connectionQuality), o && (this._avgRemoteFPS.addNext(this._calculateAvgVideoFps(o, !1, c.CAMERA)), this._avgRemoteScreenFPS.addNext(this._calculateAvgVideoFps(o, !1, c.DESKTOP)), this._avgLocalFPS.addNext(this._calculateAvgVideoFps(o, !0, c.CAMERA)), this._avgLocalScreenFPS.addNext(this._calculateAvgVideoFps(o, !0, c.DESKTOP))), a && (this._avgRemoteCameraPixels.addNext(this._calculateAvgVideoPixels(a, !1, c.CAMERA)), this._avgRemoteScreenPixels.addNext(this._calculateAvgVideoPixels(a, !1, c.DESKTOP)), this._avgLocalCameraPixels.addNext(this._calculateAvgVideoPixels(a, !0, c.CAMERA)), this._avgLocalScreenPixels.addNext(this._calculateAvgVideoPixels(a, !0, c.DESKTOP))), this._sampleIdx += 1, this._sampleIdx >= this._n) {
                                            const i = {
                                                p2p: t,
                                                conference_size: n
                                            };
                                            e.transport && e.transport.length && Object.assign(i, {
                                                local_candidate_type: e.transport[0].localCandidateType,
                                                remote_candidate_type: e.transport[0].remoteCandidateType,
                                                transport_type: e.transport[0].type
                                            }), this._avgAudioBitrateUp.appendReport(i), this._avgAudioBitrateDown.appendReport(i), this._avgVideoBitrateUp.appendReport(i), this._avgVideoBitrateDown.appendReport(i), l.a.supportsBandwidthStatistics() && (this._avgBandwidthUp.appendReport(i), this._avgBandwidthDown.appendReport(i)), this._avgPacketLossUp.appendReport(i), this._avgPacketLossDown.appendReport(i), this._avgPacketLossTotal.appendReport(i), this._avgRemoteFPS.appendReport(i), isNaN(this._avgRemoteScreenFPS.calculate()) || this._avgRemoteScreenFPS.appendReport(i), this._avgLocalFPS.appendReport(i), isNaN(this._avgLocalScreenFPS.calculate()) || this._avgLocalScreenFPS.appendReport(i), this._avgRemoteCameraPixels.appendReport(i), isNaN(this._avgRemoteScreenPixels.calculate()) || this._avgRemoteScreenPixels.appendReport(i), this._avgLocalCameraPixels.appendReport(i), isNaN(this._avgLocalScreenPixels.calculate()) || this._avgLocalScreenPixels.appendReport(i), this._avgCQ.appendReport(i), h.a.sendAnalytics(Object(u.L)(i)), this._resetAvgStats()
                                        }
                                    } else p.error("No resolution");
                    else p.error('No "framerate"');
                    else p.error('No "packetloss"');
                    else p.error('No "bandwidth"');
                    else p.error('No "bitrate"')
                }
                _calculateAvgVideoPixels(e, t, n) {
                    let i = 0,
                        s = 0;
                    const r = this._conference.myUserId();
                    for (const o of Object.keys(e))
                        if (t ? o === r : o !== r) {
                            const r = t ? null : this._conference.getParticipantById(o),
                                a = e[o];
                            if ((t || r) && a) {
                                const e = this._calculatePeerAvgVideoPixels(a, r, n);
                                isNaN(e) || (i += e, s += 1)
                            }
                        } return i / s
                }
                _calculatePeerAvgVideoPixels(e, t, n) {
                    let i = Object.keys(e).map(e => Number(e)),
                        s = null;
                    const r = this._conference.getActivePeerConnection();
                    t ? (s = t.getTracksByMediaType(a.c), s && (i = i.filter(e => s.find(t => !t.isMuted() && t.getSSRC() === e && t.videoType === n)))) : (s = this._conference.getLocalTracks(a.c), i = i.filter(e => s.find(t => !t.isMuted() && r.getLocalSSRC(t) === e && t.videoType === n)));
                    let o = 0,
                        c = 0;
                    for (const t of i) {
                        const n = Number(e[t].height) * Number(e[t].width);
                        !isNaN(n) && n > 0 && (o += n, c += 1)
                    }
                    return o / c
                }
                _calculateAvgVideoFps(e, t, n) {
                    let i = 0,
                        s = 0;
                    const r = this._conference.myUserId();
                    for (const o of Object.keys(e))
                        if (t ? o === r : o !== r) {
                            const r = t ? null : this._conference.getParticipantById(o),
                                a = e[o];
                            if ((t || r) && a) {
                                const e = this._calculatePeerAvgVideoFps(a, r, n);
                                isNaN(e) || (i += e, s += 1)
                            }
                        } return i / s
                }
                _calculatePeerAvgVideoFps(e, t, n) {
                    let i = Object.keys(e).map(e => Number(e)),
                        s = null;
                    const r = this._conference.getActivePeerConnection();
                    t ? (s = t.getTracksByMediaType(a.c), s && (i = i.filter(e => s.find(t => !t.isMuted() && t.getSSRC() === e && t.videoType === n)))) : (s = this._conference.getLocalTracks(a.c), i = i.filter(e => s.find(t => !t.isMuted() && r.getLocalSSRC(t) === e && t.videoType === n)));
                    let o = 0,
                        c = 0;
                    for (const t of i) {
                        const n = Number(e[t]);
                        !isNaN(n) && n > 0 && (o += n, c += 1)
                    }
                    return o / c
                }
                _maybeSendTransportAnalyticsEvent(e) {
                    if (!e || !e.transport || !e.transport.length) return;
                    const t = {
                        p2p: e.transport[0].p2p,
                        local_candidate_type: e.transport[0].localCandidateType,
                        remote_candidate_type: e.transport[0].remoteCandidateType,
                        transport_type: e.transport[0].type
                    };
                    this._cachedTransportStats && r()(t, this._cachedTransportStats) || (this._cachedTransportStats = t, h.a.sendAnalytics(Object(u.M)(t)))
                }
                _resetAvgJvbStats() {
                    this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats()
                }
                _resetAvgStats() {
                    this._avgAudioBitrateUp.reset(), this._avgAudioBitrateDown.reset(), this._avgVideoBitrateUp.reset(), this._avgVideoBitrateDown.reset(), this._avgBandwidthUp.reset(), this._avgBandwidthDown.reset(), this._avgPacketLossUp.reset(), this._avgPacketLossDown.reset(), this._avgPacketLossTotal.reset(), this._avgRemoteFPS.reset(), this._avgRemoteScreenFPS.reset(), this._avgLocalFPS.reset(), this._avgLocalScreenFPS.reset(), this._avgRemoteCameraPixels.reset(), this._avgRemoteScreenPixels.reset(), this._avgLocalCameraPixels.reset(), this._avgLocalScreenPixels.reset(), this._avgCQ.reset(), this._sampleIdx = 0
                }
                dispose() {
                    this._conference.off(o.P2P_STATUS, this._onP2PStatusChanged), this._conference.off(d.LOCAL_STATS_UPDATED, this._onLocalStatsUpdated), this._conference.off(o.JVB121_STATUS, this._onJvb121StatusChanged), this.jvbStatsMonitor.dispose(), this.p2pStatsMonitor.dispose()
                }
            }
        }).call(this, "modules/statistics/AvgRTPStatsReporter.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return c
        }));
        var i = n(1),
            s = n(0),
            r = n.n(s),
            o = n(70),
            a = n.n(o);
        class c {
            constructor(e) {
                this.stats = {
                    users: {},
                    dominantSpeakerId: null
                };
                const t = e.myUserId();
                this.stats.users[t] = new a.a(t, null, !0), this.conference = e, e.addEventListener(i.DOMINANT_SPEAKER_CHANGED, this._onDominantSpeaker.bind(this)), e.addEventListener(i.USER_JOINED, this._onUserJoin.bind(this)), e.addEventListener(i.USER_LEFT, this._onUserLeave.bind(this)), e.addEventListener(i.DISPLAY_NAME_CHANGED, this._onDisplayNameChange.bind(this)), e.xmpp && e.xmpp.addListener(r.a.SPEAKER_STATS_RECEIVED, this._updateStats.bind(this))
            }
            _onDominantSpeaker(e) {
                const t = this.stats.users[this.stats.dominantSpeakerId],
                    n = this.stats.users[e];
                t && t.setDominantSpeaker(!1), n && n.setDominantSpeaker(!0), this.stats.dominantSpeakerId = e
            }
            _onUserJoin(e, t) {
                t.isHidden() || this.stats.users[e] || (this.stats.users[e] = new a.a(e, t.getDisplayName()))
            }
            _onUserLeave(e) {
                const t = this.stats.users[e];
                t && t.markAsHasLeft()
            }
            _onDisplayNameChange(e, t) {
                const n = this.stats.users[e];
                n && n.setDisplayName(t)
            }
            getStats() {
                return this.stats.users
            }
            _updateStats(e) {
                for (const t in e) {
                    let n;
                    const i = this.conference.getParticipantById(t);
                    i && i.isHidden() || (this.stats.users[t] ? (n = this.stats.users[t], n.getDisplayName() || n.setDisplayName(e[t].displayName)) : (n = new a.a(t, e[t].displayName), this.stats.users[t] = n, n.markAsHasLeft())), n.totalDominantSpeakerTime = e[t].totalDominantSpeakerTime
                }
            }
        }
    }, function(e, t, n) {
        const i = n(83),
            s = n(165);

        function r() {
            this.audioRecorder = new i, this.transcriptionService = new s, this.counter = null, this.startTime = null, this.transcription = null, this.callback = null, this.results = [], this.state = "before", this.lineLength = 0
        }

        function o(e, t) {
            if (console.log("retrieved an answer from the transcription service. The answer has an array of length: " + t.wordArray.length), t.wordArray.length > 0) {
                let n = t.startTime.getUTCMilliseconds() - e.startTime.getUTCMilliseconds();
                n < 0 && (n = 0);
                let i = "[";
                t.wordArray.forEach(e => {
                    e.begin += n, e.end += n, i += e.word + ","
                }), i += "]", console.log(i), t.wordArray.name = t.name
            }
            e.results.push(t.wordArray), e.counter--, console.log("current counter: " + e.counter), e.maybeMerge()
        }

        function a(e) {
            for (let t = 0; t < e.length; t++) 0 === e[t].length && e.splice(t, 1);
            return e.length > 0
        }
        r.prototype.start = function() {
            if ("before" !== this.state) throw new Error(`The transcription can only start when it's in the "before" state. It's currently in the "${this.state}" state`);
            this.state = "recording", this.audioRecorder.start(), this.startTime = new Date
        }, r.prototype.stop = function(e) {
            if ("recording" !== this.state) throw new Error(`The transcription can only stop when it's in the "recording" state. It's currently in the "${this.state}" state`);
            console.log("stopping recording and sending audio files"), this.audioRecorder.stop();
            const t = o.bind(null, this);
            this.audioRecorder.getRecordingResults().forEach(e => {
                this.transcriptionService.send(e, t), this.counter++
            }), this.state = "transcribing", this.callback = e
        }, r.prototype.maybeMerge = function() {
            "transcribing" === this.state && 0 === this.counter && this.merge()
        }, r.prototype.merge = function() {
            console.log("starting merge process!\n The length of the array: " + this.results.length), this.transcription = "";
            const e = this.results,
                t = [];
            for (a(e), e.forEach(e => function(e, t) {
                    if (0 === e.length) e.push(t);
                    else {
                        if (e[e.length - 1].begin <= t.begin) return void e.push(t);
                        for (let n = 0; n < e.length; n++)
                            if (t.begin < e[n].begin) return void e.splice(n, 0, t);
                        e.push(t)
                    }
                }(t, e)); a(e);) {
                let t = e[0];
                e.forEach(e => {
                    e[0].begin < t[0].begin && (t = e)
                });
                let n = t.shift();
                for (this.updateTranscription(n, t.name); t.length > 0;) {
                    let i = !1;
                    const s = t[0].begin;
                    if (e.forEach(e => {
                            e[0].begin < s && (i = !0)
                        }), i) break;
                    n = t.shift(), this.updateTranscription(n, null)
                }
            }
            this.state = "finished", this.callback && this.callback(this.transcription)
        }, r.prototype.updateTranscription = function(e, t) {
            null != t && (this.transcription += `\n${t}:`, this.lineLength = t.length + 1), this.lineLength + e.word.length > 80 && (this.transcription += "\n    ", this.lineLength = 4), this.transcription += " " + e.word, this.lineLength += e.word.length + 1
        }, r.prototype.addTrack = function(e) {
            this.audioRecorder.addTrack(e)
        }, r.prototype.removeTrack = function(e) {
            this.audioRecorder.removeTrack(e)
        }, r.prototype.getTranscription = function() {
            if ("finished" !== this.state) throw new Error(`The transcription can only be retrieved when it's in the "finished" state. It's currently in the "${this.state}" state`);
            return this.transcription
        }, r.prototype.getState = function() {
            return this.state
        }, r.prototype.reset = function() {
            this.state = "before", this.counter = null, this.transcription = null, this.startTime = null, this.callback = null, this.results = [], this.lineLength = 0
        }, e.exports = r
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return r
            }));
            var i = n(6);
            const s = n(5).getLogger(e);

            function r(e) {
                this.versions = {}, this.conference = e, this.conference.addCommandListener("versions", this.processVersions.bind(this))
            }
            r.prototype.processVersions = function(e, t, n) {
                if (!this.conference._isFocus(n)) return void s.warn("Received versions not from the focus user: " + e, n);
                const r = [];
                e.children.forEach(e => {
                    const t = e.attributes.name,
                        n = e.value;
                    this.versions[t] !== n && (this.versions[t] = n, s.info(`Got ${t} version: ${n}`), r.push({
                        id: "component_version",
                        component: t,
                        version: n
                    }))
                }), r.length > 0 && i.a.sendLog(JSON.stringify(r))
            }, r.prototype.getComponentVersion = function(e) {
                return this.versions[e]
            }
        }).call(this, "modules/version/ComponentsVersions.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return d
            }));
            var i = n(5),
                s = n(0),
                r = n.n(s),
                o = n(141),
                a = n(26);
            const c = Object(i.getLogger)(e);
            class d {
                constructor(e) {
                    this.chatRoom = e, this.eventEmitter = e.eventEmitter, c.debug("creating VideoSIPGW"), this.sessions = {}, this.sessionStateChangeListener = this.sessionStateChanged.bind(this), e.addPresenceListener("jibri-sip-call-state", this.handleJibriSIPState.bind(this))
                }
                handleJibriSIPState(e) {
                    const t = e.attributes;
                    if (!t) return;
                    c.debug("Handle video sip gw state : ", t);
                    const n = t.state;
                    if (n !== this.state) switch (n) {
                        case a.STATE_ON:
                        case a.STATE_OFF:
                        case a.STATE_PENDING:
                        case a.STATE_RETRYING:
                        case a.STATE_FAILED: {
                            const e = t.sipaddress;
                            if (!e) return;
                            const i = this.sessions[e];
                            i ? i.setState(n, t.failure_reason) : c.warn("Video SIP GW session not found:", e)
                        }
                    }
                }
                createVideoSIPGWSession(e, t) {
                    if (this.sessions[e]) return c.warn("There was already a Video SIP GW session for address", e), new Error(a.ERROR_SESSION_EXISTS);
                    const n = new o.a(e, t, this.chatRoom);
                    return n.addStateListener(this.sessionStateChangeListener), this.sessions[e] = n, n
                }
                sessionStateChanged(e) {
                    const t = e.address;
                    if (e.newState === a.STATE_OFF || e.newState === a.STATE_FAILED) {
                        const e = this.sessions[t];
                        if (!e) return void c.error("Missing Video SIP GW session with address:", t);
                        e.removeStateListener(this.sessionStateChangeListener), delete this.sessions[t]
                    }
                    this.eventEmitter.emit(r.a.VIDEO_SIP_GW_SESSION_STATE_CHANGED, e)
                }
            }
        }).call(this, "modules/videosipgw/VideoSIPGW.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return c
            }));
            var i = n(5),
                s = n(2),
                r = n(22),
                o = n(26);
            const a = Object(i.getLogger)(e);
            class c extends r.a {
                constructor(e, t, n) {
                    super(), this.sipAddress = e, this.displayName = t, this.chatRoom = n, this.state = void 0
                }
                stop() {
                    this.state !== o.STATE_OFF && this.state !== o.STATE_FAILED ? this._sendJibriIQ("stop") : a.warn("Video SIP GW session already stopped or failed!")
                }
                start() {
                    this.state !== o.STATE_ON && this.state !== o.STATE_OFF && this.state !== o.STATE_PENDING && this.state !== o.STATE_RETRYING ? this._sendJibriIQ("start") : a.warn("Video SIP GW session already started!")
                }
                setState(e, t) {
                    if (e === this.state) return;
                    const n = this.state;
                    this.state = e, this.eventEmitter.emit("STATE_CHANGED", {
                        address: this.sipAddress,
                        failureReason: t,
                        oldState: n,
                        newState: this.state,
                        displayName: this.displayName
                    })
                }
                addStateListener(e) {
                    this.addListener("STATE_CHANGED", e)
                }
                removeStateListener(e) {
                    this.removeListener("STATE_CHANGED", e)
                }
                _sendJibriIQ(e) {
                    const t = {
                        xmlns: "http://jitsi.org/protocol/jibri",
                        action: e,
                        sipaddress: this.sipAddress
                    };
                    t.displayname = this.displayName;
                    const n = Object(s.$iq)({
                        to: this.chatRoom.focusMucJid,
                        type: "set"
                    }).c("jibri", t).up();
                    a.debug(e + " video SIP GW session", n.nodeTree), this.chatRoom.connection.sendIQ(n, () => {}, t => {
                        a.error(`Failed to ${e} video SIP GW session, error: `, t), this.setState(o.STATE_FAILED)
                    })
                }
            }
        }).call(this, "modules/videosipgw/JitsiVideoSIPGWSession.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return c
            }));
            var i = n(5),
                s = n(16),
                r = n(13),
                o = n(6);
            const a = Object(i.getLogger)(e);

            function c() {
                return new Promise(e => {
                    r.a.enumerateDevices(t => {
                        const n = t.filter(e => "audioinput" === e.kind),
                            i = [];
                        for (const e of n) {
                            const t = r.a.obtainAudioAndVideoPermissions({
                                devices: ["audio"],
                                micDeviceId: e.deviceId
                            }).then(e => {
                                const t = e[0],
                                    n = t.getOriginalStream();
                                return o.a.startLocalStats(n, t.setAudioLevel.bind(t)), t.addEventListener(s.LOCAL_TRACK_STOPPED, () => {
                                    o.a.stopLocalStats(n)
                                }), t
                            });
                            i.push(t)
                        }
                        Promise.allSettled(i).then(t => {
                            const n = t.filter(e => "fulfilled" === e.status),
                                i = t.filter(e => "rejected" === e.status),
                                r = n.map(e => e.value),
                                o = i.map(e => e.value);
                            for (const e of o) a.error("Failed to acquire audio device with error: ", e);
                            for (const t of r) t.on(s.TRACK_AUDIO_LEVEL_CHANGED, n => {
                                n > .008 && (d(r), e({
                                    deviceId: t.deviceId,
                                    deviceLabel: t.track.label
                                }))
                            });
                            setTimeout(() => {
                                d(r), e({
                                    deviceId: "",
                                    deviceLabel: ""
                                })
                            }, 3e3)
                        })
                    })
                })
            }

            function d(e) {
                for (const t of e) t.stopStream()
            }
        }).call(this, "modules/detection/ActiveDeviceDetector.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return f
            }));
            var i = n(5),
                s = n(2),
                r = n(4),
                o = n(14),
                a = n.n(o),
                c = n(13),
                d = n(144),
                u = n(35);

            function l(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? Object(arguments[t]) : {},
                        i = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), i.forEach((function(t) {
                        h(e, t, n[t])
                    }))
                }
                return e
            }

            function h(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }

            function p(e, t) {
                if (null == e) return {};
                var n, i, s = function(e, t) {
                    if (null == e) return {};
                    var n, i, s = {},
                        r = Object.keys(e);
                    for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || (s[n] = e[n]);
                    return s
                }(e, t);
                if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (s[n] = e[n])
                }
                return s
            }
            const m = Object(i.getLogger)(e);
            class f {
                constructor(e = {}) {
                    const {
                        jitsiConnection: t
                    } = e, n = p(e, ["jitsiConnection"]);
                    this._options = l({
                        iceConfig: t && t.xmpp.connection.jingle.p2pIceConfig
                    }, n), this._peerConnection = null, this._onFatalError = this._onFatalError.bind(this), this._onSendMessage = this._onSendMessage.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this)
                }
                processMessage(e) {
                    const t = e.from;
                    if (!t) return;
                    if (this._peerConnection && this._peerConnection.getPeerJid() !== t) return void this._onFatalError(t, u.a.CONNECTION_ERROR, "rejected");
                    const n = this._convertStringToXML(e.data.iq),
                        i = n && n.find("jingle"),
                        s = i && i.attr("action");
                    s === u.a.INITIATE && (this._peerConnection = this._createPeerConnection(t, {
                        isInitiator: !1,
                        receiveVideo: !0
                    })), this._peerConnection && this._peerConnection.processMessage(i), s !== u.a.CONNECTION_ERROR && s !== u.a.UNAVAILABLE && s !== u.a.TERMINATE || this._selfCloseConnection()
                }
                start(e, t = []) {
                    this._peerConnection = this._createPeerConnection(e, {
                        isInitiator: !0,
                        receiveVideo: !1
                    }), this._peerConnection.start(t)
                }
                stop() {
                    this._peerConnection && this._peerConnection.stop(), this._peerConnection = null
                }
                _convertStringToXML(e) {
                    try {
                        const t = (new DOMParser).parseFromString(e, "text/xml");
                        return $(t)
                    } catch (e) {
                        return m.error("Attempted to convert incorrectly formatted xml"), null
                    }
                }
                _createPeerConnection(e, t = {}) {
                    if (!e) throw new Error("Cannot create ProxyConnectionPC without a peer.");
                    const n = l({
                        iceConfig: this._options.iceConfig,
                        onError: this._onFatalError,
                        onRemoteStream: this._onRemoteStream,
                        onSendMessage: this._onSendMessage,
                        peerJid: e
                    }, t);
                    return new d.a(n)
                }
                _onFatalError(e, t, n = "") {
                    m.error("Received a proxy connection error", e, t, n);
                    const i = Object(s.$iq)({
                        to: e,
                        type: "set"
                    }).c("jingle", {
                        xmlns: "urn:xmpp:jingle:1",
                        action: t
                    }).c("details").t(n).up();
                    this._onSendMessage(e, i), this._peerConnection && this._peerConnection.getPeerJid() === e && this._selfCloseConnection()
                }
                _onRemoteStream(e) {
                    if (!this._options.onRemoteStream) return m.error("Remote track received without callback."), void e.dispose();
                    const t = e.isVideoTrack();
                    let n;
                    t && (n = this._options.convertVideoToDesktop ? a.a.DESKTOP : a.a.CAMERA);
                    const i = e.getOriginalStream(),
                        s = c.a.createLocalTracks([{
                            deviceId: "proxy:" + this._peerConnection.getPeerJid(),
                            mediaType: t ? r.c : r.a,
                            sourceType: "proxy",
                            stream: i,
                            track: i.getVideoTracks()[0],
                            videoType: n
                        }]);
                    this._options.onRemoteStream(s[0])
                }
                _onSendMessage(e, t) {
                    if (this._options.onSendMessage) try {
                        const n = (new XMLSerializer).serializeToString(t.nodeTree || t);
                        this._options.onSendMessage(e, {
                            iq: n
                        })
                    } catch (e) {
                        m.error("Attempted to send an incorrectly formatted iq.")
                    }
                }
                _selfCloseConnection() {
                    this.stop(), this._options.onConnectionClosed && this._options.onConnectionClosed()
                }
            }
        }).call(this, "modules/proxyconnection/ProxyConnectionService.js")
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return f
            }));
            var i = n(5),
                s = n(7),
                r = n.n(s),
                o = n(0),
                a = n.n(o),
                c = n(13),
                d = n(56),
                u = n(25),
                l = n(35);

            function h(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? Object(arguments[t]) : {},
                        i = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                    })))), i.forEach((function(t) {
                        p(e, t, n[t])
                    }))
                }
                return e
            }

            function p(e, t, n) {
                return t in e ? Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : e[t] = n, e
            }
            const m = Object(i.getLogger)(e);
            class f {
                constructor(e = {}) {
                    this._options = h({
                        iceConfig: {},
                        isInitiator: !1,
                        receiveAudio: !1,
                        receiveVideo: !1
                    }, e), this._tracks = [], this._peerConnection = null, this._onError = this._onError.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this), this._onSendMessage = this._onSendMessage.bind(this)
                }
                getPeerJid() {
                    return this._options.peerJid
                }
                processMessage(e) {
                    switch (e.attr("action")) {
                        case l.a.ACCEPT:
                            this._onSessionAccept(e);
                            break;
                        case l.a.INITIATE:
                            this._onSessionInitiate(e);
                            break;
                        case l.a.TERMINATE:
                            this._onSessionTerminate(e);
                            break;
                        case l.a.TRANSPORT_INFO:
                            this._onTransportInfo(e)
                    }
                }
                start(e = []) {
                    this._peerConnection || (this._tracks = this._tracks.concat(e), this._peerConnection = this._createPeerConnection(), this._peerConnection.invite(e))
                }
                stop() {
                    this._peerConnection && this._peerConnection.terminate(), this._onSessionTerminate()
                }
                _createPeerConnection() {
                    const e = {
                            connected: !0,
                            jingle: {
                                terminate: () => {}
                            },
                            sendIQ: this._onSendMessage,
                            addEventListener: () => () => {}
                        },
                        t = h({
                            iceServers: u.a
                        }, this._options.iceConfig),
                        n = {
                            addPresenceListener: () => {},
                            connectionTimes: [],
                            eventEmitter: {
                                emit: e => {
                                    switch (e) {
                                        case a.a.CONNECTION_ICE_FAILED:
                                        case a.a.CONNECTION_FAILED:
                                            this._onError(l.a.CONNECTION_ERROR, e)
                                    }
                                }
                            },
                            getMediaPresenceInfo: () => ({}),
                            removePresenceListener: () => {}
                        };
                    this._rtc = new c.a({}, {}), this._rtc.addListener(r.a.REMOTE_TRACK_ADDED, this._onRemoteStream);
                    const i = new d.a(void 0, void 0, this._options.peerJid, e, {
                        offerToReceiveAudio: this._options.receiveAudio,
                        offerToReceiveVideo: this._options.receiveVideo
                    }, t, !0, this._options.isInitiator);
                    return i.initialize(n, this._rtc, {}), i
                }
                _onError(e, t = "") {
                    this._options.onError(this._options.peerJid, e, t)
                }
                _onRemoteStream(e) {
                    this._tracks.push(e), this._options.onRemoteStream(e)
                }
                _onSendMessage(e) {
                    this._options.onSendMessage(this._options.peerJid, e)
                }
                _onSessionAccept(e) {
                    this._peerConnection ? this._peerConnection.setAnswer(e) : m.error("Received an answer when no peer connection exists.")
                }
                _onSessionInitiate(e) {
                    this._peerConnection ? m.error("Received an offer when an offer was already sent.") : (this._peerConnection = this._createPeerConnection(), this._peerConnection.acceptOffer(e, () => {}, () => this._onError(this._options.peerJid, l.a.CONNECTION_ERROR, "session initiate error")))
                }
                _onSessionTerminate() {
                    this._tracks.forEach(e => e.dispose()), this._tracks = [], this._peerConnection && this._peerConnection.onTerminated(), this._rtc && (this._rtc.removeListener(r.a.REMOTE_TRACK_ADDED, this._onRemoteStream), this._rtc.destroy())
                }
                _onTransportInfo(e) {
                    this._peerConnection.addIceCandidates(e)
                }
            }
        }).call(this, "modules/proxyconnection/ProxyConnectionPC.js")
    }, function(e, t, n) {
        "use strict";
        t.a = {
            error: {
                BUSY: "busy",
                ERROR: "error",
                RESOURCE_CONSTRAINT: "resource-constraint",
                SERVICE_UNAVAILABLE: "service-unavailable"
            },
            mode: {
                FILE: "file",
                STREAM: "stream"
            },
            status: {
                OFF: "off",
                ON: "on",
                PENDING: "pending"
            }
        }
    }, function(e, t, n) {
        "use strict";
        var i = n(19),
            s = n.n(i),
            r = n(3),
            o = n(29),
            a = n(50),
            c = n.n(a),
            d = n(43);
        const u = new s.a;
        let l = !1,
            h = null;
        t.a = {
            init: async function(e) {
                if (l) throw new Error("Precall Test already initialized");
                const {
                    callStatsID: t,
                    callStatsSecret: n,
                    disableThirdPartyRequests: i
                } = e;
                if (!t || !n || i) throw new Error("Callstats is disabled");
                return await
                function() {
                    if (!r.a.isReactNative()) return new Promise(e => {
                        c.a.loadScript(d.a, !0, !0, void 0, e)
                    })
                }(), h = new window.callstats,
                    function(e) {
                        return new Promise((t, n) => {
                            const i = e.callStatsID,
                                s = e.callStatsSecret,
                                r = e.statisticsId || e.statisticsDisplayName || o.a.callStatsUserName;
                            h.initialize(i, s, r, (e, i) => {
                                "success" === e ? (h.on("preCallTestResults", (...e) => {
                                    u.emit("preCallTestResults", ...e)
                                }), l = !0, t()) : n({
                                    status: e,
                                    message: i
                                })
                            }, null, {
                                disablePrecalltest: !0
                            })
                        })
                    }(e)
            },
            execute: function() {
                return l ? new Promise((e, t) => {
                    u.on("preCallTestResults", (n, i) => {
                        "success" === n ? e(i) : t({
                            status: n,
                            payload: i
                        })
                    }), h.makePrecallTest()
                }) : Promise.reject("uninitialized")
            }
        }
    }, function(e, t) {
        const n = {
            getTokenAuthUrl: (e, t, n) => "string" != typeof e ? null : e.replace("{room}", t).replace("{roleUpgrade}", !0 === n)
        };
        e.exports = n
    }, function(e, t, n) {
        "use strict";
        (function(e) {
            n.d(t, "a", (function() {
                return o
            }));
            var i = n(5),
                s = n(68);
            const r = Object(i.getLogger)(e);
            class o {
                constructor() {
                    this._started = !1, this._streamsToMix = [], this._streamMSSArray = []
                }
                addMediaStream(e) {
                    e.getAudioTracks() || r.warn("Added MediaStream doesn't contain audio tracks."), this._streamsToMix.push(e)
                }
                start() {
                    if (this._started) return this._mixedMSD.stream;
                    if (this._audioContext = Object(s.a)(), !this._streamsToMix.length) return r.warn("No MediaStream's added to AudioMixer, nothing will happen."), null;
                    this._started = !0, this._mixedMSD = this._audioContext.createMediaStreamDestination();
                    for (const e of this._streamsToMix) {
                        const t = this._audioContext.createMediaStreamSource(e);
                        t.connect(this._mixedMSD), this._streamMSSArray.push(t)
                    }
                    return this._mixedMSD.stream
                }
                reset() {
                    this._started = !1, this._streamsToMix = [];
                    for (const e of this._streamMSSArray) e.disconnect();
                    this._streamMSSArray = [], this._audioContext && (this._audioContext = void 0)
                }
            }
        }).call(this, "modules/webaudio/AudioMixer.js")
    }, function(e, t, n) {
        "use strict";
        n.d(t, "a", (function() {
            return f
        }));
        var i = n(44),
            s = n.n(i),
            r = n(23),
            o = n.n(r);
        var a = function(e, t) {
                return void 0 !== e && void 0 !== e.media && Array.isArray(e.media) && e.media.forEach(e => {
                    e.sources && e.sources.length && (e.ssrcs = [], e.sources.forEach(t => {
                        Object.keys(t).forEach(n => {
                            "id" !== n && e.ssrcs.push({
                                id: t.id,
                                attribute: n,
                                value: t[n]
                            })
                        })
                    }), delete e.sources), e.ssrcGroups && e.ssrcGroups.length && e.ssrcGroups.forEach(e => {
                        void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.ssrcs = e.ssrcs.join(" "))
                    })
                }), o.a.write(e, t)
            },
            c = function(e) {
                const t = o.a.parse(e);
                return void 0 !== t && void 0 !== t.media && Array.isArray(t.media) && t.media.forEach(e => {
                    void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.sources = [], e.ssrcs.forEach(t => {
                        const n = e.sources.findIndex(e => e.id === t.id);
                        if (n > -1) e.sources[n][t.attribute] = t.value;
                        else {
                            const n = {
                                id: t.id
                            };
                            n[t.attribute] = t.value, e.sources.push(n)
                        }
                    }), delete e.ssrcs), void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach(e => {
                        "string" == typeof e.ssrcs && (e.ssrcs = e.ssrcs.split(" "))
                    })
                }), t
            };
        const d = ["audio", "video", "data"],
            u = e => e.find(e => "SIM" === e.semantics),
            l = e => e.find(e => "FID" === e.semantics);

        function h(e, t, n, i) {
            if (!e || !t) return;
            const s = e => i.find(t => t.id.toString() === e);
            t.ssrcs.forEach(t => {
                e.sources.push(s(t));
                const i = n[parseInt(t, 10)].find(e => "FID" === e.semantics);
                if (i) {
                    const n = i.ssrcs.find(e => e !== t);
                    e.sources.push(s(n)), e.ssrcGroups.push(i)
                }
            }), e.ssrcGroups.push(t)
        }

        function p(e, t, n, i) {
            if (!e || !t) return;
            if (e.sources = [], e.ssrcGroups = [], !n[t.id]) return e.sources.push(t), void(e.msid = t.msid);
            const s = u(n[t.id]),
                r = l(n[t.id]);
            if (s) h(e, s, n, i);
            else if (r) {
                const s = r.ssrcs.find(e => e !== t),
                    o = u(n[s]);
                o ? h(e, o, n, i) : (r.ssrcs.forEach(t => {
                    e.sources.push((e => i.find(t => t.id.toString() === e))(t))
                }), e.ssrcGroups.push(r))
            }
            e.msid = e.sources[0].msid
        }

        function m(e, t, n) {
            if (!n.find(t => !!t.sources && t.sources.some(t => t.id === e.id))) {
                if (!t[e.id]) return !1;
                const i = u(t[e.id]),
                    s = l(t[e.id]);
                if (i) return n.some(e => e.sources && e.sources.some(e => e.id.toString() === i.ssrcs[0]));
                if (s && e.id.toString() !== s.ssrcs[0]) {
                    return m({
                        id: s.ssrcs[0]
                    }, t, n)
                }
                return !1
            }
            return !0
        }
        class f {
            toPlanB(e) {
                if (!e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
                const t = c(e.sdp);
                if (!t.media || !t.media.length) return console.warn("The description has no media."), e;
                if (t.media.every(e => -1 !== d.indexOf(e.mid))) return console.warn("The description does not look like unified plan sdp"), e;
                const n = {},
                    i = t.media;
                t.media = [], i.forEach(e => {
                    const t = e.type;
                    if ("application" === t) return e.mid = "data", void(n[e.mid] = e);
                    if (void 0 === n[t]) {
                        const i = s()(e);
                        i.sources && Array.isArray(i.sources) && i.sources.forEach(t => {
                            e.msid ? t.msid = e.msid : delete t.msid
                        }), i.ssrcGroups && e.msid || (i.ssrcGroups = []), delete i.msid, i.mid = t, n[t] = i
                    } else e.msid && (e.sources && Array.isArray(e.sources) && (n[t].sources = n[t].sources.concat(e.sources)), void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && (n[t].ssrcGroups = n[t].ssrcGroups.concat(e.ssrcGroups)))
                }), t.media = Object.values(n);
                const r = [];
                Object.values(n).forEach(e => {
                    "inactive" !== e.direction && r.push(e.mid)
                }), t.groups.forEach(e => {
                    "BUNDLE" === e.type && (e.mids = r.join(" "))
                }), t.msidSemantic = {
                    semantic: "WMS",
                    token: "*"
                };
                const o = a(t);
                return new RTCSessionDescription({
                    type: e.type,
                    sdp: o
                })
            }
            toUnifiedPlan(e, t = null) {
                if (!e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
                const n = c(e.sdp);
                if (!n.media || !n.media.length) return console.warn("The description has no media."), e;
                if (n.media.length > 3 || n.media.every(e => -1 === d.indexOf(e.mid))) return console.warn("The description does not look like plan-b"), e;
                const i = t ? c(t.sdp) : null,
                    r = {};
                n.media.forEach(e => {
                    const t = e.type;
                    if ("application" === t) {
                        if (!i || !i.media) {
                            const t = s()(e);
                            return t.mid = Object.keys(r).length.toString(), void(r[e.mid] = t)
                        }
                        const n = i.media.findIndex(e => e.type === t);
                        return void(n && (i.media[n] = e, i.media[n].mid = n))
                    }
                    const n = function(e) {
                        const t = {};
                        return e && Array.isArray(e) ? (e.forEach(e => {
                            e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach(n => {
                                void 0 === t[n] && (t[n] = []), t[n].push(e)
                            })
                        }), t) : t
                    }(e.ssrcGroups);
                    if (e.sources) e.sources.forEach((t, o) => {
                        if (!t.msid) return;
                        if (!i || !i.media) {
                            if (m(t, n, Object.values(r))) return;
                            const i = s()(e);
                            return i.mid = Object.keys(r).length.toString(), i.direction = o || "sendonly" === e.direction ? "sendonly" : "sendrecv", i.bundleOnly = void 0, p(i, t, n, e.sources), void(r[i.mid] = i)
                        }
                        if (m(t, n, i.media)) return;
                        const a = s()(e);
                        a.mid = i.media.length.toString(), a.direction = "sendonly", p(a, t, n, e.sources), i.media.push(a)
                    });
                    else if (!i) {
                        const t = s()(e);
                        t.mid = Object.keys(r).length.toString(), r[e.mid] = t
                    }
                }), n.media = i ? i.media : Object.values(r);
                const o = [];
                n.media.forEach(e => {
                    o.push(e.mid)
                }), n.groups.forEach(e => {
                    "BUNDLE" === e.type && (e.mids = o.join(" "))
                }), n.msidSemantic = {
                    semantic: "WMS",
                    token: "*"
                }, n.origin.sessionVersion++;
                const u = a(n);
                return new RTCSessionDescription({
                    type: e.type,
                    sdp: u
                })
            }
        }
    }, function(e, t, n) {
        e.exports = n(151).default
    }, function(e, t, n) {
        "use strict";
        n.r(t),
            function(e) {
                var i = n(5),
                    s = n.n(i),
                    r = n(17),
                    o = n(1),
                    a = n(84),
                    c = n(40),
                    d = n(27),
                    u = n(71),
                    l = n(49),
                    h = n(21),
                    p = n(15),
                    m = n(16),
                    f = n(63),
                    g = n(13),
                    _ = n(3),
                    v = n(52),
                    S = n(51),
                    y = n(142),
                    E = n(24),
                    b = n(67),
                    C = n(143),
                    T = n(145),
                    R = n(29),
                    A = n(62),
                    I = n(146),
                    w = n(6),
                    D = n(147),
                    P = n.n(D),
                    O = n(12),
                    N = n.n(O),
                    M = n(50),
                    L = n.n(M),
                    k = n(26),
                    x = n(148),
                    F = n(4),
                    j = n(32),
                    U = n(69),
                    H = n(8);

                function V(e, t) {
                    if (null == e) return {};
                    var n, i, s = function(e, t) {
                        if (null == e) return {};
                        var n, i, s = {},
                            r = Object.keys(e);
                        for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || (s[n] = e[n]);
                        return s
                    }(e, t);
                    if (Object.getOwnPropertySymbols) {
                        var r = Object.getOwnPropertySymbols(e);
                        for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (s[n] = e[n])
                    }
                    return s
                }
                const B = s.a.getLogger(e);

                function J(e) {
                    const t = {
                        audio_requested: e.devices.includes("audio"),
                        video_requested: e.devices.includes("video"),
                        screen_sharing_requested: e.devices.includes("desktop")
                    };
                    return t.video_requested && (t.resolution = e.resolution), t
                }
                t.default = function(e) {
                    return "object" == typeof window.JitsiMeetJS ? Object.assign({}, window.JitsiMeetJS, e) : e
                }({
                    version: "fa834c2923",
                    JitsiConnection: a.a,
                    ProxyConnectionService: C.a,
                    constants: {
                        participantConnectionStatus: S.a,
                        recording: T.a,
                        sipVideoGW: k,
                        transcriptionStatus: f
                    },
                    events: {
                        conference: o,
                        connection: d,
                        detection: E,
                        track: m,
                        mediaDevices: l,
                        connectionQuality: j,
                        e2eping: U
                    },
                    errors: {
                        conference: r,
                        connection: c,
                        track: p
                    },
                    errorTypes: {
                        JitsiTrackError: h.a
                    },
                    logLevels: s.a.levels,
                    mediaDevices: u.a,
                    analytics: w.a.analytics,
                    init(e = {}) {
                        R.a.init(e.externalStorage), w.a.init(e), window.connectionTimes || (window.connectionTimes = {}), !0 !== e.enableAnalyticsLogging && (B.warn("Analytics disabled, disposing."), this.analytics.dispose()), e.enableWindowOnErrorHandler && N.a.addHandler(this.getGlobalOnErrorHandler.bind(this));
                        const t = e.deploymentInfo;
                        if (t && Object.keys(t).length > 0) {
                            const e = {};
                            for (const n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
                            e.id = "deployment_info", w.a.sendLog(JSON.stringify(e))
                        }
                        if (this.version) {
                            const e = {
                                id: "component_version",
                                component: "lib-jitsi-meet",
                                version: this.version
                            };
                            w.a.sendLog(JSON.stringify(e))
                        }
                        return g.a.init(e)
                    },
                    isDesktopSharingEnabled: () => g.a.isDesktopSharingEnabled(),
                    isWebRtcSupported: () => g.a.isWebRtcSupported(),
                    setLogLevel(e) {
                        s.a.setLogLevel(e)
                    },
                    setLogLevelById(e, t) {
                        s.a.setLogLevelById(e, t)
                    },
                    addGlobalLogTransport(e) {
                        s.a.addGlobalTransport(e)
                    },
                    removeGlobalLogTransport(e) {
                        s.a.removeGlobalTransport(e)
                    },
                    setGlobalLogOptions(e) {
                        s.a.setGlobalOptions(e)
                    },
                    createLocalTracks(e = {}, t) {
                        let n = !1;
                        const {
                            firePermissionPromptIsShownEvent: i,
                            fireSlowPromiseEvent: s
                        } = e, r = V(e, ["firePermissionPromptIsShownEvent", "fireSlowPromiseEvent"]);
                        return (i || t) && !g.a.arePermissionsGrantedForAvailableDevices() ? u.a.emitEvent(l.PERMISSION_PROMPT_IS_SHOWN, _.a.getName()) : s && window.setTimeout(() => {
                            n || u.a.emitEvent(l.SLOW_GET_USER_MEDIA)
                        }, 1e3), window.connectionTimes || (window.connectionTimes = {}), window.connectionTimes["obtainPermissions.start"] = window.performance.now(), g.a.obtainAudioAndVideoPermissions(r).then(e => {
                            if (n = !0, window.connectionTimes["obtainPermissions.end"] = window.performance.now(), w.a.sendAnalytics(Object(H.F)("success", J(r))), !g.a.options.disableAudioLevels)
                                for (let t = 0; t < e.length; t++) {
                                    const n = e[t],
                                        i = n.getOriginalStream();
                                    n.getType() === F.a && (w.a.startLocalStats(i, n.setAudioLevel.bind(n)), n.addEventListener(m.LOCAL_TRACK_STOPPED, () => {
                                        w.a.stopLocalStats(i)
                                    }))
                                }
                            const t = g.a.getCurrentlyAvailableMediaDevices();
                            if (t)
                                for (let n = 0; n < e.length; n++) {
                                    e[n]._setRealDeviceIdFromDeviceList(t)
                                }
                            for (const t of e) t.type === F.c && "desktop" === t.videoType && this.setVideoTrackContentHints(t.track, "detail");
                            return e
                        }).catch(t => {
                            if (n = !0, t.name === p.SCREENSHARING_USER_CANCELED) {
                                const e = {
                                    id: "screensharing_user_canceled",
                                    message: t.message
                                };
                                w.a.sendLog(JSON.stringify(e)), w.a.sendAnalytics(Object(H.F)("warning", {
                                    reason: "extension install user canceled"
                                }))
                            } else if (t.name === p.NOT_FOUND) {
                                const n = {
                                    id: "usermedia_missing_device",
                                    status: t.gum.devices
                                };
                                w.a.sendLog(JSON.stringify(n));
                                const i = J(e);
                                i.reason = "device not found", i.devices = t.gum.devices.join("."), w.a.sendAnalytics(Object(H.F)("error", i))
                            } else {
                                w.a.sendGetUserMediaFailed(t);
                                const n = J(e);
                                n.reason = t.name, w.a.sendAnalytics(Object(H.F)("error", n))
                            }
                            return window.connectionTimes["obtainPermissions.end"] = window.performance.now(), Promise.reject(t)
                        })
                    },
                    createTrackVADEmitter: (e, t, n) => b.a.create(e, t, n),
                    createAudioMixer: () => new x.a,
                    getActiveAudioDevice: () => Object(y.a)(),
                    isDeviceListAvailable() {
                        return B.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceListAvailable instead"), this.mediaDevices.isDeviceListAvailable()
                    },
                    isDeviceChangeAvailable(e) {
                        return B.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead"), this.mediaDevices.isDeviceChangeAvailable(e)
                    },
                    isMultipleAudioInputSupported() {
                        return this.mediaDevices.isMultipleAudioInputSupported()
                    },
                    isCollectingLocalStats: () => w.a.audioLevelsEnabled && A.a.isLocalStatsSupported(),
                    enumerateDevices(e) {
                        B.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.enumerateDevices instead"), this.mediaDevices.enumerateDevices(e)
                    },
                    getGlobalOnErrorHandler(e, t, n, i, s) {
                        B.error("UnhandledError: " + e, "Script: " + t, "Line: " + n, "Column: " + i, "StackTrace: ", s), w.a.reportGlobalError(s)
                    },
                    setNetworkInfo({
                        isOnline: e
                    }) {
                        v.b.updateNetworkInfo({
                            isOnline: e
                        })
                    },
                    setVideoTrackContentHints(e, t) {
                        "contentHint" in e ? (e.contentHint = t, e.contentHint !== t && B.debug("Invalid video track contentHint")) : B.debug("MediaStreamTrack contentHint attribute not supported")
                    },
                    precallTest: I.a,
                    util: {
                        AuthUtil: P(),
                        ScriptUtil: L(),
                        browser: _.a
                    }
                })
            }.call(this, "JitsiMeetJS.js")
    }, function(e, t, n) {
        var i = n(80);

        function s(e, t) {
            this.logStorage = e, this.stringifyObjects = !(!t || !t.stringifyObjects) && t.stringifyObjects, this.storeInterval = t && t.storeInterval ? t.storeInterval : 3e4, this.maxEntryLength = t && t.maxEntryLength ? t.maxEntryLength : 1e4, Object.keys(i.levels).forEach(function(e) {
                this[i.levels[e]] = function() {
                    this._log.apply(this, arguments)
                }.bind(this, e)
            }.bind(this)), this.storeLogsIntervalID = null, this.queue = [], this.totalLen = 0, this.outputCache = []
        }
        s.prototype.stringify = function(e) {
            try {
                return JSON.stringify(e)
            } catch (e) {
                return "[object with circular refs?]"
            }
        }, s.prototype.formatLogMessage = function(e) {
            for (var t = "", n = 1, s = arguments.length; n < s; n++) {
                var r = arguments[n];
                !this.stringifyObjects && e !== i.levels.ERROR || "object" != typeof r || (r = this.stringify(r)), t += r, n !== s - 1 && (t += " ")
            }
            return t.length ? t : null
        }, s.prototype._log = function() {
            var e = arguments[1],
                t = this.formatLogMessage.apply(this, arguments);
            if (t) {
                var n = this.queue[this.queue.length - 1],
                    i = n && n.text;
                i === t ? n.count += 1 : (this.queue.push({
                    text: t,
                    timestamp: e,
                    count: 1
                }), this.totalLen += t.length)
            }
            this.totalLen >= this.maxEntryLength && this._flush(!0, !0)
        }, s.prototype.start = function() {
            this._reschedulePublishInterval()
        }, s.prototype._reschedulePublishInterval = function() {
            this.storeLogsIntervalID && (window.clearTimeout(this.storeLogsIntervalID), this.storeLogsIntervalID = null), this.storeLogsIntervalID = window.setTimeout(this._flush.bind(this, !1, !0), this.storeInterval)
        }, s.prototype.flush = function() {
            this._flush(!1, !0)
        }, s.prototype._flush = function(e, t) {
            this.totalLen > 0 && (this.logStorage.isReady() || e) && (this.logStorage.isReady() ? (this.outputCache.length && (this.outputCache.forEach(function(e) {
                this.logStorage.storeLogs(e)
            }.bind(this)), this.outputCache = []), this.logStorage.storeLogs(this.queue)) : this.outputCache.push(this.queue), this.queue = [], this.totalLen = 0), t && this._reschedulePublishInterval()
        }, s.prototype.stop = function() {
            this._flush(!1, !1)
        }, e.exports = s
    }, function(e, t) {
        (function(t) {
            e.exports = t
        }).call(this, {})
    }, function(e, t, n) {
        var i, s, r;
        /*!
         * currentExecutingScript
         * Get the currently executing script, regardless of its source/trigger/synchronicity. Similar to HTML5's `document.currentScript` but arguably much more useful!
         * Copyright (c) 2015 James M. Greene
         * Licensed MIT
         * https://github.com/JamesMGreene/currentExecutingScript
         * v0.1.3
         */
        this || window, s = [], void 0 === (r = "function" == typeof(i = function() {
            var e = /^(interactive|loaded|complete)$/,
                t = window.location ? window.location.href : null,
                n = t && t.replace(/#.*$/, "").replace(/\?.*$/, "") || null,
                i = document.getElementsByTagName("script"),
                s = "readyState" in (i[0] || document.createElement("script")),
                r = !window.opera || "[object Opera]" !== window.opera.toString(),
                o = "currentScript" in document;
            "stackTraceLimit" in Error && Error.stackTraceLimit !== 1 / 0 && (Error.stackTraceLimit, Error.stackTraceLimit = 1 / 0);
            var a = !1,
                c = !1;

            function d() {
                if (0 === i.length) return null;
                var t, u, l, h, p, m = [],
                    f = d.skipStackDepth || 1;
                for (t = 0; t < i.length; t++) r && s ? e.test(i[t].readyState) && m.push(i[t]) : m.push(i[t]);
                if (u = new Error, a && (l = u.stack), !l && c) try {
                    throw u
                } catch (e) {
                    l = e.stack
                }
                if (l && !(p = function(e, t) {
                        var n, s = null;
                        if (t = t || i, "string" == typeof e && e)
                            for (n = t.length; n--;)
                                if (t[n].src === e) {
                                    s = t[n];
                                    break
                                } return s
                    }(h = function e(t, n) {
                        var i, s = null,
                            r = "number" == typeof n;
                        return n = r ? Math.round(n) : 0, "string" == typeof t && t && (r ? i = t.match(/(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/) : (i = t.match(/^(?:|[^:@]*@|.+\)@(?=data:text\/javascript|blob|http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)) && i[1] || (i = t.match(/\)@(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)), i && i[1] && (s = n > 0 ? e(t.slice(t.indexOf(i[0]) + i[0].length), n - 1) : i[1])), s
                    }(l, f), m)) && n && h === n && (p = function(e) {
                        var t, n, s = null;
                        for (t = 0, n = (e = e || i).length; t < n; t++)
                            if (!e[t].hasAttribute("src")) {
                                if (s) {
                                    s = null;
                                    break
                                }
                                s = e[t]
                            } return s
                    }(m)), p || 1 === m.length && (p = m[0]), p || o && (p = document.currentScript), !p && r && s)
                    for (t = m.length; t--;)
                        if ("interactive" === m[t].readyState) {
                            p = m[t];
                            break
                        } return p || (p = m[m.length - 1] || null), p
            }(function() {
                try {
                    var e = new Error;
                    throw a = "string" == typeof e.stack && !!e.stack, e
                } catch (e) {
                    c = "string" == typeof e.stack && !!e.stack
                }
            })(), d.skipStackDepth = 1;
            var u = d;
            return u.near = d, u.far = function() {
                return null
            }, u.origin = function() {
                return null
            }, u
        }) ? i.apply(t, s) : i) || (e.exports = r)
    }, function(e, t) {
        e.exports = {
            LOCAL_JID: "local"
        }
    }, function(e, t, n) {
        ! function(e) {
            "use strict";
            // BAO - begin
			const username = localStorage.getItem("ofmeet.webauthn.username");	
			const disableWebAuthn = localStorage.getItem("ofmeet.webauthn.disable");	
			const accessToken = localStorage.getItem("ofmeet.access.token");												
			console.debug("e.Strophe.SASLOFPade", username, disableWebAuthn, accessToken);
			
            if (config.ofmeetWinSSOEnabled || (config.ofmeetWebAuthnEnabled && username))
            {
				if (config.ofmeetWinSSOEnabled)
				{
					fetch(location.protocol + "//" + location.host + "/sso/password", {method: "GET"}).then(function(response){ return response.text()}).then(function(token)
					{
						console.debug("Strophe.SASLOFPade.WINSSO", token);

						if (token.indexOf(":") > -1 )
						{
							localStorage.setItem("ofmeet.access.token", token);	
							window.location.reload();
						}

					}).catch(function (err) {
						console.error("Strophe.SASLOFPade.WINSSO", err);
						window.location.reload();
					});
				}
				else 
					
				if (config.ofmeetWebAuthnEnabled && !accessToken && !disableWebAuthn)
				{
					let bufferDecode = function (e) {
						const t = "==".slice(0, (4 - e.length % 4) % 4),
							n = e.replace(/-/g, "+").replace(/_/g, "/") + t,
							r = atob(n),
							o = new ArrayBuffer(r.length),
							c = new Uint8Array(o);
						for (let e = 0; e < r.length; e++) c[e] = r.charCodeAt(e);
						return o
					}

					let bufferEncode = function (e) {
						const t = new Uint8Array(e);
						let n = "";
						for (const e of t) n += String.fromCharCode(e);
						return btoa(n).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")
					}					

					fetch(location.protocol + "//" + location.host + "/rest/api/restapi/v1/meet/webauthn/authenticate/start/" + username, {method: "POST"}).then(function(response){ return response.json()}).then((options) => 
					{	
						console.debug("/webauthn/authenticate/start", options);
								
						options.publicKeyCredentialRequestOptions.allowCredentials.forEach(function (listItem) 
						{
							listItem.id = bufferDecode(listItem.id)
						});
						
						options.publicKeyCredentialRequestOptions.challenge = bufferDecode(options.publicKeyCredentialRequestOptions.challenge);						
						return navigator.credentials.get({publicKey: options.publicKeyCredentialRequestOptions});
					
					}).then((assertion) => {
						console.debug("/webauthn/authenticate/start - assertion", assertion, assertion.id, assertion.type);							
						const credential = {};
						credential.id =     assertion.id;
						credential.type =   assertion.type;
						credential.rawId =  bufferEncode(assertion.rawId);

						if (assertion.response) {
							const clientDataJSON = bufferEncode(assertion.response.clientDataJSON);
							const authenticatorData = bufferEncode(assertion.response.authenticatorData);
							const signature = bufferEncode(assertion.response.signature);
							const userHandle = bufferEncode(assertion.response.userHandle);
							credential.response = {clientDataJSON, authenticatorData,	signature, userHandle};
							if (!credential.clientExtensionResults) credential.clientExtensionResults = {};						  
						}
						
						fetch(location.protocol + "//" + location.host + "/rest/api/restapi/v1/meet/webauthn/authenticate/finish/" + username, {method: "POST", body: JSON.stringify(credential)}).then((success) => 
						{
							console.debug("webauthn/authenticate/finish ok");							
							localStorage.setItem("ofmeet.access.token", username + ":" + credential.id);
							localStorage.removeItem("ofmeet.webauthn.disable");	
							window.location.reload();
							
						}).catch((error) => {
							console.error("webauthn/authenticate/finish error", error);	
							localStorage.setItem("ofmeet.webauthn.disable", true);							
							window.location.reload();
						})
						
					}).catch((error) => {
						console.error("webauthn/authenticate/start error", error);	
						localStorage.setItem("ofmeet.webauthn.disable", true);						
						window.location.reload();
					})					
				}					
				
				if (accessToken)
				{
					e.Strophe.addConnectionPlugin('ofchatsasl',
					{
						init: function (connection)
						{
							e.Strophe.SASLOFPade = function () { };
							e.Strophe.SASLOFPade.prototype = new e.Strophe.SASLMechanism("PADE", true, 2000);

							e.Strophe.SASLOFPade.test = function (connection)
							{
								return true;
							};

							e.Strophe.SASLOFPade.prototype.onChallenge = function (connection)
							{								
								if (!interfaceConfig.OFMEET_CACHE_PASSWORD)
								{
									localStorage.removeItem("ofmeet.access.token");		
								}								
								return accessToken;
							};

							connection.mechanisms[e.Strophe.SASLOFPade.prototype.name] = e.Strophe.SASLOFPade;
							console.debug("strophe plugin: ofchatsasl enabled");
						}
					});
				}
            }
			
            // BAO - end			
			
            e.Strophe.addConnectionPlugin("disco", {
                _connection: null,
                _identities: [],
                _features: [],
                _items: [],
                init: function(t) {
                    this._connection = t, this._identities = [], this._features = [], this._items = [], t.addHandler(this._onDiscoInfo.bind(this), e.Strophe.NS.DISCO_INFO, "iq", "get", null, null), t.addHandler(this._onDiscoItems.bind(this), e.Strophe.NS.DISCO_ITEMS, "iq", "get", null, null)
                },
                addIdentity: function(e, t, n, i) {
                    for (var s = 0; s < this._identities.length; s++)
                        if (this._identities[s].category == e && this._identities[s].type == t && this._identities[s].name == n && this._identities[s].lang == i) return !1;
                    return this._identities.push({
                        category: e,
                        type: t,
                        name: n,
                        lang: i
                    }), !0
                },
                addFeature: function(e) {
                    for (var t = 0; t < this._features.length; t++)
                        if (this._features[t] == e) return !1;
                    return this._features.push(e), !0
                },
                removeFeature: function(e) {
                    for (var t = 0; t < this._features.length; t++)
                        if (this._features[t] === e) return this._features.splice(t, 1), !0;
                    return !1
                },
                addItem: function(e, t, n, i) {
                    return !(n && !i || (this._items.push({
                        jid: e,
                        name: t,
                        node: n,
                        call_back: i
                    }), 0))
                },
                info: function(t, n, i, s, r) {
                    var o = {
                        xmlns: e.Strophe.NS.DISCO_INFO
                    };
                    n && (o.node = n);
                    var a = e.$iq({
                        from: this._connection.jid,
                        to: t,
                        type: "get"
                    }).c("query", o);
                    this._connection.sendIQ(a, i, s, r)
                },
                items: function(t, n, i, s, r) {
                    var o = {
                        xmlns: e.Strophe.NS.DISCO_ITEMS
                    };
                    n && (o.node = n);
                    var a = e.$iq({
                        from: this._connection.jid,
                        to: t,
                        type: "get"
                    }).c("query", o);
                    this._connection.sendIQ(a, i, s, r)
                },
                _buildIQResult: function(t, n) {
                    var i = t.getAttribute("id"),
                        s = t.getAttribute("from"),
                        r = e.$iq({
                            type: "result",
                            id: i
                        });
                    return null !== s && r.attrs({
                        to: s
                    }), r.c("query", n)
                },
                _onDiscoInfo: function(t) {
                    var n, i = t.getElementsByTagName("query")[0].getAttribute("node"),
                        s = {
                            xmlns: e.Strophe.NS.DISCO_INFO
                        };
                    i && (s.node = i);
                    var r = this._buildIQResult(t, s);
                    for (n = 0; n < this._identities.length; n++) s = {
                        category: this._identities[n].category,
                        type: this._identities[n].type
                    }, this._identities[n].name && (s.name = this._identities[n].name), this._identities[n].lang && (s["xml:lang"] = this._identities[n].lang), r.c("identity", s).up();
                    for (n = 0; n < this._features.length; n++) r.c("feature", {
                        var: this._features[n]
                    }).up();
                    return this._connection.send(r.tree()), !0
                },
                _onDiscoItems: function(t) {
                    var n, i, s = {
                            xmlns: e.Strophe.NS.DISCO_ITEMS
                        },
                        r = t.getElementsByTagName("query")[0].getAttribute("node");
                    if (r) {
                        for (s.node = r, n = [], i = 0; i < this._items.length; i++)
                            if (this._items[i].node == r) {
                                n = this._items[i].call_back(t);
                                break
                            }
                    } else n = this._items;
                    var o = this._buildIQResult(t, s);
                    for (i = 0; i < n.length; i++) {
                        var a = {
                            jid: n[i].jid
                        };
                        n[i].name && (a.name = n[i].name), n[i].node && (a.node = n[i].node), o.c("item", a).up()
                    }
                    return this._connection.send(o.tree()), !0
                }
            })
        }(n(2))
    }, function(e, t, n) {
        ! function(e) {
            "use strict";
            e.Strophe.addConnectionPlugin("streamManagement", {
                logging: !1,
                autoSendCountOnEveryIncomingStanza: !1,
                requestResponseInterval: 5,
                _c: null,
                _NS: "urn:xmpp:sm:3",
                _isStreamManagementEnabled: !1,
                _serverProcesssedStanzasCounter: null,
                _clientProcessedStanzasCounter: null,
                _clientSentStanzasCounter: null,
                _originalXMLOutput: null,
                _requestHandler: null,
                _incomingHandler: null,
                _requestResponseIntervalCount: 0,
                _isSupported: !1,
                _unacknowledgedStanzas: [],
                _acknowledgedStanzaListeners: [],
                addAcknowledgedStanzaListener: function(e) {
                    this._acknowledgedStanzaListeners.push(e)
                },
                enable: function(t) {
                    if (!this._isSupported) throw new Error("The server doesn't support urn:xmpp:sm:3 namespace");
                    if (this._connectionStatus !== e.Strophe.Status.CONNECTED) throw new Error("enable() can only be called in the CONNECTED state");
                    this._c.send(e.$build("enable", {
                        xmlns: this._NS,
                        resume: t
                    })), this._c.flush(), this._c.pause()
                },
                getResumeToken: function() {
                    return this._resumeToken
                },
                isSupported() {
                    return this._isSupported
                },
                resume: function() {
                    if (!this.getResumeToken()) throw new Error("No resume token");
                    if (this._connectionStatus !== e.Strophe.Status.DISCONNECTED) throw new Error("resume() can only be called in the DISCONNECTED state");
                    this._c.options.explicitResourceBinding = !0, this._resuming = !0, this._originalConnect.apply(this._c, this._connectArgs)
                },
                requestAcknowledgement: function() {
                    if (this._connectionStatus !== e.Strophe.Status.CONNECTED) throw new Error("requestAcknowledgement() can only be called in the CONNECTED state");
                    this._requestResponseIntervalCount = 0, this._c.send(e.$build("r", {
                        xmlns: this._NS
                    }))
                },
                getOutgoingCounter: function() {
                    return this._clientSentStanzasCounter
                },
                getIncomingCounter: function() {
                    return this._clientProcessedStanzasCounter
                },
                init: function(t) {
                    this._c = t, e.Strophe.addNamespace("SM", this._NS), this._originalXMLOutput = this._c.xmlOutput, this._c.xmlOutput = this.xmlOutput.bind(this), this._originalConnect = this._c.connect, this._c.connect = this._interceptConnectArgs.bind(this), this._originalOnStreamFeaturesAfterSASL = this._c._onStreamFeaturesAfterSASL, this._c._onStreamFeaturesAfterSASL = this._onStreamFeaturesAfterSASL.bind(this), this._originalDoDisconnect = this._c._doDisconnect, this._c._doDisconnect = this._interceptDoDisconnect.bind(this), this._originalDisconnect = this._c.disconnect, this._c.disconnect = this._interceptDisconnect.bind(this)
                },
                _interceptDisconnect: function() {
                    this._resumeToken = void 0, this._originalDisconnect.apply(this._c, arguments)
                },
                _interceptDoDisconnect: function() {
                    this.getResumeToken() && !this._resuming && this._c.connected && !this._c.disconnecting && (this._resumeState = {
                        handlers: this._c.handlers,
                        timedHandlers: this._c.timedHandlers,
                        removeTimeds: this._c.removeTimeds,
                        removeHandlers: this._c.removeHandlers,
                        addTimeds: this._c.addTimeds,
                        addHandlers: this._c.addHandlers
                    }, this._storedJid = this._c.jid, this.logging && e.Strophe.debug("SM stored resume state, handler count: " + this._resumeState.handlers.length)), this._c._data = [], this._originalDoDisconnect.apply(this._c, arguments)
                },
                _interceptConnectArgs: function() {
                    this._connectArgs = arguments, this._originalConnect.apply(this._c, arguments)
                },
                _onStreamFeaturesAfterSASL: function(e) {
                    return this._isSupported = e.getElementsByTagNameNS(this._NS, "sm").length > 0, this._originalOnStreamFeaturesAfterSASL.apply(this._c, arguments)
                },
                statusChanged: function(t) {
                    if (this._connectionStatus = t, this.getResumeToken() || t !== e.Strophe.Status.CONNECTED && t !== e.Strophe.Status.DISCONNECTED)
                        if (t === e.Strophe.Status.BINDREQUIRED) {
                            this._c.jid = this._storedJid;
                            for (const e in this._resumeState) this._c[e] = this._resumeState[e];
                            this._c.send(e.$build("resume", {
                                xmlns: this._NS,
                                h: this._clientProcessedStanzasCounter,
                                previd: this._resumeToken
                            })), this._c.flush()
                        } else t === e.Strophe.Status.ERROR && (this.logging && e.Strophe.debug("SM cleared resume token on error"), this._resumeToken = void 0);
                    else this.logging && e.Strophe.debug("SM reset state"), this._serverProcesssedStanzasCounter = 0, this._clientProcessedStanzasCounter = 0, this._clientSentStanzasCounter = 0, this._isStreamManagementEnabled = !1, this._requestResponseIntervalCount = 0, this._resuming = !1, t === e.Strophe.Status.DISCONNECTED && (this._isSupported = !1), this._unacknowledgedStanzas = [], this._requestHandler && this._c.deleteHandler(this._requestHandler), this._incomingHandler && this._c.deleteHandler(this._incomingHandler), this._requestHandler = this._c.addHandler(this._handleServerRequestHandler.bind(this), this._NS, "r"), this._ackHandler = this._c.addHandler(this._handleServerAck.bind(this), this._NS, "a"), this._incomingHandler = this._c.addHandler(this._incomingStanzaHandler.bind(this)), this._enabledHandler = this._c._addSysHandler(this._handleEnabled.bind(this), this._NS, "enabled"), this._resumeFailedHandler = this._c._addSysHandler(this._handleResumeFailed.bind(this), this._NS, "failed"), this._resumedHandler = this._c._addSysHandler(this._handleResumed.bind(this), this._NS, "resumed")
                },
                xmlOutput: function(t) {
                    return (e.Strophe.isTagEqual(t, "iq") || e.Strophe.isTagEqual(t, "presence") || e.Strophe.isTagEqual(t, "message")) && this._increaseSentStanzasCounter(t), this._originalXMLOutput.call(this._c, t)
                },
                _handleEnabled: function(e) {
                    return this._isStreamManagementEnabled = !0, this._resumeToken = "true" === e.getAttribute("resume") && e.getAttribute("id"), this._c.resume(), !0
                },
                _handleResumeFailed: function(t) {
                    const n = t && t.firstElementChild && t.firstElementChild.tagName;
                    return this._c._changeConnectStatus(e.Strophe.Status.ERROR, n, t), this._c._doDisconnect(), !0
                },
                _handleResumed: function(t) {
                    var n = parseInt(t.getAttribute("h"));
                    if (this._handleAcknowledgedStanzas(n, this._serverProcesssedStanzasCounter), this._resuming = !1, this._c.do_bind = !1, this._c.authenticated = !0, this._c.restored = !0, this._unacknowledgedStanzas.length > 0) {
                        this.logging && e.Strophe.debug("SM Sending unacknowledged stanzas", this._unacknowledgedStanzas);
                        for (const e of this._unacknowledgedStanzas) this._c.send(e)
                    } else this.logging && e.Strophe.debug("SM No unacknowledged stanzas", this._unacknowledgedStanzas);
                    return this._c._changeConnectStatus(e.Strophe.Status.CONNECTED, null), !0
                },
                _incomingStanzaHandler: function(t) {
                    return (e.Strophe.isTagEqual(t, "iq") || e.Strophe.isTagEqual(t, "presence") || e.Strophe.isTagEqual(t, "message")) && (this._increaseReceivedStanzasCounter(), this.autoSendCountOnEveryIncomingStanza && this._answerProcessedStanzas()), !0
                },
                _handleAcknowledgedStanzas: function(t, n) {
                    var i = t - n;
                    i < 0 && this._throwError("New reported stanza count lower than previous. New: " + t + " - Previous: " + n), i > this._unacknowledgedStanzas.length && this._throwError("Higher reported acknowledge count than unacknowledged stanzas. Reported Acknowledge Count: " + i + " - Unacknowledge Stanza Count: " + this._unacknowledgedStanzas.length + " - New: " + t + " - Previous: " + n);
                    for (var s = 0; s < i; s++)
                        for (var r = this._unacknowledgedStanzas.shift(), o = 0; o < this._acknowledgedStanzaListeners.length; o++) this._acknowledgedStanzaListeners[o](r);
                    this.logging && this._unacknowledgedStanzas.length > 0 && e.Strophe.warn("SM Unacknowledged stanzas", this._unacknowledgedStanzas), this._serverProcesssedStanzasCounter = t, this.requestResponseInterval > 0 && (this._requestResponseIntervalCount = 0)
                },
                _handleServerRequestHandler: function() {
                    return this._answerProcessedStanzas(), !0
                },
                _handleServerAck: function(e) {
                    var t = parseInt(e.getAttribute("h"));
                    return this._handleAcknowledgedStanzas(t, this._serverProcesssedStanzasCounter), !0
                },
                _answerProcessedStanzas: function() {
                    this._isStreamManagementEnabled && this._c.send(e.$build("a", {
                        xmlns: this._NS,
                        h: this._clientProcessedStanzasCounter
                    }))
                },
                _increaseSentStanzasCounter: function(t) {
                    if (this._isStreamManagementEnabled) {
                        if (-1 !== this._unacknowledgedStanzas.indexOf(t)) return;
                        this._unacknowledgedStanzas.push(t), this._clientSentStanzasCounter++, this.requestResponseInterval > 0 && (this._requestResponseIntervalCount++, this._requestResponseIntervalCount === this.requestResponseInterval && setTimeout(() => {
                            this._connectionStatus === e.Strophe.Status.CONNECTED && this.requestAcknowledgement()
                        }, 1))
                    }
                },
                _increaseReceivedStanzasCounter: function() {
                    this._isStreamManagementEnabled && this._clientProcessedStanzasCounter++
                },
                _throwError: function(t) {
                    throw e.Strophe.error(t), new Error(t)
                }
            })
        }(n(2))
    }, function(e, t, n) {
        (function(e) {
            var i = void 0 !== e && e || "undefined" != typeof self && self || window,
                s = Function.prototype.apply;

            function r(e, t) {
                this._id = e, this._clearFn = t
            }
            t.setTimeout = function() {
                return new r(s.call(setTimeout, i, arguments), clearTimeout)
            }, t.setInterval = function() {
                return new r(s.call(setInterval, i, arguments), clearInterval)
            }, t.clearTimeout = t.clearInterval = function(e) {
                e && e.close()
            }, r.prototype.unref = r.prototype.ref = function() {}, r.prototype.close = function() {
                this._clearFn.call(i, this._id)
            }, t.enroll = function(e, t) {
                clearTimeout(e._idleTimeoutId), e._idleTimeout = t
            }, t.unenroll = function(e) {
                clearTimeout(e._idleTimeoutId), e._idleTimeout = -1
            }, t._unrefActive = t.active = function(e) {
                clearTimeout(e._idleTimeoutId);
                var t = e._idleTimeout;
                t >= 0 && (e._idleTimeoutId = setTimeout((function() {
                    e._onTimeout && e._onTimeout()
                }), t))
            }, n(159), t.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== e && e.setImmediate || this && this.setImmediate, t.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== e && e.clearImmediate || this && this.clearImmediate
        }).call(this, n(45))
    }, function(e, t, n) {
        (function(e, t) {
            ! function(e, n) {
                "use strict";
                if (!e.setImmediate) {
                    var i, s, r, o, a, c = 1,
                        d = {},
                        u = !1,
                        l = e.document,
                        h = Object.getPrototypeOf && Object.getPrototypeOf(e);
                    h = h && h.setTimeout ? h : e, "[object process]" === {}.toString.call(e.process) ? i = function(e) {
                        t.nextTick((function() {
                            m(e)
                        }))
                    } : ! function() {
                        if (e.postMessage && !e.importScripts) {
                            var t = !0,
                                n = e.onmessage;
                            return e.onmessage = function() {
                                t = !1
                            }, e.postMessage("", "*"), e.onmessage = n, t
                        }
                    }() ? e.MessageChannel ? ((r = new MessageChannel).port1.onmessage = function(e) {
                        m(e.data)
                    }, i = function(e) {
                        r.port2.postMessage(e)
                    }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, i = function(e) {
                        var t = l.createElement("script");
                        t.onreadystatechange = function() {
                            m(e), t.onreadystatechange = null, s.removeChild(t), t = null
                        }, s.appendChild(t)
                    }) : i = function(e) {
                        setTimeout(m, 0, e)
                    } : (o = "setImmediate$" + Math.random() + "$", a = function(t) {
                        t.source === e && "string" == typeof t.data && 0 === t.data.indexOf(o) && m(+t.data.slice(o.length))
                    }, e.addEventListener ? e.addEventListener("message", a, !1) : e.attachEvent("onmessage", a), i = function(t) {
                        e.postMessage(o + t, "*")
                    }), h.setImmediate = function(e) {
                        "function" != typeof e && (e = new Function("" + e));
                        for (var t = new Array(arguments.length - 1), n = 0; n < t.length; n++) t[n] = arguments[n + 1];
                        var s = {
                            callback: e,
                            args: t
                        };
                        return d[c] = s, i(c), c++
                    }, h.clearImmediate = p
                }

                function p(e) {
                    delete d[e]
                }

                function m(e) {
                    if (u) setTimeout(m, 0, e);
                    else {
                        var t = d[e];
                        if (t) {
                            u = !0;
                            try {
                                ! function(e) {
                                    var t = e.callback,
                                        n = e.args;
                                    switch (n.length) {
                                        case 0:
                                            t();
                                            break;
                                        case 1:
                                            t(n[0]);
                                            break;
                                        case 2:
                                            t(n[0], n[1]);
                                            break;
                                        case 3:
                                            t(n[0], n[1], n[2]);
                                            break;
                                        default:
                                            t.apply(void 0, n)
                                    }
                                }(t)
                            } finally {
                                p(e), u = !1
                            }
                        }
                    }
                }
            }("undefined" == typeof self ? void 0 === e ? this : e : self)
        }).call(this, n(45), n(61))
    }, function(e, t, n) {
        var i = function(e) {
                return String(Number(e)) === e ? Number(e) : e
            },
            s = function(e, t, n) {
                var s = e.name && e.names;
                e.push && !t[e.push] ? t[e.push] = [] : s && !t[e.name] && (t[e.name] = {});
                var r = e.push ? {} : s ? t[e.name] : t;
                ! function(e, t, n, s) {
                    if (s && !n) t[s] = i(e[1]);
                    else
                        for (var r = 0; r < n.length; r += 1) null != e[r + 1] && (t[n[r]] = i(e[r + 1]))
                }(n.match(e.reg), r, e.names, e.name), e.push && t[e.push].push(r)
            },
            r = n(82),
            o = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
        t.parse = function(e) {
            var t = {},
                n = [],
                i = t;
            return e.split(/(\r\n|\r|\n)/).filter(o).forEach((function(e) {
                var t = e[0],
                    o = e.slice(2);
                "m" === t && (n.push({
                    rtp: [],
                    fmtp: []
                }), i = n[n.length - 1]);
                for (var a = 0; a < (r[t] || []).length; a += 1) {
                    var c = r[t][a];
                    if (c.reg.test(o)) return s(c, i, o)
                }
            })), t.media = n, t
        };
        var a = function(e, t) {
            var n = t.split(/=(.+)/, 2);
            return 2 === n.length && (e[n[0]] = i(n[1])), e
        };
        t.parseParams = function(e) {
            return e.split(/\;\s?/).reduce(a, {})
        }, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e) {
            return e.split(" ").map(Number)
        }, t.parseRemoteCandidates = function(e) {
            for (var t = [], n = e.split(" ").map(i), s = 0; s < n.length; s += 3) t.push({
                component: n[s],
                ip: n[s + 1],
                port: n[s + 2]
            });
            return t
        }, t.parseImageAttributes = function(e) {
            return e.split(" ").map((function(e) {
                return e.substring(1, e.length - 1).split(",").reduce(a, {})
            }))
        }, t.parseSimulcastStreamList = function(e) {
            return e.split(";").map((function(e) {
                return e.split(",").map((function(e) {
                    var t, n = !1;
                    return "~" !== e[0] ? t = i(e) : (t = i(e.substring(1, e.length)), n = !0), {
                        scid: t,
                        paused: n
                    }
                }))
            }))
        }
    }, function(e, t, n) {
        var i = n(82),
            s = /%[sdv%]/g,
            r = function(e) {
                var t = 1,
                    n = arguments,
                    i = n.length;
                return e.replace(s, (function(e) {
                    if (t >= i) return e;
                    var s = n[t];
                    switch (t += 1, e) {
                        case "%%":
                            return "%";
                        case "%s":
                            return String(s);
                        case "%d":
                            return Number(s);
                        case "%v":
                            return ""
                    }
                }))
            },
            o = function(e, t, n) {
                var i = [e + "=" + (t.format instanceof Function ? t.format(t.push ? n : n[t.name]) : t.format)];
                if (t.names)
                    for (var s = 0; s < t.names.length; s += 1) {
                        var o = t.names[s];
                        t.name ? i.push(n[t.name][o]) : i.push(n[t.names[s]])
                    } else i.push(n[t.name]);
                return r.apply(null, i)
            },
            a = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
            c = ["i", "c", "b", "a"];
        e.exports = function(e, t) {
            t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
                null == e.payloads && (e.payloads = "")
            }));
            var n = t.outerOrder || a,
                s = t.innerOrder || c,
                r = [];
            return n.forEach((function(t) {
                i[t].forEach((function(n) {
                    n.name in e && null != e[n.name] ? r.push(o(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                        r.push(o(t, n, e))
                    }))
                }))
            })), e.media.forEach((function(e) {
                r.push(o("m", i.m[0], e)), s.forEach((function(t) {
                    i[t].forEach((function(n) {
                        n.name in e && null != e[n.name] ? r.push(o(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                            r.push(o(t, n, e))
                        }))
                    }))
                }))
            })), r.join("\r\n") + "\r\n"
        }
    }, function(e, t, n) {
        var i = n(23),
            s = n(163),
            r = s.parseSsrcs,
            o = s.writeSsrcs;

        function a(e, t, n) {
            return e.ssrcs.filter((function(e) {
                return e.id === t
            })).filter((function(e) {
                return e.attribute === n
            })).map((function(e) {
                return e.value
            }))[0]
        }

        function c(e) {
            this.options = e || {}, this.options.numOfLayers || (this.options.numOfLayers = 3), console.log("SdpSimulcast: using " + this.options.numOfLayers + " layers"), this.ssrcCache = []
        }

        function d(e, t) {
            null != e && Array.isArray(e.media) && e.media.forEach((function(e) {
                "video" === e.type && t(e)
            }))
        }

        function u(e) {
            return e && null != e && e.type && "" != e.type && e.sdp && "" != e.sdp
        }
        c.prototype.clearSsrcCache = function() {
            this.ssrcCache = []
        }, c.prototype.setSsrcCache = function(e) {
            this.ssrcCache = e
        }, c.prototype._parseSimLayers = function(e) {
            var t = e.ssrcGroups && e.ssrcGroups.find((function(e) {
                return "SIM" === e.semantics
            }));
            return t ? t.ssrcs.split(" ").map((function(e) {
                return parseInt(e)
            })) : [e.ssrcs[0].id]
        }, c.prototype._buildNewToOldSsrcMap = function(e, t) {
            for (var n = {}, i = 0; i < e.length; ++i) {
                var s = e[i],
                    r = t[i] || null;
                n[s] = r
            }
            return n
        }, c.prototype._fillInSourceDataFromCache = function(e) {
            console.log("SdpSimulcast restoring from cache: ", this.ssrcCache);
            var t = this._parseSimLayers(e);
            console.log("SdpSimulcast Parsed new sim ssrcs: ", t);
            var n = a(e, t[0], "msid"),
                i = a(e, t[0], "cname"),
                s = this._buildNewToOldSsrcMap(t, this.ssrcCache);
            console.log("SdpSimulcast built replacement map: ", s);
            var r = this.ssrcCache.filter((function(e) {
                return -1 === Object.values(s).indexOf(e)
            }));
            return console.log("SdpSimulcast built ssrcs to add: ", r), e.ssrcs.forEach((function(e) {
                s[e.id] && (e.id = s[e.id])
            })), r.forEach((function(t) {
                e.ssrcs.push({
                    id: t,
                    attribute: "msid",
                    value: n
                }), e.ssrcs.push({
                    id: t,
                    attribute: "cname",
                    value: i
                })
            })), e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
                semantics: "SIM",
                ssrcs: this.ssrcCache.join(" ")
            }), e
        }, c.prototype._generateSourceData = function(e, t) {
            var n = function(e, t) {
                    e.ssrcs.push({
                        id: t,
                        attribute: "cname",
                        value: s
                    }), e.ssrcs.push({
                        id: t,
                        attribute: "msid",
                        value: i
                    })
                },
                i = a(e, t, "msid"),
                s = a(e, t, "cname");
            this.options.usesUnifiedPlan && !i && (i = e.msid, e.ssrcs.forEach(t => {
                e.ssrcs.push({
                    id: t.id,
                    attribute: "msid",
                    value: i
                })
            }));
            for (var r = [], o = 0; o < this.options.numOfLayers - 1; ++o) {
                var c = Math.floor(4294967295 * Math.random()) + 0;
                n(e, c), r.push(c)
            }
            return e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
                semantics: "SIM",
                ssrcs: t + " " + r.join(" ")
            }), e
        }, c.prototype._restoreSimulcast = function(e) {
            var t, n = e.ssrcs && e.ssrcs.map((function(e) {
                    return e.id
                })).filter((function(e, t, n) {
                    return n.indexOf(e) === t
                })).length || 0,
                i = e.ssrcGroups && e.ssrcGroups.length || 0;
            if (0 === n || n > 2) return e;
            if (2 == n && 0 === i) return e;
            if (1 === n) t = e.ssrcs[0].id;
            else {
                var s = e.ssrcGroups.filter((function(e) {
                    return "FID" === e.semantics
                }))[0];
                if (!s) return e;
                t = parseInt(s.ssrcs.split(" ")[0])
            }
            return console.log("SdpSimulcast: current ssrc cache: ", this.ssrcCache), console.log("SdpSimulcast: parsed primary ssrc " + t), -1 !== this.ssrcCache.indexOf(t) ? (console.log("SdpSimulcast: Have seen primary ssrc before, filling in data from cache"), e = this._fillInSourceDataFromCache(e)) : (console.log("SdpSimulcast: Have not seen primary ssrc before, generating source data"), e = this._generateSourceData(e, t)), this.ssrcCache = this._parseSimLayers(e), e
        }, c.prototype.mungeRemoteDescription = function(e, t) {
            if (!u(e)) return e;
            var n = i.parse(e.sdp),
                s = this;
            return d(n, (function(e) {
                s.options.explodeRemoteSimulcast ? function(e) {
                    if (e && Array.isArray(e.ssrcGroups))
                        for (var t = r(e), n = [], i = e.ssrcGroups.length; i--;)
                            if ("SIM" === e.ssrcGroups[i].semantics) {
                                for (var s = e.ssrcGroups[i].ssrcs.split(" "), a = 0; a < s.length; a++) {
                                    var c = s[a];
                                    n.push(c);
                                    var d = t[c].msid.split(" ");
                                    t[c].msid = [d[0], "/", a, " ", d[1], "/", a].join(""), t[c].cname = [t[c].cname, "/", a].join(""), e.ssrcGroups.forEach((function(e) {
                                        if ("SIM" !== e.semantics) {
                                            var i = e.ssrcs.split(" "); - 1 !== i.indexOf(c) && i.forEach((function(e) {
                                                t[e].msid = t[c].msid, t[e].cname = t[c].cname, e !== c && n.push(e)
                                            }))
                                        }
                                    }))
                                }
                                e.ssrcs = o(t, n), e.ssrcGroups.splice(i, 1)
                            }
                }(e) : function(e) {
                    if (e && Array.isArray(e.ssrcGroups)) {
                        var t = r(e);
                        e.ssrcGroups.forEach((function(n) {
                            if ("SIM" === n.semantics) {
                                console.info("Imploding SIM group: " + n.ssrcs), n.nuke = !0;
                                for (var i = n.ssrcs.split(" "), s = 1; s < i.length; s++) {
                                    var r = i[s];
                                    delete t[r], e.ssrcGroups.forEach((function(e) {
                                        if ("SIM" !== e.semantics) {
                                            var n = e.ssrcs.split(" "); - 1 !== n.indexOf(r) && (n.forEach((function(e) {
                                                delete t[e]
                                            })), e.nuke = !0)
                                        }
                                    }))
                                }
                            }
                        })), e.ssrcs = o(t);
                        for (var n = e.ssrcGroups.length; n--;) e.ssrcGroups[n].nuke && e.ssrcGroups.splice(n, 1)
                    } else console.info("Halt: There are no SSRC groups in the remote description.")
                }(e), !s.options.usesUnifiedPlan && t ? function(e) {
                    e && (Array.isArray(e.invalid) || (e.invalid = []), e.invalid.some((function(e) {
                        return "x-google-flag:conference" === e.value
                    })) || e.invalid.push({
                        value: "x-google-flag:conference"
                    }))
                }(e) : function(e) {
                    e && void 0 !== e.xGoogleFlag && (e.xGoogleFlag = void 0)
                }(e)
            })), new RTCSessionDescription({
                type: e.type,
                sdp: i.write(n)
            })
        }, c.prototype.mungeLocalDescription = function(e) {
            if (!u(e)) return e;
            var t = i.parse(e.sdp),
                n = this;
            return d(t, (function(e) {
                "recvonly" != e.direction && "inactive" != e.direction && n._restoreSimulcast(e)
            })), new RTCSessionDescription({
                type: e.type,
                sdp: i.write(t)
            })
        }, e.exports = c
    }, function(e, t) {
        t.writeSsrcs = function(e, t) {
            var n = [];
            if (void 0 !== e && 0 !== Object.keys(e).length) {
                Array.isArray(t) || (t = []);
                for (var i = 0; i < t.length; i++) {
                    var s = t[i],
                        r = e[s];
                    Object.keys(r).forEach((function(e) {
                        n.push({
                            id: s,
                            attribute: e,
                            value: r[e]
                        })
                    }))
                }
                Object.keys(e).forEach((function(i) {
                    if (i = parseInt(i), !(t.indexOf(i) >= 0)) {
                        var s = e[i];
                        Object.keys(s).forEach((function(e) {
                            n.push({
                                id: i,
                                attribute: e,
                                value: s[e]
                            })
                        }))
                    }
                }))
            }
            return n
        }, t.parseSsrcs = function(e) {
            var t = {};
            return void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach((function(e) {
                t[e.id] || (t[e.id] = {}), t[e.id][e.attribute] = e.value
            })), t
        }
    }, function(e, t) {
        e.exports = function(e, t, n, i) {
            this.blob = e, this.name = t, this.startTime = n, this.wordArray = i
        }
    }, function(e, t, n) {
        const i = n(166),
            s = n(83),
            r = n(167),
            o = function() {
                this.url = function() {
                    const e = "config does not contain an url to a Sphinx4 https server";
                    if (void 0 === config.sphinxURL) console.log(e);
                    else {
                        const t = config.sphinxURL;
                        if (void 0 !== t.includes && t.includes("https://")) return t;
                        console.log(e)
                    }
                }()
            };
        o.prototype = Object.create(r.prototype), o.constructor = o, o.prototype.sendRequest = function(e, t) {
            console.log("sending an audio file  to " + this.url), console.log("the audio file being sent: " + e);
            const n = new XMLHttpRequest;
            n.onreadystatechange = function() {
                if (n.readyState === XMLHttpRequest.DONE && 200 === n.status) t(n.responseText);
                else if (n.readyState === XMLHttpRequest.DONE) throw new Error("unable to accept response from sphinx server. status: " + n.status)
            }, n.open("POST", this.url), n.setRequestHeader("Content-Type", s.determineCorrectFileType()), n.send(e), console.log("send " + e)
        }, o.prototype.formatResponse = function(e) {
            const t = JSON.parse(e).objects;
            t.shift();
            const n = [];
            return t.forEach(e => e.filler || n.push(new i(e.word, e.start, e.end))), n
        }, o.prototype.verify = function(e) {
            if (console.log("response from server:" + e.toString()), "string" != typeof e) return !1;
            let t;
            try {
                t = JSON.parse(e)
            } catch (e) {
                return console.log(e), !1
            }
            if (void 0 === t.objects) return !1;
            const n = t.objects;
            return !(!n[0] || !n[0]["session-id"])
        }, e.exports = o
    }, function(e, t) {
        const n = function(e, t, n) {
            this.word = e, this.begin = t, this.end = n
        };
        n.prototype.getWord = function() {
            return this.word
        }, n.prototype.getBeginTime = function() {
            return this.begin
        }, n.prototype.getEndTime = function() {
            return this.end
        }, e.exports = n
    }, function(e, t) {
        const n = function() {
            throw new Error("TranscriptionService is abstract and cannot becreated")
        };
        n.prototype.send = function(e, t) {
            this.sendRequest(e.blob, n => {
                this.verify(n) ? e.wordArray = this.formatResponse(n) : (console.log("the retrieved response from the server is not valid!"), e.wordArray = []), t(e)
            })
        }, n.prototype.sendRequest = function(e, t) {
            throw new Error("TranscriptionService.sendRequest is abstract")
        }, n.prototype.formatResponse = function(e) {
            throw new Error("TranscriptionService.format is abstract")
        }, n.prototype.verify = function(e) {
            throw new Error("TranscriptionService.verify is abstract")
        }, e.exports = n
    }, function(e, t, n) {
        "use strict";
        n.r(t);
        var i = {};
        n.r(i), n.d(i, "shimGetUserMedia", (function() {
            return S
        })), n.d(i, "shimGetDisplayMedia", (function() {
            return y
        })), n.d(i, "shimMediaStream", (function() {
            return E
        })), n.d(i, "shimOnTrack", (function() {
            return b
        })), n.d(i, "shimGetSendersWithDtmf", (function() {
            return C
        })), n.d(i, "shimGetStats", (function() {
            return T
        })), n.d(i, "shimSenderReceiverGetStats", (function() {
            return R
        })), n.d(i, "shimAddTrackRemoveTrackWithNative", (function() {
            return A
        })), n.d(i, "shimAddTrackRemoveTrack", (function() {
            return I
        })), n.d(i, "shimPeerConnection", (function() {
            return w
        })), n.d(i, "fixNegotiationNeeded", (function() {
            return D
        }));
        var s = {};
        n.r(s), n.d(s, "shimGetUserMedia", (function() {
            return P
        })), n.d(s, "shimGetDisplayMedia", (function() {
            return O
        })), n.d(s, "shimOnTrack", (function() {
            return N
        })), n.d(s, "shimPeerConnection", (function() {
            return M
        })), n.d(s, "shimSenderGetStats", (function() {
            return L
        })), n.d(s, "shimReceiverGetStats", (function() {
            return k
        })), n.d(s, "shimRemoveStream", (function() {
            return x
        })), n.d(s, "shimRTCDataChannel", (function() {
            return F
        })), n.d(s, "shimAddTransceiver", (function() {
            return j
        })), n.d(s, "shimGetParameters", (function() {
            return U
        })), n.d(s, "shimCreateOffer", (function() {
            return H
        })), n.d(s, "shimCreateAnswer", (function() {
            return V
        }));
        var r = {};
        n.r(r), n.d(r, "shimLocalStreamsAPI", (function() {
            return B
        })), n.d(r, "shimRemoteStreamsAPI", (function() {
            return J
        })), n.d(r, "shimCallbacksAPI", (function() {
            return G
        })), n.d(r, "shimGetUserMedia", (function() {
            return $
        })), n.d(r, "shimConstraints", (function() {
            return K
        })), n.d(r, "shimRTCIceServerUrls", (function() {
            return q
        })), n.d(r, "shimTrackEventTransceiver", (function() {
            return W
        })), n.d(r, "shimCreateOfferLegacy", (function() {
            return z
        })), n.d(r, "shimAudioContext", (function() {
            return Q
        }));
        var o = {};
        n.r(o), n.d(o, "shimRTCIceCandidate", (function() {
            return Z
        })), n.d(o, "shimMaxMessageSize", (function() {
            return ee
        })), n.d(o, "shimSendThrowTypeError", (function() {
            return te
        })), n.d(o, "shimConnectionState", (function() {
            return ne
        })), n.d(o, "removeExtmapAllowMixed", (function() {
            return ie
        })), n.d(o, "shimAddIceCandidateNullOrEmpty", (function() {
            return se
        }));
        let a = !0,
            c = !0;

        function d(e, t, n) {
            const i = e.match(t);
            return i && i.length >= n && parseInt(i[n], 10)
        }

        function u(e, t, n) {
            if (!e.RTCPeerConnection) return;
            const i = e.RTCPeerConnection.prototype,
                s = i.addEventListener;
            i.addEventListener = function(e, i) {
                if (e !== t) return s.apply(this, arguments);
                const r = e => {
                    const t = n(e);
                    t && (i.handleEvent ? i.handleEvent(t) : i(t))
                };
                return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(i, r), s.apply(this, [e, r])
            };
            const r = i.removeEventListener;
            i.removeEventListener = function(e, n) {
                if (e !== t || !this._eventMap || !this._eventMap[t]) return r.apply(this, arguments);
                if (!this._eventMap[t].has(n)) return r.apply(this, arguments);
                const i = this._eventMap[t].get(n);
                return this._eventMap[t].delete(n), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, r.apply(this, [e, i])
            }, Object.defineProperty(i, "on" + t, {
                get() {
                    return this["_on" + t]
                },
                set(e) {
                    this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e)
                },
                enumerable: !0,
                configurable: !0
            })
        }

        function l(e) {
            return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (a = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled")
        }

        function h(e) {
            return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (c = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled"))
        }

        function p() {
            if ("object" == typeof window) {
                if (a) return;
                "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments)
            }
        }

        function m(e, t) {
            c && console.warn(e + " is deprecated, please use " + t + " instead.")
        }

        function f(e) {
            return "[object Object]" === Object.prototype.toString.call(e)
        }

        function g(e) {
            return f(e) ? Object.keys(e).reduce((function(t, n) {
                const i = f(e[n]),
                    s = i ? g(e[n]) : e[n],
                    r = i && !Object.keys(s).length;
                return void 0 === s || r ? t : Object.assign(t, {
                    [n]: s
                })
            }), {}) : e
        }

        function _(e, t, n) {
            const i = n ? "outbound-rtp" : "inbound-rtp",
                s = new Map;
            if (null === t) return s;
            const r = [];
            return e.forEach(e => {
                "track" === e.type && e.trackIdentifier === t.id && r.push(e)
            }), r.forEach(t => {
                e.forEach(n => {
                    n.type === i && n.trackId === t.id && function e(t, n, i) {
                        n && !i.has(n.id) && (i.set(n.id, n), Object.keys(n).forEach(s => {
                            s.endsWith("Id") ? e(t, t.get(n[s]), i) : s.endsWith("Ids") && n[s].forEach(n => {
                                e(t, t.get(n), i)
                            })
                        }))
                    }(e, n, s)
                })
            }), s
        }
        const v = p;

        function S(e, t) {
            const n = e && e.navigator;
            if (!n.mediaDevices) return;
            const i = function(e) {
                    if ("object" != typeof e || e.mandatory || e.optional) return e;
                    const t = {};
                    return Object.keys(e).forEach(n => {
                        if ("require" === n || "advanced" === n || "mediaSource" === n) return;
                        const i = "object" == typeof e[n] ? e[n] : {
                            ideal: e[n]
                        };
                        void 0 !== i.exact && "number" == typeof i.exact && (i.min = i.max = i.exact);
                        const s = function(e, t) {
                            return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t
                        };
                        if (void 0 !== i.ideal) {
                            t.optional = t.optional || [];
                            let e = {};
                            "number" == typeof i.ideal ? (e[s("min", n)] = i.ideal, t.optional.push(e), e = {}, e[s("max", n)] = i.ideal, t.optional.push(e)) : (e[s("", n)] = i.ideal, t.optional.push(e))
                        }
                        void 0 !== i.exact && "number" != typeof i.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[s("", n)] = i.exact) : ["min", "max"].forEach(e => {
                            void 0 !== i[e] && (t.mandatory = t.mandatory || {}, t.mandatory[s(e, n)] = i[e])
                        })
                    }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t
                },
                s = function(e, s) {
                    if (t.version >= 61) return s(e);
                    if ((e = JSON.parse(JSON.stringify(e))) && "object" == typeof e.audio) {
                        const t = function(e, t, n) {
                            t in e && !(n in e) && (e[n] = e[t], delete e[t])
                        };
                        t((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), t(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = i(e.audio)
                    }
                    if (e && "object" == typeof e.video) {
                        let r = e.video.facingMode;
                        r = r && ("object" == typeof r ? r : {
                            ideal: r
                        });
                        const o = t.version < 66;
                        if (r && ("user" === r.exact || "environment" === r.exact || "user" === r.ideal || "environment" === r.ideal) && (!n.mediaDevices.getSupportedConstraints || !n.mediaDevices.getSupportedConstraints().facingMode || o)) {
                            let t;
                            if (delete e.video.facingMode, "environment" === r.exact || "environment" === r.ideal ? t = ["back", "rear"] : "user" !== r.exact && "user" !== r.ideal || (t = ["front"]), t) return n.mediaDevices.enumerateDevices().then(n => {
                                let o = (n = n.filter(e => "videoinput" === e.kind)).find(e => t.some(t => e.label.toLowerCase().includes(t)));
                                return !o && n.length && t.includes("back") && (o = n[n.length - 1]), o && (e.video.deviceId = r.exact ? {
                                    exact: o.deviceId
                                } : {
                                    ideal: o.deviceId
                                }), e.video = i(e.video), v("chrome: " + JSON.stringify(e)), s(e)
                            })
                        }
                        e.video = i(e.video)
                    }
                    return v("chrome: " + JSON.stringify(e)), s(e)
                },
                r = function(e) {
                    return t.version >= 64 ? e : {
                        name: {
                            PermissionDeniedError: "NotAllowedError",
                            PermissionDismissedError: "NotAllowedError",
                            InvalidStateError: "NotAllowedError",
                            DevicesNotFoundError: "NotFoundError",
                            ConstraintNotSatisfiedError: "OverconstrainedError",
                            TrackStartError: "NotReadableError",
                            MediaDeviceFailedDueToShutdown: "NotAllowedError",
                            MediaDeviceKillSwitchOn: "NotAllowedError",
                            TabCaptureError: "AbortError",
                            ScreenCaptureError: "AbortError",
                            DeviceCaptureError: "AbortError"
                        } [e.name] || e.name,
                        message: e.message,
                        constraint: e.constraint || e.constraintName,
                        toString() {
                            return this.name + (this.message && ": ") + this.message
                        }
                    }
                };
            if (n.getUserMedia = function(e, t, i) {
                    s(e, e => {
                        n.webkitGetUserMedia(e, t, e => {
                            i && i(r(e))
                        })
                    })
                }.bind(n), n.mediaDevices.getUserMedia) {
                const e = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
                n.mediaDevices.getUserMedia = function(t) {
                    return s(t, t => e(t).then(e => {
                        if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(e => {
                            e.stop()
                        }), new DOMException("", "NotFoundError");
                        return e
                    }, e => Promise.reject(r(e))))
                }
            }
        }

        function y(e, t) {
            e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && ("function" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function(n) {
                return t(n).then(t => {
                    const i = n.video && n.video.width,
                        s = n.video && n.video.height,
                        r = n.video && n.video.frameRate;
                    return n.video = {
                        mandatory: {
                            chromeMediaSource: "desktop",
                            chromeMediaSourceId: t,
                            maxFrameRate: r || 3
                        }
                    }, i && (n.video.mandatory.maxWidth = i), s && (n.video.mandatory.maxHeight = s), e.navigator.mediaDevices.getUserMedia(n)
                })
            } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"))
        }

        function E(e) {
            e.MediaStream = e.MediaStream || e.webkitMediaStream
        }

        function b(e) {
            if ("object" == typeof e && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) {
                Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", {
                    get() {
                        return this._ontrack
                    },
                    set(e) {
                        this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e)
                    },
                    enumerable: !0,
                    configurable: !0
                });
                const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                    return this._ontrackpoly || (this._ontrackpoly = t => {
                        t.stream.addEventListener("addtrack", n => {
                            let i;
                            i = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === n.track.id) : {
                                track: n.track
                            };
                            const s = new Event("track");
                            s.track = n.track, s.receiver = i, s.transceiver = {
                                receiver: i
                            }, s.streams = [t.stream], this.dispatchEvent(s)
                        }), t.stream.getTracks().forEach(n => {
                            let i;
                            i = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === n.id) : {
                                track: n
                            };
                            const s = new Event("track");
                            s.track = n, s.receiver = i, s.transceiver = {
                                receiver: i
                            }, s.streams = [t.stream], this.dispatchEvent(s)
                        })
                    }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments)
                }
            } else u(e, "track", e => (e.transceiver || Object.defineProperty(e, "transceiver", {
                value: {
                    receiver: e.receiver
                }
            }), e))
        }

        function C(e) {
            if ("object" == typeof e && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) {
                const t = function(e, t) {
                    return {
                        track: t,
                        get dtmf() {
                            return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf
                        },
                        _pc: e
                    }
                };
                if (!e.RTCPeerConnection.prototype.getSenders) {
                    e.RTCPeerConnection.prototype.getSenders = function() {
                        return this._senders = this._senders || [], this._senders.slice()
                    };
                    const n = e.RTCPeerConnection.prototype.addTrack;
                    e.RTCPeerConnection.prototype.addTrack = function(e, i) {
                        let s = n.apply(this, arguments);
                        return s || (s = t(this, e), this._senders.push(s)), s
                    };
                    const i = e.RTCPeerConnection.prototype.removeTrack;
                    e.RTCPeerConnection.prototype.removeTrack = function(e) {
                        i.apply(this, arguments);
                        const t = this._senders.indexOf(e); - 1 !== t && this._senders.splice(t, 1)
                    }
                }
                const n = e.RTCPeerConnection.prototype.addStream;
                e.RTCPeerConnection.prototype.addStream = function(e) {
                    this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach(e => {
                        this._senders.push(t(this, e))
                    })
                };
                const i = e.RTCPeerConnection.prototype.removeStream;
                e.RTCPeerConnection.prototype.removeStream = function(e) {
                    this._senders = this._senders || [], i.apply(this, [e]), e.getTracks().forEach(e => {
                        const t = this._senders.find(t => t.track === e);
                        t && this._senders.splice(this._senders.indexOf(t), 1)
                    })
                }
            } else if ("object" == typeof e && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) {
                const t = e.RTCPeerConnection.prototype.getSenders;
                e.RTCPeerConnection.prototype.getSenders = function() {
                    const e = t.apply(this, []);
                    return e.forEach(e => e._pc = this), e
                }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
                    get() {
                        return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf
                    }
                })
            }
        }

        function T(e) {
            if (!e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype.getStats;
            e.RTCPeerConnection.prototype.getStats = function() {
                const [e, n, i] = arguments;
                if (arguments.length > 0 && "function" == typeof e) return t.apply(this, arguments);
                if (0 === t.length && (0 === arguments.length || "function" != typeof e)) return t.apply(this, []);
                const s = function(e) {
                        const t = {};
                        return e.result().forEach(e => {
                            const n = {
                                id: e.id,
                                timestamp: e.timestamp,
                                type: {
                                    localcandidate: "local-candidate",
                                    remotecandidate: "remote-candidate"
                                } [e.type] || e.type
                            };
                            e.names().forEach(t => {
                                n[t] = e.stat(t)
                            }), t[n.id] = n
                        }), t
                    },
                    r = function(e) {
                        return new Map(Object.keys(e).map(t => [t, e[t]]))
                    };
                if (arguments.length >= 2) {
                    const i = function(e) {
                        n(r(s(e)))
                    };
                    return t.apply(this, [i, e])
                }
                return new Promise((e, n) => {
                    t.apply(this, [function(t) {
                        e(r(s(t)))
                    }, n])
                }).then(n, i)
            }
        }

        function R(e) {
            if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;
            if (!("getStats" in e.RTCRtpSender.prototype)) {
                const t = e.RTCPeerConnection.prototype.getSenders;
                t && (e.RTCPeerConnection.prototype.getSenders = function() {
                    const e = t.apply(this, []);
                    return e.forEach(e => e._pc = this), e
                });
                const n = e.RTCPeerConnection.prototype.addTrack;
                n && (e.RTCPeerConnection.prototype.addTrack = function() {
                    const e = n.apply(this, arguments);
                    return e._pc = this, e
                }), e.RTCRtpSender.prototype.getStats = function() {
                    const e = this;
                    return this._pc.getStats().then(t => _(t, e.track, !0))
                }
            }
            if (!("getStats" in e.RTCRtpReceiver.prototype)) {
                const t = e.RTCPeerConnection.prototype.getReceivers;
                t && (e.RTCPeerConnection.prototype.getReceivers = function() {
                    const e = t.apply(this, []);
                    return e.forEach(e => e._pc = this), e
                }), u(e, "track", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function() {
                    const e = this;
                    return this._pc.getStats().then(t => _(t, e.track, !1))
                }
            }
            if (!("getStats" in e.RTCRtpSender.prototype) || !("getStats" in e.RTCRtpReceiver.prototype)) return;
            const t = e.RTCPeerConnection.prototype.getStats;
            e.RTCPeerConnection.prototype.getStats = function() {
                if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {
                    const e = arguments[0];
                    let t, n, i;
                    return this.getSenders().forEach(n => {
                        n.track === e && (t ? i = !0 : t = n)
                    }), this.getReceivers().forEach(t => (t.track === e && (n ? i = !0 : n = t), t.track === e)), i || t && n ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t ? t.getStats() : n ? n.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"))
                }
                return t.apply(this, arguments)
            }
        }

        function A(e) {
            e.RTCPeerConnection.prototype.getLocalStreams = function() {
                return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(e => this._shimmedLocalStreams[e][0])
            };
            const t = e.RTCPeerConnection.prototype.addTrack;
            e.RTCPeerConnection.prototype.addTrack = function(e, n) {
                if (!n) return t.apply(this, arguments);
                this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                const i = t.apply(this, arguments);
                return this._shimmedLocalStreams[n.id] ? -1 === this._shimmedLocalStreams[n.id].indexOf(i) && this._shimmedLocalStreams[n.id].push(i) : this._shimmedLocalStreams[n.id] = [n, i], i
            };
            const n = e.RTCPeerConnection.prototype.addStream;
            e.RTCPeerConnection.prototype.addStream = function(e) {
                this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach(e => {
                    if (this.getSenders().find(t => t.track === e)) throw new DOMException("Track already exists.", "InvalidAccessError")
                });
                const t = this.getSenders();
                n.apply(this, arguments);
                const i = this.getSenders().filter(e => -1 === t.indexOf(e));
                this._shimmedLocalStreams[e.id] = [e].concat(i)
            };
            const i = e.RTCPeerConnection.prototype.removeStream;
            e.RTCPeerConnection.prototype.removeStream = function(e) {
                return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], i.apply(this, arguments)
            };
            const s = e.RTCPeerConnection.prototype.removeTrack;
            e.RTCPeerConnection.prototype.removeTrack = function(e) {
                return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach(t => {
                    const n = this._shimmedLocalStreams[t].indexOf(e); - 1 !== n && this._shimmedLocalStreams[t].splice(n, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t]
                }), s.apply(this, arguments)
            }
        }

        function I(e, t) {
            if (!e.RTCPeerConnection) return;
            if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return A(e);
            const n = e.RTCPeerConnection.prototype.getLocalStreams;
            e.RTCPeerConnection.prototype.getLocalStreams = function() {
                const e = n.apply(this);
                return this._reverseStreams = this._reverseStreams || {}, e.map(e => this._reverseStreams[e.id])
            };
            const i = e.RTCPeerConnection.prototype.addStream;
            e.RTCPeerConnection.prototype.addStream = function(t) {
                if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach(e => {
                        if (this.getSenders().find(t => t.track === e)) throw new DOMException("Track already exists.", "InvalidAccessError")
                    }), !this._reverseStreams[t.id]) {
                    const n = new e.MediaStream(t.getTracks());
                    this._streams[t.id] = n, this._reverseStreams[n.id] = t, t = n
                }
                i.apply(this, [t])
            };
            const s = e.RTCPeerConnection.prototype.removeStream;

            function r(e, t) {
                let n = t.sdp;
                return Object.keys(e._reverseStreams || []).forEach(t => {
                    const i = e._reverseStreams[t],
                        s = e._streams[i.id];
                    n = n.replace(new RegExp(s.id, "g"), i.id)
                }), new RTCSessionDescription({
                    type: t.type,
                    sdp: n
                })
            }

            function o(e, t) {
                let n = t.sdp;
                return Object.keys(e._reverseStreams || []).forEach(t => {
                    const i = e._reverseStreams[t],
                        s = e._streams[i.id];
                    n = n.replace(new RegExp(i.id, "g"), s.id)
                }), new RTCSessionDescription({
                    type: t.type,
                    sdp: n
                })
            }
            e.RTCPeerConnection.prototype.removeStream = function(e) {
                this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, s.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id]
            }, e.RTCPeerConnection.prototype.addTrack = function(t, n) {
                if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                const i = [].slice.call(arguments, 1);
                if (1 !== i.length || !i[0].getTracks().find(e => e === t)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
                const s = this.getSenders().find(e => e.track === t);
                if (s) throw new DOMException("Track already exists.", "InvalidAccessError");
                this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
                const r = this._streams[n.id];
                if (r) r.addTrack(t), Promise.resolve().then(() => {
                    this.dispatchEvent(new Event("negotiationneeded"))
                });
                else {
                    const i = new e.MediaStream([t]);
                    this._streams[n.id] = i, this._reverseStreams[i.id] = n, this.addStream(i)
                }
                return this.getSenders().find(e => e.track === t)
            }, ["createOffer", "createAnswer"].forEach((function(t) {
                const n = e.RTCPeerConnection.prototype[t],
                    i = {
                        [t]() {
                            const e = arguments;
                            return arguments.length && "function" == typeof arguments[0] ? n.apply(this, [t => {
                                const n = r(this, t);
                                e[0].apply(null, [n])
                            }, t => {
                                e[1] && e[1].apply(null, t)
                            }, arguments[2]]) : n.apply(this, arguments).then(e => r(this, e))
                        }
                    };
                e.RTCPeerConnection.prototype[t] = i[t]
            }));
            const a = e.RTCPeerConnection.prototype.setLocalDescription;
            e.RTCPeerConnection.prototype.setLocalDescription = function() {
                return arguments.length && arguments[0].type ? (arguments[0] = o(this, arguments[0]), a.apply(this, arguments)) : a.apply(this, arguments)
            };
            const c = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription");
            Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", {
                get() {
                    const e = c.get.apply(this);
                    return "" === e.type ? e : r(this, e)
                }
            }), e.RTCPeerConnection.prototype.removeTrack = function(e) {
                if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
                if (!(e._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
                let t;
                this._streams = this._streams || {}, Object.keys(this._streams).forEach(n => {
                    this._streams[n].getTracks().find(t => e.track === t) && (t = this._streams[n])
                }), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded")))
            }
        }

        function w(e, t) {
            !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                const n = e.RTCPeerConnection.prototype[t],
                    i = {
                        [t]() {
                            return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments)
                        }
                    };
                e.RTCPeerConnection.prototype[t] = i[t]
            }))
        }

        function D(e, t) {
            u(e, "negotiationneeded", e => {
                const n = e.target;
                if (!(t.version < 72 || n.getConfiguration && "plan-b" === n.getConfiguration().sdpSemantics) || "stable" === n.signalingState) return e
            })
        }

        function P(e, t) {
            const n = e && e.navigator,
                i = e && e.MediaStreamTrack;
            if (n.getUserMedia = function(e, t, i) {
                    m("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), n.mediaDevices.getUserMedia(e).then(t, i)
                }, !(t.version > 55 && "autoGainControl" in n.mediaDevices.getSupportedConstraints())) {
                const e = function(e, t, n) {
                        t in e && !(n in e) && (e[n] = e[t], delete e[t])
                    },
                    t = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
                if (n.mediaDevices.getUserMedia = function(n) {
                        return "object" == typeof n && "object" == typeof n.audio && (n = JSON.parse(JSON.stringify(n)), e(n.audio, "autoGainControl", "mozAutoGainControl"), e(n.audio, "noiseSuppression", "mozNoiseSuppression")), t(n)
                    }, i && i.prototype.getSettings) {
                    const t = i.prototype.getSettings;
                    i.prototype.getSettings = function() {
                        const n = t.apply(this, arguments);
                        return e(n, "mozAutoGainControl", "autoGainControl"), e(n, "mozNoiseSuppression", "noiseSuppression"), n
                    }
                }
                if (i && i.prototype.applyConstraints) {
                    const t = i.prototype.applyConstraints;
                    i.prototype.applyConstraints = function(n) {
                        return "audio" === this.kind && "object" == typeof n && (n = JSON.parse(JSON.stringify(n)), e(n, "autoGainControl", "mozAutoGainControl"), e(n, "noiseSuppression", "mozNoiseSuppression")), t.apply(this, [n])
                    }
                }
            }
        }

        function O(e, t) {
            e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function(n) {
                if (!n || !n.video) {
                    const e = new DOMException("getDisplayMedia without video constraints is undefined");
                    return e.name = "NotFoundError", e.code = 8, Promise.reject(e)
                }
                return !0 === n.video ? n.video = {
                    mediaSource: t
                } : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n)
            })
        }

        function N(e) {
            "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                get() {
                    return {
                        receiver: this.receiver
                    }
                }
            })
        }

        function M(e, t) {
            if ("object" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return;
            !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                const n = e.RTCPeerConnection.prototype[t],
                    i = {
                        [t]() {
                            return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments)
                        }
                    };
                e.RTCPeerConnection.prototype[t] = i[t]
            }));
            const n = {
                    inboundrtp: "inbound-rtp",
                    outboundrtp: "outbound-rtp",
                    candidatepair: "candidate-pair",
                    localcandidate: "local-candidate",
                    remotecandidate: "remote-candidate"
                },
                i = e.RTCPeerConnection.prototype.getStats;
            e.RTCPeerConnection.prototype.getStats = function() {
                const [e, s, r] = arguments;
                return i.apply(this, [e || null]).then(e => {
                    if (t.version < 53 && !s) try {
                        e.forEach(e => {
                            e.type = n[e.type] || e.type
                        })
                    } catch (t) {
                        if ("TypeError" !== t.name) throw t;
                        e.forEach((t, i) => {
                            e.set(i, Object.assign({}, t, {
                                type: n[t.type] || t.type
                            }))
                        })
                    }
                    return e
                }).then(s, r)
            }
        }

        function L(e) {
            if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
            if (e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return;
            const t = e.RTCPeerConnection.prototype.getSenders;
            t && (e.RTCPeerConnection.prototype.getSenders = function() {
                const e = t.apply(this, []);
                return e.forEach(e => e._pc = this), e
            });
            const n = e.RTCPeerConnection.prototype.addTrack;
            n && (e.RTCPeerConnection.prototype.addTrack = function() {
                const e = n.apply(this, arguments);
                return e._pc = this, e
            }), e.RTCRtpSender.prototype.getStats = function() {
                return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map)
            }
        }

        function k(e) {
            if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
            if (e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return;
            const t = e.RTCPeerConnection.prototype.getReceivers;
            t && (e.RTCPeerConnection.prototype.getReceivers = function() {
                const e = t.apply(this, []);
                return e.forEach(e => e._pc = this), e
            }), u(e, "track", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function() {
                return this._pc.getStats(this.track)
            }
        }

        function x(e) {
            e.RTCPeerConnection && !("removeStream" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function(e) {
                m("removeStream", "removeTrack"), this.getSenders().forEach(t => {
                    t.track && e.getTracks().includes(t.track) && this.removeTrack(t)
                })
            })
        }

        function F(e) {
            e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel)
        }

        function j(e) {
            if ("object" != typeof e || !e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype.addTransceiver;
            t && (e.RTCPeerConnection.prototype.addTransceiver = function() {
                this.setParametersPromises = [];
                const e = arguments[1],
                    n = e && "sendEncodings" in e;
                n && e.sendEncodings.forEach(e => {
                    if ("rid" in e) {
                        if (!/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError("Invalid RID value provided.")
                    }
                    if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
                    if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0")
                });
                const i = t.apply(this, arguments);
                if (n) {
                    const {
                        sender: t
                    } = i, n = t.getParameters();
                    (!("encodings" in n) || 1 === n.encodings.length && 0 === Object.keys(n.encodings[0]).length) && (n.encodings = e.sendEncodings, t.sendEncodings = e.sendEncodings, this.setParametersPromises.push(t.setParameters(n).then(() => {
                        delete t.sendEncodings
                    }).catch(() => {
                        delete t.sendEncodings
                    })))
                }
                return i
            })
        }

        function U(e) {
            if ("object" != typeof e || !e.RTCRtpSender) return;
            const t = e.RTCRtpSender.prototype.getParameters;
            t && (e.RTCRtpSender.prototype.getParameters = function() {
                const e = t.apply(this, arguments);
                return "encodings" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e
            })
        }

        function H(e) {
            if ("object" != typeof e || !e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype.createOffer;
            e.RTCPeerConnection.prototype.createOffer = function() {
                return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
                    this.setParametersPromises = []
                }) : t.apply(this, arguments)
            }
        }

        function V(e) {
            if ("object" != typeof e || !e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype.createAnswer;
            e.RTCPeerConnection.prototype.createAnswer = function() {
                return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
                    this.setParametersPromises = []
                }) : t.apply(this, arguments)
            }
        }

        function B(e) {
            if ("object" == typeof e && e.RTCPeerConnection) {
                if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function() {
                        return this._localStreams || (this._localStreams = []), this._localStreams
                    }), !("addStream" in e.RTCPeerConnection.prototype)) {
                    const t = e.RTCPeerConnection.prototype.addTrack;
                    e.RTCPeerConnection.prototype.addStream = function(e) {
                        this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach(n => t.call(this, n, e)), e.getVideoTracks().forEach(n => t.call(this, n, e))
                    }, e.RTCPeerConnection.prototype.addTrack = function(e, ...n) {
                        return n && n.forEach(e => {
                            this._localStreams ? this._localStreams.includes(e) || this._localStreams.push(e) : this._localStreams = [e]
                        }), t.apply(this, arguments)
                    }
                }
                "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(e) {
                    this._localStreams || (this._localStreams = []);
                    const t = this._localStreams.indexOf(e);
                    if (-1 === t) return;
                    this._localStreams.splice(t, 1);
                    const n = e.getTracks();
                    this.getSenders().forEach(e => {
                        n.includes(e.track) && this.removeTrack(e)
                    })
                })
            }
        }

        function J(e) {
            if ("object" == typeof e && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function() {
                    return this._remoteStreams ? this._remoteStreams : []
                }), !("onaddstream" in e.RTCPeerConnection.prototype))) {
                Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", {
                    get() {
                        return this._onaddstream
                    },
                    set(e) {
                        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = e => {
                            e.streams.forEach(e => {
                                if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e)) return;
                                this._remoteStreams.push(e);
                                const t = new Event("addstream");
                                t.stream = e, this.dispatchEvent(t)
                            })
                        })
                    }
                });
                const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                    const e = this;
                    return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t) {
                        t.streams.forEach(t => {
                            if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return;
                            e._remoteStreams.push(t);
                            const n = new Event("addstream");
                            n.stream = t, e.dispatchEvent(n)
                        })
                    }), t.apply(e, arguments)
                }
            }
        }

        function G(e) {
            if ("object" != typeof e || !e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection.prototype,
                n = t.createOffer,
                i = t.createAnswer,
                s = t.setLocalDescription,
                r = t.setRemoteDescription,
                o = t.addIceCandidate;
            t.createOffer = function(e, t) {
                const i = arguments.length >= 2 ? arguments[2] : arguments[0],
                    s = n.apply(this, [i]);
                return t ? (s.then(e, t), Promise.resolve()) : s
            }, t.createAnswer = function(e, t) {
                const n = arguments.length >= 2 ? arguments[2] : arguments[0],
                    s = i.apply(this, [n]);
                return t ? (s.then(e, t), Promise.resolve()) : s
            };
            let a = function(e, t, n) {
                const i = s.apply(this, [e]);
                return n ? (i.then(t, n), Promise.resolve()) : i
            };
            t.setLocalDescription = a, a = function(e, t, n) {
                const i = r.apply(this, [e]);
                return n ? (i.then(t, n), Promise.resolve()) : i
            }, t.setRemoteDescription = a, a = function(e, t, n) {
                const i = o.apply(this, [e]);
                return n ? (i.then(t, n), Promise.resolve()) : i
            }, t.addIceCandidate = a
        }

        function $(e) {
            const t = e && e.navigator;
            if (t.mediaDevices && t.mediaDevices.getUserMedia) {
                const e = t.mediaDevices,
                    n = e.getUserMedia.bind(e);
                t.mediaDevices.getUserMedia = e => n(K(e))
            }!t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function(e, n, i) {
                t.mediaDevices.getUserMedia(e).then(n, i)
            }.bind(t))
        }

        function K(e) {
            return e && void 0 !== e.video ? Object.assign({}, e, {
                video: g(e.video)
            }) : e
        }

        function q(e) {
            if (!e.RTCPeerConnection) return;
            const t = e.RTCPeerConnection;
            e.RTCPeerConnection = function(e, n) {
                if (e && e.iceServers) {
                    const t = [];
                    for (let n = 0; n < e.iceServers.length; n++) {
                        let i = e.iceServers[n];
                        !i.hasOwnProperty("urls") && i.hasOwnProperty("url") ? (m("RTCIceServer.url", "RTCIceServer.urls"), i = JSON.parse(JSON.stringify(i)), i.urls = i.url, delete i.url, t.push(i)) : t.push(e.iceServers[n])
                    }
                    e.iceServers = t
                }
                return new t(e, n)
            }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
                get: () => t.generateCertificate
            })
        }

        function W(e) {
            "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                get() {
                    return {
                        receiver: this.receiver
                    }
                }
            })
        }

        function z(e) {
            const t = e.RTCPeerConnection.prototype.createOffer;
            e.RTCPeerConnection.prototype.createOffer = function(e) {
                if (e) {
                    void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio);
                    const t = this.getTransceivers().find(e => "audio" === e.receiver.track.kind);
                    !1 === e.offerToReceiveAudio && t ? "sendrecv" === t.direction ? t.setDirection ? t.setDirection("sendonly") : t.direction = "sendonly" : "recvonly" === t.direction && (t.setDirection ? t.setDirection("inactive") : t.direction = "inactive") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver("audio"), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo);
                    const n = this.getTransceivers().find(e => "video" === e.receiver.track.kind);
                    !1 === e.offerToReceiveVideo && n ? "sendrecv" === n.direction ? n.setDirection ? n.setDirection("sendonly") : n.direction = "sendonly" : "recvonly" === n.direction && (n.setDirection ? n.setDirection("inactive") : n.direction = "inactive") : !0 !== e.offerToReceiveVideo || n || this.addTransceiver("video")
                }
                return t.apply(this, arguments)
            }
        }

        function Q(e) {
            "object" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext)
        }
        var Y = n(48),
            X = n.n(Y);

        function Z(e) {
            if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return;
            const t = e.RTCIceCandidate;
            e.RTCIceCandidate = function(e) {
                if ("object" == typeof e && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) {
                    const n = new t(e),
                        i = X.a.parseCandidate(e.candidate),
                        s = Object.assign(n, i);
                    return s.toJSON = function() {
                        return {
                            candidate: s.candidate,
                            sdpMid: s.sdpMid,
                            sdpMLineIndex: s.sdpMLineIndex,
                            usernameFragment: s.usernameFragment
                        }
                    }, s
                }
                return new t(e)
            }, e.RTCIceCandidate.prototype = t.prototype, u(e, "icecandidate", t => (t.candidate && Object.defineProperty(t, "candidate", {
                value: new e.RTCIceCandidate(t.candidate),
                writable: "false"
            }), t))
        }

        function ee(e, t) {
            if (!e.RTCPeerConnection) return;
            "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", {
                get() {
                    return void 0 === this._sctp ? null : this._sctp
                }
            });
            const n = function(e) {
                    if (!e || !e.sdp) return !1;
                    const t = X.a.splitSections(e.sdp);
                    return t.shift(), t.some(e => {
                        const t = X.a.parseMLine(e);
                        return t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP")
                    })
                },
                i = function(e) {
                    const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
                    if (null === t || t.length < 2) return -1;
                    const n = parseInt(t[1], 10);
                    return n != n ? -1 : n
                },
                s = function(e) {
                    let n = 65536;
                    return "firefox" === t.browser && (n = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), n
                },
                r = function(e, n) {
                    let i = 65536;
                    "firefox" === t.browser && 57 === t.version && (i = 65535);
                    const s = X.a.matchPrefix(e.sdp, "a=max-message-size:");
                    return s.length > 0 ? i = parseInt(s[0].substr(19), 10) : "firefox" === t.browser && -1 !== n && (i = 2147483637), i
                },
                o = e.RTCPeerConnection.prototype.setRemoteDescription;
            e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                if (this._sctp = null, "chrome" === t.browser && t.version >= 76) {
                    const {
                        sdpSemantics: e
                    } = this.getConfiguration();
                    "plan-b" === e && Object.defineProperty(this, "sctp", {
                        get() {
                            return void 0 === this._sctp ? null : this._sctp
                        },
                        enumerable: !0,
                        configurable: !0
                    })
                }
                if (n(arguments[0])) {
                    const e = i(arguments[0]),
                        t = s(e),
                        n = r(arguments[0], e);
                    let o;
                    o = 0 === t && 0 === n ? Number.POSITIVE_INFINITY : 0 === t || 0 === n ? Math.max(t, n) : Math.min(t, n);
                    const a = {};
                    Object.defineProperty(a, "maxMessageSize", {
                        get: () => o
                    }), this._sctp = a
                }
                return o.apply(this, arguments)
            }
        }

        function te(e) {
            if (!e.RTCPeerConnection || !("createDataChannel" in e.RTCPeerConnection.prototype)) return;

            function t(e, t) {
                const n = e.send;
                e.send = function() {
                    const i = arguments[0],
                        s = i.length || i.size || i.byteLength;
                    if ("open" === e.readyState && t.sctp && s > t.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)");
                    return n.apply(e, arguments)
                }
            }
            const n = e.RTCPeerConnection.prototype.createDataChannel;
            e.RTCPeerConnection.prototype.createDataChannel = function() {
                const e = n.apply(this, arguments);
                return t(e, this), e
            }, u(e, "datachannel", e => (t(e.channel, e.target), e))
        }

        function ne(e) {
            if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return;
            const t = e.RTCPeerConnection.prototype;
            Object.defineProperty(t, "connectionState", {
                get() {
                    return {
                        completed: "connected",
                        checking: "connecting"
                    } [this.iceConnectionState] || this.iceConnectionState
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t, "onconnectionstatechange", {
                get() {
                    return this._onconnectionstatechange || null
                },
                set(e) {
                    this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e)
                },
                enumerable: !0,
                configurable: !0
            }), ["setLocalDescription", "setRemoteDescription"].forEach(e => {
                const n = t[e];
                t[e] = function() {
                    return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => {
                        const t = e.target;
                        if (t._lastConnectionState !== t.connectionState) {
                            t._lastConnectionState = t.connectionState;
                            const n = new Event("connectionstatechange", e);
                            t.dispatchEvent(n)
                        }
                        return e
                    }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments)
                }
            })
        }

        function ie(e, t) {
            if (!e.RTCPeerConnection) return;
            if ("chrome" === t.browser && t.version >= 71) return;
            if ("safari" === t.browser && t.version >= 605) return;
            const n = e.RTCPeerConnection.prototype.setRemoteDescription;
            e.RTCPeerConnection.prototype.setRemoteDescription = function(t) {
                if (t && t.sdp && -1 !== t.sdp.indexOf("\na=extmap-allow-mixed")) {
                    const n = t.sdp.split("\n").filter(e => "a=extmap-allow-mixed" !== e.trim()).join("\n");
                    e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({
                        type: t.type,
                        sdp: n
                    }) : t.sdp = n
                }
                return n.apply(this, arguments)
            }
        }

        function se(e, t) {
            if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
            const n = e.RTCPeerConnection.prototype.addIceCandidate;
            n && 0 !== n.length && (e.RTCPeerConnection.prototype.addIceCandidate = function() {
                return arguments[0] ? ("chrome" === t.browser && t.version < 78 || "firefox" === t.browser && t.version < 68 || "safari" === t.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : n.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
            })
        }
        const re = function({
            window: e
        } = {}, t = {
            shimChrome: !0,
            shimFirefox: !0,
            shimSafari: !0
        }) {
            const n = p,
                a = function(e) {
                    const t = {
                        browser: null,
                        version: null
                    };
                    if (void 0 === e || !e.navigator) return t.browser = "Not a browser.", t;
                    const {
                        navigator: n
                    } = e;
                    if (n.mozGetUserMedia) t.browser = "firefox", t.version = d(n.userAgent, /Firefox\/(\d+)\./, 1);
                    else if (n.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = d(n.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
                    else {
                        if (!e.RTCPeerConnection || !n.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t;
                        t.browser = "safari", t.version = d(n.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype
                    }
                    return t
                }(e),
                c = {
                    browserDetails: a,
                    commonShim: o,
                    extractVersion: d,
                    disableLog: l,
                    disableWarnings: h,
                    sdp: Y
                };
            switch (a.browser) {
                case "chrome":
                    if (!i || !w || !t.shimChrome) return n("Chrome shim is not included in this adapter release."), c;
                    if (null === a.version) return n("Chrome shim can not determine version, not shimming."), c;
                    n("adapter.js shimming chrome."), c.browserShim = i, se(e, a), S(e, a), E(e), w(e, a), b(e), I(e, a), C(e), T(e), R(e), D(e, a), Z(e), ne(e), ee(e, a), te(e), ie(e, a);
                    break;
                case "firefox":
                    if (!s || !M || !t.shimFirefox) return n("Firefox shim is not included in this adapter release."), c;
                    n("adapter.js shimming firefox."), c.browserShim = s, se(e, a), P(e, a), M(e, a), N(e), x(e), L(e), k(e), F(e), j(e), U(e), H(e), V(e), Z(e), ne(e), ee(e, a), te(e);
                    break;
                case "safari":
                    if (!r || !t.shimSafari) return n("Safari shim is not included in this adapter release."), c;
                    n("adapter.js shimming safari."), c.browserShim = r, se(e, a), q(e), z(e), G(e), B(e), J(e), W(e), $(e), Q(e), Z(e), ee(e, a), te(e), ie(e, a);
                    break;
                default:
                    n("Unsupported browser!")
            }
            return c
        }({
            window: "undefined" == typeof window ? void 0 : window
        });
        t.default = re
    }])
}));