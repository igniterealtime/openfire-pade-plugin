/*! For license information please see lib-jitsi-meet.min.js.LICENSE.txt */ ! function(e, t) {
	"object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.JitsiMeetJS = t() : e.JitsiMeetJS = t()
}(self, (function() {
	return (() => {
		var __webpack_modules__ = {
				4449: (e, t, n) => {
					const i = n(5369).Z;
					e.exports = function(e) {
						return "object" == typeof window.JitsiMeetJS ? Object.assign({}, window.JitsiMeetJS, e) : e
					}(i)
				},
				2444: e => {
					e.exports = class {
						constructor(e, t, n) {
							this._userId = e, this.setDisplayName(t), this._isLocalStats = n || !1, this.setDominantSpeaker(!1), this.totalDominantSpeakerTime = 0, this._dominantSpeakerStart = 0, this._isDominantSpeaker = !1, this._isSilent = !1, this._hasLeft = !1, this._faceLandmarks = []
						}
						getUserId() {
							return this._userId
						}
						getDisplayName() {
							return this.displayName
						}
						setDisplayName(e) {
							this.displayName = e
						}
						isLocalStats() {
							return this._isLocalStats
						}
						isDominantSpeaker() {
							return this._isDominantSpeaker
						}
						setDominantSpeaker(e, t) {
							if (this.isDominantSpeaker() || !e || t) {
								if (this.isDominantSpeaker())
									if (e) {
										if (this._isSilent && !t) this._dominantSpeakerStart = Date.now();
										else if (!this._isSilent && t) {
											const e = Date.now() - this._dominantSpeakerStart;
											this.totalDominantSpeakerTime += e, this._dominantSpeakerStart = 0
										}
									} else if (!this._isSilent) {
									const e = Date.now() - this._dominantSpeakerStart;
									this.totalDominantSpeakerTime += e, this._dominantSpeakerStart = 0
								}
							} else this._dominantSpeakerStart = Date.now();
							this._isDominantSpeaker = e, this._isSilent = t
						}
						getTotalDominantSpeakerTime() {
							let e = this.totalDominantSpeakerTime;
							return this.isDominantSpeaker() && !this._isSilent && (e += Date.now() - this._dominantSpeakerStart), e
						}
						hasLeft() {
							return this._hasLeft
						}
						markAsHasLeft() {
							this._hasLeft = !0, this.setDominantSpeaker(!1)
						}
						getFaceLandmarks() {
							return this._faceLandmarks
						}
						setFaceLandmarks(e) {
							this._faceLandmarks = e
						}
						addFaceLandmarks(e) {
							this._faceLandmarks.push(e)
						}
					}
				},
				4424: e => {
					e.exports = {
						getTokenAuthUrl: (e, t, n) => "string" != typeof e ? null : e.replace("{room}", t).replace("{roleUpgrade}", !0 === n)
					}
				},
				4832: e => {
					function t(e, t) {
						if (!e || !t || "function" != typeof e.addListener || "function" != typeof t.emit) throw new Error("Invalid arguments passed to EventEmitterForwarder");
						this.src = e, this.dest = t
					}
					t.prototype.forward = function() {
						for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
						const i = t[0];
						t[0] = this.dest, this.src.addListener(i, Function.prototype.bind.apply(this.dest.emit, t))
					}, e.exports = t
				},
				1023: e => {
					const t = [],
						n = window.onerror,
						i = window.onunhandledrejection;
					window.onerror = function() {
						for (var e = arguments.length, i = new Array(e), s = 0; s < e; s++) i[s] = arguments[s];
						t.forEach((e => e(...i))), n && n(...i)
					}, window.onunhandledrejection = function(e) {
						t.forEach((t => t(null, null, null, null, e.reason))), i && i(e)
					};
					const s = {
						addHandler(e) {
							t.push(e)
						},
						callErrorHandler(e) {
							const t = window.onerror;
							t && t(null, null, null, null, e)
						},
						callUnhandledRejectionHandler(e) {
							const t = window.onunhandledrejection;
							t && t(e)
						}
					};
					e.exports = s
				},
				5399: e => {
					function t(e, t) {
						return Math.floor(Math.random() * (t - e + 1)) + e
					}

					function n(e) {
						return e[t(0, e.length - 1)]
					}
					const i = {
						randomHexDigit: () => n("0123456789abcdef"),
						randomHexString(e) {
							let t = "";
							for (; e--;) t += this.randomHexDigit();
							return t
						},
						randomElement: n,
						randomAlphanumStr: function(e) {
							let t = "";
							for (let i = 0; i < e; i += 1) t += n("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
							return t
						},
						randomInt: t
					};
					e.exports = i
				},
				549: (e, t, n) => {
					const i = n(6799),
						s = {
							loadScript(e, t, n, s, r, o) {
								const a = document,
									c = "script",
									d = a.createElement(c),
									l = a.getElementsByTagName(c)[0];
								if (d.async = t, s) {
									const t = i();
									if (t) {
										const n = t.src,
											i = n.substring(0, n.lastIndexOf("/") + 1);
										n && i && (e = i + e)
									}
								}
								r && (d.onload = r), o && (d.onerror = o), d.src = e, n ? l.parentNode.insertBefore(d, l) : l.parentNode.appendChild(d)
							}
						};
					e.exports = s
				},
				2593: e => {
					e.exports = {
						integerHash: function(e) {
							if (!e) return 0;
							let t, n, i = 0;
							for (n = 0; n < e.length; n++) t = e.charCodeAt(n), i += t * Math.pow(31, e.length - 1 - n), i = Math.abs(0 | i);
							return i
						}
					}
				},
				6667: (e, t, n) => {
					const i = n(5399),
						s = ["Aaliyah", "Aaron", "Abagail", "Abbey", "Abbie", "Abbigail", "Abby", "Abdiel", "Abdul", "Abdullah", "Abe", "Abel", "Abelardo", "Abigail", "Abigale", "Abigayle", "Abner", "Abraham", "Ada", "Adah", "Adalberto", "Adaline", "Adam", "Adan", "Addie", "Addison", "Adela", "Adelbert", "Adele", "Adelia", "Adeline", "Adell", "Adella", "Adelle", "Aditya", "Adolf", "Adolfo", "Adolph", "Adolphus", "Adonis", "Adrain", "Adrian", "Adriana", "Adrianna", "Adriel", "Adrien", "Adrienne", "Afton", "Aglae", "Agnes", "Agustin", "Agustina", "Ahmad", "Ahmed", "Aida", "Aidan", "Aiden", "Aileen", "Aisha", "Aiyana", "Akeem", "Al", "Alaina", "Alan", "Alana", "Alanis", "Alanna", "Alayna", "Alba", "Albert", "Alberta", "Albertha", "Alberto", "Albin", "Albina", "Alda", "Alden", "Alec", "Aleen", "Alejandra", "Alejandrin", "Alek", "Alena", "Alene", "Alessandra", "Alessandro", "Alessia", "Aletha", "Alex", "Alexa", "Alexander", "Alexandra", "Alexandre", "Alexandrea", "Alexandria", "Alexandrine", "Alexandro", "Alexane", "Alexanne", "Alexie", "Alexis", "Alexys", "Alexzander", "Alf", "Alfonso", "Alfonzo", "Alford", "Alfred", "Alfreda", "Alfredo", "Ali", "Alia", "Alice", "Alicia", "Alisa", "Alisha", "Alison", "Alivia", "Aliya", "Aliyah", "Aliza", "Alize", "Allan", "Allen", "Allene", "Allie", "Allison", "Ally", "Alphonso", "Alta", "Althea", "Alva", "Alvah", "Alvena", "Alvera", "Alverta", "Alvina", "Alvis", "Alyce", "Alycia", "Alysa", "Alysha", "Alyson", "Alysson", "Amalia", "Amanda", "Amani", "Amara", "Amari", "Amaya", "Amber", "Ambrose", "Amelia", "Amelie", "Amely", "America", "Americo", "Amie", "Amina", "Amir", "Amira", "Amiya", "Amos", "Amparo", "Amy", "Amya", "Ana", "Anabel", "Anabelle", "Anahi", "Anais", "Anastacio", "Anastasia", "Anderson", "Andre", "Andreane", "Andreanne", "Andres", "Andrew", "Andy", "Angel", "Angela", "Angelica", "Angelina", "Angeline", "Angelita", "Angelo", "Angie", "Angus", "Anibal", "Anika", "Anissa", "Anita", "Aniya", "Aniyah", "Anjali", "Anna", "Annabel", "Annabell", "Annabelle", "Annalise", "Annamae", "Annamarie", "Anne", "Annetta", "Annette", "Annie", "Ansel", "Ansley", "Anthony", "Antoinette", "Antone", "Antonetta", "Antonette", "Antonia", "Antonietta", "Antonina", "Antonio", "Antwan", "Antwon", "Anya", "April", "Ara", "Araceli", "Aracely", "Arch", "Archibald", "Ardella", "Arden", "Ardith", "Arely", "Ari", "Ariane", "Arianna", "Aric", "Ariel", "Arielle", "Arjun", "Arlene", "Arlie", "Arlo", "Armand", "Armando", "Armani", "Arnaldo", "Arne", "Arno", "Arnold", "Arnoldo", "Arnulfo", "Aron", "Art", "Arthur", "Arturo", "Arvel", "Arvid", "Arvilla", "Aryanna", "Asa", "Asha", "Ashlee", "Ashleigh", "Ashley", "Ashly", "Ashlynn", "Ashton", "Ashtyn", "Asia", "Assunta", "Astrid", "Athena", "Aubree", "Aubrey", "Audie", "Audra", "Audreanne", "Audrey", "August", "Augusta", "Augustine", "Augustus", "Aurelia", "Aurelie", "Aurelio", "Aurore", "Austen", "Austin", "Austyn", "Autumn", "Ava", "Avery", "Avis", "Axel", "Ayana", "Ayden", "Ayla", "Aylin", "Baby", "Bailee", "Bailey", "Barbara", "Barney", "Baron", "Barrett", "Barry", "Bart", "Bartholome", "Barton", "Baylee", "Beatrice", "Beau", "Beaulah", "Bell", "Bella", "Belle", "Ben", "Benedict", "Benjamin", "Bennett", "Bennie", "Benny", "Benton", "Berenice", "Bernadette", "Bernadine", "Bernard", "Bernardo", "Berneice", "Bernhard", "Bernice", "Bernie", "Berniece", "Bernita", "Berry", "Bert", "Berta", "Bertha", "Bertram", "Bertrand", "Beryl", "Bessie", "Beth", "Bethany", "Bethel", "Betsy", "Bette", "Bettie", "Betty", "Bettye", "Beulah", "Beverly", "Bianka", "Bill", "Billie", "Billy", "Birdie", "Blair", "Blaise", "Blake", "Blanca", "Blanche", "Blaze", "Bo", "Bobbie", "Bobby", "Bonita", "Bonnie", "Boris", "Boyd", "Brad", "Braden", "Bradford", "Bradley", "Bradly", "Brady", "Braeden", "Brain", "Brandi", "Brando", "Brandon", "Brandt", "Brandy", "Brandyn", "Brannon", "Branson", "Brant", "Braulio", "Braxton", "Brayan", "Breana", "Breanna", "Breanne", "Brenda", "Brendan", "Brenden", "Brendon", "Brenna", "Brennan", "Brennon", "Brent", "Bret", "Brett", "Bria", "Brian", "Briana", "Brianne", "Brice", "Bridget", "Bridgette", "Bridie", "Brielle", "Brigitte", "Brionna", "Brisa", "Britney", "Brittany", "Brock", "Broderick", "Brody", "Brook", "Brooke", "Brooklyn", "Brooks", "Brown", "Bruce", "Bryana", "Bryce", "Brycen", "Bryon", "Buck", "Bud", "Buddy", "Buford", "Bulah", "Burdette", "Burley", "Burnice", "Buster", "Cade", "Caden", "Caesar", "Caitlyn", "Cale", "Caleb", "Caleigh", "Cali", "Calista", "Callie", "Camden", "Cameron", "Camila", "Camilla", "Camille", "Camren", "Camron", "Camryn", "Camylle", "Candace", "Candelario", "Candice", "Candida", "Candido", "Cara", "Carey", "Carissa", "Carlee", "Carleton", "Carley", "Carli", "Carlie", "Carlo", "Carlos", "Carlotta", "Carmel", "Carmela", "Carmella", "Carmelo", "Carmen", "Carmine", "Carol", "Carolanne", "Carole", "Carolina", "Caroline", "Carolyn", "Carolyne", "Carrie", "Carroll", "Carson", "Carter", "Cary", "Casandra", "Casey", "Casimer", "Casimir", "Casper", "Cassandra", "Cassandre", "Cassidy", "Cassie", "Catalina", "Caterina", "Catharine", "Catherine", "Cathrine", "Cathryn", "Cathy", "Cayla", "Ceasar", "Cecelia", "Cecil", "Cecile", "Cecilia", "Cedrick", "Celestine", "Celestino", "Celia", "Celine", "Cesar", "Chad", "Chadd", "Chadrick", "Chaim", "Chance", "Chandler", "Chanel", "Chanelle", "Charity", "Charlene", "Charles", "Charley", "Charlie", "Charlotte", "Chase", "Chasity", "Chauncey", "Chaya", "Chaz", "Chelsea", "Chelsey", "Chelsie", "Chesley", "Chester", "Chet", "Cheyanne", "Cheyenne", "Chloe", "Chris", "Christ", "Christa", "Christelle", "Christian", "Christiana", "Christina", "Christine", "Christop", "Christophe", "Christopher", "Christy", "Chyna", "Ciara", "Cicero", "Cielo", "Cierra", "Cindy", "Citlalli", "Clair", "Claire", "Clara", "Clarabelle", "Clare", "Clarissa", "Clark", "Claud", "Claude", "Claudia", "Claudie", "Claudine", "Clay", "Clemens", "Clement", "Clementina", "Clementine", "Clemmie", "Cleo", "Cleora", "Cleta", "Cletus", "Cleve", "Cleveland", "Clifford", "Clifton", "Clint", "Clinton", "Clotilde", "Clovis", "Cloyd", "Clyde", "Coby", "Cody", "Colby", "Cole", "Coleman", "Colin", "Colleen", "Collin", "Colt", "Colten", "Colton", "Columbus", "Concepcion", "Conner", "Connie", "Connor", "Conor", "Conrad", "Constance", "Constantin", "Consuelo", "Cooper", "Cora", "Coralie", "Corbin", "Cordelia", "Cordell", "Cordia", "Cordie", "Corene", "Corine", "Cornelius", "Cornell", "Corrine", "Cortez", "Cortney", "Cory", "Coty", "Courtney", "Coy", "Craig", "Crawford", "Creola", "Cristal", "Cristian", "Cristina", "Cristobal", "Cristopher", "Cruz", "Crystal", "Crystel", "Cullen", "Curt", "Curtis", "Cydney", "Cynthia", "Cyril", "Cyrus", "Dagmar", "Dahlia", "Daija", "Daisha", "Daisy", "Dakota", "Dale", "Dallas", "Dallin", "Dalton", "Damaris", "Dameon", "Damian", "Damien", "Damion", "Damon", "Dan", "Dana", "Dandre", "Dane", "D'angelo", "Dangelo", "Danial", "Daniela", "Daniella", "Danielle", "Danika", "Dannie", "Danny", "Dante", "Danyka", "Daphne", "Daphnee", "Daphney", "Darby", "Daren", "Darian", "Dariana", "Darien", "Dario", "Darion", "Darius", "Darlene", "Daron", "Darrel", "Darrell", "Darren", "Darrick", "Darrin", "Darrion", "Darron", "Darryl", "Darwin", "Daryl", "Dashawn", "Dasia", "Dave", "David", "Davin", "Davion", "Davon", "Davonte", "Dawn", "Dawson", "Dax", "Dayana", "Dayna", "Dayne", "Dayton", "Dean", "Deangelo", "Deanna", "Deborah", "Declan", "Dedric", "Dedrick", "Dee", "Deion", "Deja", "Dejah", "Dejon", "Dejuan", "Delaney", "Delbert", "Delfina", "Delia", "Delilah", "Dell", "Della", "Delmer", "Delores", "Delpha", "Delphia", "Delphine", "Delta", "Demarco", "Demarcus", "Demario", "Demetris", "Demetrius", "Demond", "Dena", "Denis", "Dennis", "Deon", "Deondre", "Deontae", "Deonte", "Dereck", "Derek", "Derick", "Deron", "Derrick", "Deshaun", "Deshawn", "Desiree", "Desmond", "Dessie", "Destany", "Destin", "Destinee", "Destiney", "Destini", "Destiny", "Devan", "Devante", "Deven", "Devin", "Devon", "Devonte", "Devyn", "Dewayne", "Dewitt", "Dexter", "Diamond", "Diana", "Dianna", "Diego", "Dillan", "Dillon", "Dimitri", "Dina", "Dino", "Dion", "Dixie", "Dock", "Dolly", "Dolores", "Domenic", "Domenica", "Domenick", "Domenico", "Domingo", "Dominic", "Dominique", "Don", "Donald", "Donato", "Donavon", "Donna", "Donnell", "Donnie", "Donny", "Dora", "Dorcas", "Dorian", "Doris", "Dorothea", "Dorothy", "Dorris", "Dortha", "Dorthy", "Doug", "Douglas", "Dovie", "Doyle", "Drake", "Drew", "Duane", "Dudley", "Dulce", "Duncan", "Durward", "Dustin", "Dusty", "Dwight", "Dylan", "Earl", "Earlene", "Earline", "Earnest", "Earnestine", "Easter", "Easton", "Ebba", "Ebony", "Ed", "Eda", "Edd", "Eddie", "Eden", "Edgar", "Edgardo", "Edison", "Edmond", "Edmund", "Edna", "Eduardo", "Edward", "Edwardo", "Edwin", "Edwina", "Edyth", "Edythe", "Effie", "Efrain", "Efren", "Eileen", "Einar", "Eino", "Eladio", "Elaina", "Elbert", "Elda", "Eldon", "Eldora", "Eldred", "Eldridge", "Eleanora", "Eleanore", "Eleazar", "Electa", "Elena", "Elenor", "Elenora", "Eleonore", "Elfrieda", "Eli", "Elian", "Eliane", "Elias", "Eliezer", "Elijah", "Elinor", "Elinore", "Elisa", "Elisabeth", "Elise", "Eliseo", "Elisha", "Elissa", "Eliza", "Elizabeth", "Ella", "Ellen", "Ellie", "Elliot", "Elliott", "Ellis", "Ellsworth", "Elmer", "Elmira", "Elmo", "Elmore", "Elna", "Elnora", "Elody", "Eloisa", "Eloise", "Elouise", "Eloy", "Elroy", "Elsa", "Else", "Elsie", "Elta", "Elton", "Elva", "Elvera", "Elvie", "Elvis", "Elwin", "Elwyn", "Elyse", "Elyssa", "Elza", "Emanuel", "Emelia", "Emelie", "Emely", "Emerald", "Emerson", "Emery", "Emie", "Emil", "Emile", "Emilia", "Emiliano", "Emilie", "Emilio", "Emily", "Emma", "Emmalee", "Emmanuel", "Emmanuelle", "Emmet", "Emmett", "Emmie", "Emmitt", "Emmy", "Emory", "Ena", "Enid", "Enoch", "Enola", "Enos", "Enrico", "Enrique", "Ephraim", "Era", "Eriberto", "Eric", "Erica", "Erich", "Erick", "Ericka", "Erik", "Erika", "Erin", "Erling", "Erna", "Ernest", "Ernestina", "Ernestine", "Ernesto", "Ernie", "Ervin", "Erwin", "Eryn", "Esmeralda", "Esperanza", "Esta", "Esteban", "Estefania", "Estel", "Estell", "Estella", "Estelle", "Estevan", "Esther", "Estrella", "Etha", "Ethan", "Ethel", "Ethelyn", "Ethyl", "Ettie", "Eudora", "Eugene", "Eugenia", "Eula", "Eulah", "Eulalia", "Euna", "Eunice", "Eusebio", "Eva", "Evalyn", "Evan", "Evangeline", "Evans", "Eve", "Eveline", "Evelyn", "Everardo", "Everett", "Everette", "Evert", "Evie", "Ewald", "Ewell", "Ezekiel", "Ezequiel", "Ezra", "Fabian", "Fabiola", "Fae", "Fannie", "Fanny", "Fatima", "Faustino", "Fausto", "Favian", "Fay", "Faye", "Federico", "Felicia", "Felicita", "Felicity", "Felipa", "Felipe", "Felix", "Felton", "Fermin", "Fern", "Fernando", "Ferne", "Fidel", "Filiberto", "Filomena", "Finn", "Fiona", "Flavie", "Flavio", "Fleta", "Fletcher", "Flo", "Florence", "Florencio", "Florian", "Florida", "Florine", "Flossie", "Floy", "Floyd", "Ford", "Forest", "Forrest", "Foster", "Frances", "Francesca", "Francesco", "Francis", "Francisca", "Francisco", "Franco", "Frank", "Frankie", "Franz", "Fred", "Freda", "Freddie", "Freddy", "Frederic", "Frederick", "Frederik", "Frederique", "Fredrick", "Fredy", "Freeda", "Freeman", "Freida", "Frida", "Frieda", "Friedrich", "Fritz", "Furman", "Gabe", "Gabriel", "Gabriella", "Gabrielle", "Gaetano", "Gage", "Gail", "Gardner", "Garett", "Garfield", "Garland", "Garnet", "Garnett", "Garret", "Garrett", "Garrick", "Garrison", "Garry", "Garth", "Gaston", "Gavin", "Gay", "Gayle", "Gaylord", "Gene", "General", "Genesis", "Genevieve", "Gennaro", "Genoveva", "Geo", "Geoffrey", "George", "Georgette", "Georgiana", "Georgianna", "Geovanni", "Geovanny", "Geovany", "Gerald", "Geraldine", "Gerard", "Gerardo", "Gerda", "Gerhard", "Germaine", "German", "Gerry", "Gerson", "Gertrude", "Gia", "Gianni", "Gideon", "Gilbert", "Gilberto", "Gilda", "Giles", "Gillian", "Gina", "Gino", "Giovani", "Giovanna", "Giovanni", "Giovanny", "Gisselle", "Giuseppe", "Gladyce", "Gladys", "Glen", "Glenda", "Glenna", "Glennie", "Gloria", "Godfrey", "Golda", "Golden", "Gonzalo", "Gordon", "Grace", "Gracie", "Graciela", "Grady", "Graham", "Grant", "Granville", "Grayce", "Grayson", "Green", "Greg", "Gregg", "Gregoria", "Gregorio", "Gregory", "Greta", "Gretchen", "Greyson", "Griffin", "Grover", "Guadalupe", "Gudrun", "Guido", "Guillermo", "Guiseppe", "Gunnar", "Gunner", "Gus", "Gussie", "Gust", "Gustave", "Guy", "Gwen", "Gwendolyn", "Hadley", "Hailee", "Hailey", "Hailie", "Hal", "Haleigh", "Haley", "Halie", "Halle", "Hallie", "Hank", "Hanna", "Hannah", "Hans", "Hardy", "Harley", "Harmon", "Harmony", "Harold", "Harrison", "Harry", "Harvey", "Haskell", "Hassan", "Hassie", "Hattie", "Haven", "Hayden", "Haylee", "Hayley", "Haylie", "Hazel", "Hazle", "Heath", "Heather", "Heaven", "Heber", "Hector", "Heidi", "Helen", "Helena", "Helene", "Helga", "Hellen", "Helmer", "Heloise", "Henderson", "Henri", "Henriette", "Henry", "Herbert", "Herman", "Hermann", "Hermina", "Herminia", "Herminio", "Hershel", "Herta", "Hertha", "Hester", "Hettie", "Hilario", "Hilbert", "Hilda", "Hildegard", "Hillard", "Hillary", "Hilma", "Hilton", "Hipolito", "Hiram", "Hobart", "Holden", "Hollie", "Hollis", "Holly", "Hope", "Horace", "Horacio", "Hortense", "Hosea", "Houston", "Howard", "Howell", "Hoyt", "Hubert", "Hudson", "Hugh", "Hulda", "Humberto", "Hunter", "Hyman", "Ian", "Ibrahim", "Icie", "Ida", "Idell", "Idella", "Ignacio", "Ignatius", "Ike", "Ila", "Ilene", "Iliana", "Ima", "Imani", "Imelda", "Immanuel", "Imogene", "Ines", "Irma", "Irving", "Irwin", "Isaac", "Isabel", "Isabell", "Isabella", "Isabelle", "Isac", "Isadore", "Isai", "Isaiah", "Isaias", "Isidro", "Ismael", "Isobel", "Isom", "Israel", "Issac", "Itzel", "Iva", "Ivah", "Ivory", "Ivy", "Izabella", "Izaiah", "Jabari", "Jace", "Jacey", "Jacinthe", "Jacinto", "Jack", "Jackeline", "Jackie", "Jacklyn", "Jackson", "Jacky", "Jaclyn", "Jacquelyn", "Jacques", "Jacynthe", "Jada", "Jade", "Jaden", "Jadon", "Jadyn", "Jaeden", "Jaida", "Jaiden", "Jailyn", "Jaime", "Jairo", "Jakayla", "Jake", "Jakob", "Jaleel", "Jalen", "Jalon", "Jalyn", "Jamaal", "Jamal", "Jamar", "Jamarcus", "Jamel", "Jameson", "Jamey", "Jamie", "Jamil", "Jamir", "Jamison", "Jammie", "Jan", "Jana", "Janae", "Jane", "Janelle", "Janessa", "Janet", "Janice", "Janick", "Janie", "Janis", "Janiya", "Jannie", "Jany", "Jaquan", "Jaquelin", "Jaqueline", "Jared", "Jaren", "Jarod", "Jaron", "Jarred", "Jarrell", "Jarret", "Jarrett", "Jarrod", "Jarvis", "Jasen", "Jasmin", "Jason", "Jasper", "Jaunita", "Javier", "Javon", "Javonte", "Jay", "Jayce", "Jaycee", "Jayda", "Jayde", "Jayden", "Jaydon", "Jaylan", "Jaylen", "Jaylin", "Jaylon", "Jayme", "Jayne", "Jayson", "Jazlyn", "Jazmin", "Jazmyn", "Jazmyne", "Jean", "Jeanette", "Jeanie", "Jeanne", "Jed", "Jedediah", "Jedidiah", "Jeff", "Jefferey", "Jeffery", "Jeffrey", "Jeffry", "Jena", "Jenifer", "Jennie", "Jennifer", "Jennings", "Jennyfer", "Jensen", "Jerad", "Jerald", "Jeramie", "Jeramy", "Jerel", "Jeremie", "Jeremy", "Jermain", "Jermaine", "Jermey", "Jerod", "Jerome", "Jeromy", "Jerrell", "Jerrod", "Jerrold", "Jerry", "Jess", "Jesse", "Jessica", "Jessie", "Jessika", "Jessy", "Jessyca", "Jesus", "Jett", "Jettie", "Jevon", "Jewel", "Jewell", "Jillian", "Jimmie", "Jimmy", "Jo", "Joan", "Joana", "Joanie", "Joanne", "Joannie", "Joanny", "Joany", "Joaquin", "Jocelyn", "Jodie", "Jody", "Joe", "Joel", "Joelle", "Joesph", "Joey", "Johan", "Johann", "Johanna", "Johathan", "John", "Johnathan", "Johnathon", "Johnnie", "Johnny", "Johnpaul", "Johnson", "Jolie", "Jon", "Jonas", "Jonatan", "Jonathan", "Jonathon", "Jordan", "Jordane", "Jordi", "Jordon", "Jordy", "Jordyn", "Jorge", "Jose", "Josefa", "Josefina", "Joseph", "Josephine", "Josh", "Joshua", "Joshuah", "Josiah", "Josiane", "Josianne", "Josie", "Josue", "Jovan", "Jovani", "Jovanny", "Jovany", "Joy", "Joyce", "Juana", "Juanita", "Judah", "Judd", "Jude", "Judge", "Judson", "Judy", "Jules", "Julia", "Julian", "Juliana", "Julianne", "Julie", "Julien", "Juliet", "Julio", "Julius", "June", "Junior", "Junius", "Justen", "Justice", "Justina", "Justine", "Juston", "Justus", "Justyn", "Juvenal", "Juwan", "Kacey", "Kaci", "Kacie", "Kade", "Kaden", "Kadin", "Kaela", "Kaelyn", "Kaia", "Kailee", "Kailey", "Kailyn", "Kaitlin", "Kaitlyn", "Kale", "Kaleb", "Kaleigh", "Kaley", "Kali", "Kallie", "Kameron", "Kamille", "Kamren", "Kamron", "Kamryn", "Kane", "Kara", "Kareem", "Karelle", "Karen", "Kari", "Kariane", "Karianne", "Karina", "Karine", "Karl", "Karlee", "Karley", "Karli", "Karlie", "Karolann", "Karson", "Kasandra", "Kasey", "Kassandra", "Katarina", "Katelin", "Katelyn", "Katelynn", "Katharina", "Katherine", "Katheryn", "Kathleen", "Kathlyn", "Kathryn", "Kathryne", "Katlyn", "Katlynn", "Katrina", "Katrine", "Kattie", "Kavon", "Kay", "Kaya", "Kaycee", "Kayden", "Kayla", "Kaylah", "Kaylee", "Kayleigh", "Kayley", "Kayli", "Kaylie", "Kaylin", "Keagan", "Keanu", "Keara", "Keaton", "Keegan", "Keeley", "Keely", "Keenan", "Keira", "Keith", "Kellen", "Kelley", "Kelli", "Kellie", "Kelly", "Kelsi", "Kelsie", "Kelton", "Kelvin", "Ken", "Kendall", "Kendra", "Kendrick", "Kenna", "Kennedi", "Kennedy", "Kenneth", "Kennith", "Kenny", "Kenton", "Kenya", "Kenyatta", "Kenyon", "Keon", "Keshaun", "Keshawn", "Keven", "Kevin", "Kevon", "Keyon", "Keyshawn", "Khalid", "Khalil", "Kian", "Kiana", "Kianna", "Kiara", "Kiarra", "Kiel", "Kiera", "Kieran", "Kiley", "Kim", "Kimberly", "King", "Kip", "Kira", "Kirk", "Kirsten", "Kirstin", "Kitty", "Kobe", "Koby", "Kody", "Kolby", "Kole", "Korbin", "Korey", "Kory", "Kraig", "Kris", "Krista", "Kristian", "Kristin", "Kristina", "Kristofer", "Kristoffer", "Kristopher", "Kristy", "Krystal", "Krystel", "Krystina", "Kurt", "Kurtis", "Kyla", "Kyle", "Kylee", "Kyleigh", "Kyler", "Kylie", "Kyra", "Lacey", "Lacy", "Ladarius", "Lafayette", "Laila", "Laisha", "Lamar", "Lambert", "Lamont", "Lance", "Landen", "Lane", "Laney", "Larissa", "Laron", "Larry", "Larue", "Laura", "Laurel", "Lauren", "Laurence", "Lauretta", "Lauriane", "Laurianne", "Laurie", "Laurine", "Laury", "Lauryn", "Lavada", "Lavern", "Laverna", "Laverne", "Lavina", "Lavinia", "Lavon", "Lavonne", "Lawrence", "Lawson", "Layla", "Layne", "Lazaro", "Lea", "Leann", "Leanna", "Leanne", "Leatha", "Leda", "Lee", "Leif", "Leila", "Leilani", "Lela", "Lelah", "Leland", "Lelia", "Lempi", "Lemuel", "Lenna", "Lennie", "Lenny", "Lenora", "Lenore", "Leo", "Leola", "Leon", "Leonard", "Leonardo", "Leone", "Leonel", "Leonie", "Leonor", "Leonora", "Leopold", "Leopoldo", "Leora", "Lera", "Lesley", "Leslie", "Lesly", "Lessie", "Lester", "Leta", "Letha", "Letitia", "Levi", "Lew", "Lewis", "Lexi", "Lexie", "Lexus", "Lia", "Liam", "Liana", "Libbie", "Libby", "Lila", "Lilian", "Liliana", "Liliane", "Lilla", "Lillian", "Lilliana", "Lillie", "Lilly", "Lily", "Lilyan", "Lina", "Lincoln", "Linda", "Lindsay", "Lindsey", "Linnea", "Linnie", "Linwood", "Lionel", "Lisa", "Lisandro", "Lisette", "Litzy", "Liza", "Lizeth", "Lizzie", "Llewellyn", "Lloyd", "Logan", "Lois", "Lola", "Lolita", "Loma", "Lon", "London", "Lonie", "Lonnie", "Lonny", "Lonzo", "Lora", "Loraine", "Loren", "Lorena", "Lorenz", "Lorenza", "Lorenzo", "Lori", "Lorine", "Lorna", "Lottie", "Lou", "Louie", "Louisa", "Lourdes", "Louvenia", "Lowell", "Loy", "Loyal", "Loyce", "Lucas", "Luciano", "Lucie", "Lucienne", "Lucile", "Lucinda", "Lucio", "Lucious", "Lucius", "Lucy", "Ludie", "Ludwig", "Lue", "Luella", "Luigi", "Luis", "Luisa", "Lukas", "Lula", "Lulu", "Luna", "Lupe", "Lura", "Lurline", "Luther", "Luz", "Lyda", "Lydia", "Lyla", "Lynn", "Lyric", "Lysanne", "Mabel", "Mabelle", "Mable", "Mac", "Macey", "Maci", "Macie", "Mack", "Mackenzie", "Macy", "Madaline", "Madalyn", "Maddison", "Madeline", "Madelyn", "Madelynn", "Madge", "Madie", "Madilyn", "Madisen", "Madison", "Madisyn", "Madonna", "Madyson", "Mae", "Maegan", "Maeve", "Mafalda", "Magali", "Magdalen", "Magdalena", "Maggie", "Magnolia", "Magnus", "Maia", "Maida", "Maiya", "Major", "Makayla", "Makenna", "Makenzie", "Malachi", "Malcolm", "Malika", "Malinda", "Mallie", "Mallory", "Malvina", "Mandy", "Manley", "Manuel", "Manuela", "Mara", "Marc", "Marcel", "Marcelina", "Marcelino", "Marcella", "Marcelle", "Marcellus", "Marcelo", "Marcia", "Marco", "Marcos", "Marcus", "Margaret", "Margarete", "Margarett", "Margaretta", "Margarette", "Margarita", "Marge", "Margie", "Margot", "Margret", "Marguerite", "Maria", "Mariah", "Mariam", "Marian", "Mariana", "Mariane", "Marianna", "Marianne", "Mariano", "Maribel", "Marie", "Mariela", "Marielle", "Marietta", "Marilie", "Marilou", "Marilyne", "Marina", "Mario", "Marion", "Marisa", "Marisol", "Maritza", "Marjolaine", "Marjorie", "Marjory", "Mark", "Markus", "Marlee", "Marlen", "Marlene", "Marley", "Marlin", "Marlon", "Marques", "Marquis", "Marquise", "Marshall", "Marta", "Martin", "Martina", "Martine", "Marty", "Marvin", "Mary", "Maryam", "Maryjane", "Maryse", "Mason", "Mateo", "Mathew", "Mathias", "Mathilde", "Matilda", "Matilde", "Matt", "Matteo", "Mattie", "Maud", "Maude", "Maudie", "Maureen", "Maurice", "Mauricio", "Maurine", "Maverick", "Mavis", "Max", "Maxie", "Maxime", "Maximilian", "Maximillia", "Maximillian", "Maximo", "Maximus", "Maxine", "Maxwell", "May", "Maya", "Maybell", "Maybelle", "Maye", "Maymie", "Maynard", "Mayra", "Mazie", "Mckayla", "Mckenna", "Mckenzie", "Meagan", "Meaghan", "Meda", "Megane", "Meggie", "Meghan", "Mekhi", "Melany", "Melba", "Melisa", "Melissa", "Mellie", "Melody", "Melvin", "Melvina", "Melyna", "Melyssa", "Mercedes", "Meredith", "Merl", "Merle", "Merlin", "Merritt", "Mertie", "Mervin", "Meta", "Mia", "Micaela", "Micah", "Michael", "Michaela", "Michale", "Micheal", "Michel", "Michele", "Michelle", "Miguel", "Mikayla", "Mike", "Mikel", "Milan", "Miles", "Milford", "Miller", "Millie", "Milo", "Milton", "Mina", "Minerva", "Minnie", "Miracle", "Mireille", "Mireya", "Misael", "Missouri", "Misty", "Mitchel", "Mitchell", "Mittie", "Modesta", "Modesto", "Mohamed", "Mohammad", "Mohammed", "Moises", "Mollie", "Molly", "Mona", "Monica", "Monique", "Monroe", "Monserrat", "Monserrate", "Montana", "Monte", "Monty", "Morgan", "Moriah", "Morris", "Mortimer", "Morton", "Mose", "Moses", "Moshe", "Mossie", "Mozell", "Mozelle", "Muhammad", "Muriel", "Murl", "Murphy", "Murray", "Mustafa", "Mya", "Myah", "Mylene", "Myles", "Myra", "Myriam", "Myrl", "Myrna", "Myron", "Myrtice", "Myrtie", "Myrtis", "Myrtle", "Nadia", "Nakia", "Name", "Nannie", "Naomi", "Naomie", "Napoleon", "Narciso", "Nash", "Nasir", "Nat", "Natalia", "Natalie", "Natasha", "Nathan", "Nathanael", "Nathanial", "Nathaniel", "Nathen", "Nayeli", "Neal", "Ned", "Nedra", "Neha", "Neil", "Nelda", "Nella", "Nelle", "Nellie", "Nels", "Nelson", "Neoma", "Nestor", "Nettie", "Neva", "Newell", "Newton", "Nia", "Nicholas", "Nicholaus", "Nichole", "Nick", "Nicklaus", "Nickolas", "Nico", "Nicola", "Nicolas", "Nicole", "Nicolette", "Nigel", "Nikita", "Nikki", "Nikko", "Niko", "Nikolas", "Nils", "Nina", "Noah", "Noble", "Noe", "Noel", "Noelia", "Noemi", "Noemie", "Noemy", "Nola", "Nolan", "Nona", "Nora", "Norbert", "Norberto", "Norene", "Norma", "Norris", "Norval", "Norwood", "Nova", "Novella", "Nya", "Nyah", "Nyasia", "Obie", "Oceane", "Ocie", "Octavia", "Oda", "Odell", "Odessa", "Odie", "Ofelia", "Okey", "Ola", "Olaf", "Ole", "Olen", "Oleta", "Olga", "Olin", "Oliver", "Ollie", "Oma", "Omari", "Omer", "Ona", "Onie", "Opal", "Ophelia", "Ora", "Oral", "Oran", "Oren", "Orie", "Orin", "Orion", "Orland", "Orlando", "Orlo", "Orpha", "Orrin", "Orval", "Orville", "Osbaldo", "Osborne", "Oscar", "Osvaldo", "Oswald", "Oswaldo", "Otha", "Otho", "Otilia", "Otis", "Ottilie", "Ottis", "Otto", "Ova", "Owen", "Ozella", "Pablo", "Paige", "Palma", "Pamela", "Pansy", "Paolo", "Paris", "Parker", "Pascale", "Pasquale", "Pat", "Patience", "Patricia", "Patrick", "Patsy", "Pattie", "Paul", "Paula", "Pauline", "Paxton", "Payton", "Pearl", "Pearlie", "Pearline", "Pedro", "Peggie", "Penelope", "Percival", "Percy", "Perry", "Pete", "Peter", "Petra", "Peyton", "Philip", "Phoebe", "Phyllis", "Pierce", "Pierre", "Pietro", "Pink", "Pinkie", "Piper", "Polly", "Porter", "Precious", "Presley", "Preston", "Price", "Prince", "Princess", "Priscilla", "Providenci", "Prudence", "Queen", "Queenie", "Quentin", "Quincy", "Quinn", "Quinten", "Quinton", "Rachael", "Rachel", "Rachelle", "Rae", "Raegan", "Rafael", "Rafaela", "Raheem", "Rahsaan", "Rahul", "Raina", "Raleigh", "Ralph", "Ramiro", "Ramon", "Ramona", "Randal", "Randall", "Randi", "Randy", "Ransom", "Raoul", "Raphael", "Raphaelle", "Raquel", "Rashad", "Rashawn", "Rasheed", "Raul", "Raven", "Ray", "Raymond", "Raymundo", "Reagan", "Reanna", "Reba", "Rebeca", "Rebecca", "Rebeka", "Rebekah", "Reece", "Reed", "Reese", "Regan", "Reggie", "Reginald", "Reid", "Reilly", "Reina", "Reinhold", "Remington", "Rene", "Renee", "Ressie", "Reta", "Retha", "Retta", "Reuben", "Reva", "Rex", "Rey", "Reyes", "Reymundo", "Reyna", "Reynold", "Rhea", "Rhett", "Rhianna", "Rhiannon", "Rhoda", "Ricardo", "Richard", "Richie", "Richmond", "Rick", "Rickey", "Rickie", "Ricky", "Rico", "Rigoberto", "Riley", "Rita", "River", "Robb", "Robbie", "Robert", "Roberta", "Roberto", "Robin", "Robyn", "Rocio", "Rocky", "Rod", "Roderick", "Rodger", "Rodolfo", "Rodrick", "Rodrigo", "Roel", "Rogelio", "Roger", "Rogers", "Rolando", "Rollin", "Roma", "Romaine", "Roman", "Ron", "Ronaldo", "Ronny", "Roosevelt", "Rory", "Rosa", "Rosalee", "Rosalia", "Rosalind", "Rosalinda", "Rosalyn", "Rosamond", "Rosanna", "Rosario", "Roscoe", "Rose", "Rosella", "Roselyn", "Rosemarie", "Rosemary", "Rosendo", "Rosetta", "Rosie", "Rosina", "Roslyn", "Ross", "Rossie", "Rowan", "Rowena", "Rowland", "Roxane", "Roxanne", "Roy", "Royal", "Royce", "Rozella", "Ruben", "Rubie", "Ruby", "Rubye", "Rudolph", "Rudy", "Rupert", "Russ", "Russel", "Russell", "Rusty", "Ruth", "Ruthe", "Ruthie", "Ryan", "Ryann", "Ryder", "Rylan", "Rylee", "Ryleigh", "Ryley", "Sabina", "Sabrina", "Sabryna", "Sadie", "Sadye", "Sage", "Saige", "Sallie", "Sally", "Salma", "Salvador", "Salvatore", "Sam", "Samanta", "Samantha", "Samara", "Samir", "Sammie", "Sammy", "Samson", "Sandra", "Sandrine", "Sandy", "Sanford", "Santa", "Santiago", "Santina", "Santino", "Santos", "Sarah", "Sarai", "Sarina", "Sasha", "Saul", "Savanah", "Savanna", "Savannah", "Savion", "Scarlett", "Schuyler", "Scot", "Scottie", "Scotty", "Seamus", "Sean", "Sebastian", "Sedrick", "Selena", "Selina", "Selmer", "Serena", "Serenity", "Seth", "Shad", "Shaina", "Shakira", "Shana", "Shane", "Shanel", "Shanelle", "Shania", "Shanie", "Shaniya", "Shanna", "Shannon", "Shanny", "Shanon", "Shany", "Sharon", "Shaun", "Shawn", "Shawna", "Shaylee", "Shayna", "Shayne", "Shea", "Sheila", "Sheldon", "Shemar", "Sheridan", "Sherman", "Sherwood", "Shirley", "Shyann", "Shyanne", "Sibyl", "Sid", "Sidney", "Sienna", "Sierra", "Sigmund", "Sigrid", "Sigurd", "Silas", "Sim", "Simeon", "Simone", "Sincere", "Sister", "Skye", "Skyla", "Skylar", "Sofia", "Soledad", "Solon", "Sonia", "Sonny", "Sonya", "Sophia", "Sophie", "Spencer", "Stacey", "Stacy", "Stan", "Stanford", "Stanley", "Stanton", "Stefan", "Stefanie", "Stella", "Stephan", "Stephania", "Stephanie", "Stephany", "Stephen", "Stephon", "Sterling", "Steve", "Stevie", "Stewart", "Stone", "Stuart", "Summer", "Sunny", "Susan", "Susana", "Susanna", "Susie", "Suzanne", "Sven", "Syble", "Sydnee", "Sydney", "Sydni", "Sydnie", "Sylvan", "Sylvester", "Sylvia", "Tabitha", "Tad", "Talia", "Talon", "Tamara", "Tamia", "Tania", "Tanner", "Tanya", "Tara", "Taryn", "Tate", "Tatum", "Tatyana", "Taurean", "Tavares", "Taya", "Taylor", "Teagan", "Ted", "Telly", "Terence", "Teresa", "Terrance", "Terrell", "Terrence", "Terrill", "Terry", "Tess", "Tessie", "Tevin", "Thad", "Thaddeus", "Thalia", "Thea", "Thelma", "Theo", "Theodora", "Theodore", "Theresa", "Therese", "Theresia", "Theron", "Thomas", "Thora", "Thurman", "Tia", "Tiana", "Tianna", "Tiara", "Tierra", "Tiffany", "Tillman", "Timmothy", "Timmy", "Timothy", "Tina", "Tito", "Titus", "Tobin", "Toby", "Tod", "Tom", "Tomas", "Tomasa", "Tommie", "Toney", "Toni", "Tony", "Torey", "Torrance", "Torrey", "Toy", "Trace", "Tracey", "Tracy", "Travis", "Travon", "Tre", "Tremaine", "Tremayne", "Trent", "Trenton", "Tressa", "Tressie", "Treva", "Trever", "Trevion", "Trevor", "Trey", "Trinity", "Trisha", "Tristian", "Tristin", "Triston", "Troy", "Trudie", "Trycia", "Trystan", "Turner", "Twila", "Tyler", "Tyra", "Tyree", "Tyreek", "Tyrel", "Tyrell", "Tyrese", "Tyrique", "Tyshawn", "Tyson", "Ubaldo", "Ulices", "Ulises", "Una", "Unique", "Urban", "Uriah", "Uriel", "Ursula", "Vada", "Valentin", "Valentina", "Valentine", "Valerie", "Vallie", "Van", "Vance", "Vanessa", "Vaughn", "Veda", "Velda", "Vella", "Velma", "Velva", "Vena", "Verda", "Verdie", "Vergie", "Verla", "Verlie", "Vern", "Verna", "Verner", "Vernice", "Vernie", "Vernon", "Verona", "Veronica", "Vesta", "Vicenta", "Vicente", "Vickie", "Vicky", "Victor", "Victoria", "Vida", "Vidal", "Vilma", "Vince", "Vincent", "Vincenza", "Vincenzo", "Vinnie", "Viola", "Violet", "Violette", "Virgie", "Virgil", "Virginia", "Virginie", "Vita", "Vito", "Viva", "Vivian", "Viviane", "Vivianne", "Vivien", "Vivienne", "Vladimir", "Wade", "Waino", "Waldo", "Walker", "Wallace", "Walter", "Walton", "Wanda", "Ward", "Warren", "Watson", "Wava", "Waylon", "Wayne", "Webster", "Weldon", "Wellington", "Wendell", "Wendy", "Werner", "Westley", "Weston", "Whitney", "Wilber", "Wilbert", "Wilburn", "Wiley", "Wilford", "Wilfred", "Wilfredo", "Wilfrid", "Wilhelm", "Wilhelmine", "Will", "Willa", "Willard", "William", "Willie", "Willis", "Willow", "Willy", "Wilma", "Wilmer", "Wilson", "Wilton", "Winfield", "Winifred", "Winnifred", "Winona", "Winston", "Woodrow", "Wyatt", "Wyman", "Xander", "Xavier", "Xzavier", "Yadira", "Yasmeen", "Yasmin", "Yasmine", "Yazmin", "Yesenia", "Yessenia", "Yolanda", "Yoshiko", "Yvette", "Yvonne", "Zachariah", "Zachary", "Zachery", "Zack", "Zackary", "Zackery", "Zakary", "Zander", "Zane", "Zaria", "Zechariah", "Zelda", "Zella", "Zelma", "Zena", "Zetta", "Zion", "Zita", "Zoe", "Zoey", "Zoie", "Zoila", "Zola", "Zora", "Zula"];
					e.exports = {
						generateUsername: function() {
							return `${i.randomElement(s)}-${i.randomAlphanumStr(3)}`
						}
					}
				},
				2505: (e, t, n) => {
					var i = n(8350);

					function s(e, t) {
						this.logStorage = e, this.stringifyObjects = !(!t || !t.stringifyObjects) && t.stringifyObjects, this.storeInterval = t && t.storeInterval ? t.storeInterval : 3e4, this.maxEntryLength = t && t.maxEntryLength ? t.maxEntryLength : 1e4, Object.keys(i.levels).forEach(function(e) {
							this[i.levels[e]] = function() {
								this._log.apply(this, arguments)
							}.bind(this, e)
						}.bind(this)), this.storeLogsIntervalID = null, this.queue = [], this.totalLen = 0, this.outputCache = []
					}
					s.prototype.stringify = function(e) {
						try {
							return JSON.stringify(e)
						} catch (e) {
							return "[object with circular refs?]"
						}
					}, s.prototype.formatLogMessage = function(e) {
						for (var t = "", n = 1, s = arguments.length; n < s; n++) {
							var r = arguments[n];
							!this.stringifyObjects && e !== i.levels.ERROR || "object" != typeof r || (r = this.stringify(r)), t += r, n !== s - 1 && (t += " ")
						}
						return t.length ? t : null
					}, s.prototype._log = function() {
						var e = arguments[1],
							t = this.formatLogMessage.apply(this, arguments);
						if (t) {
							var n = this.queue[this.queue.length - 1],
								i = n && n.text;
							i === t ? n.count += 1 : (this.queue.push({
								text: t,
								timestamp: e,
								count: 1
							}), this.totalLen += t.length)
						}
						this.totalLen >= this.maxEntryLength && this._flush(!0, !0)
					}, s.prototype.start = function() {
						this._reschedulePublishInterval()
					}, s.prototype._reschedulePublishInterval = function() {
						this.storeLogsIntervalID && (window.clearTimeout(this.storeLogsIntervalID), this.storeLogsIntervalID = null), this.storeLogsIntervalID = window.setTimeout(this._flush.bind(this, !1, !0), this.storeInterval)
					}, s.prototype.flush = function() {
						this._flush(!1, !0)
					}, s.prototype._flush = function(e, t) {
						this.totalLen > 0 && (this.logStorage.isReady() || e) && (this.logStorage.isReady() ? (this.outputCache.length && (this.outputCache.forEach(function(e) {
							this.logStorage.storeLogs(e)
						}.bind(this)), this.outputCache = []), this.logStorage.storeLogs(this.queue)) : this.outputCache.push(this.queue), this.queue = [], this.totalLen = 0), t && this._reschedulePublishInterval()
					}, s.prototype.stop = function() {
						this._flush(!1, !1)
					}, e.exports = s
				},
				8350: e => {
					var t = {
						trace: 0,
						debug: 1,
						info: 2,
						log: 3,
						warn: 4,
						error: 5
					};
					o.consoleTransport = console;
					var n = [o.consoleTransport];
					o.addGlobalTransport = function(e) {
						-1 === n.indexOf(e) && n.push(e)
					}, o.removeGlobalTransport = function(e) {
						var t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
					};
					var i = {};

					function s() {
						var e = {
								methodName: "",
								fileLocation: "",
								line: null,
								column: null
							},
							t = new Error,
							n = t.stack ? t.stack.split("\n") : [];
						if (!n || n.length < 3) return e;
						var i = null;
						return n[3] && (i = n[3].match(/\s*at\s*(.+?)\s*\((\S*)\s*:(\d*)\s*:(\d*)\)/)), !i || i.length <= 4 ? (0 === n[2].indexOf("log@") ? e.methodName = n[3].substr(0, n[3].indexOf("@")) : e.methodName = n[2].substr(0, n[2].indexOf("@")), e) : (e.methodName = i[1], e.fileLocation = i[2], e.line = i[3], e.column = i[4], e)
					}

					function r() {
						var e = arguments[0],
							r = arguments[1],
							o = Array.prototype.slice.call(arguments, 2);
						if (!(t[r] < e.level))
							for (var a = !(e.options.disableCallerInfo || i.disableCallerInfo) && s(), c = n.concat(e.transports), d = 0; d < c.length; d++) {
								var l = c[d],
									u = l[r];
								if (u && "function" == typeof u) {
									var h = [];
									h.push((new Date).toISOString()), e.id && h.push("[" + e.id + "]"), a && a.methodName.length > 1 && h.push("<" + a.methodName + ">: ");
									var p = h.concat(o);
									u.bind(l).apply(l, p)
								}
							}
					}

					function o(e, n, i, s) {
						this.id = n, this.options = s || {}, this.transports = i, this.transports || (this.transports = []), this.level = t[e];
						for (var o = Object.keys(t), a = 0; a < o.length; a++) this[o[a]] = r.bind(null, this, o[a])
					}
					o.setGlobalOptions = function(e) {
						i = e || {}
					}, o.prototype.setLevel = function(e) {
						this.level = t[e]
					}, e.exports = o, o.levels = {
						TRACE: "trace",
						DEBUG: "debug",
						INFO: "info",
						LOG: "log",
						WARN: "warn",
						ERROR: "error"
					}
				},
				5810: (e, t, n) => {
					var i = n(8350),
						s = n(2505),
						r = {},
						o = [],
						a = i.levels.TRACE;
					e.exports = {
						addGlobalTransport: function(e) {
							i.addGlobalTransport(e)
						},
						removeGlobalTransport: function(e) {
							i.removeGlobalTransport(e)
						},
						setGlobalOptions: function(e) {
							i.setGlobalOptions(e)
						},
						getLogger: function(e, t, n) {
							var s = new i(a, e, t, n);
							return e ? (r[e] = r[e] || [], r[e].push(s)) : o.push(s), s
						},
						setLogLevelById: function(e, t) {
							for (var n = t ? r[t] || [] : o, i = 0; i < n.length; i++) n[i].setLevel(e)
						},
						setLogLevel: function(e) {
							a = e;
							for (var t = 0; t < o.length; t++) o[t].setLevel(e);
							for (var n in r) {
								var i = r[n] || [];
								for (t = 0; t < i.length; t++) i[t].setLevel(e)
							}
						},
						levels: i.levels,
						LogCollector: s
					}
				},
				8022: e => {
					var t = e.exports = {
						v: [{
							name: "version",
							reg: /^(\d*)$/
						}],
						o: [{
							name: "origin",
							reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
							names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
							format: "%s %s %d %s IP%d %s"
						}],
						s: [{
							name: "name"
						}],
						i: [{
							name: "description"
						}],
						u: [{
							name: "uri"
						}],
						e: [{
							name: "email"
						}],
						p: [{
							name: "phone"
						}],
						z: [{
							name: "timezones"
						}],
						r: [{
							name: "repeats"
						}],
						t: [{
							name: "timing",
							reg: /^(\d*) (\d*)/,
							names: ["start", "stop"],
							format: "%d %d"
						}],
						c: [{
							name: "connection",
							reg: /^IN IP(\d) (\S*)/,
							names: ["version", "ip"],
							format: "IN IP%d %s"
						}],
						b: [{
							push: "bandwidth",
							reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
							names: ["type", "limit"],
							format: "%s:%s"
						}],
						m: [{
							reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
							names: ["type", "port", "protocol", "payloads"],
							format: "%s %d %s %s"
						}],
						a: [{
							push: "rtp",
							reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
							names: ["payload", "codec", "rate", "encoding"],
							format: function(e) {
								return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
							}
						}, {
							push: "fmtp",
							reg: /^fmtp:(\d*) ([\S| ]*)/,
							names: ["payload", "config"],
							format: "fmtp:%d %s"
						}, {
							name: "control",
							reg: /^control:(.*)/,
							format: "control:%s"
						}, {
							name: "rtcp",
							reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
							names: ["port", "netType", "ipVer", "address"],
							format: function(e) {
								return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
							}
						}, {
							push: "rtcpFbTrrInt",
							reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
							names: ["payload", "value"],
							format: "rtcp-fb:%s trr-int %d"
						}, {
							push: "rtcpFb",
							reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
							names: ["payload", "type", "subtype"],
							format: function(e) {
								return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
							}
						}, {
							push: "ext",
							reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
							names: ["value", "direction", "encrypt-uri", "uri", "config"],
							format: function(e) {
								return "extmap:%d" + (e.direction ? "/%s" : "%v") + (e["encrypt-uri"] ? " %s" : "%v") + " %s" + (e.config ? " %s" : "")
							}
						}, {
							name: "extmapAllowMixed",
							reg: /^(extmap-allow-mixed)/
						}, {
							push: "crypto",
							reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
							names: ["id", "suite", "config", "sessionConfig"],
							format: function(e) {
								return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
							}
						}, {
							name: "setup",
							reg: /^setup:(\w*)/,
							format: "setup:%s"
						}, {
							name: "connectionType",
							reg: /^connection:(new|existing)/,
							format: "connection:%s"
						}, {
							name: "mid",
							reg: /^mid:([^\s]*)/,
							format: "mid:%s"
						}, {
							name: "msid",
							reg: /^msid:(.*)/,
							format: "msid:%s"
						}, {
							name: "ptime",
							reg: /^ptime:(\d*(?:\.\d*)*)/,
							format: "ptime:%d"
						}, {
							name: "maxptime",
							reg: /^maxptime:(\d*(?:\.\d*)*)/,
							format: "maxptime:%d"
						}, {
							name: "direction",
							reg: /^(sendrecv|recvonly|sendonly|inactive)/
						}, {
							name: "icelite",
							reg: /^(ice-lite)/
						}, {
							name: "iceUfrag",
							reg: /^ice-ufrag:(\S*)/,
							format: "ice-ufrag:%s"
						}, {
							name: "icePwd",
							reg: /^ice-pwd:(\S*)/,
							format: "ice-pwd:%s"
						}, {
							name: "fingerprint",
							reg: /^fingerprint:(\S*) (\S*)/,
							names: ["type", "hash"],
							format: "fingerprint:%s %s"
						}, {
							push: "candidates",
							reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
							names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
							format: function(e) {
								var t = "candidate:%s %d %s %d %s %d typ %s";
								return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), (t += null != e["network-id"] ? " network-id %d" : "%v") + (null != e["network-cost"] ? " network-cost %d" : "%v")
							}
						}, {
							name: "endOfCandidates",
							reg: /^(end-of-candidates)/
						}, {
							name: "remoteCandidates",
							reg: /^remote-candidates:(.*)/,
							format: "remote-candidates:%s"
						}, {
							name: "iceOptions",
							reg: /^ice-options:(\S*)/,
							format: "ice-options:%s"
						}, {
							push: "ssrcs",
							reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
							names: ["id", "attribute", "value"],
							format: function(e) {
								var t = "ssrc:%d";
								return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
							}
						}, {
							push: "ssrcGroups",
							reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
							names: ["semantics", "ssrcs"],
							format: "ssrc-group:%s %s"
						}, {
							name: "msidSemantic",
							reg: /^msid-semantic:\s?(\w*) (\S*)/,
							names: ["semantic", "token"],
							format: "msid-semantic: %s %s"
						}, {
							push: "groups",
							reg: /^group:(\w*) (.*)/,
							names: ["type", "mids"],
							format: "group:%s %s"
						}, {
							name: "rtcpMux",
							reg: /^(rtcp-mux)/
						}, {
							name: "rtcpRsize",
							reg: /^(rtcp-rsize)/
						}, {
							name: "sctpmap",
							reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
							names: ["sctpmapNumber", "app", "maxMessageSize"],
							format: function(e) {
								return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
							}
						}, {
							name: "xGoogleFlag",
							reg: /^x-google-flag:([^\s]*)/,
							format: "x-google-flag:%s"
						}, {
							push: "rids",
							reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
							names: ["id", "direction", "params"],
							format: function(e) {
								return e.params ? "rid:%s %s %s" : "rid:%s %s"
							}
						}, {
							push: "imageattrs",
							reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
							names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
							format: function(e) {
								return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
							}
						}, {
							name: "simulcast",
							reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
							names: ["dir1", "list1", "dir2", "list2"],
							format: function(e) {
								return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
							}
						}, {
							name: "simulcast_03",
							reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
							names: ["value"],
							format: "simulcast: %s"
						}, {
							name: "framerate",
							reg: /^framerate:(\d+(?:$|\.\d+))/,
							format: "framerate:%s"
						}, {
							name: "sourceFilter",
							reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
							names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
							format: "source-filter: %s %s %s %s %s"
						}, {
							name: "bundleOnly",
							reg: /^(bundle-only)/
						}, {
							name: "label",
							reg: /^label:(.+)/,
							format: "label:%s"
						}, {
							name: "sctpPort",
							reg: /^sctp-port:(\d+)$/,
							format: "sctp-port:%s"
						}, {
							name: "maxMessageSize",
							reg: /^max-message-size:(\d+)$/,
							format: "max-message-size:%s"
						}, {
							push: "tsRefClocks",
							reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
							names: ["clksrc", "clksrcExt"],
							format: function(e) {
								return "ts-refclk:%s" + (null != e.clksrcExt ? "=%s" : "")
							}
						}, {
							name: "mediaClk",
							reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
							names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
							format: function(e) {
								var t = "mediaclk:";
								return t += null != e.id ? "id=%s %s" : "%v%s", t += null != e.mediaClockValue ? "=%s" : "", (t += null != e.rateNumerator ? " rate=%s" : "") + (null != e.rateDenominator ? "/%s" : "")
							}
						}, {
							name: "keywords",
							reg: /^keywds:(.+)$/,
							format: "keywds:%s"
						}, {
							name: "content",
							reg: /^content:(.+)/,
							format: "content:%s"
						}, {
							name: "bfcpFloorCtrl",
							reg: /^floorctrl:(c-only|s-only|c-s)/,
							format: "floorctrl:%s"
						}, {
							name: "bfcpConfId",
							reg: /^confid:(\d+)/,
							format: "confid:%s"
						}, {
							name: "bfcpUserId",
							reg: /^userid:(\d+)/,
							format: "userid:%s"
						}, {
							name: "bfcpFloorId",
							reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
							names: ["id", "mStream"],
							format: "floorid:%s mstrm:%s"
						}, {
							push: "invalid",
							names: ["value"]
						}]
					};
					Object.keys(t).forEach((function(e) {
						t[e].forEach((function(e) {
							e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
						}))
					}))
				},
				6561: (e, t, n) => {
					var i = n(2408),
						s = n(2508);
					t.write = s, t.parse = i.parse, t.parseParams = i.parseParams, t.parseFmtpConfig = i.parseFmtpConfig, t.parsePayloads = i.parsePayloads, t.parseRemoteCandidates = i.parseRemoteCandidates, t.parseImageAttributes = i.parseImageAttributes, t.parseSimulcastStreamList = i.parseSimulcastStreamList
				},
				2408: (e, t, n) => {
					var i = function(e) {
							return String(Number(e)) === e ? Number(e) : e
						},
						s = function(e, t, n) {
							var s = e.name && e.names;
							e.push && !t[e.push] ? t[e.push] = [] : s && !t[e.name] && (t[e.name] = {});
							var r = e.push ? {} : s ? t[e.name] : t;
							! function(e, t, n, s) {
								if (s && !n) t[s] = i(e[1]);
								else
									for (var r = 0; r < n.length; r += 1) null != e[r + 1] && (t[n[r]] = i(e[r + 1]))
							}(n.match(e.reg), r, e.names, e.name), e.push && t[e.push].push(r)
						},
						r = n(8022),
						o = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
					t.parse = function(e) {
						var t = {},
							n = [],
							i = t;
						return e.split(/(\r\n|\r|\n)/).filter(o).forEach((function(e) {
							var t = e[0],
								o = e.slice(2);
							"m" === t && (n.push({
								rtp: [],
								fmtp: []
							}), i = n[n.length - 1]);
							for (var a = 0; a < (r[t] || []).length; a += 1) {
								var c = r[t][a];
								if (c.reg.test(o)) return s(c, i, o)
							}
						})), t.media = n, t
					};
					var a = function(e, t) {
						var n = t.split(/=(.+)/, 2);
						return 2 === n.length ? e[n[0]] = i(n[1]) : 1 === n.length && t.length > 1 && (e[n[0]] = void 0), e
					};
					t.parseParams = function(e) {
						return e.split(/;\s?/).reduce(a, {})
					}, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e) {
						return e.toString().split(" ").map(Number)
					}, t.parseRemoteCandidates = function(e) {
						for (var t = [], n = e.split(" ").map(i), s = 0; s < n.length; s += 3) t.push({
							component: n[s],
							ip: n[s + 1],
							port: n[s + 2]
						});
						return t
					}, t.parseImageAttributes = function(e) {
						return e.split(" ").map((function(e) {
							return e.substring(1, e.length - 1).split(",").reduce(a, {})
						}))
					}, t.parseSimulcastStreamList = function(e) {
						return e.split(";").map((function(e) {
							return e.split(",").map((function(e) {
								var t, n = !1;
								return "~" !== e[0] ? t = i(e) : (t = i(e.substring(1, e.length)), n = !0), {
									scid: t,
									paused: n
								}
							}))
						}))
					}
				},
				2508: (e, t, n) => {
					var i = n(8022),
						s = /%[sdv%]/g,
						r = function(e) {
							var t = 1,
								n = arguments,
								i = n.length;
							return e.replace(s, (function(e) {
								if (t >= i) return e;
								var s = n[t];
								switch (t += 1, e) {
									case "%%":
										return "%";
									case "%s":
										return String(s);
									case "%d":
										return Number(s);
									case "%v":
										return ""
								}
							}))
						},
						o = function(e, t, n) {
							var i = [e + "=" + (t.format instanceof Function ? t.format(t.push ? n : n[t.name]) : t.format)];
							if (t.names)
								for (var s = 0; s < t.names.length; s += 1) {
									var o = t.names[s];
									t.name ? i.push(n[t.name][o]) : i.push(n[t.names[s]])
								} else i.push(n[t.name]);
							return r.apply(null, i)
						},
						a = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
						c = ["i", "c", "b", "a"];
					e.exports = function(e, t) {
						t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
							null == e.payloads && (e.payloads = "")
						}));
						var n = t.outerOrder || a,
							s = t.innerOrder || c,
							r = [];
						return n.forEach((function(t) {
							i[t].forEach((function(n) {
								n.name in e && null != e[n.name] ? r.push(o(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
									r.push(o(t, n, e))
								}))
							}))
						})), e.media.forEach((function(e) {
							r.push(o("m", i.m[0], e)), s.forEach((function(t) {
								i[t].forEach((function(n) {
									n.name in e && null != e[n.name] ? r.push(o(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
										r.push(o(t, n, e))
									}))
								}))
							}))
						})), r.join("\r\n") + "\r\n"
					}
				},
				6234: (e, t, n) => {
					var i = n(8310),
						s = n(6298),
						r = s.parseSsrcs,
						o = s.writeSsrcs;

					function a(e, t, n) {
						return e.ssrcs.filter((function(e) {
							return e.id === t
						})).filter((function(e) {
							return e.attribute === n
						})).map((function(e) {
							return e.value
						}))[0]
					}

					function c(e) {
						this.options = e || {}, this.options.numOfLayers || (this.options.numOfLayers = 3), console.log("SdpSimulcast: using " + this.options.numOfLayers + " layers"), this.ssrcCache = []
					}

					function d(e, t) {
						null != e && Array.isArray(e.media) && e.media.forEach((function(e) {
							"video" === e.type && t(e)
						}))
					}

					function l(e) {
						return e && null != e && e.type && "" != e.type && e.sdp && "" != e.sdp
					}
					c.prototype.clearSsrcCache = function() {
						this.ssrcCache = []
					}, c.prototype.setSsrcCache = function(e) {
						this.ssrcCache = e
					}, c.prototype._parseSimLayers = function(e) {
						var t = e.ssrcGroups && e.ssrcGroups.find((function(e) {
							return "SIM" === e.semantics
						}));
						return t ? t.ssrcs.split(" ").map((function(e) {
							return parseInt(e)
						})) : [e.ssrcs[0].id]
					}, c.prototype._buildNewToOldSsrcMap = function(e, t) {
						for (var n = {}, i = 0; i < e.length; ++i) {
							var s = e[i],
								r = t[i] || null;
							n[s] = r
						}
						return n
					}, c.prototype._fillInSourceDataFromCache = function(e) {
						console.log("SdpSimulcast restoring from cache: ", this.ssrcCache);
						var t = this._parseSimLayers(e);
						console.log("SdpSimulcast Parsed new sim ssrcs: ", t);
						var n = a(e, t[0], "msid"),
							i = a(e, t[0], "cname"),
							s = this._buildNewToOldSsrcMap(t, this.ssrcCache);
						console.log("SdpSimulcast built replacement map: ", s);
						var r = this.ssrcCache.filter((function(e) {
							return -1 === Object.values(s).indexOf(e)
						}));
						return console.log("SdpSimulcast built ssrcs to add: ", r), e.ssrcs.forEach((function(e) {
							s[e.id] && (e.id = s[e.id])
						})), r.forEach((function(t) {
							e.ssrcs.push({
								id: t,
								attribute: "msid",
								value: n
							}), e.ssrcs.push({
								id: t,
								attribute: "cname",
								value: i
							})
						})), e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
							semantics: "SIM",
							ssrcs: this.ssrcCache.join(" ")
						}), e
					}, c.prototype._generateSourceData = function(e, t) {
						var n = function(e, t) {
								e.ssrcs.push({
									id: t,
									attribute: "cname",
									value: s
								}), e.ssrcs.push({
									id: t,
									attribute: "msid",
									value: i
								})
							},
							i = a(e, t, "msid"),
							s = a(e, t, "cname");
						this.options.usesUnifiedPlan && !i && (i = e.msid, e.ssrcs.forEach((t => {
							e.ssrcs.push({
								id: t.id,
								attribute: "msid",
								value: i
							})
						})));
						for (var r = [], o = 0; o < this.options.numOfLayers - 1; ++o) {
							var c = Math.floor(4294967295 * Math.random()) + 0;
							n(e, c), r.push(c)
						}
						return e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
							semantics: "SIM",
							ssrcs: t + " " + r.join(" ")
						}), e
					}, c.prototype._restoreSimulcast = function(e) {
						var t, n = e.ssrcs && e.ssrcs.map((function(e) {
								return e.id
							})).filter((function(e, t, n) {
								return n.indexOf(e) === t
							})).length || 0,
							i = e.ssrcGroups && e.ssrcGroups.length || 0;
						if (0 === n || n > 2) return e;
						if (2 == n && 0 === i) return e;
						if (1 === n) t = e.ssrcs[0].id;
						else {
							var s = e.ssrcGroups.filter((function(e) {
								return "FID" === e.semantics
							}))[0];
							if (!s) return e;
							t = parseInt(s.ssrcs.split(" ")[0])
						}
						return console.log("SdpSimulcast: current ssrc cache: ", this.ssrcCache), console.log("SdpSimulcast: parsed primary ssrc " + t), -1 !== this.ssrcCache.indexOf(t) ? (console.log("SdpSimulcast: Have seen primary ssrc before, filling in data from cache"), e = this._fillInSourceDataFromCache(e)) : (console.log("SdpSimulcast: Have not seen primary ssrc before, generating source data"), e = this._generateSourceData(e, t)), this.ssrcCache = this._parseSimLayers(e), e
					}, c.prototype.mungeRemoteDescription = function(e, t) {
						if (!l(e)) return e;
						var n = i.parse(e.sdp),
							s = this;
						return d(n, (function(e) {
							s.options.explodeRemoteSimulcast ? function(e) {
								if (e && Array.isArray(e.ssrcGroups))
									for (var t = r(e), n = [], i = e.ssrcGroups.length; i--;)
										if ("SIM" === e.ssrcGroups[i].semantics) {
											for (var s = e.ssrcGroups[i].ssrcs.split(" "), a = 0; a < s.length; a++) {
												var c = s[a];
												n.push(c);
												var d = t[c].msid.split(" ");
												t[c].msid = [d[0], "/", a, " ", d[1], "/", a].join(""), t[c].cname = [t[c].cname, "/", a].join(""), e.ssrcGroups.forEach((function(e) {
													if ("SIM" !== e.semantics) {
														var i = e.ssrcs.split(" "); - 1 !== i.indexOf(c) && i.forEach((function(e) {
															t[e].msid = t[c].msid, t[e].cname = t[c].cname, e !== c && n.push(e)
														}))
													}
												}))
											}
											e.ssrcs = o(t, n), e.ssrcGroups.splice(i, 1)
										}
							}(e) : function(e) {
								if (e && Array.isArray(e.ssrcGroups)) {
									var t = r(e);
									e.ssrcGroups.forEach((function(n) {
										if ("SIM" === n.semantics) {
											console.info("Imploding SIM group: " + n.ssrcs), n.nuke = !0;
											for (var i = n.ssrcs.split(" "), s = 1; s < i.length; s++) {
												var r = i[s];
												delete t[r], e.ssrcGroups.forEach((function(e) {
													if ("SIM" !== e.semantics) {
														var n = e.ssrcs.split(" "); - 1 !== n.indexOf(r) && (n.forEach((function(e) {
															delete t[e]
														})), e.nuke = !0)
													}
												}))
											}
										}
									})), e.ssrcs = o(t);
									for (var n = e.ssrcGroups.length; n--;) e.ssrcGroups[n].nuke && e.ssrcGroups.splice(n, 1)
								} else console.info("Halt: There are no SSRC groups in the remote description.")
							}(e), !s.options.usesUnifiedPlan && t ? function(e) {
								e && (Array.isArray(e.invalid) || (e.invalid = []), e.invalid.some((function(e) {
									return "x-google-flag:conference" === e.value
								})) || e.invalid.push({
									value: "x-google-flag:conference"
								}))
							}(e) : function(e) {
								e && void 0 !== e.xGoogleFlag && (e.xGoogleFlag = void 0)
							}(e)
						})), new RTCSessionDescription({
							type: e.type,
							sdp: i.write(n)
						})
					}, c.prototype.mungeLocalDescription = function(e) {
						if (!l(e)) return e;
						var t = i.parse(e.sdp),
							n = this;
						return d(t, (function(e) {
							"recvonly" != e.direction && "inactive" != e.direction && n._restoreSimulcast(e)
						})), new RTCSessionDescription({
							type: e.type,
							sdp: i.write(t)
						})
					}, e.exports = c
				},
				6298: (e, t) => {
					t.writeSsrcs = function(e, t) {
						var n = [];
						if (void 0 !== e && 0 !== Object.keys(e).length) {
							Array.isArray(t) || (t = []);
							for (var i = 0; i < t.length; i++) {
								var s = t[i],
									r = e[s];
								Object.keys(r).forEach((function(e) {
									n.push({
										id: s,
										attribute: e,
										value: r[e]
									})
								}))
							}
							Object.keys(e).forEach((function(i) {
								if (i = parseInt(i), !(t.indexOf(i) >= 0)) {
									var s = e[i];
									Object.keys(s).forEach((function(e) {
										n.push({
											id: i,
											attribute: e,
											value: s[e]
										})
									}))
								}
							}))
						}
						return n
					}, t.parseSsrcs = function(e) {
						var t = {};
						return void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach((function(e) {
							t[e.id] || (t[e.id] = {}), t[e.id][e.attribute] = e.value
						})), t
					}
				},
				3577: (e, t) => {
					"use strict";
					t.byteLength = function(e) {
						var t = c(e),
							n = t[0],
							i = t[1];
						return 3 * (n + i) / 4 - i
					}, t.toByteArray = function(e) {
						var t, n, r = c(e),
							o = r[0],
							a = r[1],
							d = new s(function(e, t, n) {
								return 3 * (t + n) / 4 - n
							}(0, o, a)),
							l = 0,
							u = a > 0 ? o - 4 : o;
						for (n = 0; n < u; n += 4) t = i[e.charCodeAt(n)] << 18 | i[e.charCodeAt(n + 1)] << 12 | i[e.charCodeAt(n + 2)] << 6 | i[e.charCodeAt(n + 3)], d[l++] = t >> 16 & 255, d[l++] = t >> 8 & 255, d[l++] = 255 & t;
						return 2 === a && (t = i[e.charCodeAt(n)] << 2 | i[e.charCodeAt(n + 1)] >> 4, d[l++] = 255 & t), 1 === a && (t = i[e.charCodeAt(n)] << 10 | i[e.charCodeAt(n + 1)] << 4 | i[e.charCodeAt(n + 2)] >> 2, d[l++] = t >> 8 & 255, d[l++] = 255 & t), d
					}, t.fromByteArray = function(e) {
						for (var t, i = e.length, s = i % 3, r = [], o = 16383, a = 0, c = i - s; a < c; a += o) r.push(d(e, a, a + o > c ? c : a + o));
						return 1 === s ? (t = e[i - 1], r.push(n[t >> 2] + n[t << 4 & 63] + "==")) : 2 === s && (t = (e[i - 2] << 8) + e[i - 1], r.push(n[t >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + "=")), r.join("")
					};
					for (var n = [], i = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, a = r.length; o < a; ++o) n[o] = r[o], i[r.charCodeAt(o)] = o;

					function c(e) {
						var t = e.length;
						if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
						var n = e.indexOf("=");
						return -1 === n && (n = t), [n, n === t ? 0 : 4 - n % 4]
					}

					function d(e, t, i) {
						for (var s, r, o = [], a = t; a < i; a += 3) s = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), o.push(n[(r = s) >> 18 & 63] + n[r >> 12 & 63] + n[r >> 6 & 63] + n[63 & r]);
						return o.join("")
					}
					i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63
				},
				7032: function(e) {
					e.exports = function(e) {
						var t = {};

						function n(i) {
							if (t[i]) return t[i].exports;
							var s = t[i] = {
								i,
								l: !1,
								exports: {}
							};
							return e[i].call(s.exports, s, s.exports, n), s.l = !0, s.exports
						}
						return n.m = e, n.c = t, n.d = function(e, t, i) {
							n.o(e, t) || Object.defineProperty(e, t, {
								enumerable: !0,
								get: i
							})
						}, n.r = function(e) {
							"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
								value: "Module"
							}), Object.defineProperty(e, "__esModule", {
								value: !0
							})
						}, n.t = function(e, t) {
							if (1 & t && (e = n(e)), 8 & t) return e;
							if (4 & t && "object" == typeof e && e && e.__esModule) return e;
							var i = Object.create(null);
							if (n.r(i), Object.defineProperty(i, "default", {
									enumerable: !0,
									value: e
								}), 2 & t && "string" != typeof e)
								for (var s in e) n.d(i, s, function(t) {
									return e[t]
								}.bind(null, s));
							return i
						}, n.n = function(e) {
							var t = e && e.__esModule ? function() {
								return e.default
							} : function() {
								return e
							};
							return n.d(t, "a", t), t
						}, n.o = function(e, t) {
							return Object.prototype.hasOwnProperty.call(e, t)
						}, n.p = "", n(n.s = 90)
					}({
						17: function(e, t, n) {
							"use strict";
							t.__esModule = !0, t.default = void 0;
							var i = n(18),
								s = function() {
									function e() {}
									return e.getFirstMatch = function(e, t) {
										var n = t.match(e);
										return n && n.length > 0 && n[1] || ""
									}, e.getSecondMatch = function(e, t) {
										var n = t.match(e);
										return n && n.length > 1 && n[2] || ""
									}, e.matchAndReturnConst = function(e, t, n) {
										if (e.test(t)) return n
									}, e.getWindowsVersionName = function(e) {
										switch (e) {
											case "NT":
												return "NT";
											case "XP":
											case "NT 5.1":
												return "XP";
											case "NT 5.0":
												return "2000";
											case "NT 5.2":
												return "2003";
											case "NT 6.0":
												return "Vista";
											case "NT 6.1":
												return "7";
											case "NT 6.2":
												return "8";
											case "NT 6.3":
												return "8.1";
											case "NT 10.0":
												return "10";
											default:
												return
										}
									}, e.getMacOSVersionName = function(e) {
										var t = e.split(".").splice(0, 2).map((function(e) {
											return parseInt(e, 10) || 0
										}));
										if (t.push(0), 10 === t[0]) switch (t[1]) {
											case 5:
												return "Leopard";
											case 6:
												return "Snow Leopard";
											case 7:
												return "Lion";
											case 8:
												return "Mountain Lion";
											case 9:
												return "Mavericks";
											case 10:
												return "Yosemite";
											case 11:
												return "El Capitan";
											case 12:
												return "Sierra";
											case 13:
												return "High Sierra";
											case 14:
												return "Mojave";
											case 15:
												return "Catalina";
											default:
												return
										}
									}, e.getAndroidVersionName = function(e) {
										var t = e.split(".").splice(0, 2).map((function(e) {
											return parseInt(e, 10) || 0
										}));
										if (t.push(0), !(1 === t[0] && t[1] < 5)) return 1 === t[0] && t[1] < 6 ? "Cupcake" : 1 === t[0] && t[1] >= 6 ? "Donut" : 2 === t[0] && t[1] < 2 ? "Eclair" : 2 === t[0] && 2 === t[1] ? "Froyo" : 2 === t[0] && t[1] > 2 ? "Gingerbread" : 3 === t[0] ? "Honeycomb" : 4 === t[0] && t[1] < 1 ? "Ice Cream Sandwich" : 4 === t[0] && t[1] < 4 ? "Jelly Bean" : 4 === t[0] && t[1] >= 4 ? "KitKat" : 5 === t[0] ? "Lollipop" : 6 === t[0] ? "Marshmallow" : 7 === t[0] ? "Nougat" : 8 === t[0] ? "Oreo" : 9 === t[0] ? "Pie" : void 0
									}, e.getVersionPrecision = function(e) {
										return e.split(".").length
									}, e.compareVersions = function(t, n, i) {
										void 0 === i && (i = !1);
										var s = e.getVersionPrecision(t),
											r = e.getVersionPrecision(n),
											o = Math.max(s, r),
											a = 0,
											c = e.map([t, n], (function(t) {
												var n = o - e.getVersionPrecision(t),
													i = t + new Array(n + 1).join(".0");
												return e.map(i.split("."), (function(e) {
													return new Array(20 - e.length).join("0") + e
												})).reverse()
											}));
										for (i && (a = o - Math.min(s, r)), o -= 1; o >= a;) {
											if (c[0][o] > c[1][o]) return 1;
											if (c[0][o] === c[1][o]) {
												if (o === a) return 0;
												o -= 1
											} else if (c[0][o] < c[1][o]) return -1
										}
									}, e.map = function(e, t) {
										var n, i = [];
										if (Array.prototype.map) return Array.prototype.map.call(e, t);
										for (n = 0; n < e.length; n += 1) i.push(t(e[n]));
										return i
									}, e.getBrowserAlias = function(e) {
										return i.BROWSER_ALIASES_MAP[e]
									}, e.getBrowserTypeByAlias = function(e) {
										return i.BROWSER_MAP[e] || ""
									}, e
								}();
							t.default = s, e.exports = t.default
						},
						18: function(e, t, n) {
							"use strict";
							t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0, t.BROWSER_ALIASES_MAP = {
								"Amazon Silk": "amazon_silk",
								"Android Browser": "android",
								Bada: "bada",
								BlackBerry: "blackberry",
								Chrome: "chrome",
								Chromium: "chromium",
								Epiphany: "epiphany",
								Firefox: "firefox",
								Focus: "focus",
								Generic: "generic",
								"Google Search": "google_search",
								Googlebot: "googlebot",
								"Internet Explorer": "ie",
								"K-Meleon": "k_meleon",
								Maxthon: "maxthon",
								"Microsoft Edge": "edge",
								"MZ Browser": "mz",
								"NAVER Whale Browser": "naver",
								Opera: "opera",
								"Opera Coast": "opera_coast",
								PhantomJS: "phantomjs",
								Puffin: "puffin",
								QupZilla: "qupzilla",
								QQ: "qq",
								QQLite: "qqlite",
								Safari: "safari",
								Sailfish: "sailfish",
								"Samsung Internet for Android": "samsung_internet",
								SeaMonkey: "seamonkey",
								Sleipnir: "sleipnir",
								Swing: "swing",
								Tizen: "tizen",
								"UC Browser": "uc",
								Vivaldi: "vivaldi",
								"WebOS Browser": "webos",
								WeChat: "wechat",
								"Yandex Browser": "yandex",
								Roku: "roku"
							}, t.BROWSER_MAP = {
								amazon_silk: "Amazon Silk",
								android: "Android Browser",
								bada: "Bada",
								blackberry: "BlackBerry",
								chrome: "Chrome",
								chromium: "Chromium",
								epiphany: "Epiphany",
								firefox: "Firefox",
								focus: "Focus",
								generic: "Generic",
								googlebot: "Googlebot",
								google_search: "Google Search",
								ie: "Internet Explorer",
								k_meleon: "K-Meleon",
								maxthon: "Maxthon",
								edge: "Microsoft Edge",
								mz: "MZ Browser",
								naver: "NAVER Whale Browser",
								opera: "Opera",
								opera_coast: "Opera Coast",
								phantomjs: "PhantomJS",
								puffin: "Puffin",
								qupzilla: "QupZilla",
								qq: "QQ Browser",
								qqlite: "QQ Browser Lite",
								safari: "Safari",
								sailfish: "Sailfish",
								samsung_internet: "Samsung Internet for Android",
								seamonkey: "SeaMonkey",
								sleipnir: "Sleipnir",
								swing: "Swing",
								tizen: "Tizen",
								uc: "UC Browser",
								vivaldi: "Vivaldi",
								webos: "WebOS Browser",
								wechat: "WeChat",
								yandex: "Yandex Browser"
							}, t.PLATFORMS_MAP = {
								tablet: "tablet",
								mobile: "mobile",
								desktop: "desktop",
								tv: "tv"
							}, t.OS_MAP = {
								WindowsPhone: "Windows Phone",
								Windows: "Windows",
								MacOS: "macOS",
								iOS: "iOS",
								Android: "Android",
								WebOS: "WebOS",
								BlackBerry: "BlackBerry",
								Bada: "Bada",
								Tizen: "Tizen",
								Linux: "Linux",
								ChromeOS: "Chrome OS",
								PlayStation4: "PlayStation 4",
								Roku: "Roku"
							}, t.ENGINE_MAP = {
								EdgeHTML: "EdgeHTML",
								Blink: "Blink",
								Trident: "Trident",
								Presto: "Presto",
								Gecko: "Gecko",
								WebKit: "WebKit"
							}
						},
						90: function(e, t, n) {
							"use strict";
							t.__esModule = !0, t.default = void 0;
							var i, s = (i = n(91)) && i.__esModule ? i : {
									default: i
								},
								r = n(18);

							function o(e, t) {
								for (var n = 0; n < t.length; n++) {
									var i = t[n];
									i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
								}
							}
							var a = function() {
								function e() {}
								var t, n;
								return e.getParser = function(e, t) {
									if (void 0 === t && (t = !1), "string" != typeof e) throw new Error("UserAgent should be a string");
									return new s.default(e, t)
								}, e.parse = function(e) {
									return new s.default(e).getResult()
								}, t = e, n = [{
									key: "BROWSER_MAP",
									get: function() {
										return r.BROWSER_MAP
									}
								}, {
									key: "ENGINE_MAP",
									get: function() {
										return r.ENGINE_MAP
									}
								}, {
									key: "OS_MAP",
									get: function() {
										return r.OS_MAP
									}
								}, {
									key: "PLATFORMS_MAP",
									get: function() {
										return r.PLATFORMS_MAP
									}
								}], null && o(t.prototype, null), n && o(t, n), e
							}();
							t.default = a, e.exports = t.default
						},
						91: function(e, t, n) {
							"use strict";
							t.__esModule = !0, t.default = void 0;
							var i = c(n(92)),
								s = c(n(93)),
								r = c(n(94)),
								o = c(n(95)),
								a = c(n(17));

							function c(e) {
								return e && e.__esModule ? e : {
									default: e
								}
							}
							var d = function() {
								function e(e, t) {
									if (void 0 === t && (t = !1), null == e || "" === e) throw new Error("UserAgent parameter can't be empty");
									this._ua = e, this.parsedResult = {}, !0 !== t && this.parse()
								}
								var t = e.prototype;
								return t.getUA = function() {
									return this._ua
								}, t.test = function(e) {
									return e.test(this._ua)
								}, t.parseBrowser = function() {
									var e = this;
									this.parsedResult.browser = {};
									var t = i.default.find((function(t) {
										if ("function" == typeof t.test) return t.test(e);
										if (t.test instanceof Array) return t.test.some((function(t) {
											return e.test(t)
										}));
										throw new Error("Browser's test function is not valid")
									}));
									return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser
								}, t.getBrowser = function() {
									return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser()
								}, t.getBrowserName = function(e) {
									return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || ""
								}, t.getBrowserVersion = function() {
									return this.getBrowser().version
								}, t.getOS = function() {
									return this.parsedResult.os ? this.parsedResult.os : this.parseOS()
								}, t.parseOS = function() {
									var e = this;
									this.parsedResult.os = {};
									var t = s.default.find((function(t) {
										if ("function" == typeof t.test) return t.test(e);
										if (t.test instanceof Array) return t.test.some((function(t) {
											return e.test(t)
										}));
										throw new Error("Browser's test function is not valid")
									}));
									return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os
								}, t.getOSName = function(e) {
									var t = this.getOS().name;
									return e ? String(t).toLowerCase() || "" : t || ""
								}, t.getOSVersion = function() {
									return this.getOS().version
								}, t.getPlatform = function() {
									return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform()
								}, t.getPlatformType = function(e) {
									void 0 === e && (e = !1);
									var t = this.getPlatform().type;
									return e ? String(t).toLowerCase() || "" : t || ""
								}, t.parsePlatform = function() {
									var e = this;
									this.parsedResult.platform = {};
									var t = r.default.find((function(t) {
										if ("function" == typeof t.test) return t.test(e);
										if (t.test instanceof Array) return t.test.some((function(t) {
											return e.test(t)
										}));
										throw new Error("Browser's test function is not valid")
									}));
									return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform
								}, t.getEngine = function() {
									return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine()
								}, t.getEngineName = function(e) {
									return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || ""
								}, t.parseEngine = function() {
									var e = this;
									this.parsedResult.engine = {};
									var t = o.default.find((function(t) {
										if ("function" == typeof t.test) return t.test(e);
										if (t.test instanceof Array) return t.test.some((function(t) {
											return e.test(t)
										}));
										throw new Error("Browser's test function is not valid")
									}));
									return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine
								}, t.parse = function() {
									return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this
								}, t.getResult = function() {
									return Object.assign({}, this.parsedResult)
								}, t.satisfies = function(e) {
									var t = this,
										n = {},
										i = 0,
										s = {},
										r = 0;
									if (Object.keys(e).forEach((function(t) {
											var o = e[t];
											"string" == typeof o ? (s[t] = o, r += 1) : "object" == typeof o && (n[t] = o, i += 1)
										})), i > 0) {
										var o = Object.keys(n),
											a = o.find((function(e) {
												return t.isOS(e)
											}));
										if (a) {
											var c = this.satisfies(n[a]);
											if (void 0 !== c) return c
										}
										var d = o.find((function(e) {
											return t.isPlatform(e)
										}));
										if (d) {
											var l = this.satisfies(n[d]);
											if (void 0 !== l) return l
										}
									}
									if (r > 0) {
										var u = Object.keys(s).find((function(e) {
											return t.isBrowser(e, !0)
										}));
										if (void 0 !== u) return this.compareVersion(s[u])
									}
								}, t.isBrowser = function(e, t) {
									void 0 === t && (t = !1);
									var n = this.getBrowserName().toLowerCase(),
										i = e.toLowerCase(),
										s = a.default.getBrowserTypeByAlias(i);
									return t && s && (i = s.toLowerCase()), i === n
								}, t.compareVersion = function(e) {
									var t = [0],
										n = e,
										i = !1,
										s = this.getBrowserVersion();
									if ("string" == typeof s) return ">" === e[0] || "<" === e[0] ? (n = e.substr(1), "=" === e[1] ? (i = !0, n = e.substr(2)) : t = [], ">" === e[0] ? t.push(1) : t.push(-1)) : "=" === e[0] ? n = e.substr(1) : "~" === e[0] && (i = !0, n = e.substr(1)), t.indexOf(a.default.compareVersions(s, n, i)) > -1
								}, t.isOS = function(e) {
									return this.getOSName(!0) === String(e).toLowerCase()
								}, t.isPlatform = function(e) {
									return this.getPlatformType(!0) === String(e).toLowerCase()
								}, t.isEngine = function(e) {
									return this.getEngineName(!0) === String(e).toLowerCase()
								}, t.is = function(e) {
									return this.isBrowser(e) || this.isOS(e) || this.isPlatform(e)
								}, t.some = function(e) {
									var t = this;
									return void 0 === e && (e = []), e.some((function(e) {
										return t.is(e)
									}))
								}, e
							}();
							t.default = d, e.exports = t.default
						},
						92: function(e, t, n) {
							"use strict";
							t.__esModule = !0, t.default = void 0;
							var i, s = (i = n(17)) && i.__esModule ? i : {
									default: i
								},
								r = /version\/(\d+(\.?_?\d+)+)/i,
								o = [{
									test: [/googlebot/i],
									describe: function(e) {
										var t = {
												name: "Googlebot"
											},
											n = s.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/opera/i],
									describe: function(e) {
										var t = {
												name: "Opera"
											},
											n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/opr\/|opios/i],
									describe: function(e) {
										var t = {
												name: "Opera"
											},
											n = s.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/SamsungBrowser/i],
									describe: function(e) {
										var t = {
												name: "Samsung Internet for Android"
											},
											n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/Whale/i],
									describe: function(e) {
										var t = {
												name: "NAVER Whale Browser"
											},
											n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/MZBrowser/i],
									describe: function(e) {
										var t = {
												name: "MZ Browser"
											},
											n = s.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/focus/i],
									describe: function(e) {
										var t = {
												name: "Focus"
											},
											n = s.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/swing/i],
									describe: function(e) {
										var t = {
												name: "Swing"
											},
											n = s.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/coast/i],
									describe: function(e) {
										var t = {
												name: "Opera Coast"
											},
											n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/yabrowser/i],
									describe: function(e) {
										var t = {
												name: "Yandex Browser"
											},
											n = s.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/ucbrowser/i],
									describe: function(e) {
										var t = {
												name: "UC Browser"
											},
											n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/Maxthon|mxios/i],
									describe: function(e) {
										var t = {
												name: "Maxthon"
											},
											n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/epiphany/i],
									describe: function(e) {
										var t = {
												name: "Epiphany"
											},
											n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/puffin/i],
									describe: function(e) {
										var t = {
												name: "Puffin"
											},
											n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/sleipnir/i],
									describe: function(e) {
										var t = {
												name: "Sleipnir"
											},
											n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/k-meleon/i],
									describe: function(e) {
										var t = {
												name: "K-Meleon"
											},
											n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/micromessenger/i],
									describe: function(e) {
										var t = {
												name: "WeChat"
											},
											n = s.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/qqbrowser/i],
									describe: function(e) {
										var t = {
												name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
											},
											n = s.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/msie|trident/i],
									describe: function(e) {
										var t = {
												name: "Internet Explorer"
											},
											n = s.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/\sedg\//i],
									describe: function(e) {
										var t = {
												name: "Microsoft Edge"
											},
											n = s.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/edg([ea]|ios)/i],
									describe: function(e) {
										var t = {
												name: "Microsoft Edge"
											},
											n = s.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/vivaldi/i],
									describe: function(e) {
										var t = {
												name: "Vivaldi"
											},
											n = s.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/seamonkey/i],
									describe: function(e) {
										var t = {
												name: "SeaMonkey"
											},
											n = s.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/sailfish/i],
									describe: function(e) {
										var t = {
												name: "Sailfish"
											},
											n = s.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/silk/i],
									describe: function(e) {
										var t = {
												name: "Amazon Silk"
											},
											n = s.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/phantom/i],
									describe: function(e) {
										var t = {
												name: "PhantomJS"
											},
											n = s.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/slimerjs/i],
									describe: function(e) {
										var t = {
												name: "SlimerJS"
											},
											n = s.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
									describe: function(e) {
										var t = {
												name: "BlackBerry"
											},
											n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/(web|hpw)[o0]s/i],
									describe: function(e) {
										var t = {
												name: "WebOS Browser"
											},
											n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/bada/i],
									describe: function(e) {
										var t = {
												name: "Bada"
											},
											n = s.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/tizen/i],
									describe: function(e) {
										var t = {
												name: "Tizen"
											},
											n = s.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/qupzilla/i],
									describe: function(e) {
										var t = {
												name: "QupZilla"
											},
											n = s.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/firefox|iceweasel|fxios/i],
									describe: function(e) {
										var t = {
												name: "Firefox"
											},
											n = s.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/chromium/i],
									describe: function(e) {
										var t = {
												name: "Chromium"
											},
											n = s.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/chrome|crios|crmo/i],
									describe: function(e) {
										var t = {
												name: "Chrome"
											},
											n = s.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/GSA/i],
									describe: function(e) {
										var t = {
												name: "Google Search"
											},
											n = s.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: function(e) {
										var t = !e.test(/like android/i),
											n = e.test(/android/i);
										return t && n
									},
									describe: function(e) {
										var t = {
												name: "Android Browser"
											},
											n = s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/playstation 4/i],
									describe: function(e) {
										var t = {
												name: "PlayStation 4"
											},
											n = s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/safari|applewebkit/i],
									describe: function(e) {
										var t = {
												name: "Safari"
											},
											n = s.default.getFirstMatch(r, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/.*/i],
									describe: function(e) {
										var t = -1 !== e.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
										return {
											name: s.default.getFirstMatch(t, e),
											version: s.default.getSecondMatch(t, e)
										}
									}
								}];
							t.default = o, e.exports = t.default
						},
						93: function(e, t, n) {
							"use strict";
							t.__esModule = !0, t.default = void 0;
							var i, s = (i = n(17)) && i.__esModule ? i : {
									default: i
								},
								r = n(18),
								o = [{
									test: [/Roku\/DVP/],
									describe: function(e) {
										var t = s.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
										return {
											name: r.OS_MAP.Roku,
											version: t
										}
									}
								}, {
									test: [/windows phone/i],
									describe: function(e) {
										var t = s.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
										return {
											name: r.OS_MAP.WindowsPhone,
											version: t
										}
									}
								}, {
									test: [/windows/i],
									describe: function(e) {
										var t = s.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e),
											n = s.default.getWindowsVersionName(t);
										return {
											name: r.OS_MAP.Windows,
											version: t,
											versionName: n
										}
									}
								}, {
									test: [/macintosh/i],
									describe: function(e) {
										var t = s.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."),
											n = s.default.getMacOSVersionName(t),
											i = {
												name: r.OS_MAP.MacOS,
												version: t
											};
										return n && (i.versionName = n), i
									}
								}, {
									test: [/(ipod|iphone|ipad)/i],
									describe: function(e) {
										var t = s.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
										return {
											name: r.OS_MAP.iOS,
											version: t
										}
									}
								}, {
									test: function(e) {
										var t = !e.test(/like android/i),
											n = e.test(/android/i);
										return t && n
									},
									describe: function(e) {
										var t = s.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e),
											n = s.default.getAndroidVersionName(t),
											i = {
												name: r.OS_MAP.Android,
												version: t
											};
										return n && (i.versionName = n), i
									}
								}, {
									test: [/(web|hpw)[o0]s/i],
									describe: function(e) {
										var t = s.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e),
											n = {
												name: r.OS_MAP.WebOS
											};
										return t && t.length && (n.version = t), n
									}
								}, {
									test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
									describe: function(e) {
										var t = s.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || s.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || s.default.getFirstMatch(/\bbb(\d+)/i, e);
										return {
											name: r.OS_MAP.BlackBerry,
											version: t
										}
									}
								}, {
									test: [/bada/i],
									describe: function(e) {
										var t = s.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
										return {
											name: r.OS_MAP.Bada,
											version: t
										}
									}
								}, {
									test: [/tizen/i],
									describe: function(e) {
										var t = s.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
										return {
											name: r.OS_MAP.Tizen,
											version: t
										}
									}
								}, {
									test: [/linux/i],
									describe: function() {
										return {
											name: r.OS_MAP.Linux
										}
									}
								}, {
									test: [/CrOS/],
									describe: function() {
										return {
											name: r.OS_MAP.ChromeOS
										}
									}
								}, {
									test: [/PlayStation 4/],
									describe: function(e) {
										var t = s.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
										return {
											name: r.OS_MAP.PlayStation4,
											version: t
										}
									}
								}];
							t.default = o, e.exports = t.default
						},
						94: function(e, t, n) {
							"use strict";
							t.__esModule = !0, t.default = void 0;
							var i, s = (i = n(17)) && i.__esModule ? i : {
									default: i
								},
								r = n(18),
								o = [{
									test: [/googlebot/i],
									describe: function() {
										return {
											type: "bot",
											vendor: "Google"
										}
									}
								}, {
									test: [/huawei/i],
									describe: function(e) {
										var t = s.default.getFirstMatch(/(can-l01)/i, e) && "Nova",
											n = {
												type: r.PLATFORMS_MAP.mobile,
												vendor: "Huawei"
											};
										return t && (n.model = t), n
									}
								}, {
									test: [/nexus\s*(?:7|8|9|10).*/i],
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.tablet,
											vendor: "Nexus"
										}
									}
								}, {
									test: [/ipad/i],
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.tablet,
											vendor: "Apple",
											model: "iPad"
										}
									}
								}, {
									test: [/kftt build/i],
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.tablet,
											vendor: "Amazon",
											model: "Kindle Fire HD 7"
										}
									}
								}, {
									test: [/silk/i],
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.tablet,
											vendor: "Amazon"
										}
									}
								}, {
									test: [/tablet(?! pc)/i],
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.tablet
										}
									}
								}, {
									test: function(e) {
										var t = e.test(/ipod|iphone/i),
											n = e.test(/like (ipod|iphone)/i);
										return t && !n
									},
									describe: function(e) {
										var t = s.default.getFirstMatch(/(ipod|iphone)/i, e);
										return {
											type: r.PLATFORMS_MAP.mobile,
											vendor: "Apple",
											model: t
										}
									}
								}, {
									test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.mobile,
											vendor: "Nexus"
										}
									}
								}, {
									test: [/[^-]mobi/i],
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.mobile
										}
									}
								}, {
									test: function(e) {
										return "blackberry" === e.getBrowserName(!0)
									},
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.mobile,
											vendor: "BlackBerry"
										}
									}
								}, {
									test: function(e) {
										return "bada" === e.getBrowserName(!0)
									},
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.mobile
										}
									}
								}, {
									test: function(e) {
										return "windows phone" === e.getBrowserName()
									},
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.mobile,
											vendor: "Microsoft"
										}
									}
								}, {
									test: function(e) {
										var t = Number(String(e.getOSVersion()).split(".")[0]);
										return "android" === e.getOSName(!0) && t >= 3
									},
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.tablet
										}
									}
								}, {
									test: function(e) {
										return "android" === e.getOSName(!0)
									},
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.mobile
										}
									}
								}, {
									test: function(e) {
										return "macos" === e.getOSName(!0)
									},
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.desktop,
											vendor: "Apple"
										}
									}
								}, {
									test: function(e) {
										return "windows" === e.getOSName(!0)
									},
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.desktop
										}
									}
								}, {
									test: function(e) {
										return "linux" === e.getOSName(!0)
									},
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.desktop
										}
									}
								}, {
									test: function(e) {
										return "playstation 4" === e.getOSName(!0)
									},
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.tv
										}
									}
								}, {
									test: function(e) {
										return "roku" === e.getOSName(!0)
									},
									describe: function() {
										return {
											type: r.PLATFORMS_MAP.tv
										}
									}
								}];
							t.default = o, e.exports = t.default
						},
						95: function(e, t, n) {
							"use strict";
							t.__esModule = !0, t.default = void 0;
							var i, s = (i = n(17)) && i.__esModule ? i : {
									default: i
								},
								r = n(18),
								o = [{
									test: function(e) {
										return "microsoft edge" === e.getBrowserName(!0)
									},
									describe: function(e) {
										if (/\sedg\//i.test(e)) return {
											name: r.ENGINE_MAP.Blink
										};
										var t = s.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
										return {
											name: r.ENGINE_MAP.EdgeHTML,
											version: t
										}
									}
								}, {
									test: [/trident/i],
									describe: function(e) {
										var t = {
												name: r.ENGINE_MAP.Trident
											},
											n = s.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: function(e) {
										return e.test(/presto/i)
									},
									describe: function(e) {
										var t = {
												name: r.ENGINE_MAP.Presto
											},
											n = s.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: function(e) {
										var t = e.test(/gecko/i),
											n = e.test(/like gecko/i);
										return t && !n
									},
									describe: function(e) {
										var t = {
												name: r.ENGINE_MAP.Gecko
											},
											n = s.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}, {
									test: [/(apple)?webkit\/537\.36/i],
									describe: function() {
										return {
											name: r.ENGINE_MAP.Blink
										}
									}
								}, {
									test: [/(apple)?webkit/i],
									describe: function(e) {
										var t = {
												name: r.ENGINE_MAP.WebKit
											},
											n = s.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
										return n && (t.version = n), t
									}
								}];
							t.default = o, e.exports = t.default
						}
					})
				},
				6799: function(e, t) {
					var n, i;
					this || window, void 0 === (i = "function" == typeof(n = function() {
						var e = /^(interactive|loaded|complete)$/,
							t = window.location ? window.location.href : null,
							n = t && t.replace(/#.*$/, "").replace(/\?.*$/, "") || null,
							i = document.getElementsByTagName("script"),
							s = "readyState" in (i[0] || document.createElement("script")),
							r = !window.opera || "[object Opera]" !== window.opera.toString(),
							o = "currentScript" in document;
						"stackTraceLimit" in Error && Error.stackTraceLimit !== 1 / 0 && (Error.stackTraceLimit, Error.stackTraceLimit = 1 / 0);
						var a = !1,
							c = !1;

						function d(e, t) {
							var n, i = null,
								s = "number" == typeof t;
							return t = s ? Math.round(t) : 0, "string" == typeof e && e && (s ? n = e.match(/(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/) : (n = e.match(/^(?:|[^:@]*@|.+\)@(?=data:text\/javascript|blob|http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)) && n[1] || (n = e.match(/\)@(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)), n && n[1] && (i = t > 0 ? d(e.slice(e.indexOf(n[0]) + n[0].length), t - 1) : n[1])), i
						}

						function l() {
							if (0 === i.length) return null;
							var t, u, h, p, m, f = [],
								g = l.skipStackDepth || 1;
							for (t = 0; t < i.length; t++) r && s ? e.test(i[t].readyState) && f.push(i[t]) : f.push(i[t]);
							if (u = new Error, a && (h = u.stack), !h && c) try {
								throw u
							} catch (e) {
								h = e.stack
							}
							if (h && !(m = function(e, t) {
									var n, s = null;
									if (t = t || i, "string" == typeof e && e)
										for (n = t.length; n--;)
											if (t[n].src === e) {
												s = t[n];
												break
											} return s
								}(p = d(h, g), f)) && n && p === n && (m = function(e) {
									var t, n, s = null;
									for (t = 0, n = (e = e || i).length; t < n; t++)
										if (!e[t].hasAttribute("src")) {
											if (s) {
												s = null;
												break
											}
											s = e[t]
										} return s
								}(f)), m || 1 === f.length && (m = f[0]), m || o && (m = document.currentScript), !m && r && s)
								for (t = f.length; t--;)
									if ("interactive" === f[t].readyState) {
										m = f[t];
										break
									} return m || (m = f[f.length - 1] || null), m
						}(function() {
							try {
								var e = new Error;
								throw a = "string" == typeof e.stack && !!e.stack, e
							} catch (e) {
								c = "string" == typeof e.stack && !!e.stack
							}
						})(), l.skipStackDepth = 1;
						var u = l;
						return u.near = l, u.far = function() {
							return null
						}, u.origin = function() {
							return null
						}, u
					}) ? n.apply(t, []) : n) || (e.exports = i)
				},
				6857: e => {
					"use strict";
					var t, n = "object" == typeof Reflect ? Reflect : null,
						i = n && "function" == typeof n.apply ? n.apply : function(e, t, n) {
							return Function.prototype.apply.call(e, t, n)
						};
					t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e) {
						return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
					} : function(e) {
						return Object.getOwnPropertyNames(e)
					};
					var s = Number.isNaN || function(e) {
						return e != e
					};

					function r() {
						r.init.call(this)
					}
					e.exports = r, e.exports.once = function(e, t) {
						return new Promise((function(n, i) {
							function s(n) {
								e.removeListener(t, r), i(n)
							}

							function r() {
								"function" == typeof e.removeListener && e.removeListener("error", s), n([].slice.call(arguments))
							}
							f(e, t, r, {
								once: !0
							}), "error" !== t && function(e, t, n) {
								"function" == typeof e.on && f(e, "error", t, {
									once: !0
								})
							}(e, s)
						}))
					}, r.EventEmitter = r, r.prototype._events = void 0, r.prototype._eventsCount = 0, r.prototype._maxListeners = void 0;
					var o = 10;

					function a(e) {
						if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
					}

					function c(e) {
						return void 0 === e._maxListeners ? r.defaultMaxListeners : e._maxListeners
					}

					function d(e, t, n, i) {
						var s, r, o, d;
						if (a(n), void 0 === (r = e._events) ? (r = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== r.newListener && (e.emit("newListener", t, n.listener ? n.listener : n), r = e._events), o = r[t]), void 0 === o) o = r[t] = n, ++e._eventsCount;
						else if ("function" == typeof o ? o = r[t] = i ? [n, o] : [o, n] : i ? o.unshift(n) : o.push(n), (s = c(e)) > 0 && o.length > s && !o.warned) {
							o.warned = !0;
							var l = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
							l.name = "MaxListenersExceededWarning", l.emitter = e, l.type = t, l.count = o.length, d = l, console && console.warn && console.warn(d)
						}
						return e
					}

					function l() {
						if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
					}

					function u(e, t, n) {
						var i = {
								fired: !1,
								wrapFn: void 0,
								target: e,
								type: t,
								listener: n
							},
							s = l.bind(i);
						return s.listener = n, i.wrapFn = s, s
					}

					function h(e, t, n) {
						var i = e._events;
						if (void 0 === i) return [];
						var s = i[t];
						return void 0 === s ? [] : "function" == typeof s ? n ? [s.listener || s] : [s] : n ? function(e) {
							for (var t = new Array(e.length), n = 0; n < t.length; ++n) t[n] = e[n].listener || e[n];
							return t
						}(s) : m(s, s.length)
					}

					function p(e) {
						var t = this._events;
						if (void 0 !== t) {
							var n = t[e];
							if ("function" == typeof n) return 1;
							if (void 0 !== n) return n.length
						}
						return 0
					}

					function m(e, t) {
						for (var n = new Array(t), i = 0; i < t; ++i) n[i] = e[i];
						return n
					}

					function f(e, t, n, i) {
						if ("function" == typeof e.on) i.once ? e.once(t, n) : e.on(t, n);
						else {
							if ("function" != typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
							e.addEventListener(t, (function s(r) {
								i.once && e.removeEventListener(t, s), n(r)
							}))
						}
					}
					Object.defineProperty(r, "defaultMaxListeners", {
						enumerable: !0,
						get: function() {
							return o
						},
						set: function(e) {
							if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
							o = e
						}
					}), r.init = function() {
						void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
					}, r.prototype.setMaxListeners = function(e) {
						if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
						return this._maxListeners = e, this
					}, r.prototype.getMaxListeners = function() {
						return c(this)
					}, r.prototype.emit = function(e) {
						for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
						var s = "error" === e,
							r = this._events;
						if (void 0 !== r) s = s && void 0 === r.error;
						else if (!s) return !1;
						if (s) {
							var o;
							if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
							var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
							throw a.context = o, a
						}
						var c = r[e];
						if (void 0 === c) return !1;
						if ("function" == typeof c) i(c, this, t);
						else {
							var d = c.length,
								l = m(c, d);
							for (n = 0; n < d; ++n) i(l[n], this, t)
						}
						return !0
					}, r.prototype.addListener = function(e, t) {
						return d(this, e, t, !1)
					}, r.prototype.on = r.prototype.addListener, r.prototype.prependListener = function(e, t) {
						return d(this, e, t, !0)
					}, r.prototype.once = function(e, t) {
						return a(t), this.on(e, u(this, e, t)), this
					}, r.prototype.prependOnceListener = function(e, t) {
						return a(t), this.prependListener(e, u(this, e, t)), this
					}, r.prototype.removeListener = function(e, t) {
						var n, i, s, r, o;
						if (a(t), void 0 === (i = this._events)) return this;
						if (void 0 === (n = i[e])) return this;
						if (n === t || n.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || t));
						else if ("function" != typeof n) {
							for (s = -1, r = n.length - 1; r >= 0; r--)
								if (n[r] === t || n[r].listener === t) {
									o = n[r].listener, s = r;
									break
								} if (s < 0) return this;
							0 === s ? n.shift() : function(e, t) {
								for (; t + 1 < e.length; t++) e[t] = e[t + 1];
								e.pop()
							}(n, s), 1 === n.length && (i[e] = n[0]), void 0 !== i.removeListener && this.emit("removeListener", e, o || t)
						}
						return this
					}, r.prototype.off = r.prototype.removeListener, r.prototype.removeAllListeners = function(e) {
						var t, n, i;
						if (void 0 === (n = this._events)) return this;
						if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[e]), this;
						if (0 === arguments.length) {
							var s, r = Object.keys(n);
							for (i = 0; i < r.length; ++i) "removeListener" !== (s = r[i]) && this.removeAllListeners(s);
							return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
						}
						if ("function" == typeof(t = n[e])) this.removeListener(e, t);
						else if (void 0 !== t)
							for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
						return this
					}, r.prototype.listeners = function(e) {
						return h(this, e, !0)
					}, r.prototype.rawListeners = function(e) {
						return h(this, e, !1)
					}, r.listenerCount = function(e, t) {
						return "function" == typeof e.listenerCount ? e.listenerCount(t) : p.call(e, t)
					}, r.prototype.listenerCount = p, r.prototype.eventNames = function() {
						return this._eventsCount > 0 ? t(this._events) : []
					}
				},
				8387: function(e, t) {
					var n;
					! function(t, n) {
						"use strict";
						"object" == typeof e.exports ? e.exports = t.document ? n(t, !0) : function(e) {
							if (!e.document) throw new Error("jQuery requires a window with a document");
							return n(e)
						} : n(t)
					}("undefined" != typeof window ? window : this, (function(i, s) {
						"use strict";
						var r = [],
							o = Object.getPrototypeOf,
							a = r.slice,
							c = r.flat ? function(e) {
								return r.flat.call(e)
							} : function(e) {
								return r.concat.apply([], e)
							},
							d = r.push,
							l = r.indexOf,
							u = {},
							h = u.toString,
							p = u.hasOwnProperty,
							m = p.toString,
							f = m.call(Object),
							g = {},
							_ = function(e) {
								return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item
							},
							v = function(e) {
								return null != e && e === e.window
							},
							S = i.document,
							E = {
								type: !0,
								src: !0,
								nonce: !0,
								noModule: !0
							};

						function y(e, t, n) {
							var i, s, r = (n = n || S).createElement("script");
							if (r.text = e, t)
								for (i in E)(s = t[i] || t.getAttribute && t.getAttribute(i)) && r.setAttribute(i, s);
							n.head.appendChild(r).parentNode.removeChild(r)
						}

						function T(e) {
							return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? u[h.call(e)] || "object" : typeof e
						}
						var C = "3.6.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-deprecated/ajax-event-alias,-effects,-effects/Tween,-effects/animatedSelector",
							b = function(e, t) {
								return new b.fn.init(e, t)
							};

						function A(e) {
							var t = !!e && "length" in e && e.length,
								n = T(e);
							return !_(e) && !v(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e)
						}
						b.fn = b.prototype = {
							jquery: C,
							constructor: b,
							length: 0,
							toArray: function() {
								return a.call(this)
							},
							get: function(e) {
								return null == e ? a.call(this) : e < 0 ? this[e + this.length] : this[e]
							},
							pushStack: function(e) {
								var t = b.merge(this.constructor(), e);
								return t.prevObject = this, t
							},
							each: function(e) {
								return b.each(this, e)
							},
							map: function(e) {
								return this.pushStack(b.map(this, (function(t, n) {
									return e.call(t, n, t)
								})))
							},
							slice: function() {
								return this.pushStack(a.apply(this, arguments))
							},
							first: function() {
								return this.eq(0)
							},
							last: function() {
								return this.eq(-1)
							},
							even: function() {
								return this.pushStack(b.grep(this, (function(e, t) {
									return (t + 1) % 2
								})))
							},
							odd: function() {
								return this.pushStack(b.grep(this, (function(e, t) {
									return t % 2
								})))
							},
							eq: function(e) {
								var t = this.length,
									n = +e + (e < 0 ? t : 0);
								return this.pushStack(0 <= n && n < t ? [this[n]] : [])
							},
							end: function() {
								return this.prevObject || this.constructor()
							},
							push: d,
							sort: r.sort,
							splice: r.splice
						}, b.extend = b.fn.extend = function() {
							var e, t, n, i, s, r, o = arguments[0] || {},
								a = 1,
								c = arguments.length,
								d = !1;
							for ("boolean" == typeof o && (d = o, o = arguments[a] || {}, a++), "object" == typeof o || _(o) || (o = {}), a === c && (o = this, a--); a < c; a++)
								if (null != (e = arguments[a]))
									for (t in e) i = e[t], "__proto__" !== t && o !== i && (d && i && (b.isPlainObject(i) || (s = Array.isArray(i))) ? (n = o[t], r = s && !Array.isArray(n) ? [] : s || b.isPlainObject(n) ? n : {}, s = !1, o[t] = b.extend(d, r, i)) : void 0 !== i && (o[t] = i));
							return o
						}, b.extend({
							expando: "jQuery" + (C + Math.random()).replace(/\D/g, ""),
							isReady: !0,
							error: function(e) {
								throw new Error(e)
							},
							noop: function() {},
							isPlainObject: function(e) {
								var t, n;
								return !(!e || "[object Object]" !== h.call(e) || (t = o(e)) && ("function" != typeof(n = p.call(t, "constructor") && t.constructor) || m.call(n) !== f))
							},
							isEmptyObject: function(e) {
								var t;
								for (t in e) return !1;
								return !0
							},
							globalEval: function(e, t, n) {
								y(e, {
									nonce: t && t.nonce
								}, n)
							},
							each: function(e, t) {
								var n, i = 0;
								if (A(e))
									for (n = e.length; i < n && !1 !== t.call(e[i], i, e[i]); i++);
								else
									for (i in e)
										if (!1 === t.call(e[i], i, e[i])) break;
								return e
							},
							makeArray: function(e, t) {
								var n = t || [];
								return null != e && (A(Object(e)) ? b.merge(n, "string" == typeof e ? [e] : e) : d.call(n, e)), n
							},
							inArray: function(e, t, n) {
								return null == t ? -1 : l.call(t, e, n)
							},
							merge: function(e, t) {
								for (var n = +t.length, i = 0, s = e.length; i < n; i++) e[s++] = t[i];
								return e.length = s, e
							},
							grep: function(e, t, n) {
								for (var i = [], s = 0, r = e.length, o = !n; s < r; s++) !t(e[s], s) !== o && i.push(e[s]);
								return i
							},
							map: function(e, t, n) {
								var i, s, r = 0,
									o = [];
								if (A(e))
									for (i = e.length; r < i; r++) null != (s = t(e[r], r, n)) && o.push(s);
								else
									for (r in e) null != (s = t(e[r], r, n)) && o.push(s);
								return c(o)
							},
							guid: 1,
							support: g
						}), "function" == typeof Symbol && (b.fn[Symbol.iterator] = r[Symbol.iterator]), b.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function(e, t) {
							u["[object " + t + "]"] = t.toLowerCase()
						}));
						var R = function(e) {
							var t, n, i, s, r, o, a, c, d, l, u, h, p, m, f, g, _, v, S, E = "sizzle" + 1 * new Date,
								y = e.document,
								T = 0,
								C = 0,
								b = ce(),
								A = ce(),
								R = ce(),
								I = ce(),
								P = function(e, t) {
									return e === t && (u = !0), 0
								},
								D = {}.hasOwnProperty,
								w = [],
								O = w.pop,
								N = w.push,
								M = w.push,
								L = w.slice,
								k = function(e, t) {
									for (var n = 0, i = e.length; n < i; n++)
										if (e[n] === t) return n;
									return -1
								},
								x = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
								F = "[\\x20\\t\\r\\n\\f]",
								V = "(?:\\\\[\\da-fA-F]{1,6}" + F + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
								U = "\\[" + F + "*(" + V + ")(?:" + F + "*([*^$|!~]?=)" + F + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + V + "))|)" + F + "*\\]",
								j = ":(" + V + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + U + ")*)|.*)\\)|)",
								H = new RegExp(F + "+", "g"),
								B = new RegExp("^" + F + "+|((?:^|[^\\\\])(?:\\\\.)*)" + F + "+$", "g"),
								$ = new RegExp("^" + F + "*," + F + "*"),
								J = new RegExp("^" + F + "*([>+~]|" + F + ")" + F + "*"),
								G = new RegExp(F + "|>"),
								q = new RegExp(j),
								K = new RegExp("^" + V + "$"),
								W = {
									ID: new RegExp("^#(" + V + ")"),
									CLASS: new RegExp("^\\.(" + V + ")"),
									TAG: new RegExp("^(" + V + "|[*])"),
									ATTR: new RegExp("^" + U),
									PSEUDO: new RegExp("^" + j),
									CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + F + "*(even|odd|(([+-]|)(\\d*)n|)" + F + "*(?:([+-]|)" + F + "*(\\d+)|))" + F + "*\\)|)", "i"),
									bool: new RegExp("^(?:" + x + ")$", "i"),
									needsContext: new RegExp("^" + F + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + F + "*((?:-\\d)?\\d*)" + F + "*\\)|)(?=[^-]|$)", "i")
								},
								X = /HTML$/i,
								z = /^(?:input|select|textarea|button)$/i,
								Y = /^h\d$/i,
								Q = /^[^{]+\{\s*\[native \w/,
								Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
								ee = /[+~]/,
								te = new RegExp("\\\\[\\da-fA-F]{1,6}" + F + "?|\\\\([^\\r\\n\\f])", "g"),
								ne = function(e, t) {
									var n = "0x" + e.slice(1) - 65536;
									return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
								},
								ie = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
								se = function(e, t) {
									return t ? "\0" === e ? "" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
								},
								re = function() {
									h()
								},
								oe = Ee((function(e) {
									return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase()
								}), {
									dir: "parentNode",
									next: "legend"
								});
							try {
								M.apply(w = L.call(y.childNodes), y.childNodes), w[y.childNodes.length].nodeType
							} catch (t) {
								M = {
									apply: w.length ? function(e, t) {
										N.apply(e, L.call(t))
									} : function(e, t) {
										for (var n = e.length, i = 0; e[n++] = t[i++];);
										e.length = n - 1
									}
								}
							}

							function ae(e, t, i, s) {
								var r, a, d, l, u, m, _, v = t && t.ownerDocument,
									y = t ? t.nodeType : 9;
								if (i = i || [], "string" != typeof e || !e || 1 !== y && 9 !== y && 11 !== y) return i;
								if (!s && (h(t), t = t || p, f)) {
									if (11 !== y && (u = Z.exec(e)))
										if (r = u[1]) {
											if (9 === y) {
												if (!(d = t.getElementById(r))) return i;
												if (d.id === r) return i.push(d), i
											} else if (v && (d = v.getElementById(r)) && S(t, d) && d.id === r) return i.push(d), i
										} else {
											if (u[2]) return M.apply(i, t.getElementsByTagName(e)), i;
											if ((r = u[3]) && n.getElementsByClassName && t.getElementsByClassName) return M.apply(i, t.getElementsByClassName(r)), i
										} if (n.qsa && !I[e + " "] && (!g || !g.test(e)) && (1 !== y || "object" !== t.nodeName.toLowerCase())) {
										if (_ = e, v = t, 1 === y && (G.test(e) || J.test(e))) {
											for ((v = ee.test(e) && _e(t.parentNode) || t) === t && n.scope || ((l = t.getAttribute("id")) ? l = l.replace(ie, se) : t.setAttribute("id", l = E)), a = (m = o(e)).length; a--;) m[a] = (l ? "#" + l : ":scope") + " " + Se(m[a]);
											_ = m.join(",")
										}
										try {
											return M.apply(i, v.querySelectorAll(_)), i
										} catch (t) {
											I(e, !0)
										} finally {
											l === E && t.removeAttribute("id")
										}
									}
								}
								return c(e.replace(B, "$1"), t, i, s)
							}

							function ce() {
								var e = [];
								return function t(n, s) {
									return e.push(n + " ") > i.cacheLength && delete t[e.shift()], t[n + " "] = s
								}
							}

							function de(e) {
								return e[E] = !0, e
							}

							function le(e) {
								var t = p.createElement("fieldset");
								try {
									return !!e(t)
								} catch (e) {
									return !1
								} finally {
									t.parentNode && t.parentNode.removeChild(t), t = null
								}
							}

							function ue(e, t) {
								for (var n = e.split("|"), s = n.length; s--;) i.attrHandle[n[s]] = t
							}

							function he(e, t) {
								var n = t && e,
									i = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
								if (i) return i;
								if (n)
									for (; n = n.nextSibling;)
										if (n === t) return -1;
								return e ? 1 : -1
							}

							function pe(e) {
								return function(t) {
									return "input" === t.nodeName.toLowerCase() && t.type === e
								}
							}

							function me(e) {
								return function(t) {
									var n = t.nodeName.toLowerCase();
									return ("input" === n || "button" === n) && t.type === e
								}
							}

							function fe(e) {
								return function(t) {
									return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && oe(t) === e : t.disabled === e : "label" in t && t.disabled === e
								}
							}

							function ge(e) {
								return de((function(t) {
									return t = +t, de((function(n, i) {
										for (var s, r = e([], n.length, t), o = r.length; o--;) n[s = r[o]] && (n[s] = !(i[s] = n[s]))
									}))
								}))
							}

							function _e(e) {
								return e && void 0 !== e.getElementsByTagName && e
							}
							for (t in n = ae.support = {}, r = ae.isXML = function(e) {
									var t = e && e.namespaceURI,
										n = e && (e.ownerDocument || e).documentElement;
									return !X.test(t || n && n.nodeName || "HTML")
								}, h = ae.setDocument = function(e) {
									var t, s, o = e ? e.ownerDocument || e : y;
									return o != p && 9 === o.nodeType && o.documentElement && (m = (p = o).documentElement, f = !r(p), y != p && (s = p.defaultView) && s.top !== s && (s.addEventListener ? s.addEventListener("unload", re, !1) : s.attachEvent && s.attachEvent("onunload", re)), n.scope = le((function(e) {
										return m.appendChild(e).appendChild(p.createElement("div")), void 0 !== e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length
									})), n.attributes = le((function(e) {
										return e.className = "i", !e.getAttribute("className")
									})), n.getElementsByTagName = le((function(e) {
										return e.appendChild(p.createComment("")), !e.getElementsByTagName("*").length
									})), n.getElementsByClassName = Q.test(p.getElementsByClassName), n.getById = le((function(e) {
										return m.appendChild(e).id = E, !p.getElementsByName || !p.getElementsByName(E).length
									})), n.getById ? (i.filter.ID = function(e) {
										var t = e.replace(te, ne);
										return function(e) {
											return e.getAttribute("id") === t
										}
									}, i.find.ID = function(e, t) {
										if (void 0 !== t.getElementById && f) {
											var n = t.getElementById(e);
											return n ? [n] : []
										}
									}) : (i.filter.ID = function(e) {
										var t = e.replace(te, ne);
										return function(e) {
											var n = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
											return n && n.value === t
										}
									}, i.find.ID = function(e, t) {
										if (void 0 !== t.getElementById && f) {
											var n, i, s, r = t.getElementById(e);
											if (r) {
												if ((n = r.getAttributeNode("id")) && n.value === e) return [r];
												for (s = t.getElementsByName(e), i = 0; r = s[i++];)
													if ((n = r.getAttributeNode("id")) && n.value === e) return [r]
											}
											return []
										}
									}), i.find.TAG = n.getElementsByTagName ? function(e, t) {
										return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0
									} : function(e, t) {
										var n, i = [],
											s = 0,
											r = t.getElementsByTagName(e);
										if ("*" === e) {
											for (; n = r[s++];) 1 === n.nodeType && i.push(n);
											return i
										}
										return r
									}, i.find.CLASS = n.getElementsByClassName && function(e, t) {
										if (void 0 !== t.getElementsByClassName && f) return t.getElementsByClassName(e)
									}, _ = [], g = [], (n.qsa = Q.test(p.querySelectorAll)) && (le((function(e) {
										var t;
										m.appendChild(e).innerHTML = "<a id='" + E + "'></a><select id='" + E + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && g.push("[*^$]=" + F + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || g.push("\\[" + F + "*(?:value|" + x + ")"), e.querySelectorAll("[id~=" + E + "-]").length || g.push("~="), (t = p.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || g.push("\\[" + F + "*name" + F + "*=" + F + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || g.push(":checked"), e.querySelectorAll("a#" + E + "+*").length || g.push(".#.+[+~]"), e.querySelectorAll("\\\f"), g.push("[\\r\\n\\f]")
									})), le((function(e) {
										e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
										var t = p.createElement("input");
										t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && g.push("name" + F + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && g.push(":enabled", ":disabled"), m.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && g.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), g.push(",.*:")
									}))), (n.matchesSelector = Q.test(v = m.matches || m.webkitMatchesSelector || m.mozMatchesSelector || m.oMatchesSelector || m.msMatchesSelector)) && le((function(e) {
										n.disconnectedMatch = v.call(e, "*"), v.call(e, "[s!='']:x"), _.push("!=", j)
									})), g = g.length && new RegExp(g.join("|")), _ = _.length && new RegExp(_.join("|")), t = Q.test(m.compareDocumentPosition), S = t || Q.test(m.contains) ? function(e, t) {
										var n = 9 === e.nodeType ? e.documentElement : e,
											i = t && t.parentNode;
										return e === i || !(!i || 1 !== i.nodeType || !(n.contains ? n.contains(i) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(i)))
									} : function(e, t) {
										if (t)
											for (; t = t.parentNode;)
												if (t === e) return !0;
										return !1
									}, P = t ? function(e, t) {
										if (e === t) return u = !0, 0;
										var i = !e.compareDocumentPosition - !t.compareDocumentPosition;
										return i || (1 & (i = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === i ? e == p || e.ownerDocument == y && S(y, e) ? -1 : t == p || t.ownerDocument == y && S(y, t) ? 1 : l ? k(l, e) - k(l, t) : 0 : 4 & i ? -1 : 1)
									} : function(e, t) {
										if (e === t) return u = !0, 0;
										var n, i = 0,
											s = e.parentNode,
											r = t.parentNode,
											o = [e],
											a = [t];
										if (!s || !r) return e == p ? -1 : t == p ? 1 : s ? -1 : r ? 1 : l ? k(l, e) - k(l, t) : 0;
										if (s === r) return he(e, t);
										for (n = e; n = n.parentNode;) o.unshift(n);
										for (n = t; n = n.parentNode;) a.unshift(n);
										for (; o[i] === a[i];) i++;
										return i ? he(o[i], a[i]) : o[i] == y ? -1 : a[i] == y ? 1 : 0
									}), p
								}, ae.matches = function(e, t) {
									return ae(e, null, null, t)
								}, ae.matchesSelector = function(e, t) {
									if (h(e), n.matchesSelector && f && !I[t + " "] && (!_ || !_.test(t)) && (!g || !g.test(t))) try {
										var i = v.call(e, t);
										if (i || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return i
									} catch (e) {
										I(t, !0)
									}
									return 0 < ae(t, p, null, [e]).length
								}, ae.contains = function(e, t) {
									return (e.ownerDocument || e) != p && h(e), S(e, t)
								}, ae.attr = function(e, t) {
									(e.ownerDocument || e) != p && h(e);
									var s = i.attrHandle[t.toLowerCase()],
										r = s && D.call(i.attrHandle, t.toLowerCase()) ? s(e, t, !f) : void 0;
									return void 0 !== r ? r : n.attributes || !f ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
								}, ae.escape = function(e) {
									return (e + "").replace(ie, se)
								}, ae.error = function(e) {
									throw new Error("Syntax error, unrecognized expression: " + e)
								}, ae.uniqueSort = function(e) {
									var t, i = [],
										s = 0,
										r = 0;
									if (u = !n.detectDuplicates, l = !n.sortStable && e.slice(0), e.sort(P), u) {
										for (; t = e[r++];) t === e[r] && (s = i.push(r));
										for (; s--;) e.splice(i[s], 1)
									}
									return l = null, e
								}, s = ae.getText = function(e) {
									var t, n = "",
										i = 0,
										r = e.nodeType;
									if (r) {
										if (1 === r || 9 === r || 11 === r) {
											if ("string" == typeof e.textContent) return e.textContent;
											for (e = e.firstChild; e; e = e.nextSibling) n += s(e)
										} else if (3 === r || 4 === r) return e.nodeValue
									} else
										for (; t = e[i++];) n += s(t);
									return n
								}, (i = ae.selectors = {
									cacheLength: 50,
									createPseudo: de,
									match: W,
									attrHandle: {},
									find: {},
									relative: {
										">": {
											dir: "parentNode",
											first: !0
										},
										" ": {
											dir: "parentNode"
										},
										"+": {
											dir: "previousSibling",
											first: !0
										},
										"~": {
											dir: "previousSibling"
										}
									},
									preFilter: {
										ATTR: function(e) {
											return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
										},
										CHILD: function(e) {
											return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || ae.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && ae.error(e[0]), e
										},
										PSEUDO: function(e) {
											var t, n = !e[6] && e[2];
											return W.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && q.test(n) && (t = o(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
										}
									},
									filter: {
										TAG: function(e) {
											var t = e.replace(te, ne).toLowerCase();
											return "*" === e ? function() {
												return !0
											} : function(e) {
												return e.nodeName && e.nodeName.toLowerCase() === t
											}
										},
										CLASS: function(e) {
											var t = b[e + " "];
											return t || (t = new RegExp("(^|" + F + ")" + e + "(" + F + "|$)")) && b(e, (function(e) {
												return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "")
											}))
										},
										ATTR: function(e, t, n) {
											return function(i) {
												var s = ae.attr(i, e);
												return null == s ? "!=" === t : !t || (s += "", "=" === t ? s === n : "!=" === t ? s !== n : "^=" === t ? n && 0 === s.indexOf(n) : "*=" === t ? n && -1 < s.indexOf(n) : "$=" === t ? n && s.slice(-n.length) === n : "~=" === t ? -1 < (" " + s.replace(H, " ") + " ").indexOf(n) : "|=" === t && (s === n || s.slice(0, n.length + 1) === n + "-"))
											}
										},
										CHILD: function(e, t, n, i, s) {
											var r = "nth" !== e.slice(0, 3),
												o = "last" !== e.slice(-4),
												a = "of-type" === t;
											return 1 === i && 0 === s ? function(e) {
												return !!e.parentNode
											} : function(t, n, c) {
												var d, l, u, h, p, m, f = r !== o ? "nextSibling" : "previousSibling",
													g = t.parentNode,
													_ = a && t.nodeName.toLowerCase(),
													v = !c && !a,
													S = !1;
												if (g) {
													if (r) {
														for (; f;) {
															for (h = t; h = h[f];)
																if (a ? h.nodeName.toLowerCase() === _ : 1 === h.nodeType) return !1;
															m = f = "only" === e && !m && "nextSibling"
														}
														return !0
													}
													if (m = [o ? g.firstChild : g.lastChild], o && v) {
														for (S = (p = (d = (l = (u = (h = g)[E] || (h[E] = {}))[h.uniqueID] || (u[h.uniqueID] = {}))[e] || [])[0] === T && d[1]) && d[2], h = p && g.childNodes[p]; h = ++p && h && h[f] || (S = p = 0) || m.pop();)
															if (1 === h.nodeType && ++S && h === t) {
																l[e] = [T, p, S];
																break
															}
													} else if (v && (S = p = (d = (l = (u = (h = t)[E] || (h[E] = {}))[h.uniqueID] || (u[h.uniqueID] = {}))[e] || [])[0] === T && d[1]), !1 === S)
														for (;
															(h = ++p && h && h[f] || (S = p = 0) || m.pop()) && ((a ? h.nodeName.toLowerCase() !== _ : 1 !== h.nodeType) || !++S || (v && ((l = (u = h[E] || (h[E] = {}))[h.uniqueID] || (u[h.uniqueID] = {}))[e] = [T, S]), h !== t)););
													return (S -= s) === i || S % i == 0 && 0 <= S / i
												}
											}
										},
										PSEUDO: function(e, t) {
											var n, s = i.pseudos[e] || i.setFilters[e.toLowerCase()] || ae.error("unsupported pseudo: " + e);
											return s[E] ? s(t) : 1 < s.length ? (n = [e, e, "", t], i.setFilters.hasOwnProperty(e.toLowerCase()) ? de((function(e, n) {
												for (var i, r = s(e, t), o = r.length; o--;) e[i = k(e, r[o])] = !(n[i] = r[o])
											})) : function(e) {
												return s(e, 0, n)
											}) : s
										}
									},
									pseudos: {
										not: de((function(e) {
											var t = [],
												n = [],
												i = a(e.replace(B, "$1"));
											return i[E] ? de((function(e, t, n, s) {
												for (var r, o = i(e, null, s, []), a = e.length; a--;)(r = o[a]) && (e[a] = !(t[a] = r))
											})) : function(e, s, r) {
												return t[0] = e, i(t, null, r, n), t[0] = null, !n.pop()
											}
										})),
										has: de((function(e) {
											return function(t) {
												return 0 < ae(e, t).length
											}
										})),
										contains: de((function(e) {
											return e = e.replace(te, ne),
												function(t) {
													return -1 < (t.textContent || s(t)).indexOf(e)
												}
										})),
										lang: de((function(e) {
											return K.test(e || "") || ae.error("unsupported lang: " + e), e = e.replace(te, ne).toLowerCase(),
												function(t) {
													var n;
													do {
														if (n = f ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-")
													} while ((t = t.parentNode) && 1 === t.nodeType);
													return !1
												}
										})),
										target: function(t) {
											var n = e.location && e.location.hash;
											return n && n.slice(1) === t.id
										},
										root: function(e) {
											return e === m
										},
										focus: function(e) {
											return e === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
										},
										enabled: fe(!1),
										disabled: fe(!0),
										checked: function(e) {
											var t = e.nodeName.toLowerCase();
											return "input" === t && !!e.checked || "option" === t && !!e.selected
										},
										selected: function(e) {
											return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
										},
										empty: function(e) {
											for (e = e.firstChild; e; e = e.nextSibling)
												if (e.nodeType < 6) return !1;
											return !0
										},
										parent: function(e) {
											return !i.pseudos.empty(e)
										},
										header: function(e) {
											return Y.test(e.nodeName)
										},
										input: function(e) {
											return z.test(e.nodeName)
										},
										button: function(e) {
											var t = e.nodeName.toLowerCase();
											return "input" === t && "button" === e.type || "button" === t
										},
										text: function(e) {
											var t;
											return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
										},
										first: ge((function() {
											return [0]
										})),
										last: ge((function(e, t) {
											return [t - 1]
										})),
										eq: ge((function(e, t, n) {
											return [n < 0 ? n + t : n]
										})),
										even: ge((function(e, t) {
											for (var n = 0; n < t; n += 2) e.push(n);
											return e
										})),
										odd: ge((function(e, t) {
											for (var n = 1; n < t; n += 2) e.push(n);
											return e
										})),
										lt: ge((function(e, t, n) {
											for (var i = n < 0 ? n + t : t < n ? t : n; 0 <= --i;) e.push(i);
											return e
										})),
										gt: ge((function(e, t, n) {
											for (var i = n < 0 ? n + t : n; ++i < t;) e.push(i);
											return e
										}))
									}
								}).pseudos.nth = i.pseudos.eq, {
									radio: !0,
									checkbox: !0,
									file: !0,
									password: !0,
									image: !0
								}) i.pseudos[t] = pe(t);
							for (t in {
									submit: !0,
									reset: !0
								}) i.pseudos[t] = me(t);

							function ve() {}

							function Se(e) {
								for (var t = 0, n = e.length, i = ""; t < n; t++) i += e[t].value;
								return i
							}

							function Ee(e, t, n) {
								var i = t.dir,
									s = t.next,
									r = s || i,
									o = n && "parentNode" === r,
									a = C++;
								return t.first ? function(t, n, s) {
									for (; t = t[i];)
										if (1 === t.nodeType || o) return e(t, n, s);
									return !1
								} : function(t, n, c) {
									var d, l, u, h = [T, a];
									if (c) {
										for (; t = t[i];)
											if ((1 === t.nodeType || o) && e(t, n, c)) return !0
									} else
										for (; t = t[i];)
											if (1 === t.nodeType || o)
												if (l = (u = t[E] || (t[E] = {}))[t.uniqueID] || (u[t.uniqueID] = {}), s && s === t.nodeName.toLowerCase()) t = t[i] || t;
												else {
													if ((d = l[r]) && d[0] === T && d[1] === a) return h[2] = d[2];
													if ((l[r] = h)[2] = e(t, n, c)) return !0
												} return !1
								}
							}

							function ye(e) {
								return 1 < e.length ? function(t, n, i) {
									for (var s = e.length; s--;)
										if (!e[s](t, n, i)) return !1;
									return !0
								} : e[0]
							}

							function Te(e, t, n, i, s) {
								for (var r, o = [], a = 0, c = e.length, d = null != t; a < c; a++)(r = e[a]) && (n && !n(r, i, s) || (o.push(r), d && t.push(a)));
								return o
							}

							function Ce(e, t, n, i, s, r) {
								return i && !i[E] && (i = Ce(i)), s && !s[E] && (s = Ce(s, r)), de((function(r, o, a, c) {
									var d, l, u, h = [],
										p = [],
										m = o.length,
										f = r || function(e, t, n) {
											for (var i = 0, s = t.length; i < s; i++) ae(e, t[i], n);
											return n
										}(t || "*", a.nodeType ? [a] : a, []),
										g = !e || !r && t ? f : Te(f, h, e, a, c),
										_ = n ? s || (r ? e : m || i) ? [] : o : g;
									if (n && n(g, _, a, c), i)
										for (d = Te(_, p), i(d, [], a, c), l = d.length; l--;)(u = d[l]) && (_[p[l]] = !(g[p[l]] = u));
									if (r) {
										if (s || e) {
											if (s) {
												for (d = [], l = _.length; l--;)(u = _[l]) && d.push(g[l] = u);
												s(null, _ = [], d, c)
											}
											for (l = _.length; l--;)(u = _[l]) && -1 < (d = s ? k(r, u) : h[l]) && (r[d] = !(o[d] = u))
										}
									} else _ = Te(_ === o ? _.splice(m, _.length) : _), s ? s(null, o, _, c) : M.apply(o, _)
								}))
							}

							function be(e) {
								for (var t, n, s, r = e.length, o = i.relative[e[0].type], a = o || i.relative[" "], c = o ? 1 : 0, l = Ee((function(e) {
										return e === t
									}), a, !0), u = Ee((function(e) {
										return -1 < k(t, e)
									}), a, !0), h = [function(e, n, i) {
										var s = !o && (i || n !== d) || ((t = n).nodeType ? l(e, n, i) : u(e, n, i));
										return t = null, s
									}]; c < r; c++)
									if (n = i.relative[e[c].type]) h = [Ee(ye(h), n)];
									else {
										if ((n = i.filter[e[c].type].apply(null, e[c].matches))[E]) {
											for (s = ++c; s < r && !i.relative[e[s].type]; s++);
											return Ce(1 < c && ye(h), 1 < c && Se(e.slice(0, c - 1).concat({
												value: " " === e[c - 2].type ? "*" : ""
											})).replace(B, "$1"), n, c < s && be(e.slice(c, s)), s < r && be(e = e.slice(s)), s < r && Se(e))
										}
										h.push(n)
									} return ye(h)
							}
							return ve.prototype = i.filters = i.pseudos, i.setFilters = new ve, o = ae.tokenize = function(e, t) {
								var n, s, r, o, a, c, d, l = A[e + " "];
								if (l) return t ? 0 : l.slice(0);
								for (a = e, c = [], d = i.preFilter; a;) {
									for (o in n && !(s = $.exec(a)) || (s && (a = a.slice(s[0].length) || a), c.push(r = [])), n = !1, (s = J.exec(a)) && (n = s.shift(), r.push({
											value: n,
											type: s[0].replace(B, " ")
										}), a = a.slice(n.length)), i.filter) !(s = W[o].exec(a)) || d[o] && !(s = d[o](s)) || (n = s.shift(), r.push({
										value: n,
										type: o,
										matches: s
									}), a = a.slice(n.length));
									if (!n) break
								}
								return t ? a.length : a ? ae.error(e) : A(e, c).slice(0)
							}, a = ae.compile = function(e, t) {
								var n, s, r, a, c, l, u = [],
									m = [],
									g = R[e + " "];
								if (!g) {
									for (t || (t = o(e)), n = t.length; n--;)(g = be(t[n]))[E] ? u.push(g) : m.push(g);
									(g = R(e, (s = m, a = 0 < (r = u).length, c = 0 < s.length, l = function(e, t, n, o, l) {
										var u, m, g, _ = 0,
											v = "0",
											S = e && [],
											E = [],
											y = d,
											C = e || c && i.find.TAG("*", l),
											b = T += null == y ? 1 : Math.random() || .1,
											A = C.length;
										for (l && (d = t == p || t || l); v !== A && null != (u = C[v]); v++) {
											if (c && u) {
												for (m = 0, t || u.ownerDocument == p || (h(u), n = !f); g = s[m++];)
													if (g(u, t || p, n)) {
														o.push(u);
														break
													} l && (T = b)
											}
											a && ((u = !g && u) && _--, e && S.push(u))
										}
										if (_ += v, a && v !== _) {
											for (m = 0; g = r[m++];) g(S, E, t, n);
											if (e) {
												if (0 < _)
													for (; v--;) S[v] || E[v] || (E[v] = O.call(o));
												E = Te(E)
											}
											M.apply(o, E), l && !e && 0 < E.length && 1 < _ + r.length && ae.uniqueSort(o)
										}
										return l && (T = b, d = y), S
									}, a ? de(l) : l))).selector = e
								}
								return g
							}, c = ae.select = function(e, t, n, s) {
								var r, c, d, l, u, h = "function" == typeof e && e,
									p = !s && o(e = h.selector || e);
								if (n = n || [], 1 === p.length) {
									if (2 < (c = p[0] = p[0].slice(0)).length && "ID" === (d = c[0]).type && 9 === t.nodeType && f && i.relative[c[1].type]) {
										if (!(t = (i.find.ID(d.matches[0].replace(te, ne), t) || [])[0])) return n;
										h && (t = t.parentNode), e = e.slice(c.shift().value.length)
									}
									for (r = W.needsContext.test(e) ? 0 : c.length; r-- && (d = c[r], !i.relative[l = d.type]);)
										if ((u = i.find[l]) && (s = u(d.matches[0].replace(te, ne), ee.test(c[0].type) && _e(t.parentNode) || t))) {
											if (c.splice(r, 1), !(e = s.length && Se(c))) return M.apply(n, s), n;
											break
										}
								}
								return (h || a(e, p))(s, t, !f, n, !t || ee.test(e) && _e(t.parentNode) || t), n
							}, n.sortStable = E.split("").sort(P).join("") === E, n.detectDuplicates = !!u, h(), n.sortDetached = le((function(e) {
								return 1 & e.compareDocumentPosition(p.createElement("fieldset"))
							})), le((function(e) {
								return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
							})) || ue("type|href|height|width", (function(e, t, n) {
								if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
							})), n.attributes && le((function(e) {
								return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
							})) || ue("value", (function(e, t, n) {
								if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue
							})), le((function(e) {
								return null == e.getAttribute("disabled")
							})) || ue(x, (function(e, t, n) {
								var i;
								if (!n) return !0 === e[t] ? t.toLowerCase() : (i = e.getAttributeNode(t)) && i.specified ? i.value : null
							})), ae
						}(i);
						b.find = R, b.expr = R.selectors, b.expr[":"] = b.expr.pseudos, b.uniqueSort = b.unique = R.uniqueSort, b.text = R.getText, b.isXMLDoc = R.isXML, b.contains = R.contains, b.escapeSelector = R.escape;
						var I = function(e, t, n) {
								for (var i = [], s = void 0 !== n;
									(e = e[t]) && 9 !== e.nodeType;)
									if (1 === e.nodeType) {
										if (s && b(e).is(n)) break;
										i.push(e)
									} return i
							},
							P = function(e, t) {
								for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
								return n
							},
							D = b.expr.match.needsContext;

						function w(e, t) {
							return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
						}
						var O = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

						function N(e, t, n) {
							return _(t) ? b.grep(e, (function(e, i) {
								return !!t.call(e, i, e) !== n
							})) : t.nodeType ? b.grep(e, (function(e) {
								return e === t !== n
							})) : "string" != typeof t ? b.grep(e, (function(e) {
								return -1 < l.call(t, e) !== n
							})) : b.filter(t, e, n)
						}
						b.filter = function(e, t, n) {
							var i = t[0];
							return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === i.nodeType ? b.find.matchesSelector(i, e) ? [i] : [] : b.find.matches(e, b.grep(t, (function(e) {
								return 1 === e.nodeType
							})))
						}, b.fn.extend({
							find: function(e) {
								var t, n, i = this.length,
									s = this;
								if ("string" != typeof e) return this.pushStack(b(e).filter((function() {
									for (t = 0; t < i; t++)
										if (b.contains(s[t], this)) return !0
								})));
								for (n = this.pushStack([]), t = 0; t < i; t++) b.find(e, s[t], n);
								return 1 < i ? b.uniqueSort(n) : n
							},
							filter: function(e) {
								return this.pushStack(N(this, e || [], !1))
							},
							not: function(e) {
								return this.pushStack(N(this, e || [], !0))
							},
							is: function(e) {
								return !!N(this, "string" == typeof e && D.test(e) ? b(e) : e || [], !1).length
							}
						});
						var M, L = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
						(b.fn.init = function(e, t, n) {
							var i, s;
							if (!e) return this;
							if (n = n || M, "string" == typeof e) {
								if (!(i = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : L.exec(e)) || !i[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
								if (i[1]) {
									if (t = t instanceof b ? t[0] : t, b.merge(this, b.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : S, !0)), O.test(i[1]) && b.isPlainObject(t))
										for (i in t) _(this[i]) ? this[i](t[i]) : this.attr(i, t[i]);
									return this
								}
								return (s = S.getElementById(i[2])) && (this[0] = s, this.length = 1), this
							}
							return e.nodeType ? (this[0] = e, this.length = 1, this) : _(e) ? void 0 !== n.ready ? n.ready(e) : e(b) : b.makeArray(e, this)
						}).prototype = b.fn, M = b(S);
						var k = /^(?:parents|prev(?:Until|All))/,
							x = {
								children: !0,
								contents: !0,
								next: !0,
								prev: !0
							};

						function F(e, t) {
							for (;
								(e = e[t]) && 1 !== e.nodeType;);
							return e
						}
						b.fn.extend({
							has: function(e) {
								var t = b(e, this),
									n = t.length;
								return this.filter((function() {
									for (var e = 0; e < n; e++)
										if (b.contains(this, t[e])) return !0
								}))
							},
							closest: function(e, t) {
								var n, i = 0,
									s = this.length,
									r = [],
									o = "string" != typeof e && b(e);
								if (!D.test(e))
									for (; i < s; i++)
										for (n = this[i]; n && n !== t; n = n.parentNode)
											if (n.nodeType < 11 && (o ? -1 < o.index(n) : 1 === n.nodeType && b.find.matchesSelector(n, e))) {
												r.push(n);
												break
											} return this.pushStack(1 < r.length ? b.uniqueSort(r) : r)
							},
							index: function(e) {
								return e ? "string" == typeof e ? l.call(b(e), this[0]) : l.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
							},
							add: function(e, t) {
								return this.pushStack(b.uniqueSort(b.merge(this.get(), b(e, t))))
							},
							addBack: function(e) {
								return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
							}
						}), b.each({
							parent: function(e) {
								var t = e.parentNode;
								return t && 11 !== t.nodeType ? t : null
							},
							parents: function(e) {
								return I(e, "parentNode")
							},
							parentsUntil: function(e, t, n) {
								return I(e, "parentNode", n)
							},
							next: function(e) {
								return F(e, "nextSibling")
							},
							prev: function(e) {
								return F(e, "previousSibling")
							},
							nextAll: function(e) {
								return I(e, "nextSibling")
							},
							prevAll: function(e) {
								return I(e, "previousSibling")
							},
							nextUntil: function(e, t, n) {
								return I(e, "nextSibling", n)
							},
							prevUntil: function(e, t, n) {
								return I(e, "previousSibling", n)
							},
							siblings: function(e) {
								return P((e.parentNode || {}).firstChild, e)
							},
							children: function(e) {
								return P(e.firstChild)
							},
							contents: function(e) {
								return null != e.contentDocument && o(e.contentDocument) ? e.contentDocument : (w(e, "template") && (e = e.content || e), b.merge([], e.childNodes))
							}
						}, (function(e, t) {
							b.fn[e] = function(n, i) {
								var s = b.map(this, t, n);
								return "Until" !== e.slice(-5) && (i = n), i && "string" == typeof i && (s = b.filter(i, s)), 1 < this.length && (x[e] || b.uniqueSort(s), k.test(e) && s.reverse()), this.pushStack(s)
							}
						}));
						var V = /[^\x20\t\r\n\f]+/g;

						function U(e) {
							return e
						}

						function j(e) {
							throw e
						}

						function H(e, t, n, i) {
							var s;
							try {
								e && _(s = e.promise) ? s.call(e).done(t).fail(n) : e && _(s = e.then) ? s.call(e, t, n) : t.apply(void 0, [e].slice(i))
							} catch (e) {
								n.apply(void 0, [e])
							}
						}
						b.Callbacks = function(e) {
							var t, n;
							e = "string" == typeof e ? (t = e, n = {}, b.each(t.match(V) || [], (function(e, t) {
								n[t] = !0
							})), n) : b.extend({}, e);
							var i, s, r, o, a = [],
								c = [],
								d = -1,
								l = function() {
									for (o = o || e.once, r = i = !0; c.length; d = -1)
										for (s = c.shift(); ++d < a.length;) !1 === a[d].apply(s[0], s[1]) && e.stopOnFalse && (d = a.length, s = !1);
									e.memory || (s = !1), i = !1, o && (a = s ? [] : "")
								},
								u = {
									add: function() {
										return a && (s && !i && (d = a.length - 1, c.push(s)), function t(n) {
											b.each(n, (function(n, i) {
												_(i) ? e.unique && u.has(i) || a.push(i) : i && i.length && "string" !== T(i) && t(i)
											}))
										}(arguments), s && !i && l()), this
									},
									remove: function() {
										return b.each(arguments, (function(e, t) {
											for (var n; - 1 < (n = b.inArray(t, a, n));) a.splice(n, 1), n <= d && d--
										})), this
									},
									has: function(e) {
										return e ? -1 < b.inArray(e, a) : 0 < a.length
									},
									empty: function() {
										return a && (a = []), this
									},
									disable: function() {
										return o = c = [], a = s = "", this
									},
									disabled: function() {
										return !a
									},
									lock: function() {
										return o = c = [], s || i || (a = s = ""), this
									},
									locked: function() {
										return !!o
									},
									fireWith: function(e, t) {
										return o || (t = [e, (t = t || []).slice ? t.slice() : t], c.push(t), i || l()), this
									},
									fire: function() {
										return u.fireWith(this, arguments), this
									},
									fired: function() {
										return !!r
									}
								};
							return u
						}, b.extend({
							Deferred: function(e) {
								var t = [
										["notify", "progress", b.Callbacks("memory"), b.Callbacks("memory"), 2],
										["resolve", "done", b.Callbacks("once memory"), b.Callbacks("once memory"), 0, "resolved"],
										["reject", "fail", b.Callbacks("once memory"), b.Callbacks("once memory"), 1, "rejected"]
									],
									n = "pending",
									s = {
										state: function() {
											return n
										},
										always: function() {
											return r.done(arguments).fail(arguments), this
										},
										catch: function(e) {
											return s.then(null, e)
										},
										pipe: function() {
											var e = arguments;
											return b.Deferred((function(n) {
												b.each(t, (function(t, i) {
													var s = _(e[i[4]]) && e[i[4]];
													r[i[1]]((function() {
														var e = s && s.apply(this, arguments);
														e && _(e.promise) ? e.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[i[0] + "With"](this, s ? [e] : arguments)
													}))
												})), e = null
											})).promise()
										},
										then: function(e, n, s) {
											var r = 0;

											function o(e, t, n, s) {
												return function() {
													var a = this,
														c = arguments,
														d = function() {
															var i, d;
															if (!(e < r)) {
																if ((i = n.apply(a, c)) === t.promise()) throw new TypeError("Thenable self-resolution");
																d = i && ("object" == typeof i || "function" == typeof i) && i.then, _(d) ? s ? d.call(i, o(r, t, U, s), o(r, t, j, s)) : (r++, d.call(i, o(r, t, U, s), o(r, t, j, s), o(r, t, U, t.notifyWith))) : (n !== U && (a = void 0, c = [i]), (s || t.resolveWith)(a, c))
															}
														},
														l = s ? d : function() {
															try {
																d()
															} catch (i) {
																b.Deferred.exceptionHook && b.Deferred.exceptionHook(i, l.stackTrace), r <= e + 1 && (n !== j && (a = void 0, c = [i]), t.rejectWith(a, c))
															}
														};
													e ? l() : (b.Deferred.getStackHook && (l.stackTrace = b.Deferred.getStackHook()), i.setTimeout(l))
												}
											}
											return b.Deferred((function(i) {
												t[0][3].add(o(0, i, _(s) ? s : U, i.notifyWith)), t[1][3].add(o(0, i, _(e) ? e : U)), t[2][3].add(o(0, i, _(n) ? n : j))
											})).promise()
										},
										promise: function(e) {
											return null != e ? b.extend(e, s) : s
										}
									},
									r = {};
								return b.each(t, (function(e, i) {
									var o = i[2],
										a = i[5];
									s[i[1]] = o.add, a && o.add((function() {
										n = a
									}), t[3 - e][2].disable, t[3 - e][3].disable, t[0][2].lock, t[0][3].lock), o.add(i[3].fire), r[i[0]] = function() {
										return r[i[0] + "With"](this === r ? void 0 : this, arguments), this
									}, r[i[0] + "With"] = o.fireWith
								})), s.promise(r), e && e.call(r, r), r
							},
							when: function(e) {
								var t = arguments.length,
									n = t,
									i = Array(n),
									s = a.call(arguments),
									r = b.Deferred(),
									o = function(e) {
										return function(n) {
											i[e] = this, s[e] = 1 < arguments.length ? a.call(arguments) : n, --t || r.resolveWith(i, s)
										}
									};
								if (t <= 1 && (H(e, r.done(o(n)).resolve, r.reject, !t), "pending" === r.state() || _(s[n] && s[n].then))) return r.then();
								for (; n--;) H(s[n], o(n), r.reject);
								return r.promise()
							}
						});
						var B = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
						b.Deferred.exceptionHook = function(e, t) {
							i.console && i.console.warn && e && B.test(e.name) && i.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
						}, b.readyException = function(e) {
							i.setTimeout((function() {
								throw e
							}))
						};
						var $ = b.Deferred();

						function J() {
							S.removeEventListener("DOMContentLoaded", J), i.removeEventListener("load", J), b.ready()
						}
						b.fn.ready = function(e) {
							return $.then(e).catch((function(e) {
								b.readyException(e)
							})), this
						}, b.extend({
							isReady: !1,
							readyWait: 1,
							ready: function(e) {
								(!0 === e ? --b.readyWait : b.isReady) || (b.isReady = !0) !== e && 0 < --b.readyWait || $.resolveWith(S, [b])
							}
						}), b.ready.then = $.then, "complete" === S.readyState || "loading" !== S.readyState && !S.documentElement.doScroll ? i.setTimeout(b.ready) : (S.addEventListener("DOMContentLoaded", J), i.addEventListener("load", J));
						var G = function(e, t, n, i, s, r, o) {
								var a = 0,
									c = e.length,
									d = null == n;
								if ("object" === T(n))
									for (a in s = !0, n) G(e, t, a, n[a], !0, r, o);
								else if (void 0 !== i && (s = !0, _(i) || (o = !0), d && (o ? (t.call(e, i), t = null) : (d = t, t = function(e, t, n) {
										return d.call(b(e), n)
									})), t))
									for (; a < c; a++) t(e[a], n, o ? i : i.call(e[a], a, t(e[a], n)));
								return s ? e : d ? t.call(e) : c ? t(e[0], n) : r
							},
							q = /^-ms-/,
							K = /-([a-z])/g;

						function W(e, t) {
							return t.toUpperCase()
						}

						function X(e) {
							return e.replace(q, "ms-").replace(K, W)
						}
						var z = function(e) {
							return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
						};

						function Y() {
							this.expando = b.expando + Y.uid++
						}
						Y.uid = 1, Y.prototype = {
							cache: function(e) {
								var t = e[this.expando];
								return t || (t = {}, z(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
									value: t,
									configurable: !0
								}))), t
							},
							set: function(e, t, n) {
								var i, s = this.cache(e);
								if ("string" == typeof t) s[X(t)] = n;
								else
									for (i in t) s[X(i)] = t[i];
								return s
							},
							get: function(e, t) {
								return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)]
							},
							access: function(e, t, n) {
								return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t)
							},
							remove: function(e, t) {
								var n, i = e[this.expando];
								if (void 0 !== i) {
									if (void 0 !== t) {
										n = (t = Array.isArray(t) ? t.map(X) : (t = X(t)) in i ? [t] : t.match(V) || []).length;
										for (; n--;) delete i[t[n]]
									}(void 0 === t || b.isEmptyObject(i)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
								}
							},
							hasData: function(e) {
								var t = e[this.expando];
								return void 0 !== t && !b.isEmptyObject(t)
							}
						};
						var Q = new Y,
							Z = new Y,
							ee = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
							te = /[A-Z]/g;

						function ne(e, t, n) {
							var i, s;
							if (void 0 === n && 1 === e.nodeType)
								if (i = "data-" + t.replace(te, "-$&").toLowerCase(), "string" == typeof(n = e.getAttribute(i))) {
									try {
										n = "true" === (s = n) || "false" !== s && ("null" === s ? null : s === +s + "" ? +s : ee.test(s) ? JSON.parse(s) : s)
									} catch (e) {}
									Z.set(e, t, n)
								} else n = void 0;
							return n
						}
						b.extend({
							hasData: function(e) {
								return Z.hasData(e) || Q.hasData(e)
							},
							data: function(e, t, n) {
								return Z.access(e, t, n)
							},
							removeData: function(e, t) {
								Z.remove(e, t)
							},
							_data: function(e, t, n) {
								return Q.access(e, t, n)
							},
							_removeData: function(e, t) {
								Q.remove(e, t)
							}
						}), b.fn.extend({
							data: function(e, t) {
								var n, i, s, r = this[0],
									o = r && r.attributes;
								if (void 0 === e) {
									if (this.length && (s = Z.get(r), 1 === r.nodeType && !Q.get(r, "hasDataAttrs"))) {
										for (n = o.length; n--;) o[n] && 0 === (i = o[n].name).indexOf("data-") && (i = X(i.slice(5)), ne(r, i, s[i]));
										Q.set(r, "hasDataAttrs", !0)
									}
									return s
								}
								return "object" == typeof e ? this.each((function() {
									Z.set(this, e)
								})) : G(this, (function(t) {
									var n;
									if (r && void 0 === t) return void 0 !== (n = Z.get(r, e)) || void 0 !== (n = ne(r, e)) ? n : void 0;
									this.each((function() {
										Z.set(this, e, t)
									}))
								}), null, t, 1 < arguments.length, null, !0)
							},
							removeData: function(e) {
								return this.each((function() {
									Z.remove(this, e)
								}))
							}
						}), b.extend({
							queue: function(e, t, n) {
								var i;
								if (e) return t = (t || "fx") + "queue", i = Q.get(e, t), n && (!i || Array.isArray(n) ? i = Q.access(e, t, b.makeArray(n)) : i.push(n)), i || []
							},
							dequeue: function(e, t) {
								t = t || "fx";
								var n = b.queue(e, t),
									i = n.length,
									s = n.shift(),
									r = b._queueHooks(e, t);
								"inprogress" === s && (s = n.shift(), i--), s && ("fx" === t && n.unshift("inprogress"), delete r.stop, s.call(e, (function() {
									b.dequeue(e, t)
								}), r)), !i && r && r.empty.fire()
							},
							_queueHooks: function(e, t) {
								var n = t + "queueHooks";
								return Q.get(e, n) || Q.access(e, n, {
									empty: b.Callbacks("once memory").add((function() {
										Q.remove(e, [t + "queue", n])
									}))
								})
							}
						}), b.fn.extend({
							queue: function(e, t) {
								var n = 2;
								return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? b.queue(this[0], e) : void 0 === t ? this : this.each((function() {
									var n = b.queue(this, e, t);
									b._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && b.dequeue(this, e)
								}))
							},
							dequeue: function(e) {
								return this.each((function() {
									b.dequeue(this, e)
								}))
							},
							clearQueue: function(e) {
								return this.queue(e || "fx", [])
							},
							promise: function(e, t) {
								var n, i = 1,
									s = b.Deferred(),
									r = this,
									o = this.length,
									a = function() {
										--i || s.resolveWith(r, [r])
									};
								for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; o--;)(n = Q.get(r[o], e + "queueHooks")) && n.empty && (i++, n.empty.add(a));
								return a(), s.promise(t)
							}
						});
						var ie = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
							se = new RegExp("^(?:([+-])=|)(" + ie + ")([a-z%]*)$", "i"),
							re = ["Top", "Right", "Bottom", "Left"],
							oe = S.documentElement,
							ae = function(e) {
								return b.contains(e.ownerDocument, e)
							},
							ce = {
								composed: !0
							};
						oe.getRootNode && (ae = function(e) {
							return b.contains(e.ownerDocument, e) || e.getRootNode(ce) === e.ownerDocument
						});
						var de = function(e, t) {
								return "none" === (e = t || e).style.display || "" === e.style.display && ae(e) && "none" === b.css(e, "display")
							},
							le = {};

						function ue(e, t) {
							for (var n, i, s, r, o, a, c, d = [], l = 0, u = e.length; l < u; l++)(i = e[l]).style && (n = i.style.display, t ? ("none" === n && (d[l] = Q.get(i, "display") || null, d[l] || (i.style.display = "")), "" === i.style.display && de(i) && (d[l] = (c = o = r = void 0, o = (s = i).ownerDocument, a = s.nodeName, (c = le[a]) || (r = o.body.appendChild(o.createElement(a)), c = b.css(r, "display"), r.parentNode.removeChild(r), "none" === c && (c = "block"), le[a] = c)))) : "none" !== n && (d[l] = "none", Q.set(i, "display", n)));
							for (l = 0; l < u; l++) null != d[l] && (e[l].style.display = d[l]);
							return e
						}
						b.fn.extend({
							show: function() {
								return ue(this, !0)
							},
							hide: function() {
								return ue(this)
							},
							toggle: function(e) {
								return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each((function() {
									de(this) ? b(this).show() : b(this).hide()
								}))
							}
						});
						var he, pe, me = /^(?:checkbox|radio)$/i,
							fe = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
							ge = /^$|^module$|\/(?:java|ecma)script/i;
						he = S.createDocumentFragment().appendChild(S.createElement("div")), (pe = S.createElement("input")).setAttribute("type", "radio"), pe.setAttribute("checked", "checked"), pe.setAttribute("name", "t"), he.appendChild(pe), g.checkClone = he.cloneNode(!0).cloneNode(!0).lastChild.checked, he.innerHTML = "<textarea>x</textarea>", g.noCloneChecked = !!he.cloneNode(!0).lastChild.defaultValue, he.innerHTML = "<option></option>", g.option = !!he.lastChild;
						var _e = {
							thead: [1, "<table>", "</table>"],
							col: [2, "<table><colgroup>", "</colgroup></table>"],
							tr: [2, "<table><tbody>", "</tbody></table>"],
							td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
							_default: [0, "", ""]
						};

						function ve(e, t) {
							var n;
							return n = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && w(e, t) ? b.merge([e], n) : n
						}

						function Se(e, t) {
							for (var n = 0, i = e.length; n < i; n++) Q.set(e[n], "globalEval", !t || Q.get(t[n], "globalEval"))
						}
						_e.tbody = _e.tfoot = _e.colgroup = _e.caption = _e.thead, _e.th = _e.td, g.option || (_e.optgroup = _e.option = [1, "<select multiple='multiple'>", "</select>"]);
						var Ee = /<|&#?\w+;/;

						function ye(e, t, n, i, s) {
							for (var r, o, a, c, d, l, u = t.createDocumentFragment(), h = [], p = 0, m = e.length; p < m; p++)
								if ((r = e[p]) || 0 === r)
									if ("object" === T(r)) b.merge(h, r.nodeType ? [r] : r);
									else if (Ee.test(r)) {
								for (o = o || u.appendChild(t.createElement("div")), a = (fe.exec(r) || ["", ""])[1].toLowerCase(), c = _e[a] || _e._default, o.innerHTML = c[1] + b.htmlPrefilter(r) + c[2], l = c[0]; l--;) o = o.lastChild;
								b.merge(h, o.childNodes), (o = u.firstChild).textContent = ""
							} else h.push(t.createTextNode(r));
							for (u.textContent = "", p = 0; r = h[p++];)
								if (i && -1 < b.inArray(r, i)) s && s.push(r);
								else if (d = ae(r), o = ve(u.appendChild(r), "script"), d && Se(o), n)
								for (l = 0; r = o[l++];) ge.test(r.type || "") && n.push(r);
							return u
						}
						var Te = /^([^.]*)(?:\.(.+)|)/;

						function Ce() {
							return !0
						}

						function be() {
							return !1
						}

						function Ae(e, t) {
							return e === function() {
								try {
									return S.activeElement
								} catch (e) {}
							}() == ("focus" === t)
						}

						function Re(e, t, n, i, s, r) {
							var o, a;
							if ("object" == typeof t) {
								for (a in "string" != typeof n && (i = i || n, n = void 0), t) Re(e, a, n, i, t[a], r);
								return e
							}
							if (null == i && null == s ? (s = n, i = n = void 0) : null == s && ("string" == typeof n ? (s = i, i = void 0) : (s = i, i = n, n = void 0)), !1 === s) s = be;
							else if (!s) return e;
							return 1 === r && (o = s, (s = function(e) {
								return b().off(e), o.apply(this, arguments)
							}).guid = o.guid || (o.guid = b.guid++)), e.each((function() {
								b.event.add(this, t, s, i, n)
							}))
						}

						function Ie(e, t, n) {
							n ? (Q.set(e, t, !1), b.event.add(e, t, {
								namespace: !1,
								handler: function(e) {
									var i, s, r = Q.get(this, t);
									if (1 & e.isTrigger && this[t]) {
										if (r.length)(b.event.special[t] || {}).delegateType && e.stopPropagation();
										else if (r = a.call(arguments), Q.set(this, t, r), i = n(this, t), this[t](), r !== (s = Q.get(this, t)) || i ? Q.set(this, t, !1) : s = {}, r !== s) return e.stopImmediatePropagation(), e.preventDefault(), s && s.value
									} else r.length && (Q.set(this, t, {
										value: b.event.trigger(b.extend(r[0], b.Event.prototype), r.slice(1), this)
									}), e.stopImmediatePropagation())
								}
							})) : void 0 === Q.get(e, t) && b.event.add(e, t, Ce)
						}
						b.event = {
							global: {},
							add: function(e, t, n, i, s) {
								var r, o, a, c, d, l, u, h, p, m, f, g = Q.get(e);
								if (z(e))
									for (n.handler && (n = (r = n).handler, s = r.selector), s && b.find.matchesSelector(oe, s), n.guid || (n.guid = b.guid++), (c = g.events) || (c = g.events = Object.create(null)), (o = g.handle) || (o = g.handle = function(t) {
											return void 0 !== b && b.event.triggered !== t.type ? b.event.dispatch.apply(e, arguments) : void 0
										}), d = (t = (t || "").match(V) || [""]).length; d--;) p = f = (a = Te.exec(t[d]) || [])[1], m = (a[2] || "").split(".").sort(), p && (u = b.event.special[p] || {}, p = (s ? u.delegateType : u.bindType) || p, u = b.event.special[p] || {}, l = b.extend({
										type: p,
										origType: f,
										data: i,
										handler: n,
										guid: n.guid,
										selector: s,
										needsContext: s && b.expr.match.needsContext.test(s),
										namespace: m.join(".")
									}, r), (h = c[p]) || ((h = c[p] = []).delegateCount = 0, u.setup && !1 !== u.setup.call(e, i, m, o) || e.addEventListener && e.addEventListener(p, o)), u.add && (u.add.call(e, l), l.handler.guid || (l.handler.guid = n.guid)), s ? h.splice(h.delegateCount++, 0, l) : h.push(l), b.event.global[p] = !0)
							},
							remove: function(e, t, n, i, s) {
								var r, o, a, c, d, l, u, h, p, m, f, g = Q.hasData(e) && Q.get(e);
								if (g && (c = g.events)) {
									for (d = (t = (t || "").match(V) || [""]).length; d--;)
										if (p = f = (a = Te.exec(t[d]) || [])[1], m = (a[2] || "").split(".").sort(), p) {
											for (u = b.event.special[p] || {}, h = c[p = (i ? u.delegateType : u.bindType) || p] || [], a = a[2] && new RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)"), o = r = h.length; r--;) l = h[r], !s && f !== l.origType || n && n.guid !== l.guid || a && !a.test(l.namespace) || i && i !== l.selector && ("**" !== i || !l.selector) || (h.splice(r, 1), l.selector && h.delegateCount--, u.remove && u.remove.call(e, l));
											o && !h.length && (u.teardown && !1 !== u.teardown.call(e, m, g.handle) || b.removeEvent(e, p, g.handle), delete c[p])
										} else
											for (p in c) b.event.remove(e, p + t[d], n, i, !0);
									b.isEmptyObject(c) && Q.remove(e, "handle events")
								}
							},
							dispatch: function(e) {
								var t, n, i, s, r, o, a = new Array(arguments.length),
									c = b.event.fix(e),
									d = (Q.get(this, "events") || Object.create(null))[c.type] || [],
									l = b.event.special[c.type] || {};
								for (a[0] = c, t = 1; t < arguments.length; t++) a[t] = arguments[t];
								if (c.delegateTarget = this, !l.preDispatch || !1 !== l.preDispatch.call(this, c)) {
									for (o = b.event.handlers.call(this, c, d), t = 0;
										(s = o[t++]) && !c.isPropagationStopped();)
										for (c.currentTarget = s.elem, n = 0;
											(r = s.handlers[n++]) && !c.isImmediatePropagationStopped();) c.rnamespace && !1 !== r.namespace && !c.rnamespace.test(r.namespace) || (c.handleObj = r, c.data = r.data, void 0 !== (i = ((b.event.special[r.origType] || {}).handle || r.handler).apply(s.elem, a)) && !1 === (c.result = i) && (c.preventDefault(), c.stopPropagation()));
									return l.postDispatch && l.postDispatch.call(this, c), c.result
								}
							},
							handlers: function(e, t) {
								var n, i, s, r, o, a = [],
									c = t.delegateCount,
									d = e.target;
								if (c && d.nodeType && !("click" === e.type && 1 <= e.button))
									for (; d !== this; d = d.parentNode || this)
										if (1 === d.nodeType && ("click" !== e.type || !0 !== d.disabled)) {
											for (r = [], o = {}, n = 0; n < c; n++) void 0 === o[s = (i = t[n]).selector + " "] && (o[s] = i.needsContext ? -1 < b(s, this).index(d) : b.find(s, this, null, [d]).length), o[s] && r.push(i);
											r.length && a.push({
												elem: d,
												handlers: r
											})
										} return d = this, c < t.length && a.push({
									elem: d,
									handlers: t.slice(c)
								}), a
							},
							addProp: function(e, t) {
								Object.defineProperty(b.Event.prototype, e, {
									enumerable: !0,
									configurable: !0,
									get: _(t) ? function() {
										if (this.originalEvent) return t(this.originalEvent)
									} : function() {
										if (this.originalEvent) return this.originalEvent[e]
									},
									set: function(t) {
										Object.defineProperty(this, e, {
											enumerable: !0,
											configurable: !0,
											writable: !0,
											value: t
										})
									}
								})
							},
							fix: function(e) {
								return e[b.expando] ? e : new b.Event(e)
							},
							special: {
								load: {
									noBubble: !0
								},
								click: {
									setup: function(e) {
										var t = this || e;
										return me.test(t.type) && t.click && w(t, "input") && Ie(t, "click", Ce), !1
									},
									trigger: function(e) {
										var t = this || e;
										return me.test(t.type) && t.click && w(t, "input") && Ie(t, "click"), !0
									},
									_default: function(e) {
										var t = e.target;
										return me.test(t.type) && t.click && w(t, "input") && Q.get(t, "click") || w(t, "a")
									}
								},
								beforeunload: {
									postDispatch: function(e) {
										void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
									}
								}
							}
						}, b.removeEvent = function(e, t, n) {
							e.removeEventListener && e.removeEventListener(t, n)
						}, b.Event = function(e, t) {
							if (!(this instanceof b.Event)) return new b.Event(e, t);
							e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? Ce : be, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && b.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[b.expando] = !0
						}, b.Event.prototype = {
							constructor: b.Event,
							isDefaultPrevented: be,
							isPropagationStopped: be,
							isImmediatePropagationStopped: be,
							isSimulated: !1,
							preventDefault: function() {
								var e = this.originalEvent;
								this.isDefaultPrevented = Ce, e && !this.isSimulated && e.preventDefault()
							},
							stopPropagation: function() {
								var e = this.originalEvent;
								this.isPropagationStopped = Ce, e && !this.isSimulated && e.stopPropagation()
							},
							stopImmediatePropagation: function() {
								var e = this.originalEvent;
								this.isImmediatePropagationStopped = Ce, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
							}
						}, b.each({
							altKey: !0,
							bubbles: !0,
							cancelable: !0,
							changedTouches: !0,
							ctrlKey: !0,
							detail: !0,
							eventPhase: !0,
							metaKey: !0,
							pageX: !0,
							pageY: !0,
							shiftKey: !0,
							view: !0,
							char: !0,
							code: !0,
							charCode: !0,
							key: !0,
							keyCode: !0,
							button: !0,
							buttons: !0,
							clientX: !0,
							clientY: !0,
							offsetX: !0,
							offsetY: !0,
							pointerId: !0,
							pointerType: !0,
							screenX: !0,
							screenY: !0,
							targetTouches: !0,
							toElement: !0,
							touches: !0,
							which: !0
						}, b.event.addProp), b.each({
							focus: "focusin",
							blur: "focusout"
						}, (function(e, t) {
							b.event.special[e] = {
								setup: function() {
									return Ie(this, e, Ae), !1
								},
								trigger: function() {
									return Ie(this, e), !0
								},
								_default: function(t) {
									return Q.get(t.target, e)
								},
								delegateType: t
							}
						})), b.each({
							mouseenter: "mouseover",
							mouseleave: "mouseout",
							pointerenter: "pointerover",
							pointerleave: "pointerout"
						}, (function(e, t) {
							b.event.special[e] = {
								delegateType: t,
								bindType: t,
								handle: function(e) {
									var n, i = e.relatedTarget,
										s = e.handleObj;
									return i && (i === this || b.contains(this, i)) || (e.type = s.origType, n = s.handler.apply(this, arguments), e.type = t), n
								}
							}
						})), b.fn.extend({
							on: function(e, t, n, i) {
								return Re(this, e, t, n, i)
							},
							one: function(e, t, n, i) {
								return Re(this, e, t, n, i, 1)
							},
							off: function(e, t, n) {
								var i, s;
								if (e && e.preventDefault && e.handleObj) return i = e.handleObj, b(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;
								if ("object" == typeof e) {
									for (s in e) this.off(s, t, e[s]);
									return this
								}
								return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = be), this.each((function() {
									b.event.remove(this, e, n, t)
								}))
							}
						});
						var Pe = /<script|<style|<link/i,
							De = /checked\s*(?:[^=]|=\s*.checked.)/i,
							we = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

						function Oe(e, t) {
							return w(e, "table") && w(11 !== t.nodeType ? t : t.firstChild, "tr") && b(e).children("tbody")[0] || e
						}

						function Ne(e) {
							return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
						}

						function Me(e) {
							return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
						}

						function Le(e, t) {
							var n, i, s, r, o, a;
							if (1 === t.nodeType) {
								if (Q.hasData(e) && (a = Q.get(e).events))
									for (s in Q.remove(t, "handle events"), a)
										for (n = 0, i = a[s].length; n < i; n++) b.event.add(t, s, a[s][n]);
								Z.hasData(e) && (r = Z.access(e), o = b.extend({}, r), Z.set(t, o))
							}
						}

						function ke(e, t, n, i) {
							t = c(t);
							var s, r, o, a, d, l, u = 0,
								h = e.length,
								p = h - 1,
								m = t[0],
								f = _(m);
							if (f || 1 < h && "string" == typeof m && !g.checkClone && De.test(m)) return e.each((function(s) {
								var r = e.eq(s);
								f && (t[0] = m.call(this, s, r.html())), ke(r, t, n, i)
							}));
							if (h && (r = (s = ye(t, e[0].ownerDocument, !1, e, i)).firstChild, 1 === s.childNodes.length && (s = r), r || i)) {
								for (a = (o = b.map(ve(s, "script"), Ne)).length; u < h; u++) d = s, u !== p && (d = b.clone(d, !0, !0), a && b.merge(o, ve(d, "script"))), n.call(e[u], d, u);
								if (a)
									for (l = o[o.length - 1].ownerDocument, b.map(o, Me), u = 0; u < a; u++) d = o[u], ge.test(d.type || "") && !Q.access(d, "globalEval") && b.contains(l, d) && (d.src && "module" !== (d.type || "").toLowerCase() ? b._evalUrl && !d.noModule && b._evalUrl(d.src, {
										nonce: d.nonce || d.getAttribute("nonce")
									}, l) : y(d.textContent.replace(we, ""), d, l))
							}
							return e
						}

						function xe(e, t, n) {
							for (var i, s = t ? b.filter(t, e) : e, r = 0; null != (i = s[r]); r++) n || 1 !== i.nodeType || b.cleanData(ve(i)), i.parentNode && (n && ae(i) && Se(ve(i, "script")), i.parentNode.removeChild(i));
							return e
						}
						b.extend({
							htmlPrefilter: function(e) {
								return e
							},
							clone: function(e, t, n) {
								var i, s, r, o, a, c, d, l = e.cloneNode(!0),
									u = ae(e);
								if (!(g.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || b.isXMLDoc(e)))
									for (o = ve(l), i = 0, s = (r = ve(e)).length; i < s; i++) a = r[i], "input" === (d = (c = o[i]).nodeName.toLowerCase()) && me.test(a.type) ? c.checked = a.checked : "input" !== d && "textarea" !== d || (c.defaultValue = a.defaultValue);
								if (t)
									if (n)
										for (r = r || ve(e), o = o || ve(l), i = 0, s = r.length; i < s; i++) Le(r[i], o[i]);
									else Le(e, l);
								return 0 < (o = ve(l, "script")).length && Se(o, !u && ve(e, "script")), l
							},
							cleanData: function(e) {
								for (var t, n, i, s = b.event.special, r = 0; void 0 !== (n = e[r]); r++)
									if (z(n)) {
										if (t = n[Q.expando]) {
											if (t.events)
												for (i in t.events) s[i] ? b.event.remove(n, i) : b.removeEvent(n, i, t.handle);
											n[Q.expando] = void 0
										}
										n[Z.expando] && (n[Z.expando] = void 0)
									}
							}
						}), b.fn.extend({
							detach: function(e) {
								return xe(this, e, !0)
							},
							remove: function(e) {
								return xe(this, e)
							},
							text: function(e) {
								return G(this, (function(e) {
									return void 0 === e ? b.text(this) : this.empty().each((function() {
										1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
									}))
								}), null, e, arguments.length)
							},
							append: function() {
								return ke(this, arguments, (function(e) {
									1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Oe(this, e).appendChild(e)
								}))
							},
							prepend: function() {
								return ke(this, arguments, (function(e) {
									if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
										var t = Oe(this, e);
										t.insertBefore(e, t.firstChild)
									}
								}))
							},
							before: function() {
								return ke(this, arguments, (function(e) {
									this.parentNode && this.parentNode.insertBefore(e, this)
								}))
							},
							after: function() {
								return ke(this, arguments, (function(e) {
									this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
								}))
							},
							empty: function() {
								for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (b.cleanData(ve(e, !1)), e.textContent = "");
								return this
							},
							clone: function(e, t) {
								return e = null != e && e, t = null == t ? e : t, this.map((function() {
									return b.clone(this, e, t)
								}))
							},
							html: function(e) {
								return G(this, (function(e) {
									var t = this[0] || {},
										n = 0,
										i = this.length;
									if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
									if ("string" == typeof e && !Pe.test(e) && !_e[(fe.exec(e) || ["", ""])[1].toLowerCase()]) {
										e = b.htmlPrefilter(e);
										try {
											for (; n < i; n++) 1 === (t = this[n] || {}).nodeType && (b.cleanData(ve(t, !1)), t.innerHTML = e);
											t = 0
										} catch (e) {}
									}
									t && this.empty().append(e)
								}), null, e, arguments.length)
							},
							replaceWith: function() {
								var e = [];
								return ke(this, arguments, (function(t) {
									var n = this.parentNode;
									b.inArray(this, e) < 0 && (b.cleanData(ve(this)), n && n.replaceChild(t, this))
								}), e)
							}
						}), b.each({
							appendTo: "append",
							prependTo: "prepend",
							insertBefore: "before",
							insertAfter: "after",
							replaceAll: "replaceWith"
						}, (function(e, t) {
							b.fn[e] = function(e) {
								for (var n, i = [], s = b(e), r = s.length - 1, o = 0; o <= r; o++) n = o === r ? this : this.clone(!0), b(s[o])[t](n), d.apply(i, n.get());
								return this.pushStack(i)
							}
						}));
						var Fe = new RegExp("^(" + ie + ")(?!px)[a-z%]+$", "i"),
							Ve = /^--/,
							Ue = function(e) {
								var t = e.ownerDocument.defaultView;
								return t && t.opener || (t = i), t.getComputedStyle(e)
							},
							je = function(e, t, n) {
								var i, s, r = {};
								for (s in t) r[s] = e.style[s], e.style[s] = t[s];
								for (s in i = n.call(e), t) e.style[s] = r[s];
								return i
							},
							He = new RegExp(re.join("|"), "i"),
							Be = "[\\x20\\t\\r\\n\\f]",
							$e = new RegExp("^" + Be + "+|((?:^|[^\\\\])(?:\\\\.)*)" + Be + "+$", "g");

						function Je(e, t, n) {
							var i, s, r, o, a = Ve.test(t),
								c = e.style;
							return (n = n || Ue(e)) && (o = n.getPropertyValue(t) || n[t], a && (o = o.replace($e, "$1")), "" !== o || ae(e) || (o = b.style(e, t)), !g.pixelBoxStyles() && Fe.test(o) && He.test(t) && (i = c.width, s = c.minWidth, r = c.maxWidth, c.minWidth = c.maxWidth = c.width = o, o = n.width, c.width = i, c.minWidth = s, c.maxWidth = r)), void 0 !== o ? o + "" : o
						}

						function Ge(e, t) {
							return {
								get: function() {
									if (!e()) return (this.get = t).apply(this, arguments);
									delete this.get
								}
							}
						}! function() {
							function e() {
								if (l) {
									d.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", oe.appendChild(d).appendChild(l);
									var e = i.getComputedStyle(l);
									n = "1%" !== e.top, c = 12 === t(e.marginLeft), l.style.right = "60%", o = 36 === t(e.right), s = 36 === t(e.width), l.style.position = "absolute", r = 12 === t(l.offsetWidth / 3), oe.removeChild(d), l = null
								}
							}

							function t(e) {
								return Math.round(parseFloat(e))
							}
							var n, s, r, o, a, c, d = S.createElement("div"),
								l = S.createElement("div");
							l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", g.clearCloneStyle = "content-box" === l.style.backgroundClip, b.extend(g, {
								boxSizingReliable: function() {
									return e(), s
								},
								pixelBoxStyles: function() {
									return e(), o
								},
								pixelPosition: function() {
									return e(), n
								},
								reliableMarginLeft: function() {
									return e(), c
								},
								scrollboxSize: function() {
									return e(), r
								},
								reliableTrDimensions: function() {
									var e, t, n, s;
									return null == a && (e = S.createElement("table"), t = S.createElement("tr"), n = S.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", oe.appendChild(e).appendChild(t).appendChild(n), s = i.getComputedStyle(t), a = parseInt(s.height, 10) + parseInt(s.borderTopWidth, 10) + parseInt(s.borderBottomWidth, 10) === t.offsetHeight, oe.removeChild(e)), a
								}
							}))
						}();
						var qe = ["Webkit", "Moz", "ms"],
							Ke = S.createElement("div").style,
							We = {};

						function Xe(e) {
							return b.cssProps[e] || We[e] || (e in Ke ? e : We[e] = function(e) {
								for (var t = e[0].toUpperCase() + e.slice(1), n = qe.length; n--;)
									if ((e = qe[n] + t) in Ke) return e
							}(e) || e)
						}
						var ze, Ye, Qe = /^(none|table(?!-c[ea]).+)/,
							Ze = {
								position: "absolute",
								visibility: "hidden",
								display: "block"
							},
							et = {
								letterSpacing: "0",
								fontWeight: "400"
							};

						function tt(e, t, n) {
							var i = se.exec(t);
							return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : t
						}

						function nt(e, t, n, i, s, r) {
							var o = "width" === t ? 1 : 0,
								a = 0,
								c = 0;
							if (n === (i ? "border" : "content")) return 0;
							for (; o < 4; o += 2) "margin" === n && (c += b.css(e, n + re[o], !0, s)), i ? ("content" === n && (c -= b.css(e, "padding" + re[o], !0, s)), "margin" !== n && (c -= b.css(e, "border" + re[o] + "Width", !0, s))) : (c += b.css(e, "padding" + re[o], !0, s), "padding" !== n ? c += b.css(e, "border" + re[o] + "Width", !0, s) : a += b.css(e, "border" + re[o] + "Width", !0, s));
							return !i && 0 <= r && (c += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - r - c - a - .5)) || 0), c
						}

						function it(e, t, n) {
							var i = Ue(e),
								s = (!g.boxSizingReliable() || n) && "border-box" === b.css(e, "boxSizing", !1, i),
								r = s,
								o = Je(e, t, i),
								a = "offset" + t[0].toUpperCase() + t.slice(1);
							if (Fe.test(o)) {
								if (!n) return o;
								o = "auto"
							}
							return (!g.boxSizingReliable() && s || !g.reliableTrDimensions() && w(e, "tr") || "auto" === o || !parseFloat(o) && "inline" === b.css(e, "display", !1, i)) && e.getClientRects().length && (s = "border-box" === b.css(e, "boxSizing", !1, i), (r = a in e) && (o = e[a])), (o = parseFloat(o) || 0) + nt(e, t, n || (s ? "border" : "content"), r, i, o) + "px"
						}
						b.extend({
							cssHooks: {
								opacity: {
									get: function(e, t) {
										if (t) {
											var n = Je(e, "opacity");
											return "" === n ? "1" : n
										}
									}
								}
							},
							cssNumber: {
								animationIterationCount: !0,
								columnCount: !0,
								fillOpacity: !0,
								flexGrow: !0,
								flexShrink: !0,
								fontWeight: !0,
								gridArea: !0,
								gridColumn: !0,
								gridColumnEnd: !0,
								gridColumnStart: !0,
								gridRow: !0,
								gridRowEnd: !0,
								gridRowStart: !0,
								lineHeight: !0,
								opacity: !0,
								order: !0,
								orphans: !0,
								widows: !0,
								zIndex: !0,
								zoom: !0
							},
							cssProps: {},
							style: function(e, t, n, i) {
								if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
									var s, r, o, a = X(t),
										c = Ve.test(t),
										d = e.style;
									if (c || (t = Xe(a)), o = b.cssHooks[t] || b.cssHooks[a], void 0 === n) return o && "get" in o && void 0 !== (s = o.get(e, !1, i)) ? s : d[t];
									"string" == (r = typeof n) && (s = se.exec(n)) && s[1] && (n = function(e, t, n, i) {
										var s, r, o = 20,
											a = function() {
												return b.css(e, t, "")
											},
											c = a(),
											d = n && n[3] || (b.cssNumber[t] ? "" : "px"),
											l = e.nodeType && (b.cssNumber[t] || "px" !== d && +c) && se.exec(b.css(e, t));
										if (l && l[3] !== d) {
											for (c /= 2, d = d || l[3], l = +c || 1; o--;) b.style(e, t, l + d), (1 - r) * (1 - (r = a() / c || .5)) <= 0 && (o = 0), l /= r;
											l *= 2, b.style(e, t, l + d), n = n || []
										}
										return n && (l = +l || +c || 0, s = n[1] ? l + (n[1] + 1) * n[2] : +n[2]), s
									}(e, t, s), r = "number"), null != n && n == n && ("number" !== r || c || (n += s && s[3] || (b.cssNumber[a] ? "" : "px")), g.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (d[t] = "inherit"), o && "set" in o && void 0 === (n = o.set(e, n, i)) || (c ? d.setProperty(t, n) : d[t] = n))
								}
							},
							css: function(e, t, n, i) {
								var s, r, o, a = X(t);
								return Ve.test(t) || (t = Xe(a)), (o = b.cssHooks[t] || b.cssHooks[a]) && "get" in o && (s = o.get(e, !0, n)), void 0 === s && (s = Je(e, t, i)), "normal" === s && t in et && (s = et[t]), "" === n || n ? (r = parseFloat(s), !0 === n || isFinite(r) ? r || 0 : s) : s
							}
						}), b.each(["height", "width"], (function(e, t) {
							b.cssHooks[t] = {
								get: function(e, n, i) {
									if (n) return !Qe.test(b.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? it(e, t, i) : je(e, Ze, (function() {
										return it(e, t, i)
									}))
								},
								set: function(e, n, i) {
									var s, r = Ue(e),
										o = !g.scrollboxSize() && "absolute" === r.position,
										a = (o || i) && "border-box" === b.css(e, "boxSizing", !1, r),
										c = i ? nt(e, t, i, a, r) : 0;
									return a && o && (c -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(r[t]) - nt(e, t, "border", !1, r) - .5)), c && (s = se.exec(n)) && "px" !== (s[3] || "px") && (e.style[t] = n, n = b.css(e, t)), tt(0, n, c)
								}
							}
						})), b.cssHooks.marginLeft = Ge(g.reliableMarginLeft, (function(e, t) {
							if (t) return (parseFloat(Je(e, "marginLeft")) || e.getBoundingClientRect().left - je(e, {
								marginLeft: 0
							}, (function() {
								return e.getBoundingClientRect().left
							}))) + "px"
						})), b.each({
							margin: "",
							padding: "",
							border: "Width"
						}, (function(e, t) {
							b.cssHooks[e + t] = {
								expand: function(n) {
									for (var i = 0, s = {}, r = "string" == typeof n ? n.split(" ") : [n]; i < 4; i++) s[e + re[i] + t] = r[i] || r[i - 2] || r[0];
									return s
								}
							}, "margin" !== e && (b.cssHooks[e + t].set = tt)
						})), b.fn.extend({
							css: function(e, t) {
								return G(this, (function(e, t, n) {
									var i, s, r = {},
										o = 0;
									if (Array.isArray(t)) {
										for (i = Ue(e), s = t.length; o < s; o++) r[t[o]] = b.css(e, t[o], !1, i);
										return r
									}
									return void 0 !== n ? b.style(e, t, n) : b.css(e, t)
								}), e, t, 1 < arguments.length)
							}
						}), b.fn.delay = function(e, t) {
							return e = b.fx && b.fx.speeds[e] || e, t = t || "fx", this.queue(t, (function(t, n) {
								var s = i.setTimeout(t, e);
								n.stop = function() {
									i.clearTimeout(s)
								}
							}))
						}, ze = S.createElement("input"), Ye = S.createElement("select").appendChild(S.createElement("option")), ze.type = "checkbox", g.checkOn = "" !== ze.value, g.optSelected = Ye.selected, (ze = S.createElement("input")).value = "t", ze.type = "radio", g.radioValue = "t" === ze.value;
						var st, rt = b.expr.attrHandle;
						b.fn.extend({
							attr: function(e, t) {
								return G(this, b.attr, e, t, 1 < arguments.length)
							},
							removeAttr: function(e) {
								return this.each((function() {
									b.removeAttr(this, e)
								}))
							}
						}), b.extend({
							attr: function(e, t, n) {
								var i, s, r = e.nodeType;
								if (3 !== r && 8 !== r && 2 !== r) return void 0 === e.getAttribute ? b.prop(e, t, n) : (1 === r && b.isXMLDoc(e) || (s = b.attrHooks[t.toLowerCase()] || (b.expr.match.bool.test(t) ? st : void 0)), void 0 !== n ? null === n ? void b.removeAttr(e, t) : s && "set" in s && void 0 !== (i = s.set(e, n, t)) ? i : (e.setAttribute(t, n + ""), n) : s && "get" in s && null !== (i = s.get(e, t)) ? i : null == (i = b.find.attr(e, t)) ? void 0 : i)
							},
							attrHooks: {
								type: {
									set: function(e, t) {
										if (!g.radioValue && "radio" === t && w(e, "input")) {
											var n = e.value;
											return e.setAttribute("type", t), n && (e.value = n), t
										}
									}
								}
							},
							removeAttr: function(e, t) {
								var n, i = 0,
									s = t && t.match(V);
								if (s && 1 === e.nodeType)
									for (; n = s[i++];) e.removeAttribute(n)
							}
						}), st = {
							set: function(e, t, n) {
								return !1 === t ? b.removeAttr(e, n) : e.setAttribute(n, n), n
							}
						}, b.each(b.expr.match.bool.source.match(/\w+/g), (function(e, t) {
							var n = rt[t] || b.find.attr;
							rt[t] = function(e, t, i) {
								var s, r, o = t.toLowerCase();
								return i || (r = rt[o], rt[o] = s, s = null != n(e, t, i) ? o : null, rt[o] = r), s
							}
						}));
						var ot = /^(?:input|select|textarea|button)$/i,
							at = /^(?:a|area)$/i;

						function ct(e) {
							return (e.match(V) || []).join(" ")
						}

						function dt(e) {
							return e.getAttribute && e.getAttribute("class") || ""
						}

						function lt(e) {
							return Array.isArray(e) ? e : "string" == typeof e && e.match(V) || []
						}
						b.fn.extend({
							prop: function(e, t) {
								return G(this, b.prop, e, t, 1 < arguments.length)
							},
							removeProp: function(e) {
								return this.each((function() {
									delete this[b.propFix[e] || e]
								}))
							}
						}), b.extend({
							prop: function(e, t, n) {
								var i, s, r = e.nodeType;
								if (3 !== r && 8 !== r && 2 !== r) return 1 === r && b.isXMLDoc(e) || (t = b.propFix[t] || t, s = b.propHooks[t]), void 0 !== n ? s && "set" in s && void 0 !== (i = s.set(e, n, t)) ? i : e[t] = n : s && "get" in s && null !== (i = s.get(e, t)) ? i : e[t]
							},
							propHooks: {
								tabIndex: {
									get: function(e) {
										var t = b.find.attr(e, "tabindex");
										return t ? parseInt(t, 10) : ot.test(e.nodeName) || at.test(e.nodeName) && e.href ? 0 : -1
									}
								}
							},
							propFix: {
								for: "htmlFor",
								class: "className"
							}
						}), g.optSelected || (b.propHooks.selected = {
							get: function(e) {
								var t = e.parentNode;
								return t && t.parentNode && t.parentNode.selectedIndex, null
							},
							set: function(e) {
								var t = e.parentNode;
								t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
							}
						}), b.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function() {
							b.propFix[this.toLowerCase()] = this
						})), b.fn.extend({
							addClass: function(e) {
								var t, n, i, s, r, o;
								return _(e) ? this.each((function(t) {
									b(this).addClass(e.call(this, t, dt(this)))
								})) : (t = lt(e)).length ? this.each((function() {
									if (i = dt(this), n = 1 === this.nodeType && " " + ct(i) + " ") {
										for (r = 0; r < t.length; r++) s = t[r], n.indexOf(" " + s + " ") < 0 && (n += s + " ");
										o = ct(n), i !== o && this.setAttribute("class", o)
									}
								})) : this
							},
							removeClass: function(e) {
								var t, n, i, s, r, o;
								return _(e) ? this.each((function(t) {
									b(this).removeClass(e.call(this, t, dt(this)))
								})) : arguments.length ? (t = lt(e)).length ? this.each((function() {
									if (i = dt(this), n = 1 === this.nodeType && " " + ct(i) + " ") {
										for (r = 0; r < t.length; r++)
											for (s = t[r]; - 1 < n.indexOf(" " + s + " ");) n = n.replace(" " + s + " ", " ");
										o = ct(n), i !== o && this.setAttribute("class", o)
									}
								})) : this : this.attr("class", "")
							},
							toggleClass: function(e, t) {
								var n, i, s, r, o = typeof e,
									a = "string" === o || Array.isArray(e);
								return _(e) ? this.each((function(n) {
									b(this).toggleClass(e.call(this, n, dt(this), t), t)
								})) : "boolean" == typeof t && a ? t ? this.addClass(e) : this.removeClass(e) : (n = lt(e), this.each((function() {
									if (a)
										for (r = b(this), s = 0; s < n.length; s++) i = n[s], r.hasClass(i) ? r.removeClass(i) : r.addClass(i);
									else void 0 !== e && "boolean" !== o || ((i = dt(this)) && Q.set(this, "__className__", i), this.setAttribute && this.setAttribute("class", i || !1 === e ? "" : Q.get(this, "__className__") || ""))
								})))
							},
							hasClass: function(e) {
								var t, n, i = 0;
								for (t = " " + e + " "; n = this[i++];)
									if (1 === n.nodeType && -1 < (" " + ct(dt(n)) + " ").indexOf(t)) return !0;
								return !1
							}
						});
						var ut = /\r/g;
						b.fn.extend({
							val: function(e) {
								var t, n, i, s = this[0];
								return arguments.length ? (i = _(e), this.each((function(n) {
									var s;
									1 === this.nodeType && (null == (s = i ? e.call(this, n, b(this).val()) : e) ? s = "" : "number" == typeof s ? s += "" : Array.isArray(s) && (s = b.map(s, (function(e) {
										return null == e ? "" : e + ""
									}))), (t = b.valHooks[this.type] || b.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, s, "value") || (this.value = s))
								}))) : s ? (t = b.valHooks[s.type] || b.valHooks[s.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(s, "value")) ? n : "string" == typeof(n = s.value) ? n.replace(ut, "") : null == n ? "" : n : void 0
							}
						}), b.extend({
							valHooks: {
								option: {
									get: function(e) {
										var t = b.find.attr(e, "value");
										return null != t ? t : ct(b.text(e))
									}
								},
								select: {
									get: function(e) {
										var t, n, i, s = e.options,
											r = e.selectedIndex,
											o = "select-one" === e.type,
											a = o ? null : [],
											c = o ? r + 1 : s.length;
										for (i = r < 0 ? c : o ? r : 0; i < c; i++)
											if (((n = s[i]).selected || i === r) && !n.disabled && (!n.parentNode.disabled || !w(n.parentNode, "optgroup"))) {
												if (t = b(n).val(), o) return t;
												a.push(t)
											} return a
									},
									set: function(e, t) {
										for (var n, i, s = e.options, r = b.makeArray(t), o = s.length; o--;)((i = s[o]).selected = -1 < b.inArray(b.valHooks.option.get(i), r)) && (n = !0);
										return n || (e.selectedIndex = -1), r
									}
								}
							}
						}), b.each(["radio", "checkbox"], (function() {
							b.valHooks[this] = {
								set: function(e, t) {
									if (Array.isArray(t)) return e.checked = -1 < b.inArray(b(e).val(), t)
								}
							}, g.checkOn || (b.valHooks[this].get = function(e) {
								return null === e.getAttribute("value") ? "on" : e.value
							})
						})), g.focusin = "onfocusin" in i;
						var ht = /^(?:focusinfocus|focusoutblur)$/,
							pt = function(e) {
								e.stopPropagation()
							};
						b.extend(b.event, {
							trigger: function(e, t, n, s) {
								var r, o, a, c, d, l, u, h, m = [n || S],
									f = p.call(e, "type") ? e.type : e,
									g = p.call(e, "namespace") ? e.namespace.split(".") : [];
								if (o = h = a = n = n || S, 3 !== n.nodeType && 8 !== n.nodeType && !ht.test(f + b.event.triggered) && (-1 < f.indexOf(".") && (f = (g = f.split(".")).shift(), g.sort()), d = f.indexOf(":") < 0 && "on" + f, (e = e[b.expando] ? e : new b.Event(f, "object" == typeof e && e)).isTrigger = s ? 2 : 3, e.namespace = g.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + g.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : b.makeArray(t, [e]), u = b.event.special[f] || {}, s || !u.trigger || !1 !== u.trigger.apply(n, t))) {
									if (!s && !u.noBubble && !v(n)) {
										for (c = u.delegateType || f, ht.test(c + f) || (o = o.parentNode); o; o = o.parentNode) m.push(o), a = o;
										a === (n.ownerDocument || S) && m.push(a.defaultView || a.parentWindow || i)
									}
									for (r = 0;
										(o = m[r++]) && !e.isPropagationStopped();) h = o, e.type = 1 < r ? c : u.bindType || f, (l = (Q.get(o, "events") || Object.create(null))[e.type] && Q.get(o, "handle")) && l.apply(o, t), (l = d && o[d]) && l.apply && z(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault());
									return e.type = f, s || e.isDefaultPrevented() || u._default && !1 !== u._default.apply(m.pop(), t) || !z(n) || d && _(n[f]) && !v(n) && ((a = n[d]) && (n[d] = null), b.event.triggered = f, e.isPropagationStopped() && h.addEventListener(f, pt), n[f](), e.isPropagationStopped() && h.removeEventListener(f, pt), b.event.triggered = void 0, a && (n[d] = a)), e.result
								}
							},
							simulate: function(e, t, n) {
								var i = b.extend(new b.Event, n, {
									type: e,
									isSimulated: !0
								});
								b.event.trigger(i, null, t)
							}
						}), b.fn.extend({
							trigger: function(e, t) {
								return this.each((function() {
									b.event.trigger(e, t, this)
								}))
							},
							triggerHandler: function(e, t) {
								var n = this[0];
								if (n) return b.event.trigger(e, t, n, !0)
							}
						}), g.focusin || b.each({
							focus: "focusin",
							blur: "focusout"
						}, (function(e, t) {
							var n = function(e) {
								b.event.simulate(t, e.target, b.event.fix(e))
							};
							b.event.special[t] = {
								setup: function() {
									var i = this.ownerDocument || this.document || this,
										s = Q.access(i, t);
									s || i.addEventListener(e, n, !0), Q.access(i, t, (s || 0) + 1)
								},
								teardown: function() {
									var i = this.ownerDocument || this.document || this,
										s = Q.access(i, t) - 1;
									s ? Q.access(i, t, s) : (i.removeEventListener(e, n, !0), Q.remove(i, t))
								}
							}
						})), b.parseXML = function(e) {
							var t, n;
							if (!e || "string" != typeof e) return null;
							try {
								t = (new i.DOMParser).parseFromString(e, "text/xml")
							} catch (e) {}
							return n = t && t.getElementsByTagName("parsererror")[0], t && !n || b.error("Invalid XML: " + (n ? b.map(n.childNodes, (function(e) {
								return e.textContent
							})).join("\n") : e)), t
						};
						var mt, ft = /\[\]$/,
							gt = /\r?\n/g,
							_t = /^(?:submit|button|image|reset|file)$/i,
							vt = /^(?:input|select|textarea|keygen)/i;

						function St(e, t, n, i) {
							var s;
							if (Array.isArray(t)) b.each(t, (function(t, s) {
								n || ft.test(e) ? i(e, s) : St(e + "[" + ("object" == typeof s && null != s ? t : "") + "]", s, n, i)
							}));
							else if (n || "object" !== T(t)) i(e, t);
							else
								for (s in t) St(e + "[" + s + "]", t[s], n, i)
						}
						b.param = function(e, t) {
							var n, i = [],
								s = function(e, t) {
									var n = _(t) ? t() : t;
									i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n)
								};
							if (null == e) return "";
							if (Array.isArray(e) || e.jquery && !b.isPlainObject(e)) b.each(e, (function() {
								s(this.name, this.value)
							}));
							else
								for (n in e) St(n, e[n], t, s);
							return i.join("&")
						}, b.fn.extend({
							serialize: function() {
								return b.param(this.serializeArray())
							},
							serializeArray: function() {
								return this.map((function() {
									var e = b.prop(this, "elements");
									return e ? b.makeArray(e) : this
								})).filter((function() {
									var e = this.type;
									return this.name && !b(this).is(":disabled") && vt.test(this.nodeName) && !_t.test(e) && (this.checked || !me.test(e))
								})).map((function(e, t) {
									var n = b(this).val();
									return null == n ? null : Array.isArray(n) ? b.map(n, (function(e) {
										return {
											name: t.name,
											value: e.replace(gt, "\r\n")
										}
									})) : {
										name: t.name,
										value: n.replace(gt, "\r\n")
									}
								})).get()
							}
						}), b.fn.extend({
							wrapAll: function(e) {
								var t;
								return this[0] && (_(e) && (e = e.call(this[0])), t = b(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map((function() {
									for (var e = this; e.firstElementChild;) e = e.firstElementChild;
									return e
								})).append(this)), this
							},
							wrapInner: function(e) {
								return _(e) ? this.each((function(t) {
									b(this).wrapInner(e.call(this, t))
								})) : this.each((function() {
									var t = b(this),
										n = t.contents();
									n.length ? n.wrapAll(e) : t.append(e)
								}))
							},
							wrap: function(e) {
								var t = _(e);
								return this.each((function(n) {
									b(this).wrapAll(t ? e.call(this, n) : e)
								}))
							},
							unwrap: function(e) {
								return this.parent(e).not("body").each((function() {
									b(this).replaceWith(this.childNodes)
								})), this
							}
						}), b.expr.pseudos.hidden = function(e) {
							return !b.expr.pseudos.visible(e)
						}, b.expr.pseudos.visible = function(e) {
							return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
						}, g.createHTMLDocument = ((mt = S.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === mt.childNodes.length), b.parseHTML = function(e, t, n) {
							return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (g.createHTMLDocument ? ((i = (t = S.implementation.createHTMLDocument("")).createElement("base")).href = S.location.href, t.head.appendChild(i)) : t = S), r = !n && [], (s = O.exec(e)) ? [t.createElement(s[1])] : (s = ye([e], t, r), r && r.length && b(r).remove(), b.merge([], s.childNodes)));
							var i, s, r
						}, b.offset = {
							setOffset: function(e, t, n) {
								var i, s, r, o, a, c, d = b.css(e, "position"),
									l = b(e),
									u = {};
								"static" === d && (e.style.position = "relative"), a = l.offset(), r = b.css(e, "top"), c = b.css(e, "left"), ("absolute" === d || "fixed" === d) && -1 < (r + c).indexOf("auto") ? (o = (i = l.position()).top, s = i.left) : (o = parseFloat(r) || 0, s = parseFloat(c) || 0), _(t) && (t = t.call(e, n, b.extend({}, a))), null != t.top && (u.top = t.top - a.top + o), null != t.left && (u.left = t.left - a.left + s), "using" in t ? t.using.call(e, u) : l.css(u)
							}
						}, b.fn.extend({
							offset: function(e) {
								if (arguments.length) return void 0 === e ? this : this.each((function(t) {
									b.offset.setOffset(this, e, t)
								}));
								var t, n, i = this[0];
								return i ? i.getClientRects().length ? (t = i.getBoundingClientRect(), n = i.ownerDocument.defaultView, {
									top: t.top + n.pageYOffset,
									left: t.left + n.pageXOffset
								}) : {
									top: 0,
									left: 0
								} : void 0
							},
							position: function() {
								if (this[0]) {
									var e, t, n, i = this[0],
										s = {
											top: 0,
											left: 0
										};
									if ("fixed" === b.css(i, "position")) t = i.getBoundingClientRect();
									else {
										for (t = this.offset(), n = i.ownerDocument, e = i.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && "static" === b.css(e, "position");) e = e.parentNode;
										e && e !== i && 1 === e.nodeType && ((s = b(e).offset()).top += b.css(e, "borderTopWidth", !0), s.left += b.css(e, "borderLeftWidth", !0))
									}
									return {
										top: t.top - s.top - b.css(i, "marginTop", !0),
										left: t.left - s.left - b.css(i, "marginLeft", !0)
									}
								}
							},
							offsetParent: function() {
								return this.map((function() {
									for (var e = this.offsetParent; e && "static" === b.css(e, "position");) e = e.offsetParent;
									return e || oe
								}))
							}
						}), b.each({
							scrollLeft: "pageXOffset",
							scrollTop: "pageYOffset"
						}, (function(e, t) {
							var n = "pageYOffset" === t;
							b.fn[e] = function(i) {
								return G(this, (function(e, i, s) {
									var r;
									if (v(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === s) return r ? r[t] : e[i];
									r ? r.scrollTo(n ? r.pageXOffset : s, n ? s : r.pageYOffset) : e[i] = s
								}), e, i, arguments.length)
							}
						})), b.each(["top", "left"], (function(e, t) {
							b.cssHooks[t] = Ge(g.pixelPosition, (function(e, n) {
								if (n) return n = Je(e, t), Fe.test(n) ? b(e).position()[t] + "px" : n
							}))
						})), b.each({
							Height: "height",
							Width: "width"
						}, (function(e, t) {
							b.each({
								padding: "inner" + e,
								content: t,
								"": "outer" + e
							}, (function(n, i) {
								b.fn[i] = function(s, r) {
									var o = arguments.length && (n || "boolean" != typeof s),
										a = n || (!0 === s || !0 === r ? "margin" : "border");
									return G(this, (function(t, n, s) {
										var r;
										return v(t) ? 0 === i.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (r = t.documentElement, Math.max(t.body["scroll" + e], r["scroll" + e], t.body["offset" + e], r["offset" + e], r["client" + e])) : void 0 === s ? b.css(t, n, a) : b.style(t, n, s, a)
									}), t, o ? s : void 0, o)
								}
							}))
						})), b.fn.extend({
							bind: function(e, t, n) {
								return this.on(e, null, t, n)
							},
							unbind: function(e, t) {
								return this.off(e, null, t)
							},
							delegate: function(e, t, n, i) {
								return this.on(t, e, n, i)
							},
							undelegate: function(e, t, n) {
								return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
							},
							hover: function(e, t) {
								return this.mouseenter(e).mouseleave(t || e)
							}
						}), b.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function(e, t) {
							b.fn[t] = function(e, n) {
								return 0 < arguments.length ? this.on(t, null, e, n) : this.trigger(t)
							}
						}));
						var Et = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
						b.proxy = function(e, t) {
							var n, i, s;
							if ("string" == typeof t && (n = e[t], t = e, e = n), _(e)) return i = a.call(arguments, 2), (s = function() {
								return e.apply(t || this, i.concat(a.call(arguments)))
							}).guid = e.guid = e.guid || b.guid++, s
						}, b.holdReady = function(e) {
							e ? b.readyWait++ : b.ready(!0)
						}, b.isArray = Array.isArray, b.parseJSON = JSON.parse, b.nodeName = w, b.isFunction = _, b.isWindow = v, b.camelCase = X, b.type = T, b.now = Date.now, b.isNumeric = function(e) {
							var t = b.type(e);
							return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
						}, b.trim = function(e) {
							return null == e ? "" : (e + "").replace(Et, "$1")
						}, void 0 === (n = function() {
							return b
						}.apply(t, [])) || (e.exports = n);
						var yt = i.jQuery,
							Tt = i.$;
						return b.noConflict = function(e) {
							return i.$ === b && (i.$ = Tt), e && i.jQuery === b && (i.jQuery = yt), b
						}, void 0 === s && (i.jQuery = i.$ = b), b
					}))
				},
				3478: (module, exports, __webpack_require__) => {
					var __WEBPACK_AMD_DEFINE_RESULT__;
					(function() {
						"use strict";
						var ERROR = "input is invalid type",
							WINDOW = "object" == typeof window,
							root = WINDOW ? window : {};
						root.JS_MD5_NO_WINDOW && (WINDOW = !1);
						var WEB_WORKER = !WINDOW && "object" == typeof self,
							NODE_JS = !root.JS_MD5_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node;
						NODE_JS ? root = __webpack_require__.g : WEB_WORKER && (root = self);
						var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && module.exports,
							AMD = __webpack_require__.amdO,
							ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer,
							HEX_CHARS = "0123456789abcdef".split(""),
							EXTRA = [128, 32768, 8388608, -2147483648],
							SHIFT = [0, 8, 16, 24],
							OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"],
							BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),
							blocks = [],
							buffer8;
						if (ARRAY_BUFFER) {
							var buffer = new ArrayBuffer(68);
							buffer8 = new Uint8Array(buffer), blocks = new Uint32Array(buffer)
						}!root.JS_MD5_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
							return "[object Array]" === Object.prototype.toString.call(e)
						}), !ARRAY_BUFFER || !root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
							return "object" == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
						});
						var createOutputMethod = function(e) {
								return function(t) {
									return new Md5(!0).update(t)[e]()
								}
							},
							createMethod = function() {
								var e = createOutputMethod("hex");
								NODE_JS && (e = nodeWrap(e)), e.create = function() {
									return new Md5
								}, e.update = function(t) {
									return e.create().update(t)
								};
								for (var t = 0; t < OUTPUT_TYPES.length; ++t) {
									var n = OUTPUT_TYPES[t];
									e[n] = createOutputMethod(n)
								}
								return e
							},
							nodeWrap = function(method) {
								var crypto = eval("require('crypto')"),
									Buffer = eval("require('buffer').Buffer"),
									nodeMethod = function(e) {
										if ("string" == typeof e) return crypto.createHash("md5").update(e, "utf8").digest("hex");
										if (null == e) throw ERROR;
										return e.constructor === ArrayBuffer && (e = new Uint8Array(e)), Array.isArray(e) || ArrayBuffer.isView(e) || e.constructor === Buffer ? crypto.createHash("md5").update(new Buffer(e)).digest("hex") : method(e)
									};
								return nodeMethod
							};

						function Md5(e) {
							if (e) blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks, this.buffer8 = buffer8;
							else if (ARRAY_BUFFER) {
								var t = new ArrayBuffer(68);
								this.buffer8 = new Uint8Array(t), this.blocks = new Uint32Array(t)
							} else this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
							this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0
						}
						Md5.prototype.update = function(e) {
							if (!this.finalized) {
								var t, n = typeof e;
								if ("string" !== n) {
									if ("object" !== n) throw ERROR;
									if (null === e) throw ERROR;
									if (ARRAY_BUFFER && e.constructor === ArrayBuffer) e = new Uint8Array(e);
									else if (!(Array.isArray(e) || ARRAY_BUFFER && ArrayBuffer.isView(e))) throw ERROR;
									t = !0
								}
								for (var i, s, r = 0, o = e.length, a = this.blocks, c = this.buffer8; r < o;) {
									if (this.hashed && (this.hashed = !1, a[0] = a[16], a[16] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = a[9] = a[10] = a[11] = a[12] = a[13] = a[14] = a[15] = 0), t)
										if (ARRAY_BUFFER)
											for (s = this.start; r < o && s < 64; ++r) c[s++] = e[r];
										else
											for (s = this.start; r < o && s < 64; ++r) a[s >> 2] |= e[r] << SHIFT[3 & s++];
									else if (ARRAY_BUFFER)
										for (s = this.start; r < o && s < 64; ++r)(i = e.charCodeAt(r)) < 128 ? c[s++] = i : i < 2048 ? (c[s++] = 192 | i >> 6, c[s++] = 128 | 63 & i) : i < 55296 || i >= 57344 ? (c[s++] = 224 | i >> 12, c[s++] = 128 | i >> 6 & 63, c[s++] = 128 | 63 & i) : (i = 65536 + ((1023 & i) << 10 | 1023 & e.charCodeAt(++r)), c[s++] = 240 | i >> 18, c[s++] = 128 | i >> 12 & 63, c[s++] = 128 | i >> 6 & 63, c[s++] = 128 | 63 & i);
									else
										for (s = this.start; r < o && s < 64; ++r)(i = e.charCodeAt(r)) < 128 ? a[s >> 2] |= i << SHIFT[3 & s++] : i < 2048 ? (a[s >> 2] |= (192 | i >> 6) << SHIFT[3 & s++], a[s >> 2] |= (128 | 63 & i) << SHIFT[3 & s++]) : i < 55296 || i >= 57344 ? (a[s >> 2] |= (224 | i >> 12) << SHIFT[3 & s++], a[s >> 2] |= (128 | i >> 6 & 63) << SHIFT[3 & s++], a[s >> 2] |= (128 | 63 & i) << SHIFT[3 & s++]) : (i = 65536 + ((1023 & i) << 10 | 1023 & e.charCodeAt(++r)), a[s >> 2] |= (240 | i >> 18) << SHIFT[3 & s++], a[s >> 2] |= (128 | i >> 12 & 63) << SHIFT[3 & s++], a[s >> 2] |= (128 | i >> 6 & 63) << SHIFT[3 & s++], a[s >> 2] |= (128 | 63 & i) << SHIFT[3 & s++]);
									this.lastByteIndex = s, this.bytes += s - this.start, s >= 64 ? (this.start = s - 64, this.hash(), this.hashed = !0) : this.start = s
								}
								return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this
							}
						}, Md5.prototype.finalize = function() {
							if (!this.finalized) {
								this.finalized = !0;
								var e = this.blocks,
									t = this.lastByteIndex;
								e[t >> 2] |= EXTRA[3 & t], t >= 56 && (this.hashed || this.hash(), e[0] = e[16], e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0), e[14] = this.bytes << 3, e[15] = this.hBytes << 3 | this.bytes >>> 29, this.hash()
							}
						}, Md5.prototype.hash = function() {
							var e, t, n, i, s, r, o = this.blocks;
							this.first ? t = ((t = ((e = ((e = o[0] - 680876937) << 7 | e >>> 25) - 271733879 << 0) ^ (n = ((n = (-271733879 ^ (i = ((i = (-1732584194 ^ 2004318071 & e) + o[1] - 117830708) << 12 | i >>> 20) + e << 0) & (-271733879 ^ e)) + o[2] - 1126478375) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[3] - 1316259209) << 22 | t >>> 10) + n << 0 : (e = this.h0, t = this.h1, n = this.h2, t = ((t += ((e = ((e += ((i = this.h3) ^ t & (n ^ i)) + o[0] - 680876936) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[1] - 389564586) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[2] + 606105819) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[3] - 1044525330) << 22 | t >>> 10) + n << 0), t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + o[4] - 176418897) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[5] + 1200080426) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[6] - 1473231341) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[7] - 45705983) << 22 | t >>> 10) + n << 0, t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + o[8] + 1770035416) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[9] - 1958414417) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[10] - 42063) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[11] - 1990404162) << 22 | t >>> 10) + n << 0, t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + o[12] + 1804603682) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[13] - 40341101) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[14] - 1502002290) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[15] + 1236535329) << 22 | t >>> 10) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[1] - 165796510) << 5 | e >>> 27) + t << 0) ^ t)) + o[6] - 1069501632) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[11] + 643717713) << 14 | n >>> 18) + i << 0) ^ i)) + o[0] - 373897302) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[5] - 701558691) << 5 | e >>> 27) + t << 0) ^ t)) + o[10] + 38016083) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[15] - 660478335) << 14 | n >>> 18) + i << 0) ^ i)) + o[4] - 405537848) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[9] + 568446438) << 5 | e >>> 27) + t << 0) ^ t)) + o[14] - 1019803690) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[3] - 187363961) << 14 | n >>> 18) + i << 0) ^ i)) + o[8] + 1163531501) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[13] - 1444681467) << 5 | e >>> 27) + t << 0) ^ t)) + o[2] - 51403784) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[7] + 1735328473) << 14 | n >>> 18) + i << 0) ^ i)) + o[12] - 1926607734) << 20 | t >>> 12) + n << 0, t = ((t += ((r = (i = ((i += ((s = t ^ n) ^ (e = ((e += (s ^ i) + o[5] - 378558) << 4 | e >>> 28) + t << 0)) + o[8] - 2022574463) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (r ^ t) + o[11] + 1839030562) << 16 | n >>> 16) + i << 0)) + o[14] - 35309556) << 23 | t >>> 9) + n << 0, t = ((t += ((r = (i = ((i += ((s = t ^ n) ^ (e = ((e += (s ^ i) + o[1] - 1530992060) << 4 | e >>> 28) + t << 0)) + o[4] + 1272893353) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (r ^ t) + o[7] - 155497632) << 16 | n >>> 16) + i << 0)) + o[10] - 1094730640) << 23 | t >>> 9) + n << 0, t = ((t += ((r = (i = ((i += ((s = t ^ n) ^ (e = ((e += (s ^ i) + o[13] + 681279174) << 4 | e >>> 28) + t << 0)) + o[0] - 358537222) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (r ^ t) + o[3] - 722521979) << 16 | n >>> 16) + i << 0)) + o[6] + 76029189) << 23 | t >>> 9) + n << 0, t = ((t += ((r = (i = ((i += ((s = t ^ n) ^ (e = ((e += (s ^ i) + o[9] - 640364487) << 4 | e >>> 28) + t << 0)) + o[12] - 421815835) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (r ^ t) + o[15] + 530742520) << 16 | n >>> 16) + i << 0)) + o[2] - 995338651) << 23 | t >>> 9) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[0] - 198630844) << 6 | e >>> 26) + t << 0) | ~n)) + o[7] + 1126891415) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[14] - 1416354905) << 15 | n >>> 17) + i << 0) | ~e)) + o[5] - 57434055) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[12] + 1700485571) << 6 | e >>> 26) + t << 0) | ~n)) + o[3] - 1894986606) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[10] - 1051523) << 15 | n >>> 17) + i << 0) | ~e)) + o[1] - 2054922799) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[8] + 1873313359) << 6 | e >>> 26) + t << 0) | ~n)) + o[15] - 30611744) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[6] - 1560198380) << 15 | n >>> 17) + i << 0) | ~e)) + o[13] + 1309151649) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[4] - 145523070) << 6 | e >>> 26) + t << 0) | ~n)) + o[11] - 1120210379) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[2] + 718787259) << 15 | n >>> 17) + i << 0) | ~e)) + o[9] - 343485551) << 21 | t >>> 11) + n << 0, this.first ? (this.h0 = e + 1732584193 << 0, this.h1 = t - 271733879 << 0, this.h2 = n - 1732584194 << 0, this.h3 = i + 271733878 << 0, this.first = !1) : (this.h0 = this.h0 + e << 0, this.h1 = this.h1 + t << 0, this.h2 = this.h2 + n << 0, this.h3 = this.h3 + i << 0)
						}, Md5.prototype.hex = function() {
							this.finalize();
							var e = this.h0,
								t = this.h1,
								n = this.h2,
								i = this.h3;
							return HEX_CHARS[e >> 4 & 15] + HEX_CHARS[15 & e] + HEX_CHARS[e >> 12 & 15] + HEX_CHARS[e >> 8 & 15] + HEX_CHARS[e >> 20 & 15] + HEX_CHARS[e >> 16 & 15] + HEX_CHARS[e >> 28 & 15] + HEX_CHARS[e >> 24 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[15 & t] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[15 & n] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[i >> 4 & 15] + HEX_CHARS[15 & i] + HEX_CHARS[i >> 12 & 15] + HEX_CHARS[i >> 8 & 15] + HEX_CHARS[i >> 20 & 15] + HEX_CHARS[i >> 16 & 15] + HEX_CHARS[i >> 28 & 15] + HEX_CHARS[i >> 24 & 15]
						}, Md5.prototype.toString = Md5.prototype.hex, Md5.prototype.digest = function() {
							this.finalize();
							var e = this.h0,
								t = this.h1,
								n = this.h2,
								i = this.h3;
							return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255, 255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255, 255 & n, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255, 255 & i, i >> 8 & 255, i >> 16 & 255, i >> 24 & 255]
						}, Md5.prototype.array = Md5.prototype.digest, Md5.prototype.arrayBuffer = function() {
							this.finalize();
							var e = new ArrayBuffer(16),
								t = new Uint32Array(e);
							return t[0] = this.h0, t[1] = this.h1, t[2] = this.h2, t[3] = this.h3, e
						}, Md5.prototype.buffer = Md5.prototype.arrayBuffer, Md5.prototype.base64 = function() {
							for (var e, t, n, i = "", s = this.array(), r = 0; r < 15;) e = s[r++], t = s[r++], n = s[r++], i += BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[63 & (e << 4 | t >>> 4)] + BASE64_ENCODE_CHAR[63 & (t << 2 | n >>> 6)] + BASE64_ENCODE_CHAR[63 & n];
							return e = s[r], i + (BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[e << 4 & 63] + "==")
						};
						var exports = createMethod();
						COMMON_JS ? module.exports = exports : (root.md5 = exports, AMD && (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
							return exports
						}.call(exports, __webpack_require__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)))
					})()
				},
				2138: (e, t, n) => {
					e = n.nmd(e);
					var i = "__lodash_hash_undefined__",
						s = 9007199254740991,
						r = "[object Arguments]",
						o = "[object Boolean]",
						a = "[object Date]",
						c = "[object Function]",
						d = "[object GeneratorFunction]",
						l = "[object Map]",
						u = "[object Number]",
						h = "[object Object]",
						p = "[object Promise]",
						m = "[object RegExp]",
						f = "[object Set]",
						g = "[object String]",
						_ = "[object Symbol]",
						v = "[object WeakMap]",
						S = "[object ArrayBuffer]",
						E = "[object DataView]",
						y = "[object Float32Array]",
						T = "[object Float64Array]",
						C = "[object Int8Array]",
						b = "[object Int16Array]",
						A = "[object Int32Array]",
						R = "[object Uint8Array]",
						I = "[object Uint8ClampedArray]",
						P = "[object Uint16Array]",
						D = "[object Uint32Array]",
						w = /\w*$/,
						O = /^\[object .+?Constructor\]$/,
						N = /^(?:0|[1-9]\d*)$/,
						M = {};
					M[r] = M["[object Array]"] = M[S] = M[E] = M[o] = M[a] = M[y] = M[T] = M[C] = M[b] = M[A] = M[l] = M[u] = M[h] = M[m] = M[f] = M[g] = M[_] = M[R] = M[I] = M[P] = M[D] = !0, M["[object Error]"] = M[c] = M[v] = !1;
					var L = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
						k = "object" == typeof self && self && self.Object === Object && self,
						x = L || k || Function("return this")(),
						F = t && !t.nodeType && t,
						V = F && e && !e.nodeType && e,
						U = V && V.exports === F;

					function j(e, t) {
						return e.set(t[0], t[1]), e
					}

					function H(e, t) {
						return e.add(t), e
					}

					function B(e, t, n, i) {
						var s = -1,
							r = e ? e.length : 0;
						for (i && r && (n = e[++s]); ++s < r;) n = t(n, e[s], s, e);
						return n
					}

					function $(e) {
						var t = !1;
						if (null != e && "function" != typeof e.toString) try {
							t = !!(e + "")
						} catch (e) {}
						return t
					}

					function J(e) {
						var t = -1,
							n = Array(e.size);
						return e.forEach((function(e, i) {
							n[++t] = [i, e]
						})), n
					}

					function G(e, t) {
						return function(n) {
							return e(t(n))
						}
					}

					function q(e) {
						var t = -1,
							n = Array(e.size);
						return e.forEach((function(e) {
							n[++t] = e
						})), n
					}
					var K, W = Array.prototype,
						X = Function.prototype,
						z = Object.prototype,
						Y = x["__core-js_shared__"],
						Q = (K = /[^.]+$/.exec(Y && Y.keys && Y.keys.IE_PROTO || "")) ? "Symbol(src)_1." + K : "",
						Z = X.toString,
						ee = z.hasOwnProperty,
						te = z.toString,
						ne = RegExp("^" + Z.call(ee).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
						ie = U ? x.Buffer : void 0,
						se = x.Symbol,
						re = x.Uint8Array,
						oe = G(Object.getPrototypeOf, Object),
						ae = Object.create,
						ce = z.propertyIsEnumerable,
						de = W.splice,
						le = Object.getOwnPropertySymbols,
						ue = ie ? ie.isBuffer : void 0,
						he = G(Object.keys, Object),
						pe = xe(x, "DataView"),
						me = xe(x, "Map"),
						fe = xe(x, "Promise"),
						ge = xe(x, "Set"),
						_e = xe(x, "WeakMap"),
						ve = xe(Object, "create"),
						Se = He(pe),
						Ee = He(me),
						ye = He(fe),
						Te = He(ge),
						Ce = He(_e),
						be = se ? se.prototype : void 0,
						Ae = be ? be.valueOf : void 0;

					function Re(e) {
						var t = -1,
							n = e ? e.length : 0;
						for (this.clear(); ++t < n;) {
							var i = e[t];
							this.set(i[0], i[1])
						}
					}

					function Ie(e) {
						var t = -1,
							n = e ? e.length : 0;
						for (this.clear(); ++t < n;) {
							var i = e[t];
							this.set(i[0], i[1])
						}
					}

					function Pe(e) {
						var t = -1,
							n = e ? e.length : 0;
						for (this.clear(); ++t < n;) {
							var i = e[t];
							this.set(i[0], i[1])
						}
					}

					function De(e) {
						this.__data__ = new Ie(e)
					}

					function we(e, t, n) {
						var i = e[t];
						ee.call(e, t) && Be(i, n) && (void 0 !== n || t in e) || (e[t] = n)
					}

					function Oe(e, t) {
						for (var n = e.length; n--;)
							if (Be(e[n][0], t)) return n;
						return -1
					}

					function Ne(e, t, n, i, s, p, v) {
						var O;
						if (i && (O = p ? i(e, s, p, v) : i(e)), void 0 !== O) return O;
						if (!Ke(e)) return e;
						var N = $e(e);
						if (N) {
							if (O = function(e) {
									var t = e.length,
										n = e.constructor(t);
									return t && "string" == typeof e[0] && ee.call(e, "index") && (n.index = e.index, n.input = e.input), n
								}(e), !t) return function(e, t) {
								var n = -1,
									i = e.length;
								for (t || (t = Array(i)); ++n < i;) t[n] = e[n];
								return t
							}(e, O)
						} else {
							var L = Ve(e),
								k = L == c || L == d;
							if (Ge(e)) return function(e, t) {
								if (t) return e.slice();
								var n = new e.constructor(e.length);
								return e.copy(n), n
							}(e, t);
							if (L == h || L == r || k && !p) {
								if ($(e)) return p ? e : {};
								if (O = function(e) {
										return "function" != typeof e.constructor || je(e) ? {} : Ke(t = oe(e)) ? ae(t) : {};
										var t
									}(k ? {} : e), !t) return function(e, t) {
									return Le(e, Fe(e), t)
								}(e, function(e, t) {
									return e && Le(t, We(t), e)
								}(O, e))
							} else {
								if (!M[L]) return p ? e : {};
								O = function(e, t, n, i) {
									var s, r = e.constructor;
									switch (t) {
										case S:
											return Me(e);
										case o:
										case a:
											return new r(+e);
										case E:
											return function(e, t) {
												var n = t ? Me(e.buffer) : e.buffer;
												return new e.constructor(n, e.byteOffset, e.byteLength)
											}(e, i);
										case y:
										case T:
										case C:
										case b:
										case A:
										case R:
										case I:
										case P:
										case D:
											return function(e, t) {
												var n = t ? Me(e.buffer) : e.buffer;
												return new e.constructor(n, e.byteOffset, e.length)
											}(e, i);
										case l:
											return function(e, t, n) {
												return B(t ? n(J(e), !0) : J(e), j, new e.constructor)
											}(e, i, n);
										case u:
										case g:
											return new r(e);
										case m:
											return function(e) {
												var t = new e.constructor(e.source, w.exec(e));
												return t.lastIndex = e.lastIndex, t
											}(e);
										case f:
											return function(e, t, n) {
												return B(t ? n(q(e), !0) : q(e), H, new e.constructor)
											}(e, i, n);
										case _:
											return s = e, Ae ? Object(Ae.call(s)) : {}
									}
								}(e, L, Ne, t)
							}
						}
						v || (v = new De);
						var x = v.get(e);
						if (x) return x;
						if (v.set(e, O), !N) var F = n ? function(e) {
							return function(e, t, n) {
								var i = t(e);
								return $e(e) ? i : function(e, t) {
									for (var n = -1, i = t.length, s = e.length; ++n < i;) e[s + n] = t[n];
									return e
								}(i, n(e))
							}(e, We, Fe)
						}(e) : We(e);
						return function(e, t) {
							for (var n = -1, i = e ? e.length : 0; ++n < i && !1 !== t(e[n], n););
						}(F || e, (function(s, r) {
							F && (s = e[r = s]), we(O, r, Ne(s, t, n, i, r, e, v))
						})), O
					}

					function Me(e) {
						var t = new e.constructor(e.byteLength);
						return new re(t).set(new re(e)), t
					}

					function Le(e, t, n, i) {
						n || (n = {});
						for (var s = -1, r = t.length; ++s < r;) {
							var o = t[s],
								a = i ? i(n[o], e[o], o, n, e) : void 0;
							we(n, o, void 0 === a ? e[o] : a)
						}
						return n
					}

					function ke(e, t) {
						var n, i, s = e.__data__;
						return ("string" == (i = typeof(n = t)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? s["string" == typeof t ? "string" : "hash"] : s.map
					}

					function xe(e, t) {
						var n = function(e, t) {
							return null == e ? void 0 : e[t]
						}(e, t);
						return function(e) {
							return !(!Ke(e) || (t = e, Q && Q in t)) && (qe(e) || $(e) ? ne : O).test(He(e));
							var t
						}(n) ? n : void 0
					}
					Re.prototype.clear = function() {
						this.__data__ = ve ? ve(null) : {}
					}, Re.prototype.delete = function(e) {
						return this.has(e) && delete this.__data__[e]
					}, Re.prototype.get = function(e) {
						var t = this.__data__;
						if (ve) {
							var n = t[e];
							return n === i ? void 0 : n
						}
						return ee.call(t, e) ? t[e] : void 0
					}, Re.prototype.has = function(e) {
						var t = this.__data__;
						return ve ? void 0 !== t[e] : ee.call(t, e)
					}, Re.prototype.set = function(e, t) {
						return this.__data__[e] = ve && void 0 === t ? i : t, this
					}, Ie.prototype.clear = function() {
						this.__data__ = []
					}, Ie.prototype.delete = function(e) {
						var t = this.__data__,
							n = Oe(t, e);
						return !(n < 0 || (n == t.length - 1 ? t.pop() : de.call(t, n, 1), 0))
					}, Ie.prototype.get = function(e) {
						var t = this.__data__,
							n = Oe(t, e);
						return n < 0 ? void 0 : t[n][1]
					}, Ie.prototype.has = function(e) {
						return Oe(this.__data__, e) > -1
					}, Ie.prototype.set = function(e, t) {
						var n = this.__data__,
							i = Oe(n, e);
						return i < 0 ? n.push([e, t]) : n[i][1] = t, this
					}, Pe.prototype.clear = function() {
						this.__data__ = {
							hash: new Re,
							map: new(me || Ie),
							string: new Re
						}
					}, Pe.prototype.delete = function(e) {
						return ke(this, e).delete(e)
					}, Pe.prototype.get = function(e) {
						return ke(this, e).get(e)
					}, Pe.prototype.has = function(e) {
						return ke(this, e).has(e)
					}, Pe.prototype.set = function(e, t) {
						return ke(this, e).set(e, t), this
					}, De.prototype.clear = function() {
						this.__data__ = new Ie
					}, De.prototype.delete = function(e) {
						return this.__data__.delete(e)
					}, De.prototype.get = function(e) {
						return this.__data__.get(e)
					}, De.prototype.has = function(e) {
						return this.__data__.has(e)
					}, De.prototype.set = function(e, t) {
						var n = this.__data__;
						if (n instanceof Ie) {
							var i = n.__data__;
							if (!me || i.length < 199) return i.push([e, t]), this;
							n = this.__data__ = new Pe(i)
						}
						return n.set(e, t), this
					};
					var Fe = le ? G(le, Object) : function() {
							return []
						},
						Ve = function(e) {
							return te.call(e)
						};

					function Ue(e, t) {
						return !!(t = null == t ? s : t) && ("number" == typeof e || N.test(e)) && e > -1 && e % 1 == 0 && e < t
					}

					function je(e) {
						var t = e && e.constructor;
						return e === ("function" == typeof t && t.prototype || z)
					}

					function He(e) {
						if (null != e) {
							try {
								return Z.call(e)
							} catch (e) {}
							try {
								return e + ""
							} catch (e) {}
						}
						return ""
					}

					function Be(e, t) {
						return e === t || e != e && t != t
					}(pe && Ve(new pe(new ArrayBuffer(1))) != E || me && Ve(new me) != l || fe && Ve(fe.resolve()) != p || ge && Ve(new ge) != f || _e && Ve(new _e) != v) && (Ve = function(e) {
						var t = te.call(e),
							n = t == h ? e.constructor : void 0,
							i = n ? He(n) : void 0;
						if (i) switch (i) {
							case Se:
								return E;
							case Ee:
								return l;
							case ye:
								return p;
							case Te:
								return f;
							case Ce:
								return v
						}
						return t
					});
					var $e = Array.isArray;

					function Je(e) {
						return null != e && function(e) {
							return "number" == typeof e && e > -1 && e % 1 == 0 && e <= s
						}(e.length) && !qe(e)
					}
					var Ge = ue || function() {
						return !1
					};

					function qe(e) {
						var t = Ke(e) ? te.call(e) : "";
						return t == c || t == d
					}

					function Ke(e) {
						var t = typeof e;
						return !!e && ("object" == t || "function" == t)
					}

					function We(e) {
						return Je(e) ? function(e, t) {
							var n = $e(e) || function(e) {
									return function(e) {
										return function(e) {
											return !!e && "object" == typeof e
										}(e) && Je(e)
									}(e) && ee.call(e, "callee") && (!ce.call(e, "callee") || te.call(e) == r)
								}(e) ? function(e, t) {
									for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
									return i
								}(e.length, String) : [],
								i = n.length,
								s = !!i;
							for (var o in e) !t && !ee.call(e, o) || s && ("length" == o || Ue(o, i)) || n.push(o);
							return n
						}(e) : function(e) {
							if (!je(e)) return he(e);
							var t = [];
							for (var n in Object(e)) ee.call(e, n) && "constructor" != n && t.push(n);
							return t
						}(e)
					}
					e.exports = function(e) {
						return Ne(e, !0, !0)
					}
				},
				9509: (e, t, n) => {
					var i = /^\s+|\s+$/g,
						s = /^[-+]0x[0-9a-f]+$/i,
						r = /^0b[01]+$/i,
						o = /^0o[0-7]+$/i,
						a = parseInt,
						c = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
						d = "object" == typeof self && self && self.Object === Object && self,
						l = c || d || Function("return this")(),
						u = Object.prototype.toString,
						h = Math.max,
						p = Math.min,
						m = function() {
							return l.Date.now()
						};

					function f(e) {
						var t = typeof e;
						return !!e && ("object" == t || "function" == t)
					}

					function g(e) {
						if ("number" == typeof e) return e;
						if (function(e) {
								return "symbol" == typeof e || function(e) {
									return !!e && "object" == typeof e
								}(e) && "[object Symbol]" == u.call(e)
							}(e)) return NaN;
						if (f(e)) {
							var t = "function" == typeof e.valueOf ? e.valueOf() : e;
							e = f(t) ? t + "" : t
						}
						if ("string" != typeof e) return 0 === e ? e : +e;
						e = e.replace(i, "");
						var n = r.test(e);
						return n || o.test(e) ? a(e.slice(2), n ? 2 : 8) : s.test(e) ? NaN : +e
					}
					e.exports = function(e, t, n) {
						var i, s, r, o, a, c, d = 0,
							l = !1,
							u = !1,
							_ = !0;
						if ("function" != typeof e) throw new TypeError("Expected a function");

						function v(t) {
							var n = i,
								r = s;
							return i = s = void 0, d = t, o = e.apply(r, n)
						}

						function S(e) {
							return d = e, a = setTimeout(y, t), l ? v(e) : o
						}

						function E(e) {
							var n = e - c;
							return void 0 === c || n >= t || n < 0 || u && e - d >= r
						}

						function y() {
							var e = m();
							if (E(e)) return T(e);
							a = setTimeout(y, function(e) {
								var n = t - (e - c);
								return u ? p(n, r - (e - d)) : n
							}(e))
						}

						function T(e) {
							return a = void 0, _ && i ? v(e) : (i = s = void 0, o)
						}

						function C() {
							var e = m(),
								n = E(e);
							if (i = arguments, s = this, c = e, n) {
								if (void 0 === a) return S(c);
								if (u) return a = setTimeout(y, t), v(c)
							}
							return void 0 === a && (a = setTimeout(y, t)), o
						}
						return t = g(t) || 0, f(n) && (l = !!n.leading, r = (u = "maxWait" in n) ? h(g(n.maxWait) || 0, t) : r, _ = "trailing" in n ? !!n.trailing : _), C.cancel = function() {
							void 0 !== a && clearTimeout(a), d = 0, i = c = s = a = void 0
						}, C.flush = function() {
							return void 0 === a ? o : T(m())
						}, C
					}
				},
				7047: (e, t, n) => {
					e = n.nmd(e);
					var i = "__lodash_hash_undefined__",
						s = 9007199254740991,
						r = "[object Arguments]",
						o = "[object Array]",
						a = "[object Boolean]",
						c = "[object Date]",
						d = "[object Error]",
						l = "[object Function]",
						u = "[object Map]",
						h = "[object Number]",
						p = "[object Object]",
						m = "[object Promise]",
						f = "[object RegExp]",
						g = "[object Set]",
						_ = "[object String]",
						v = "[object WeakMap]",
						S = "[object ArrayBuffer]",
						E = "[object DataView]",
						y = /^\[object .+?Constructor\]$/,
						T = /^(?:0|[1-9]\d*)$/,
						C = {};
					C["[object Float32Array]"] = C["[object Float64Array]"] = C["[object Int8Array]"] = C["[object Int16Array]"] = C["[object Int32Array]"] = C["[object Uint8Array]"] = C["[object Uint8ClampedArray]"] = C["[object Uint16Array]"] = C["[object Uint32Array]"] = !0, C[r] = C[o] = C[S] = C[a] = C[E] = C[c] = C[d] = C[l] = C[u] = C[h] = C[p] = C[f] = C[g] = C[_] = C[v] = !1;
					var b = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
						A = "object" == typeof self && self && self.Object === Object && self,
						R = b || A || Function("return this")(),
						I = t && !t.nodeType && t,
						P = I && e && !e.nodeType && e,
						D = P && P.exports === I,
						w = D && b.process,
						O = function() {
							try {
								return w && w.binding && w.binding("util")
							} catch (e) {}
						}(),
						N = O && O.isTypedArray;

					function M(e, t) {
						for (var n = -1, i = null == e ? 0 : e.length; ++n < i;)
							if (t(e[n], n, e)) return !0;
						return !1
					}

					function L(e) {
						var t = -1,
							n = Array(e.size);
						return e.forEach((function(e, i) {
							n[++t] = [i, e]
						})), n
					}

					function k(e) {
						var t = -1,
							n = Array(e.size);
						return e.forEach((function(e) {
							n[++t] = e
						})), n
					}
					var x, F, V, U = Array.prototype,
						j = Function.prototype,
						H = Object.prototype,
						B = R["__core-js_shared__"],
						$ = j.toString,
						J = H.hasOwnProperty,
						G = (x = /[^.]+$/.exec(B && B.keys && B.keys.IE_PROTO || "")) ? "Symbol(src)_1." + x : "",
						q = H.toString,
						K = RegExp("^" + $.call(J).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
						W = D ? R.Buffer : void 0,
						X = R.Symbol,
						z = R.Uint8Array,
						Y = H.propertyIsEnumerable,
						Q = U.splice,
						Z = X ? X.toStringTag : void 0,
						ee = Object.getOwnPropertySymbols,
						te = W ? W.isBuffer : void 0,
						ne = (F = Object.keys, V = Object, function(e) {
							return F(V(e))
						}),
						ie = Pe(R, "DataView"),
						se = Pe(R, "Map"),
						re = Pe(R, "Promise"),
						oe = Pe(R, "Set"),
						ae = Pe(R, "WeakMap"),
						ce = Pe(Object, "create"),
						de = Ne(ie),
						le = Ne(se),
						ue = Ne(re),
						he = Ne(oe),
						pe = Ne(ae),
						me = X ? X.prototype : void 0,
						fe = me ? me.valueOf : void 0;

					function ge(e) {
						var t = -1,
							n = null == e ? 0 : e.length;
						for (this.clear(); ++t < n;) {
							var i = e[t];
							this.set(i[0], i[1])
						}
					}

					function _e(e) {
						var t = -1,
							n = null == e ? 0 : e.length;
						for (this.clear(); ++t < n;) {
							var i = e[t];
							this.set(i[0], i[1])
						}
					}

					function ve(e) {
						var t = -1,
							n = null == e ? 0 : e.length;
						for (this.clear(); ++t < n;) {
							var i = e[t];
							this.set(i[0], i[1])
						}
					}

					function Se(e) {
						var t = -1,
							n = null == e ? 0 : e.length;
						for (this.__data__ = new ve; ++t < n;) this.add(e[t])
					}

					function Ee(e) {
						var t = this.__data__ = new _e(e);
						this.size = t.size
					}

					function ye(e, t) {
						for (var n = e.length; n--;)
							if (Me(e[n][0], t)) return n;
						return -1
					}

					function Te(e) {
						return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Z && Z in Object(e) ? function(e) {
							var t = J.call(e, Z),
								n = e[Z];
							try {
								e[Z] = void 0;
								var i = !0
							} catch (e) {}
							var s = q.call(e);
							return i && (t ? e[Z] = n : delete e[Z]), s
						}(e) : function(e) {
							return q.call(e)
						}(e)
					}

					function Ce(e) {
						return je(e) && Te(e) == r
					}

					function be(e, t, n, i, s) {
						return e === t || (null == e || null == t || !je(e) && !je(t) ? e != e && t != t : function(e, t, n, i, s, l) {
							var m = ke(e),
								v = ke(t),
								y = m ? o : we(e),
								T = v ? o : we(t),
								C = (y = y == r ? p : y) == p,
								b = (T = T == r ? p : T) == p,
								A = y == T;
							if (A && xe(e)) {
								if (!xe(t)) return !1;
								m = !0, C = !1
							}
							if (A && !C) return l || (l = new Ee), m || He(e) ? Ae(e, t, n, i, s, l) : function(e, t, n, i, s, r, o) {
								switch (n) {
									case E:
										if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
										e = e.buffer, t = t.buffer;
									case S:
										return !(e.byteLength != t.byteLength || !r(new z(e), new z(t)));
									case a:
									case c:
									case h:
										return Me(+e, +t);
									case d:
										return e.name == t.name && e.message == t.message;
									case f:
									case _:
										return e == t + "";
									case u:
										var l = L;
									case g:
										var p = 1 & i;
										if (l || (l = k), e.size != t.size && !p) return !1;
										var m = o.get(e);
										if (m) return m == t;
										i |= 2, o.set(e, t);
										var v = Ae(l(e), l(t), i, s, r, o);
										return o.delete(e), v;
									case "[object Symbol]":
										if (fe) return fe.call(e) == fe.call(t)
								}
								return !1
							}(e, t, y, n, i, s, l);
							if (!(1 & n)) {
								var R = C && J.call(e, "__wrapped__"),
									I = b && J.call(t, "__wrapped__");
								if (R || I) {
									var P = R ? e.value() : e,
										D = I ? t.value() : t;
									return l || (l = new Ee), s(P, D, n, i, l)
								}
							}
							return !!A && (l || (l = new Ee), function(e, t, n, i, s, r) {
								var o = 1 & n,
									a = Re(e),
									c = a.length;
								if (c != Re(t).length && !o) return !1;
								for (var d = c; d--;) {
									var l = a[d];
									if (!(o ? l in t : J.call(t, l))) return !1
								}
								var u = r.get(e);
								if (u && r.get(t)) return u == t;
								var h = !0;
								r.set(e, t), r.set(t, e);
								for (var p = o; ++d < c;) {
									var m = e[l = a[d]],
										f = t[l];
									if (i) var g = o ? i(f, m, l, t, e, r) : i(m, f, l, e, t, r);
									if (!(void 0 === g ? m === f || s(m, f, n, i, r) : g)) {
										h = !1;
										break
									}
									p || (p = "constructor" == l)
								}
								if (h && !p) {
									var _ = e.constructor,
										v = t.constructor;
									_ == v || !("constructor" in e) || !("constructor" in t) || "function" == typeof _ && _ instanceof _ && "function" == typeof v && v instanceof v || (h = !1)
								}
								return r.delete(e), r.delete(t), h
							}(e, t, n, i, s, l))
						}(e, t, n, i, be, s))
					}

					function Ae(e, t, n, i, s, r) {
						var o = 1 & n,
							a = e.length,
							c = t.length;
						if (a != c && !(o && c > a)) return !1;
						var d = r.get(e);
						if (d && r.get(t)) return d == t;
						var l = -1,
							u = !0,
							h = 2 & n ? new Se : void 0;
						for (r.set(e, t), r.set(t, e); ++l < a;) {
							var p = e[l],
								m = t[l];
							if (i) var f = o ? i(m, p, l, t, e, r) : i(p, m, l, e, t, r);
							if (void 0 !== f) {
								if (f) continue;
								u = !1;
								break
							}
							if (h) {
								if (!M(t, (function(e, t) {
										if (o = t, !h.has(o) && (p === e || s(p, e, n, i, r))) return h.push(t);
										var o
									}))) {
									u = !1;
									break
								}
							} else if (p !== m && !s(p, m, n, i, r)) {
								u = !1;
								break
							}
						}
						return r.delete(e), r.delete(t), u
					}

					function Re(e) {
						return function(e, t, n) {
							var i = t(e);
							return ke(e) ? i : function(e, t) {
								for (var n = -1, i = t.length, s = e.length; ++n < i;) e[s + n] = t[n];
								return e
							}(i, n(e))
						}(e, Be, De)
					}

					function Ie(e, t) {
						var n, i, s = e.__data__;
						return ("string" == (i = typeof(n = t)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? s["string" == typeof t ? "string" : "hash"] : s.map
					}

					function Pe(e, t) {
						var n = function(e, t) {
							return null == e ? void 0 : e[t]
						}(e, t);
						return function(e) {
							return !(!Ue(e) || function(e) {
								return !!G && G in e
							}(e)) && (Fe(e) ? K : y).test(Ne(e))
						}(n) ? n : void 0
					}
					ge.prototype.clear = function() {
						this.__data__ = ce ? ce(null) : {}, this.size = 0
					}, ge.prototype.delete = function(e) {
						var t = this.has(e) && delete this.__data__[e];
						return this.size -= t ? 1 : 0, t
					}, ge.prototype.get = function(e) {
						var t = this.__data__;
						if (ce) {
							var n = t[e];
							return n === i ? void 0 : n
						}
						return J.call(t, e) ? t[e] : void 0
					}, ge.prototype.has = function(e) {
						var t = this.__data__;
						return ce ? void 0 !== t[e] : J.call(t, e)
					}, ge.prototype.set = function(e, t) {
						var n = this.__data__;
						return this.size += this.has(e) ? 0 : 1, n[e] = ce && void 0 === t ? i : t, this
					}, _e.prototype.clear = function() {
						this.__data__ = [], this.size = 0
					}, _e.prototype.delete = function(e) {
						var t = this.__data__,
							n = ye(t, e);
						return !(n < 0 || (n == t.length - 1 ? t.pop() : Q.call(t, n, 1), --this.size, 0))
					}, _e.prototype.get = function(e) {
						var t = this.__data__,
							n = ye(t, e);
						return n < 0 ? void 0 : t[n][1]
					}, _e.prototype.has = function(e) {
						return ye(this.__data__, e) > -1
					}, _e.prototype.set = function(e, t) {
						var n = this.__data__,
							i = ye(n, e);
						return i < 0 ? (++this.size, n.push([e, t])) : n[i][1] = t, this
					}, ve.prototype.clear = function() {
						this.size = 0, this.__data__ = {
							hash: new ge,
							map: new(se || _e),
							string: new ge
						}
					}, ve.prototype.delete = function(e) {
						var t = Ie(this, e).delete(e);
						return this.size -= t ? 1 : 0, t
					}, ve.prototype.get = function(e) {
						return Ie(this, e).get(e)
					}, ve.prototype.has = function(e) {
						return Ie(this, e).has(e)
					}, ve.prototype.set = function(e, t) {
						var n = Ie(this, e),
							i = n.size;
						return n.set(e, t), this.size += n.size == i ? 0 : 1, this
					}, Se.prototype.add = Se.prototype.push = function(e) {
						return this.__data__.set(e, i), this
					}, Se.prototype.has = function(e) {
						return this.__data__.has(e)
					}, Ee.prototype.clear = function() {
						this.__data__ = new _e, this.size = 0
					}, Ee.prototype.delete = function(e) {
						var t = this.__data__,
							n = t.delete(e);
						return this.size = t.size, n
					}, Ee.prototype.get = function(e) {
						return this.__data__.get(e)
					}, Ee.prototype.has = function(e) {
						return this.__data__.has(e)
					}, Ee.prototype.set = function(e, t) {
						var n = this.__data__;
						if (n instanceof _e) {
							var i = n.__data__;
							if (!se || i.length < 199) return i.push([e, t]), this.size = ++n.size, this;
							n = this.__data__ = new ve(i)
						}
						return n.set(e, t), this.size = n.size, this
					};
					var De = ee ? function(e) {
							return null == e ? [] : (e = Object(e), function(t, n) {
								for (var i = -1, s = null == t ? 0 : t.length, r = 0, o = []; ++i < s;) {
									var a = t[i];
									c = a, Y.call(e, c) && (o[r++] = a)
								}
								var c;
								return o
							}(ee(e)))
						} : function() {
							return []
						},
						we = Te;

					function Oe(e, t) {
						return !!(t = null == t ? s : t) && ("number" == typeof e || T.test(e)) && e > -1 && e % 1 == 0 && e < t
					}

					function Ne(e) {
						if (null != e) {
							try {
								return $.call(e)
							} catch (e) {}
							try {
								return e + ""
							} catch (e) {}
						}
						return ""
					}

					function Me(e, t) {
						return e === t || e != e && t != t
					}(ie && we(new ie(new ArrayBuffer(1))) != E || se && we(new se) != u || re && we(re.resolve()) != m || oe && we(new oe) != g || ae && we(new ae) != v) && (we = function(e) {
						var t = Te(e),
							n = t == p ? e.constructor : void 0,
							i = n ? Ne(n) : "";
						if (i) switch (i) {
							case de:
								return E;
							case le:
								return u;
							case ue:
								return m;
							case he:
								return g;
							case pe:
								return v
						}
						return t
					});
					var Le = Ce(function() {
							return arguments
						}()) ? Ce : function(e) {
							return je(e) && J.call(e, "callee") && !Y.call(e, "callee")
						},
						ke = Array.isArray,
						xe = te || function() {
							return !1
						};

					function Fe(e) {
						if (!Ue(e)) return !1;
						var t = Te(e);
						return t == l || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t
					}

					function Ve(e) {
						return "number" == typeof e && e > -1 && e % 1 == 0 && e <= s
					}

					function Ue(e) {
						var t = typeof e;
						return null != e && ("object" == t || "function" == t)
					}

					function je(e) {
						return null != e && "object" == typeof e
					}
					var He = N ? function(e) {
						return function(t) {
							return e(t)
						}
					}(N) : function(e) {
						return je(e) && Ve(e.length) && !!C[Te(e)]
					};

					function Be(e) {
						return null != (t = e) && Ve(t.length) && !Fe(t) ? function(e, t) {
							var n = ke(e),
								i = !n && Le(e),
								s = !n && !i && xe(e),
								r = !n && !i && !s && He(e),
								o = n || i || s || r,
								a = o ? function(e, t) {
									for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
									return i
								}(e.length, String) : [],
								c = a.length;
							for (var d in e) !t && !J.call(e, d) || o && ("length" == d || s && ("offset" == d || "parent" == d) || r && ("buffer" == d || "byteLength" == d || "byteOffset" == d) || Oe(d, c)) || a.push(d);
							return a
						}(e) : function(e) {
							if (n = (t = e) && t.constructor, t !== ("function" == typeof n && n.prototype || H)) return ne(e);
							var t, n, i = [];
							for (var s in Object(e)) J.call(e, s) && "constructor" != s && i.push(s);
							return i
						}(e);
						var t
					}
					e.exports = function(e, t) {
						return be(e, t)
					}
				},
				5296: e => {
					var t = e.exports = {
						v: [{
							name: "version",
							reg: /^(\d*)$/
						}],
						o: [{
							name: "origin",
							reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
							names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
							format: "%s %s %d %s IP%d %s"
						}],
						s: [{
							name: "name"
						}],
						i: [{
							name: "description"
						}],
						u: [{
							name: "uri"
						}],
						e: [{
							name: "email"
						}],
						p: [{
							name: "phone"
						}],
						z: [{
							name: "timezones"
						}],
						r: [{
							name: "repeats"
						}],
						t: [{
							name: "timing",
							reg: /^(\d*) (\d*)/,
							names: ["start", "stop"],
							format: "%d %d"
						}],
						c: [{
							name: "connection",
							reg: /^IN IP(\d) (\S*)/,
							names: ["version", "ip"],
							format: "IN IP%d %s"
						}],
						b: [{
							push: "bandwidth",
							reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
							names: ["type", "limit"],
							format: "%s:%s"
						}],
						m: [{
							reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
							names: ["type", "port", "protocol", "payloads"],
							format: "%s %d %s %s"
						}],
						a: [{
							push: "rtp",
							reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
							names: ["payload", "codec", "rate", "encoding"],
							format: function(e) {
								return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
							}
						}, {
							push: "fmtp",
							reg: /^fmtp:(\d*) ([\S| ]*)/,
							names: ["payload", "config"],
							format: "fmtp:%d %s"
						}, {
							name: "control",
							reg: /^control:(.*)/,
							format: "control:%s"
						}, {
							name: "rtcp",
							reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
							names: ["port", "netType", "ipVer", "address"],
							format: function(e) {
								return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
							}
						}, {
							push: "rtcpFbTrrInt",
							reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
							names: ["payload", "value"],
							format: "rtcp-fb:%d trr-int %d"
						}, {
							push: "rtcpFb",
							reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
							names: ["payload", "type", "subtype"],
							format: function(e) {
								return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
							}
						}, {
							push: "ext",
							reg: /^extmap:(\d+)(?:\/(\w+))? (\S*)(?: (\S*))?/,
							names: ["value", "direction", "uri", "config"],
							format: function(e) {
								return "extmap:%d" + (e.direction ? "/%s" : "%v") + " %s" + (e.config ? " %s" : "")
							}
						}, {
							push: "crypto",
							reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
							names: ["id", "suite", "config", "sessionConfig"],
							format: function(e) {
								return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
							}
						}, {
							name: "setup",
							reg: /^setup:(\w*)/,
							format: "setup:%s"
						}, {
							name: "mid",
							reg: /^mid:([^\s]*)/,
							format: "mid:%s"
						}, {
							name: "msid",
							reg: /^msid:(.*)/,
							format: "msid:%s"
						}, {
							name: "ptime",
							reg: /^ptime:(\d*)/,
							format: "ptime:%d"
						}, {
							name: "maxptime",
							reg: /^maxptime:(\d*)/,
							format: "maxptime:%d"
						}, {
							name: "direction",
							reg: /^(sendrecv|recvonly|sendonly|inactive)/
						}, {
							name: "icelite",
							reg: /^(ice-lite)/
						}, {
							name: "iceUfrag",
							reg: /^ice-ufrag:(\S*)/,
							format: "ice-ufrag:%s"
						}, {
							name: "icePwd",
							reg: /^ice-pwd:(\S*)/,
							format: "ice-pwd:%s"
						}, {
							name: "fingerprint",
							reg: /^fingerprint:(\S*) (\S*)/,
							names: ["type", "hash"],
							format: "fingerprint:%s %s"
						}, {
							push: "candidates",
							reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
							names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
							format: function(e) {
								var t = "candidate:%s %d %s %d %s %d typ %s";
								return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), (t += null != e["network-id"] ? " network-id %d" : "%v") + (null != e["network-cost"] ? " network-cost %d" : "%v")
							}
						}, {
							name: "endOfCandidates",
							reg: /^(end-of-candidates)/
						}, {
							name: "remoteCandidates",
							reg: /^remote-candidates:(.*)/,
							format: "remote-candidates:%s"
						}, {
							name: "iceOptions",
							reg: /^ice-options:(\S*)/,
							format: "ice-options:%s"
						}, {
							push: "ssrcs",
							reg: /^ssrc:(\d*) ([\w_]*)(?::(.*))?/,
							names: ["id", "attribute", "value"],
							format: function(e) {
								var t = "ssrc:%d";
								return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
							}
						}, {
							push: "ssrcGroups",
							reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
							names: ["semantics", "ssrcs"],
							format: "ssrc-group:%s %s"
						}, {
							name: "msidSemantic",
							reg: /^msid-semantic:\s?(\w*) (\S*)/,
							names: ["semantic", "token"],
							format: "msid-semantic: %s %s"
						}, {
							push: "groups",
							reg: /^group:(\w*) (.*)/,
							names: ["type", "mids"],
							format: "group:%s %s"
						}, {
							name: "rtcpMux",
							reg: /^(rtcp-mux)/
						}, {
							name: "rtcpRsize",
							reg: /^(rtcp-rsize)/
						}, {
							name: "sctpmap",
							reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
							names: ["sctpmapNumber", "app", "maxMessageSize"],
							format: function(e) {
								return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
							}
						}, {
							name: "xGoogleFlag",
							reg: /^x-google-flag:([^\s]*)/,
							format: "x-google-flag:%s"
						}, {
							push: "rids",
							reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
							names: ["id", "direction", "params"],
							format: function(e) {
								return e.params ? "rid:%s %s %s" : "rid:%s %s"
							}
						}, {
							push: "imageattrs",
							reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
							names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
							format: function(e) {
								return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
							}
						}, {
							name: "simulcast",
							reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
							names: ["dir1", "list1", "dir2", "list2"],
							format: function(e) {
								return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
							}
						}, {
							name: "simulcast_03",
							reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
							names: ["value"],
							format: "simulcast: %s"
						}, {
							name: "framerate",
							reg: /^framerate:(\d+(?:$|\.\d+))/,
							format: "framerate:%s"
						}, {
							push: "invalid",
							names: ["value"]
						}]
					};
					Object.keys(t).forEach((function(e) {
						t[e].forEach((function(e) {
							e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
						}))
					}))
				},
				8310: (e, t, n) => {
					var i = n(1415),
						s = n(9159);
					t.write = s, t.parse = i.parse, t.parseFmtpConfig = i.parseFmtpConfig, t.parseParams = i.parseParams, t.parsePayloads = i.parsePayloads, t.parseRemoteCandidates = i.parseRemoteCandidates, t.parseImageAttributes = i.parseImageAttributes, t.parseSimulcastStreamList = i.parseSimulcastStreamList
				},
				1415: (e, t, n) => {
					var i = function(e) {
							return String(Number(e)) === e ? Number(e) : e
						},
						s = function(e, t, n) {
							var s = e.name && e.names;
							e.push && !t[e.push] ? t[e.push] = [] : s && !t[e.name] && (t[e.name] = {});
							var r = e.push ? {} : s ? t[e.name] : t;
							! function(e, t, n, s) {
								if (s && !n) t[s] = i(e[1]);
								else
									for (var r = 0; r < n.length; r += 1) null != e[r + 1] && (t[n[r]] = i(e[r + 1]))
							}(n.match(e.reg), r, e.names, e.name), e.push && t[e.push].push(r)
						},
						r = n(5296),
						o = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
					t.parse = function(e) {
						var t = {},
							n = [],
							i = t;
						return e.split(/(\r\n|\r|\n)/).filter(o).forEach((function(e) {
							var t = e[0],
								o = e.slice(2);
							"m" === t && (n.push({
								rtp: [],
								fmtp: []
							}), i = n[n.length - 1]);
							for (var a = 0; a < (r[t] || []).length; a += 1) {
								var c = r[t][a];
								if (c.reg.test(o)) return s(c, i, o)
							}
						})), t.media = n, t
					};
					var a = function(e, t) {
						var n = t.split(/=(.+)/, 2);
						return 2 === n.length && (e[n[0]] = i(n[1])), e
					};
					t.parseParams = function(e) {
						return e.split(/\;\s?/).reduce(a, {})
					}, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e) {
						return e.split(" ").map(Number)
					}, t.parseRemoteCandidates = function(e) {
						for (var t = [], n = e.split(" ").map(i), s = 0; s < n.length; s += 3) t.push({
							component: n[s],
							ip: n[s + 1],
							port: n[s + 2]
						});
						return t
					}, t.parseImageAttributes = function(e) {
						return e.split(" ").map((function(e) {
							return e.substring(1, e.length - 1).split(",").reduce(a, {})
						}))
					}, t.parseSimulcastStreamList = function(e) {
						return e.split(";").map((function(e) {
							return e.split(",").map((function(e) {
								var t, n = !1;
								return "~" !== e[0] ? t = i(e) : (t = i(e.substring(1, e.length)), n = !0), {
									scid: t,
									paused: n
								}
							}))
						}))
					}
				},
				9159: (e, t, n) => {
					var i = n(5296),
						s = /%[sdv%]/g,
						r = function(e) {
							var t = 1,
								n = arguments,
								i = n.length;
							return e.replace(s, (function(e) {
								if (t >= i) return e;
								var s = n[t];
								switch (t += 1, e) {
									case "%%":
										return "%";
									case "%s":
										return String(s);
									case "%d":
										return Number(s);
									case "%v":
										return ""
								}
							}))
						},
						o = function(e, t, n) {
							var i = [e + "=" + (t.format instanceof Function ? t.format(t.push ? n : n[t.name]) : t.format)];
							if (t.names)
								for (var s = 0; s < t.names.length; s += 1) {
									var o = t.names[s];
									t.name ? i.push(n[t.name][o]) : i.push(n[t.names[s]])
								} else i.push(n[t.name]);
							return r.apply(null, i)
						},
						a = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
						c = ["i", "c", "b", "a"];
					e.exports = function(e, t) {
						t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
							null == e.payloads && (e.payloads = "")
						}));
						var n = t.outerOrder || a,
							s = t.innerOrder || c,
							r = [];
						return n.forEach((function(t) {
							i[t].forEach((function(n) {
								n.name in e && null != e[n.name] ? r.push(o(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
									r.push(o(t, n, e))
								}))
							}))
						})), e.media.forEach((function(e) {
							r.push(o("m", i.m[0], e)), s.forEach((function(t) {
								i[t].forEach((function(n) {
									n.name in e && null != e[n.name] ? r.push(o(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
										r.push(o(t, n, e))
									}))
								}))
							}))
						})), r.join("\r\n") + "\r\n"
					}
				},
				5483: e => {
					"use strict";
					const t = {
						generateIdentifier: function() {
							return Math.random().toString(36).substr(2, 10)
						}
					};
					t.localCName = t.generateIdentifier(), t.splitLines = function(e) {
						return e.trim().split("\n").map((e => e.trim()))
					}, t.splitSections = function(e) {
						return e.split("\nm=").map(((e, t) => (t > 0 ? "m=" + e : e).trim() + "\r\n"))
					}, t.getDescription = function(e) {
						const n = t.splitSections(e);
						return n && n[0]
					}, t.getMediaSections = function(e) {
						const n = t.splitSections(e);
						return n.shift(), n
					}, t.matchPrefix = function(e, n) {
						return t.splitLines(e).filter((e => 0 === e.indexOf(n)))
					}, t.parseCandidate = function(e) {
						let t;
						t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" ");
						const n = {
							foundation: t[0],
							component: {
								1: "rtp",
								2: "rtcp"
							} [t[1]] || t[1],
							protocol: t[2].toLowerCase(),
							priority: parseInt(t[3], 10),
							ip: t[4],
							address: t[4],
							port: parseInt(t[5], 10),
							type: t[7]
						};
						for (let e = 8; e < t.length; e += 2) switch (t[e]) {
							case "raddr":
								n.relatedAddress = t[e + 1];
								break;
							case "rport":
								n.relatedPort = parseInt(t[e + 1], 10);
								break;
							case "tcptype":
								n.tcpType = t[e + 1];
								break;
							case "ufrag":
								n.ufrag = t[e + 1], n.usernameFragment = t[e + 1];
								break;
							default:
								void 0 === n[t[e]] && (n[t[e]] = t[e + 1])
						}
						return n
					}, t.writeCandidate = function(e) {
						const t = [];
						t.push(e.foundation);
						const n = e.component;
						"rtp" === n ? t.push(1) : "rtcp" === n ? t.push(2) : t.push(n), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port);
						const i = e.type;
						return t.push("typ"), t.push(i), "host" !== i && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ")
					}, t.parseIceOptions = function(e) {
						return e.substr(14).split(" ")
					}, t.parseRtpMap = function(e) {
						let t = e.substr(9).split(" ");
						const n = {
							payloadType: parseInt(t.shift(), 10)
						};
						return t = t[0].split("/"), n.name = t[0], n.clockRate = parseInt(t[1], 10), n.channels = 3 === t.length ? parseInt(t[2], 10) : 1, n.numChannels = n.channels, n
					}, t.writeRtpMap = function(e) {
						let t = e.payloadType;
						void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);
						const n = e.channels || e.numChannels || 1;
						return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== n ? "/" + n : "") + "\r\n"
					}, t.parseExtmap = function(e) {
						const t = e.substr(9).split(" ");
						return {
							id: parseInt(t[0], 10),
							direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv",
							uri: t[1]
						}
					}, t.writeExtmap = function(e) {
						return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n"
					}, t.parseFmtp = function(e) {
						const t = {};
						let n;
						const i = e.substr(e.indexOf(" ") + 1).split(";");
						for (let e = 0; e < i.length; e++) n = i[e].trim().split("="), t[n[0].trim()] = n[1];
						return t
					}, t.writeFmtp = function(e) {
						let t = "",
							n = e.payloadType;
						if (void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
							const i = [];
							Object.keys(e.parameters).forEach((t => {
								void 0 !== e.parameters[t] ? i.push(t + "=" + e.parameters[t]) : i.push(t)
							})), t += "a=fmtp:" + n + " " + i.join(";") + "\r\n"
						}
						return t
					}, t.parseRtcpFb = function(e) {
						const t = e.substr(e.indexOf(" ") + 1).split(" ");
						return {
							type: t.shift(),
							parameter: t.join(" ")
						}
					}, t.writeRtcpFb = function(e) {
						let t = "",
							n = e.payloadType;
						return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach((e => {
							t += "a=rtcp-fb:" + n + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n"
						})), t
					}, t.parseSsrcMedia = function(e) {
						const t = e.indexOf(" "),
							n = {
								ssrc: parseInt(e.substr(7, t - 7), 10)
							},
							i = e.indexOf(":", t);
						return i > -1 ? (n.attribute = e.substr(t + 1, i - t - 1), n.value = e.substr(i + 1)) : n.attribute = e.substr(t + 1), n
					}, t.parseSsrcGroup = function(e) {
						const t = e.substr(13).split(" ");
						return {
							semantics: t.shift(),
							ssrcs: t.map((e => parseInt(e, 10)))
						}
					}, t.getMid = function(e) {
						const n = t.matchPrefix(e, "a=mid:")[0];
						if (n) return n.substr(6)
					}, t.parseFingerprint = function(e) {
						const t = e.substr(14).split(" ");
						return {
							algorithm: t[0].toLowerCase(),
							value: t[1].toUpperCase()
						}
					}, t.getDtlsParameters = function(e, n) {
						return {
							role: "auto",
							fingerprints: t.matchPrefix(e + n, "a=fingerprint:").map(t.parseFingerprint)
						}
					}, t.writeDtlsParameters = function(e, t) {
						let n = "a=setup:" + t + "\r\n";
						return e.fingerprints.forEach((e => {
							n += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n"
						})), n
					}, t.parseCryptoLine = function(e) {
						const t = e.substr(9).split(" ");
						return {
							tag: parseInt(t[0], 10),
							cryptoSuite: t[1],
							keyParams: t[2],
							sessionParams: t.slice(3)
						}
					}, t.writeCryptoLine = function(e) {
						return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" == typeof e.keyParams ? t.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n"
					}, t.parseCryptoKeyParams = function(e) {
						if (0 !== e.indexOf("inline:")) return null;
						const t = e.substr(7).split("|");
						return {
							keyMethod: "inline",
							keySalt: t[0],
							lifeTime: t[1],
							mkiValue: t[2] ? t[2].split(":")[0] : void 0,
							mkiLength: t[2] ? t[2].split(":")[1] : void 0
						}
					}, t.writeCryptoKeyParams = function(e) {
						return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "")
					}, t.getCryptoParameters = function(e, n) {
						return t.matchPrefix(e + n, "a=crypto:").map(t.parseCryptoLine)
					}, t.getIceParameters = function(e, n) {
						const i = t.matchPrefix(e + n, "a=ice-ufrag:")[0],
							s = t.matchPrefix(e + n, "a=ice-pwd:")[0];
						return i && s ? {
							usernameFragment: i.substr(12),
							password: s.substr(10)
						} : null
					}, t.writeIceParameters = function(e) {
						let t = "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n";
						return e.iceLite && (t += "a=ice-lite\r\n"), t
					}, t.parseRtpParameters = function(e) {
						const n = {
								codecs: [],
								headerExtensions: [],
								fecMechanisms: [],
								rtcp: []
							},
							i = t.splitLines(e)[0].split(" ");
						for (let s = 3; s < i.length; s++) {
							const r = i[s],
								o = t.matchPrefix(e, "a=rtpmap:" + r + " ")[0];
							if (o) {
								const i = t.parseRtpMap(o),
									s = t.matchPrefix(e, "a=fmtp:" + r + " ");
								switch (i.parameters = s.length ? t.parseFmtp(s[0]) : {}, i.rtcpFeedback = t.matchPrefix(e, "a=rtcp-fb:" + r + " ").map(t.parseRtcpFb), n.codecs.push(i), i.name.toUpperCase()) {
									case "RED":
									case "ULPFEC":
										n.fecMechanisms.push(i.name.toUpperCase())
								}
							}
						}
						return t.matchPrefix(e, "a=extmap:").forEach((e => {
							n.headerExtensions.push(t.parseExtmap(e))
						})), n
					}, t.writeRtpDescription = function(e, n) {
						let i = "";
						i += "m=" + e + " ", i += n.codecs.length > 0 ? "9" : "0", i += " UDP/TLS/RTP/SAVPF ", i += n.codecs.map((e => void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType)).join(" ") + "\r\n", i += "c=IN IP4 0.0.0.0\r\n", i += "a=rtcp:9 IN IP4 0.0.0.0\r\n", n.codecs.forEach((e => {
							i += t.writeRtpMap(e), i += t.writeFmtp(e), i += t.writeRtcpFb(e)
						}));
						let s = 0;
						return n.codecs.forEach((e => {
							e.maxptime > s && (s = e.maxptime)
						})), s > 0 && (i += "a=maxptime:" + s + "\r\n"), n.headerExtensions && n.headerExtensions.forEach((e => {
							i += t.writeExtmap(e)
						})), i
					}, t.parseRtpEncodingParameters = function(e) {
						const n = [],
							i = t.parseRtpParameters(e),
							s = -1 !== i.fecMechanisms.indexOf("RED"),
							r = -1 !== i.fecMechanisms.indexOf("ULPFEC"),
							o = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "cname" === e.attribute)),
							a = o.length > 0 && o[0].ssrc;
						let c;
						const d = t.matchPrefix(e, "a=ssrc-group:FID").map((e => e.substr(17).split(" ").map((e => parseInt(e, 10)))));
						d.length > 0 && d[0].length > 1 && d[0][0] === a && (c = d[0][1]), i.codecs.forEach((e => {
							if ("RTX" === e.name.toUpperCase() && e.parameters.apt) {
								let t = {
									ssrc: a,
									codecPayloadType: parseInt(e.parameters.apt, 10)
								};
								a && c && (t.rtx = {
									ssrc: c
								}), n.push(t), s && (t = JSON.parse(JSON.stringify(t)), t.fec = {
									ssrc: a,
									mechanism: r ? "red+ulpfec" : "red"
								}, n.push(t))
							}
						})), 0 === n.length && a && n.push({
							ssrc: a
						});
						let l = t.matchPrefix(e, "b=");
						return l.length && (l = 0 === l[0].indexOf("b=TIAS:") ? parseInt(l[0].substr(7), 10) : 0 === l[0].indexOf("b=AS:") ? 1e3 * parseInt(l[0].substr(5), 10) * .95 - 16e3 : void 0, n.forEach((e => {
							e.maxBitrate = l
						}))), n
					}, t.parseRtcpParameters = function(e) {
						const n = {},
							i = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "cname" === e.attribute))[0];
						i && (n.cname = i.value, n.ssrc = i.ssrc);
						const s = t.matchPrefix(e, "a=rtcp-rsize");
						n.reducedSize = s.length > 0, n.compound = 0 === s.length;
						const r = t.matchPrefix(e, "a=rtcp-mux");
						return n.mux = r.length > 0, n
					}, t.writeRtcpParameters = function(e) {
						let t = "";
						return e.reducedSize && (t += "a=rtcp-rsize\r\n"), e.mux && (t += "a=rtcp-mux\r\n"), void 0 !== e.ssrc && e.cname && (t += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"), t
					}, t.parseMsid = function(e) {
						let n;
						const i = t.matchPrefix(e, "a=msid:");
						if (1 === i.length) return n = i[0].substr(7).split(" "), {
							stream: n[0],
							track: n[1]
						};
						const s = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "msid" === e.attribute));
						return s.length > 0 ? (n = s[0].value.split(" "), {
							stream: n[0],
							track: n[1]
						}) : void 0
					}, t.parseSctpDescription = function(e) {
						const n = t.parseMLine(e),
							i = t.matchPrefix(e, "a=max-message-size:");
						let s;
						i.length > 0 && (s = parseInt(i[0].substr(19), 10)), isNaN(s) && (s = 65536);
						const r = t.matchPrefix(e, "a=sctp-port:");
						if (r.length > 0) return {
							port: parseInt(r[0].substr(12), 10),
							protocol: n.fmt,
							maxMessageSize: s
						};
						const o = t.matchPrefix(e, "a=sctpmap:");
						if (o.length > 0) {
							const e = o[0].substr(10).split(" ");
							return {
								port: parseInt(e[0], 10),
								protocol: e[1],
								maxMessageSize: s
							}
						}
					}, t.writeSctpDescription = function(e, t) {
						let n = [];
						return n = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && n.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), n.join("")
					}, t.generateSessionId = function() {
						return Math.random().toString().substr(2, 21)
					}, t.writeSessionBoilerplate = function(e, n, i) {
						let s;
						const r = void 0 !== n ? n : 2;
						return s = e || t.generateSessionId(), "v=0\r\no=" + (i || "thisisadapterortc") + " " + s + " " + r + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"
					}, t.getDirection = function(e, n) {
						const i = t.splitLines(e);
						for (let e = 0; e < i.length; e++) switch (i[e]) {
							case "a=sendrecv":
							case "a=sendonly":
							case "a=recvonly":
							case "a=inactive":
								return i[e].substr(2)
						}
						return n ? t.getDirection(n) : "sendrecv"
					}, t.getKind = function(e) {
						return t.splitLines(e)[0].split(" ")[0].substr(2)
					}, t.isRejected = function(e) {
						return "0" === e.split(" ", 2)[1]
					}, t.parseMLine = function(e) {
						const n = t.splitLines(e)[0].substr(2).split(" ");
						return {
							kind: n[0],
							port: parseInt(n[1], 10),
							protocol: n[2],
							fmt: n.slice(3).join(" ")
						}
					}, t.parseOLine = function(e) {
						const n = t.matchPrefix(e, "o=")[0].substr(2).split(" ");
						return {
							username: n[0],
							sessionId: n[1],
							sessionVersion: parseInt(n[2], 10),
							netType: n[3],
							addressType: n[4],
							address: n[5]
						}
					}, t.isValidSDP = function(e) {
						if ("string" != typeof e || 0 === e.length) return !1;
						const n = t.splitLines(e);
						for (let e = 0; e < n.length; e++)
							if (n[e].length < 2 || "=" !== n[e].charAt(1)) return !1;
						return !0
					}, e.exports = t
				},
				6033: function(e, t, n) {
					e.exports = function() {
						"use strict";
						var e = void 0 !== n.g ? n.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};

						function t(e) {
							return t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
								return typeof e
							} : function(e) {
								return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
							}, t(e)
						}

						function i(e) {
							return function(e) {
								if (Array.isArray(e)) {
									for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
									return n
								}
							}(e) || function(e) {
								if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
							}(e) || function() {
								throw new TypeError("Invalid attempt to spread non-iterable instance")
							}()
						}
						var s = function(e, t) {
								var n = (65535 & e) + (65535 & t);
								return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
							},
							r = function(e) {
								if ("string" != typeof e) throw new Error("str2binl was passed a non-string");
								for (var t = [], n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << n % 32;
								return t
							},
							o = function(e, t, n, i, r, o) {
								return s((a = s(s(t, e), s(i, o))) << (c = r) | a >>> 32 - c, n);
								var a, c
							},
							a = function(e, t, n, i, s, r, a) {
								return o(t & n | ~t & i, e, t, s, r, a)
							},
							c = function(e, t, n, i, s, r, a) {
								return o(t & i | n & ~i, e, t, s, r, a)
							},
							d = function(e, t, n, i, s, r, a) {
								return o(t ^ n ^ i, e, t, s, r, a)
							},
							l = function(e, t, n, i, s, r, a) {
								return o(n ^ (t | ~i), e, t, s, r, a)
							},
							u = function(e, t) {
								e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
								for (var n, i, r, o, u = 1732584193, h = -271733879, p = -1732584194, m = 271733878, f = 0; f < e.length; f += 16) n = u, i = h, r = p, o = m, u = a(u, h, p, m, e[f + 0], 7, -680876936), m = a(m, u, h, p, e[f + 1], 12, -389564586), p = a(p, m, u, h, e[f + 2], 17, 606105819), h = a(h, p, m, u, e[f + 3], 22, -1044525330), u = a(u, h, p, m, e[f + 4], 7, -176418897), m = a(m, u, h, p, e[f + 5], 12, 1200080426), p = a(p, m, u, h, e[f + 6], 17, -1473231341), h = a(h, p, m, u, e[f + 7], 22, -45705983), u = a(u, h, p, m, e[f + 8], 7, 1770035416), m = a(m, u, h, p, e[f + 9], 12, -1958414417), p = a(p, m, u, h, e[f + 10], 17, -42063), h = a(h, p, m, u, e[f + 11], 22, -1990404162), u = a(u, h, p, m, e[f + 12], 7, 1804603682), m = a(m, u, h, p, e[f + 13], 12, -40341101), p = a(p, m, u, h, e[f + 14], 17, -1502002290), h = a(h, p, m, u, e[f + 15], 22, 1236535329), u = c(u, h, p, m, e[f + 1], 5, -165796510), m = c(m, u, h, p, e[f + 6], 9, -1069501632), p = c(p, m, u, h, e[f + 11], 14, 643717713), h = c(h, p, m, u, e[f + 0], 20, -373897302), u = c(u, h, p, m, e[f + 5], 5, -701558691), m = c(m, u, h, p, e[f + 10], 9, 38016083), p = c(p, m, u, h, e[f + 15], 14, -660478335), h = c(h, p, m, u, e[f + 4], 20, -405537848), u = c(u, h, p, m, e[f + 9], 5, 568446438), m = c(m, u, h, p, e[f + 14], 9, -1019803690), p = c(p, m, u, h, e[f + 3], 14, -187363961), h = c(h, p, m, u, e[f + 8], 20, 1163531501), u = c(u, h, p, m, e[f + 13], 5, -1444681467), m = c(m, u, h, p, e[f + 2], 9, -51403784), p = c(p, m, u, h, e[f + 7], 14, 1735328473), h = c(h, p, m, u, e[f + 12], 20, -1926607734), u = d(u, h, p, m, e[f + 5], 4, -378558), m = d(m, u, h, p, e[f + 8], 11, -2022574463), p = d(p, m, u, h, e[f + 11], 16, 1839030562), h = d(h, p, m, u, e[f + 14], 23, -35309556), u = d(u, h, p, m, e[f + 1], 4, -1530992060), m = d(m, u, h, p, e[f + 4], 11, 1272893353), p = d(p, m, u, h, e[f + 7], 16, -155497632), h = d(h, p, m, u, e[f + 10], 23, -1094730640), u = d(u, h, p, m, e[f + 13], 4, 681279174), m = d(m, u, h, p, e[f + 0], 11, -358537222), p = d(p, m, u, h, e[f + 3], 16, -722521979), h = d(h, p, m, u, e[f + 6], 23, 76029189), u = d(u, h, p, m, e[f + 9], 4, -640364487), m = d(m, u, h, p, e[f + 12], 11, -421815835), p = d(p, m, u, h, e[f + 15], 16, 530742520), h = d(h, p, m, u, e[f + 2], 23, -995338651), u = l(u, h, p, m, e[f + 0], 6, -198630844), m = l(m, u, h, p, e[f + 7], 10, 1126891415), p = l(p, m, u, h, e[f + 14], 15, -1416354905), h = l(h, p, m, u, e[f + 5], 21, -57434055), u = l(u, h, p, m, e[f + 12], 6, 1700485571), m = l(m, u, h, p, e[f + 3], 10, -1894986606), p = l(p, m, u, h, e[f + 10], 15, -1051523), h = l(h, p, m, u, e[f + 1], 21, -2054922799), u = l(u, h, p, m, e[f + 8], 6, 1873313359), m = l(m, u, h, p, e[f + 15], 10, -30611744), p = l(p, m, u, h, e[f + 6], 15, -1560198380), h = l(h, p, m, u, e[f + 13], 21, 1309151649), u = l(u, h, p, m, e[f + 4], 6, -145523070), m = l(m, u, h, p, e[f + 11], 10, -1120210379), p = l(p, m, u, h, e[f + 2], 15, 718787259), h = l(h, p, m, u, e[f + 9], 21, -343485551), u = s(u, n), h = s(h, i), p = s(p, r), m = s(m, o);
								return [u, h, p, m]
							},
							h = {
								hexdigest: function(e) {
									return function(e) {
										for (var t = "0123456789abcdef", n = "", i = 0; i < 4 * e.length; i++) n += t.charAt(e[i >> 2] >> i % 4 * 8 + 4 & 15) + t.charAt(e[i >> 2] >> i % 4 * 8 & 15);
										return n
									}(u(r(e), 8 * e.length))
								},
								hash: function(e) {
									return function(e) {
										for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> n % 32 & 255);
										return t
									}(u(r(e), 8 * e.length))
								}
							};

						function p(e, t) {
							e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;
							var n, i, s, r, o, a, c, d, l = new Array(80),
								u = 1732584193,
								h = -271733879,
								p = -1732584194,
								g = 271733878,
								S = -1009589776;
							for (n = 0; n < e.length; n += 16) {
								for (r = u, o = h, a = p, c = g, d = S, i = 0; i < 80; i++) l[i] = i < 16 ? e[n + i] : v(l[i - 3] ^ l[i - 8] ^ l[i - 14] ^ l[i - 16], 1), s = _(_(v(u, 5), m(i, h, p, g)), _(_(S, l[i]), f(i))), S = g, g = p, p = v(h, 30), h = u, u = s;
								u = _(u, r), h = _(h, o), p = _(p, a), g = _(g, c), S = _(S, d)
							}
							return [u, h, p, g, S]
						}

						function m(e, t, n, i) {
							return e < 20 ? t & n | ~t & i : e < 40 ? t ^ n ^ i : e < 60 ? t & n | t & i | n & i : t ^ n ^ i
						}

						function f(e) {
							return e < 20 ? 1518500249 : e < 40 ? 1859775393 : e < 60 ? -1894007588 : -899497514
						}

						function g(e, t) {
							var n = S(e);
							n.length > 16 && (n = p(n, 8 * e.length));
							for (var i = new Array(16), s = new Array(16), r = 0; r < 16; r++) i[r] = 909522486 ^ n[r], s[r] = 1549556828 ^ n[r];
							var o = p(i.concat(S(t)), 512 + 8 * t.length);
							return p(s.concat(o), 672)
						}

						function _(e, t) {
							var n = (65535 & e) + (65535 & t);
							return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
						}

						function v(e, t) {
							return e << t | e >>> 32 - t
						}

						function S(e) {
							for (var t = [], n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << 24 - n % 32;
							return t
						}

						function E(e) {
							for (var t, n, i = "", s = 0; s < 4 * e.length; s += 3)
								for (t = (e[s >> 2] >> 8 * (3 - s % 4) & 255) << 16 | (e[s + 1 >> 2] >> 8 * (3 - (s + 1) % 4) & 255) << 8 | e[s + 2 >> 2] >> 8 * (3 - (s + 2) % 4) & 255, n = 0; n < 4; n++) 8 * s + 6 * n > 32 * e.length ? i += "=" : i += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(t >> 6 * (3 - n) & 63);
							return i
						}

						function y(e) {
							for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> 24 - n % 32 & 255);
							return t
						}
						var T = {
								b64_hmac_sha1: function(e, t) {
									return E(g(e, t))
								},
								b64_sha1: function(e) {
									return E(p(S(e), 8 * e.length))
								},
								binb2str: y,
								core_hmac_sha1: g,
								str_hmac_sha1: function(e, t) {
									return y(g(e, t))
								},
								str_sha1: function(e) {
									return y(p(S(e), 8 * e.length))
								}
							},
							C = function(e) {
								var t, n, i = "",
									s = e.length;
								for (t = 0; t < s; t++)(n = e.charCodeAt(t)) >= 0 && n <= 127 ? i += e.charAt(t) : n > 2047 ? (i += String.fromCharCode(224 | n >> 12 & 15), i += String.fromCharCode(128 | n >> 6 & 63), i += String.fromCharCode(128 | n >> 0 & 63)) : (i += String.fromCharCode(192 | n >> 6 & 31), i += String.fromCharCode(128 | n >> 0 & 63));
								return i
							},
							b = function(e) {
								for (var n in e = e || {})
									if (Object.prototype.hasOwnProperty.call(e, n)) {
										var i = "",
											s = "",
											r = "",
											o = e[n],
											a = "object" === t(o),
											c = escape(unescape(a ? o.value : o));
										a && (i = o.expires ? ";expires=" + o.expires : "", s = o.domain ? ";domain=" + o.domain : "", r = o.path ? ";path=" + o.path : ""), document.cookie = n + "=" + c + i + s + r
									}
							};

						function A(e, t) {
							return new P.Builder(e, t)
						}

						function R(e) {
							return new P.Builder("iq", e)
						}

						function I(e) {
							return new P.Builder("presence", e)
						}
						var P = {
							VERSION: "@VERSION@",
							NS: {
								HTTPBIND: "http://jabber.org/protocol/httpbind",
								BOSH: "urn:xmpp:xbosh",
								CLIENT: "jabber:client",
								AUTH: "jabber:iq:auth",
								ROSTER: "jabber:iq:roster",
								PROFILE: "jabber:iq:profile",
								DISCO_INFO: "http://jabber.org/protocol/disco#info",
								DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
								MUC: "http://jabber.org/protocol/muc",
								SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
								STREAM: "http://etherx.jabber.org/streams",
								FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
								BIND: "urn:ietf:params:xml:ns:xmpp-bind",
								SESSION: "urn:ietf:params:xml:ns:xmpp-session",
								VERSION: "jabber:iq:version",
								STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
								XHTML_IM: "http://jabber.org/protocol/xhtml-im",
								XHTML: "http://www.w3.org/1999/xhtml"
							},
							XHTML: {
								tags: ["a", "blockquote", "br", "cite", "em", "img", "li", "ol", "p", "span", "strong", "ul", "body"],
								attributes: {
									a: ["href"],
									blockquote: ["style"],
									br: [],
									cite: ["style"],
									em: [],
									img: ["src", "alt", "style", "height", "width"],
									li: ["style"],
									ol: ["style"],
									p: ["style"],
									span: ["style"],
									strong: [],
									ul: ["style"],
									body: []
								},
								css: ["background-color", "color", "font-family", "font-size", "font-style", "font-weight", "margin-left", "margin-right", "text-align", "text-decoration"],
								validTag: function(e) {
									for (var t = 0; t < P.XHTML.tags.length; t++)
										if (e === P.XHTML.tags[t]) return !0;
									return !1
								},
								validAttribute: function(e, t) {
									if (void 0 !== P.XHTML.attributes[e] && P.XHTML.attributes[e].length > 0)
										for (var n = 0; n < P.XHTML.attributes[e].length; n++)
											if (t === P.XHTML.attributes[e][n]) return !0;
									return !1
								},
								validCSS: function(e) {
									for (var t = 0; t < P.XHTML.css.length; t++)
										if (e === P.XHTML.css[t]) return !0;
									return !1
								}
							},
							Status: {
								ERROR: 0,
								CONNECTING: 1,
								CONNFAIL: 2,
								AUTHENTICATING: 3,
								AUTHFAIL: 4,
								CONNECTED: 5,
								DISCONNECTED: 6,
								DISCONNECTING: 7,
								ATTACHED: 8,
								REDIRECT: 9,
								CONNTIMEOUT: 10,
								BINDREQUIRED: 11
							},
							ErrorCondition: {
								BAD_FORMAT: "bad-format",
								CONFLICT: "conflict",
								MISSING_JID_NODE: "x-strophe-bad-non-anon-jid",
								NO_AUTH_MECH: "no-auth-mech",
								UNKNOWN_REASON: "unknown"
							},
							LogLevel: {
								DEBUG: 0,
								INFO: 1,
								WARN: 2,
								ERROR: 3,
								FATAL: 4
							},
							ElementType: {
								NORMAL: 1,
								TEXT: 3,
								CDATA: 4,
								FRAGMENT: 11
							},
							TIMEOUT: 1.1,
							SECONDARY_TIMEOUT: .1,
							addNamespace: function(e, t) {
								P.NS[e] = t
							},
							forEachChild: function(e, t, n) {
								for (var i = 0; i < e.childNodes.length; i++) {
									var s = e.childNodes[i];
									s.nodeType !== P.ElementType.NORMAL || t && !this.isTagEqual(s, t) || n(s)
								}
							},
							isTagEqual: function(e, t) {
								return e.tagName === t
							},
							_xmlGenerator: null,
							_makeGenerator: function() {
								var e;
								return void 0 === document.implementation.createDocument || document.implementation.createDocument && document.documentMode && document.documentMode < 10 ? (e = this._getIEXmlDom()).appendChild(e.createElement("strophe")) : e = document.implementation.createDocument("jabber:client", "strophe", null), e
							},
							xmlGenerator: function() {
								return P._xmlGenerator || (P._xmlGenerator = P._makeGenerator()), P._xmlGenerator
							},
							_getIEXmlDom: function() {
								for (var e = null, t = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"], n = 0; n < t.length && null === e; n++) try {
									e = new ActiveXObject(t[n])
								} catch (t) {
									e = null
								}
								return e
							},
							xmlElement: function(e) {
								if (!e) return null;
								for (var n = P.xmlGenerator().createElement(e), i = 1; i < arguments.length; i++) {
									var s = arguments[i];
									if (s)
										if ("string" == typeof s || "number" == typeof s) n.appendChild(P.xmlTextNode(s));
										else if ("object" === t(s) && "function" == typeof s.sort)
										for (var r = 0; r < s.length; r++) {
											var o = s[r];
											"object" === t(o) && "function" == typeof o.sort && void 0 !== o[1] && null !== o[1] && n.setAttribute(o[0], o[1])
										} else if ("object" === t(s))
											for (var a in s) Object.prototype.hasOwnProperty.call(s, a) && void 0 !== s[a] && null !== s[a] && n.setAttribute(a, s[a])
								}
								return n
							},
							xmlescape: function(e) {
								return (e = (e = (e = (e = e.replace(/\&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/'/g, "&apos;")).replace(/"/g, "&quot;")
							},
							xmlunescape: function(e) {
								return (e = (e = (e = (e = e.replace(/\&amp;/g, "&")).replace(/&lt;/g, "<")).replace(/&gt;/g, ">")).replace(/&apos;/g, "'")).replace(/&quot;/g, '"')
							},
							xmlTextNode: function(e) {
								return P.xmlGenerator().createTextNode(e)
							},
							xmlHtmlNode: function(e) {
								var t;
								return DOMParser ? t = (new DOMParser).parseFromString(e, "text/xml") : ((t = new ActiveXObject("Microsoft.XMLDOM")).async = "false", t.loadXML(e)), t
							},
							getText: function(e) {
								if (!e) return null;
								var t = "";
								0 === e.childNodes.length && e.nodeType === P.ElementType.TEXT && (t += e.nodeValue);
								for (var n = 0; n < e.childNodes.length; n++) e.childNodes[n].nodeType === P.ElementType.TEXT && (t += e.childNodes[n].nodeValue);
								return P.xmlescape(t)
							},
							copyElement: function(e) {
								var t;
								if (e.nodeType === P.ElementType.NORMAL) {
									t = P.xmlElement(e.tagName);
									for (var n = 0; n < e.attributes.length; n++) t.setAttribute(e.attributes[n].nodeName, e.attributes[n].value);
									for (var i = 0; i < e.childNodes.length; i++) t.appendChild(P.copyElement(e.childNodes[i]))
								} else e.nodeType === P.ElementType.TEXT && (t = P.xmlGenerator().createTextNode(e.nodeValue));
								return t
							},
							createHtml: function(e) {
								var n;
								if (e.nodeType === P.ElementType.NORMAL) {
									var i = e.nodeName.toLowerCase();
									if (P.XHTML.validTag(i)) try {
										n = P.xmlElement(i);
										for (var s = 0; s < P.XHTML.attributes[i].length; s++) {
											var r = P.XHTML.attributes[i][s],
												o = e.getAttribute(r);
											if (null != o && "" !== o && !1 !== o && 0 !== o)
												if ("style" === r && "object" === t(o) && void 0 !== o.cssText && (o = o.cssText), "style" === r) {
													for (var a = [], c = o.split(";"), d = 0; d < c.length; d++) {
														var l = c[d].split(":"),
															u = l[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
														if (P.XHTML.validCSS(u)) {
															var h = l[1].replace(/^\s*/, "").replace(/\s*$/, "");
															a.push(u + ": " + h)
														}
													}
													a.length > 0 && (o = a.join("; "), n.setAttribute(r, o))
												} else n.setAttribute(r, o)
										}
										for (var p = 0; p < e.childNodes.length; p++) n.appendChild(P.createHtml(e.childNodes[p]))
									} catch (e) {
										n = P.xmlTextNode("")
									} else {
										n = P.xmlGenerator().createDocumentFragment();
										for (var m = 0; m < e.childNodes.length; m++) n.appendChild(P.createHtml(e.childNodes[m]))
									}
								} else if (e.nodeType === P.ElementType.FRAGMENT) {
									n = P.xmlGenerator().createDocumentFragment();
									for (var f = 0; f < e.childNodes.length; f++) n.appendChild(P.createHtml(e.childNodes[f]))
								} else e.nodeType === P.ElementType.TEXT && (n = P.xmlTextNode(e.nodeValue));
								return n
							},
							escapeNode: function(e) {
								return "string" != typeof e ? e : e.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40")
							},
							unescapeNode: function(e) {
								return "string" != typeof e ? e : e.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\")
							},
							getNodeFromJid: function(e) {
								return e.indexOf("@") < 0 ? null : e.split("@")[0]
							},
							getDomainFromJid: function(e) {
								var t = P.getBareJidFromJid(e);
								if (t.indexOf("@") < 0) return t;
								var n = t.split("@");
								return n.splice(0, 1), n.join("@")
							},
							getResourceFromJid: function(e) {
								if (!e) return null;
								var t = e.split("/");
								return t.length < 2 ? null : (t.splice(0, 1), t.join("/"))
							},
							getBareJidFromJid: function(e) {
								return e ? e.split("/")[0] : null
							},
							_handleError: function(e) {
								void 0 !== e.stack && P.fatal(e.stack), e.sourceURL ? P.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message) : e.fileName ? P.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message) : P.fatal("error: " + e.message)
							},
							log: function(e, n) {
								e === this.LogLevel.FATAL && "object" === t(window.console) && "function" == typeof window.console.error && window.console.error(n)
							},
							debug: function(e) {
								this.log(this.LogLevel.DEBUG, e)
							},
							info: function(e) {
								this.log(this.LogLevel.INFO, e)
							},
							warn: function(e) {
								this.log(this.LogLevel.WARN, e)
							},
							error: function(e) {
								this.log(this.LogLevel.ERROR, e)
							},
							fatal: function(e) {
								this.log(this.LogLevel.FATAL, e)
							},
							serialize: function(e) {
								if (!e) return null;
								"function" == typeof e.tree && (e = e.tree());
								var t = i(Array(e.attributes.length).keys()).map((function(t) {
									return e.attributes[t].nodeName
								}));
								t.sort();
								var n = t.reduce((function(t, n) {
									return "".concat(t, " ").concat(n, '="').concat(P.xmlescape(e.attributes.getNamedItem(n).value), '"')
								}), "<".concat(e.nodeName));
								if (e.childNodes.length > 0) {
									n += ">";
									for (var s = 0; s < e.childNodes.length; s++) {
										var r = e.childNodes[s];
										switch (r.nodeType) {
											case P.ElementType.NORMAL:
												n += P.serialize(r);
												break;
											case P.ElementType.TEXT:
												n += P.xmlescape(r.nodeValue);
												break;
											case P.ElementType.CDATA:
												n += "<![CDATA[" + r.nodeValue + "]]>"
										}
									}
									n += "</" + e.nodeName + ">"
								} else n += "/>";
								return n
							},
							_requestId: 0,
							_connectionPlugins: {},
							addConnectionPlugin: function(e, t) {
								P._connectionPlugins[e] = t
							},
							Builder: function(e, t) {
								"presence" !== e && "message" !== e && "iq" !== e || (t && !t.xmlns ? t.xmlns = P.NS.CLIENT : t || (t = {
									xmlns: P.NS.CLIENT
								})), this.nodeTree = P.xmlElement(e, t), this.node = this.nodeTree
							}
						};
						P.Builder.prototype = {
							tree: function() {
								return this.nodeTree
							},
							toString: function() {
								return P.serialize(this.nodeTree)
							},
							up: function() {
								return this.node = this.node.parentNode, this
							},
							root: function() {
								return this.node = this.nodeTree, this
							},
							attrs: function(e) {
								for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (void 0 === e[t] ? this.node.removeAttribute(t) : this.node.setAttribute(t, e[t]));
								return this
							},
							c: function(e, t, n) {
								var i = P.xmlElement(e, t, n);
								return this.node.appendChild(i), "string" != typeof n && "number" != typeof n && (this.node = i), this
							},
							cnode: function(e) {
								var t, n = P.xmlGenerator();
								try {
									t = void 0 !== n.importNode
								} catch (e) {
									t = !1
								}
								var i = t ? n.importNode(e, !0) : P.copyElement(e);
								return this.node.appendChild(i), this.node = i, this
							},
							t: function(e) {
								var t = P.xmlTextNode(e);
								return this.node.appendChild(t), this
							},
							h: function(e) {
								var t = document.createElement("body");
								t.innerHTML = e;
								for (var n = P.createHtml(t); n.childNodes.length > 0;) this.node.appendChild(n.childNodes[0]);
								return this
							}
						}, P.Handler = function(e, t, n, i, s, r, o) {
							this.handler = e, this.ns = t, this.name = n, this.type = i, this.id = s, this.options = o || {
								matchBareFromJid: !1,
								ignoreNamespaceFragment: !1
							}, this.options.matchBare && (P.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.'), this.options.matchBareFromJid = this.options.matchBare, delete this.options.matchBare), this.options.matchBareFromJid ? this.from = r ? P.getBareJidFromJid(r) : null : this.from = r, this.user = !0
						}, P.Handler.prototype = {
							getNamespace: function(e) {
								var t = e.getAttribute("xmlns");
								return t && this.options.ignoreNamespaceFragment && (t = t.split("#")[0]), t
							},
							namespaceMatch: function(e) {
								var t = this,
									n = !1;
								return !this.ns || (P.forEachChild(e, null, (function(e) {
									t.getNamespace(e) === t.ns && (n = !0)
								})), n || this.getNamespace(e) === this.ns)
							},
							isMatch: function(e) {
								var t = e.getAttribute("from");
								this.options.matchBareFromJid && (t = P.getBareJidFromJid(t));
								var n = e.getAttribute("type");
								return !(!this.namespaceMatch(e) || this.name && !P.isTagEqual(e, this.name) || this.type && (Array.isArray(this.type) ? -1 === this.type.indexOf(n) : n !== this.type) || this.id && e.getAttribute("id") !== this.id || this.from && t !== this.from)
							},
							run: function(e) {
								var t = null;
								try {
									t = this.handler(e)
								} catch (e) {
									throw P._handleError(e), e
								}
								return t
							},
							toString: function() {
								return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}"
							}
						}, P.TimedHandler = function(e, t) {
							this.period = e, this.handler = t, this.lastCalled = (new Date).getTime(), this.user = !0
						}, P.TimedHandler.prototype = {
							run: function() {
								return this.lastCalled = (new Date).getTime(), this.handler()
							},
							reset: function() {
								this.lastCalled = (new Date).getTime()
							},
							toString: function() {
								return "{TimedHandler: " + this.handler + "(" + this.period + ")}"
							}
						}, P.Connection = function(e, t) {
							var n = this;
							this.service = e, this.options = t || {};
							var i = this.options.protocol || "";
							for (var s in 0 === e.indexOf("ws:") || 0 === e.indexOf("wss:") || 0 === i.indexOf("ws") ? this._proto = new P.Websocket(this) : this._proto = new P.Bosh(this), this.jid = "", this.domain = null, this.features = null, this._sasl_data = {}, this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.protocolErrorHandlers = {
									HTTP: {},
									websocket: {}
								}, this._idleTimeout = null, this._disconnectTimeout = null, this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.do_authentication = !0, this.paused = !1, this.restored = !1, this._data = [], this._uniqueId = 0, this._sasl_success_handler = null, this._sasl_failure_handler = null, this._sasl_challenge_handler = null, this.maxRetries = 5, this._idleTimeout = setTimeout((function() {
									return n._onIdle()
								}), 100), b(this.options.cookies), this.registerSASLMechanisms(this.options.mechanisms), P._connectionPlugins)
								if (Object.prototype.hasOwnProperty.call(P._connectionPlugins, s)) {
									var r = function() {};
									r.prototype = P._connectionPlugins[s], this[s] = new r, this[s].init(this)
								}
						}, P.Connection.prototype = {
							reset: function() {
								this._proto._reset(), this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.restored = !1, this._data = [], this._requests = [], this._uniqueId = 0
							},
							pause: function() {
								this.paused = !0
							},
							resume: function() {
								this.paused = !1
							},
							getUniqueId: function(e) {
								var t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
									var t = 16 * Math.random() | 0;
									return ("x" === e ? t : 3 & t | 8).toString(16)
								}));
								return "string" == typeof e || "number" == typeof e ? t + ":" + e : t + ""
							},
							addProtocolErrorHandler: function(e, t, n) {
								this.protocolErrorHandlers[e][t] = n
							},
							connect: function(e, t, n, i, s, r, o) {
								this.jid = e, this.authzid = P.getBareJidFromJid(this.jid), this.authcid = o || P.getNodeFromJid(this.jid), this.pass = t, this.servtype = "xmpp", this.connect_callback = n, this.disconnecting = !1, this.connected = !1, this.authenticated = !1, this.restored = !1, this.domain = P.getDomainFromJid(this.jid), this._changeConnectStatus(P.Status.CONNECTING, null), this._proto._connect(i, s, r)
							},
							attach: function(e, t, n, i, s, r, o) {
								if (!(this._proto instanceof P.Bosh)) {
									var a = new Error('The "attach" method can only be used with a BOSH connection.');
									throw a.name = "StropheSessionError", a
								}
								this._proto._attach(e, t, n, i, s, r, o)
							},
							restore: function(e, t, n, i, s) {
								if (!this._sessionCachingSupported()) {
									var r = new Error('The "restore" method can only be used with a BOSH connection.');
									throw r.name = "StropheSessionError", r
								}
								this._proto._restore(e, t, n, i, s)
							},
							_sessionCachingSupported: function() {
								if (this._proto instanceof P.Bosh) {
									if (!JSON) return !1;
									try {
										sessionStorage.setItem("_strophe_", "_strophe_"), sessionStorage.removeItem("_strophe_")
									} catch (e) {
										return !1
									}
									return !0
								}
								return !1
							},
							xmlInput: function(e) {},
							xmlOutput: function(e) {},
							rawInput: function(e) {},
							rawOutput: function(e) {},
							nextValidRid: function(e) {},
							send: function(e) {
								if (null !== e) {
									if ("function" == typeof e.sort)
										for (var t = 0; t < e.length; t++) this._queueData(e[t]);
									else "function" == typeof e.tree ? this._queueData(e.tree()) : this._queueData(e);
									this._proto._send()
								}
							},
							flush: function() {
								clearTimeout(this._idleTimeout), this._onIdle()
							},
							sendPresence: function(e, t, n, i) {
								var s = this,
									r = null;
								"function" == typeof e.tree && (e = e.tree());
								var o = e.getAttribute("id");
								if (o || (o = this.getUniqueId("sendPresence"), e.setAttribute("id", o)), "function" == typeof t || "function" == typeof n) {
									var a = this.addHandler((function(e) {
										r && s.deleteTimedHandler(r), "error" === e.getAttribute("type") ? n && n(e) : t && t(e)
									}), null, "presence", null, o);
									i && (r = this.addTimedHandler(i, (function() {
										return s.deleteHandler(a), n && n(null), !1
									})))
								}
								return this.send(e), o
							},
							sendIQ: function(e, t, n, i) {
								var s = this,
									r = null;
								"function" == typeof e.tree && (e = e.tree());
								var o = e.getAttribute("id");
								if (o || (o = this.getUniqueId("sendIQ"), e.setAttribute("id", o)), "function" == typeof t || "function" == typeof n) {
									var a = this.addHandler((function(e) {
										r && s.deleteTimedHandler(r);
										var i = e.getAttribute("type");
										if ("result" === i) t && t(e);
										else {
											if ("error" !== i) {
												var o = new Error("Got bad IQ type of ".concat(i));
												throw o.name = "StropheError", o
											}
											n && n(e)
										}
									}), null, "iq", ["error", "result"], o);
									i && (r = this.addTimedHandler(i, (function() {
										return s.deleteHandler(a), n && n(null), !1
									})))
								}
								return this.send(e), o
							},
							_queueData: function(e) {
								if (null === e || !e.tagName || !e.childNodes) {
									var t = new Error("Cannot queue non-DOMElement.");
									throw t.name = "StropheError", t
								}
								this._data.push(e)
							},
							_sendRestart: function() {
								var e = this;
								this._data.push("restart"), this._proto._sendRestart(), this._idleTimeout = setTimeout((function() {
									return e._onIdle()
								}), 100)
							},
							addTimedHandler: function(e, t) {
								var n = new P.TimedHandler(e, t);
								return this.addTimeds.push(n), n
							},
							deleteTimedHandler: function(e) {
								this.removeTimeds.push(e)
							},
							addHandler: function(e, t, n, i, s, r, o) {
								var a = new P.Handler(e, t, n, i, s, r, o);
								return this.addHandlers.push(a), a
							},
							deleteHandler: function(e) {
								this.removeHandlers.push(e);
								var t = this.addHandlers.indexOf(e);
								t >= 0 && this.addHandlers.splice(t, 1)
							},
							registerSASLMechanisms: function(e) {
								this.mechanisms = {}, (e = e || [P.SASLAnonymous, P.SASLExternal, P.SASLMD5, P.SASLOAuthBearer, P.SASLXOAuth2, P.SASLPlain, P.SASLSHA1]).forEach(this.registerSASLMechanism.bind(this))
							},
							registerSASLMechanism: function(e) {
								this.mechanisms[e.prototype.name] = e
							},
							disconnect: function(e) {
								if (this._changeConnectStatus(P.Status.DISCONNECTING, e), P.warn("Disconnect was called because: " + e), this.connected) {
									var t = !1;
									this.disconnecting = !0, this.authenticated && (t = I({
										xmlns: P.NS.CLIENT,
										type: "unavailable"
									})), this._disconnectTimeout = this._addSysTimedHandler(3e3, this._onDisconnectTimeout.bind(this)), this._proto._disconnect(t)
								} else P.warn("Disconnect was called before Strophe connected to the server"), this._proto._abortAllRequests(), this._doDisconnect()
							},
							_changeConnectStatus: function(e, t, n) {
								for (var i in P._connectionPlugins)
									if (Object.prototype.hasOwnProperty.call(P._connectionPlugins, i)) {
										var s = this[i];
										if (s.statusChanged) try {
											s.statusChanged(e, t)
										} catch (e) {
											P.error("".concat(i, " plugin caused an exception changing status: ").concat(e))
										}
									} if (this.connect_callback) try {
									this.connect_callback(e, t, n)
								} catch (e) {
									P._handleError(e), P.error("User connection callback caused an exception: ".concat(e))
								}
							},
							_doDisconnect: function(e) {
								"number" == typeof this._idleTimeout && clearTimeout(this._idleTimeout), null !== this._disconnectTimeout && (this.deleteTimedHandler(this._disconnectTimeout), this._disconnectTimeout = null), P.debug("_doDisconnect was called"), this._proto._doDisconnect(), this.authenticated = !1, this.disconnecting = !1, this.restored = !1, this.handlers = [], this.timedHandlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this._changeConnectStatus(P.Status.DISCONNECTED, e), this.connected = !1
							},
							_dataRecv: function(e, t) {
								var n = this;
								P.debug("_dataRecv called");
								var i = this._proto._reqToData(e);
								if (null !== i) {
									for (this.xmlInput !== P.Connection.prototype.xmlInput && (i.nodeName === this._proto.strip && i.childNodes.length ? this.xmlInput(i.childNodes[0]) : this.xmlInput(i)), this.rawInput !== P.Connection.prototype.rawInput && (t ? this.rawInput(t) : this.rawInput(P.serialize(i))); this.removeHandlers.length > 0;) {
										var s = this.removeHandlers.pop(),
											r = this.handlers.indexOf(s);
										r >= 0 && this.handlers.splice(r, 1)
									}
									for (; this.addHandlers.length > 0;) this.handlers.push(this.addHandlers.pop());
									if (this.disconnecting && this._proto._emptyQueue()) this._doDisconnect();
									else {
										var o = i.getAttribute("type");
										if (null !== o && "terminate" === o) {
											if (this.disconnecting) return;
											var a = i.getAttribute("condition"),
												c = i.getElementsByTagName("conflict");
											return null !== a ? ("remote-stream-error" === a && c.length > 0 && (a = "conflict"), this._changeConnectStatus(P.Status.CONNFAIL, a)) : this._changeConnectStatus(P.Status.CONNFAIL, P.ErrorCondition.UNKOWN_REASON), void this._doDisconnect(a)
										}
										P.forEachChild(i, null, (function(e) {
											var t = n.handlers;
											n.handlers = [];
											for (var i = 0; i < t.length; i++) {
												var s = t[i];
												try {
													(!s.isMatch(e) || !n.authenticated && s.user || s.run(e)) && n.handlers.push(s)
												} catch (e) {
													P.warn("Removing Strophe handlers due to uncaught exception: " + e.message)
												}
											}
										}))
									}
								}
							},
							mechanisms: {},
							_connect_cb: function(e, t, n) {
								var i;
								P.debug("_connect_cb was called"), this.connected = !0;
								try {
									i = this._proto._reqToData(e)
								} catch (e) {
									if (e.name !== P.ErrorCondition.BAD_FORMAT) throw e;
									this._changeConnectStatus(P.Status.CONNFAIL, P.ErrorCondition.BAD_FORMAT), this._doDisconnect(P.ErrorCondition.BAD_FORMAT)
								}
								if (i && (this.xmlInput !== P.Connection.prototype.xmlInput && (i.nodeName === this._proto.strip && i.childNodes.length ? this.xmlInput(i.childNodes[0]) : this.xmlInput(i)), this.rawInput !== P.Connection.prototype.rawInput && (n ? this.rawInput(n) : this.rawInput(P.serialize(i))), this._proto._connect_cb(i) !== P.Status.CONNFAIL))
									if (i.getElementsByTagNameNS ? i.getElementsByTagNameNS(P.NS.STREAM, "features").length > 0 : i.getElementsByTagName("stream:features").length > 0 || i.getElementsByTagName("features").length > 0) {
										var s = [],
											r = i.getElementsByTagName("mechanism");
										if (r.length > 0)
											for (var o = 0; o < r.length; o++) {
												var a = P.getText(r[o]);
												this.mechanisms[a] && s.push(this.mechanisms[a])
											}
										0 !== s.length || 0 !== i.getElementsByTagName("auth").length ? !1 !== this.do_authentication && this.authenticate(s) : this._proto._no_auth_received(t)
									} else this._proto._no_auth_received(t)
							},
							sortMechanismsByPriority: function(e) {
								for (var t = 0; t < e.length - 1; ++t) {
									for (var n = t, i = t + 1; i < e.length; ++i) e[i].prototype.priority > e[n].prototype.priority && (n = i);
									if (n !== t) {
										var s = e[t];
										e[t] = e[n], e[n] = s
									}
								}
								return e
							},
							authenticate: function(e) {
								this._attemptSASLAuth(e) || this._attemptLegacyAuth()
							},
							_attemptSASLAuth: function(e) {
								e = this.sortMechanismsByPriority(e || []);
								for (var t = !1, n = 0; n < e.length; ++n)
									if (e[n].prototype.test(this)) {
										this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null), this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null), this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null), this._sasl_mechanism = new e[n], this._sasl_mechanism.onStart(this);
										var i = A("auth", {
											xmlns: P.NS.SASL,
											mechanism: this._sasl_mechanism.name
										});
										if (this._sasl_mechanism.isClientFirst) {
											var s = this._sasl_mechanism.onChallenge(this, null);
											i.t(btoa(s))
										}
										this.send(i.tree()), t = !0;
										break
									} return t
							},
							_sasl_challenge_cb: function(e) {
								var t = atob(P.getText(e)),
									n = this._sasl_mechanism.onChallenge(this, t),
									i = A("response", {
										xmlns: P.NS.SASL
									});
								return "" !== n && i.t(btoa(n)), this.send(i.tree()), !0
							},
							_attemptLegacyAuth: function() {
								null === P.getNodeFromJid(this.jid) ? (this._changeConnectStatus(P.Status.CONNFAIL, P.ErrorCondition.MISSING_JID_NODE), this.disconnect(P.ErrorCondition.MISSING_JID_NODE)) : (this._changeConnectStatus(P.Status.AUTHENTICATING, null), this._addSysHandler(this._onLegacyAuthIQResult.bind(this), null, null, null, "_auth_1"), this.send(R({
									type: "get",
									to: this.domain,
									id: "_auth_1"
								}).c("query", {
									xmlns: P.NS.AUTH
								}).c("username", {}).t(P.getNodeFromJid(this.jid)).tree()))
							},
							_onLegacyAuthIQResult: function(e) {
								var t = R({
									type: "set",
									id: "_auth_2"
								}).c("query", {
									xmlns: P.NS.AUTH
								}).c("username", {}).t(P.getNodeFromJid(this.jid)).up().c("password").t(this.pass);
								return P.getResourceFromJid(this.jid) || (this.jid = P.getBareJidFromJid(this.jid) + "/strophe"), t.up().c("resource", {}).t(P.getResourceFromJid(this.jid)), this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2"), this.send(t.tree()), !1
							},
							_sasl_success_cb: function(e) {
								var t = this;
								if (this._sasl_data["server-signature"]) {
									var n, i = atob(P.getText(e)).match(/([a-z]+)=([^,]+)(,|$)/);
									if ("v" === i[1] && (n = i[2]), n !== this._sasl_data["server-signature"]) return this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_data = {}, this._sasl_failure_cb(null)
								}
								P.info("SASL authentication succeeded."), this._sasl_mechanism && this._sasl_mechanism.onSuccess(), this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null);
								var s = [],
									r = function(e, n) {
										for (; e.length;) t.deleteHandler(e.pop());
										return t._onStreamFeaturesAfterSASL(n), !1
									};
								return s.push(this._addSysHandler((function(e) {
									return r(s, e)
								}), null, "stream:features", null, null)), s.push(this._addSysHandler((function(e) {
									return r(s, e)
								}), P.NS.STREAM, "features", null, null)), this._sendRestart(), !1
							},
							_onStreamFeaturesAfterSASL: function(e) {
								this.features = e;
								for (var t = 0; t < e.childNodes.length; t++) {
									var n = e.childNodes[t];
									"bind" === n.nodeName && (this.do_bind = !0), "session" === n.nodeName && (this.do_session = !0)
								}
								return this.do_bind ? (this.options.explicitResourceBinding ? this._changeConnectStatus(P.Status.BINDREQUIRED, null) : this.bind(), !1) : (this._changeConnectStatus(P.Status.AUTHFAIL, null), !1)
							},
							bind: function() {
								if (this.do_bind) {
									this._addSysHandler(this._onResourceBindResultIQ.bind(this), null, null, null, "_bind_auth_2");
									var e = P.getResourceFromJid(this.jid);
									e ? this.send(R({
										type: "set",
										id: "_bind_auth_2"
									}).c("bind", {
										xmlns: P.NS.BIND
									}).c("resource", {}).t(e).tree()) : this.send(R({
										type: "set",
										id: "_bind_auth_2"
									}).c("bind", {
										xmlns: P.NS.BIND
									}).tree())
								} else P.log(P.LogLevel.INFO, 'Strophe.Connection.prototype.bind called but "do_bind" is false')
							},
							_onResourceBindResultIQ: function(e) {
								var t;
								if ("error" === e.getAttribute("type")) return P.warn("Resource binding failed."), e.getElementsByTagName("conflict").length > 0 && (t = P.ErrorCondition.CONFLICT), this._changeConnectStatus(P.Status.AUTHFAIL, t, e), !1;
								var n = e.getElementsByTagName("bind");
								if (!(n.length > 0)) return P.warn("Resource binding failed."), this._changeConnectStatus(P.Status.AUTHFAIL, null, e), !1;
								var i = n[0].getElementsByTagName("jid");
								i.length > 0 && (this.jid = P.getText(i[0]), this.do_session ? this._establishSession() : (this.authenticated = !0, this._changeConnectStatus(P.Status.CONNECTED, null)))
							},
							_establishSession: function() {
								if (!this.do_session) throw new Error("Strophe.Connection.prototype._establishSession " + "called but apparently ".concat(P.NS.SESSION, " wasn't advertised by the server"));
								this._addSysHandler(this._onSessionResultIQ.bind(this), null, null, null, "_session_auth_2"), this.send(R({
									type: "set",
									id: "_session_auth_2"
								}).c("session", {
									xmlns: P.NS.SESSION
								}).tree())
							},
							_onSessionResultIQ: function(e) {
								if ("result" === e.getAttribute("type")) this.authenticated = !0, this._changeConnectStatus(P.Status.CONNECTED, null);
								else if ("error" === e.getAttribute("type")) return P.warn("Session creation failed."), this._changeConnectStatus(P.Status.AUTHFAIL, null, e), !1;
								return !1
							},
							_sasl_failure_cb: function(e) {
								return this._sasl_success_handler && (this.deleteHandler(this._sasl_success_handler), this._sasl_success_handler = null), this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_mechanism && this._sasl_mechanism.onFailure(), this._changeConnectStatus(P.Status.AUTHFAIL, null, e), !1
							},
							_auth2_cb: function(e) {
								return "result" === e.getAttribute("type") ? (this.authenticated = !0, this._changeConnectStatus(P.Status.CONNECTED, null)) : "error" === e.getAttribute("type") && (this._changeConnectStatus(P.Status.AUTHFAIL, null, e), this.disconnect("authentication failed")), !1
							},
							_addSysTimedHandler: function(e, t) {
								var n = new P.TimedHandler(e, t);
								return n.user = !1, this.addTimeds.push(n), n
							},
							_addSysHandler: function(e, t, n, i, s) {
								var r = new P.Handler(e, t, n, i, s);
								return r.user = !1, this.addHandlers.push(r), r
							},
							_onDisconnectTimeout: function() {
								return P.debug("_onDisconnectTimeout was called"), this._changeConnectStatus(P.Status.CONNTIMEOUT, null), this._proto._onDisconnectTimeout(), this._doDisconnect(), !1
							},
							_onIdle: function() {
								for (var e = this; this.addTimeds.length > 0;) this.timedHandlers.push(this.addTimeds.pop());
								for (; this.removeTimeds.length > 0;) {
									var t = this.removeTimeds.pop(),
										n = this.timedHandlers.indexOf(t);
									n >= 0 && this.timedHandlers.splice(n, 1)
								}
								for (var i = (new Date).getTime(), s = [], r = 0; r < this.timedHandlers.length; r++) {
									var o = this.timedHandlers[r];
									!this.authenticated && o.user || (o.lastCalled + o.period - i <= 0 ? o.run() && s.push(o) : s.push(o))
								}
								this.timedHandlers = s, clearTimeout(this._idleTimeout), this._proto._onIdle(), this.connected && (this._idleTimeout = setTimeout((function() {
									return e._onIdle()
								}), 100))
							}
						}, P.SASLMechanism = function(e, t, n) {
							this.name = e, this.isClientFirst = t, this.priority = n
						}, P.SASLMechanism.prototype = {
							test: function(e) {
								return !0
							},
							onStart: function(e) {
								this._connection = e
							},
							onChallenge: function(e, t) {
								throw new Error("You should implement challenge handling!")
							},
							onFailure: function() {
								this._connection = null
							},
							onSuccess: function() {
								this._connection = null
							}
						}, P.SASLAnonymous = function() {}, P.SASLAnonymous.prototype = new P.SASLMechanism("ANONYMOUS", !1, 20), P.SASLAnonymous.prototype.test = function(e) {
							return null === e.authcid
						}, P.SASLPlain = function() {}, P.SASLPlain.prototype = new P.SASLMechanism("PLAIN", !0, 50), P.SASLPlain.prototype.test = function(e) {
							return null !== e.authcid
						}, P.SASLPlain.prototype.onChallenge = function(e) {
							var t = e.authzid;
							return t += "\0", t += e.authcid, t += "\0", t += e.pass, C(t)
						}, P.SASLSHA1 = function() {}, P.SASLSHA1.prototype = new P.SASLMechanism("SCRAM-SHA-1", !0, 70), P.SASLSHA1.prototype.test = function(e) {
							return null !== e.authcid
						}, P.SASLSHA1.prototype.onChallenge = function(e, t, n) {
							var i = n || h.hexdigest("" + 1234567890 * Math.random()),
								s = "n=" + C(e.authcid);
							return s += ",r=", s += i, e._sasl_data.cnonce = i, e._sasl_data["client-first-message-bare"] = s, s = "n,," + s, this.onChallenge = function(e, t) {
								for (var n, i, s, r, o, a, c, d, l = "c=biws,", u = "".concat(e._sasl_data["client-first-message-bare"], ",").concat(t, ","), h = e._sasl_data.cnonce, p = /([a-z]+)=([^,]+)(,|$)/; t.match(p);) {
									var m = t.match(p);
									switch (t = t.replace(m[0], ""), m[1]) {
										case "r":
											n = m[2];
											break;
										case "s":
											i = m[2];
											break;
										case "i":
											s = m[2]
									}
								}
								if (n.substr(0, h.length) !== h) return e._sasl_data = {}, e._sasl_failure_cb();
								u += l += "r=" + n, i = atob(i), i += "\0\0\0";
								var f = C(e.pass);
								for (r = a = T.core_hmac_sha1(f, i), c = 1; c < s; c++) {
									for (o = T.core_hmac_sha1(f, T.binb2str(a)), d = 0; d < 5; d++) r[d] ^= o[d];
									a = o
								}
								r = T.binb2str(r);
								var g = T.core_hmac_sha1(r, "Client Key"),
									_ = T.str_hmac_sha1(r, "Server Key"),
									v = T.core_hmac_sha1(T.str_sha1(T.binb2str(g)), u);
								for (e._sasl_data["server-signature"] = T.b64_hmac_sha1(_, u), d = 0; d < 5; d++) g[d] ^= v[d];
								return l + ",p=" + btoa(T.binb2str(g))
							}, s
						}, P.SASLMD5 = function() {}, P.SASLMD5.prototype = new P.SASLMechanism("DIGEST-MD5", !1, 60), P.SASLMD5.prototype.test = function(e) {
							return null !== e.authcid
						}, P.SASLMD5.prototype._quote = function(e) {
							return '"' + e.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'
						}, P.SASLMD5.prototype.onChallenge = function(e, t, n) {
							for (var i = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/, s = n || h.hexdigest("" + 1234567890 * Math.random()), r = "", o = null, a = ""; t.match(i);) {
								var c = t.match(i);
								switch (t = t.replace(c[0], ""), c[2] = c[2].replace(/^"(.+)"$/, "$1"), c[1]) {
									case "realm":
										r = c[2];
										break;
									case "nonce":
										a = c[2];
										break;
									case "qop":
										c[2];
										break;
									case "host":
										o = c[2]
								}
							}
							var d = e.servtype + "/" + e.domain;
							null !== o && (d = d + "/" + o);
							var l = C(e.authcid + ":" + r + ":" + this._connection.pass),
								u = h.hash(l) + ":" + a + ":" + s,
								p = "AUTHENTICATE:" + d,
								m = "";
							return m += "charset=utf-8,", m += "username=" + this._quote(C(e.authcid)) + ",", m += "realm=" + this._quote(r) + ",", m += "nonce=" + this._quote(a) + ",", m += "nc=00000001,", m += "cnonce=" + this._quote(s) + ",", m += "digest-uri=" + this._quote(d) + ",", m += "response=" + h.hexdigest(h.hexdigest(u) + ":" + a + ":00000001:" + s + ":auth:" + h.hexdigest(p)) + ",", m += "qop=auth", this.onChallenge = function() {
								return ""
							}, m
						}, P.SASLOAuthBearer = function() {}, P.SASLOAuthBearer.prototype = new P.SASLMechanism("OAUTHBEARER", !0, 40), P.SASLOAuthBearer.prototype.test = function(e) {
							return null !== e.pass
						}, P.SASLOAuthBearer.prototype.onChallenge = function(e) {
							var t = "n,";
							return null !== e.authcid && (t = t + "a=" + e.authzid), t += ",", t += "", t += "auth=Bearer ", t += e.pass, t += "", C(t += "")
						}, P.SASLExternal = function() {}, P.SASLExternal.prototype = new P.SASLMechanism("EXTERNAL", !0, 10), P.SASLExternal.prototype.onChallenge = function(e) {
							return e.authcid === e.authzid ? "" : e.authzid
						}, P.SASLXOAuth2 = function() {}, P.SASLXOAuth2.prototype = new P.SASLMechanism("X-OAUTH2", !0, 30), P.SASLXOAuth2.prototype.test = function(e) {
							return null !== e.pass
						}, P.SASLXOAuth2.prototype.onChallenge = function(e) {
							var t = "\0";
							return null !== e.authcid && (t += e.authzid), t += "\0", t += e.pass, C(t)
						};
						var D = {
								Strophe: P,
								$build: A,
								$iq: R,
								$msg: function(e) {
									return new P.Builder("message", e)
								},
								$pres: I,
								SHA1: T,
								MD5: h,
								b64_hmac_sha1: T.b64_hmac_sha1,
								b64_sha1: T.b64_sha1,
								str_hmac_sha1: T.str_hmac_sha1,
								str_sha1: T.str_sha1
							},
							w = D.Strophe,
							O = D.$build;
						w.Request = function(e, t, n, i) {
							this.id = ++w._requestId, this.xmlData = e, this.data = w.serialize(e), this.origFunc = t, this.func = t, this.rid = n, this.date = NaN, this.sends = i || 0, this.abort = !1, this.dead = null, this.age = function() {
								return this.date ? (new Date - this.date) / 1e3 : 0
							}, this.timeDead = function() {
								return this.dead ? (new Date - this.dead) / 1e3 : 0
							}, this.xhr = this._newXHR()
						}, w.Request.prototype = {
							getResponse: function() {
								var e = null;
								if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
									if ("parsererror" === (e = this.xhr.responseXML.documentElement).tagName) throw w.error("invalid response received"), w.error("responseText: " + this.xhr.responseText), w.error("responseXML: " + w.serialize(this.xhr.responseXML)), new Error("parsererror")
								} else if (this.xhr.responseText) {
									if (w.debug("Got responseText but no responseXML; attempting to parse it with DOMParser..."), !(e = (new DOMParser).parseFromString(this.xhr.responseText, "application/xml").documentElement)) throw new Error("Parsing produced null node");
									if (e.querySelector("parsererror")) {
										w.error("invalid response received: " + e.querySelector("parsererror").textContent), w.error("responseText: " + this.xhr.responseText);
										var t = new Error;
										throw t.name = w.ErrorCondition.BAD_FORMAT, t
									}
								}
								return e
							},
							_newXHR: function() {
								var e = null;
								return window.XMLHttpRequest ? (e = new XMLHttpRequest).overrideMimeType && e.overrideMimeType("text/xml; charset=utf-8") : window.ActiveXObject && (e = new ActiveXObject("Microsoft.XMLHTTP")), e.onreadystatechange = this.func.bind(null, this), e
							}
						}, w.Bosh = function(e) {
							this._conn = e, this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.hold = 1, this.wait = 60, this.window = 5, this.errors = 0, this.inactivity = null, this.lastResponseHeaders = null, this._requests = []
						}, w.Bosh.prototype = {
							strip: null,
							_buildBody: function() {
								var e = O("body", {
									rid: this.rid++,
									xmlns: w.NS.HTTPBIND
								});
								return null !== this.sid && e.attrs({
									sid: this.sid
								}), this._conn.options.keepalive && this._conn._sessionCachingSupported() && this._cacheSession(), e
							},
							_reset: function() {
								this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.errors = 0, this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
							},
							_connect: function(e, t, n) {
								this.wait = e || this.wait, this.hold = t || this.hold, this.errors = 0;
								var i = this._buildBody().attrs({
									to: this._conn.domain,
									"xml:lang": "en",
									wait: this.wait,
									hold: this.hold,
									content: "text/xml; charset=utf-8",
									ver: "1.6",
									"xmpp:version": "1.0",
									"xmlns:xmpp": w.NS.BOSH
								});
								n && i.attrs({
									route: n
								});
								var s = this._conn._connect_cb;
								this._requests.push(new w.Request(i.tree(), this._onRequestStateChange.bind(this, s.bind(this._conn)), i.tree().getAttribute("rid"))), this._throttledRequestHandler()
							},
							_attach: function(e, t, n, i, s, r, o) {
								this._conn.jid = e, this.sid = t, this.rid = n, this._conn.connect_callback = i, this._conn.domain = w.getDomainFromJid(this._conn.jid), this._conn.authenticated = !0, this._conn.connected = !0, this.wait = s || this.wait, this.hold = r || this.hold, this.window = o || this.window, this._conn._changeConnectStatus(w.Status.ATTACHED, null)
							},
							_restore: function(e, t, n, i, s) {
								var r = JSON.parse(window.sessionStorage.getItem("strophe-bosh-session"));
								if (!(null != r && r.rid && r.sid && r.jid && (null == e || w.getBareJidFromJid(r.jid) === w.getBareJidFromJid(e) || null === w.getNodeFromJid(e) && w.getDomainFromJid(r.jid) === e))) {
									var o = new Error("_restore: no restoreable session.");
									throw o.name = "StropheSessionError", o
								}
								this._conn.restored = !0, this._attach(r.jid, r.sid, r.rid, t, n, i, s)
							},
							_cacheSession: function() {
								this._conn.authenticated ? this._conn.jid && this.rid && this.sid && window.sessionStorage.setItem("strophe-bosh-session", JSON.stringify({
									jid: this._conn.jid,
									rid: this.rid,
									sid: this.sid
								})) : window.sessionStorage.removeItem("strophe-bosh-session")
							},
							_connect_cb: function(e) {
								var t = e.getAttribute("type");
								if (null !== t && "terminate" === t) {
									var n = e.getAttribute("condition");
									w.error("BOSH-Connection failed: " + n);
									var i = e.getElementsByTagName("conflict");
									return null !== n ? ("remote-stream-error" === n && i.length > 0 && (n = "conflict"), this._conn._changeConnectStatus(w.Status.CONNFAIL, n)) : this._conn._changeConnectStatus(w.Status.CONNFAIL, "unknown"), this._conn._doDisconnect(n), w.Status.CONNFAIL
								}
								this.sid || (this.sid = e.getAttribute("sid"));
								var s = e.getAttribute("requests");
								s && (this.window = parseInt(s, 10));
								var r = e.getAttribute("hold");
								r && (this.hold = parseInt(r, 10));
								var o = e.getAttribute("wait");
								o && (this.wait = parseInt(o, 10));
								var a = e.getAttribute("inactivity");
								a && (this.inactivity = parseInt(a, 10))
							},
							_disconnect: function(e) {
								this._sendTerminate(e)
							},
							_doDisconnect: function() {
								this.sid = null, this.rid = Math.floor(4294967295 * Math.random()), this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
							},
							_emptyQueue: function() {
								return 0 === this._requests.length
							},
							_callProtocolErrorHandlers: function(e) {
								var t = this._getRequestStatus(e),
									n = this._conn.protocolErrorHandlers.HTTP[t];
								n && n.call(this, t)
							},
							_hitError: function(e) {
								this.errors++, w.warn("request errored, status: " + e + ", number of errors: " + this.errors), this.errors > 4 && this._conn._onDisconnectTimeout()
							},
							_no_auth_received: function(e) {
								w.warn("Server did not yet offer a supported authentication mechanism. Sending a blank poll request."), e = e ? e.bind(this._conn) : this._conn._connect_cb.bind(this._conn);
								var t = this._buildBody();
								this._requests.push(new w.Request(t.tree(), this._onRequestStateChange.bind(this, e), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
							},
							_onDisconnectTimeout: function() {
								this._abortAllRequests()
							},
							_abortAllRequests: function() {
								for (; this._requests.length > 0;) {
									var e = this._requests.pop();
									e.abort = !0, e.xhr.abort(), e.xhr.onreadystatechange = function() {}
								}
							},
							_onIdle: function() {
								var e = this._conn._data;
								if (this._conn.authenticated && 0 === this._requests.length && 0 === e.length && !this._conn.disconnecting && (w.debug("no requests during idle cycle, sending blank request"), e.push(null)), !this._conn.paused) {
									if (this._requests.length < 2 && e.length > 0) {
										for (var t = this._buildBody(), n = 0; n < e.length; n++) null !== e[n] && ("restart" === e[n] ? t.attrs({
											to: this._conn.domain,
											"xml:lang": "en",
											"xmpp:restart": "true",
											"xmlns:xmpp": w.NS.BOSH
										}) : t.cnode(e[n]).up());
										delete this._conn._data, this._conn._data = [], this._requests.push(new w.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
									}
									if (this._requests.length > 0) {
										var i = this._requests[0].age();
										null !== this._requests[0].dead && this._requests[0].timeDead() > Math.floor(w.SECONDARY_TIMEOUT * this.wait) && this._throttledRequestHandler(), i > Math.floor(w.TIMEOUT * this.wait) && (w.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(w.TIMEOUT * this.wait) + " seconds since last activity"), this._throttledRequestHandler())
									}
								}
							},
							_getRequestStatus: function(e, t) {
								var n;
								if (4 === e.xhr.readyState) try {
									n = e.xhr.status
								} catch (e) {
									w.error("Caught an error while retrieving a request's status, reqStatus: " + n)
								}
								return void 0 === n && (n = "number" == typeof t ? t : 0), n
							},
							_onRequestStateChange: function(e, t) {
								if (w.debug("request id " + t.id + "." + t.sends + " state changed to " + t.xhr.readyState), t.abort) t.abort = !1;
								else if (4 === t.xhr.readyState) {
									var n = this._getRequestStatus(t);
									if (this.lastResponseHeaders = t.xhr.getAllResponseHeaders(), this.disconnecting && n >= 400) return this._hitError(n), void this._callProtocolErrorHandlers(t);
									var i = n > 0 && n < 500,
										s = t.sends > this._conn.maxRetries;
									if ((i || s) && (this._removeRequest(t), w.debug("request id " + t.id + " should now be removed")), 200 === n) {
										var r = this._requests[0] === t;
										(this._requests[1] === t || r && this._requests.length > 0 && this._requests[0].age() > Math.floor(w.SECONDARY_TIMEOUT * this.wait)) && this._restartRequest(0), this._conn.nextValidRid(Number(t.rid) + 1), w.debug("request id " + t.id + "." + t.sends + " got 200"), e(t), this.errors = 0
									} else 0 === n || n >= 400 && n < 600 || n >= 12e3 ? (w.error("request id " + t.id + "." + t.sends + " error " + n + " happened"), this._hitError(n), this._callProtocolErrorHandlers(t), n >= 400 && n < 500 && (this._conn._changeConnectStatus(w.Status.DISCONNECTING, null), this._conn._doDisconnect())) : w.error("request id " + t.id + "." + t.sends + " error " + n + " happened");
									i || s ? s && !this._conn.connected && this._conn._changeConnectStatus(w.Status.CONNFAIL, "giving-up") : this._throttledRequestHandler()
								}
							},
							_processRequest: function(e) {
								var t = this,
									n = this._requests[e],
									i = this._getRequestStatus(n, -1);
								if (n.sends > this._conn.maxRetries) this._conn._onDisconnectTimeout();
								else {
									var s = n.age(),
										r = !isNaN(s) && s > Math.floor(w.TIMEOUT * this.wait),
										o = null !== n.dead && n.timeDead() > Math.floor(w.SECONDARY_TIMEOUT * this.wait),
										a = 4 === n.xhr.readyState && (i < 1 || i >= 500);
									if ((r || o || a) && (o && w.error("Request ".concat(this._requests[e].id, " timed out (secondary), restarting")), n.abort = !0, n.xhr.abort(), n.xhr.onreadystatechange = function() {}, this._requests[e] = new w.Request(n.xmlData, n.origFunc, n.rid, n.sends), n = this._requests[e]), 0 === n.xhr.readyState) {
										w.debug("request id " + n.id + "." + n.sends + " posting");
										try {
											var c = this._conn.options.contentType || "text/xml; charset=utf-8";
											n.xhr.open("POST", this._conn.service, !this._conn.options.sync), void 0 !== n.xhr.setRequestHeader && n.xhr.setRequestHeader("Content-Type", c), this._conn.options.withCredentials && (n.xhr.withCredentials = !0)
										} catch (e) {
											return w.error("XHR open failed: " + e.toString()), this._conn.connected || this._conn._changeConnectStatus(w.Status.CONNFAIL, "bad-service"), void this._conn.disconnect()
										}
										var d = function() {
											if (n.date = new Date, t._conn.options.customHeaders) {
												var e = t._conn.options.customHeaders;
												for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && n.xhr.setRequestHeader(i, e[i])
											}
											n.xhr.send(n.data)
										};
										if (n.sends > 1) {
											var l = 1e3 * Math.min(Math.floor(w.TIMEOUT * this.wait), Math.pow(n.sends, 3));
											setTimeout((function() {
												d()
											}), l)
										} else d();
										n.sends++, this._conn.xmlOutput !== w.Connection.prototype.xmlOutput && (n.xmlData.nodeName === this.strip && n.xmlData.childNodes.length ? this._conn.xmlOutput(n.xmlData.childNodes[0]) : this._conn.xmlOutput(n.xmlData)), this._conn.rawOutput !== w.Connection.prototype.rawOutput && this._conn.rawOutput(n.data)
									} else w.debug("_processRequest: " + (0 === e ? "first" : "second") + " request has readyState of " + n.xhr.readyState)
								}
							},
							_removeRequest: function(e) {
								w.debug("removing request");
								for (var t = this._requests.length - 1; t >= 0; t--) e === this._requests[t] && this._requests.splice(t, 1);
								e.xhr.onreadystatechange = function() {}, this._throttledRequestHandler()
							},
							_restartRequest: function(e) {
								var t = this._requests[e];
								null === t.dead && (t.dead = new Date), this._processRequest(e)
							},
							_reqToData: function(e) {
								try {
									return e.getResponse()
								} catch (e) {
									if ("parsererror" !== e.message) throw e;
									this._conn.disconnect("strophe-parsererror")
								}
							},
							_sendTerminate: function(e) {
								w.debug("_sendTerminate was called");
								var t = this._buildBody().attrs({
									type: "terminate"
								});
								e && t.cnode(e.tree());
								var n = new w.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"));
								this._requests.push(n), this._throttledRequestHandler()
							},
							_send: function() {
								var e = this;
								clearTimeout(this._conn._idleTimeout), this._throttledRequestHandler(), this._conn._idleTimeout = setTimeout((function() {
									return e._conn._onIdle()
								}), 100)
							},
							_sendRestart: function() {
								this._throttledRequestHandler(), clearTimeout(this._conn._idleTimeout)
							},
							_throttledRequestHandler: function() {
								this._requests ? w.debug("_throttledRequestHandler called with " + this._requests.length + " requests") : w.debug("_throttledRequestHandler called with undefined requests"), this._requests && 0 !== this._requests.length && (this._requests.length > 0 && this._processRequest(0), this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window && this._processRequest(1))
							}
						};
						var N = D.Strophe,
							M = D.$build;
						return N.Websocket = function(e) {
							this._conn = e, this.strip = "wrapper";
							var t = e.service;
							if (0 !== t.indexOf("ws:") && 0 !== t.indexOf("wss:")) {
								var n = "";
								"ws" === e.options.protocol && "https:" !== window.location.protocol ? n += "ws" : n += "wss", n += "://" + window.location.host, 0 !== t.indexOf("/") ? n += window.location.pathname + t : n += t, e.service = n
							}
						}, N.Websocket.prototype = {
							_buildStream: function() {
								return M("open", {
									xmlns: N.NS.FRAMING,
									to: this._conn.domain,
									version: "1.0"
								})
							},
							_check_streamerror: function(e, t) {
								var n;
								if (0 === (n = e.getElementsByTagNameNS ? e.getElementsByTagNameNS(N.NS.STREAM, "error") : e.getElementsByTagName("stream:error")).length) return !1;
								for (var i = n[0], s = "", r = "", o = 0; o < i.childNodes.length; o++) {
									var a = i.childNodes[o];
									if ("urn:ietf:params:xml:ns:xmpp-streams" !== a.getAttribute("xmlns")) break;
									"text" === a.nodeName ? r = a.textContent : s = a.nodeName
								}
								var c = "WebSocket stream error: ";
								return c += s || "unknown", r && (c += " - " + r), N.error(c), this._conn._changeConnectStatus(t, s), this._conn._doDisconnect(), !0
							},
							_reset: function() {},
							_connect: function() {
								this._closeSocket(), this.socket = new WebSocket(this._conn.service, "xmpp"), this.socket.onopen = this._onOpen.bind(this), this.socket.onerror = this._onError.bind(this), this.socket.onclose = this._onClose.bind(this), this.socket.onmessage = this._connect_cb_wrapper.bind(this)
							},
							_connect_cb: function(e) {
								if (this._check_streamerror(e, N.Status.CONNFAIL)) return N.Status.CONNFAIL
							},
							_handleStreamStart: function(e) {
								var t = !1,
									n = e.getAttribute("xmlns");
								"string" != typeof n ? t = "Missing xmlns in <open />" : n !== N.NS.FRAMING && (t = "Wrong xmlns in <open />: " + n);
								var i = e.getAttribute("version");
								return "string" != typeof i ? t = "Missing version in <open />" : "1.0" !== i && (t = "Wrong version in <open />: " + i), !t || (this._conn._changeConnectStatus(N.Status.CONNFAIL, t), this._conn._doDisconnect(), !1)
							},
							_connect_cb_wrapper: function(e) {
								if (0 === e.data.indexOf("<open ") || 0 === e.data.indexOf("<?xml")) {
									var t = e.data.replace(/^(<\?.*?\?>\s*)*/, "");
									if ("" === t) return;
									var n = (new DOMParser).parseFromString(t, "text/xml").documentElement;
									this._conn.xmlInput(n), this._conn.rawInput(e.data), this._handleStreamStart(n) && this._connect_cb(n)
								} else if (0 === e.data.indexOf("<close ")) {
									var i = (new DOMParser).parseFromString(e.data, "text/xml").documentElement;
									this._conn.xmlInput(i), this._conn.rawInput(e.data);
									var s = i.getAttribute("see-other-uri");
									if (s) {
										var r = this._conn.service;
										(r.indexOf("wss:") >= 0 && s.indexOf("wss:") >= 0 || r.indexOf("ws:") >= 0) && (this._conn._changeConnectStatus(N.Status.REDIRECT, "Received see-other-uri, resetting connection"), this._conn.reset(), this._conn.service = s, this._connect())
									} else this._conn._changeConnectStatus(N.Status.CONNFAIL, "Received closing stream"), this._conn._doDisconnect()
								} else {
									var o = this._streamWrap(e.data),
										a = (new DOMParser).parseFromString(o, "text/xml").documentElement;
									this.socket.onmessage = this._onMessage.bind(this), this._conn._connect_cb(a, null, e.data)
								}
							},
							_disconnect: function(e) {
								if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
									e && this._conn.send(e);
									var t = M("close", {
										xmlns: N.NS.FRAMING
									});
									this._conn.xmlOutput(t.tree());
									var n = N.serialize(t);
									this._conn.rawOutput(n);
									try {
										this.socket.send(n)
									} catch (e) {
										N.warn("Couldn't send <close /> tag.")
									}
								}
								this._conn._doDisconnect()
							},
							_doDisconnect: function() {
								N.debug("WebSockets _doDisconnect was called"), this._closeSocket()
							},
							_streamWrap: function(e) {
								return "<wrapper>" + e + "</wrapper>"
							},
							_closeSocket: function() {
								if (this.socket) try {
									this.socket.onclose = null, this.socket.onerror = null, this.socket.onmessage = null, this.socket.close()
								} catch (e) {
									N.debug(e.message)
								}
								this.socket = null
							},
							_emptyQueue: function() {
								return !0
							},
							_onClose: function(e) {
								this._conn.connected && !this._conn.disconnecting ? (N.error("Websocket closed unexpectedly"), this._conn._doDisconnect()) : e && 1006 === e.code && !this._conn.connected && this.socket ? (N.error("Websocket closed unexcectedly"), this._conn._changeConnectStatus(N.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._conn._doDisconnect()) : N.debug("Websocket closed")
							},
							_no_auth_received: function(e) {
								N.error("Server did not offer a supported authentication mechanism"), this._conn._changeConnectStatus(N.Status.CONNFAIL, N.ErrorCondition.NO_AUTH_MECH), e && e.call(this._conn), this._conn._doDisconnect()
							},
							_onDisconnectTimeout: function() {},
							_abortAllRequests: function() {},
							_onError: function(e) {
								N.error("Websocket error " + e), this._conn._changeConnectStatus(N.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._disconnect()
							},
							_onIdle: function() {
								var e = this._conn._data;
								if (e.length > 0 && !this._conn.paused) {
									for (var t = 0; t < e.length; t++)
										if (null !== e[t]) {
											var n;
											n = "restart" === e[t] ? this._buildStream().tree() : e[t];
											var i = N.serialize(n);
											this._conn.xmlOutput(n), this._conn.rawOutput(i), this.socket.send(i)
										} this._conn._data = []
								}
							},
							_onMessage: function(e) {
								var t, n = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
								if (e.data === n) return this._conn.rawInput(n), this._conn.xmlInput(e), void(this._conn.disconnecting || this._conn._doDisconnect());
								if (0 === e.data.search("<open ")) {
									if (t = (new DOMParser).parseFromString(e.data, "text/xml").documentElement, !this._handleStreamStart(t)) return
								} else {
									var i = this._streamWrap(e.data);
									t = (new DOMParser).parseFromString(i, "text/xml").documentElement
								}
								return this._check_streamerror(t, N.Status.ERROR) ? void 0 : this._conn.disconnecting && "presence" === t.firstChild.nodeName && "unavailable" === t.firstChild.getAttribute("type") ? (this._conn.xmlInput(t), void this._conn.rawInput(N.serialize(t))) : void this._conn._dataRecv(t, e.data)
							},
							_onOpen: function() {
								N.debug("Websocket open");
								var e = this._buildStream();
								this._conn.xmlOutput(e.tree());
								var t = N.serialize(e);
								this._conn.rawOutput(t), this.socket.send(t)
							},
							_reqToData: function(e) {
								return e
							},
							_send: function() {
								this._conn.flush()
							},
							_sendRestart: function() {
								clearTimeout(this._conn._idleTimeout), this._conn._onIdle.bind(this._conn)()
							}
						}, e.Strophe = D.Strophe, e.$build = D.$build, e.$iq = D.$iq, e.$msg = D.$msg, e.$pres = D.$pres, D
					}()
				},
				1352: function(e, t, n) {
					! function(e) {
						"use strict";
						
						// BAO - begin
						const username = localStorage.getItem("ofmeet.webauthn.username");	
						const disableWebAuthn = localStorage.getItem("ofmeet.webauthn.disable");	
						const accessToken = localStorage.getItem("ofmeet.access.token");												
						console.debug("e.Strophe.SASLOFPade", username, disableWebAuthn, accessToken);
						
						if (config.ofmeetWinSSOEnabled || (config.ofmeetWebAuthnEnabled && username))
						{
							if (config.ofmeetWinSSOEnabled)
							{
								fetch("./password", {method: "GET"}).then(function(response){ return response.text()}).then(function(token)
								{
									console.debug("Strophe.SASLOFPade.WINSSO", token);

									if (token.indexOf(":") > -1 )
									{
										localStorage.setItem("ofmeet.access.token", token);
										//BUG? reload only if token changed to prevent infinite login loop for NTLM

										if (!accessToken || accessToken !== token) {
										    console.debug("SASLOFPade token has changed, reloading document");
										    window.location.reload();
										}
									}

								}).catch(function (err) {
									console.error("Strophe.SASLOFPade.WINSSO", err);
									window.location.reload();
								});
							}
							else 
								
							if (config.ofmeetWebAuthnEnabled && !accessToken && !disableWebAuthn)
							{
								let bufferDecode = function (e) {
									const t = "==".slice(0, (4 - e.length % 4) % 4),
										n = e.replace(/-/g, "+").replace(/_/g, "/") + t,
										r = atob(n),
										o = new ArrayBuffer(r.length),
										c = new Uint8Array(o);
									for (let e = 0; e < r.length; e++) c[e] = r.charCodeAt(e);
									return o
								}

								let bufferEncode = function (e) {
									const t = new Uint8Array(e);
									let n = "";
									for (const e of t) n += String.fromCharCode(e);
									return btoa(n).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")
								}					

								fetch(location.protocol + "//" + location.host + "/rest/api/restapi/v1/meet/webauthn/authenticate/start/" + username, {method: "POST"}).then(function(response){ return response.json()}).then((options) => 
								{	
									console.debug("/webauthn/authenticate/start", options);
											
									options.publicKeyCredentialRequestOptions.allowCredentials.forEach(function (listItem) 
									{
										listItem.id = bufferDecode(listItem.id)
									});
									
									options.publicKeyCredentialRequestOptions.challenge = bufferDecode(options.publicKeyCredentialRequestOptions.challenge);						
									return navigator.credentials.get({publicKey: options.publicKeyCredentialRequestOptions});
								
								}).then((assertion) => {
									console.debug("/webauthn/authenticate/start - assertion", assertion, assertion.id, assertion.type);							
									const credential = {};
									credential.id =     assertion.id;
									credential.type =   assertion.type;
									credential.rawId =  bufferEncode(assertion.rawId);

									if (assertion.response) {
										const clientDataJSON = bufferEncode(assertion.response.clientDataJSON);
										const authenticatorData = bufferEncode(assertion.response.authenticatorData);
										const signature = bufferEncode(assertion.response.signature);
										const userHandle = bufferEncode(assertion.response.userHandle);
										credential.response = {clientDataJSON, authenticatorData,	signature, userHandle};
										if (!credential.clientExtensionResults) credential.clientExtensionResults = {};						  
									}
									
									fetch(location.protocol + "//" + location.host + "/rest/api/restapi/v1/meet/webauthn/authenticate/finish/" + username, {method: "POST", body: JSON.stringify(credential)}).then((success) => 
									{
										console.debug("webauthn/authenticate/finish ok");							
										localStorage.setItem("ofmeet.access.token", username + ":" + credential.id);
										localStorage.removeItem("ofmeet.webauthn.disable");	
										window.location.reload();
										
									}).catch((error) => {
										console.error("webauthn/authenticate/finish error", error);	
										localStorage.setItem("ofmeet.webauthn.disable", true);							
										window.location.reload();
									})
									
								}).catch((error) => {
									console.error("webauthn/authenticate/start error", error);	
									localStorage.setItem("ofmeet.webauthn.disable", true);						
									window.location.reload();
								})					
							}					
							
							if (accessToken)
							{
								e.Strophe.addConnectionPlugin('ofchatsasl',
								{
									init: function (connection)
									{
										e.Strophe.SASLOFPade = function () { };
										e.Strophe.SASLOFPade.prototype = new e.Strophe.SASLMechanism("PADE", true, 2000);

										e.Strophe.SASLOFPade.test = function (connection)
										{
											return true;
										};

										e.Strophe.SASLOFPade.prototype.onChallenge = function (connection)
										{								
											if (!interfaceConfig.OFMEET_CACHE_PASSWORD)
											{
												localStorage.removeItem("ofmeet.access.token");		
											}								
											return accessToken;
										};

										connection.mechanisms[e.Strophe.SASLOFPade.prototype.name] = e.Strophe.SASLOFPade;
										console.debug("strophe plugin: ofchatsasl enabled");
									}
								});
							}
						}			
						// BAO - end							
						
						e.Strophe.addConnectionPlugin("disco", {
							_connection: null,
							_identities: [],
							_features: [],
							_items: [],
							init: function(t) {
								this._connection = t, this._identities = [], this._features = [], this._items = [], t.addHandler(this._onDiscoInfo.bind(this), e.Strophe.NS.DISCO_INFO, "iq", "get", null, null), t.addHandler(this._onDiscoItems.bind(this), e.Strophe.NS.DISCO_ITEMS, "iq", "get", null, null)
							},
							addIdentity: function(e, t, n, i) {
								for (var s = 0; s < this._identities.length; s++)
									if (this._identities[s].category == e && this._identities[s].type == t && this._identities[s].name == n && this._identities[s].lang == i) return !1;
								return this._identities.push({
									category: e,
									type: t,
									name: n,
									lang: i
								}), !0
							},
							addFeature: function(e) {
								for (var t = 0; t < this._features.length; t++)
									if (this._features[t] == e) return !1;
								return this._features.push(e), !0
							},
							removeFeature: function(e) {
								for (var t = 0; t < this._features.length; t++)
									if (this._features[t] === e) return this._features.splice(t, 1), !0;
								return !1
							},
							addItem: function(e, t, n, i) {
								return !(n && !i || (this._items.push({
									jid: e,
									name: t,
									node: n,
									call_back: i
								}), 0))
							},
							info: function(t, n, i, s, r) {
								var o = {
									xmlns: e.Strophe.NS.DISCO_INFO
								};
								n && (o.node = n);
								var a = e.$iq({
									from: this._connection.jid,
									to: t,
									type: "get"
								}).c("query", o);
								this._connection.sendIQ(a, i, s, r)
							},
							items: function(t, n, i, s, r) {
								var o = {
									xmlns: e.Strophe.NS.DISCO_ITEMS
								};
								n && (o.node = n);
								var a = e.$iq({
									from: this._connection.jid,
									to: t,
									type: "get"
								}).c("query", o);
								this._connection.sendIQ(a, i, s, r)
							},
							_buildIQResult: function(t, n) {
								var i = t.getAttribute("id"),
									s = t.getAttribute("from"),
									r = e.$iq({
										type: "result",
										id: i
									});
								return null !== s && r.attrs({
									to: s
								}), r.c("query", n)
							},
							_onDiscoInfo: function(t) {
								var n, i = t.getElementsByTagName("query")[0].getAttribute("node"),
									s = {
										xmlns: e.Strophe.NS.DISCO_INFO
									};
								i && (s.node = i);
								var r = this._buildIQResult(t, s);
								for (n = 0; n < this._identities.length; n++) s = {
									category: this._identities[n].category,
									type: this._identities[n].type
								}, this._identities[n].name && (s.name = this._identities[n].name), this._identities[n].lang && (s["xml:lang"] = this._identities[n].lang), r.c("identity", s).up();
								for (n = 0; n < this._features.length; n++) r.c("feature", {
									var: this._features[n]
								}).up();
								return this._connection.send(r.tree()), !0
							},
							_onDiscoItems: function(t) {
								var n, i, s = {
										xmlns: e.Strophe.NS.DISCO_ITEMS
									},
									r = t.getElementsByTagName("query")[0].getAttribute("node");
								if (r) {
									for (s.node = r, n = [], i = 0; i < this._items.length; i++)
										if (this._items[i].node == r) {
											n = this._items[i].call_back(t);
											break
										}
								} else n = this._items;
								var o = this._buildIQResult(t, s);
								for (i = 0; i < n.length; i++) {
									var a = {
										jid: n[i].jid
									};
									n[i].name && (a.name = n[i].name), n[i].node && (a.node = n[i].node), o.c("item", a).up()
								}
								return this._connection.send(o.tree()), !0
							}
						})
					}(n(6033))
				},
				9617: function(e, t, n) {
					! function(e) {
						"use strict";
						e.Strophe.addConnectionPlugin("streamManagement", {
							logging: !1,
							autoSendCountOnEveryIncomingStanza: !1,
							requestResponseInterval: 5,
							_c: null,
							_NS: "urn:xmpp:sm:3",
							_isStreamManagementEnabled: !1,
							_serverProcesssedStanzasCounter: null,
							_clientProcessedStanzasCounter: null,
							_clientSentStanzasCounter: null,
							_originalXMLOutput: null,
							_requestHandler: null,
							_incomingHandler: null,
							_requestResponseIntervalCount: 0,
							_isSupported: !1,
							_unacknowledgedStanzas: [],
							_acknowledgedStanzaListeners: [],
							addAcknowledgedStanzaListener: function(e) {
								this._acknowledgedStanzaListeners.push(e)
							},
							enable: function(t) {
								if (!this._isSupported) throw new Error("The server doesn't support urn:xmpp:sm:3 namespace");
								if (this._connectionStatus !== e.Strophe.Status.CONNECTED) throw new Error("enable() can only be called in the CONNECTED state");
								this._c.send(e.$build("enable", {
									xmlns: this._NS,
									resume: t
								})), this._c.flush(), this._c.pause()
							},
							getResumeToken: function() {
								return this._resumeToken
							},
							isSupported() {
								return this._isSupported
							},
							resume: function() {
								if (!this.getResumeToken()) throw new Error("No resume token");
								if (this._connectionStatus !== e.Strophe.Status.DISCONNECTED) throw new Error("resume() can only be called in the DISCONNECTED state");
								this._c.options.explicitResourceBinding = !0, this._resuming = !0, this._originalConnect.apply(this._c, this._connectArgs)
							},
							requestAcknowledgement: function() {
								if (this._connectionStatus !== e.Strophe.Status.CONNECTED) throw new Error("requestAcknowledgement() can only be called in the CONNECTED state");
								this._requestResponseIntervalCount = 0, this._c.send(e.$build("r", {
									xmlns: this._NS
								}))
							},
							getOutgoingCounter: function() {
								return this._clientSentStanzasCounter
							},
							getIncomingCounter: function() {
								return this._clientProcessedStanzasCounter
							},
							init: function(t) {
								this._c = t, e.Strophe.addNamespace("SM", this._NS), this._originalXMLOutput = this._c.xmlOutput, this._c.xmlOutput = this.xmlOutput.bind(this), this._originalConnect = this._c.connect, this._c.connect = this._interceptConnectArgs.bind(this), this._originalOnStreamFeaturesAfterSASL = this._c._onStreamFeaturesAfterSASL, this._c._onStreamFeaturesAfterSASL = this._onStreamFeaturesAfterSASL.bind(this), this._originalDoDisconnect = this._c._doDisconnect, this._c._doDisconnect = this._interceptDoDisconnect.bind(this), this._originalDisconnect = this._c.disconnect, this._c.disconnect = this._interceptDisconnect.bind(this)
							},
							_interceptDisconnect: function() {
								this._resumeToken = void 0, this._originalDisconnect.apply(this._c, arguments)
							},
							_interceptDoDisconnect: function() {
								this.getResumeToken() && !this._resuming && this._c.connected && !this._c.disconnecting && (this._resumeState = {
									handlers: this._c.handlers,
									timedHandlers: this._c.timedHandlers,
									removeTimeds: this._c.removeTimeds,
									removeHandlers: this._c.removeHandlers,
									addTimeds: this._c.addTimeds,
									addHandlers: this._c.addHandlers
								}, this._storedJid = this._c.jid, this.logging && e.Strophe.debug("SM stored resume state, handler count: " + this._resumeState.handlers.length)), this._c._data = [], this._originalDoDisconnect.apply(this._c, arguments)
							},
							_interceptConnectArgs: function() {
								this._connectArgs = arguments, this._originalConnect.apply(this._c, arguments)
							},
							_onStreamFeaturesAfterSASL: function(e) {
								return this._isSupported = e.getElementsByTagNameNS(this._NS, "sm").length > 0, this._originalOnStreamFeaturesAfterSASL.apply(this._c, arguments)
							},
							statusChanged: function(t) {
								if (this._connectionStatus = t, this.getResumeToken() || t !== e.Strophe.Status.CONNECTED && t !== e.Strophe.Status.DISCONNECTED)
									if (t === e.Strophe.Status.BINDREQUIRED) {
										this._c.jid = this._storedJid;
										for (const e in this._resumeState) this._c[e] = this._resumeState[e];
										this._c.send(e.$build("resume", {
											xmlns: this._NS,
											h: this._clientProcessedStanzasCounter,
											previd: this._resumeToken
										})), this._c.flush()
									} else t === e.Strophe.Status.ERROR && (this.logging && e.Strophe.debug("SM cleared resume token on error"), this._resumeToken = void 0);
								else this.logging && e.Strophe.debug("SM reset state"), this._serverProcesssedStanzasCounter = 0, this._clientProcessedStanzasCounter = 0, this._clientSentStanzasCounter = 0, this._isStreamManagementEnabled = !1, this._requestResponseIntervalCount = 0, this._resuming = !1, t === e.Strophe.Status.DISCONNECTED && (this._isSupported = !1), this._unacknowledgedStanzas = [], this._requestHandler && this._c.deleteHandler(this._requestHandler), this._incomingHandler && this._c.deleteHandler(this._incomingHandler), this._requestHandler = this._c.addHandler(this._handleServerRequestHandler.bind(this), this._NS, "r"), this._ackHandler = this._c.addHandler(this._handleServerAck.bind(this), this._NS, "a"), this._incomingHandler = this._c.addHandler(this._incomingStanzaHandler.bind(this)), this._enabledHandler = this._c._addSysHandler(this._handleEnabled.bind(this), this._NS, "enabled"), this._resumeFailedHandler = this._c._addSysHandler(this._handleResumeFailed.bind(this), this._NS, "failed"), this._resumedHandler = this._c._addSysHandler(this._handleResumed.bind(this), this._NS, "resumed")
							},
							xmlOutput: function(t) {
								return (e.Strophe.isTagEqual(t, "iq") || e.Strophe.isTagEqual(t, "presence") || e.Strophe.isTagEqual(t, "message")) && this._increaseSentStanzasCounter(t), this._originalXMLOutput.call(this._c, t)
							},
							_handleEnabled: function(e) {
								return this._isStreamManagementEnabled = !0, this._resumeToken = "true" === e.getAttribute("resume") && e.getAttribute("id"), this._c.resume(), !0
							},
							_handleResumeFailed: function(t) {
								const n = t && t.firstElementChild && t.firstElementChild.tagName;
								return this._c._changeConnectStatus(e.Strophe.Status.ERROR, n, t), this._c._doDisconnect(), !0
							},
							_handleResumed: function(t) {
								var n = parseInt(t.getAttribute("h"));
								if (this._handleAcknowledgedStanzas(n, this._serverProcesssedStanzasCounter), this._resuming = !1, this._c.do_bind = !1, this._c.authenticated = !0, this._c.restored = !0, this._unacknowledgedStanzas.length > 0) {
									this.logging && e.Strophe.debug("SM Sending unacknowledged stanzas", this._unacknowledgedStanzas);
									for (const e of this._unacknowledgedStanzas) this._c.send(e)
								} else this.logging && e.Strophe.debug("SM No unacknowledged stanzas", this._unacknowledgedStanzas);
								return this._c._changeConnectStatus(e.Strophe.Status.CONNECTED, null), !0
							},
							_incomingStanzaHandler: function(t) {
								return (e.Strophe.isTagEqual(t, "iq") || e.Strophe.isTagEqual(t, "presence") || e.Strophe.isTagEqual(t, "message")) && (this._increaseReceivedStanzasCounter(), this.autoSendCountOnEveryIncomingStanza && this._answerProcessedStanzas()), !0
							},
							_handleAcknowledgedStanzas: function(t, n) {
								var i = t - n;
								i < 0 && this._throwError("New reported stanza count lower than previous. New: " + t + " - Previous: " + n), i > this._unacknowledgedStanzas.length && this._throwError("Higher reported acknowledge count than unacknowledged stanzas. Reported Acknowledge Count: " + i + " - Unacknowledge Stanza Count: " + this._unacknowledgedStanzas.length + " - New: " + t + " - Previous: " + n);
								for (var s = 0; s < i; s++)
									for (var r = this._unacknowledgedStanzas.shift(), o = 0; o < this._acknowledgedStanzaListeners.length; o++) this._acknowledgedStanzaListeners[o](r);
								this.logging && this._unacknowledgedStanzas.length > 0 && e.Strophe.warn("SM Unacknowledged stanzas", this._unacknowledgedStanzas), this._serverProcesssedStanzasCounter = t, this.requestResponseInterval > 0 && (this._requestResponseIntervalCount = 0)
							},
							_handleServerRequestHandler: function() {
								return this._answerProcessedStanzas(), !0
							},
							_handleServerAck: function(e) {
								var t = parseInt(e.getAttribute("h"));
								return this._handleAcknowledgedStanzas(t, this._serverProcesssedStanzasCounter), !0
							},
							_answerProcessedStanzas: function() {
								this._isStreamManagementEnabled && this._c.send(e.$build("a", {
									xmlns: this._NS,
									h: this._clientProcessedStanzasCounter
								}))
							},
							_increaseSentStanzasCounter: function(t) {
								if (this._isStreamManagementEnabled) {
									if (-1 !== this._unacknowledgedStanzas.indexOf(t)) return;
									this._unacknowledgedStanzas.push(t), this._clientSentStanzasCounter++, this.requestResponseInterval > 0 && (this._requestResponseIntervalCount++, this._requestResponseIntervalCount === this.requestResponseInterval && setTimeout((() => {
										this._connectionStatus === e.Strophe.Status.CONNECTED && this.requestAcknowledgement()
									}), 1))
								}
							},
							_increaseReceivedStanzasCounter: function() {
								this._isStreamManagementEnabled && this._clientProcessedStanzasCounter++
							},
							_throwError: function(t) {
								throw e.Strophe.error(t), new Error(t)
							}
						})
					}(n(6033))
				},
				8144: (e, t) => {
					"use strict";
					Object.defineProperty(t, "__esModule", {
						value: !0
					}), t.default = void 0;
					const n = [];
					for (let e = 0; e < 256; ++e) n.push((e + 256).toString(16).substr(1));
					t.default = function(e, t) {
						const i = t || 0,
							s = n;
						return (s[e[i + 0]] + s[e[i + 1]] + s[e[i + 2]] + s[e[i + 3]] + "-" + s[e[i + 4]] + s[e[i + 5]] + "-" + s[e[i + 6]] + s[e[i + 7]] + "-" + s[e[i + 8]] + s[e[i + 9]] + "-" + s[e[i + 10]] + s[e[i + 11]] + s[e[i + 12]] + s[e[i + 13]] + s[e[i + 14]] + s[e[i + 15]]).toLowerCase()
					}
				},
				4433: (e, t, n) => {
					"use strict";
					Object.defineProperty(t, "v1", {
						enumerable: !0,
						get: function() {
							return i.default
						}
					}), Object.defineProperty(t, "v3", {
						enumerable: !0,
						get: function() {
							return s.default
						}
					}), Object.defineProperty(t, "v4", {
						enumerable: !0,
						get: function() {
							return r.default
						}
					}), Object.defineProperty(t, "v5", {
						enumerable: !0,
						get: function() {
							return o.default
						}
					});
					var i = a(n(3423)),
						s = a(n(89)),
						r = a(n(7600)),
						o = a(n(9400));

					function a(e) {
						return e && e.__esModule ? e : {
							default: e
						}
					}
				},
				2862: (e, t) => {
					"use strict";

					function n(e) {
						return 14 + (e + 64 >>> 9 << 4) + 1
					}

					function i(e, t) {
						const n = (65535 & e) + (65535 & t);
						return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
					}

					function s(e, t, n, s, r, o) {
						return i((a = i(i(t, e), i(s, o))) << (c = r) | a >>> 32 - c, n);
						var a, c
					}

					function r(e, t, n, i, r, o, a) {
						return s(t & n | ~t & i, e, t, r, o, a)
					}

					function o(e, t, n, i, r, o, a) {
						return s(t & i | n & ~i, e, t, r, o, a)
					}

					function a(e, t, n, i, r, o, a) {
						return s(t ^ n ^ i, e, t, r, o, a)
					}

					function c(e, t, n, i, r, o, a) {
						return s(n ^ (t | ~i), e, t, r, o, a)
					}
					Object.defineProperty(t, "__esModule", {
						value: !0
					}), t.default = void 0;
					t.default = function(e) {
						if ("string" == typeof e) {
							const t = unescape(encodeURIComponent(e));
							e = new Uint8Array(t.length);
							for (let n = 0; n < t.length; ++n) e[n] = t.charCodeAt(n)
						}
						return function(e) {
							const t = [],
								n = 32 * e.length,
								i = "0123456789abcdef";
							for (let s = 0; s < n; s += 8) {
								const n = e[s >> 5] >>> s % 32 & 255,
									r = parseInt(i.charAt(n >>> 4 & 15) + i.charAt(15 & n), 16);
								t.push(r)
							}
							return t
						}(function(e, t) {
							e[t >> 5] |= 128 << t % 32, e[n(t) - 1] = t;
							let s = 1732584193,
								d = -271733879,
								l = -1732584194,
								u = 271733878;
							for (let t = 0; t < e.length; t += 16) {
								const n = s,
									h = d,
									p = l,
									m = u;
								s = r(s, d, l, u, e[t], 7, -680876936), u = r(u, s, d, l, e[t + 1], 12, -389564586), l = r(l, u, s, d, e[t + 2], 17, 606105819), d = r(d, l, u, s, e[t + 3], 22, -1044525330), s = r(s, d, l, u, e[t + 4], 7, -176418897), u = r(u, s, d, l, e[t + 5], 12, 1200080426), l = r(l, u, s, d, e[t + 6], 17, -1473231341), d = r(d, l, u, s, e[t + 7], 22, -45705983), s = r(s, d, l, u, e[t + 8], 7, 1770035416), u = r(u, s, d, l, e[t + 9], 12, -1958414417), l = r(l, u, s, d, e[t + 10], 17, -42063), d = r(d, l, u, s, e[t + 11], 22, -1990404162), s = r(s, d, l, u, e[t + 12], 7, 1804603682), u = r(u, s, d, l, e[t + 13], 12, -40341101), l = r(l, u, s, d, e[t + 14], 17, -1502002290), d = r(d, l, u, s, e[t + 15], 22, 1236535329), s = o(s, d, l, u, e[t + 1], 5, -165796510), u = o(u, s, d, l, e[t + 6], 9, -1069501632), l = o(l, u, s, d, e[t + 11], 14, 643717713), d = o(d, l, u, s, e[t], 20, -373897302), s = o(s, d, l, u, e[t + 5], 5, -701558691), u = o(u, s, d, l, e[t + 10], 9, 38016083), l = o(l, u, s, d, e[t + 15], 14, -660478335), d = o(d, l, u, s, e[t + 4], 20, -405537848), s = o(s, d, l, u, e[t + 9], 5, 568446438), u = o(u, s, d, l, e[t + 14], 9, -1019803690), l = o(l, u, s, d, e[t + 3], 14, -187363961), d = o(d, l, u, s, e[t + 8], 20, 1163531501), s = o(s, d, l, u, e[t + 13], 5, -1444681467), u = o(u, s, d, l, e[t + 2], 9, -51403784), l = o(l, u, s, d, e[t + 7], 14, 1735328473), d = o(d, l, u, s, e[t + 12], 20, -1926607734), s = a(s, d, l, u, e[t + 5], 4, -378558), u = a(u, s, d, l, e[t + 8], 11, -2022574463), l = a(l, u, s, d, e[t + 11], 16, 1839030562), d = a(d, l, u, s, e[t + 14], 23, -35309556), s = a(s, d, l, u, e[t + 1], 4, -1530992060), u = a(u, s, d, l, e[t + 4], 11, 1272893353), l = a(l, u, s, d, e[t + 7], 16, -155497632), d = a(d, l, u, s, e[t + 10], 23, -1094730640), s = a(s, d, l, u, e[t + 13], 4, 681279174), u = a(u, s, d, l, e[t], 11, -358537222), l = a(l, u, s, d, e[t + 3], 16, -722521979), d = a(d, l, u, s, e[t + 6], 23, 76029189), s = a(s, d, l, u, e[t + 9], 4, -640364487), u = a(u, s, d, l, e[t + 12], 11, -421815835), l = a(l, u, s, d, e[t + 15], 16, 530742520), d = a(d, l, u, s, e[t + 2], 23, -995338651), s = c(s, d, l, u, e[t], 6, -198630844), u = c(u, s, d, l, e[t + 7], 10, 1126891415), l = c(l, u, s, d, e[t + 14], 15, -1416354905), d = c(d, l, u, s, e[t + 5], 21, -57434055), s = c(s, d, l, u, e[t + 12], 6, 1700485571), u = c(u, s, d, l, e[t + 3], 10, -1894986606), l = c(l, u, s, d, e[t + 10], 15, -1051523), d = c(d, l, u, s, e[t + 1], 21, -2054922799), s = c(s, d, l, u, e[t + 8], 6, 1873313359), u = c(u, s, d, l, e[t + 15], 10, -30611744), l = c(l, u, s, d, e[t + 6], 15, -1560198380), d = c(d, l, u, s, e[t + 13], 21, 1309151649), s = c(s, d, l, u, e[t + 4], 6, -145523070), u = c(u, s, d, l, e[t + 11], 10, -1120210379), l = c(l, u, s, d, e[t + 2], 15, 718787259), d = c(d, l, u, s, e[t + 9], 21, -343485551), s = i(s, n), d = i(d, h), l = i(l, p), u = i(u, m)
							}
							return [s, d, l, u]
						}(function(e) {
							if (0 === e.length) return [];
							const t = 8 * e.length,
								i = new Uint32Array(n(t));
							for (let n = 0; n < t; n += 8) i[n >> 5] |= (255 & e[n / 8]) << n % 32;
							return i
						}(e), 8 * e.length))
					}
				},
				294: (e, t) => {
					"use strict";
					Object.defineProperty(t, "__esModule", {
						value: !0
					}), t.default = function() {
						if (!n) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
						return n(i)
					};
					const n = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto),
						i = new Uint8Array(16)
				},
				7585: (e, t) => {
					"use strict";

					function n(e, t, n, i) {
						switch (e) {
							case 0:
								return t & n ^ ~t & i;
							case 1:
							case 3:
								return t ^ n ^ i;
							case 2:
								return t & n ^ t & i ^ n & i
						}
					}

					function i(e, t) {
						return e << t | e >>> 32 - t
					}
					Object.defineProperty(t, "__esModule", {
						value: !0
					}), t.default = void 0;
					t.default = function(e) {
						const t = [1518500249, 1859775393, 2400959708, 3395469782],
							s = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
						if ("string" == typeof e) {
							const t = unescape(encodeURIComponent(e));
							e = [];
							for (let n = 0; n < t.length; ++n) e.push(t.charCodeAt(n))
						}
						e.push(128);
						const r = e.length / 4 + 2,
							o = Math.ceil(r / 16),
							a = new Array(o);
						for (let t = 0; t < o; ++t) {
							const n = new Uint32Array(16);
							for (let i = 0; i < 16; ++i) n[i] = e[64 * t + 4 * i] << 24 | e[64 * t + 4 * i + 1] << 16 | e[64 * t + 4 * i + 2] << 8 | e[64 * t + 4 * i + 3];
							a[t] = n
						}
						a[o - 1][14] = 8 * (e.length - 1) / Math.pow(2, 32), a[o - 1][14] = Math.floor(a[o - 1][14]), a[o - 1][15] = 8 * (e.length - 1) & 4294967295;
						for (let e = 0; e < o; ++e) {
							const r = new Uint32Array(80);
							for (let t = 0; t < 16; ++t) r[t] = a[e][t];
							for (let e = 16; e < 80; ++e) r[e] = i(r[e - 3] ^ r[e - 8] ^ r[e - 14] ^ r[e - 16], 1);
							let o = s[0],
								c = s[1],
								d = s[2],
								l = s[3],
								u = s[4];
							for (let e = 0; e < 80; ++e) {
								const s = Math.floor(e / 20),
									a = i(o, 5) + n(s, c, d, l) + u + t[s] + r[e] >>> 0;
								u = l, l = d, d = i(c, 30) >>> 0, c = o, o = a
							}
							s[0] = s[0] + o >>> 0, s[1] = s[1] + c >>> 0, s[2] = s[2] + d >>> 0, s[3] = s[3] + l >>> 0, s[4] = s[4] + u >>> 0
						}
						return [s[0] >> 24 & 255, s[0] >> 16 & 255, s[0] >> 8 & 255, 255 & s[0], s[1] >> 24 & 255, s[1] >> 16 & 255, s[1] >> 8 & 255, 255 & s[1], s[2] >> 24 & 255, s[2] >> 16 & 255, s[2] >> 8 & 255, 255 & s[2], s[3] >> 24 & 255, s[3] >> 16 & 255, s[3] >> 8 & 255, 255 & s[3], s[4] >> 24 & 255, s[4] >> 16 & 255, s[4] >> 8 & 255, 255 & s[4]]
					}
				},
				3423: (e, t, n) => {
					"use strict";
					Object.defineProperty(t, "__esModule", {
						value: !0
					}), t.default = void 0;
					var i = r(n(294)),
						s = r(n(8144));

					function r(e) {
						return e && e.__esModule ? e : {
							default: e
						}
					}
					let o, a, c = 0,
						d = 0;
					t.default = function(e, t, n) {
						let r = t && n || 0;
						const l = t || [];
						let u = (e = e || {}).node || o,
							h = void 0 !== e.clockseq ? e.clockseq : a;
						if (null == u || null == h) {
							const t = e.random || (e.rng || i.default)();
							null == u && (u = o = [1 | t[0], t[1], t[2], t[3], t[4], t[5]]), null == h && (h = a = 16383 & (t[6] << 8 | t[7]))
						}
						let p = void 0 !== e.msecs ? e.msecs : Date.now(),
							m = void 0 !== e.nsecs ? e.nsecs : d + 1;
						const f = p - c + (m - d) / 1e4;
						if (f < 0 && void 0 === e.clockseq && (h = h + 1 & 16383), (f < 0 || p > c) && void 0 === e.nsecs && (m = 0), m >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
						c = p, d = m, a = h, p += 122192928e5;
						const g = (1e4 * (268435455 & p) + m) % 4294967296;
						l[r++] = g >>> 24 & 255, l[r++] = g >>> 16 & 255, l[r++] = g >>> 8 & 255, l[r++] = 255 & g;
						const _ = p / 4294967296 * 1e4 & 268435455;
						l[r++] = _ >>> 8 & 255, l[r++] = 255 & _, l[r++] = _ >>> 24 & 15 | 16, l[r++] = _ >>> 16 & 255, l[r++] = h >>> 8 | 128, l[r++] = 255 & h;
						for (let e = 0; e < 6; ++e) l[r + e] = u[e];
						return t || (0, s.default)(l)
					}
				},
				89: (e, t, n) => {
					"use strict";
					Object.defineProperty(t, "__esModule", {
						value: !0
					}), t.default = void 0;
					var i = r(n(6929)),
						s = r(n(2862));

					function r(e) {
						return e && e.__esModule ? e : {
							default: e
						}
					}
					var o = (0, i.default)("v3", 48, s.default);
					t.default = o
				},
				6929: (e, t, n) => {
					"use strict";
					Object.defineProperty(t, "__esModule", {
						value: !0
					}), t.default = function(e, t, n) {
						function i(e, i, r, o) {
							const a = r && o || 0;
							if ("string" == typeof e && (e = function(e) {
									e = unescape(encodeURIComponent(e));
									const t = [];
									for (let n = 0; n < e.length; ++n) t.push(e.charCodeAt(n));
									return t
								}(e)), "string" == typeof i && (i = function(e) {
									const t = [];
									return e.replace(/[a-fA-F0-9]{2}/g, (function(e) {
										t.push(parseInt(e, 16))
									})), t
								}(i)), !Array.isArray(e)) throw TypeError("value must be an array of bytes");
							if (!Array.isArray(i) || 16 !== i.length) throw TypeError("namespace must be uuid string or an Array of 16 byte values");
							const c = n(i.concat(e));
							if (c[6] = 15 & c[6] | t, c[8] = 63 & c[8] | 128, r)
								for (let e = 0; e < 16; ++e) r[a + e] = c[e];
							return r || (0, s.default)(c)
						}
						try {
							i.name = e
						} catch (e) {}
						return i.DNS = r, i.URL = o, i
					}, t.URL = t.DNS = void 0;
					var i, s = (i = n(8144)) && i.__esModule ? i : {
						default: i
					};
					const r = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
					t.DNS = r;
					const o = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
					t.URL = o
				},
				7600: (e, t, n) => {
					"use strict";
					Object.defineProperty(t, "__esModule", {
						value: !0
					}), t.default = void 0;
					var i = r(n(294)),
						s = r(n(8144));

					function r(e) {
						return e && e.__esModule ? e : {
							default: e
						}
					}
					t.default = function(e, t, n) {
						"string" == typeof e && (t = "binary" === e ? new Uint8Array(16) : null, e = null);
						const r = (e = e || {}).random || (e.rng || i.default)();
						if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {
							const e = n || 0;
							for (let n = 0; n < 16; ++n) t[e + n] = r[n];
							return t
						}
						return (0, s.default)(r)
					}
				},
				9400: (e, t, n) => {
					"use strict";
					Object.defineProperty(t, "__esModule", {
						value: !0
					}), t.default = void 0;
					var i = r(n(6929)),
						s = r(n(7585));

					function r(e) {
						return e && e.__esModule ? e : {
							default: e
						}
					}
					var o = (0, i.default)("v5", 80, s.default);
					t.default = o
				},
				7318: e => {
					e.exports = {
						CAMERA: "camera",
						DESKTOP: "desktop",
						DESKTOP_HIGH_FPS: "desktop_high_fps",
						NONE: "none"
					}
				},
				4940: e => {
					e.exports = {
						ENVIRONMENT: "environment",
						USER: "user"
					}
				},
				4391: e => {
					e.exports = {
						AV1: "av1",
						H264: "h264",
						OPUS: "opus",
						ULPFEC: "ulpfec",
						VP8: "vp8",
						VP9: "vp9"
					}
				},
				9987: (e, t, n) => {
					"use strict";
					let i;
					n.r(t), n.d(t, {
							RTCEvents: () => i,
							CREATE_ANSWER_FAILED: () => s,
							CREATE_OFFER_FAILED: () => r,
							DATA_CHANNEL_OPEN: () => o,
							DATA_CHANNEL_CLOSED: () => a,
							ENDPOINT_CONN_STATUS_CHANGED: () => c,
							DOMINANT_SPEAKER_CHANGED: () => d,
							FORWARDED_SOURCES_CHANGED: () => l,
							PERMISSIONS_CHANGED: () => u,
							SENDER_VIDEO_CONSTRAINTS_CHANGED: () => h,
							LASTN_VALUE_CHANGED: () => p,
							LOCAL_TRACK_SSRC_UPDATED: () => m,
							LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED: () => f,
							TRACK_ATTACHED: () => g,
							REMOTE_TRACK_ADDED: () => _,
							REMOTE_TRACK_MUTE: () => v,
							REMOTE_TRACK_REMOVED: () => S,
							REMOTE_TRACK_UNMUTE: () => E,
							SET_LOCAL_DESCRIPTION_FAILED: () => y,
							SET_REMOTE_DESCRIPTION_FAILED: () => T,
							AUDIO_OUTPUT_DEVICE_CHANGED: () => C,
							DEVICE_LIST_CHANGED: () => b,
							DEVICE_LIST_WILL_CHANGE: () => A,
							DEVICE_LIST_AVAILABLE: () => R,
							ENDPOINT_MESSAGE_RECEIVED: () => I,
							ENDPOINT_STATS_RECEIVED: () => P,
							LOCAL_UFRAG_CHANGED: () => D,
							REMOTE_UFRAG_CHANGED: () => w,
							VIDEO_SSRCS_REMAPPED: () => O,
							AUDIO_SSRCS_REMAPPED: () => N,
							default: () => M
						}),
						function(e) {
							e.CREATE_ANSWER_FAILED = "rtc.create_answer_failed", e.CREATE_OFFER_FAILED = "rtc.create_offer_failed", e.DATA_CHANNEL_OPEN = "rtc.data_channel_open", e.DATA_CHANNEL_CLOSED = "rtc.data_channel_closed", e.ENDPOINT_CONN_STATUS_CHANGED = "rtc.endpoint_conn_status_changed", e.DOMINANT_SPEAKER_CHANGED = "rtc.dominant_speaker_changed", e.FORWARDED_SOURCES_CHANGED = "rtc.forwarded_sources_changed", e.PERMISSIONS_CHANGED = "rtc.permissions_changed", e.SENDER_VIDEO_CONSTRAINTS_CHANGED = "rtc.sender_video_constraints_changed", e.LASTN_VALUE_CHANGED = "rtc.lastn_value_changed", e.LOCAL_TRACK_SSRC_UPDATED = "rtc.local_track_ssrc_updated", e.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED = "rtc.local_track_max_enabled_resolution_changed", e.TRACK_ATTACHED = "rtc.track_attached", e.REMOTE_TRACK_ADDED = "rtc.remote_track_added", e.REMOTE_TRACK_MUTE = "rtc.remote_track_mute", e.REMOTE_TRACK_REMOVED = "rtc.remote_track_removed", e.REMOTE_TRACK_UNMUTE = "rtc.remote_track_unmute", e.SET_LOCAL_DESCRIPTION_FAILED = "rtc.set_local_description_failed", e.SET_REMOTE_DESCRIPTION_FAILED = "rtc.set_remote_description_failed", e.AUDIO_OUTPUT_DEVICE_CHANGED = "rtc.audio_output_device_changed", e.DEVICE_LIST_CHANGED = "rtc.device_list_changed", e.DEVICE_LIST_WILL_CHANGE = "rtc.device_list_will_change", e.DEVICE_LIST_AVAILABLE = "rtc.device_list_available", e.ENDPOINT_MESSAGE_RECEIVED = "rtc.endpoint_message_received", e.ENDPOINT_STATS_RECEIVED = "rtc.endpoint_stats_received", e.LOCAL_UFRAG_CHANGED = "rtc.local_ufrag_changed", e.REMOTE_UFRAG_CHANGED = "rtc.remote_ufrag_changed", e.VIDEO_SSRCS_REMAPPED = "rtc.video_ssrcs_remapped", e.AUDIO_SSRCS_REMAPPED = "rtc.audio_ssrcs_remapped"
						}(i || (i = {}));
					const s = i.CREATE_ANSWER_FAILED,
						r = i.CREATE_OFFER_FAILED,
						o = i.DATA_CHANNEL_OPEN,
						a = i.DATA_CHANNEL_CLOSED,
						c = i.ENDPOINT_CONN_STATUS_CHANGED,
						d = i.DOMINANT_SPEAKER_CHANGED,
						l = i.FORWARDED_SOURCES_CHANGED,
						u = i.PERMISSIONS_CHANGED,
						h = i.SENDER_VIDEO_CONSTRAINTS_CHANGED,
						p = i.LASTN_VALUE_CHANGED,
						m = i.LOCAL_TRACK_SSRC_UPDATED,
						f = i.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED,
						g = i.TRACK_ATTACHED,
						_ = i.REMOTE_TRACK_ADDED,
						v = i.REMOTE_TRACK_MUTE,
						S = i.REMOTE_TRACK_REMOVED,
						E = i.REMOTE_TRACK_UNMUTE,
						y = i.SET_LOCAL_DESCRIPTION_FAILED,
						T = i.SET_REMOTE_DESCRIPTION_FAILED,
						C = i.AUDIO_OUTPUT_DEVICE_CHANGED,
						b = i.DEVICE_LIST_CHANGED,
						A = i.DEVICE_LIST_WILL_CHANGE,
						R = i.DEVICE_LIST_AVAILABLE,
						I = i.ENDPOINT_MESSAGE_RECEIVED,
						P = i.ENDPOINT_STATS_RECEIVED,
						D = i.LOCAL_UFRAG_CHANGED,
						w = i.REMOTE_UFRAG_CHANGED,
						O = i.VIDEO_SSRCS_REMAPPED,
						N = i.AUDIO_SSRCS_REMAPPED,
						M = i
				},
				6125: e => {
					e.exports = {
						2160: {
							width: 3840,
							height: 2160
						},
						"4k": {
							width: 3840,
							height: 2160
						},
						1080: {
							width: 1920,
							height: 1080
						},
						fullhd: {
							width: 1920,
							height: 1080
						},
						720: {
							width: 1280,
							height: 720
						},
						hd: {
							width: 1280,
							height: 720
						},
						540: {
							width: 960,
							height: 540
						},
						qhd: {
							width: 960,
							height: 540
						},
						480: {
							width: 640,
							height: 480
						},
						vga: {
							width: 640,
							height: 480
						},
						360: {
							width: 640,
							height: 360
						},
						240: {
							width: 320,
							height: 240
						},
						180: {
							width: 320,
							height: 180
						}
					}
				},
				3408: (e, t, n) => {
					"use strict";
					let i;
					n.r(t), n.d(t, {
							VideoType: () => i
						}),
						function(e) {
							e.CAMERA = "camera", e.DESKTOP = "desktop"
						}(i || (i = {}))
				},
				3514: e => {
					e.exports = {
						IDENTITY_UPDATED: "authentication.identity_updated"
					}
				},
				7680: (e, t, n) => {
					"use strict";
					n.d(t, {
						D: () => i
					});
					const i = "local"
				},
				609: (e, t, n) => {
					"use strict";
					let i;
					n.r(t), n.d(t, {
							XMPPEvents: () => i
						}),
						function(e) {
							e.ADD_ICE_CANDIDATE_FAILED = "xmpp.add_ice_candidate_failed", e.AUDIO_MUTED_BY_FOCUS = "xmpp.audio_muted_by_focus", e.VIDEO_MUTED_BY_FOCUS = "xmpp.video_muted_by_focus", e.AUTHENTICATION_REQUIRED = "xmpp.authentication_required", e.BRIDGE_DOWN = "xmpp.bridge_down", e.CALL_ACCEPTED = "xmpp.callaccepted.jingle", e.CALL_INCOMING = "xmpp.callincoming.jingle", e.CALL_ENDED = "xmpp.callended.jingle", e.CHAT_ERROR_RECEIVED = "xmpp.chat_error_received", e.SETTINGS_ERROR_RECEIVED = "xmpp.settings_error_received", e.CONFERENCE_PROPERTIES_CHANGED = "xmpp.conference_properties_changed", e.CONNECTION_ESTABLISHED = "xmpp.connection.connected", e.CONNECTION_FAILED = "xmpp.connection.failed", e.CONNECTION_INTERRUPTED = "xmpp.connection.interrupted", e.CONNECTION_RESTORED = "xmpp.connection.restored", e.CONNECTION_ICE_FAILED = "xmpp.connection.ice.failed", e.CONNECTION_RESTARTED = "xmpp.connection.restart", e.CONNECTION_STATUS_CHANGED = "xmpp.connection.status.changed", e.DISPLAY_NAME_CHANGED = "xmpp.display_name_changed", e.EMUC_ROOM_ADDED = "xmpp.emuc_room_added", e.EMUC_ROOM_REMOVED = "xmpp.emuc_room_removed", e.ETHERPAD = "xmpp.etherpad", e.FOCUS_DISCONNECTED = "xmpp.focus_disconnected", e.FOCUS_LEFT = "xmpp.focus_left", e.GRACEFUL_SHUTDOWN = "xmpp.graceful_shutdown", e.ICE_RESTARTING = "rtc.ice_restarting", e.ICE_RESTART_SUCCESS = "rtc.ice_restart_success", e.KICKED = "xmpp.kicked", e.LOCAL_ROLE_CHANGED = "xmpp.localrole_changed", e.MEETING_ID_SET = "xmpp.meeting_id_set", e.MESSAGE_RECEIVED = "xmpp.message_received", e.INVITE_MESSAGE_RECEIVED = "xmpp.invite_message_received", e.PRIVATE_MESSAGE_RECEIVED = "xmpp.private_message_received", e.MUC_MEMBER_BOT_TYPE_CHANGED = "xmpp.muc_member_bot_type_changed", e.MUC_DESTROYED = "xmpp.muc_destroyed", e.MUC_JOIN_IN_PROGRESS = "xmpp.muc_join_in_progress", e.MUC_JOINED = "xmpp.muc_joined", e.MUC_MEMBER_JOINED = "xmpp.muc_member_joined", e.MUC_MEMBER_LEFT = "xmpp.muc_member_left", e.MUC_LOBBY_MEMBER_JOINED = "xmpp.muc_lobby_member_joined", e.MUC_LOBBY_MEMBER_UPDATED = "xmpp.muc_lobby_member_updated", e.MUC_LOBBY_MEMBER_LEFT = "xmpp.muc_lobby_member_left", e.MUC_DENIED_ACCESS = "xmpp.muc_denied access", e.MUC_LEFT = "xmpp.muc_left", e.MUC_ROLE_CHANGED = "xmpp.muc_role_changed", e.MUC_LOCK_CHANGED = "xmpp.muc_lock_changed", e.MUC_MEMBERS_ONLY_CHANGED = "xmpp.muc_members_only_changed", e.PARTICIPANT_AUDIO_MUTED = "xmpp.audio_muted", e.PARTICIPANT_VIDEO_MUTED = "xmpp.video_muted", e.PARTICIPANT_VIDEO_TYPE_CHANGED = "xmpp.video_type", e.PARTICIPANT_FEATURES_CHANGED = "xmpp.participant_features_changed", e.PASSWORD_REQUIRED = "xmpp.password_required", e.PHONE_NUMBER_CHANGED = "conference.phoneNumberChanged", e.PRESENCE_RECEIVED = "xmpp.presence_received", e.PRESENCE_STATUS = "xmpp.presence_status", e.PROMPT_FOR_LOGIN = "xmpp.prompt_for_login", e.READY_TO_JOIN = "xmpp.ready_to_join", e.RECORDER_STATE_CHANGED = "xmpp.recorderStateChanged", e.REDIRECTED = "xmpp.redirected", e.REMOTE_STATS = "xmpp.remote_stats", e.RENEGOTIATION_FAILED = "xmpp.renegotiation_failed", e.RESERVATION_ERROR = "xmpp.room_reservation_error", e.ROOM_CONNECT_ERROR = "xmpp.room_connect_error", e.ROOM_CONNECT_NOT_ALLOWED_ERROR = "xmpp.room_connect_error.not_allowed", e.ROOM_JOIN_ERROR = "xmpp.room_join_error", e.ROOM_CONNECT_MEMBERS_ONLY_ERROR = "xmpp.room_connect_error.members_only", e.ROOM_MAX_USERS_ERROR = "xmpp.room_max_users_error", e.SENDING_CHAT_MESSAGE = "xmpp.sending_chat_message", e.SENDING_PRIVATE_CHAT_MESSAGE = "xmpp.sending_private_chat_message", e.SESSION_ACCEPT = "xmpp.session_accept", e.SESSION_ACCEPT_ERROR = "xmpp.session_accept_error", e.SESSION_ACCEPT_TIMEOUT = "xmpp.session_accept_timeout", e.SOURCE_ADD = "xmpp.source_add", e.SOURCE_ADD_ERROR = "xmpp.source_add_error", e.SOURCE_REMOVE = "xmpp.source_remove", e.SOURCE_REMOVE_ERROR = "xmpp.source_remove_error", e.SPEAKER_STATS_RECEIVED = "xmpp.speaker_stats_received", e.CONFERENCE_TIMESTAMP_RECEIVED = "xmpp.conference_timestamp_received", e.AV_MODERATION_APPROVED = "xmpp.av_moderation.approved", e.AV_MODERATION_REJECTED = "xmpp.av_moderation.rejected", e.AV_MODERATION_RECEIVED = "xmpp.av_moderation.received", e.AV_MODERATION_CHANGED = "xmpp.av_moderation.changed", e.AV_MODERATION_PARTICIPANT_APPROVED = "xmpp.av_moderation.participant.approved", e.AV_MODERATION_PARTICIPANT_REJECTED = "xmpp.av_moderation.participant.rejected", e.BREAKOUT_ROOMS_MOVE_TO_ROOM = "xmpp.breakout-rooms.move-to-room", e.BREAKOUT_ROOMS_EVENT = "xmpp.breakout-rooms.event", e.BREAKOUT_ROOMS_UPDATED = "xmpp.breakout-rooms.updated", e.ROOM_METADATA_EVENT = "xmpp.room-metadata.event", e.ROOM_METADATA_UPDATED = "xmpp.room-metadata.updated", e.START_MUTED_FROM_FOCUS = "xmpp.start_muted_from_focus", e.SUBJECT_CHANGED = "xmpp.subject_changed", e.SUSPEND_DETECTED = "xmpp.suspend_detected", e.TRANSCRIPTION_STATUS_CHANGED = "xmpp.transcription_status_changed", e.TRANSPORT_INFO = "xmpp.transportinfo.jingle", e.VIDEO_SIP_GW_AVAILABILITY_CHANGED = "xmpp.videoSIPGWAvailabilityChanged", e.VIDEO_SIP_GW_SESSION_STATE_CHANGED = "xmpp.videoSIPGWSessionStateChanged", e.ICE_CONNECTION_STATE_CHANGED = "xmpp.ice_connection_state_changed", e.JSON_MESSAGE_RECEIVED = "xmmp.json_message_received"
						}(i || (i = {}))
				},
				5369: (e, t, n) => {
					"use strict";
					n.d(t, {
						Z: () => Ph
					});
					var i = {};
					n.r(i), n.d(i, {
						AUTHENTICATION_REQUIRED: () => T,
						CHAT_ERROR: () => C,
						CONFERENCE_ACCESS_DENIED: () => O,
						CONFERENCE_DESTROYED: () => A,
						CONFERENCE_MAX_USERS: () => R,
						CONFERENCE_RESTARTED: () => P,
						CONNECTION_ERROR: () => I,
						FOCUS_DISCONNECTED: () => N,
						FOCUS_LEFT: () => M,
						GRACEFUL_SHUTDOWN: () => L,
						ICE_FAILED: () => k,
						INCOMPATIBLE_SERVER_VERSIONS: () => x,
						JitsiConferenceErrors: () => y,
						MEMBERS_ONLY_ERROR: () => w,
						NOT_ALLOWED_ERROR: () => D,
						OFFER_ANSWER_FAILED: () => F,
						PASSWORD_NOT_SUPPORTED: () => V,
						PASSWORD_REQUIRED: () => U,
						REDIRECTED: () => j,
						RESERVATION_ERROR: () => H,
						SETTINGS_ERROR: () => b,
						VIDEOBRIDGE_NOT_AVAILABLE: () => B
					});
					var s = {};
					n.r(s), n.d(s, {
						AUDIO_INPUT_STATE_CHANGE: () => J,
						AUDIO_UNMUTE_PERMISSIONS_CHANGED: () => G,
						AUTH_STATUS_CHANGED: () => q,
						AV_MODERATION_APPROVED: () => st,
						AV_MODERATION_CHANGED: () => ot,
						AV_MODERATION_PARTICIPANT_APPROVED: () => at,
						AV_MODERATION_PARTICIPANT_REJECTED: () => ct,
						AV_MODERATION_REJECTED: () => rt,
						BEFORE_STATISTICS_DISPOSED: () => K,
						BOT_TYPE_CHANGED: () => et,
						BREAKOUT_ROOMS_MOVE_TO_ROOM: () => dt,
						BREAKOUT_ROOMS_UPDATED: () => lt,
						CONFERENCE_CREATED_TIMESTAMP: () => ae,
						CONFERENCE_ERROR: () => W,
						CONFERENCE_FAILED: () => X,
						CONFERENCE_JOINED: () => Y,
						CONFERENCE_JOIN_IN_PROGRESS: () => z,
						CONFERENCE_LEFT: () => Q,
						CONFERENCE_UNIQUE_ID_SET: () => Z,
						CONNECTION_ESTABLISHED: () => ee,
						CONNECTION_INTERRUPTED: () => te,
						CONNECTION_RESTORED: () => ne,
						DATA_CHANNEL_CLOSED: () => se,
						DATA_CHANNEL_OPENED: () => ie,
						DISPLAY_NAME_CHANGED: () => re,
						DOMINANT_SPEAKER_CHANGED: () => oe,
						DTMF_SUPPORT_CHANGED: () => ce,
						E2EE_VERIFICATION_AVAILABLE: () => ue,
						E2EE_VERIFICATION_COMPLETED: () => pe,
						E2EE_VERIFICATION_READY: () => he,
						ENDPOINT_MESSAGE_RECEIVED: () => de,
						ENDPOINT_STATS_RECEIVED: () => le,
						FORWARDED_SOURCES_CHANGED: () => Se,
						JVB121_STATUS: () => me,
						JitsiConferenceEvents: () => $,
						KICKED: () => fe,
						LAST_N_ENDPOINTS_CHANGED: () => ve,
						LOBBY_USER_JOINED: () => tt,
						LOBBY_USER_LEFT: () => it,
						LOBBY_USER_UPDATED: () => nt,
						LOCK_STATE_CHANGED: () => Ee,
						MEMBERS_ONLY_CHANGED: () => be,
						MESSAGE_RECEIVED: () => Ae,
						METADATA_UPDATED: () => ut,
						NOISY_MIC: () => Ie,
						NON_PARTICIPANT_MESSAGE_RECEIVED: () => Pe,
						NO_AUDIO_INPUT: () => Re,
						P2P_STATUS: () => Ne,
						PARTCIPANT_FEATURES_CHANGED: () => we,
						PARTICIPANT_KICKED: () => ge,
						PARTICIPANT_PROPERTY_CHANGED: () => Oe,
						PARTICIPANT_SOURCE_UPDATED: () => _e,
						PHONE_NUMBER_CHANGED: () => Me,
						PRIVATE_MESSAGE_RECEIVED: () => De,
						PROPERTIES_CHANGED: () => Le,
						RECORDER_STATE_CHANGED: () => ke,
						SERVER_REGION_CHANGED: () => ye,
						STARTED_MUTED: () => Ue,
						START_MUTED_POLICY_CHANGED: () => Ve,
						SUBJECT_CHANGED: () => je,
						SUSPEND_DETECTED: () => He,
						TALK_WHILE_MUTED: () => Be,
						TRACK_ADDED: () => $e,
						TRACK_AUDIO_LEVEL_CHANGED: () => Je,
						TRACK_MUTE_CHANGED: () => Ge,
						TRACK_REMOVED: () => qe,
						TRACK_UNMUTE_REJECTED: () => Ke,
						TRANSCRIPTION_STATUS_CHANGED: () => We,
						USER_JOINED: () => Xe,
						USER_LEFT: () => ze,
						USER_ROLE_CHANGED: () => Ye,
						USER_STATUS_CHANGED: () => Qe,
						VIDEO_SIP_GW_AVAILABILITY_CHANGED: () => xe,
						VIDEO_SIP_GW_SESSION_STATE_CHANGED: () => Fe,
						VIDEO_UNMUTE_PERMISSIONS_CHANGED: () => Ze,
						_MEDIA_SESSION_ACTIVE_CHANGED: () => Ce,
						_MEDIA_SESSION_STARTED: () => Te
					});
					var r = {};
					n.r(r), n.d(r, {
						JitsiTrackEvents: () => St,
						LOCAL_TRACK_STOPPED: () => Et,
						NO_AUDIO_INPUT: () => Rt,
						NO_DATA_FROM_SOURCE: () => At,
						TRACK_AUDIO_LEVEL_CHANGED: () => yt,
						TRACK_AUDIO_OUTPUT_CHANGED: () => Tt,
						TRACK_MUTE_CHANGED: () => Ct,
						TRACK_OWNER_CHANGED: () => Pt,
						TRACK_REMOVED: () => Dt,
						TRACK_STREAMING_STATUS_CHANGED: () => It,
						TRACK_VIDEOTYPE_CHANGED: () => bt
					});
					var o = {};
					n.r(o), n.d(o, {
						CONSTRAINT_FAILED: () => Nt,
						ELECTRON_DESKTOP_PICKER_ERROR: () => Mt,
						ELECTRON_DESKTOP_PICKER_NOT_FOUND: () => Lt,
						GENERAL: () => kt,
						JitsiTrackErrors: () => Ot,
						NOT_FOUND: () => xt,
						PERMISSION_DENIED: () => Ft,
						SCREENSHARING_GENERIC_ERROR: () => Vt,
						SCREENSHARING_USER_CANCELED: () => Ut,
						TIMEOUT: () => jt,
						TRACK_IS_DISPOSED: () => Ht,
						TRACK_NO_STREAM_FOUND: () => Bt,
						UNSUPPORTED_RESOLUTION: () => $t
					});
					var a = {};
					n.r(a), n.d(a, {
						CONNECTION_DISCONNECTED: () => ji,
						CONNECTION_ESTABLISHED: () => Hi,
						CONNECTION_FAILED: () => Bi,
						DISPLAY_NAME_REQUIRED: () => Ji,
						JitsiConnectionEvents: () => Ui,
						WRONG_STATE: () => $i
					});
					var c = {};
					n.r(c), n.d(c, {
						CONNECTION_DROPPED_ERROR: () => qi,
						JitsiConnectionErrors: () => Gi,
						OTHER_ERROR: () => Ki,
						PASSWORD_REQUIRED: () => Wi,
						SERVER_ERROR: () => Xi
					});
					var d = {};
					n.r(d), n.d(d, {
						JitsiTranscriptionStatus: () => Zs,
						OFF: () => tr,
						ON: () => er
					});
					var l = {};
					n.r(l), n.d(l, {
						fixNegotiationNeeded: () => Ya,
						shimAddTrackRemoveTrack: () => Xa,
						shimAddTrackRemoveTrackWithNative: () => Wa,
						shimGetDisplayMedia: () => Ba,
						shimGetSendersWithDtmf: () => Ga,
						shimGetStats: () => qa,
						shimGetUserMedia: () => Ha,
						shimMediaStream: () => $a,
						shimOnTrack: () => Ja,
						shimPeerConnection: () => za,
						shimSenderReceiverGetStats: () => Ka
					});
					var u = {};
					n.r(u), n.d(u, {
						shimAddTransceiver: () => oc,
						shimCreateAnswer: () => dc,
						shimCreateOffer: () => cc,
						shimGetDisplayMedia: () => Za,
						shimGetParameters: () => ac,
						shimGetUserMedia: () => Qa,
						shimOnTrack: () => ec,
						shimPeerConnection: () => tc,
						shimRTCDataChannel: () => rc,
						shimReceiverGetStats: () => ic,
						shimRemoveStream: () => sc,
						shimSenderGetStats: () => nc
					});
					var h = {};
					n.r(h), n.d(h, {
						shimAudioContext: () => vc,
						shimCallbacksAPI: () => hc,
						shimConstraints: () => mc,
						shimCreateOfferLegacy: () => _c,
						shimGetUserMedia: () => pc,
						shimLocalStreamsAPI: () => lc,
						shimRTCIceServerUrls: () => fc,
						shimRemoteStreamsAPI: () => uc,
						shimTrackEventTransceiver: () => gc
					});
					var p = {};
					n.r(p), n.d(p, {
						removeExtmapAllowMixed: () => Ac,
						shimAddIceCandidateNullOrEmpty: () => Rc,
						shimConnectionState: () => bc,
						shimMaxMessageSize: () => Tc,
						shimParameterlessSetLocalDescription: () => Ic,
						shimRTCIceCandidate: () => yc,
						shimSendThrowTypeError: () => Cc
					});
					var m = {};
					n.r(m), n.d(m, {
						ConnectionQualityEvents: () => Zd,
						LOCAL_STATS_UPDATED: () => sl,
						REMOTE_STATS_UPDATED: () => rl
					});
					var f = {};
					n.r(f), n.d(f, {
						AUDIO_INPUT_STATE_CHANGE: () => _l,
						DETECTOR_STATE_CHANGE: () => gl,
						DetectionEvents: () => fl,
						NO_AUDIO_INPUT: () => vl,
						VAD_NOISY_DEVICE: () => Sl,
						VAD_REPORT_PUBLISHED: () => El,
						VAD_SCORE_PUBLISHED: () => yl,
						VAD_TALK_WHILE_MUTED: () => Tl
					});
					var g = {};
					n.r(g), n.d(g, {
						E2E_RTT_CHANGED: () => Nl,
						E2ePingEvents: () => Ol
					});
					var _ = {};
					n.r(_), n.d(_, {
						ERROR_NO_CONNECTION: () => Uu,
						ERROR_SESSION_EXISTS: () => ju,
						STATE_FAILED: () => Vu,
						STATE_OFF: () => ku,
						STATE_ON: () => Lu,
						STATE_PENDING: () => xu,
						STATE_RETRYING: () => Fu,
						STATUS_AVAILABLE: () => Ou,
						STATUS_BUSY: () => Mu,
						STATUS_UNDEFINED: () => Nu,
						VideoSIPGWErrorConstants: () => wu,
						VideoSIPGWStateConstants: () => Du,
						VideoSIPGWStatusConstants: () => Pu
					});
					var v = {};
					n.r(v), n.d(v, {
						DEVICE_LIST_CHANGED: () => nh,
						JitsiMediaDevicesEvents: () => th,
						PERMISSIONS_CHANGED: () => ih,
						PERMISSION_PROMPT_IS_SHOWN: () => sh,
						SLOW_GET_USER_MEDIA: () => rh
					});
					var S = n(5810),
						E = n.n(S);
					let y;
					! function(e) {
						e.AUTHENTICATION_REQUIRED = "conference.authenticationRequired", e.CHAT_ERROR = "conference.chatError", e.SETTINGS_ERROR = "conference.settingsError", e.CONFERENCE_DESTROYED = "conference.destroyed", e.CONFERENCE_MAX_USERS = "conference.max_users", e.CONNECTION_ERROR = "conference.connectionError", e.CONFERENCE_RESTARTED = "conference.restarted", e.NOT_ALLOWED_ERROR = "conference.connectionError.notAllowed", e.MEMBERS_ONLY_ERROR = "conference.connectionError.membersOnly", e.CONFERENCE_ACCESS_DENIED = "conference.connectionError.accessDenied", e.FOCUS_DISCONNECTED = "conference.focusDisconnected", e.FOCUS_LEFT = "conference.focusLeft", e.GRACEFUL_SHUTDOWN = "conference.gracefulShutdown", e.ICE_FAILED = "conference.iceFailed", e.INCOMPATIBLE_SERVER_VERSIONS = "conference.incompatible_server_versions", e.OFFER_ANSWER_FAILED = "conference.offerAnswerFailed", e.PASSWORD_NOT_SUPPORTED = "conference.passwordNotSupported", e.PASSWORD_REQUIRED = "conference.passwordRequired", e.REDIRECTED = "conference.redirected", e.RESERVATION_ERROR = "conference.reservationError", e.VIDEOBRIDGE_NOT_AVAILABLE = "conference.videobridgeNotAvailable"
					}(y || (y = {}));
					const T = y.AUTHENTICATION_REQUIRED,
						C = y.CHAT_ERROR,
						b = y.SETTINGS_ERROR,
						A = y.CONFERENCE_DESTROYED,
						R = y.CONFERENCE_MAX_USERS,
						I = y.CONNECTION_ERROR,
						P = y.CONFERENCE_RESTARTED,
						D = y.NOT_ALLOWED_ERROR,
						w = y.MEMBERS_ONLY_ERROR,
						O = y.CONFERENCE_ACCESS_DENIED,
						N = y.FOCUS_DISCONNECTED,
						M = y.FOCUS_LEFT,
						L = y.GRACEFUL_SHUTDOWN,
						k = y.ICE_FAILED,
						x = y.INCOMPATIBLE_SERVER_VERSIONS,
						F = y.OFFER_ANSWER_FAILED,
						V = y.PASSWORD_NOT_SUPPORTED,
						U = y.PASSWORD_REQUIRED,
						j = y.REDIRECTED,
						H = y.RESERVATION_ERROR,
						B = y.VIDEOBRIDGE_NOT_AVAILABLE;
					let $;
					! function(e) {
						e.AUDIO_INPUT_STATE_CHANGE = "conference.audio_input_state_changed", e.AUDIO_UNMUTE_PERMISSIONS_CHANGED = "conference.audio_unmute_permissions_changed", e.AUTH_STATUS_CHANGED = "conference.auth_status_changed", e.BEFORE_STATISTICS_DISPOSED = "conference.beforeStatisticsDisposed", e.CONFERENCE_ERROR = "conference.error", e.CONFERENCE_FAILED = "conference.failed", e.CONFERENCE_JOIN_IN_PROGRESS = "conference.join_in_progress", e.CONFERENCE_JOINED = "conference.joined", e.CONFERENCE_LEFT = "conference.left", e.CONFERENCE_UNIQUE_ID_SET = "conference.unique_id_set", e.CONNECTION_ESTABLISHED = "conference.connectionEstablished", e.CONNECTION_INTERRUPTED = "conference.connectionInterrupted", e.CONNECTION_RESTORED = "conference.connectionRestored", e.DATA_CHANNEL_OPENED = "conference.dataChannelOpened", e.DATA_CHANNEL_CLOSED = "conference.dataChannelClosed", e.DISPLAY_NAME_CHANGED = "conference.displayNameChanged", e.DOMINANT_SPEAKER_CHANGED = "conference.dominantSpeaker", e.CONFERENCE_CREATED_TIMESTAMP = "conference.createdTimestamp", e.DTMF_SUPPORT_CHANGED = "conference.dtmfSupportChanged", e.ENDPOINT_MESSAGE_RECEIVED = "conference.endpoint_message_received", e.ENDPOINT_STATS_RECEIVED = "conference.endpoint_stats_received", e.JVB121_STATUS = "conference.jvb121Status", e.KICKED = "conference.kicked", e.PARTICIPANT_KICKED = "conference.participant_kicked", e.LAST_N_ENDPOINTS_CHANGED = "conference.lastNEndpointsChanged", e.FORWARDED_SOURCES_CHANGED = "conference.forwardedSourcesChanged", e.LOCK_STATE_CHANGED = "conference.lock_state_changed", e.SERVER_REGION_CHANGED = "conference.server_region_changed", e._MEDIA_SESSION_STARTED = "conference.media_session.started", e._MEDIA_SESSION_ACTIVE_CHANGED = "conference.media_session.active_changed", e.MEMBERS_ONLY_CHANGED = "conference.membersOnlyChanged", e.MESSAGE_RECEIVED = "conference.messageReceived", e.NO_AUDIO_INPUT = "conference.no_audio_input", e.NOISY_MIC = "conference.noisy_mic", e.NON_PARTICIPANT_MESSAGE_RECEIVED = "conference.non_participant_message_received", e.PRIVATE_MESSAGE_RECEIVED = "conference.privateMessageReceived", e.PARTCIPANT_FEATURES_CHANGED = "conference.partcipant_features_changed", e.PARTICIPANT_PROPERTY_CHANGED = "conference.participant_property_changed", e.PARTICIPANT_SOURCE_UPDATED = "conference.participant_source_updated", e.P2P_STATUS = "conference.p2pStatus", e.PHONE_NUMBER_CHANGED = "conference.phoneNumberChanged", e.PROPERTIES_CHANGED = "conference.propertiesChanged", e.RECORDER_STATE_CHANGED = "conference.recorderStateChanged", e.VIDEO_SIP_GW_AVAILABILITY_CHANGED = "conference.videoSIPGWAvailabilityChanged", e.VIDEO_SIP_GW_SESSION_STATE_CHANGED = "conference.videoSIPGWSessionStateChanged", e.START_MUTED_POLICY_CHANGED = "conference.start_muted_policy_changed", e.STARTED_MUTED = "conference.started_muted", e.SUBJECT_CHANGED = "conference.subjectChanged", e.SUSPEND_DETECTED = "conference.suspendDetected", e.TALK_WHILE_MUTED = "conference.talk_while_muted", e.TRACK_ADDED = "conference.trackAdded", e.TRACK_AUDIO_LEVEL_CHANGED = "conference.audioLevelsChanged", e.TRACK_MUTE_CHANGED = "conference.trackMuteChanged", e.TRACK_REMOVED = "conference.trackRemoved", e.TRACK_UNMUTE_REJECTED = "conference.trackUnmuteRejected", e.TRANSCRIPTION_STATUS_CHANGED = "conference.transcriptionStatusChanged", e.USER_JOINED = "conference.userJoined", e.USER_LEFT = "conference.userLeft", e.USER_ROLE_CHANGED = "conference.roleChanged", e.USER_STATUS_CHANGED = "conference.statusChanged", e.VIDEO_UNMUTE_PERMISSIONS_CHANGED = "conference.video_unmute_permissions_changed", e.BOT_TYPE_CHANGED = "conference.bot_type_changed", e.LOBBY_USER_JOINED = "conference.lobby.userJoined", e.LOBBY_USER_UPDATED = "conference.lobby.userUpdated", e.LOBBY_USER_LEFT = "conference.lobby.userLeft", e.AV_MODERATION_APPROVED = "conference.av_moderation.approved", e.AV_MODERATION_REJECTED = "conference.av_moderation.rejected", e.AV_MODERATION_CHANGED = "conference.av_moderation.changed", e.AV_MODERATION_PARTICIPANT_APPROVED = "conference.av_moderation.participant.approved", e.AV_MODERATION_PARTICIPANT_REJECTED = "conference.av_moderation.participant.rejected", e.BREAKOUT_ROOMS_MOVE_TO_ROOM = "conference.breakout-rooms.move-to-room", e.BREAKOUT_ROOMS_UPDATED = "conference.breakout-rooms.updated", e.METADATA_UPDATED = "conference.metadata.updated", e.E2EE_VERIFICATION_AVAILABLE = "conference.e2ee.verification.available", e.E2EE_VERIFICATION_READY = "conference.e2ee.verification.ready", e.E2EE_VERIFICATION_COMPLETED = "conference.e2ee.verification.completed"
					}($ || ($ = {}));
					const J = $.AUDIO_INPUT_STATE_CHANGE,
						G = $.AUDIO_UNMUTE_PERMISSIONS_CHANGED,
						q = $.AUTH_STATUS_CHANGED,
						K = $.BEFORE_STATISTICS_DISPOSED,
						W = $.CONFERENCE_ERROR,
						X = $.CONFERENCE_FAILED,
						z = $.CONFERENCE_JOIN_IN_PROGRESS,
						Y = $.CONFERENCE_JOINED,
						Q = $.CONFERENCE_LEFT,
						Z = $.CONFERENCE_UNIQUE_ID_SET,
						ee = $.CONNECTION_ESTABLISHED,
						te = $.CONNECTION_INTERRUPTED,
						ne = $.CONNECTION_RESTORED,
						ie = $.DATA_CHANNEL_OPENED,
						se = $.DATA_CHANNEL_CLOSED,
						re = $.DISPLAY_NAME_CHANGED,
						oe = $.DOMINANT_SPEAKER_CHANGED,
						ae = $.CONFERENCE_CREATED_TIMESTAMP,
						ce = $.DTMF_SUPPORT_CHANGED,
						de = $.ENDPOINT_MESSAGE_RECEIVED,
						le = $.ENDPOINT_STATS_RECEIVED,
						ue = $.E2EE_VERIFICATION_AVAILABLE,
						he = $.E2EE_VERIFICATION_READY,
						pe = $.E2EE_VERIFICATION_COMPLETED,
						me = $.JVB121_STATUS,
						fe = $.KICKED,
						ge = $.PARTICIPANT_KICKED,
						_e = $.PARTICIPANT_SOURCE_UPDATED,
						ve = $.LAST_N_ENDPOINTS_CHANGED,
						Se = $.FORWARDED_SOURCES_CHANGED,
						Ee = $.LOCK_STATE_CHANGED,
						ye = $.SERVER_REGION_CHANGED,
						Te = $._MEDIA_SESSION_STARTED,
						Ce = $._MEDIA_SESSION_ACTIVE_CHANGED,
						be = $.MEMBERS_ONLY_CHANGED,
						Ae = $.MESSAGE_RECEIVED,
						Re = $.NO_AUDIO_INPUT,
						Ie = $.NOISY_MIC,
						Pe = $.NON_PARTICIPANT_MESSAGE_RECEIVED,
						De = $.PRIVATE_MESSAGE_RECEIVED,
						we = $.PARTCIPANT_FEATURES_CHANGED,
						Oe = $.PARTICIPANT_PROPERTY_CHANGED,
						Ne = $.P2P_STATUS,
						Me = $.PHONE_NUMBER_CHANGED,
						Le = $.PROPERTIES_CHANGED,
						ke = $.RECORDER_STATE_CHANGED,
						xe = $.VIDEO_SIP_GW_AVAILABILITY_CHANGED,
						Fe = $.VIDEO_SIP_GW_SESSION_STATE_CHANGED,
						Ve = $.START_MUTED_POLICY_CHANGED,
						Ue = $.STARTED_MUTED,
						je = $.SUBJECT_CHANGED,
						He = $.SUSPEND_DETECTED,
						Be = $.TALK_WHILE_MUTED,
						$e = $.TRACK_ADDED,
						Je = $.TRACK_AUDIO_LEVEL_CHANGED,
						Ge = $.TRACK_MUTE_CHANGED,
						qe = $.TRACK_REMOVED,
						Ke = $.TRACK_UNMUTE_REJECTED,
						We = $.TRANSCRIPTION_STATUS_CHANGED,
						Xe = $.USER_JOINED,
						ze = $.USER_LEFT,
						Ye = $.USER_ROLE_CHANGED,
						Qe = $.USER_STATUS_CHANGED,
						Ze = $.VIDEO_UNMUTE_PERMISSIONS_CHANGED,
						et = $.BOT_TYPE_CHANGED,
						tt = $.LOBBY_USER_JOINED,
						nt = $.LOBBY_USER_UPDATED,
						it = $.LOBBY_USER_LEFT,
						st = $.AV_MODERATION_APPROVED,
						rt = $.AV_MODERATION_REJECTED,
						ot = $.AV_MODERATION_CHANGED,
						at = $.AV_MODERATION_PARTICIPANT_APPROVED,
						ct = $.AV_MODERATION_PARTICIPANT_REJECTED,
						dt = $.BREAKOUT_ROOMS_MOVE_TO_ROOM,
						lt = $.BREAKOUT_ROOMS_UPDATED,
						ut = $.METADATA_UPDATED;
					var ht = n(6857),
						pt = n.n(ht),
						mt = n(8387),
						ft = n.n(mt),
						gt = n(7047),
						_t = n.n(gt),
						vt = n(6033);
					let St;
					! function(e) {
						e.LOCAL_TRACK_STOPPED = "track.stopped", e.TRACK_AUDIO_LEVEL_CHANGED = "track.audioLevelsChanged", e.TRACK_AUDIO_OUTPUT_CHANGED = "track.audioOutputChanged", e.TRACK_MUTE_CHANGED = "track.trackMuteChanged", e.TRACK_VIDEOTYPE_CHANGED = "track.videoTypeChanged", e.NO_DATA_FROM_SOURCE = "track.no_data_from_source", e.NO_AUDIO_INPUT = "track.no_audio_input", e.TRACK_STREAMING_STATUS_CHANGED = "track.streaming_status_changed", e.TRACK_OWNER_CHANGED = "track.owner_changed", e.TRACK_REMOVED = "track.removed"
					}(St || (St = {}));
					const Et = St.LOCAL_TRACK_STOPPED,
						yt = St.TRACK_AUDIO_LEVEL_CHANGED,
						Tt = St.TRACK_AUDIO_OUTPUT_CHANGED,
						Ct = St.TRACK_MUTE_CHANGED,
						bt = St.TRACK_VIDEOTYPE_CHANGED,
						At = St.NO_DATA_FROM_SOURCE,
						Rt = St.NO_AUDIO_INPUT,
						It = St.TRACK_STREAMING_STATUS_CHANGED,
						Pt = St.TRACK_OWNER_CHANGED,
						Dt = St.TRACK_REMOVED,
						wt = "https://api.callstats.io/static/callstats-ws.min.js";
					let Ot;
					! function(e) {
						e.CONSTRAINT_FAILED = "gum.constraint_failed", e.ELECTRON_DESKTOP_PICKER_ERROR = "gum.electron_desktop_picker_error", e.ELECTRON_DESKTOP_PICKER_NOT_FOUND = "gum.electron_desktop_picker_not_found", e.GENERAL = "gum.general", e.NOT_FOUND = "gum.not_found", e.PERMISSION_DENIED = "gum.permission_denied", e.SCREENSHARING_GENERIC_ERROR = "gum.screensharing_generic_error", e.SCREENSHARING_USER_CANCELED = "gum.screensharing_user_canceled", e.TIMEOUT = "gum.timeout", e.TRACK_IS_DISPOSED = "track.track_is_disposed", e.TRACK_NO_STREAM_FOUND = "track.no_stream_found", e.UNSUPPORTED_RESOLUTION = "gum.unsupported_resolution"
					}(Ot || (Ot = {}));
					const Nt = Ot.CONSTRAINT_FAILED,
						Mt = Ot.ELECTRON_DESKTOP_PICKER_ERROR,
						Lt = Ot.ELECTRON_DESKTOP_PICKER_NOT_FOUND,
						kt = Ot.GENERAL,
						xt = Ot.NOT_FOUND,
						Ft = Ot.PERMISSION_DENIED,
						Vt = Ot.SCREENSHARING_GENERIC_ERROR,
						Ut = Ot.SCREENSHARING_USER_CANCELED,
						jt = Ot.TIMEOUT,
						Ht = Ot.TRACK_IS_DISPOSED,
						Bt = Ot.TRACK_NO_STREAM_FOUND,
						$t = Ot.UNSUPPORTED_RESOLUTION,
						Jt = {};

					function Gt(e, t, n) {
						if ("object" == typeof e && void 0 !== e.name) switch (this.gum = {
							error: e,
							constraints: t,
							devices: n && Array.isArray(n) ? n.slice(0) : void 0
						}, e.name) {
							case "NotAllowedError":
							case "PermissionDeniedError":
							case "SecurityError":
								this.name = Ft, this.message = Jt[this.name] + (this.gum.devices || []).join(", ");
								break;
							case "DevicesNotFoundError":
							case "NotFoundError":
								this.name = xt, this.message = Jt[this.name] + (this.gum.devices || []).join(", ");
								break;
							case "ConstraintNotSatisfiedError":
							case "OverconstrainedError": {
								const i = e.constraintName || e.constraint;
								t && t.video && (!n || n.indexOf("video") > -1) && ("minWidth" === i || "maxWidth" === i || "minHeight" === i || "maxHeight" === i || "width" === i || "height" === i || "deviceId" === i) ? (this.name = $t, this.message = Jt[this.name] + function(e, t) {
									if (t && t.video && t.video.mandatory) switch (e) {
										case "width":
											return t.video.mandatory.minWidth;
										case "height":
											return t.video.mandatory.minHeight;
										default:
											return t.video.mandatory[e] || ""
									}
									return ""
								}(i, t)) : (this.name = Nt, this.message = Jt[this.name] + e.constraintName);
								break
							}
							default:
								this.name = kt, this.message = e.message || Jt[this.name]
						} else {
							if ("string" != typeof e) throw new Error("Invalid arguments");
							Jt[e] ? (this.name = e, this.message = t || Jt[e]) : this.message = e
						}
						this.stack = e.stack || (new Error).stack
					}
					Jt[$t] = "Video resolution is not supported: ", Jt[Ut] = "User canceled screen sharing prompt", Jt[Vt] = "Unknown error from screensharing", Jt[Mt] = "Unkown error from desktop picker", Jt[Lt] = "Failed to detect desktop picker", Jt[kt] = "Generic getUserMedia error", Jt[Ft] = "User denied permission to use device(s): ", Jt[xt] = "Requested device(s) was/were not found: ", Jt[Nt] = "Constraint could not be satisfied: ", Jt[jt] = "Could not start media source. Timeout occured!", Jt[Ht] = "Track has been already disposed", Jt[Bt] = "Track does not have an associated Media Stream", Gt.prototype = Object.create(Error.prototype), Gt.prototype.constructor = Gt;
					const qt = Gt;
					let Kt;
					! function(e) {
						e.TYPE_OPERATIONAL = "operational", e.TYPE_PAGE = "page", e.TYPE_TRACK = "track", e.TYPE_UI = "ui", e.ACTION_JINGLE_RESTART = "restart", e.ACTION_JINGLE_SA_TIMEOUT = "session-accept.timeout", e.ACTION_JINGLE_SI_RECEIVED = "session-initiate.received", e.ACTION_JINGLE_SI_TIMEOUT = "session-initiate.timeout", e.ACTION_JINGLE_TERMINATE = "terminate", e.ACTION_JINGLE_TR_RECEIVED = "transport-replace.received", e.ACTION_JINGLE_TR_SUCCESS = "transport-replace.success", e.ACTION_P2P_DECLINED = "decline", e.ACTION_P2P_ESTABLISHED = "established", e.ACTION_P2P_FAILED = "failed", e.ACTION_P2P_SWITCH_TO_JVB = "switch.to.jvb", e.AVAILABLE_DEVICE = "available.device", e.CONNECTION_DISCONNECTED = "connection.disconnected", e.FEEDBACK = "feedback", e.ICE_DURATION = "ice.duration", e.ICE_ESTABLISHMENT_DURATION_DIFF = "ice.establishment.duration.diff", e.ICE_STATE_CHANGED = "ice.state.changed", e.NO_BYTES_SENT = "track.no-bytes-sent", e.TRACK_UNMUTED = "track.unmuted"
					}(Kt || (Kt = {}));
					const Wt = Kt.TYPE_OPERATIONAL,
						Xt = Kt.TYPE_PAGE,
						zt = Kt.TYPE_TRACK,
						Yt = Kt.TYPE_UI,
						Qt = Kt.ACTION_JINGLE_RESTART,
						Zt = Kt.ACTION_JINGLE_SA_TIMEOUT,
						en = Kt.ACTION_JINGLE_SI_RECEIVED,
						tn = Kt.ACTION_JINGLE_SI_TIMEOUT,
						nn = Kt.ACTION_JINGLE_TERMINATE,
						sn = Kt.ACTION_JINGLE_TR_RECEIVED,
						rn = Kt.ACTION_JINGLE_TR_SUCCESS,
						on = Kt.ACTION_P2P_DECLINED,
						an = Kt.ACTION_P2P_ESTABLISHED,
						cn = Kt.ACTION_P2P_FAILED,
						dn = Kt.ACTION_P2P_SWITCH_TO_JVB,
						ln = Kt.AVAILABLE_DEVICE,
						un = Kt.CONNECTION_DISCONNECTED,
						hn = Kt.FEEDBACK,
						pn = Kt.ICE_DURATION,
						mn = Kt.ICE_ESTABLISHMENT_DURATION_DIFF,
						fn = Kt.ICE_STATE_CHANGED,
						gn = Kt.NO_BYTES_SENT,
						_n = Kt.TRACK_UNMUTED,
						vn = (e, t) => ({
							action: e,
							attributes: t,
							source: "conference",
							type: Kt.TYPE_OPERATIONAL
						}),
						Sn = (e, t) => ({
							action: "connection.stage.reached",
							actionSubject: e,
							attributes: t,
							source: "connection.stage.reached",
							type: Kt.TYPE_OPERATIONAL
						}),
						En = function(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
							return {
								type: Kt.TYPE_OPERATIONAL,
								source: "get.user.media",
								action: e,
								attributes: t
							}
						},
						yn = function(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
							return {
								type: Kt.TYPE_OPERATIONAL,
								action: e,
								source: "jingle",
								attributes: t
							}
						},
						Tn = function(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
							return {
								type: Kt.TYPE_OPERATIONAL,
								action: e,
								source: "p2p",
								attributes: t
							}
						},
						Cn = e => ({
							type: Kt.TYPE_OPERATIONAL,
							action: "remotely.muted",
							mediaType: e
						}),
						bn = e => ({
							type: Kt.TYPE_OPERATIONAL,
							action: "rtp.stats",
							attributes: e
						});
					let An;
					! function(e) {
						e.AUDIO_LEVEL = "statistics.audioLevel", e.BEFORE_DISPOSED = "statistics.before_disposed", e.BYTE_SENT_STATS = "statistics.byte_sent_stats", e.CONNECTION_STATS = "statistics.connectionstats", e.LONG_TASKS_STATS = "statistics.long_tasks_stats"
					}(An || (An = {}));
					const Rn = An.AUDIO_LEVEL,
						In = An.BEFORE_DISPOSED,
						Pn = An.BYTE_SENT_STATS,
						Dn = An.CONNECTION_STATS,
						wn = An.LONG_TASKS_STATS;
					n(3478);
					var On = n(7032);
					const Nn = "chrome",
						Mn = "opera",
						Ln = "firefox",
						kn = "iexplorer",
						xn = "safari",
						Fn = "nwjs",
						Vn = "electron",
						Un = "react-native",
						jn = "unknown",
						Hn = {
							Chrome: Nn,
							Chromium: Nn,
							Opera: Mn,
							Firefox: Ln,
							"Internet Explorer": kn,
							Safari: xn
						};

					function Bn() {
						const e = navigator.userAgent;
						if (e.match(/Electron/)) {
							const t = e.match(/Electron(?:\s|\/)([\d.]+)/)[1];
							return {
								name: Vn,
								version: t
							}
						}
						if (void 0 !== window.JitsiMeetElectron) return {
							name: Vn,
							version: void 0
						}
					}

					function $n() {
						const e = navigator.userAgent;
						if (e.match(/JitsiMeetNW/)) {
							const t = e.match(/JitsiMeetNW\/([\d.]+)/)[1];
							return {
								name: Fn,
								version: t
							}
						}
					}

					function Jn() {
						const e = navigator.userAgent.match(/\b(react[ \t_-]*native)(?:\/(\S+))?/i);
						let t;
						if (e || "ReactNative" === navigator.product) {
							let n;
							return e && e.length > 2 && (n = e[1], t = e[2]), n || (n = "react-native"), t || (t = "unknown"), {
								name: Un,
								version: t
							}
						}
					}
					class Gn extends ht {
						constructor() {
							var e, t;
							super(...arguments), t = {}, (e = "_storage") in this ? Object.defineProperty(this, e, {
								value: t,
								enumerable: !0,
								configurable: !0,
								writable: !0
							}) : this[e] = t
						}
						clear() {
							this._storage = {}
						}
						get length() {
							return Object.keys(this._storage).length
						}
						getItem(e) {
							return this._storage[e]
						}
						setItem(e, t) {
							this._storage[e] = t
						}
						removeItem(e) {
							delete this._storage[e]
						}
						key(e) {
							const t = Object.keys(this._storage);
							if (!(t.length <= e)) return t[e]
						}
						serialize() {
							return JSON.stringify(this._storage)
						}
					}
					const qn = new class extends ht {
							constructor() {
								super();
								try {
									this._storage = window.localStorage, this._localStorageDisabled = !1
								} catch (e) {}
								this._storage || (console.warn("Local storage is disabled."), this._storage = new Gn, this._localStorageDisabled = !0)
							}
							isLocalStorageDisabled() {
								return this._localStorageDisabled
							}
							clear() {
								this._storage.clear(), this.emit("changed")
							}
							get length() {
								return this._storage.length
							}
							getItem(e) {
								return this._storage.getItem(e)
							}
							setItem(e, t) {
								let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
								this._storage.setItem(e, t), n || this.emit("changed")
							}
							removeItem(e) {
								this._storage.removeItem(e), this.emit("changed")
							}
							key(e) {
								return this._storage.key(e)
							}
							serialize() {
								if (this.isLocalStorageDisabled()) return this._storage.serialize();
								const e = this._storage.length,
									t = {};
								for (let n = 0; n < e; n++) {
									const e = this._storage.key(n);
									t[e] = this._storage.getItem(e)
								}
								return JSON.stringify(t)
							}
						},
						Kn = (0, S.getLogger)("modules/browser/BrowserCapabilities.js"),
						Wn = new class extends class {
							constructor(e) {
								let t, n;
								if (this._bowser = On.getParser(navigator.userAgent), void 0 === e) {
									const e = function(e) {
										let t;
										const n = [Jn, Bn, $n];
										for (let e = 0; e < n.length; e++)
											if (t = n[e](), t) return t;
										const i = e.getBrowserName();
										return i in Hn ? {
											name: Hn[i],
											version: e.getBrowserVersion()
										} : (t = function() {
											const e = navigator.userAgent,
												t = {
													name: jn,
													version: void 0
												};
											if (e.match(/Chrome/) && !e.match(/Edge/))
												if (e.match(/Edg(A?)/)) {
													const n = e.match(/Chrome\/([\d.]+)/)[1];
													Number.parseInt(n, 10) > 72 && (t.name = Nn, t.version = n)
												} else t.name = Nn, t.version = e.match(/Chrome\/([\d.]+)/)[1];
											return t
										}(), t || {
											name: jn,
											version: void 0
										})
									}(this._bowser);
									t = e.name, n = e.version
								} else e.name in Hn ? (t = Hn[e.name], n = e.version) : (t = jn, n = void 0);
								this._name = t, this._version = n
							}
							getName() {
								return this._name
							}
							isChrome() {
								return this._name === Nn
							}
							isOpera() {
								return this._name === Mn
							}
							isFirefox() {
								return this._name === Ln
							}
							isIExplorer() {
								return this._name === kn
							}
							isSafari() {
								return this._name === xn
							}
							isNWJS() {
								return this._name === Fn
							}
							isElectron() {
								return this._name === Vn
							}
							isReactNative() {
								return this._name === Un
							}
							getVersion() {
								return this._version
							}
							_checkCondition(e) {
								if (this._version) return this._bowser.satisfies(e)
							}
							isVersionGreaterThan(e) {
								return this._checkCondition({
									[this._name]: `>${e}`
								})
							}
							isVersionLessThan(e) {
								return this._checkCondition({
									[this._name]: `<${e}`
								})
							}
							isVersionEqualTo(e) {
								return this._checkCondition({
									[this._name]: `~${e}`
								})
							}
						} {
							constructor() {
								super(), Kn.info(`This appears to be ${this.getName()}, ver: ${this.getVersion()}`)
							}
							doesVideoMuteByStreamRemove() {
								return this.isChromiumBased() || this.isWebKitBased() || this.isFirefox()
							}
							isChromiumBased() {
								return (this.isChrome() || this.isElectron() || this.isNWJS() || this.isOpera()) && !this.isWebKitBased()
							}
							isIosBrowser() {
								const {
									userAgent: e,
									maxTouchPoints: t,
									platform: n
								} = navigator;
								return Boolean(e.match(/iP(ad|hone|od)/i)) || t && t > 2 && /MacIntel/.test(n)
							}
							isWebKitBased() {
								return this._bowser.isEngine("webkit") && void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getUserMedia && void 0 !== window.RTCRtpTransceiver && Object.keys(RTCRtpTransceiver.prototype).indexOf("currentDirection") > -1
							}
							isTwa() {
								return "matchMedia" in window && window.matchMedia("(display-mode:standalone)").matches
							}
							isSupported() {
								return !(this.isSafari() && this._getSafariVersion() < 14) && (this.isChromiumBased() && this._getChromiumBasedVersion() >= 72 || this.isFirefox() || this.isReactNative() || this.isWebKitBased())
							}
							isSupportedAndroidBrowser() {
								return this.isChromiumBased() || this.isFirefox()
							}
							isSupportedIOSBrowser() {
								return this._getIOSVersion() >= 14
							}
							isUserInteractionRequiredForUnmute() {
								return this.isFirefox() && this.isVersionLessThan("68")
							}
							supportsVideoMuteOnConnInterrupted() {
								return this.isChromiumBased() || this.isReactNative()
							}
							supportsBandwidthStatistics() {
								return !this.isFirefox() && !this.isWebKitBased()
							}
							supportsCodecPreferences() {
								return Boolean(window.RTCRtpTransceiver && "setCodecPreferences" in window.RTCRtpTransceiver.prototype && window.RTCRtpReceiver && void 0 !== window.RTCRtpReceiver.getCapabilities) && !this.isWebKitBased()
							}
							supportsDeviceChangeEvent() {
								return navigator.mediaDevices && void 0 !== navigator.mediaDevices.ondevicechange && void 0 !== navigator.mediaDevices.addEventListener
							}
							supportsPerformanceObserver() {
								return void 0 !== window.PerformanceObserver && PerformanceObserver.supportedEntryTypes.indexOf("longtask") > -1
							}
							supportsReceiverStats() {
								return void 0 !== window.RTCRtpReceiver && Object.keys(RTCRtpReceiver.prototype).indexOf("getSynchronizationSources") > -1 && !this.isWebKitBased()
							}
							supportsRTTStatistics() {
								return !this.isFirefox()
							}
							supportsVP9() {
								return this.isChromiumBased() || this.isReactNative()
							}
							usesSdpMungingForSimulcast() {
								return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased()
							}
							usesRidsForSimulcast() {
								return !1
							}
							supportsGetDisplayMedia() {
								return void 0 !== navigator.getDisplayMedia || void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getDisplayMedia
							}
							supportsEncodedTransform() {
								return Boolean(window.RTCRtpScriptTransform)
							}
							supportsInsertableStreams() {
								if (void 0 === window.RTCRtpSender || !window.RTCRtpSender.prototype.createEncodedStreams) return !1;
								const e = new ReadableStream;
								try {
									return window.postMessage(e, "*", [e]), !0
								} catch {
									return !1
								}
							}
							supportsAudioRed() {
								return Boolean(window.RTCRtpSender && window.RTCRtpSender.getCapabilities && window.RTCRtpSender.getCapabilities("audio").codecs.some((e => "audio/red" === e.mimeType)) && window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("audio").codecs.some((e => "audio/red" === e.mimeType)))
							}
							supportsUnifiedPlan() {
								return !(this.isElectron() && this._getChromiumBasedVersion() < 96)
							}
							supportsVADDetection() {
								return this.isChromiumBased()
							}
							supportsRTX() {
								return !(this.isFirefox() && this.isVersionLessThan("96"))
							}
							_getChromiumBasedVersion() {
								if (this.isChromiumBased()) {
									if (this.isNWJS()) return Number.parseInt(process.versions.chromium, 10);
									const e = navigator.userAgent;
									if (e.match(/Chrome/)) return Number.parseInt(e.match(/Chrome\/([\d.]+)/)[1], 10)
								}
								return -1
							}
							_getSafariVersion() {
								return this.isSafari() ? Number.parseInt(this.getVersion(), 10) : -1
							}
							_getIOSVersion() {
								return this.isWebKitBased() ? Number.parseInt(this.getVersion(), 10) : -1
							}
						};
					var Xn = n(549),
						zn = n.n(Xn);
					const Yn = (0, S.getLogger)("modules/statistics/AnalyticsAdapter.js"),
						Qn = new class {
							constructor() {
								this.reset()
							}
							reset() {
								this.disposed = !1, this.analyticsHandlers = new Set, this.cache = [], this.permanentProperties = {}, this.conferenceName = "", this.addPermanentProperties({
									user_agent: navigator.userAgent,
									browser_name: Wn.getName()
								})
							}
							dispose() {
								Yn.warn("Disposing of analytics adapter."), this.analyticsHandlers && this.analyticsHandlers.size > 0 && this.analyticsHandlers.forEach((e => {
									"function" == typeof e.dispose && e.dispose()
								})), this.setAnalyticsHandlers([]), this.disposed = !0
							}
							setAnalyticsHandlers(e) {
								if (this.disposed) return;
								this.analyticsHandlers = new Set(e), this._setUserProperties();
								const t = this.cache;
								this.cache = null, t && t.forEach((e => this._sendEvent(e)))
							}
							_setUserProperties() {
								this.analyticsHandlers.forEach((e => {
									try {
										e.setUserProperties(this.permanentProperties)
									} catch (e) {
										Yn.warn(`Error in setUserProperties method of one of the analytics handlers: ${e}`)
									}
								}))
							}
							addPermanentProperties(e) {
								this.permanentProperties = {
									...this.permanentProperties,
									...e
								}, this._setUserProperties()
							}
							setConferenceName(e) {
								this.conferenceName = e, this.addPermanentProperties({
									conference_name: e
								})
							}
							sendEvent(e) {
								let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
								if (this.disposed) return;
								let n = null;
								"string" == typeof e ? n = {
									type: Wt,
									action: e,
									actionSubject: e,
									source: e,
									attributes: t
								} : "object" == typeof e && (n = e), this._verifyRequiredFields(n) ? this._sendEvent(n) : Yn.error(`Dropping a mis-formatted event: ${JSON.stringify(n)}`)
							}
							_verifyRequiredFields(e) {
								if (!e) return !1;
								e.type || (e.type = Wt);
								const t = e.type;
								return t !== Wt && t !== Xt && t !== Yt && t !== zt ? (Yn.error(`Unknown event type: ${t}`), !1) : t === Xt ? Boolean(e.name) : (e.action = e.action || e.name || e.actionSubject, e.actionSubject = e.actionSubject || e.name || e.action, e.source = e.source || e.name || e.action || e.actionSubject, e.action && e.actionSubject && e.source ? !!(t !== zt || (e.objectType = e.objectType || "generic-object-type", e.containerType = e.containerType || "conference", "conference" !== e.containerType || e.containerId || (e.containerId = this.conferenceName), e.objectType && e.objectId && e.containerType && e.containerId)) || (Yn.error("Required field missing (containerId, containerType, objectId or objectType)"), !1) : (Yn.error("Required field missing (action, actionSubject or source)"), !1))
							}
							_maybeCacheEvent(e) {
								return !!this.cache && (this.cache.push(e), this.cache.length > 100 && this.cache.splice(0, 1), !0)
							}
							_sendEvent(e) {
								this._maybeCacheEvent(e) || this.analyticsHandlers.forEach((t => {
									try {
										t.sendEvent(e)
									} catch (e) {
										Yn.warn(`Error sending analytics event: ${e}`)
									}
								}))
							}
						};
					var Zn = n(1023),
						ei = n.n(Zn);
					const ti = n(5810).getLogger("modules/statistics/CallStats.js"),
						ni = "applicationLog",
						ii = "error",
						si = "event",
						ri = "mstWithUserID";
					let oi;
					class ai {
						static _addNewFabricCallback(e, t) {
							ai.backend && "success" !== e && ti.error(`Monitoring status: ${e} msg: ${t}`)
						}
						static _initCallback(e, t) {
							if (ti.log(`CallStats Status: err=${e} msg=${t}`), "success" !== e) return;
							ai.backendInitialized = !0;
							let n = !1,
								i = null;
							for (const e of ai.fabrics.values()) e.hasFabric || (ti.debug("addNewFabric - initCallback"), e._addNewFabric() && (n = !0, i || (i = e)));
							n && ai._emptyReportQueue(i)
						}
						static _emptyReportQueue(e) {
							const t = e.confID,
								n = e.peerconnection;
							for (const i of ai.reportsQueue)
								if (i.type === ii) {
									const t = i.data;
									ai._reportError(e, t.type, t.error, t.pc || n)
								} else if (i.type === si) {
								const e = i.data;
								ai.backend.sendFabricEvent(i.pc || n, e.event, t, e.eventData)
							} else if (i.type === ri) {
								const e = i.data;
								ai.backend.associateMstWithUserID(i.pc || n, e.callStatsId, t, e.ssrc, e.usageLabel, e.containerId)
							}
							ai.reportsQueue.length = 0
						}
						static _reportError(e, t, n, i) {
							let s = n;
							s || (ti.warn("No error is passed!"), s = new Error("Unknown error")), ai.backendInitialized && e ? ai.backend.reportError(i, e.confID, t, s) : ai.reportsQueue.push({
								type: ii,
								data: {
									error: s,
									pc: i,
									type: t
								}
							})
						}
						static _reportEvent(e, t, n) {
							const i = e && e.peerconnection,
								s = e && e.confID;
							ai.backendInitialized && e ? ai.backend.sendFabricEvent(i, t, s, n) : ai.reportsQueue.push({
								confID: s,
								pc: i,
								type: si,
								data: {
									event: t,
									eventData: n
								}
							})
						}
						static _traceAndCatchBackendCalls(e) {
							const t = ["associateMstWithUserID", "sendFabricEvent", "sendUserFeedback"];
							for (const n of t) {
								const t = e[n];
								e[n] = function() {
									try {
										for (var n = arguments.length, i = new Array(n), s = 0; s < n; s++) i[s] = arguments[s];
										return t.apply(e, i)
									} catch (e) {
										ei().callErrorHandler(e)
									}
								}
							}
							const n = ["associateMstWithUserID", "sendFabricEvent", "sendUserFeedback"];
							for (const t of n) {
								const n = e[t];
								e[t] = function() {
									for (var i = arguments.length, s = new Array(i), r = 0; r < i; r++) s[r] = arguments[r];
									ti.debug(t, s), n.apply(e, s)
								}
							}
							const i = e.reportError;
							e.reportError = function(t, n, s) {
								for (var r = arguments.length, o = new Array(r > 3 ? r - 3 : 0), a = 3; a < r; a++) o[a - 3] = arguments[a];
								s === ni ? Wn.isReactNative() || console && console.debug("reportError", t, n, s) : ti.debug("reportError", t, n, s, ...o);
								try {
									i.call(e, t, n, s, ...o)
								} catch (e) {
									s === ni ? console && console.error("reportError", e) : ei().callErrorHandler(e)
								}
							}
						}
						static get fabrics() {
							return oi || (oi = new Set), oi
						}
						static initBackend(e) {
							if (ai.backend) throw new Error("CallStats backend has been initialized already!");
							try {
								const t = callstats;
								ai.backend = new t, ai._traceAndCatchBackendCalls(ai.backend), ai.userID = {
									aliasName: e.aliasName,
									userName: e.userName
								}, ai.callStatsID = e.callStatsID, ai.callStatsSecret = e.callStatsSecret;
								const n = {
									...e.configParams
								};
								if (e.applicationName && (n.applicationVersion = `${e.applicationName} (${Wn.getName()})`), e.confID) {
									const t = e.confID.match(/.*\/(.*)\/.*/);
									n.siteID = e.siteID || t && t[1] || "/"
								}
								return ai.backend.initialize(ai.callStatsID, ai.callStatsSecret, ai.userID, ai._initCallback, void 0, n), !0
							} catch (e) {
								return ei().callErrorHandler(e), ai.backend = null, ti.error(e), !1
							}
						}
						static isBackendInitialized() {
							return Boolean(ai.backend)
						}
						static sendActiveDeviceListEvent(e, t) {
							ai._reportEvent(t, "activeDeviceList", e)
						}
						static sendApplicationLog(e, t) {
							try {
								ai._reportError(t, ni, e, t && t.peerconnection)
							} catch (e) {
								console && "function" == typeof console.error && console.error("sendApplicationLog failed", e)
							}
						}
						static sendFeedback(e, t, n) {
							return new Promise(((i, s) => {
								if (ai.backend) ai.backend.sendUserFeedback(e, {
									userID: ai.userID,
									overall: t,
									comment: n
								}, ((e, t) => {
									"success" === e ? i(t) : s(t)
								}));
								else {
									const e = "Failed to submit feedback to CallStats - no backend";
									ti.error(e), s(e)
								}
							}))
						}
						static sendGetUserMediaFailed(e, t) {
							ai._reportError(t, "getUserMedia", e, null)
						}
						static sendMuteEvent(e, t, n) {
							let i;
							i = "video" === t ? e ? "videoPause" : "videoResume" : e ? "audioMute" : "audioUnmute", ai._reportEvent(n, i)
						}
						constructor(e, t) {
							this.confID = t.confID, this.tpc = e, this.peerconnection = e.peerconnection, this.remoteUserID = t.remoteUserID || "jitsi", this.hasFabric = !1, ai.fabrics.add(this), ai.backendInitialized && (this._addNewFabric(), 1 === ai.fabrics.size && ai._emptyReportQueue(this))
						}
						_addNewFabric() {
							ti.info("addNewFabric", this.remoteUserID);
							try {
								const e = {
										remoteEndpointType: this.tpc.isP2P ? ai.backend.endpointType.peer : ai.backend.endpointType.server
									},
									t = ai.backend.addNewFabric(this.peerconnection, this.remoteUserID, ai.backend.fabricUsage.multiplex, this.confID, e, ai._addNewFabricCallback);
								this.hasFabric = !0;
								const n = "success" === t.status;
								return n || ti.error("callstats fabric not initilized", t.message), n
							} catch (e) {
								return ei().callErrorHandler(e), !1
							}
						}
						associateStreamWithVideoTag(e, t, n, i, s) {
							if (!ai.backend) return;
							const r = t ? ai.userID : n;
							ai.backendInitialized ? ai.backend.associateMstWithUserID(this.peerconnection, r, this.confID, e, i, s) : ai.reportsQueue.push({
								type: ri,
								pc: this.peerconnection,
								data: {
									callStatsId: r,
									containerId: s,
									ssrc: e,
									usageLabel: i
								}
							})
						}
						sendDominantSpeakerEvent() {
							ai._reportEvent(this, "dominantSpeaker")
						}
						sendTerminateEvent() {
							ai.backendInitialized && ai.backend.sendFabricEvent(this.peerconnection, ai.backend.fabricEvent.fabricTerminated, this.confID), ai.fabrics.delete(this)
						}
						sendIceConnectionFailedEvent() {
							ai._reportError(this, "iceConnectionFailure", null, this.peerconnection)
						}
						sendCreateOfferFailed(e) {
							ai._reportError(this, "createOffer", e, this.peerconnection)
						}
						sendCreateAnswerFailed(e) {
							ai._reportError(this, "createAnswer", e, this.peerconnection)
						}
						sendResumeOrHoldEvent(e) {
							ai._reportEvent(this, e ? "fabricResume" : "fabricHold")
						}
						sendScreenSharingEvent(e, t) {
							let n;
							t && (n = {
								ssrc: t
							}), ai._reportEvent(this, e ? "screenShareStart" : "screenShareStop", n)
						}
						sendSetLocalDescFailed(e) {
							ai._reportError(this, "setLocalDescription", e, this.peerconnection)
						}
						sendSetRemoteDescFailed(e) {
							ai._reportError(this, "setRemoteDescription", e, this.peerconnection)
						}
						sendAddIceCandidateFailed(e) {
							ai._reportError(this, "addIceCandidate", e, this.peerconnection)
						}
					}
					ai.backend = null, ai.reportsQueue = [], ai.backendInitialized = !1, ai.callStatsID = null, ai.callStatsSecret = null, ai.userID = null;
					const ci = n(5810).getLogger("modules/statistics/LocalStatsCollector.js");
					window.AudioContext = window.AudioContext || window.webkitAudioContext;
					let di = null;

					function li(e, t, n) {
						this.stream = e, this.intervalId = null, this.intervalMilis = t, this.audioLevel = 0, this.callback = n, this.source = null, this.analyser = null
					}

					function ui(e) {
						let t = e;
						return e >= Number.MAX_SAFE_INTEGER && (t = 0), t + 1
					}

					function hi(e) {
						return e.length > 0 ? e.reduce(((e, t) => e + t)) / e.length : 0
					}

					function pi(e) {
						return e.filter((e => e >= 0))
					}
					li.prototype.start = function() {
						li.isLocalStatsSupported() && (di.resume(), this.analyser = di.createAnalyser(), this.analyser.smoothingTimeConstant = .8, this.analyser.fftSize = 2048, this.source = di.createMediaStreamSource(this.stream), this.source.connect(this.analyser), this.intervalId = setInterval((() => {
							const e = new Uint8Array(this.analyser.frequencyBinCount);
							this.analyser.getByteTimeDomainData(e);
							const t = function(e) {
								let t = 0;
								const n = e.length;
								for (let i = 0; i < n; i++) t < e[i] && (t = e[i]);
								return parseFloat(((t - 127) / 128).toFixed(3))
							}(e);
							this.audioLevel = function(e, t) {
								let n = 0;
								const i = t - e;
								return n = i > .2 ? t - .2 : i < -.4 ? t + .4 : e, parseFloat(n.toFixed(3))
							}(t, this.audioLevel), this.callback(this.audioLevel)
						}), this.intervalMilis))
					}, li.prototype.stop = function() {
						var e, t;
						this.intervalId && (clearInterval(this.intervalId), this.intervalId = null), null === (e = this.analyser) || void 0 === e || e.disconnect(), this.analyser = null, null === (t = this.source) || void 0 === t || t.disconnect(), this.source = null
					}, li.isLocalStatsSupported = function() {
						return Boolean(window.AudioContext)
					}, li.disconnectAudioContext = async function() {
						di && (ci.info("Disconnecting audio context"), await di.close(), di = null)
					}, li.connectAudioContext = function() {
						li.isLocalStatsSupported() && (ci.info("Connecting audio context"), di = new AudioContext, di.suspend())
					}, li.connectAudioContext();
					class mi {
						constructor() {
							this.average = 0, this.n = 0
						}
						addNext(e) {
							"number" == typeof e && (this.n += 1, this.average = this.average + (e - this.average) / this.n)
						}
						getAverage() {
							return this.average
						}
					}
					const fi = (0, S.getLogger)("modules/statistics/PerformanceObserverStats.js");
					class gi {
						constructor(e, t) {
							this.eventEmitter = e, this.longTasks = 0, this.maxDuration = 0, this.performanceStatsInterval = t, this.stats = new mi
						}
						getLongTasksStats() {
							return {
								avgRatePerMinute: (60 * this.stats.getAverage()).toFixed(2),
								maxDurationMs: this.maxDuration
							}
						}
						startObserver() {
							this.longTaskEventHandler = e => {
								const t = e.getEntries();
								for (const e of t) this.longTasks++, this.maxDuration = Math.max(this.maxDuration, e.duration).toFixed(3)
							}, fi.info("Creating a Performance Observer for monitoring Long Tasks"), this.observer = new PerformanceObserver(this.longTaskEventHandler), this.observer.observe({
								type: "longtask",
								buffered: !0
							});
							const e = Date.now();
							this.longTasksIntervalId = setInterval((() => {
								const t = Date.now(),
									n = this._lastTimeStamp ? (t - this._lastTimeStamp) / 1e3 : (t - e) / 1e3,
									i = this.longTasks / n;
								this.stats.addNext(i), this.eventEmitter.emit(wn, this.getLongTasksStats()), this.longTasks = 0, this._lastTimeStamp = Date.now()
							}), this.performanceStatsInterval)
						}
						stopObserver() {
							this.observer && this.observer.disconnect(), this.longTaskEventHandler = null, this.longTasksIntervalId && (clearInterval(this.longTasksIntervalId), this.longTasksIntervalId = null)
						}
					}
					let _i;
					! function(e) {
						e.AUDIO = "audio", e.VIDEO = "video"
					}(_i || (_i = {}));
					const vi = n(1023),
						Si = (0, S.getLogger)("modules/statistics/RTPStatsCollector.js");

					function Ei(e, t) {
						return !t || t <= 0 || !e || e <= 0 ? 0 : Math.round(e / t * 100)
					}

					function yi() {
						this.loss = {}, this.bitrate = {
							download: 0,
							upload: 0
						}, this.resolution = {}, this.framerate = 0, this.codec = ""
					}

					function Ti() {
						this.bandwidth = {}, this.bitrate = {}, this.packetLoss = null, this.transport = []
					}

					function Ci(e, t, n, i) {
						this.peerconnection = e, this.baselineAudioLevelsReport = null, this.currentAudioLevelsReport = null, this.currentStatsReport = null, this.previousStatsReport = null, this.audioLevelReportHistory = {}, this.audioLevelsIntervalId = null, this.eventEmitter = i, this.conferenceStats = new Ti, this.audioLevelsIntervalMilis = t, this.speakerList = [], this.statsIntervalId = null, this.statsIntervalMilis = n, this.ssrc2stats = new Map
					}
					yi.prototype.setLoss = function(e) {
						this.loss = e || {}
					}, yi.prototype.setResolution = function(e) {
						this.resolution = e || {}
					}, yi.prototype.addBitrate = function(e) {
						this.bitrate.download += e.download, this.bitrate.upload += e.upload
					}, yi.prototype.resetBitrate = function() {
						this.bitrate.download = 0, this.bitrate.upload = 0
					}, yi.prototype.setFramerate = function(e) {
						this.framerate = e || 0
					}, yi.prototype.setCodec = function(e) {
						this.codec = e || ""
					}, Ci.prototype.setSpeakerList = function(e) {
						this.speakerList = e
					}, Ci.prototype.stop = function() {
						this.audioLevelsIntervalId && (clearInterval(this.audioLevelsIntervalId), this.audioLevelsIntervalId = null), this.statsIntervalId && (clearInterval(this.statsIntervalId), this.statsIntervalId = null)
					}, Ci.prototype.errorCallback = function(e) {
						vi.callErrorHandler(e), Si.error("Get stats error", e), this.stop()
					}, Ci.prototype.start = function(e) {
						e && (Wn.supportsReceiverStats() && Si.info("Using RTCRtpSynchronizationSource for remote audio levels"), this.audioLevelsIntervalId = setInterval((() => {
							if (Wn.supportsReceiverStats()) {
								const e = this.peerconnection.getAudioLevels(this.speakerList);
								for (const t in e)
									if (e.hasOwnProperty(t)) {
										const n = 2.5 * e[t];
										this.eventEmitter.emit(Rn, this.peerconnection, Number.parseInt(t, 10), n, !1)
									}
							} else this.peerconnection.getStats().then((e => {
								this.currentAudioLevelsReport = "function" == typeof(null == e ? void 0 : e.result) ? e.result() : e, this.processAudioLevelReport(), this.baselineAudioLevelsReport = this.currentAudioLevelsReport
							})).catch((e => this.errorCallback(e)))
						}), this.audioLevelsIntervalMilis));
						const t = () => {
							this.peerconnection.getStats().then((e => {
								this.currentStatsReport = "function" == typeof(null == e ? void 0 : e.result) ? e.result() : e;
								try {
									this.processStatsReport()
								} catch (e) {
									vi.callErrorHandler(e), Si.error("Processing of RTP stats failed:", e)
								}
								this.previousStatsReport = this.currentStatsReport
							})).catch((e => this.errorCallback(e)))
						};
						t(), this.statsIntervalId = setInterval(t, this.statsIntervalMilis)
					}, Ci.prototype._processAndEmitReport = function() {
						const e = {
								download: 0,
								upload: 0
							},
							t = {
								download: 0,
								upload: 0
							};
						let n = 0,
							i = 0;
						const s = {},
							r = {},
							o = {};
						let a = 0,
							c = 0,
							d = 0,
							l = 0;
						for (const [h, p] of this.ssrc2stats) {
							const m = p.loss,
								f = m.isDownloadStream ? "download" : "upload";
							e[f] += m.packetsTotal, t[f] += m.packetsLost, n += p.bitrate.download, i += p.bitrate.upload;
							const g = this.peerconnection.getTrackBySSRC(h);
							if (g) {
								let e, t;
								g.isAudioTrack() ? (a += p.bitrate.download, c += p.bitrate.upload, e = p.codec) : (d += p.bitrate.download, l += p.bitrate.upload, t = p.codec);
								const n = g.getParticipantId();
								if (n) {
									var u;
									const i = p.resolution;
									if (i.width && i.height && -1 !== i.width && -1 !== i.height) {
										const e = s[n] || {};
										e[h] = i, s[n] = e
									}
									if (p.framerate > 0) {
										const e = r[n] || {};
										e[h] = p.framerate, r[n] = e
									}
									const a = null !== (u = o[n]) && void 0 !== u ? u : {};
									a[h] = {
										audio: e,
										video: t
									}, o[n] = a
								} else Si.error(`No participant ID returned by ${g}`)
							}
							p.resetBitrate()
						}
						this.conferenceStats.bitrate = {
							upload: i,
							download: n
						}, this.conferenceStats.bitrate.audio = {
							upload: c,
							download: a
						}, this.conferenceStats.bitrate.video = {
							upload: l,
							download: d
						}, this.conferenceStats.packetLoss = {
							total: Ei(t.download + t.upload, e.download + e.upload),
							download: Ei(t.download, e.download),
							upload: Ei(t.upload, e.upload)
						};
						const h = {};
						let p;
						Object.keys(this.audioLevelReportHistory).forEach((e => {
							const {
								data: t,
								isLocal: n
							} = this.audioLevelReportHistory[e], i = t.reduce(((e, t) => e + t)) / t.length;
							if (n) p = i;
							else {
								const t = this.peerconnection.getTrackBySSRC(Number(e));
								if (t) {
									const e = t.getParticipantId();
									e && (h[e] = i)
								}
							}
						})), this.audioLevelReportHistory = {}, this.eventEmitter.emit(Dn, this.peerconnection, {
							bandwidth: this.conferenceStats.bandwidth,
							bitrate: this.conferenceStats.bitrate,
							packetLoss: this.conferenceStats.packetLoss,
							resolution: s,
							framerate: r,
							codec: o,
							transport: this.conferenceStats.transport,
							localAvgAudioLevels: p,
							avgAudioLevels: h
						}), this.conferenceStats.transport = []
					}, Ci.prototype.getNonNegativeValue = function(e) {
						let t = e;
						return "number" != typeof t && (t = Number(t)), isNaN(t) ? 0 : Math.max(0, t)
					}, Ci.prototype._calculateBitrate = function(e, t, n) {
						const i = this.getNonNegativeValue(e[n]),
							s = this.getNonNegativeValue(t[n]),
							r = Math.max(0, i - s),
							o = e.timestamp - t.timestamp;
						let a = 0;
						return o > 0 && (a = Math.round(8 * r / o)), a
					}, Ci.prototype.processStatsReport = function() {
						const e = {};
						this.currentStatsReport.forEach((t => {
							const n = this.previousStatsReport ? this.previousStatsReport.get(t.id) : null;
							if ("candidate-pair" === t.type && t.nominated && "succeeded" === t.state) {
								const e = t.availableIncomingBitrate,
									n = t.availableOutgoingBitrate;
								(e || n) && (this.conferenceStats.bandwidth = {
									download: Math.round(e / 1e3),
									upload: Math.round(n / 1e3)
								});
								const i = this.currentStatsReport.get(t.remoteCandidateId),
									s = this.currentStatsReport.get(t.localCandidateId);
								if (i && s) {
									const e = `${Wn.isChromiumBased()?i.ip:i.address}:${i.port}`,
										n = `${Wn.isChromiumBased()?s.ip:s.address}:${s.port}`,
										r = i.protocol,
										o = this.conferenceStats.transport;
									o.some((t => t.ip === e && t.type === r && t.localip === n)) || o.push({
										ip: e,
										type: r,
										localip: n,
										p2p: this.peerconnection.isP2P,
										localCandidateType: s.candidateType,
										remoteCandidateType: i.candidateType,
										networkType: s.networkType,
										rtt: 1e3 * t.currentRoundTripTime
									})
								}
							} else if ("inbound-rtp" === t.type || "outbound-rtp" === t.type) {
								const i = this.getNonNegativeValue(t.ssrc);
								if (!i) return;
								let s = this.ssrc2stats.get(i);
								s || (s = new yi, this.ssrc2stats.set(i, s));
								let r = !0,
									o = "packetsReceived";
								"outbound-rtp" === t.type && (r = !1, o = "packetsSent");
								let a = t[o];
								if ((!a || a < 0) && (a = 0), n) {
									const e = this.getNonNegativeValue(n[o]),
										i = Math.max(0, a - e),
										c = this.getNonNegativeValue(t.packetsLost),
										d = this.getNonNegativeValue(n.packetsLost),
										l = Math.max(0, c - d);
									s.setLoss({
										packetsTotal: i + l,
										packetsLost: l,
										isDownloadStream: r
									})
								}
								if ("inbound-rtp" === t.type) {
									const e = {
											height: t.frameHeight,
											width: t.frameWidth
										},
										i = t.framesPerSecond;
									e.height && e.width && s.setResolution(e), s.setFramerate(Math.round(i || 0)), n && s.addBitrate({
										download: this._calculateBitrate(t, n, "bytesReceived"),
										upload: 0
									})
								} else n && (e[i] = this.getNonNegativeValue(t.bytesSent), s.addBitrate({
									download: 0,
									upload: this._calculateBitrate(t, n, "bytesSent")
								}));
								const c = this.currentStatsReport.get(t.codecId);
								if (c) {
									const e = c.mimeType.split("/")[1];
									e && s.setCodec(e)
								}
							} else if ("track" === t.type && t.kind === _i.VIDEO && !t.remoteSource) {
								const e = {
										height: t.frameHeight,
										width: t.frameWidth
									},
									i = this.peerconnection.getLocalTracks(_i.VIDEO);
								if (null == i || !i.length) return;
								const s = this.peerconnection.getSsrcByTrackId(t.trackIdentifier);
								if (!s) return;
								let r = this.ssrc2stats.get(s);
								r || (r = new yi, this.ssrc2stats.set(s, r)), e.height && e.width && r.setResolution(e);
								let o = t.framesPerSecond;
								if (!o) {
									if (n) {
										const e = t.timestamp - n.timestamp;
										e > 0 && t.framesSent && (o = (t.framesSent - n.framesSent) / e * 1e3)
									}
									if (!o) return
								}
								const a = this.peerconnection.getActiveSimulcastStreams();
								o = a ? Math.round(o / a) : 0, r.setFramerate(o)
							}
						})), Object.keys(e).length && this.eventEmitter.emit(Pn, this.peerconnection, e), this._processAndEmitReport()
					}, Ci.prototype.processAudioLevelReport = function() {
						this.baselineAudioLevelsReport && this.currentAudioLevelsReport.forEach((e => {
							if ("track" !== e.type) return;
							const t = e.audioLevel;
							if (!t) return;
							const n = e.trackIdentifier,
								i = this.peerconnection.getSsrcByTrackId(n);
							if (i) {
								const e = i === this.peerconnection.getLocalSSRC(this.peerconnection.getLocalTracks(_i.AUDIO));
								this.eventEmitter.emit(Rn, this.peerconnection, i, t, e)
							}
						}))
					};
					const bi = n(5810).getLogger("modules/statistics/statistics.js");
					let Ai, Ri = !1;

					function Ii(e) {
						ai.isBackendInitialized() || ai.initBackend({
							callStatsID: e.callStatsID,
							callStatsSecret: e.callStatsSecret,
							userName: e.userName,
							aliasName: e.aliasName,
							applicationName: e.applicationName,
							confID: e.confID,
							siteID: e.siteID,
							configParams: e.configParams
						}) || bi.error("CallStats Backend initialization failed bad")
					}

					function Pi(e, t) {
						this.rtpStatsMap = new Map, this.eventEmitter = new(pt()), this.xmpp = e, this.options = t || {}, this.callStatsIntegrationEnabled = this.options.callStatsID && this.options.callStatsSecret && this.options.enableCallStats && !0 !== Pi.disableThirdPartyRequests, this.callStatsIntegrationEnabled && (this.callStatsApplicationLogsDisabled = this.options.callStatsApplicationLogsDisabled, Wn.isReactNative() ? Ii(this.options) : function(e) {
							Ri || (zn().loadScript(e.customScriptUrl || wt, !0, !0, void 0, (() => Ii(e))), Ri = !0)
						}(this.options), this.options.confID || bi.warn('"confID" is not defined')), this.callsStatsInstances = new Map, Pi.instances.add(this)
					}
					Pi.init = function(e) {
						Pi.audioLevelsEnabled = !e.disableAudioLevels, "number" == typeof e.pcStatsInterval && (Pi.pcStatsInterval = e.pcStatsInterval), "number" == typeof e.audioLevelsInterval && (Pi.audioLevelsInterval = e.audioLevelsInterval), "number" == typeof e.longTasksStatsInterval && (Pi.longTasksStatsInterval = e.longTasksStatsInterval), Pi.disableThirdPartyRequests = e.disableThirdPartyRequests
					}, Pi.audioLevelsEnabled = !1, Pi.audioLevelsInterval = 200, Pi.pcStatsInterval = 1e4, Pi.disableThirdPartyRequests = !1, Pi.analytics = Qn, Object.defineProperty(Pi, "instances", {
						get: () => (Ai || (Ai = new Set), Ai)
					}), Pi.prototype.startRemoteStats = function(e) {
						this.stopRemoteStats(e);
						try {
							const t = new Ci(e, Pi.audioLevelsInterval, Pi.pcStatsInterval, this.eventEmitter);
							t.start(Pi.audioLevelsEnabled), this.rtpStatsMap.set(e.id, t)
						} catch (e) {
							bi.error(`Failed to start collecting remote statistics: ${e}`)
						}
					}, Pi.localStats = [], Pi.startLocalStats = function(e, t) {
						if (Wn.isIosBrowser() && e.addEventListener(St.NO_DATA_FROM_SOURCE, (async e => {
								if (e) {
									for (const e of Pi.localStats) e.stop();
									await li.disconnectAudioContext()
								} else {
									li.connectAudioContext();
									for (const e of Pi.localStats) e.start()
								}
							})), !Pi.audioLevelsEnabled) return;
						e.addEventListener(St.LOCAL_TRACK_STOPPED, (() => {
							Pi.stopLocalStats(e)
						}));
						const n = new li(e.getOriginalStream(), Pi.audioLevelsInterval, t);
						this.localStats.push(n), n.start()
					}, Pi.prototype.addAudioLevelListener = function(e) {
						Pi.audioLevelsEnabled && this.eventEmitter.on(Rn, e)
					}, Pi.prototype.removeAudioLevelListener = function(e) {
						Pi.audioLevelsEnabled && this.eventEmitter.removeListener(Rn, e)
					}, Pi.prototype.addBeforeDisposedListener = function(e) {
						this.eventEmitter.on(In, e)
					}, Pi.prototype.removeBeforeDisposedListener = function(e) {
						this.eventEmitter.removeListener(In, e)
					}, Pi.prototype.addConnectionStatsListener = function(e) {
						this.eventEmitter.on(Dn, e)
					}, Pi.prototype.removeConnectionStatsListener = function(e) {
						this.eventEmitter.removeListener(Dn, e)
					}, Pi.prototype.addByteSentStatsListener = function(e) {
						this.eventEmitter.on(Pn, e)
					}, Pi.prototype.removeByteSentStatsListener = function(e) {
						this.eventEmitter.removeListener(Pn, e)
					}, Pi.prototype.addLongTasksStatsListener = function(e) {
						this.eventEmitter.on(wn, e)
					}, Pi.prototype.attachLongTasksStats = function(e) {
						Wn.supportsPerformanceObserver() ? (this.performanceObserverStats = new gi(this.eventEmitter, Pi.longTasksStatsInterval), e.on(Y, (() => this.performanceObserverStats.startObserver())), e.on(Q, (() => this.performanceObserverStats.stopObserver()))) : bi.warn("Performance observer for long tasks not supported by browser!")
					}, Pi.prototype.getLongTasksStats = function() {
						return this.performanceObserverStats ? this.performanceObserverStats.getLongTasksStats() : null
					}, Pi.prototype.removeLongTasksStatsListener = function(e) {
						this.eventEmitter.removeListener(wn, e)
					}, Pi.prototype.setSpeakerList = function(e) {
						for (const t of Array.from(this.rtpStatsMap.values())) t.peerconnection.isP2P || t.setSpeakerList(e)
					}, Pi.prototype.dispose = function() {
						try {
							this.callsStatsInstances.size || this.eventEmitter.emit(In);
							for (const e of this.callsStatsInstances.values()) this.stopCallStats(e.tpc);
							for (const e of this.rtpStatsMap.keys()) this._stopRemoteStats(e);
							this.eventEmitter && this.eventEmitter.removeAllListeners()
						} finally {
							Pi.instances.delete(this)
						}
					}, Pi.stopLocalStats = function(e) {
						if (!Pi.audioLevelsEnabled) return;
						const t = e.getOriginalStream();
						for (let e = 0; e < Pi.localStats.length; e++)
							if (Pi.localStats[e].stream === t) {
								Pi.localStats.splice(e, 1)[0].stop();
								break
							}
					}, Pi.prototype._stopRemoteStats = function(e) {
						const t = this.rtpStatsMap.get(e);
						t && (t.stop(), this.rtpStatsMap.delete(e))
					}, Pi.prototype.stopRemoteStats = function(e) {
						this._stopRemoteStats(e.id)
					}, Pi.prototype.startCallStats = function(e, t) {
						if (!this.callStatsIntegrationEnabled) return;
						if (this.callsStatsInstances.has(e.id)) return void bi.error("CallStats instance for ${tpc} exists already");
						let n = this.options.confID;
						n.endsWith(this.options.roomName) || (n = `${this.options.confID.slice(0,this.options.confID.lastIndexOf("/"))}/${this.options.roomName}`), bi.info(`Starting CallStats for ${e}...`);
						const i = new ai(e, {
							confID: n,
							remoteUserID: t
						});
						this.callsStatsInstances.set(e.id, i)
					}, Pi._getAllCallStatsInstances = function() {
						const e = new Set;
						for (const t of Pi.instances)
							for (const n of t.callsStatsInstances.values()) e.add(n);
						return e
					}, Pi.prototype.stopCallStats = function(e) {
						const t = this.callsStatsInstances.get(e.id);
						t && (1 === this.callsStatsInstances.size && this.eventEmitter.emit(In), this.callsStatsInstances.delete(e.id), t.sendTerminateEvent())
					}, Pi.prototype.isCallstatsEnabled = function() {
						return this.callStatsIntegrationEnabled
					}, Pi.prototype.sendConnectionResumeOrHoldEvent = function(e, t) {
						const n = this.callsStatsInstances.get(e.id);
						n && n.sendResumeOrHoldEvent(t)
					}, Pi.prototype.sendIceConnectionFailedEvent = function(e) {
						const t = this.callsStatsInstances.get(e.id);
						t && t.sendIceConnectionFailedEvent()
					}, Pi.prototype.sendMuteEvent = function(e, t, n) {
						const i = e && this.callsStatsInstances.get(e.id);
						ai.sendMuteEvent(t, n, i)
					}, Pi.prototype.sendScreenSharingEvent = function(e, t) {
						for (const n of this.callsStatsInstances.values()) n.sendScreenSharingEvent(e, t)
					}, Pi.prototype.sendDominantSpeakerEvent = function(e, t) {
						for (const e of this.callsStatsInstances.values()) e.sendDominantSpeakerEvent();
						this.xmpp.sendDominantSpeakerEvent(e, t)
					}, Pi.sendActiveDeviceListEvent = function(e) {
						const t = Pi._getAllCallStatsInstances();
						if (t.size)
							for (const n of t) ai.sendActiveDeviceListEvent(e, n);
						else ai.sendActiveDeviceListEvent(e, null)
					}, Pi.prototype.associateStreamWithVideoTag = function(e, t, n, i, s, r) {
						const o = this.callsStatsInstances.get(e.id);
						o && o.associateStreamWithVideoTag(t, n, i, s, r)
					}, Pi.sendGetUserMediaFailed = function(e) {
						const t = e instanceof qt ? function(e) {
								const t = new Error;
								return t.stack = e.stack, t.name = (e.name || "Unknown error") + (e.gum && e.gum.error && e.gum.error.name ? ` - ${e.gum.error.name}` : ""), t.constraintName = e.gum && e.gum.constraints ? JSON.stringify(e.gum.constraints) : "", t.message = e.message, t
							}(e) : e,
							n = Pi._getAllCallStatsInstances();
						if (n.size)
							for (const e of n) ai.sendGetUserMediaFailed(t, e);
						else ai.sendGetUserMediaFailed(t, null)
					}, Pi.prototype.sendCreateOfferFailed = function(e, t) {
						const n = this.callsStatsInstances.get(t.id);
						n && n.sendCreateOfferFailed(e)
					}, Pi.prototype.sendCreateAnswerFailed = function(e, t) {
						const n = this.callsStatsInstances.get(t.id);
						n && n.sendCreateAnswerFailed(e)
					}, Pi.prototype.sendSetLocalDescFailed = function(e, t) {
						const n = this.callsStatsInstances.get(t.id);
						n && n.sendSetLocalDescFailed(e)
					}, Pi.prototype.sendSetRemoteDescFailed = function(e, t) {
						const n = this.callsStatsInstances.get(t.id);
						n && n.sendSetRemoteDescFailed(e)
					}, Pi.prototype.sendAddIceCandidateFailed = function(e, t) {
						const n = this.callsStatsInstances.get(t.id);
						n && n.sendAddIceCandidateFailed(e)
					}, Pi.sendLog = function(e) {
						const t = new Set;
						for (const e of Pi.instances) {
							if (e.callStatsApplicationLogsDisabled) return;
							e.callsStatsInstances.size && t.add(e.callsStatsInstances.values().next().value)
						}
						if (t.size)
							for (const n of t) ai.sendApplicationLog(e, n);
						else ai.sendApplicationLog(e, null)
					}, Pi.prototype.sendFeedback = function(e, t) {
						return Pi.analytics.sendEvent(hn, {
							rating: e,
							comment: t
						}), ai.sendFeedback(this.options.confID, e, t)
					}, Pi.LOCAL_JID = n(7680).D, Pi.reportGlobalError = function(e) {
						e instanceof qt && e.gum ? Pi.sendGetUserMediaFailed(e) : Pi.sendLog(e)
					}, Pi.sendAnalyticsAndLog = function(e) {
						let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
						e ? (t = "object" == typeof e ? e : {
							name: e,
							properties: n
						}, bi.log(JSON.stringify(t)), this.analytics.sendEvent(e, n)) : bi.warn("No event or event name given.")
					}, Pi.sendAnalytics = function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
						this.analytics.sendEvent(e, t)
					};
					var Di = n(4832),
						wi = n.n(Di),
						Oi = n(9987),
						Ni = n(3408),
						Mi = n(3514),
						Li = n.n(Mi),
						ki = n(609);
					const xi = (0, S.getLogger)("JitsiConferenceEventManager.js");

					function Fi(e) {
						this.conference = e, this.xmppListeners = {}, e.on(Ge, (t => {
							if (!t.isLocal() || !e.statistics) return;
							const n = t.isP2P ? e.p2pJingleSession : e.jvbJingleSession,
								i = n && n.peerconnection || null;
							e.statistics.sendMuteEvent(i, t.isMuted(), t.getType())
						}))
					}
					Fi.prototype.setupChatRoomListeners = function() {
						const e = this.conference,
							t = e.room;
						this.chatRoomForwarder = new(wi())(t, this.conference.eventEmitter), t.addListener(ki.XMPPEvents.ICE_RESTARTING, (t => {
							t.isP2P || e.rtc.closeBridgeChannel()
						})), t.addListener(ki.XMPPEvents.PARTICIPANT_FEATURES_CHANGED, ((t, n) => {
							const i = e.getParticipantById(vt.Strophe.getResourceFromJid(t));
							i && (i.setFeatures(n), e.eventEmitter.emit(we, i))
						})), t.addListener(ki.XMPPEvents.ICE_RESTART_SUCCESS, ((t, n) => {
							!t.isP2P && e._setBridgeChannel(n, t.peerconnection)
						})), t.addListener(ki.XMPPEvents.AUDIO_MUTED_BY_FOCUS, (t => {
							Pi.sendAnalytics(Cn(_i.AUDIO)), e.mutedByFocusActor = t, e.rtc.setAudioMute(!0).then((() => {
								e.isMutedByFocus = !0, e.mutedByFocusActor = null
							})).catch((t => {
								e.mutedByFocusActor = null, xi.warn("Error while audio muting due to focus request", t)
							}))
						})), t.addListener(ki.XMPPEvents.VIDEO_MUTED_BY_FOCUS, (t => {
							Pi.sendAnalytics(Cn(_i.VIDEO)), e.mutedVideoByFocusActor = t, e.rtc.setVideoMute(!0).then((() => {
								e.isVideoMutedByFocus = !0, e.mutedVideoByFocusActor = null
							})).catch((t => {
								e.mutedVideoByFocusActor = null, xi.warn("Error while video muting due to focus request", t)
							}))
						})), this.chatRoomForwarder.forward(ki.XMPPEvents.SUBJECT_CHANGED, je), this.chatRoomForwarder.forward(ki.XMPPEvents.MUC_JOINED, Y), this.chatRoomForwarder.forward(ki.XMPPEvents.MUC_JOIN_IN_PROGRESS, z), this.chatRoomForwarder.forward(ki.XMPPEvents.MEETING_ID_SET, Z), t.addListener(ki.XMPPEvents.MUC_JOINED, (() => {
							this.conference._onMucJoined(), this.conference.isJvbConnectionInterrupted = !1, Object.keys(t.connectionTimes).forEach((e => {
								const n = Sn(`conference_${e}`, {
									value: t.connectionTimes[e]
								});
								Pi.sendAnalytics(n)
							})), Object.keys(t.xmpp.connectionTimes).forEach((e => {
								const n = Sn(`xmpp_${e}`, {
									value: t.xmpp.connectionTimes[e]
								});
								Pi.sendAnalytics(n)
							}))
						})), t.addListener(ki.XMPPEvents.RENEGOTIATION_FAILED, ((t, n) => {
							n.isP2P || e.eventEmitter.emit(X, F, t)
						})), t.addListener(Dt, (t => {
							e.eventEmitter.emit(qe, t)
						})), this.chatRoomForwarder.forward(ki.XMPPEvents.ROOM_JOIN_ERROR, X, I), this.chatRoomForwarder.forward(ki.XMPPEvents.ROOM_CONNECT_ERROR, X, I), this.chatRoomForwarder.forward(ki.XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR, X, D), this.chatRoomForwarder.forward(ki.XMPPEvents.ROOM_CONNECT_MEMBERS_ONLY_ERROR, X, w), this.chatRoomForwarder.forward(ki.XMPPEvents.ROOM_MAX_USERS_ERROR, X, R), t.addListener(ki.XMPPEvents.ROOM_MAX_USERS_ERROR, (() => e.leave())), this.chatRoomForwarder.forward(ki.XMPPEvents.PASSWORD_REQUIRED, X, U), this.chatRoomForwarder.forward(ki.XMPPEvents.AUTHENTICATION_REQUIRED, X, T), this.chatRoomForwarder.forward(ki.XMPPEvents.REDIRECTED, X, j), this.chatRoomForwarder.forward(ki.XMPPEvents.BRIDGE_DOWN, X, B), t.addListener(ki.XMPPEvents.BRIDGE_DOWN, (() => Pi.sendAnalytics({
							action: "bridge.down",
							actionSubject: "bridge.down",
							type: Wt
						}))), t.addListener(ki.XMPPEvents.CONNECTION_RESTARTED, (t => {
							e._onConferenceRestarted(t)
						})), this.chatRoomForwarder.forward(ki.XMPPEvents.RESERVATION_ERROR, X, H), t.addListener(ki.XMPPEvents.RESERVATION_ERROR, (() => e.leave())), this.chatRoomForwarder.forward(ki.XMPPEvents.GRACEFUL_SHUTDOWN, X, L), t.addListener(ki.XMPPEvents.CONNECTION_ICE_FAILED, (t => {
							e._onIceConnectionFailed(t)
						})), this.chatRoomForwarder.forward(ki.XMPPEvents.MUC_DESTROYED, X, A), t.addListener(ki.XMPPEvents.MUC_DESTROYED, (() => e.leave())), this.chatRoomForwarder.forward(ki.XMPPEvents.CHAT_ERROR_RECEIVED, W, C), this.chatRoomForwarder.forward(ki.XMPPEvents.SETTINGS_ERROR_RECEIVED, W, b), this.chatRoomForwarder.forward(ki.XMPPEvents.FOCUS_DISCONNECTED, X, N), t.addListener(ki.XMPPEvents.FOCUS_LEFT, (() => {
							Pi.sendAnalytics({
								action: "focus.left",
								actionSubject: "focus.left",
								type: Kt.TYPE_OPERATIONAL
							}), e.eventEmitter.emit(X, M)
						})), t.addListener(ki.XMPPEvents.SESSION_ACCEPT_TIMEOUT, (e => {
							Pi.sendAnalyticsAndLog(yn(Zt, {
								p2p: e.isP2P
							}))
						})), t.addListener(ki.XMPPEvents.RECORDER_STATE_CHANGED, ((t, n) => {
							if (n) {
								const i = vt.Strophe.getResourceFromJid(n),
									s = e.getParticipantById(i) || i;
								"off" === t.getStatus() ? t.setTerminator(s) : "on" === t.getStatus() && t.setInitiator(s)
							}
							e.eventEmitter.emit(ke, t)
						})), this.chatRoomForwarder.forward(ki.XMPPEvents.TRANSCRIPTION_STATUS_CHANGED, We), this.chatRoomForwarder.forward(ki.XMPPEvents.VIDEO_SIP_GW_AVAILABILITY_CHANGED, xe), this.chatRoomForwarder.forward(ki.XMPPEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED, Fe), this.chatRoomForwarder.forward(ki.XMPPEvents.PHONE_NUMBER_CHANGED, Me), t.setParticipantPropertyListener(((t, n) => {
							const i = e.getParticipantById(n);
							i && i.setProperty(t.tagName.substring("jitsi_participant_".length), t.value)
						})), t.addListener(ki.XMPPEvents.KICKED, e.onMemberKicked.bind(e)), t.addListener(ki.XMPPEvents.SUSPEND_DETECTED, e.onSuspendDetected.bind(e)), this.chatRoomForwarder.forward(ki.XMPPEvents.MUC_LOCK_CHANGED, Ee), this.chatRoomForwarder.forward(ki.XMPPEvents.MUC_MEMBERS_ONLY_CHANGED, be), t.addListener(ki.XMPPEvents.MUC_MEMBER_JOINED, e.onMemberJoined.bind(e)), this.chatRoomForwarder.forward(ki.XMPPEvents.MUC_LOBBY_MEMBER_JOINED, tt), this.chatRoomForwarder.forward(ki.XMPPEvents.MUC_LOBBY_MEMBER_UPDATED, nt), this.chatRoomForwarder.forward(ki.XMPPEvents.MUC_LOBBY_MEMBER_LEFT, it), t.addListener(ki.XMPPEvents.MUC_MEMBER_BOT_TYPE_CHANGED, e._onMemberBotTypeChanged.bind(e)), t.addListener(ki.XMPPEvents.MUC_MEMBER_LEFT, e.onMemberLeft.bind(e)), this.chatRoomForwarder.forward(ki.XMPPEvents.MUC_LEFT, Q), this.chatRoomForwarder.forward(ki.XMPPEvents.MUC_DENIED_ACCESS, X, O), t.addListener(ki.XMPPEvents.DISPLAY_NAME_CHANGED, e.onDisplayNameChanged.bind(e)), t.addListener(ki.XMPPEvents.LOCAL_ROLE_CHANGED, (t => {
							e.onLocalRoleChanged(t), e.statistics && e.isModerator() && e.on(ke, (e => {
								const t = {
									error: e.getError(),
									id: "recorder_status",
									status: e.getStatus()
								};
								Pi.sendLog(JSON.stringify(t))
							}))
						})), t.addListener(ki.XMPPEvents.MUC_ROLE_CHANGED, e.onUserRoleChanged.bind(e)), t.addListener(Li().IDENTITY_UPDATED, ((t, n) => {
							e.authEnabled = t, e.authIdentity = n, e.eventEmitter.emit(q, t, n)
						})), t.addListener(ki.XMPPEvents.MESSAGE_RECEIVED, ((t, n, i, s) => {
							const r = vt.Strophe.getResourceFromJid(t);
							e.eventEmitter.emit(Ae, r, n, s)
						})), t.addListener(ki.XMPPEvents.PRIVATE_MESSAGE_RECEIVED, ((t, n, i, s) => {
							const r = vt.Strophe.getResourceFromJid(t);
							e.eventEmitter.emit(De, r, n, s)
						})), t.addListener(ki.XMPPEvents.PRESENCE_STATUS, ((t, n) => {
							const i = vt.Strophe.getResourceFromJid(t),
								s = e.getParticipantById(i);
							s && s._status !== n && (s._status = n, e.eventEmitter.emit(Qe, i, n))
						})), t.addListener(ki.XMPPEvents.JSON_MESSAGE_RECEIVED, ((t, n) => {
							const i = vt.Strophe.getResourceFromJid(t),
								s = e.getParticipantById(i);
							s ? e.eventEmitter.emit(de, s, n) : e.eventEmitter.emit(Pe, i, n)
						})), t.addPresenceListener("startmuted", ((t, n) => {
							let i = !1;
							if (e.myUserId() === n && e.isModerator()) i = !0;
							else {
								const t = e.getParticipantById(n);
								t && t.isModerator() && (i = !0)
							}
							if (!i) return;
							const s = "true" === t.attributes.audio,
								r = "true" === t.attributes.video;
							let o = !1;
							s !== e.startMutedPolicy.audio && (e.startMutedPolicy.audio = s, o = !0), r !== e.startMutedPolicy.video && (e.startMutedPolicy.video = r, o = !0), o && e.eventEmitter.emit(Ve, e.startMutedPolicy)
						})), e.statistics && (t.addListener(ki.XMPPEvents.CONNECTION_ICE_FAILED, (t => {
							e.statistics.sendIceConnectionFailedEvent(t.peerconnection)
						})), t.addListener(ki.XMPPEvents.ADD_ICE_CANDIDATE_FAILED, ((t, n) => {
							e.statistics.sendAddIceCandidateFailed(t, n)
						}))), this.chatRoomForwarder.forward(ki.XMPPEvents.BREAKOUT_ROOMS_MOVE_TO_ROOM, dt), this.chatRoomForwarder.forward(ki.XMPPEvents.BREAKOUT_ROOMS_UPDATED, lt), this.chatRoomForwarder.forward(ki.XMPPEvents.ROOM_METADATA_UPDATED, ut)
					}, Fi.prototype.setupRTCListeners = function() {
						const e = this.conference,
							t = e.rtc;
						t.addListener(Oi.default.REMOTE_TRACK_ADDED, e.onRemoteTrackAdded.bind(e)), t.addListener(Oi.default.REMOTE_TRACK_REMOVED, e.onRemoteTrackRemoved.bind(e)), t.addListener(Oi.default.DOMINANT_SPEAKER_CHANGED, ((t, n, i) => {
							if ((e.lastDominantSpeaker !== t || e.dominantSpeakerIsSilent !== i) && e.room && (e.lastDominantSpeaker = t, e.dominantSpeakerIsSilent = i, e.eventEmitter.emit(oe, t, n, i), e.statistics && e.myUserId() === t && e.statistics.sendDominantSpeakerEvent(e.room.roomjid, i), e.lastDominantSpeaker !== t && n && n.length)) {
								const i = n.slice(0);
								e.myUserId !== t && i.splice(0, 0, t), i.length > 5 && i.splice(5, i.length - 5), e.statistics && e.statistics.setSpeakerList(i)
							}
						})), t.addListener(Oi.default.DATA_CHANNEL_OPEN, (() => {
							const t = window.performance.now(),
								n = "data.channel.opened";
							xi.log(`(TIME) ${n}:\t`, t), e.room.connectionTimes[n] = t, Pi.sendAnalytics(Sn(n, {
								value: t
							})), e.eventEmitter.emit(ie)
						})), t.addListener(Oi.default.DATA_CHANNEL_CLOSED, (t => {
							e.eventEmitter.emit(se, t)
						})), t.addListener(Oi.default.VIDEO_SSRCS_REMAPPED, (e => {
							for (const t of this.conference.getMediaSessions()) t.processSourceMap(e, _i.VIDEO)
						})), t.addListener(Oi.default.AUDIO_SSRCS_REMAPPED, (e => {
							for (const t of this.conference.getMediaSessions()) t.processSourceMap(e, _i.AUDIO)
						})), t.addListener(Oi.default.ENDPOINT_MESSAGE_RECEIVED, ((t, n) => {
							const i = e.getParticipantById(t);
							i ? e.eventEmitter.emit(de, i, n) : xi.warn(`Ignored ENDPOINT_MESSAGE_RECEIVED for not existing participant: ${t}`, n)
						})), t.addListener(Oi.default.ENDPOINT_STATS_RECEIVED, ((t, n) => {
							const i = e.getParticipantById(t);
							i ? e.eventEmitter.emit(le, i, n) : xi.warn(`Ignoring ENDPOINT_STATS_RECEIVED for a non-existant participant: ${t}`)
						})), t.addListener(Oi.default.LOCAL_UFRAG_CHANGED, ((e, t) => {
							e.isP2P || Pi.sendLog(JSON.stringify({
								id: "local_ufrag",
								value: t
							}))
						})), t.addListener(Oi.default.REMOTE_UFRAG_CHANGED, ((e, t) => {
							e.isP2P || Pi.sendLog(JSON.stringify({
								id: "remote_ufrag",
								value: t
							}))
						})), t.addListener(Oi.default.CREATE_ANSWER_FAILED, ((t, n) => {
							e.statistics.sendCreateAnswerFailed(t, n), n.isP2P || e.eventEmitter.emit(X, F, t)
						})), t.addListener(Oi.default.CREATE_OFFER_FAILED, ((t, n) => {
							e.statistics.sendCreateOfferFailed(t, n), n.isP2P || e.eventEmitter.emit(X, F, t)
						})), t.addListener(Oi.default.SET_LOCAL_DESCRIPTION_FAILED, ((t, n) => {
							e.statistics.sendSetLocalDescFailed(t, n), n.isP2P || e.eventEmitter.emit(X, F, t)
						})), t.addListener(Oi.default.SET_REMOTE_DESCRIPTION_FAILED, ((t, n) => {
							e.statistics.sendSetRemoteDescFailed(t, n), n.isP2P || e.eventEmitter.emit(X, F, t)
						})), t.addListener(Oi.default.LOCAL_TRACK_SSRC_UPDATED, ((t, n) => {
							t.isVideoTrack() && t.videoType === Ni.VideoType.DESKTOP && e.statistics.sendScreenSharingEvent(!0, n)
						}))
					}, Fi.prototype.removeXMPPListeners = function() {
						const e = this.conference;
						Object.keys(this.xmppListeners).forEach((t => {
							e.xmpp.removeListener(t, this.xmppListeners[t])
						})), this.xmppListeners = {}
					}, Fi.prototype.setupXMPPListeners = function() {
						const e = this.conference;
						this._addConferenceXMPPListener(ki.XMPPEvents.CALL_INCOMING, e.onIncomingCall.bind(e)), this._addConferenceXMPPListener(ki.XMPPEvents.CALL_ACCEPTED, e.onCallAccepted.bind(e)), this._addConferenceXMPPListener(ki.XMPPEvents.TRANSPORT_INFO, e.onTransportInfo.bind(e)), this._addConferenceXMPPListener(ki.XMPPEvents.CALL_ENDED, e.onCallEnded.bind(e)), this._addConferenceXMPPListener(ki.XMPPEvents.START_MUTED_FROM_FOCUS, ((t, n) => {
							e.options.config.ignoreStartMuted || (e.startAudioMuted = t, e.startVideoMuted = n, t && (e.isMutedByFocus = !0), n && (e.isVideoMutedByFocus = !0), e.getLocalTracks().forEach((t => {
								switch (t.getType()) {
									case _i.AUDIO:
										e.startAudioMuted && t.mute();
										break;
									case _i.VIDEO:
										e.startVideoMuted && t.mute()
								}
							})), e.eventEmitter.emit(Ue))
						})), this._addConferenceXMPPListener(ki.XMPPEvents.CONFERENCE_TIMESTAMP_RECEIVED, (t => {
							e.eventEmitter.emit(ae, t)
						})), this._addConferenceXMPPListener(ki.XMPPEvents.AV_MODERATION_CHANGED, ((t, n, i) => {
							const s = e.getParticipants().find((e => e.getJid() === i));
							e.eventEmitter.emit(ot, {
								enabled: t,
								mediaType: n,
								actor: s
							})
						})), this._addConferenceXMPPListener(ki.XMPPEvents.AV_MODERATION_PARTICIPANT_APPROVED, ((t, n) => {
							const i = e.getParticipantById(vt.Strophe.getResourceFromJid(n));
							i && e.eventEmitter.emit(at, {
								participant: i,
								mediaType: t
							})
						})), this._addConferenceXMPPListener(ki.XMPPEvents.AV_MODERATION_PARTICIPANT_REJECTED, ((t, n) => {
							const i = e.getParticipantById(vt.Strophe.getResourceFromJid(n));
							i && e.eventEmitter.emit(ct, {
								participant: i,
								mediaType: t
							})
						})), this._addConferenceXMPPListener(ki.XMPPEvents.AV_MODERATION_APPROVED, (t => e.eventEmitter.emit(st, {
							mediaType: t
						}))), this._addConferenceXMPPListener(ki.XMPPEvents.AV_MODERATION_REJECTED, (t => {
							e.eventEmitter.emit(rt, {
								mediaType: t
							})
						}))
					}, Fi.prototype._addConferenceXMPPListener = function(e, t) {
						this.xmppListeners[e] = t, this.conference.xmpp.addListener(e, t)
					}, Fi.prototype.setupStatisticsListeners = function() {
						const e = this.conference;
						e.statistics && (e.statistics.addAudioLevelListener(((t, n, i, s) => {
							e.rtc.setAudioLevel(t, n, i, s)
						})), e.statistics.addBeforeDisposedListener((() => {
							e.eventEmitter.emit(K)
						})), e.options.config.startSilent || e.statistics.addByteSentStatsListener(((t, n) => {
							e.getLocalTracks(_i.AUDIO).forEach((e => {
								const i = t.getLocalSSRC(e);
								i && n.hasOwnProperty(i) && e.onByteSentStatsReceived(t, n[i])
							}))
						})))
					};
					class Vi {
						constructor(e, t, n, i, s, r, o, a, c) {
							this._jid = e, this._id = vt.Strophe.getResourceFromJid(e), this._conference = t, this._displayName = n, this._supportsDTMF = !1, this._tracks = [], this._role = "none", this._status = r, this._hidden = i, this._statsID = s, this._properties = {}, this._identity = o, this._isReplacing = a, this._isReplaced = c, this._features = new Set, this._sources = new Map
						}
						_isMediaTypeMuted(e) {
							return this.getTracks().reduce(((t, n) => t && (n.getType() !== e || n.isMuted())), !0)
						}
						_setSources(e, t, n, i) {
							var s;
							let r = this._sources.get(e);
							const o = {
								muted: t,
								videoType: i
							};
							null !== (s = r) && void 0 !== s && s.size ? r.set(n, o) : (r = new Map, r.set(n, o), this._sources.set(e, r))
						}
						getBotType() {
							return this._botType
						}
						getConference() {
							return this._conference
						}
						getConnectionJid() {
							return this._connectionJid
						}
						getDisplayName() {
							return this._displayName
						}
						getFeatures() {
							return Promise.resolve(this._features)
						}
						getId() {
							return this._id
						}
						getJid() {
							return this._jid
						}
						getProperty(e) {
							return this._properties[e]
						}
						getRole() {
							return this._role
						}
						getSources() {
							return this._sources
						}
						getStatsID() {
							return this._statsID
						}
						getStatus() {
							return this._status
						}
						getTracks() {
							return this._tracks.slice()
						}
						getTracksByMediaType(e) {
							return this.getTracks().filter((t => t.getType() === e))
						}
						hasFeature(e) {
							return this._features.has(e)
						}
						isAudioMuted() {
							return this._isMediaTypeMuted(_i.AUDIO)
						}
						isHidden() {
							return this._hidden
						}
						isHiddenFromRecorder() {
							var e, t;
							return "true" === (null === (e = this._identity) || void 0 === e || null === (t = e.user) || void 0 === t ? void 0 : t["hidden-from-recorder"])
						}
						isModerator() {
							return "moderator" === this._role
						}
						isReplaced() {
							return this._isReplaced
						}
						isReplacing() {
							return this._isReplacing
						}
						isVideoMuted() {
							return this._isMediaTypeMuted(_i.VIDEO)
						}
						setBotType(e) {
							this._botType = e
						}
						setConnectionJid(e) {
							this._connectionJid = e
						}
						setFeatures(e) {
							this._features = e || new Set
						}
						setIsReplaced(e) {
							this._isReplaced = e
						}
						setIsReplacing(e) {
							this._isReplacing = e
						}
						setProperty(e, t) {
							const n = this._properties[e];
							t !== n && (this._properties[e] = t, this._conference.eventEmitter.emit(Oe, this, e, n, t))
						}
						setRole(e) {
							this._role = e
						}
						supportsDTMF() {
							return this._supportsDTMF
						}
					}
					let Ui;
					! function(e) {
						e.CONNECTION_DISCONNECTED = "connection.connectionDisconnected", e.CONNECTION_ESTABLISHED = "connection.connectionEstablished", e.CONNECTION_FAILED = "connection.connectionFailed", e.WRONG_STATE = "connection.wrongState", e.DISPLAY_NAME_REQUIRED = "connection.display_name_required"
					}(Ui || (Ui = {}));
					const ji = Ui.CONNECTION_DISCONNECTED,
						Hi = Ui.CONNECTION_ESTABLISHED,
						Bi = Ui.CONNECTION_FAILED,
						$i = Ui.WRONG_STATE,
						Ji = Ui.DISPLAY_NAME_REQUIRED;
					let Gi;
					n(1352),
						function(e) {
							e.CONNECTION_DROPPED_ERROR = "connection.droppedError", e.OTHER_ERROR = "connection.otherError", e.PASSWORD_REQUIRED = "connection.passwordRequired", e.SERVER_ERROR = "connection.serverError"
						}(Gi || (Gi = {}));
					const qi = Gi.CONNECTION_DROPPED_ERROR,
						Ki = Gi.OTHER_ERROR,
						Wi = Gi.PASSWORD_REQUIRED,
						Xi = Gi.SERVER_ERROR;
					class zi {
						constructor() {
							var e = this;
							this.promise = new Promise(((t, n) => {
								this.resolve = function() {
									e.clearRejectTimeout(), t(...arguments)
								}, this.reject = function() {
									e.clearRejectTimeout(), n(...arguments)
								}
							})), this.then = this.promise.then.bind(this.promise), this.catch = this.promise.catch.bind(this.promise)
						}
						clearRejectTimeout() {
							clearTimeout(this._timeout)
						}
						setRejectTimeout(e) {
							this._timeout = setTimeout((() => {
								this.reject(new Error("timeout"))
							}), e)
						}
					}
					class Yi {
						constructor() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new(pt());
							this.eventEmitter = e, this.addEventListener = this.on = this.addListener, this.removeEventListener = this.off = this.removeListener
						}
						addListener(e, t) {
							return this.eventEmitter.addListener(e, t), () => this.removeEventListener(e, t)
						}
						removeListener(e, t) {
							this.eventEmitter.removeListener(e, t)
						}
					}
					const Qi = (0, S.getLogger)("modules/e2ee/E2EEContext.js"),
						Zi = Symbol("kJitsiE2EE");
					class es {
						constructor() {
							let {
								sharedKey: e
							} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = "";
							const n = document.querySelector('script[src*="lib-jitsi-meet"]');
							if (n) {
								const e = n.src.lastIndexOf("/");
								t = `${n.src.substring(0,e)}/`
							}
							let i = `${t}lib-jitsi-meet.e2ee-worker.js`;
							if (t && "/" !== t) {
								const e = new Blob([`importScripts("${i}");`], {
									type: "application/javascript"
								});
								i = window.URL.createObjectURL(e)
							}
							this._worker = new Worker(i, {
								name: "E2EE Worker"
							}), this._worker.onerror = e => Qi.error(e), this._worker.postMessage({
								operation: "initialize",
								sharedKey: e
							})
						}
						cleanup(e) {
							this._worker.postMessage({
								operation: "cleanup",
								participantId: e
							})
						}
						cleanupAll() {
							this._worker.postMessage({
								operation: "cleanupAll"
							})
						}
						handleReceiver(e, t, n) {
							if (!e[Zi])
								if (e[Zi] = !0, window.RTCRtpScriptTransform) {
									const t = {
										operation: "decode",
										participantId: n
									};
									e.transform = new RTCRtpScriptTransform(this._worker, t)
								} else {
									const t = e.createEncodedStreams();
									this._worker.postMessage({
										operation: "decode",
										readableStream: t.readable,
										writableStream: t.writable,
										participantId: n
									}, [t.readable, t.writable])
								}
						}
						handleSender(e, t, n) {
							if (!e[Zi])
								if (e[Zi] = !0, window.RTCRtpScriptTransform) {
									const t = {
										operation: "encode",
										participantId: n
									};
									e.transform = new RTCRtpScriptTransform(this._worker, t)
								} else {
									const t = e.createEncodedStreams();
									this._worker.postMessage({
										operation: "encode",
										readableStream: t.readable,
										writableStream: t.writable,
										participantId: n
									}, [t.readable, t.writable])
								}
						}
						setKey(e, t, n) {
							this._worker.postMessage({
								operation: "setKey",
								key: t,
								keyIndex: n,
								participantId: e
							})
						}
					}
					const ts = (0, S.getLogger)("modules/e2ee/KeyHandler.js");
					class ns extends Yi {
						constructor(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
							super(), this.conference = e, this.e2eeCtx = new es(t), this.enabled = !1, this._enabling = void 0, this.conference.on(Te, this._onMediaSessionStarted.bind(this)), this.conference.on($e, (e => e.isLocal() && this._onLocalTrackAdded(e))), this.conference.rtc.on(Oi.default.REMOTE_TRACK_ADDED, ((e, t) => this._setupReceiverE2EEForTrack(t, e))), this.conference.on(Ge, this._trackMuteChanged.bind(this))
						}
						isEnabled() {
							return this.enabled
						}
						async setEnabled(e) {
							this._enabling && await this._enabling, e !== this.enabled && (this._enabling = new zi, this.enabled = e, e || this.e2eeCtx.cleanupAll(), this._setEnabled && await this._setEnabled(e), this.conference.setLocalParticipantProperty("e2ee.enabled", e), this.conference._restartMediaSessions(), this._enabling.resolve())
						}
						setEncryptionKey() {
							throw new Error("Not implemented by subclass")
						}
						_onLocalTrackAdded(e) {
							for (const t of this.conference.getMediaSessions()) this._setupSenderE2EEForTrack(t, e)
						}
						_onMediaSessionStarted(e) {
							const t = this.conference.getLocalTracks();
							for (const n of t) this._setupSenderE2EEForTrack(e, n)
						}
						_setupReceiverE2EEForTrack(e, t) {
							if (!this.enabled) return;
							const n = e.findReceiverForTrack(t.track);
							n ? this.e2eeCtx.handleReceiver(n, t.getType(), t.getParticipantId()) : ts.warn(`Could not handle E2EE for ${t}: receiver not found in: ${e}`)
						}
						_setupSenderE2EEForTrack(e, t) {
							if (!this.enabled) return;
							const n = e.peerconnection,
								i = n && n.findSenderForTrack(t.track);
							i ? this.e2eeCtx.handleSender(i, t.getType(), t.getParticipantId()) : ts.warn(`Could not handle E2EE for ${t}: sender not found in ${n}`)
						}
						_trackMuteChanged(e) {
							if (Wn.doesVideoMuteByStreamRemove() && e.isLocal() && e.isVideoTrack() && !e.isMuted())
								for (const t of this.conference.getMediaSessions()) this._setupSenderE2EEForTrack(t, e)
						}
					}
					class is extends ns {
						constructor(e) {
							super(e, {
								sharedKey: !0
							})
						}
						setKey(e) {
							this.e2eeCtx.setKey(void 0, {
								encryptionKey: e.encryptionKey
							}, e.index)
						}
					}
					var ss = n(9509),
						rs = n.n(ss),
						os = n(3577),
						as = n(4433);
					as.v1, as.v3;
					const cs = as.v4;
					let ds;
					as.v5,
						function(e) {
							e.E2EE_SAS_KEYS_MAC_MISMATCH = "e2ee.sas.keys-mac-mismatch", e.E2EE_SAS_MAC_MISMATCH = "e2ee.sas.mac-mismatch", e.E2EE_SAS_MISSING_KEY = "e2ee.sas.missing-key", e.E2EE_SAS_COMMITMENT_MISMATCHED = "e2ee.sas.commitment-mismatched", e.E2EE_SAS_CHANNEL_VERIFICATION_FAILED = "e2ee.sas.channel-verification-failed", e.E2EE_SAS_INVALID_SAS_VERIFICATION = "e2ee.sas.invalid-sas-verification"
						}(ds || (ds = {}));
					const ls = [
							["", "dog"],
							["", "cat"],
							["", "lion"],
							["", "horse"],
							["", "unicorn"],
							["", "pig"],
							["", "elephant"],
							["", "rabbit"],
							["", "panda"],
							["", "rooster"],
							["", "penguin"],
							["", "turtle"],
							["", "fish"],
							["", "octopus"],
							["", "butterfly"],
							["", "flower"],
							["", "tree"],
							["", "cactus"],
							["", "mushroom"],
							["", "globe"],
							["", "moon"],
							["", "cloud"],
							["", "fire"],
							["", "banana"],
							["", "apple"],
							["", "strawberry"],
							["", "corn"],
							["", "pizza"],
							["", "cake"],
							["", "heart"],
							["", "smiley"],
							["", "robot"],
							["", "hat"],
							["", "glasses"],
							["", "spanner"],
							["", "santa"],
							["", "thumbs up"],
							["", "umbrella"],
							["", "hourglass"],
							["", "clock"],
							["", "gift"],
							["", "light bulb"],
							["", "book"],
							["", "pencil"],
							["", "paperclip"],
							["", "scissors"],
							["", "lock"],
							["", "key"],
							["", "hammer"],
							["", "telephone"],
							["", "flag"],
							["", "train"],
							["", "bicycle"],
							["", "aeroplane"],
							["", "rocket"],
							["", "trophy"],
							["", "ball"],
							["", "guitar"],
							["", "trumpet"],
							["", "bell"],
							["", "anchor"],
							["", "headphones"],
							["", "folder"],
							["", "pin"]
						],
						us = {
							decimal: function(e) {
								return [1e3 + (e[0] << 5 | e[1] >> 3), 1e3 + ((7 & e[1]) << 10 | e[2] << 2 | e[3] >> 6), 1e3 + ((63 & e[3]) << 7 | e[4] >> 1)]
							},
							emoji: function(e) {
								return [e[0] >> 2, (3 & e[0]) << 4 | e[1] >> 4, (15 & e[1]) << 2 | e[2] >> 6, 63 & e[2], e[3] >> 2, (3 & e[3]) << 4 | e[4] >> 4, (15 & e[4]) << 2 | e[5] >> 6].map((e => ls[e]))
							}
						},
						hs = (0, S.getLogger)("modules/e2ee/OlmAdapter.js"),
						ps = 5e3,
						ms = "olm",
						fs = "error",
						gs = "key-info",
						_s = "key-info-ack",
						vs = "session-ack",
						Ss = "session-init",
						Es = "sas-start",
						ys = "sas-accept",
						Ts = "sas-key",
						Cs = "sas-mac",
						bs = "Jitsi-KEY_IDS",
						As = Symbol("OlmData"),
						Rs = {
							PARTICIPANT_E2EE_CHANNEL_READY: "olm.participant_e2ee_channel_ready",
							PARTICIPANT_SAS_AVAILABLE: "olm.participant_sas_available",
							PARTICIPANT_SAS_READY: "olm.participant_sas_ready",
							PARTICIPANT_KEY_UPDATED: "olm.partitipant_key_updated",
							PARTICIPANT_VERIFICATION_COMPLETED: "olm.participant_verification_completed"
						};
					class Is extends Yi {
						constructor(e) {
							super(), this._conf = e, this._init = new zi, this._mediaKey = void 0, this._mediaKeyIndex = -1, this._reqs = new Map, this._sessionInitialization = void 0, Is.isSupported() ? (this._bootstrapOlm(), this._conf.on(de, this._onEndpointMessageReceived.bind(this)), this._conf.on(Q, this._onConferenceLeft.bind(this)), this._conf.on(ze, this._onParticipantLeft.bind(this)), this._conf.on(Oe, this._onParticipantPropertyChanged.bind(this))) : this._init.reject(new Error("Olm not supported"))
						}
						get myId() {
							return this._conf.myUserId()
						}
						async initSessions() {
							if (this._sessionInitialization) throw new Error("OlmAdapter initSessions called multiple times"); {
								this._sessionInitialization = new zi, await this._init;
								const e = [],
									t = this._conf.myUserId();
								for (const n of this._conf.getParticipants()) n.hasFeature(va) && t < n.getId() && e.push(this._sendSessionInit(n));
								await Promise.allSettled(e), this._sessionInitialization.resolve(), this._sessionInitialization = void 0
							}
						}
						static isSupported() {
							return void 0 !== window.Olm
						}
						async updateKey(e) {
							this._mediaKey = e, this._mediaKeyIndex++;
							const t = [];
							for (const e of this._conf.getParticipants()) {
								const n = e.getId(),
									i = this._getParticipantOlmData(e);
								if (!i.session) {
									hs.warn(`Tried to send key to participant ${n} but we have no session`);
									continue
								}
								const s = cs(),
									r = {
										[ga]: ms,
										olm: {
											type: gs,
											data: {
												ciphertext: this._encryptKeyInfo(i.session),
												uuid: s
											}
										}
									},
									o = new zi;
								o.setRejectTimeout(ps), o.catch((() => {
									this._reqs.delete(s)
								})), this._reqs.set(s, o), t.push(o), this._sendMessage(r, n)
							}
							return await Promise.allSettled(t), this._mediaKeyIndex
						}
						updateCurrentMediaKey(e) {
							return this._mediaKey = e, this._mediaKeyIndex
						}
						clearParticipantSession(e) {
							const t = this._getParticipantOlmData(e);
							t.session && (t.session.free(), t.session = void 0)
						}
						clearAllParticipantsSessions() {
							for (const e of this._conf.getParticipants()) this.clearParticipantSession(e)
						}
						markParticipantVerified(e, t) {
							const n = this._getParticipantOlmData(e),
								i = e.getId();
							if (!t) return n.sasVerification = void 0, hs.warn(`Verification failed for participant ${i}`), void this.eventEmitter.emit(Rs.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, ds.E2EE_SAS_CHANNEL_VERIFICATION_FAILED);
							if (!n.sasVerification) return hs.warn(`Participant ${i} does not have valid sasVerification`), void this.eventEmitter.emit(Rs.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, ds.E2EE_SAS_INVALID_SAS_VERIFICATION);
							const {
								sas: s,
								sasMacSent: r
							} = n.sasVerification;
							s && s.is_their_key_set() && !r && (this._sendSasMac(e), n.sasVerification.sasMacSent = !0)
						}
						async _bootstrapOlm() {
							hs.debug("Initializing Olm...");
							try {
								await Olm.init(), this._olmAccount = new Olm.Account, this._olmAccount.create(), this._idKeys = JSON.parse(this._olmAccount.identity_keys()), hs.debug(`Olm ${Olm.get_library_version().join(".")} initialized`), this._init.resolve(), this._onIdKeysReady(this._idKeys)
							} catch (e) {
								hs.error("Failed to initialize Olm", e), this._init.reject(e)
							}
						}
						startVerification(e) {
							const t = e.getId(),
								n = this._getParticipantOlmData(e);
							if (!n.session) return void hs.warn(`Tried to start verification with participant ${t} but we have no session`);
							if (n.sasVerification) return void hs.warn(`There is already a verification in progress with participant ${t}`);
							n.sasVerification = {
								sas: new Olm.SAS,
								transactionId: cs()
							};
							const i = {
								transactionId: n.sasVerification.transactionId
							};
							n.sasVerification.startContent = i, n.sasVerification.isInitiator = !0;
							const s = {
								[ga]: ms,
								olm: {
									type: Es,
									data: i
								}
							};
							this._sendMessage(s, t)
						}
						_onIdKeysReady(e) {
							hs.debug(`Olm id key ready: ${e}`);
							for (const t in e)
								if (e.hasOwnProperty(t)) {
									const n = e[t];
									this._conf.setLocalParticipantProperty(`e2ee.idKey.${t}`, n)
								}
						}
						_onParticipantE2EEChannelReady(e) {
							hs.debug(`E2EE channel with participant ${e} is ready`)
						}
						_encryptKeyInfo(e) {
							const t = {};
							return void 0 !== this._mediaKey && (t.key = !!this._mediaKey && os.fromByteArray(this._mediaKey), t.keyIndex = this._mediaKeyIndex), e.encrypt(JSON.stringify(t))
						}
						_getParticipantOlmData(e) {
							return e[As] = e[As] || {}, e[As]
						}
						async _onConferenceLeft() {
							hs.debug("Conference left"), await this._init;
							for (const e of this._conf.getParticipants()) this._onParticipantLeft(e.getId(), e);
							this._olmAccount && (this._olmAccount.free(), this._olmAccount = void 0)
						}
						async _onEndpointMessageReceived(e, t) {
							if (t[ga] !== ms) return;
							if (!t.olm) return void hs.warn("Incorrectly formatted message");
							await this._init;
							const n = t.olm,
								i = e.getId(),
								s = this._getParticipantOlmData(e);
							switch (n.type) {
								case Ss:
									if (s.session) hs.warn(`Participant ${i} already has a session`), this._sendError(e, "Session already established");
									else {
										const e = new Olm.Session;
										e.create_outbound(this._olmAccount, n.data.idKey, n.data.otKey), s.session = e;
										const t = {
											[ga]: ms,
											olm: {
												type: vs,
												data: {
													ciphertext: this._encryptKeyInfo(e),
													uuid: n.data.uuid
												}
											}
										};
										this._sendMessage(t, i), this._onParticipantE2EEChannelReady(i)
									}
									break;
								case vs:
									if (s.session) hs.warn(`Participant ${i} already has a session`), this._sendError(e, "No session found");
									else if (n.data.uuid === s.pendingSessionUuid) {
										const {
											ciphertext: e
										} = n.data, t = this._reqs.get(n.data.uuid), r = new Olm.Session;
										r.create_inbound(this._olmAccount, e.body), this._olmAccount.remove_one_time_keys(r);
										const o = r.decrypt(e.type, e.body);
										s.session = r, s.pendingSessionUuid = void 0, this._onParticipantE2EEChannelReady(i), this._reqs.delete(n.data.uuid), t.resolve();
										const a = Ps(o);
										if (a.key) {
											const e = os.toByteArray(a.key),
												t = a.keyIndex;
											s.lastKey = e, this.eventEmitter.emit(Rs.PARTICIPANT_KEY_UPDATED, i, e, t)
										}
									} else hs.warn("Received ACK with the wrong UUID"), this._sendError(e, "Invalid UUID");
									break;
								case fs:
									hs.error(n.data.error);
									break;
								case gs:
									if (s.session) {
										const {
											ciphertext: e
										} = n.data, t = Ps(s.session.decrypt(e.type, e.body));
										if (void 0 !== t.key && void 0 !== t.keyIndex) {
											const e = !!t.key && os.toByteArray(t.key),
												r = t.keyIndex;
											_t()(s.lastKey, e) || (s.lastKey = e, this.eventEmitter.emit(Rs.PARTICIPANT_KEY_UPDATED, i, e, r));
											const o = {
												[ga]: ms,
												olm: {
													type: _s,
													data: {
														ciphertext: this._encryptKeyInfo(s.session),
														uuid: n.data.uuid
													}
												}
											};
											this._sendMessage(o, i)
										}
									} else hs.debug(`Received key info message from ${i} but we have no session for them!`), this._sendError(e, "No session found while processing key-info");
									break;
								case _s:
									if (s.session) {
										const {
											ciphertext: e
										} = n.data, t = Ps(s.session.decrypt(e.type, e.body));
										if (void 0 !== t.key && void 0 !== t.keyIndex) {
											const e = !!t.key && os.toByteArray(t.key),
												n = t.keyIndex;
											_t()(s.lastKey, e) || (s.lastKey = e, this.eventEmitter.emit(Rs.PARTICIPANT_KEY_UPDATED, i, e, n))
										}
										const r = this._reqs.get(n.data.uuid);
										this._reqs.delete(n.data.uuid), r.resolve()
									} else hs.debug(`Received key info ack message from ${i} but we have no session for them!`), this._sendError(e, "No session found while processing key-info-ack");
									break;
								case Es: {
									var r;
									if (!s.session) return hs.debug(`Received sas init message from ${i} but we have no session for them!`), void this._sendError(e, "No session found while processing sas-init");
									if (null !== (r = s.sasVerification) && void 0 !== r && r.sas) return hs.warn(`SAS already created for participant ${i}`), void this.eventEmitter.emit(Rs.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, ds.E2EE_SAS_INVALID_SAS_VERIFICATION);
									const {
										transactionId: t
									} = n.data, o = new Olm.SAS;
									s.sasVerification = {
										sas: o,
										transactionId: t,
										isInitiator: !1
									};
									const a = s.sasVerification.sas.get_pubkey(),
										c = this._computeCommitment(a, n.data),
										d = {
											[ga]: ms,
											olm: {
												type: ys,
												data: {
													transactionId: t,
													commitment: c
												}
											}
										};
									this._sendMessage(d, i);
									break
								}
								case ys: {
									if (!s.session) return hs.debug(`Received sas accept message from ${i} but we have no session for them!`), void this._sendError(e, "No session found while processing sas-accept");
									const {
										commitment: t,
										transactionId: r
									} = n.data;
									if (!s.sasVerification) return hs.warn(`SAS_ACCEPT Participant ${i} does not have valid sasVerification`), void this.eventEmitter.emit(Rs.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, ds.E2EE_SAS_INVALID_SAS_VERIFICATION);
									if (s.sasVerification.sasCommitment) return hs.debug(`Already received sas commitment message from ${i}!`), void this._sendError(e, "Already received sas commitment message from ${pId}!");
									s.sasVerification.sasCommitment = t;
									const o = s.sasVerification.sas.get_pubkey(),
										a = {
											[ga]: ms,
											olm: {
												type: Ts,
												data: {
													key: o,
													transactionId: r
												}
											}
										};
									this._sendMessage(a, i), s.sasVerification.keySent = !0;
									break
								}
								case Ts: {
									if (!s.session) return hs.debug(`Received sas key message from ${i} but we have no session for them!`), void this._sendError(e, "No session found while processing sas-key");
									if (!s.sasVerification) return hs.warn(`SAS_KEY Participant ${i} does not have valid sasVerification`), void this.eventEmitter.emit(Rs.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, ds.E2EE_SAS_INVALID_SAS_VERIFICATION);
									const {
										isInitiator: t,
										sas: r,
										sasCommitment: o,
										startContent: a,
										keySent: c
									} = s.sasVerification;
									if (r.is_their_key_set()) return void hs.warn("SAS already has their key!");
									const {
										key: d,
										transactionId: l
									} = n.data;
									if (o && o !== this._computeCommitment(d, a)) return this._sendError(e, "OlmAdapter commitments mismatched"), this.eventEmitter.emit(Rs.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, ds.E2EE_SAS_COMMITMENT_MISMATCHED), void s.sasVerification.free();
									r.set_their_key(d);
									const u = r.get_pubkey(),
										h = `${this.myId}|${u}`,
										p = `${i}|${d}`,
										m = t ? `${h}|${p}` : `${p}|${h}`,
										f = function(e) {
											const t = {};
											for (const n in us) us.hasOwnProperty(n) && (t[n] = us[n](e));
											return t
										}(r.generate_bytes(m, 6));
									if (this.eventEmitter.emit(Rs.PARTICIPANT_SAS_READY, i, f), c) return;
									const g = {
										[ga]: ms,
										olm: {
											type: Ts,
											data: {
												key: u,
												transactionId: l
											}
										}
									};
									this._sendMessage(g, i), s.sasVerification.keySent = !0;
									break
								}
								case Cs: {
									if (!s.session) return hs.debug(`Received sas mac message from ${i} but we have no session for them!`), void this._sendError(e, "No session found while processing sas-mac");
									const {
										keys: t,
										mac: r,
										transactionId: o
									} = n.data;
									if (!r || !t) return void hs.warn("Invalid SAS MAC message");
									if (!s.sasVerification) return void hs.warn(`SAS_MAC Participant ${i} does not have valid sasVerification`);
									const a = s.sasVerification.sas,
										c = `Jitsi-KEY_VERIFICATION_MAC${i}${this.myId}${o}`;
									if (a.calculate_mac(Object.keys(r).sort().join(","), c + bs) !== t) return hs.error("SAS verification error: keys MAC mismatch"), void this.eventEmitter.emit(Rs.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, ds.E2EE_SAS_KEYS_MAC_MISMATCH);
									if (!s.ed25519) return hs.warn("SAS verification error: Missing ed25519 key"), void this.eventEmitter.emit(Rs.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, ds.E2EE_SAS_MISSING_KEY);
									for (const [e, t] of Object.entries(r))
										if (t !== a.calculate_mac(s.ed25519, c + e)) return hs.error("SAS verification error: MAC mismatch"), void this.eventEmitter.emit(Rs.PARTICIPANT_VERIFICATION_COMPLETED, i, !1, ds.E2EE_SAS_MAC_MISMATCH);
									hs.info(`SAS MAC verified for participant ${i}`), this.eventEmitter.emit(Rs.PARTICIPANT_VERIFICATION_COMPLETED, i, !0);
									break
								}
							}
						}
						_onParticipantLeft(e, t) {
							hs.debug(`Participant ${e} left`), this.clearParticipantSession(t)
						}
						async _onParticipantPropertyChanged(e, t, n, i) {
							const s = e.getId(),
								r = this._getParticipantOlmData(e);
							switch (t) {
								case "e2ee.enabled":
									if (i && this._conf.isE2EEEnabled()) {
										const t = this._conf.myUserId();
										if ((await e.getFeatures()).has(va) && t < s) {
											this._sessionInitialization && await this._sessionInitialization, await this._sendSessionInit(e);
											const t = cs(),
												n = new zi;
											n.setRejectTimeout(ps), n.catch((() => {
												this._reqs.delete(t), r.pendingSessionUuid = void 0
											})), this._reqs.set(t, n);
											const i = {
												[ga]: ms,
												olm: {
													type: gs,
													data: {
														ciphertext: this._encryptKeyInfo(r.session),
														uuid: t
													}
												}
											};
											this._sendMessage(i, s)
										}
									}
									break;
								case "e2ee.idKey.ed25519":
									r.ed25519 = i, this.eventEmitter.emit(Rs.PARTICIPANT_SAS_AVAILABLE, s)
							}
						}
						_sendError(e, t) {
							const n = e.getId(),
								i = {
									[ga]: ms,
									olm: {
										type: fs,
										data: {
											error: t
										}
									}
								};
							this._sendMessage(i, n)
						}
						_sendMessage(e, t) {
							this._conf.sendMessage(e, t)
						}
						_sendSessionInit(e) {
							const t = e.getId(),
								n = this._getParticipantOlmData(e);
							if (n.session) return hs.warn(`Tried to send session-init to ${t} but we already have a session`), Promise.reject();
							if (void 0 !== n.pendingSessionUuid) return hs.warn(`Tried to send session-init to ${t} but we already have a pending session`), Promise.reject();
							this._olmAccount.generate_one_time_keys(1);
							const i = JSON.parse(this._olmAccount.one_time_keys()),
								s = Object.values(i.curve25519)[0];
							if (!s) return Promise.reject(new Error("No one-time-keys generated"));
							this._olmAccount.mark_keys_as_published();
							const r = cs(),
								o = {
									[ga]: ms,
									olm: {
										type: Ss,
										data: {
											idKey: this._idKeys.curve25519,
											otKey: s,
											uuid: r
										}
									}
								},
								a = new zi;
							return a.setRejectTimeout(ps), a.catch((() => {
								this._reqs.delete(r), n.pendingSessionUuid = void 0
							})), this._reqs.set(r, a), this._sendMessage(o, t), n.pendingSessionUuid = r, a
						}
						_sendSasMac(e) {
							const t = e.getId(),
								n = this._getParticipantOlmData(e),
								{
									sas: i,
									transactionId: s
								} = n.sasVerification,
								r = {},
								o = [],
								a = `Jitsi-KEY_VERIFICATION_MAC${this.myId}${t}${s}`,
								c = `ed25519:${t}`;
							r[c] = i.calculate_mac(this._idKeys.ed25519, a + c), o.push(c);
							const d = i.calculate_mac(o.sort().join(","), a + bs),
								l = {
									[ga]: ms,
									olm: {
										type: Cs,
										data: {
											keys: d,
											mac: r,
											transactionId: s
										}
									}
								};
							this._sendMessage(l, t)
						}
						_computeCommitment(e, t) {
							const n = new Olm.Utility,
								i = n.sha256(e + JSON.stringify(t));
							return n.free(), i
						}
					}

					function Ps(e) {
						try {
							return JSON.parse(e)
						} catch (e) {
							return {}
						}
					}
					Is.events = Rs;
					const Ds = (0, S.getLogger)("modules/e2ee/ManagedKeyHandler.js");
					class ws extends ns {
						constructor(e) {
							super(e), this._key = void 0, this._conferenceJoined = !1, this._olmAdapter = new Is(e), this._rotateKey = rs()(this._rotateKeyImpl, 5e3), this._ratchetKey = rs()(this._ratchetKeyImpl, 5e3), this._olmAdapter.on(Is.events.PARTICIPANT_KEY_UPDATED, this._onParticipantKeyUpdated.bind(this)), this._olmAdapter.on(Is.events.PARTICIPANT_SAS_READY, this._onParticipantSasReady.bind(this)), this._olmAdapter.on(Is.events.PARTICIPANT_SAS_AVAILABLE, this._onParticipantSasAvailable.bind(this)), this._olmAdapter.on(Is.events.PARTICIPANT_VERIFICATION_COMPLETED, this._onParticipantVerificationCompleted.bind(this)), this.conference.on(Oe, this._onParticipantPropertyChanged.bind(this)), this.conference.on(Xe, this._onParticipantJoined.bind(this)), this.conference.on(ze, this._onParticipantLeft.bind(this)), this.conference.on(Y, (() => {
								this._conferenceJoined = !0
							}))
						}
						get sasVerification() {
							return this._olmAdapter
						}
						async _setEnabled(e) {
							e ? await this._olmAdapter.initSessions() : this._olmAdapter.clearAllParticipantsSessions(), this._key = !!e && this._generateKey();
							const t = await this._olmAdapter.updateKey(this._key);
							this.e2eeCtx.setKey(this.conference.myUserId(), this._key, t)
						}
						async _onParticipantPropertyChanged(e, t, n, i) {
							switch (t) {
								case "e2ee.idKey":
									Ds.debug(`Participant ${e.getId()} updated their id key: ${i}`);
									break;
								case "e2ee.enabled":
									!i && this.enabled && this._olmAdapter.clearParticipantSession(e)
							}
						}
						_onParticipantJoined() {
							this._conferenceJoined && this.enabled && this._ratchetKey()
						}
						_onParticipantLeft(e) {
							this.e2eeCtx.cleanup(e), this.enabled && this._rotateKey()
						}
						async _rotateKeyImpl() {
							Ds.debug("Rotating key"), this._key = this._generateKey();
							const e = await this._olmAdapter.updateKey(this._key);
							this.e2eeCtx.setKey(this.conference.myUserId(), this._key, e)
						}
						async _ratchetKeyImpl() {
							Ds.debug("Ratchetting key");
							const e = await async function(e) {
								return crypto.subtle.importKey("raw", e, "HKDF", !1, ["deriveBits", "deriveKey"])
							}(this._key), t = await async function(e) {
								const t = new TextEncoder;
								return crypto.subtle.deriveBits({
									name: "HKDF",
									salt: t.encode("JFrameRatchetKey"),
									hash: "SHA-256",
									info: new ArrayBuffer
								}, e, 256)
							}(e);
							this._key = new Uint8Array(t);
							const n = this._olmAdapter.updateCurrentKey(this._key);
							this.e2eeCtx.setKey(this.conference.myUserId(), this._key, n)
						}
						_onParticipantKeyUpdated(e, t, n) {
							Ds.debug(`Participant ${e} updated their key`), this.e2eeCtx.setKey(e, t, n)
						}
						_onParticipantSasReady(e, t) {
							this.conference.eventEmitter.emit(he, e, t)
						}
						_onParticipantSasAvailable(e) {
							this.conference.eventEmitter.emit(ue, e)
						}
						_onParticipantVerificationCompleted(e, t, n) {
							this.conference.eventEmitter.emit(pe, e, t, n)
						}
						_generateKey() {
							return window.crypto.getRandomValues(new Uint8Array(32))
						}
					}
					class Os {
						constructor(e) {
							const {
								e2ee: t = {}
							} = e.options.config;
							this._externallyManaged = t.externallyManagedKey, this._externallyManaged ? this._keyHandler = new is(e) : this._keyHandler = new ws(e)
						}
						static isSupported(e) {
							const {
								e2ee: t = {}
							} = e;
							return !(!t.externallyManagedKey && !Is.isSupported()) && !(e.testing && e.testing.disableE2EE) && (Wn.supportsInsertableStreams() || e.enableEncodedTransformSupport && Wn.supportsEncodedTransform())
						}
						isEnabled() {
							return this._keyHandler.isEnabled()
						}
						async setEnabled(e) {
							await this._keyHandler.setEnabled(e)
						}
						setEncryptionKey(e) {
							this._keyHandler.setKey(e)
						}
						startVerification(e) {
							var t;
							null === (t = this._keyHandler.sasVerification) || void 0 === t || t.startVerification(e)
						}
						markParticipantVerified(e, t) {
							var n;
							null === (n = this._keyHandler.sasVerification) || void 0 === n || n.markParticipantVerified(e, t)
						}
					}
					const Ns = new class {
						init(e) {
							this._runInLiteMode = Boolean(e.runInLiteMode), this._ssrcRewriting = Boolean(e.ssrcRewritingEnabled)
						}
						isMultiStreamSendSupportEnabled() {
							return Wn.supportsUnifiedPlan()
						}
						isRunInLiteModeEnabled() {
							return this._runInLiteMode && Wn.supportsInsertableStreams()
						}
						isSsrcRewritingSupported() {
							return this._ssrcRewriting
						}
					};
					var Ms = n(5399),
						Ls = n.n(Ms);
					const ks = ["category", "type", "lang", "name"],
						xs = ["category", "type", "lang"];

					function Fs(e, t) {
						let n = 0;
						return xs.some((i => 0 !== (n = e[i] > t[i] ? 1 : e[i] < t[i] && -1))), n
					}

					function Vs(e) {
						const t = new Set,
							n = new Set;
						return ft()(e).find(">query>feature").each(((e, n) => t.add(n.getAttribute("var")))), ft()(e).find(">query>identity").each(((e, t) => n.add({
							type: t.getAttribute("type"),
							name: t.getAttribute("name"),
							category: t.getAttribute("category")
						}))), {
							features: t,
							identities: n
						}
					}
					class Us extends Yi {
						constructor() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
								t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "http://jitsi.org/jitsimeet";
							if (super(), this.node = t, this.disco = e.disco, !this.disco) throw new Error("Missing strophe-plugins (disco plugin is required)!");
							this.version = "", this.rooms = new Set, this.externalFeatures = new Set;
							const n = e.emuc;
							n.addListener(ki.XMPPEvents.EMUC_ROOM_ADDED, (e => this._addChatRoom(e))), n.addListener(ki.XMPPEvents.EMUC_ROOM_REMOVED, (e => this._removeChatRoom(e))), Object.keys(n.rooms).forEach((e => {
								this._addChatRoom(n.rooms[e])
							})), vt.Strophe.addNamespace("CAPS", "http://jabber.org/protocol/caps"), this.disco.addFeature(vt.Strophe.NS.CAPS)
						}
						addFeature(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
								n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
							this.disco.addFeature(e), this._generateVersion(), n && !this.externalFeatures.has(e) && (this.externalFeatures.add(e), this.rooms.forEach((e => this._updateRoomWithExternalFeatures(e)))), t && this.submit()
						}
						removeFeature(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
								n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
							this.disco.removeFeature(e), this._generateVersion(), n && this.externalFeatures.has(e) && (this.externalFeatures.delete(e), this.rooms.forEach((e => this._updateRoomWithExternalFeatures(e)))), t && this.submit()
						}
						submit() {
							this.rooms.forEach((e => e.sendPresence()))
						}
						_updateRoomWithExternalFeatures(e) {
							if (0 === this.externalFeatures.size) e.removeFromPresence("features");
							else {
								const t = [];
								this.externalFeatures.forEach((e => {
									t.push({
										tagName: "feature",
										attributes: {
											var: e
										}
									})
								})), e.addOrReplaceInPresence("features", {
									children: t
								})
							}
						}
						getFeaturesAndIdentities(e, t) {
							let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5e3;
							return this._getDiscoInfo(e, t, n)
						}
						_getDiscoInfo(e, t, n) {
							return new Promise(((i, s) => this.disco.info(e, t, (e => {
								i(Vs(e))
							}), s, n)))
						}
						_addChatRoom(e) {
							this.rooms.add(e), this._fixChatRoomPresenceMap(e), this._updateRoomWithExternalFeatures(e)
						}
						_removeChatRoom(e) {
							this.rooms.delete(e)
						}
						_fixChatRoomPresenceMap(e) {
							e.addOrReplaceInPresence("c", {
								attributes: {
									xmlns: vt.Strophe.NS.CAPS,
									hash: "sha-1",
									node: this.node,
									ver: this.version
								}
							})
						}
						_notifyVersionChanged() {
							this.rooms.forEach((e => this._fixChatRoomPresenceMap(e)))
						}
						_generateVersion() {
							this.version = function(e, t) {
								const n = e.sort(Fs).reduce(((e, t) => `${ks.reduce(((e,n,i)=>e+(0===i?"":"/")+(t[n]?t[n]:"")),"")}<`), ""),
									i = t.sort().reduce(((e, t) => `${e+t}<`), "");
								return (0, vt.b64_sha1)(n + i)
							}(this.disco._identities, this.disco._features), this._notifyVersionChanged()
						}
					}
					n(9617);
					const js = "NETWORK_INFO_CHANGED",
						Hs = (0, S.getLogger)("modules/connectivity/NetworkInfo.js"),
						Bs = new class extends Yi {
							constructor() {
								super(), this._current = {
									isOnline: !0
								}
							}
							updateNetworkInfo(e) {
								let {
									isOnline: t
								} = e;
								Hs.debug("updateNetworkInfo", {
									isOnline: t
								}), this._current = {
									isOnline: !0 === t
								}, this.eventEmitter.emit(js, this._current)
							}
							isOnline() {
								return !0 === this._current.isOnline
							}
						},
						$s = (0, S.getLogger)("modules/xmpp/ResumeTask.js");
					class Js {
						constructor(e) {
							this._stropheConn = e, this._resumeRetryN = 0, this._retryDelay = void 0
						}
						get retryDelay() {
							return this._retryDelay
						}
						schedule() {
							this._cancelResume(), this._resumeRetryN += 1, this._networkOnlineListener = Bs.addEventListener(js, (e => {
								let {
									isOnline: t
								} = e;
								t ? this._scheduleResume() : this._cancelResume()
							})), Bs.isOnline() && this._scheduleResume()
						}
						_scheduleResume() {
							this._resumeTimeout || (this._resumeRetryN = Math.min(3, this._resumeRetryN), this._retryDelay = function(e) {
								let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500,
									n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2;
								return Math.floor(Math.random() * (1e3 * Math.pow(n, e) - t) + t)
							}(this._resumeRetryN, 1500 * this._resumeRetryN, 3), $s.info(`Will try to resume the XMPP connection in ${this.retryDelay}ms`), this._resumeTimeout = setTimeout((() => this._resumeConnection()), this.retryDelay))
						}
						_cancelResume() {
							this._resumeTimeout && ($s.info("Canceling connection resume task"), clearTimeout(this._resumeTimeout), this._resumeTimeout = void 0, this._retryDelay = void 0)
						}
						_resumeConnection() {
							const {
								streamManagement: e
							} = this._stropheConn, t = e.getResumeToken();
							if (!t) return;
							$s.info("Trying to resume the XMPP connection");
							const n = new URL(this._stropheConn.service);
							let {
								search: i
							} = n;
							const s = /(previd=)([\w-]+)/,
								r = i.match(s);
							r && -1 === r.indexOf(t) ? i = i.replace(s, `$1${t}`) : r || (i += -1 === i.indexOf("?") ? `?previd=${t}` : `&previd=${t}`), n.search = i, this._stropheConn.service = n.toString(), e.resume()
						}
						cancel() {
							this._cancelResume(), this._resumeRetryN = 0, this._networkOnlineListener && (this._networkOnlineListener(), this._networkOnlineListener = null)
						}
					}
					class Gs {
						constructor() {
							this._lastSuccess = null, this._lastFailedMessage = null
						}
						startTracking(e, t) {
							var n = this;
							const i = t.rawInput;
							t.rawInput = function() {
								for (var s = arguments.length, r = new Array(s), o = 0; o < s; o++) r[o] = arguments[o];
								const a = r[0];
								a.includes("failure") && (n._lastFailedMessage = a), e.connected && (n._lastSuccess = Date.now()), i.apply(t, r)
							}
						}
						getLastFailedMessage() {
							return this._lastFailedMessage
						}
						getTimeSinceLastSuccess() {
							return this._lastSuccess ? Date.now() - this._lastSuccess : null
						}
					}

					function qs() {
						let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : class {};
						return class extends e {
							constructor() {
								super(...arguments), this.connection = null
							}
							init(e) {
								this.connection = e
							}
						}
					}
					const Ks = qs(),
						Ws = qs(Yi),
						Xs = (0, S.getLogger)("modules/xmpp/strophe.ping.js");
					class zs extends Ks {
						constructor(e) {
							let {
								getTimeSinceLastServerResponse: t,
								onPingThresholdExceeded: n,
								pingOptions: i = {}
							} = e;
							super(), this.failedPings = 0, this._onPingThresholdExceeded = n, this._getTimeSinceLastServerResponse = t, this.pingInterval = "number" == typeof i.interval ? i.interval : 1e4, this.pingTimeout = "number" == typeof i.timeout ? i.timeout : 5e3, this.pingThreshold = "number" == typeof i.threshold ? i.threshold : 2, this.pingTimestampsToKeep = Math.round(12e4 / this.pingInterval), this.pingExecIntervals = new Array(this.pingTimestampsToKeep)
						}
						init(e) {
							super.init(e), vt.Strophe.addNamespace("PING", "urn:xmpp:ping")
						}
						ping(e, t, n, i) {
							this._addPingExecutionTimestamp();
							const s = (0, vt.$iq)({
								type: "get",
								to: e
							});
							s.c("ping", {
								xmlns: vt.Strophe.NS.PING
							}), this.connection.sendIQ2(s, {
								timeout: i
							}).then(t, n)
						}
						startInterval(e) {
							clearInterval(this.intervalId), this.intervalId = window.setInterval((() => {
								const t = Date.now();
								if (this._getTimeSinceLastServerResponse() < t - this._lastServerCheck) return this._addPingExecutionTimestamp(), this._lastServerCheck = t, void(this.failedPings = 0);
								this.ping(e, (() => {
									this._lastServerCheck = this._getTimeSinceLastServerResponse() + Date.now(), this.failedPings = 0
								}), (e => {
									this.failedPings += 1;
									const t = "Ping " + (e ? "error" : "timeout");
									this.failedPings >= this.pingThreshold ? (ei().callErrorHandler(new Error(t)), Xs.error(t, e), this._onPingThresholdExceeded && this._onPingThresholdExceeded()) : Xs.warn(t, e)
								}), this.pingTimeout)
							}), this.pingInterval), Xs.info(`XMPP pings will be sent every ${this.pingInterval} ms`)
						}
						stopInterval() {
							this.intervalId && (window.clearInterval(this.intervalId), this.intervalId = null, this.failedPings = 0, Xs.info("Ping interval cleared"))
						}
						_addPingExecutionTimestamp() {
							this.pingExecIntervals.push((new Date).getTime()), this.pingExecIntervals.length > this.pingTimestampsToKeep && this.pingExecIntervals.shift()
						}
						getPingSuspendTime() {
							const e = this.pingExecIntervals.slice();
							e.push((new Date).getTime());
							let t = 0,
								n = e[0];
							return e.forEach((e => {
								const i = e - n;
								i > t && (t = i), n = e
							})), t -= this.pingInterval, Math.max(t, 0)
						}
					}
					const Ys = (0, S.getLogger)("modules/xmpp/XmppConnection.js");
					class Qs extends Yi {
						static get Events() {
							return {
								CONN_STATUS_CHANGED: "CONN_STATUS_CHANGED",
								CONN_SHARD_CHANGED: "CONN_SHARD_CHANGED"
							}
						}
						static get Status() {
							return vt.Strophe.Status
						}
						constructor(e) {
							let {
								enableWebsocketResume: t,
								websocketKeepAlive: n,
								websocketKeepAliveUrl: i,
								serviceUrl: s,
								shard: r,
								xmppPing: o
							} = e;
							super(), this._options = {
								enableWebsocketResume: void 0 === t || t,
								pingOptions: o,
								shard: r,
								websocketKeepAlive: void 0 === n ? 6e4 : Number(n),
								websocketKeepAliveUrl: i
								// BAO
							}, this.$msg = vt.$msg, this.$pres = vt.$pres, this.$iq = vt.$iq, this._stropheConn = new vt.Strophe.Connection(s), this._usesWebsocket = s.startsWith("ws:") || s.startsWith("wss:"), this._stropheConn.maxRetries = 3, this._rawInputTracker = new Gs, this._rawInputTracker.startTracking(this, this._stropheConn), this._resumeTask = new Js(this._stropheConn), this._deferredIQs = [], this.addConnectionPlugin("ping", new zs({
								getTimeSinceLastServerResponse: () => this.getTimeSinceLastSuccess(),
								onPingThresholdExceeded: () => this._onPingErrorThresholdExceeded(),
								pingOptions: o
							})), this._oneSuccessfulConnect = !1
						}
						get connected() {
							const e = this._stropheConn && this._stropheConn._proto && this._stropheConn._proto.socket;
							return (this._status === vt.Strophe.Status.CONNECTED || this._status === vt.Strophe.Status.ATTACHED) && (!this.isUsingWebSocket || e && e.readyState === WebSocket.OPEN)
						}
						get disco() {
							return this._stropheConn.disco
						}
						get disconnecting() {
							return !0 === this._stropheConn.disconnecting
						}
						get domain() {
							return this._stropheConn.domain
						}
						get isUsingWebSocket() {
							return this._usesWebsocket
						}
						get jid() {
							return this._stropheConn.jid
						}
						get lastResponseHeaders() {
							return this._stropheConn._proto && this._stropheConn._proto.lastResponseHeaders
						}
						get logger() {
							return this._stropheConn.logger
						}
						get options() {
							return this._stropheConn.options
						}
						get pingDomain() {
							var e;
							return (null === (e = this._options.pingOptions) || void 0 === e ? void 0 : e.domain) || this.domain
						}
						get service() {
							return this._stropheConn.service
						}
						set shard(e) {
							this._options.shard = e, this._oneSuccessfulConnect && this._maybeStartWSKeepAlive()
						}
						get status() {
							return this._status
						}
						addConnectionPlugin(e, t) {
							this[e] = t, t.init(this)
						}
						addHandler() {
							return this._stropheConn.addHandler(...arguments)
						}
						deleteHandler() {
							this._stropheConn.deleteHandler(...arguments)
						}
						attach(e, t, n, i) {
							for (var s = arguments.length, r = new Array(s > 4 ? s - 4 : 0), o = 4; o < s; o++) r[o - 4] = arguments[o];
							this._stropheConn.attach(e, t, n, this._stropheConnectionCb.bind(this, i), ...r)
						}
						connect(e, t, n) {
							for (var i = arguments.length, s = new Array(i > 3 ? i - 3 : 0), r = 3; r < i; r++) s[r - 3] = arguments[r];
							this._stropheConn.connect(e, t, this._stropheConnectionCb.bind(this, n), ...s)
						}
						_stropheConnectionCb(e, t) {
							this._status = t;
							let n = !1;
							var i;
							if (t === vt.Strophe.Status.CONNECTED || t === vt.Strophe.Status.ATTACHED ? (this._maybeEnableStreamResume(), this._usesWebsocket && this._oneSuccessfulConnect && this._keepAliveAndCheckShard(), this._oneSuccessfulConnect = !0, this._maybeStartWSKeepAlive(), this._processDeferredIQs(), this._resumeTask.cancel(), this.ping.startInterval((null === (i = this._options.pingOptions) || void 0 === i ? void 0 : i.domain) || this.domain)) : t === vt.Strophe.Status.DISCONNECTED && (this.ping.stopInterval(), n = this._tryResumingConnection(), n || clearTimeout(this._wsKeepAlive)), !n) {
								for (var s = arguments.length, r = new Array(s > 2 ? s - 2 : 0), o = 2; o < s; o++) r[o - 2] = arguments[o];
								e(t, ...r), this.eventEmitter.emit(Qs.Events.CONN_STATUS_CHANGED, t)
							}
						}
						_clearDeferredIQs() {
							for (const e of this._deferredIQs) e.reject(new Error("disconnect"));
							this._deferredIQs = []
						}
						closeWebsocket() {
							this._stropheConn && this._stropheConn._proto && (this._stropheConn._proto._closeSocket(), this._stropheConn._proto._onClose(null))
						}
						disconnect() {
							this._resumeTask.cancel(), clearTimeout(this._wsKeepAlive), this._clearDeferredIQs(), this._stropheConn.disconnect(...arguments)
						}
						flush() {
							this._stropheConn.flush(...arguments)
						}
						getTimeSinceLastSuccess() {
							return this._rawInputTracker.getTimeSinceLastSuccess()
						}
						getLastFailedMessage() {
							return this._rawInputTracker.getLastFailedMessage()
						}
						_maybeEnableStreamResume() {
							if (!this._options.enableWebsocketResume) return;
							const {
								streamManagement: e
							} = this._stropheConn;
							this.isUsingWebSocket ? e ? e.isSupported() ? e.getResumeToken() || (Ys.info("Enabling XEP-0198 stream management"), e.enable(!0)) : Ys.warn("Stream resume enabled, but XEP-0198 is not supported by the server") : Ys.warn("Stream resume enabled, but Strophe streamManagement plugin is not installed") : Ys.warn("Stream resume enabled, but WebSockets are not enabled")
						}
						_maybeStartWSKeepAlive() {
							const {
								websocketKeepAlive: e
							} = this._options;
							if (this._usesWebsocket && e > 0) {
								this._wsKeepAlive || Ys.info(`WebSocket keep alive interval: ${e}ms`), clearTimeout(this._wsKeepAlive);
								const t = e + 60 * Math.random() * 1e3;
								Ys.debug(`Scheduling next WebSocket keep-alive in ${t}ms`), this._wsKeepAlive = setTimeout((() => this._keepAliveAndCheckShard().then((() => this._maybeStartWSKeepAlive()))), t)
							}
						}
						_keepAliveAndCheckShard() {
							const {
								shard: e,
								websocketKeepAliveUrl: t
							} = this._options, n = t || this.service.replace("wss://", "https://").replace("ws://", "http://");
							return fetch(n,{mode: 'no-cors'}).then((t => {	// BAO	gj:add no-cors							
								if (!e) return;
								const n = t.headers.get("x-jitsi-shard");
								n !== e && (Ys.error(`Detected that shard changed from ${e} to ${n}`), this.eventEmitter.emit(Qs.Events.CONN_SHARD_CHANGED))
							})).catch((e => {
								Ys.error(`Websocket Keep alive failed for url: ${n}`, {
									error: e
								})
							}))
						}
						_processDeferredIQs() {
							for (const e of this._deferredIQs)
								if (e.iq) {
									clearTimeout(e.timeout);
									const t = Date.now() - e.start;
									this.sendIQ(e.iq, (t => e.resolve(t)), (t => e.reject(t)), t)
								} this._deferredIQs = []
						}
						send(e) {
							if (!this.connected) throw new Error("Not connected");
							this._stropheConn.send(e)
						}
						sendIQ(e, t, n, i) {
							if (this.connected) return this._stropheConn.sendIQ(e, t, n, i);
							n("Not connected")
						}
						sendIQ2(e, t) {
							let {
								timeout: n
							} = t;
							return new Promise(((t, i) => {
								if (this.connected) this.sendIQ(e, (e => t(e)), (e => i(e)), n);
								else {
									const s = {
										iq: e,
										resolve: t,
										reject: i,
										start: Date.now(),
										timeout: setTimeout((() => {
											s.iq = void 0, i(void 0)
										}), n)
									};
									this._deferredIQs.push(s)
								}
							}))
						}
						_onPingErrorThresholdExceeded() {
							this.isUsingWebSocket && (Ys.warn("Ping error threshold exceeded - killing the WebSocket"), this.closeWebsocket())
						}
						sendPresence(e, t, n, i) {
							this.connected ? this._stropheConn.sendPresence(e, t, n, i) : n("Not connected")
						}
						sendUnavailableBeacon() {
							if (!navigator.sendBeacon || this._stropheConn.disconnecting || !this._stropheConn.connected) return !1;
							this._stropheConn._changeConnectStatus(vt.Strophe.Status.DISCONNECTING), this._stropheConn.disconnecting = !0;
							const e = this._stropheConn._proto._buildBody().attrs({
									type: "terminate"
								}),
								t = (0, vt.$pres)({
									xmlns: vt.Strophe.NS.CLIENT,
									type: "unavailable"
								});
							e.cnode(t.tree());
							const n = navigator.sendBeacon(-1 === this.service.indexOf("https://") ? `https:${this.service}` : this.service, vt.Strophe.serialize(e.tree()));
							return Ys.info(`Successfully send unavailable beacon ${n}`), this._stropheConn._proto._abortAllRequests(), this._stropheConn._doDisconnect(), !0
						}
						_tryResumingConnection() {
							const {
								streamManagement: e
							} = this._stropheConn;
							return !(!e || !e.getResumeToken() || (this._resumeTask.schedule(), 0))
						}
					}
					let Zs;
					! function(e) {
						e.ON = "on", e.OFF = "off"
					}(Zs || (Zs = {}));
					const er = Zs.ON,
						tr = Zs.OFF,
						nr = (0, S.getLogger)("modules/xmpp/AVModeration.js");
					class ir {
						constructor(e) {
							this._xmpp = e.xmpp, this._mainRoom = e, this._moderationEnabledByType = {
								[_i.AUDIO]: !1,
								[_i.VIDEO]: !1
							}, this._whitelistAudio = [], this._whitelistVideo = [], this._onMessage = this._onMessage.bind(this), this._xmpp.addListener(ki.XMPPEvents.AV_MODERATION_RECEIVED, this._onMessage)
						}
						dispose() {
							this._xmpp.removeListener(ki.XMPPEvents.AV_MODERATION_RECEIVED, this._onMessage)
						}
						isSupported() {
							return Boolean(this._xmpp.avModerationComponentAddress)
						}
						enable(e, t) {
							if (!this.isSupported() || !this._mainRoom.isModerator()) return void nr.error(`Cannot enable:${e} AV moderation supported:${this.isSupported()},\n                moderator:${this._mainRoom.isModerator()}`);
							if (e === this._moderationEnabledByType[t]) return void nr.warn(`Moderation already in state:${e} for mediaType:${t}`);
							const n = (0, vt.$msg)({
								to: this._xmpp.avModerationComponentAddress
							});
							n.c("av_moderation", {
								enable: e,
								mediaType: t
							}).up(), this._xmpp.connection.send(n)
						}
						approve(e, t) {
							if (!this.isSupported() || !this._mainRoom.isModerator()) return void nr.error(`Cannot approve in AV moderation supported:${this.isSupported()},\n                moderator:${this._mainRoom.isModerator()}`);
							const n = (0, vt.$msg)({
								to: this._xmpp.avModerationComponentAddress
							});
							n.c("av_moderation", {
								mediaType: e,
								jidToWhitelist: t
							}).up(), this._xmpp.connection.send(n)
						}
						reject(e, t) {
							if (!this.isSupported() || !this._mainRoom.isModerator()) return void nr.error(`Cannot reject in AV moderation supported:${this.isSupported()},\n                moderator:${this._mainRoom.isModerator()}`);
							const n = (0, vt.$msg)({
								to: this._xmpp.avModerationComponentAddress
							});
							n.c("av_moderation", {
								mediaType: e,
								jidToBlacklist: t
							}).up(), this._xmpp.connection.send(n)
						}
						_onMessage(e) {
							const {
								removed: t,
								mediaType: n,
								enabled: i,
								approved: s,
								actor: r,
								whitelists: o
							} = e;
							if (o) {
								const e = n === _i.AUDIO ? this._whitelistAudio : this._whitelistVideo,
									i = Array.isArray(o[n]) ? o[n] : [];
								t ? e.filter((e => !i.includes(e))).forEach((e => this._xmpp.eventEmitter.emit(ki.XMPPEvents.AV_MODERATION_PARTICIPANT_REJECTED, n, e))) : i.filter((t => !e.includes(t))).forEach((e => this._xmpp.eventEmitter.emit(ki.XMPPEvents.AV_MODERATION_PARTICIPANT_APPROVED, n, e))), n === _i.AUDIO ? this._whitelistAudio = i : this._whitelistVideo = i
							} else void 0 !== i && this._moderationEnabledByType[n] !== i ? (this._moderationEnabledByType[n] = i, this._xmpp.eventEmitter.emit(ki.XMPPEvents.AV_MODERATION_CHANGED, i, n, r)) : t ? this._xmpp.eventEmitter.emit(ki.XMPPEvents.AV_MODERATION_REJECTED, n) : s && this._xmpp.eventEmitter.emit(ki.XMPPEvents.AV_MODERATION_APPROVED, n)
						}
					}
					const sr = "features/breakout-rooms",
						rr = {
							ADD: `${sr}/add`,
							REMOVE: `${sr}/remove`,
							MOVE_TO_ROOM: `${sr}/move-to-room`
						},
						or = `${sr}/move-to-room`,
						ar = `${sr}/update`,
						cr = (0, S.getLogger)("modules/xmpp/BreakoutRooms.js");
					class dr {
						constructor(e) {
							this.room = e, this._handleMessages = this._handleMessages.bind(this), this.room.xmpp.addListener(ki.XMPPEvents.BREAKOUT_ROOMS_EVENT, this._handleMessages), this._rooms = {}
						}
						dispose() {
							this.room.xmpp.removeListener(ki.XMPPEvents.BREAKOUT_ROOMS_EVENT, this._handleMessages)
						}
						createBreakoutRoom(e) {
							if (!this.isSupported() || !this.room.isModerator()) return void cr.error(`Cannot create breakout room - supported:${this.isSupported()},\n                moderator:${this.room.isModerator()}`);
							const t = {
								type: rr.ADD,
								subject: e
							};
							this._sendMessage(t)
						}
						removeBreakoutRoom(e) {
							if (!this.isSupported() || !this.room.isModerator()) return void cr.error(`Cannot remove breakout room - supported:${this.isSupported()},\n                moderator:${this.room.isModerator()}`);
							const t = {
								type: rr.REMOVE,
								breakoutRoomJid: e
							};
							this._sendMessage(t)
						}
						sendParticipantToRoom(e, t) {
							if (!this.isSupported() || !this.room.isModerator()) return void cr.error(`Cannot send participant to room - supported:${this.isSupported()},\n                moderator:${this.room.isModerator()}`);
							const n = {
								type: rr.MOVE_TO_ROOM,
								participantJid: e,
								roomJid: t
							};
							this._sendMessage(n)
						}
						isSupported() {
							return Boolean(this.getComponentAddress())
						}
						getComponentAddress() {
							return this.room.xmpp.breakoutRoomsComponentAddress
						}
						_setIsBreakoutRoom(e) {
							this._isBreakoutRoom = e
						}
						isBreakoutRoom() {
							return void 0 !== this._isBreakoutRoom ? this._isBreakoutRoom : vt.Strophe.getDomainFromJid(this.room.myroomjid) === this.getComponentAddress()
						}
						_setMainRoomJid(e) {
							this._mainRoomJid = e
						}
						getMainRoomJid() {
							return this._mainRoomJid
						}
						_handleMessages(e) {
							switch (e.event) {
								case or:
									this.room.eventEmitter.emit(ki.XMPPEvents.BREAKOUT_ROOMS_MOVE_TO_ROOM, e.roomJid);
									break;
								case ar: {
									const t = this._filterUpdatePayload(e);
									this._rooms = t.rooms, this.room.eventEmitter.emit(ki.XMPPEvents.BREAKOUT_ROOMS_UPDATED, t);
									break
								}
							}
						}
						_filterUpdatePayload(e) {
							const t = this.room.options.hiddenDomain,
								{
									rooms: n
								} = e,
								i = {};
							return Object.entries(n).forEach((e => {
								let [n, s] = e;
								const {
									participants: r = {}
								} = s, o = {};
								Object.entries(r).forEach((e => {
									let [n, i] = e;
									vt.Strophe.getDomainFromJid(i.jid) !== t && (o[n] = i)
								})), i[n] = {
									...s,
									participants: o
								}
							})), {
								...e,
								rooms: i
							}
						}
						_sendMessage(e) {
							const t = (0, vt.$msg)({
								to: this.getComponentAddress()
							});
							t.c("breakout_rooms", e).up(), this.room.xmpp.connection.send(t)
						}
					}
					const lr = (0, S.getLogger)("modules/xmpp/Lobby.js"),
						ur = "email";
					class hr {
						constructor(e) {
							this.xmpp = e.xmpp, this.mainRoom = e;
							const t = this._maybeJoinLobbyRoom.bind(this);
							this.mainRoom.addEventListener(ki.XMPPEvents.LOCAL_ROLE_CHANGED, t), this.mainRoom.addEventListener(ki.XMPPEvents.MUC_MEMBERS_ONLY_CHANGED, t), this.mainRoom.addEventListener(ki.XMPPEvents.ROOM_CONNECT_MEMBERS_ONLY_ERROR, (e => {
								this.lobbyRoomJid = e
							}))
						}
						isSupported() {
							return this.xmpp.lobbySupported
						}
						enable() {
							return this.isSupported() ? new Promise(((e, t) => {
								this.mainRoom.setMembersOnly(!0, e, t)
							})) : Promise.reject(new Error("Lobby not supported!"))
						}
						disable() {
							this.isSupported() && this.mainRoom.isModerator() && this.lobbyRoom && this.mainRoom.membersOnlyEnabled && this.mainRoom.setMembersOnly(!1)
						}
						sendMessage(e) {
							this.lobbyRoom && this.lobbyRoom.sendMessage(JSON.stringify(e), "json-message")
						}
						sendPrivateMessage(e, t) {
							this.lobbyRoom && this.lobbyRoom.sendPrivateMessage(e, JSON.stringify(t), "json-message")
						}
						getLocalId() {
							if (this.lobbyRoom) return vt.Strophe.getResourceFromJid(this.lobbyRoom.myroomjid)
						}
						addMessageListener(e) {
							if (this.lobbyRoom) {
								const t = (t, n) => {
									e(n, vt.Strophe.getResourceFromJid(t))
								};
								return this.lobbyRoom.on(ki.XMPPEvents.JSON_MESSAGE_RECEIVED, t), t
							}
						}
						removeMessageHandler(e) {
							this.lobbyRoom && this.lobbyRoom.off(ki.XMPPEvents.JSON_MESSAGE_RECEIVED, e)
						}
						leave() {
							return this.lobbyRoom ? this.lobbyRoom.leave().then((() => {
								this.lobbyRoom = void 0, lr.info("Lobby room left!")
							})).catch((() => {})) : Promise.reject(new Error("The lobby has already been left"))
						}
						setLobbyRoomJid(e) {
							this.lobbyRoomJid = e
						}
						_maybeJoinLobbyRoom() {
							this.isSupported() && this.mainRoom.joined && this.mainRoom.isModerator() && this.mainRoom.membersOnlyEnabled && !this.lobbyRoom && this.join().then((() => lr.info("Joined lobby room"))).catch((e => lr.error("Failed joining lobby", e)))
						}
						join(e, t) {
							const n = this.mainRoom.joined && this.mainRoom.isModerator();
							if (!this.lobbyRoomJid) return Promise.reject(new Error("Missing lobbyRoomJid, cannot join lobby room."));
							const i = vt.Strophe.getNodeFromJid(this.lobbyRoomJid),
								s = vt.Strophe.getDomainFromJid(this.lobbyRoomJid);
							return this.lobbyRoom = this.xmpp.createRoom(i, {
								customDomain: s,
								disableDiscoInfo: !0,
								disableFocus: !0,
								enableLobby: !1
							}), e && this.lobbyRoom.addOrReplaceInPresence("nick", {
								attributes: {
									xmlns: "http://jabber.org/protocol/nick"
								},
								value: e
							}), n ? (this.lobbyRoom.addPresenceListener(ur, ((e, t) => {
								this.mainRoom.eventEmitter.emit(ki.XMPPEvents.MUC_LOBBY_MEMBER_UPDATED, t, {
									email: e.value
								})
							})), this.lobbyRoom.addEventListener(ki.XMPPEvents.MUC_MEMBER_JOINED, ((e, t, n, i, s, r, o, a, c) => {
								if (!Object.values(this.mainRoom.members).find((e => e.jid === c))) {
									for (const e of Object.values(this.mainRoom.getBreakoutRooms()._rooms))
										if (Object.values(e.participants).find((e => e.jid === c))) return;
									this.mainRoom.eventEmitter.emit(ki.XMPPEvents.MUC_LOBBY_MEMBER_JOINED, vt.Strophe.getResourceFromJid(e), t, o ? o.avatar : void 0)
								}
							})), this.lobbyRoom.addEventListener(ki.XMPPEvents.MUC_MEMBER_LEFT, (e => {
								this.mainRoom.eventEmitter.emit(ki.XMPPEvents.MUC_LOBBY_MEMBER_LEFT, vt.Strophe.getResourceFromJid(e))
							})), this.lobbyRoom.addEventListener(ki.XMPPEvents.MUC_DESTROYED, (() => {
								Object.keys(this.lobbyRoom.members).forEach((e => this.mainRoom.eventEmitter.emit(ki.XMPPEvents.MUC_LOBBY_MEMBER_LEFT, vt.Strophe.getResourceFromJid(e)))), this.lobbyRoom.clean(), this.lobbyRoom = void 0, lr.info("Lobby room left(destroyed)!")
							}))) : (this.lobbyRoom.addEventListener(ki.XMPPEvents.KICKED, (e => {
								if (e) return this.mainRoom.eventEmitter.emit(ki.XMPPEvents.MUC_DENIED_ACCESS), void this.lobbyRoom.clean()
							})), this.mainRoom.addEventListener(ki.XMPPEvents.INVITE_MESSAGE_RECEIVED, ((e, t, n, i) => {
								lr.debug(`Received approval to join ${e} ${t} ${n}`), e === this.mainRoom.roomjid && this.mainRoom.join(i)
							})), this.lobbyRoom.addEventListener(ki.XMPPEvents.MUC_DESTROYED, ((e, t) => {
								t ? this.mainRoom.join() : (this.lobbyRoom.clean(), this.mainRoom.eventEmitter.emit(ki.XMPPEvents.MUC_DESTROYED, e))
							})), this.mainRoom.addEventListener(ki.XMPPEvents.MUC_JOINED, (() => {
								this.leave()
							}))), new Promise(((e, i) => {
								this.lobbyRoom.addEventListener(ki.XMPPEvents.MUC_JOINED, (() => {
									e(), t && !n && this.lobbyRoom.addOrReplaceInPresence(ur, {
										value: t
									}) && this.lobbyRoom.sendPresence()
								})), this.lobbyRoom.addEventListener(ki.XMPPEvents.ROOM_JOIN_ERROR, i), this.lobbyRoom.addEventListener(ki.XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR, i), this.lobbyRoom.addEventListener(ki.XMPPEvents.ROOM_CONNECT_ERROR, i), this.lobbyRoom.join()
							}))
						}
						denyAccess(e) {
							if (!this.isSupported() || !this.mainRoom.isModerator()) return;
							const t = Object.keys(this.lobbyRoom.members).find((t => vt.Strophe.getResourceFromJid(t) === e));
							t ? this.lobbyRoom.kick(t) : lr.error(`Not found member for ${e} in lobby room.`)
						}
						approveAccess(e) {
							if (!this.isSupported() || !this.mainRoom.isModerator()) return;
							let t = this.mainRoom.roomjid;
							this.mainRoom.getBreakoutRooms().isBreakoutRoom() && (t = this.mainRoom.getBreakoutRooms().getMainRoomJid());
							const n = Object.keys(this.lobbyRoom.members).find((t => vt.Strophe.getResourceFromJid(t) === e));
							if (n) {
								const e = this.lobbyRoom.members[n].jid,
									i = (0, vt.$msg)({
										to: t
									}).c("x", {
										xmlns: "http://jabber.org/protocol/muc#user"
									}).c("invite", {
										to: e
									});
								this.xmpp.connection.sendIQ(i, (() => {}), (t => {
									lr.error(`Error sending invite for ${e}`, t)
								}))
							} else lr.error(`Not found member for ${n} in lobby room.`)
						}
					}
					const pr = (0, S.getLogger)("modules/xmpp/RoomMetadata.ts");
					class mr {
						constructor(e) {
							this.room = e, this._handleMessages = this._handleMessages.bind(this), this.room.xmpp.addListener(ki.XMPPEvents.ROOM_METADATA_EVENT, this._handleMessages), this._metadata = {}
						}
						dispose() {
							this.room.xmpp.removeListener(ki.XMPPEvents.ROOM_METADATA_EVENT, this._handleMessages)
						}
						setMetadata(e, t) {
							if (!this.isSupported() || !this.room.isModerator()) return void pr.error(`Cannot set room metadata - supported:${this.isSupported()},\n                moderator:${this.room.isModerator()}`);
							const n = {
								key: e,
								data: t
							};
							this._sendMessage(n)
						}
						getMetadata() {
							return this._metadata
						}
						isSupported() {
							return Boolean(this.getComponentAddress())
						}
						getComponentAddress() {
							return this.room.xmpp.roomMetadataComponentAddress
						}
						_handleMessages(e) {
							const {
								metadata: t
							} = e;
							t && !_t()(this._metadata, t) && (this._metadata = t, this.room.eventEmitter.emit(ki.XMPPEvents.ROOM_METADATA_UPDATED, t))
						}
						_sendMessage(e) {
							e[ga] = "room_metadata";
							const t = (0, vt.$msg)({
								to: this.getComponentAddress()
							});
							t.c("room_metadata", {
								room: this.room.roomjid,
								xmlns: "http://jitsi.org/jitmeet"
							}, JSON.stringify(e)).up(), this.room.xmpp.connection.send(t)
						}
					}
					var fr = n(6667),
						gr = n.n(fr);
					const _r = (0, S.getLogger)("modules/settings/Settings.js");
					let vr, Sr;
					const Er = {
						_storage: qn,
						init(e) {
							this._storage = e || qn
						},
						get callStatsUserName() {
							return vr || (vr = this._storage.getItem("callStatsUserName"), vr || (vr = function() {
								const e = gr().generateUsername();
								return _r.log("generated callstats uid", e), e
							}(), this._storage.setItem("callStatsUserName", vr))), vr
						},
						get machineId() {
							if (!Sr) {
								const e = this._storage.getItem("billingId");
								Sr = e || this._storage.getItem("jitsiMeetId"), e ? this._storage.setItem("jitsiMeetId", e) : Sr || (Sr = function() {
									const e = yr() + yr() + yr() + yr();
									return _r.log("generated id", e), e
								}(), this._storage.setItem("jitsiMeetId", Sr))
							}
							return Sr
						},
						get sessionId() {
							return this._storage.getItem("sessionId")
						},
						set sessionId(e) {
							e ? this._storage.setItem("sessionId", e) : this._storage.removeItem("sessionId")
						}
					};

					function yr() {
						return `${Math.random().toString(16)}000000000`.substr(2, 8)
					}
					const Tr = n(3514),
						{
							XMPPEvents: Cr
						} = n(609),
						br = n(1023),
						Ar = (0, S.getLogger)("modules/xmpp/moderator.js");

					function Rr(e) {
						let t = 1;
						return function(n) {
							if (n) return void(t = 1);
							const i = Math.pow(2, t - 1);
							return t += 1, Math.min(i * e, 12e4)
						}
					}

					function Ir(e, t, n, i) {
						var s, r;

						function o(e) {
							if (e.data && e.data.sessionId) {
								if (e.origin !== window.location.origin) return void Ar.warn(`Ignoring sessionId from different origin: ${e.origin}`);
								Er.sessionId = e.data.sessionId
							}
						}
						this.roomName = e, this.getNextTimeout = Rr(1e3), this.getNextErrorTimeout = Rr(1e3), this.options = i, this.externalAuthEnabled = !1, this.sipGatewayEnabled = !1, this.eventEmitter = n, this.connection = t.connection, this.targetJid = null === (s = this.options.hosts) || void 0 === s ? void 0 : s.focus, this.targetJid || (this.targetJid = `focus.${null===(r=this.options.hosts)||void 0===r?void 0:r.domain}`), this.targetUrl = this.options.conferenceRequestUrl, this.mode = this.targetUrl ? "http" : "xmpp", Ar.info(`Using ${this.mode} for conference requests.`), this.focusUserJids = new Set, i.focusUserJid && this.focusUserJids.add(i.focusUserJid), window.addEventListener ? window.addEventListener("message", o, !1) : window.attachEvent("onmessage", o)
					}
					Ir.prototype.isFocusJid = function(e) {
						if (!e) return !1;
						for (const t of this.focusUserJids)
							if (0 === e.indexOf(`${t}/`)) return !0;
						return !1
					}, Ir.prototype.isExternalAuthEnabled = function() {
						return this.externalAuthEnabled
					}, Ir.prototype.isSipGatewayEnabled = function() {
						return this.sipGatewayEnabled
					}, Ir.prototype._createConferenceRequest = function() {
						var e, t;
						const {
							sessionId: n
						} = Er, i = this.options, s = {};
						void 0 !== i.startAudioMuted && (s.startAudioMuted = i.startAudioMuted), void 0 !== i.startVideoMuted && (s.startVideoMuted = i.startVideoMuted), null !== (e = null == i || null === (t = i.analytics) || void 0 === t ? void 0 : t.rtcstatsEnabled) && void 0 !== e && e || (s.rtcstatsEnabled = !1);
						const r = {
							properties: s,
							machineUid: Er.machineId,
							room: this.roomName
						};
						return n && (r.sessionId = n), r
					}, Ir.prototype._createConferenceIq = function() {
						const e = this._createConferenceRequest(),
							t = (0, vt.$iq)({
								to: this.targetJid,
								type: "set"
							});
						t.c("conference", {
							xmlns: "http://jitsi.org/protocol/focus",
							room: this.roomName,
							"machine-uid": e.machineUid
						}), e.sessionId && t.attrs({
							"session-id": e.sessionId
						});
						for (const n in e.properties) e.properties.hasOwnProperty(n) && t.c("property", {
							name: n,
							value: e.properties[n]
						}).up();
						return t
					}, Ir.prototype._parseConferenceIq = function(e) {
						const t = {
							properties: {}
						};
						return t.focusJid = ft()(e).find("conference").attr("focusjid"), t.sessionId = ft()(e).find("conference").attr("session-id"), t.identity = ft()(e).find(">conference").attr("identity"), t.ready = "true" === ft()(e).find("conference").attr("ready"), t.vnode = ft()(e).find("conference").attr("vnode"), ft()(e).find(">conference>property[name='authentication'][value='true']").length > 0 && (t.properties.authentication = "true"), ft()(e).find(">conference>property[name='externalAuth'][value='true']").length > 0 && (t.properties.externalAuth = "true"), ft()(e).find(">conference>property[name='sipGatewayEnabled'][value='true']").length > 0 && (t.properties.sipGatewayEnabled = "true"), t
					}, Ir.prototype.sendConferenceRequest = function() {
						return new Promise((e => {
							"xmpp" === this.mode ? (Ar.info(`Sending conference request over XMPP to ${this.targetJid}`), this.connection.sendIQ(this._createConferenceIq(), (t => this._handleIqSuccess(t, e)), (t => this._handleIqError(t, e))), this.connection.flush()) : (Ar.info(`Sending conference request over HTTP to ${this.targetUrl}`), fetch(this.targetUrl, {
								method: "POST",
								body: JSON.stringify(this._createConferenceRequest()),
								headers: {
									"Content-Type": "application/json"
								}
							}).then((t => {
								t.ok ? t.json().then((t => {
									this._handleSuccess(t, e)
								})) : t.text().then((n => {
									Ar.warn(`Received HTTP ${t.status} ${t.statusText}. Body: ${n}`);
									const i = 400 === t.status && n.indexOf("400 invalid-session") > 0,
										s = 403 === t.status;
									this._handleError(i, s, e)
								})).catch((e => {
									Ar.warn(`Error: ${e}`), this._handleError()
								}))
							})).catch((e => {
								Ar.warn(`Error: ${e}`), this._handleError()
							})))
						}))
					}, Ir.prototype._handleSuccess = function(e, t) {
						this.getNextErrorTimeout(!0), e.focusJid ? (Ar.info(`Adding focus JID: ${e.focusJid}`), this.focusUserJids.add(e.focusJid)) : Ar.warn("Conference request response contained no focusJid.");
						const n = "true" === e.properties.authentication;
						if (Ar.info(`Authentication enabled: ${n}`), this.externalAuthEnabled = "true" === e.properties.externalAuth, Ar.info(`External authentication enabled: ${this.externalAuthEnabled}`), !this.externalAuthEnabled && e.sessionId && (Ar.info(`Received sessionId: ${e.sessionId}`), Er.sessionId = e.sessionId), this.eventEmitter.emit(Tr.IDENTITY_UPDATED, n, e.identity), this.sipGatewayEnabled = e.properties.sipGatewayEnabled, Ar.info(`Sip gateway enabled: ${this.sipGatewayEnabled}`), e.ready) {
							if (this.getNextTimeout(!0), e.vnode) return Ar.warn(`Redirected to: ${e.vnode} with focusJid ${e.focusJid} }`), void this.eventEmitter.emit(Cr.REDIRECTED, e.vnode, e.focusJid);
							Ar.info("Conference-request successful, ready to join the MUC."), t()
						} else {
							const e = this.getNextTimeout();
							Ar.info(`Not ready yet, will retry in ${e} ms.`), window.setTimeout((() => this.sendConferenceRequest().then(t)), e)
						}
					}, Ir.prototype._handleError = function(e, t, n) {
						if (e && (Ar.info("Session expired! - removing"), Er.sessionId = void 0), t) return Ar.warn("Unauthorized to start the conference"), void this.eventEmitter.emit(Cr.AUTHENTICATION_REQUIRED);
						const i = this.getNextErrorTimeout();
						if (e && i < 6e4) Ar.info(`Invalid session, will retry after ${i} ms.`), this.getNextTimeout(!0), window.setTimeout((() => this.sendConferenceRequest().then(n)), i);
						else {
							const e = "Failed to get a successful response, giving up.",
								t = new Error(e);
							Ar.error(e, t), br.callErrorHandler(t), this.eventEmitter.emit(Cr.FOCUS_DISCONNECTED)
						}
					}, Ir.prototype._handleIqError = function(e, t) {
						const n = ft()(e).find(">error>reservation-error");
						if (n.length) {
							const t = n.attr("error-code"),
								i = ft()(e).find(">error>text");
							let s;
							return i && (s = i.text()), void this.eventEmitter.emit(Cr.RESERVATION_ERROR, t, s)
						}
						const i = Boolean(ft()(e).find(">error>session-invalid").length || ft()(e).find(">error>not-acceptable").length),
							s = ft()(e).find(">error>not-authorized").length > 0;
						s && vt.Strophe.getDomainFromJid(e.getAttribute("to")) !== this.options.hosts.anonymousdomain && (this.externalAuthEnabled = !0), this._handleError(i, s, t)
					}, Ir.prototype._handleIqSuccess = function(e, t) {
						const n = this._parseConferenceIq(e);
						this._handleSuccess(n, t)
					}, Ir.prototype.authenticate = function() {
						return new Promise(((e, t) => {
							this.connection.sendIQ(this._createConferenceIq(), (t => {
								const n = ft()(t).find("conference").attr("session-id");
								n ? (Ar.info(`Received sessionId:  ${n}`), Er.sessionId = n) : Ar.warn("Response did not contain a session-id"), e()
							}), (e => t({
								error: ft()(e).find("iq>error :first").prop("tagName"),
								message: ft()(e).find("iq>error>text").text()
							})))
						}))
					}, Ir.prototype.getLoginUrl = function(e, t) {
						this._getLoginUrl(!1, e, t)
					}, Ir.prototype._getLoginUrl = function(e, t, n) {
						const i = (0, vt.$iq)({
								to: this.targetJid,
								type: "get"
							}),
							s = {
								xmlns: "http://jitsi.org/protocol/focus",
								room: this.roomName,
								"machine-uid": Er.machineId
							};
						let r = "auth url";

						function o(e, t) {
							br.callErrorHandler(new Error(e)), Ar.error(e, t), n(t)
						}
						e && (s.popup = !0, r = `POPUP ${r}`), i.c("login-url", s), this.connection.sendIQ(i, (e => {
							let n = ft()(e).find("login-url").attr("url");
							n = decodeURIComponent(n), n ? (Ar.info(`Got ${r}: ${n}`), t(n)) : o(`Failed to get ${r} from the focus`, e)
						}), o.bind(void 0, `Get ${r} error`))
					}, Ir.prototype.getPopupLoginUrl = function(e, t) {
						this._getLoginUrl(!0, e, t)
					}, Ir.prototype.logout = function(e) {
						const t = (0, vt.$iq)({
								to: this.targetJid,
								type: "set"
							}),
							{
								sessionId: n
							} = Er;
						n ? (t.c("logout", {
							xmlns: "http://jitsi.org/protocol/focus",
							"session-id": n
						}), this.connection.sendIQ(t, (t => {
							let n = ft()(t).find("logout").attr("logout-url");
							n && (n = decodeURIComponent(n)), Ar.info(`Log out OK, url: ${n}`, t), Er.sessionId = void 0, e(n)
						}), (e => {
							const t = "Logout error";
							br.callErrorHandler(new Error(t)), Ar.error(t, e)
						}))) : e()
					};
					const Pr = (0, S.getLogger)("modules/xmpp/ChatRoom.js"),
						Dr = {
							packet2JSON(e, t) {
								for (const n of Array.from(e.children)) {
									const e = {
										attributes: {},
										children: [],
										tagName: n.tagName
									};
									for (const t of Array.from(n.attributes)) e.attributes[t.name] = t.value;
									const i = vt.Strophe.getText(n);
									i && (e.value = vt.Strophe.xmlunescape(i)), t.push(e), this.packet2JSON(n, e.children)
								}
							},
							json2packet(e, t) {
								for (let n = 0; n < e.length; n++) {
									const i = e[n];
									i && (t.c(i.tagName, i.attributes), i.value && t.t(i.value), i.children && this.json2packet(i.children, t), t.up())
								}
							}
						};

					function wr(e, t) {
						const n = [];
						for (let i = 0; i < e.length; i++) e[i].tagName === t && n.push(e[i]);
						return n
					}
					const Or = ["owner", "admin", "member"];
					class Nr extends Yi {
						constructor(e, t, n, i, s) {
							super(), this.xmpp = i, this.connection = e, this.roomjid = vt.Strophe.getBareJidFromJid(t), this.myroomjid = t, this.password = n, this.replaceParticipant = !1, Pr.info(`Joining MUC as ${this.myroomjid}`), this.members = {}, this.presMap = {}, this.presHandlers = {}, this._removeConnListeners = [], this.joined = !1, this.inProgressEmitted = !1, this.role = null, this.focusMucJid = null, this.noBridgeAvailable = !1, this.options = s || {}, this.moderator = new Ir(this.roomjid, this.xmpp, this.eventEmitter, i.options), (void 0 === this.options.enableLobby || this.options.enableLobby) && (this.lobby = new hr(this)), this.avModeration = new ir(this), this.breakoutRooms = new dr(this), this.roomMetadata = new mr(this), this.initPresenceMap(s), this.lastPresences = {}, this.phoneNumber = null, this.phonePin = null, this.connectionTimes = {}, this.participantPropertyListener = null, this.locked = !1, this.transcriptionStatus = tr
						}
						initPresenceMap() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
							this.presMap.to = this.myroomjid, this.presMap.xns = "http://jabber.org/protocol/muc", this.presMap.nodes = [], e.statsId && this.presMap.nodes.push({
								tagName: "stats-id",
								value: e.statsId
							}), this.presenceUpdateTime = Date.now()
						}
						join(e, t) {
							return this.password = e, this.replaceParticipant = t, new Promise((e => {
								this.options.disableFocus && Pr.info(`Conference focus disabled for ${this.roomjid}`), (this.options.disableFocus ? Promise.resolve() : this.moderator.sendConferenceRequest()).then((() => {
									this.sendPresence(!0), this._removeConnListeners.push(this.connection.addEventListener(Qs.Events.CONN_STATUS_CHANGED, this.onConnStatusChanged.bind(this))), e()
								}))
							}))
						}
						sendPresence(e) {
							const t = this.presMap.to;
							if (!this.connection || !this.connection.connected || !t || !this.joined && !e) return;
							const n = (0, vt.$pres)({
								to: t
							});
							e && (this.replaceParticipant && n.c("flip_device").up(), n.c("x", {
								xmlns: this.presMap.xns
							}), this.password && n.c("password").t(this.password).up(), this.options.billingId && n.c("billingid").t(this.options.billingId).up(), n.up()), Dr.json2packet(this.presMap.nodes, n), this.presenceSyncTime = Date.now(), this.connection.send(n), e && this.connection.flush()
						}
						doLeave(e) {
							Pr.log("do leave", this.myroomjid);
							const t = (0, vt.$pres)({
								to: this.myroomjid,
								type: "unavailable"
							});
							e && t.c("status").t(e).up(), this.presMap.length = 0, !this.connection.isUsingWebSocket && this.connection.flush(), this.connection.send(t), this.connection.flush()
						}
						discoRoomInfo() {
							const e = (0, vt.$iq)({
								type: "get",
								to: this.roomjid
							}).c("query", {
								xmlns: vt.Strophe.NS.DISCO_INFO
							});
							this.connection.sendIQ(e, (e => {
								const t = 1 === ft()(e).find('>query>feature[var="muc_passwordprotected"]').length;
								t !== this.locked && (this.eventEmitter.emit(ki.XMPPEvents.MUC_LOCK_CHANGED, t), this.locked = t);
								const n = ft()(e).find('>query>x[type="result"]>field[var="muc#roominfo_meetingId"]>value');
								n.length ? this.setMeetingId(n.text()) : Pr.warn("No meeting ID from backend");
								const i = 1 === ft()(e).find('>query>feature[var="muc_membersonly"]').length,
									s = ft()(e).find('>query>x[type="result"]>field[var="muc#roominfo_lobbyroom"]>value');
								this.lobby && this.lobby.setLobbyRoomJid(s && s.length ? s.text() : void 0);
								const r = ft()(e).find('>query>x[type="result"]>field[var="muc#roominfo_isbreakout"]>value'),
									o = Boolean(null == r ? void 0 : r.text());
								this.breakoutRooms._setIsBreakoutRoom(o);
								const a = ft()(e).find('>query>x[type="result"]>field[var="muc#roominfo_breakout_main_room"]>value');
								null != a && a.length && this.breakoutRooms._setMainRoomJid(a.text()), i !== this.membersOnlyEnabled && (this.membersOnlyEnabled = i, this.eventEmitter.emit(ki.XMPPEvents.MUC_MEMBERS_ONLY_CHANGED, i));
								const c = ft()(e).find('>query>x[type="result"]>field[var="muc#roominfo_jitsimetadata"]>value'),
									d = null == c ? void 0 : c.text();
								if (d) try {
									this.roomMetadata._handleMessages(JSON.parse(d))
								} catch (e) {
									Pr.warn("Failed to set room metadata", e)
								}
							}), (e => {
								ei().callErrorHandler(e), Pr.error("Error getting room info: ", e)
							}))
						}
						setMeetingId(e) {
							this.meetingId !== e && (this.meetingId && Pr.warn(`Meeting Id changed from:${this.meetingId} to:${e}`), this.meetingId = e, this.eventEmitter.emit(ki.XMPPEvents.MEETING_ID_SET, e))
						}
						createNonAnonymousRoom() {
							if (this.options.disableDiscoInfo) return;
							const e = (0, vt.$iq)({
								type: "get",
								to: this.roomjid
							}).c("query", {
								xmlns: "http://jabber.org/protocol/muc#owner"
							}).c("x", {
								xmlns: "jabber:x:data",
								type: "submit"
							});
							this.connection.sendIQ(e, (e => {
								if (!ft()(e).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_whois"]').length) {
									const e = "non-anonymous rooms not supported";
									return ei().callErrorHandler(new Error(e)), void Pr.error(e)
								}
								const t = (0, vt.$iq)({
									to: this.roomjid,
									type: "set"
								}).c("query", {
									xmlns: "http://jabber.org/protocol/muc#owner"
								});
								t.c("x", {
									xmlns: "jabber:x:data",
									type: "submit"
								}), t.c("field", {
									var: "FORM_TYPE"
								}).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), t.c("field", {
									var: "muc#roomconfig_whois"
								}).c("value").t("anyone").up().up(), this.connection.sendIQ(t)
							}), (e => {
								ei().callErrorHandler(e), Pr.error("Error getting room configuration form: ", e)
							}))
						}
						onConnStatusChanged(e) {
							e === Qs.Status.CONNECTED && this.presenceUpdateTime > this.presenceSyncTime && this.sendPresence()
						}
						onPresence(e) {
							const t = e.getAttribute("from"),
								n = {},
								i = e.getElementsByTagName("status")[0];
							i && (n.status = i.textContent || "");
							let s = !1,
								r = !1;
							const o = e.getElementsByTagNameNS("http://jabber.org/protocol/muc#user", "x")[0],
								a = o && o.getElementsByTagName("item")[0];
							n.isReplaceParticipant = e.getElementsByTagName("flip_device").length, n.affiliation = a && a.getAttribute("affiliation"), n.role = a && a.getAttribute("role");
							const c = a && a.getAttribute("jid");
							n.jid = c, n.isFocus = this.moderator.isFocusJid(c), n.isHiddenDomain = c && c.indexOf("@") > 0 && this.options.hiddenDomain === c.substring(c.indexOf("@") + 1, c.indexOf("/")), this.eventEmitter.emit(ki.XMPPEvents.PRESENCE_RECEIVED, {
								fromHiddenDomain: n.isHiddenDomain,
								presence: e
							});
							const d = e.querySelector("x");
							d && d.remove();
							const l = [];
							Dr.packet2JSON(e, l), this.lastPresences[t] = l;
							const u = e => {
								const t = {},
									n = e.children.find((e => "user" === e.tagName));
								if (n) {
									t.user = {};
									const e = ["id", "name", "avatar"];
									this.options.hiddenFromRecorderFeatureEnabled && e.push("hidden-from-recorder");
									for (const i of e) {
										const e = n.children.find((e => e.tagName === i));
										e && (t.user[i] = e.value)
									}
								}
								const i = e.children.find((e => "group" === e.tagName));
								return i && (t.group = i.value), t
							};
							for (let e = 0; e < l.length; e++) {
								const t = l[e];
								switch (t.tagName) {
									case "bot": {
										const {
											attributes: e
										} = t;
										if (!e) break;
										const {
											type: i
										} = e;
										n.botType = i;
										break
									}
									case "nick":
										n.nick = t.value;
										break;
									case "userId":
										n.id = t.value;
										break;
									case "stats-id":
										n.statsID = t.value;
										break;
									case "identity":
										n.identity = u(t);
										break;
									case "features":
										n.features = this._extractFeatures(t);
										break;
									case "stat": {
										const {
											attributes: e
										} = t;
										if (!e) break;
										const {
											name: i
										} = e;
										"version" === i && (n.version = e.value);
										break
									}
								}
							}
							if (!this.joined && !this.inProgressEmitted) {
								const e = this.connectionTimes["muc.join.started"] = window.performance.now();
								Pr.log("(TIME) MUC join started:\t", e), this.eventEmitter.emit(ki.XMPPEvents.MUC_JOIN_IN_PROGRESS), this.inProgressEmitted = !0
							}
							if (t === this.myroomjid) {
								const e = "owner" === n.affiliation ? n.role : "none";
								if (this.role !== e && (this.role = e, this.eventEmitter.emit(ki.XMPPEvents.LOCAL_ROLE_CHANGED, this.role)), !this.joined) {
									this.joined = !0;
									const e = this.connectionTimes["muc.joined"] = window.performance.now();
									Pr.log("(TIME) MUC joined:\t", e), this.password && (this.locked = !0), this.presenceUpdateTime >= this.presenceSyncTime && this.sendPresence(), this.eventEmitter.emit(ki.XMPPEvents.MUC_JOINED), !this.options.disableDiscoInfo && this.discoRoomInfo()
								}
							} else if (void 0 === c) Pr.info("Ignoring member with undefined JID");
							else if (void 0 === this.members[t]) this.members[t] = n, Pr.log("entered", t, n), s = void 0 !== n.status, r = void 0 !== n.version, n.isFocus ? this._initFocus(t, n.features) : (this.eventEmitter.emit(ki.XMPPEvents.MUC_MEMBER_JOINED, t, n.nick, n.role, n.isHiddenDomain, n.statsID, n.status, n.identity, n.botType, n.jid, n.features, n.isReplaceParticipant), s = !1);
							else {
								const e = this.members[t];
								e.role !== n.role && (e.role = n.role, this.eventEmitter.emit(ki.XMPPEvents.MUC_ROLE_CHANGED, t, n.role)), e.affiliation !== n.affiliation && (e.affiliation = n.affiliation), e.botType !== n.botType && (e.botType = n.botType, this.eventEmitter.emit(ki.XMPPEvents.MUC_MEMBER_BOT_TYPE_CHANGED, t, n.botType)), n.isFocus && (e.isFocus = !0, this._initFocus(t, n.features)), n.displayName && (e.displayName = n.displayName), e.status !== n.status && (s = !0, e.status = n.status), e.version !== n.version && (r = !0, e.version = n.version), _t()(e.features, n.features) || (e.features = n.features, this.eventEmitter.emit(ki.XMPPEvents.PARTICIPANT_FEATURES_CHANGED, t, n.features))
							}
							for (let e = 0; e < l.length; e++) {
								const i = l[e];
								switch (i.tagName) {
									case "nick":
										if (!n.isFocus) {
											const e = this.xmpp.options.displayJids ? vt.Strophe.getResourceFromJid(t) : n.nick;
											this.eventEmitter.emit(ki.XMPPEvents.DISPLAY_NAME_CHANGED, t, e)
										}
										break;
									case "bridgeNotAvailable":
										n.isFocus && !this.noBridgeAvailable && (this.noBridgeAvailable = !0, this.eventEmitter.emit(ki.XMPPEvents.BRIDGE_DOWN));
										break;
									case "conference-properties":
										if (n.isFocus) {
											const e = {};
											for (let t = 0; t < i.children.length; t++) {
												const {
													attributes: n
												} = i.children[t];
												n && n.key && (e[n.key] = n.value)
											}
											this.eventEmitter.emit(ki.XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, e), void 0 === this.restartByTerminateSupported && (this.restartByTerminateSupported = "true" === e["support-terminate-restart"], Pr.info(`Jicofo supports restart by terminate: ${this.supportsRestartByTerminate()}`))
										}
										break;
									case "transcription-status": {
										const {
											attributes: e
										} = i;
										if (!e) break;
										const {
											status: t
										} = e;
										t && t !== this.transcriptionStatus && (this.transcriptionStatus = t, this.eventEmitter.emit(ki.XMPPEvents.TRANSCRIPTION_STATUS_CHANGED, t));
										break
									}
									case "call-control": {
										const e = i.attributes;
										if (!e) break;
										this.phoneNumber = e.phone || null, this.phonePin = e.pin || null, this.eventEmitter.emit(ki.XMPPEvents.PHONE_NUMBER_CHANGED);
										break
									}
									default:
										this.processNode(i, t)
								}
							}
							s && this.eventEmitter.emit(ki.XMPPEvents.PRESENCE_STATUS, t, n.status), r && Pr.info(`Received version for ${c}: ${n.version}`)
						}
						_extractFeatures(e) {
							const t = new Set;
							for (let n = 0; n < e.children.length; n++) {
								const {
									attributes: i
								} = e.children[n];
								i && i.var && t.add(i.var)
							}
							return t
						}
						_initFocus(e, t) {
							this.focusMucJid = e, this.focusFeatures = t
						}
						setParticipantPropertyListener(e) {
							this.participantPropertyListener = e
						}
						supportsRestartByTerminate() {
							return this.restartByTerminateSupported
						}
						processNode(e, t) {
							try {
								let n = this.presHandlers[e.tagName];
								e.tagName.startsWith("jitsi_participant_") && (n = [this.participantPropertyListener]), n && n.forEach((n => {
									n(e, vt.Strophe.getResourceFromJid(t), t)
								}))
							} catch (t) {
								ei().callErrorHandler(t), Pr.error(`Error processing:${e.tagName} node.`, t)
							}
						}
						sendMessage(e, t) {
							const n = (0, vt.$msg)({
								to: this.roomjid,
								type: "groupchat"
							});
							"body" === t ? n.c(t, {}, e) : n.c(t, {
								xmlns: "http://jitsi.org/jitmeet"
							}, e), this.connection.send(n), this.eventEmitter.emit(ki.XMPPEvents.SENDING_CHAT_MESSAGE, e)
						}
						sendPrivateMessage(e, t, n) {
							const i = (0, vt.$msg)({
								to: `${this.roomjid}/${e}`,
								type: "chat"
							});
							"body" === n ? i.c(n, t).up() : i.c(n, {
								xmlns: "http://jitsi.org/jitmeet"
							}, t).up(), this.connection.send(i), this.eventEmitter.emit(ki.XMPPEvents.SENDING_PRIVATE_CHAT_MESSAGE, t)
						}
						setSubject(e) {
							const t = (0, vt.$msg)({
								to: this.roomjid,
								type: "groupchat"
							});
							t.c("subject", e), this.connection.send(t)
						}
						onPresenceUnavailable(e, t) {
							if (ft()(e).find('>ignore[xmlns="http://jitsi.org/jitmeet/"]').length) return !0;
							const n = ft()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy');
							if (n.length) {
								let t;
								const i = ft()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy>reason');
								return i.length && (t = i.text()), this.eventEmitter.emit(ki.XMPPEvents.MUC_DESTROYED, t, n.attr("jid")), this.connection.emuc.doLeave(this.roomjid), !0
							}
							const i = ft()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="110"]').length,
								s = ft()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="307"]').length,
								r = Object.keys(this.members),
								o = ft()(e).find("flip_device").length;
							if (s) {
								const n = ft()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>actor');
								let s, r;
								n.length && (s = n.attr("nick"));
								const a = ft()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>reason');
								a.length && (r = a.text()), this.eventEmitter.emit(ki.XMPPEvents.KICKED, i, s, vt.Strophe.getResourceFromJid(t), r, o)
							}
							if (i) r.forEach((e => {
								const t = this.members[e];
								delete this.members[e], delete this.lastPresences[e], t.isFocus || this.eventEmitter.emit(ki.XMPPEvents.MUC_MEMBER_LEFT, e)
							})), this.connection.emuc.doLeave(this.roomjid), s || this.eventEmitter.emit(ki.XMPPEvents.MUC_LEFT);
							else {
								const n = ft()(e).find(">status"),
									i = this.members[t];
								let s;
								n.length && (s = n.text()), delete this.members[t], delete this.lastPresences[t], this.eventEmitter.emit(ki.XMPPEvents.MUC_MEMBER_LEFT, t, s), null != i && i.isFocus && (Pr.info("Focus has left the room - leaving conference"), this.eventEmitter.emit(ki.XMPPEvents.FOCUS_LEFT))
							}
						}
						onMessage(e, t) {
							const n = e.getAttribute("type");
							if ("error" === n) {
								const t = ft()(e).find(">settings-error>text").text();
								if (t.length) return this.eventEmitter.emit(ki.XMPPEvents.SETTINGS_ERROR_RECEIVED, t), !0;
								const n = ft()(e).find(">error>text").text();
								return this.eventEmitter.emit(ki.XMPPEvents.CHAT_ERROR_RECEIVED, n), !0
							}
							const i = ft()(e).find(">body").text(),
								s = ft()(e).find(">subject");
							if (s.length) {
								const e = s.text();
								(e || "" === e) && (this.eventEmitter.emit(ki.XMPPEvents.SUBJECT_CHANGED, e), Pr.log(`Subject is changed to ${e}`))
							}
							let r = ft()(e).find(">delay").attr("stamp");
							if (!r && (r = ft()(e).find('>[xmlns="jabber:x:delay"]').attr("stamp"), r)) {
								const e = r.match(/(\d{4})(\d{2})(\d{2}T\d{2}:\d{2}:\d{2})/);
								r = `${e[1]}-${e[2]}-${e[3]}Z`
							}
							if (t === this.roomjid) {
								let n;
								if (ft()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="104"]').length) this.discoRoomInfo();
								else if ((n = ft()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>invite')) && n.length) {
									const s = ft()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>password');
									let r;
									s && s.length && (r = s.text()), this.eventEmitter.emit(ki.XMPPEvents.INVITE_MESSAGE_RECEIVED, t, n.attr("from"), i, r)
								}
							}
							const o = ft()(e).find(">json-message").text();
							if (o) {
								const e = this.xmpp.tryParseJSONAndVerify(o);
								if (e && void 0 === r) return void this.eventEmitter.emit(ki.XMPPEvents.JSON_MESSAGE_RECEIVED, t, e)
							}
							i && ("chat" === n ? this.eventEmitter.emit(ki.XMPPEvents.PRIVATE_MESSAGE_RECEIVED, t, i, this.myroomjid, r) : "groupchat" === n && this.eventEmitter.emit(ki.XMPPEvents.MESSAGE_RECEIVED, t, i, this.myroomjid, r))
						}
						onPresenceError(e, t) {
							if (ft()(e).find('>error[type="auth"]>not-authorized[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) Pr.log("on password required", t), this.eventEmitter.emit(ki.XMPPEvents.PASSWORD_REQUIRED);
							else if (ft()(e).find('>error[type="cancel"]>not-allowed[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) vt.Strophe.getDomainFromJid(e.getAttribute("to")) === this.xmpp.options.hosts.anonymousdomain ? this.eventEmitter.emit(ki.XMPPEvents.ROOM_JOIN_ERROR) : (Pr.warn("onPresError ", e), this.eventEmitter.emit(ki.XMPPEvents.ROOM_CONNECT_NOT_ALLOWED_ERROR));
							else if (ft()(e).find(">error>service-unavailable").length) Pr.warn("Maximum users limit for the room has been reached", e), this.eventEmitter.emit(ki.XMPPEvents.ROOM_MAX_USERS_ERROR);
							else if (ft()(e).find('>error[type="auth"]>registration-required[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
								const t = ft()(e).find('>x>lobbyroom'); // BAO
								let n;
								this.lobby.setLobbyRoomJid(t.text()); // BAO									
								if (t.length) n = t.text();
								else {
									const t = ft()(e).find(">lobbyroom");
									t.length && (n = t.text())
								}
								this.eventEmitter.emit(ki.XMPPEvents.ROOM_CONNECT_MEMBERS_ONLY_ERROR, n)
							} else Pr.warn("onPresError ", e), this.eventEmitter.emit(ki.XMPPEvents.ROOM_CONNECT_ERROR)
						}
						setAffiliation(e, t) {
							const n = (0, vt.$iq)({
								to: this.roomjid,
								type: "set"
							}).c("query", {
								xmlns: "http://jabber.org/protocol/muc#admin"
							}).c("item", {
								affiliation: t,
								jid: vt.Strophe.getBareJidFromJid(e)
							}).c("reason").t(`Your affiliation has been changed to '${t}'.`).up().up().up();
							this.connection.sendIQ(n, (n => Pr.log("Set affiliation of participant with jid: ", e, "to", t, n)), (e => Pr.log("Set affiliation of participant error: ", e)))
						}
						kick(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "You have been kicked.";
							const n = (0, vt.$iq)({
								to: this.roomjid,
								type: "set"
							}).c("query", {
								xmlns: "http://jabber.org/protocol/muc#admin"
							}).c("item", {
								nick: vt.Strophe.getResourceFromJid(e),
								role: "none"
							}).c("reason").t(t).up().up().up();
							this.connection.sendIQ(n, (t => Pr.log("Kick participant with jid: ", e, t)), (e => Pr.log("Kick participant error: ", e)))
						}
						lockRoom(e, t, n, i) {
							this.connection.sendIQ((0, vt.$iq)({
								to: this.roomjid,
								type: "get"
							}).c("query", {
								xmlns: "http://jabber.org/protocol/muc#owner"
							}), (s => {
								if (ft()(s).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_roomsecret"]').length) {
									const i = (0, vt.$iq)({
										to: this.roomjid,
										type: "set"
									}).c("query", {
										xmlns: "http://jabber.org/protocol/muc#owner"
									});
									i.c("x", {
										xmlns: "jabber:x:data",
										type: "submit"
									}), i.c("field", {
										var: "FORM_TYPE"
									}).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), i.c("field", {
										var: "muc#roomconfig_roomsecret"
									}).c("value").t(e).up().up(), i.c("field", {
										var: "muc#roomconfig_passwordprotectedroom"
									}).c("value").t(null === e || 0 === e.length ? "0" : "1").up().up(), this.membersOnlyEnabled && i.c("field", {
										var: "muc#roomconfig_membersonly"
									}).c("value").t("true").up().up(), i.c("field", {
										var: "muc#roomconfig_whois"
									}).c("value").t("anyone").up().up(), this.connection.sendIQ(i, (() => {
										this.password = e, t()
									}), n)
								} else i()
							}), n)
						}
						setMembersOnly(e, t, n) {
							e && Object.values(this.members).filter((e => !e.isFocus)).length && Object.values(this.members).forEach((e => {
								e.jid && !Or.includes(e.affiliation) && this.xmpp.connection.sendIQ((0, vt.$iq)({
									to: this.roomjid,
									type: "set"
								}).c("query", {
									xmlns: "http://jabber.org/protocol/muc#admin"
								}).c("item", {
									affiliation: "member",
									jid: vt.Strophe.getBareJidFromJid(e.jid)
								}).up().up())
							}));
							const i = n || (() => {});
							this.xmpp.connection.sendIQ((0, vt.$iq)({
								to: this.roomjid,
								type: "get"
							}).c("query", {
								xmlns: "http://jabber.org/protocol/muc#owner"
							}), (n => {
								if (ft()(n).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_membersonly"]').length) {
									const n = (0, vt.$iq)({
										to: this.roomjid,
										type: "set"
									}).c("query", {
										xmlns: "http://jabber.org/protocol/muc#owner"
									});
									n.c("x", {
										xmlns: "jabber:x:data",
										type: "submit"
									}), n.c("field", {
										var: "FORM_TYPE"
									}).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), n.c("field", {
										var: "muc#roomconfig_membersonly"
									}).c("value").t(e ? "true" : "false").up().up(), this.locked && n.c("field", {
										var: "muc#roomconfig_passwordprotectedroom"
									}).c("value").t("1").up().up(), this.xmpp.connection.sendIQ(n, t, i)
								} else i(new Error("Setting members only room not supported!"))
							}), i)
						}
						addToPresence(e, t) {
							return this.addOrReplaceInPresence(e, t)
						}
						addOrReplaceInPresence(e, t) {
							t.tagName = e;
							const n = this.presMap.nodes.filter((t => e === t.tagName));
							return !(1 === n.length && _t()(n[0], t) || (this.removeFromPresence(e), this.presMap.nodes.push(t), this.presenceUpdateTime = Date.now(), 0))
						}
						getFromPresence(e) {
							return this.presMap.nodes.find((t => e === t.tagName))
						}
						removeFromPresence(e) {
							const t = this.presMap.nodes.filter((t => e !== t.tagName));
							this.presMap.nodes = t, this.presenceUpdateTime = Date.now()
						}
						addPresenceListener(e, t) {
							if ("function" != typeof t) throw new Error('"handler" is not a function');
							let n = this.presHandlers[e];
							n || (this.presHandlers[e] = n = []), -1 === n.indexOf(t) ? n.push(t) : Pr.warn(`Trying to add the same handler more than once for: ${e}`)
						}
						removePresenceListener(e, t) {
							const n = this.presHandlers[e],
								i = n ? n.indexOf(t) : -1; - 1 !== i ? n.splice(i, 1) : Pr.warn(`Handler for: ${e} was not registered`)
						}
						isFocus(e) {
							const t = this.members[e];
							return t ? t.isFocus : null
						}
						isModerator() {
							return "moderator" === this.role
						}
						getMediaPresenceInfo(e, t) {
							const n = this.lastPresences[`${this.roomjid}/${e}`];
							if (!n) return null;
							const i = {
								muted: !0,
								videoType: t === _i.VIDEO ? Ni.VideoType.CAMERA : void 0
							};
							let s = null;
							if (t === _i.AUDIO) s = wr(n, "audiomuted");
							else {
								if (t !== _i.VIDEO) return Pr.error(`Unsupported media type: ${t}`), null; {
									s = wr(n, "videomuted");
									const e = wr(n, "jitsi_participant_codecType"),
										t = wr(n, "videoType");
									t.length > 0 && (i.videoType = t[0].value), e.length > 0 && (i.codecType = e[0].value)
								}
							}
							return s.length > 0 && (i.muted = "true" === s[0].value), i
						}
						getMemberRole(e) {
							return this.members[e] ? this.members[e].role : null
						}
						getLastPresence(e) {
							return this.lastPresences[`${this.roomjid}/${e}`]
						}
						dial(e) {
							return this.connection.rayo.dial(e, "fromnumber", vt.Strophe.getBareJidFromJid(this.myroomjid), this.password, this.focusMucJid)
						}
						hangup() {
							return this.connection.rayo.hangup()
						}
						getLobby() {
							return this.lobby
						}
						getAVModeration() {
							return this.avModeration
						}
						getBreakoutRooms() {
							return this.breakoutRooms
						}
						getMetadataHandler() {
							return this.roomMetadata
						}
						getPhoneNumber() {
							return this.phoneNumber
						}
						getPhonePin() {
							return this.phonePin
						}
						getMeetingId() {
							return this.meetingId
						}
						muteParticipant(e, t, n) {
							Pr.info("set mute", t, e);
							const i = (0, vt.$iq)({
								to: this.focusMucJid,
								type: "set"
							}).c("mute", {
								xmlns: `http://jitsi.org/jitmeet/${n}`,
								jid: e
							}).t(t.toString()).up();
							this.connection.sendIQ(i, (e => Pr.log("set mute", e)), (e => Pr.log("set mute error", e)))
						}
						onMute(e) {
							if (e.getAttribute("from") !== this.focusMucJid) return void Pr.warn("Ignored mute from non focus peer");
							const t = ft()(e).find("mute");
							t.length && "true" === t.text() ? this.eventEmitter.emit(ki.XMPPEvents.AUDIO_MUTED_BY_FOCUS, t.attr("actor")) : Pr.warn("Ignoring a mute request which does not explicitly specify a positive mute command.")
						}
						onMuteVideo(e) {
							if (e.getAttribute("from") !== this.focusMucJid) return void Pr.warn("Ignored mute from non focus peer");
							const t = ft()(e).find("mute");
							t.length && "true" === t.text() ? this.eventEmitter.emit(ki.XMPPEvents.VIDEO_MUTED_BY_FOCUS, t.attr("actor")) : Pr.warn("Ignoring a mute request which does not explicitly specify a positive mute command.")
						}
						clean() {
							this._removeConnListeners.forEach((e => e())), this._removeConnListeners = [], this.joined = !1, this.inProgressEmitted = !1
						}
						leave(e) {
							var t, n = this;
							this.avModeration.dispose(), this.breakoutRooms.dispose(), this.roomMetadata.dispose();
							const i = [];
							return (null === (t = this.lobby) || void 0 === t ? void 0 : t.lobbyRoom) && i.push(this.lobby.leave()), i.push(new Promise(((t, i) => {
								let s = -1;
								const r = function() {
									let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
									n.eventEmitter.removeListener(ki.XMPPEvents.MUC_LEFT, r), clearTimeout(s), e ? (n.connection.emuc.doLeave(n.roomjid), i(new Error("The timeout for the confirmation about leaving the room expired."))) : t()
								};
								s = setTimeout((() => r(!0)), 5e3), this.clean(), this.eventEmitter.on(ki.XMPPEvents.MUC_LEFT, r), this.doLeave(e)
							}))), Promise.allSettled(i)
						}
						end() {
							if (this.breakoutRooms.isBreakoutRoom()) return void Pr.warn("Cannot end conference: this is a breakout room.");
							const e = (0, vt.$msg)({
								to: this.xmpp.endConferenceComponentAddress
							});
							e.c("end_conference").up(), this.xmpp.connection.send(e)
						}
					}
					const Mr = (0, S.getLogger)("modules/xmpp/strophe.emuc.js");
					class Lr extends Ws {
						constructor(e) {
							super(), this.xmpp = e, this.rooms = {}
						}
						init(e) {
							super.init(e), this.connection.addHandler(this.onPresence.bind(this), null, "presence", null, null, null, null), this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, "presence", "unavailable", null), this.connection.addHandler(this.onPresenceError.bind(this), null, "presence", "error", null), this.connection.addHandler(this.onMessage.bind(this), null, "message", null, null), this.connection.addHandler(this.onMute.bind(this), "http://jitsi.org/jitmeet/audio", "iq", "set", null, null), this.connection.addHandler(this.onMuteVideo.bind(this), "http://jitsi.org/jitmeet/video", "iq", "set", null, null)
						}
						createRoom(e, t, n) {
							const i = vt.Strophe.getBareJidFromJid(e);
							if (this.isRoomCreated(i)) {
								const e = "You are already in the room!";
								throw Mr.error(e), new Error(e)
							}
							return this.rooms[i] = new Nr(this.connection, e, t, this.xmpp, n), this.eventEmitter.emit(ki.XMPPEvents.EMUC_ROOM_ADDED, this.rooms[i]), this.rooms[i]
						}
						isRoomCreated(e) {
							return e in this.rooms
						}
						doLeave(e) {
							this.eventEmitter.emit(ki.XMPPEvents.EMUC_ROOM_REMOVED, this.rooms[e]), delete this.rooms[e]
						}
						onPresence(e) {
							const t = e.getAttribute("from");
							if (e.getAttribute("type")) return !0;
							const n = this.rooms[vt.Strophe.getBareJidFromJid(t)];
							return !n || (ft()(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="201"]').length && n.createNonAnonymousRoom(), n.onPresence(e), !0)
						}
						onPresenceUnavailable(e) {
							const t = e.getAttribute("from"),
								n = this.rooms[vt.Strophe.getBareJidFromJid(t)];
							return !n || (n.onPresenceUnavailable(e, t), !0)
						}
						onPresenceError(e) {
							const t = e.getAttribute("from"),
								n = this.rooms[vt.Strophe.getBareJidFromJid(t)];
							return !n || (n.onPresenceError(e, t), !0)
						}
						onMessage(e) {
							const t = e.getAttribute("from"),
								n = this.rooms[vt.Strophe.getBareJidFromJid(t)];
							return !n || (n.onMessage(e, t), !0)
						}
						onMute(e) {
							const t = e.getAttribute("from"),
								n = this.rooms[vt.Strophe.getBareJidFromJid(t)];
							return !n || (n.onMute(e), !0)
						}
						onMuteVideo(e) {
							const t = e.getAttribute("from"),
								n = this.rooms[vt.Strophe.getBareJidFromJid(t)];
							return !n || (n.onMuteVideo(e), !0)
						}
					}
					const kr = (0, S.getLogger)("modules/xmpp/JingleHelperFunctions.js");

					function xr(e, t) {
						const n = (0, vt.$build)("source", {
							xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
							ssrc: t.s,
							name: t.n
						});
						return t.m && n.c("parameter", {
							name: "msid",
							value: t.m
						}).up(), n.c("ssrc-info", {
							xmlns: "http://jitsi.org/jitmeet",
							owner: e
						}).up(), n.node
					}

					function Fr(e) {
						const t = (0, vt.$build)("ssrc-group", {
							xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
							semantics: (n = e[0], "f" === n ? "FID" : "s" === n ? "SIM" : null)
						});
						var n;
						for (let n = 1; n < e.length; n++) t.c("source", {
							xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
							ssrc: e[n]
						}).up();
						return t.node
					}

					function Vr(e, t) {
						const n = ft()(e).find("jingle")[0];
						let i, s = ft()(n).find(`content[name="${t}"]`);
						return s.length ? s = s[0] : (s = (0, vt.$build)("content", {
							name: t
						}).node, n.appendChild(s)), i = ft()(s).find("description"), i.length ? i = i[0] : (i = (0, vt.$build)("description", {
							xmlns: "urn:xmpp:jingle:apps:rtp:1",
							media: t
						}).node, s.appendChild(i)), i
					}

					function Ur(e, t) {
						var n;
						let i;
						try {
							i = JSON.parse(t.textContent)
						} catch (e) {
							return kr.error(`json-message XML contained invalid JSON, ignoring: ${t.textContent}`), null
						}
						if (null === (n = i) || void 0 === n || !n.sources) return null;
						const s = Vr(e, _i.AUDIO),
							r = Vr(e, _i.VIDEO),
							o = new Map;
						for (const e in i.sources)
							if (i.sources.hasOwnProperty(e)) {
								const t = [],
									n = i.sources[e],
									d = (null == n ? void 0 : n.length) && n[0],
									l = (null == n ? void 0 : n.length) > 1 && n[1],
									u = (null == n ? void 0 : n.length) > 2 && n[2],
									h = (null == n ? void 0 : n.length) > 3 && n[3];
								if (null != d && d.length)
									for (let n = 0; n < d.length; n++) {
										var a;
										r.appendChild(xr(e, d[n])), t.push(null === (a = d[n]) || void 0 === a ? void 0 : a.s)
									}
								if (null != l && l.length)
									for (let e = 0; e < l.length; e++) r.appendChild(Fr(l[e]));
								if (null != u && u.length)
									for (let n = 0; n < u.length; n++) {
										var c;
										s.appendChild(xr(e, u[n])), t.push(null === (c = u[n]) || void 0 === c ? void 0 : c.s)
									}
								if (null != h && h.length)
									for (let e = 0; e < h.length; e++) s.appendChild(Fr(h[e]));
								o.set(e, t)
							} return o
					}
					var jr = n(4391),
						Hr = n.n(jr);
					let Br;
					! function(e) {
						e.INACTIVE = "inactive", e.RECVONLY = "recvonly", e.SENDONLY = "sendonly", e.SENDRECV = "sendrecv"
					}(Br || (Br = {}));
					const $r = n(5810).getLogger("modules/RTC/ScreenObtainer.js"),
						Jr = {
							obtainStream: null,
							init() {
								let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
								this.options = e, this.obtainStream = this._createObtainStreamMethod(), this.obtainStream || $r.info("Desktop sharing disabled")
							},
							_createObtainStreamMethod() {
								return Wn.isNWJS() ? (e, t) => {
									window.JitsiMeetNW.obtainDesktopStream(e, ((e, n) => {
										let i;
										i = e && "InvalidStateError" === e.name ? new qt(Ut) : new qt(e, n, ["desktop"]), "function" == typeof t && t(i)
									}))
								} : Wn.isElectron() ? this.obtainScreenOnElectron : Wn.isReactNative() && Wn.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMediaRN : Wn.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMedia : ($r.log("Screen sharing not supported on ", Wn.getName()), null)
							},
							_getAudioConstraints() {
								const {
									audioQuality: e
								} = this.options;
								return null == e || !e.stereo || {
									autoGainControl: !1,
									channelCount: 2,
									echoCancellation: !1,
									noiseSuppression: !1
								}
							},
							isSupported() {
								return null !== this.obtainStream
							},
							obtainScreenOnElectron(e, t) {
								var n = this;
								let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
								if (window.JitsiMeetScreenObtainer && window.JitsiMeetScreenObtainer.openDesktopPicker) {
									const {
										desktopSharingFrameRate: s,
										desktopSharingSources: r
									} = this.options;
									window.JitsiMeetScreenObtainer.openDesktopPicker({
										desktopSharingSources: i.desktopSharingSources || r || ["screen", "window"]
									}, (function(i, r) {
										let o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
										if (i) {
											var a, c;
											let d = !1;
											if (o) {
												d = {};
												const e = n._getAudioConstraints();
												"boolean" != typeof e && (d = {
													optional: e
												}), "screen" === r && (d.mandatory = {
													chromeMediaSource: "desktop"
												})
											}
											const l = {
												audio: d,
												video: {
													mandatory: {
														chromeMediaSource: "desktop",
														chromeMediaSourceId: i,
														minFrameRate: null !== (a = null == s ? void 0 : s.min) && void 0 !== a ? a : 5,
														maxFrameRate: null !== (c = null == s ? void 0 : s.max) && void 0 !== c ? c : 5,
														maxWidth: window.screen.width,
														maxHeight: window.screen.height
													}
												}
											};
											navigator.mediaDevices.getUserMedia(l).then((t => e({
												stream: t,
												sourceId: i,
												sourceType: r
											})), t)
										} else t(new qt(Ut))
									}), (e => t(new qt(Mt, e))))
								} else t(new qt(Lt))
							},
							obtainScreenFromGetDisplayMedia(e, t) {
								let n;
								n = navigator.getDisplayMedia ? navigator.getDisplayMedia.bind(navigator) : navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices);
								const i = this._getAudioConstraints();
								let s = {};
								const {
									desktopSharingFrameRate: r
								} = this.options;
								"object" == typeof r && (s.frameRate = r), s.frameRate && delete s.frameRate.min, Wn.isChromiumBased() && (Wn.isVersionGreaterThan(106) && (s.surfaceSwitching = "include"), (null == r ? void 0 : r.max) <= 5 && (s.height = 99999, s.width = 99999)), 0 === Object.keys(s).length && (s = !0);
								const o = {
									video: s,
									audio: i,
									cursor: "always"
								};
								$r.info("Using getDisplayMedia for screen sharing", o), n(o).then((t => {
									e({
										stream: t,
										sourceId: t.id
									})
								})).catch((e => {
									const n = {
										errorName: e && e.name,
										errorMsg: e && e.message,
										errorStack: e && e.stack
									};
									$r.error("getDisplayMedia error", o, n), n.errorMsg && -1 !== n.errorMsg.indexOf("denied by system") ? t(new qt(Ft)) : t(new qt(Ut))
								}))
							},
							obtainScreenFromGetDisplayMediaRN(e, t) {
								$r.info("Using getDisplayMedia for screen sharing"), navigator.mediaDevices.getDisplayMedia({
									video: !0
								}).then((t => {
									e({
										stream: t,
										sourceId: t.id
									})
								})).catch((() => {
									t(new qt(Ut))
								}))
							},
							setDesktopSharingFrameRate(e) {
								$r.info(`Setting the desktop capture rate to ${e}`), this.options.desktopSharingFrameRate = {
									min: 5,
									max: e
								}
							}
						},
						Gr = Jr;
					var qr = n(2138),
						Kr = n.n(qr),
						Wr = n(8310);
					const Xr = (0, S.getLogger)("modules/sdp/SDPUtil.js"),
						zr = {
							filterSpecialChars: e => e ? e.replace(/[\\\/\{,\}\+]/g, "") : e,
							iceparams(e, t) {
								let n, i, s = null;
								return (i = zr.findLine(e, "a=ice-ufrag:", t)) && (n = zr.findLine(e, "a=ice-pwd:", t)) && (s = {
									ufrag: zr.parseICEUfrag(i),
									pwd: zr.parseICEPwd(n)
								}), s
							},
							parseICEUfrag: e => e.substring(12),
							buildICEUfrag: e => `a=ice-ufrag:${e}`,
							parseICEPwd: e => e.substring(10),
							buildICEPwd: e => `a=ice-pwd:${e}`,
							parseMID: e => e.substring(6),
							parseMSIDAttribute(e) {
								const t = e.find((e => e.indexOf(" msid:") > 0));
								if (!t) return;
								const n = t.substring(t.indexOf(" msid:") + 6);
								return zr.filterSpecialChars(n)
							},
							parseMLine(e) {
								const t = {},
									n = e.substring(2).split(" ");
								return t.media = n.shift(), t.port = n.shift(), t.proto = n.shift(), "" === n[n.length - 1] && n.pop(), t.fmt = n, t
							},
							buildMLine: e => `m=${e.media} ${e.port} ${e.proto} ${e.fmt.join(" ")}`,
							parseRTPMap(e) {
								const t = {};
								let n = e.substring(9).split(" ");
								return t.id = n.shift(), n = n[0].split("/"), t.name = n.shift(), t.clockrate = n.shift(), t.channels = n.length ? n.shift() : "1", t
							},
							parseSCTPMap(e) {
								const t = e.substring(10).split(" ");
								return [t[0], t[1], t.length > 2 ? t[2] : null]
							},
							parseSCTPPort: e => e.substring(12),
							buildRTPMap(e) {
								let t = `a=rtpmap:${e.getAttribute("id")} ${e.getAttribute("name")}/${e.getAttribute("clockrate")}`;
								return e.getAttribute("channels") && "1" !== e.getAttribute("channels") && (t += `/${e.getAttribute("channels")}`), t
							},
							parseCrypto(e) {
								const t = {},
									n = e.substring(9).split(" ");
								return t.tag = n.shift(), t["crypto-suite"] = n.shift(), t["key-params"] = n.shift(), n.length && (t["session-params"] = n.join(" ")), t
							},
							parseFingerprint(e) {
								const t = {},
									n = e.substring(14).split(" ");
								return t.hash = n.shift(), t.fingerprint = n.shift(), t
							},
							parseFmtp(e) {
								const t = [];
								let n = e.split(" ");
								n.shift(), n = n.join(" ").split(";");
								for (let e = 0; e < n.length; e++) {
									let i = n[e].split("=")[0];
									for (; i.length && " " === i[0];) i = i.substring(1);
									const s = n[e].split("=")[1];
									i && s ? t.push({
										name: i,
										value: s
									}) : i && t.push({
										name: "",
										value: i
									})
								}
								return t
							},
							parseICECandidate(e) {
								const t = {},
									n = e.split(" ");
								t.foundation = n[0].substring(12), t.component = n[1], t.protocol = n[2].toLowerCase(), t.priority = n[3], t.ip = n[4], t.port = n[5], t.type = n[7], t.generation = 0;
								for (let e = 8; e < n.length; e += 2) switch (n[e]) {
									case "raddr":
										t["rel-addr"] = n[e + 1];
										break;
									case "rport":
										t["rel-port"] = n[e + 1];
										break;
									case "generation":
										t.generation = n[e + 1];
										break;
									case "tcptype":
										t.tcptype = n[e + 1];
										break;
									default:
										Xr.debug(`parseICECandidate not translating "${n[e]}" = "${n[e+1]}"`)
								}
								return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
							},
							buildICECandidate(e) {
								let t = [`a=candidate:${e.foundation}`, e.component, e.protocol, e.priority, e.ip, e.port, "typ", e.type].join(" ");
								switch (t += " ", e.type) {
									case "srflx":
									case "prflx":
									case "relay":
										e.hasOwnAttribute("rel-addr") && e.hasOwnAttribute("rel-port") && (t += "raddr", t += " ", t += e["rel-addr"], t += " ", t += "rport", t += " ", t += e["rel-port"], t += " ")
								}
								return e.hasOwnAttribute("tcptype") && (t += "tcptype", t += " ", t += e.tcptype, t += " "), t += "generation", t += " ", t += e.hasOwnAttribute("generation") ? e.generation : "0", t
							},
							parseSSRC(e) {
								const t = new Map,
									n = e.split("\r\n");
								for (let e = 0; e < n.length; e++)
									if ("a=ssrc:" === n[e].substring(0, 7)) {
										const i = n[e].split("a=ssrc:")[1].split(" ")[0];
										t.get(i) || t.set(i, []), t.get(i).push(n[e])
									} return t
							},
							parseSourceNameLine(e) {
								const t = e.find((e => e.indexOf(" name:") > 0));
								return null == t ? void 0 : t.substring(t.indexOf(" name:") + 6)
							},
							parseVideoTypeLine(e) {
								const t = " videoType:",
									n = e.find((e => e.indexOf(t) > 0));
								return null == n ? void 0 : n.substring(n.indexOf(t) + t.length)
							},
							parseRTCPFB(e) {
								const t = e.substr(10).split(" "),
									n = {};
								return n.pt = t.shift(), n.type = t.shift(), n.params = t, n
							},
							parseExtmap(e) {
								const t = e.substr(9).split(" "),
									n = {};
								return n.value = t.shift(), -1 === n.value.indexOf("/") ? n.direction = "both" : (n.direction = n.value.substr(n.value.indexOf("/") + 1), n.value = n.value.substr(0, n.value.indexOf("/"))), n.uri = t.shift(), n.params = t, n
							},
							findLine(e, t, n) {
								let i = e.split("\r\n");
								for (let e = 0; e < i.length; e++)
									if (i[e].substring(0, t.length) === t) return i[e];
								if (!n) return !1;
								i = n.split("\r\n");
								for (let e = 0; e < i.length; e++)
									if (i[e].substring(0, t.length) === t) return i[e];
								return !1
							},
							findLines(e, t, n) {
								let i = e.split("\r\n");
								const s = [];
								for (let e = 0; e < i.length; e++) i[e].substring(0, t.length) === t && s.push(i[e]);
								if (s.length || !n) return s;
								i = n.split("\r\n");
								for (let e = 0; e < i.length; e++) i[e].substring(0, t.length) === t && s.push(i[e]);
								return s
							},
							candidateToJingle(e) {
								if (0 === e.indexOf("candidate:")) e = `a=${e}`;
								else if ("a=candidate:" !== e.substring(0, 12)) return Xr.warn("parseCandidate called with a line that is not a candidate line"), Xr.warn(e), null;
								"\r\n" === e.substring(e.length - 2) && (e = e.substring(0, e.length - 2));
								const t = {},
									n = e.split(" ");
								if ("typ" !== n[6]) return Xr.warn("did not find typ in the right place"), Xr.warn(e), null;
								t.foundation = n[0].substring(12), t.component = n[1], t.protocol = n[2].toLowerCase(), t.priority = n[3], t.ip = n[4], t.port = n[5], t.type = n[7], t.generation = "0";
								for (let e = 8; e < n.length; e += 2) switch (n[e]) {
									case "raddr":
										t["rel-addr"] = n[e + 1];
										break;
									case "rport":
										t["rel-port"] = n[e + 1];
										break;
									case "generation":
										t.generation = n[e + 1];
										break;
									case "tcptype":
										t.tcptype = n[e + 1];
										break;
									default:
										Xr.debug(`not translating "${n[e]}" = "${n[e+1]}"`)
								}
								return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
							},
							candidateFromJingle(e) {
								let t = "a=candidate:";
								t += e.getAttribute("foundation"), t += " ", t += e.getAttribute("component"), t += " ";
								let n = e.getAttribute("protocol");
								switch (Wn.isFirefox() && "ssltcp" === n.toLowerCase() && (n = "tcp"), t += n, t += " ", t += e.getAttribute("priority"), t += " ", t += e.getAttribute("ip"), t += " ", t += e.getAttribute("port"), t += " ", t += "typ", t += ` ${e.getAttribute("type")}`, t += " ", e.getAttribute("type")) {
									case "srflx":
									case "prflx":
									case "relay":
										e.getAttribute("rel-addr") && e.getAttribute("rel-port") && (t += "raddr", t += " ", t += e.getAttribute("rel-addr"), t += " ", t += "rport", t += " ", t += e.getAttribute("rel-port"), t += " ")
								}
								return "tcp" === n.toLowerCase() && (t += "tcptype", t += " ", t += e.getAttribute("tcptype"), t += " "), t += "generation", t += " ", t += e.getAttribute("generation") || "0", `${t}\r\n`
							},
							parsePrimaryVideoSsrc(e) {
								const t = e.ssrcs.map((e => e.id)).filter(((e, t, n) => n.indexOf(e) === t)).length,
									n = e.ssrcGroups && e.ssrcGroups.length || 0;
								if (t > 1 && 0 === n) return;
								let i = null;
								if (1 === t) i = e.ssrcs[0].id;
								else if (2 === t) {
									const t = e.ssrcGroups.find((e => "FID" === e.semantics));
									t && (i = t.ssrcs.split(" ")[0])
								} else if (t >= 3) {
									const t = e.ssrcGroups.find((e => "SIM" === e.semantics));
									t && (i = t.ssrcs.split(" ")[0])
								}
								return i
							},
							generateSsrc: () => Ls().randomInt(1, 4294967295),
							getSsrcAttribute(e, t, n) {
								for (let i = 0; i < e.ssrcs.length; ++i) {
									const s = e.ssrcs[i];
									if (s.id === t && s.attribute === n) return s.value
								}
							},
							parseGroupSsrcs: e => e.ssrcs.split(" ").map((e => parseInt(e, 10))),
							getMedia: (e, t) => e.media.find((e => e.type === t)),
							getUfrag(e) {
								const t = e.split("\n").filter((e => e.startsWith("a=ice-ufrag:")));
								if (t.length > 0) return t[0].substr("a=ice-ufrag:".length)
							},
							preferCodec(e, t) {
								if (!e || !t) return;
								const n = e.rtp.filter((e => e.codec && e.codec.toLowerCase() === t.toLowerCase())).map((e => e.payload));
								if (n) {
									const t = e.payloads.toString().split(" ").map((e => parseInt(e, 10)));
									for (const e of n.reverse()) {
										const n = t.indexOf(e);
										t.splice(n, 1), t.unshift(e)
									}
									e.payloads = t.join(" ")
								} else Xr.error(`No matching RTP payload type found for ${t}, failed to set preferred codecs`)
							},
							stripCodec(e, t) {
								let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
								if (!e || !t) return;
								const i = [];
								let s = [];
								const r = t.toLowerCase() === Hr().H264 && n;
								for (const n of e.rtp) n.codec && n.codec.toLowerCase() === t.toLowerCase() && (r ? i.push(n.payload) : s.push(n.payload));
								if (r && (s = e.fmtp.filter((e => i.indexOf(e.payload) > -1 && e.config.includes("profile-level-id=64"))).map((e => e.payload))), s.length > 0) {
									const t = s.map((e => `apt=${e}`)),
										n = e.fmtp.filter((e => -1 !== t.indexOf(e.config)));
									s.push(...n.map((e => e.payload)));
									const i = e.payloads.toString().split(" ").map(Number).filter((e => -1 === s.indexOf(e)));
									0 === i.length ? (e.port = 0, e.direction = Br.INACTIVE, e.payloads = "*") : e.payloads = i.join(" "), e.rtp = e.rtp.filter((e => -1 !== i.indexOf(e.payload))), e.fmtp = e.fmtp.filter((e => -1 !== i.indexOf(e.payload))), e.rtcpFb && (e.rtcpFb = e.rtcpFb.filter((e => -1 !== i.indexOf(e.payload))))
								}
							}
						},
						Yr = zr;

					function Qr(e) {
						const t = e.split("\r\nm=");
						for (let e = 1, n = t.length; e < n; e++) {
							let i = `m=${t[e]}`;
							e !== n - 1 && (i += "\r\n"), t[e] = i
						}
						const n = `${t.shift()}\r\n`;
						this.media = t, this.raw = n + t.join(""), this.session = n
					}

					function Zr(e, t) {
						if (!t) return !1;
						if (e.length !== t.length) return !1;
						for (let n = 0, i = e.length; n < i; n++)
							if (e[n] instanceof Array && t[n] instanceof Array) {
								if (!e[n].equals(t[n])) return !1
							} else if (e[n] !== t[n]) return !1;
						return !0
					}

					function eo(e, t) {
						if (this.mySDP = e, this.otherSDP = t, !e) throw new Error('"mySDP" is undefined!');
						if (!t) throw new Error('"otherSDP" is undefined!')
					}
					Qr.prototype.failICE = !1, Qr.prototype.removeTcpCandidates = !1, Qr.prototype.removeUdpCandidates = !1, Qr.prototype.addMlineForNewLocalSource = function(e) {
						const t = this.media.length,
							n = Wr.parse(this.raw),
							i = Kr()(n.media.find((t => t.type === e)));
						i.mid = t, i.direction = Br.RECVONLY, i.msid = void 0, i.ssrcs = void 0, i.ssrcGroups = void 0, n.media = n.media.concat(i), n.groups.forEach((e => {
							if ("BUNDLE" === e.type) {
								const n = e.mids.split(" ");
								n.push(t), e.mids = n.join(" ")
							}
						})), this.raw = Wr.write(n)
					}, Qr.prototype.getMediaSsrcMap = function() {
						const e = {};
						for (let t = 0; t < this.media.length; t++) {
							const n = {
								mediaindex: t,
								mid: Yr.parseMID(Yr.findLine(this.media[t], "a=mid:")),
								ssrcs: {},
								ssrcGroups: []
							};
							e[t] = n, Yr.findLines(this.media[t], "a=ssrc:").forEach((e => {
								const t = e.substring(7).split(" ")[0];
								n.ssrcs[t] || (n.ssrcs[t] = {
									ssrc: t,
									lines: []
								}), n.ssrcs[t].lines.push(e)
							})), Yr.findLines(this.media[t], "a=ssrc-group:").forEach((e => {
								const t = e.indexOf(" "),
									i = e.substr(0, t).substr(13),
									s = e.substr(14 + i.length).split(" ");
								s.length && n.ssrcGroups.push({
									semantics: i,
									ssrcs: s
								})
							}))
						}
						return e
					}, Qr.prototype.containsSSRC = function(e) {
						const t = this.getMediaSsrcMap();
						let n = !1;
						return Object.keys(t).forEach((i => {
							n || t[i].ssrcs[e] && (n = !0)
						})), n
					}, Qr.prototype.toJingle = function(e, t) {
						Yr.findLines(this.session, "a=group:").forEach((t => {
							const n = t.split(" "),
								i = n.shift().substr(8);
							e.c("group", {
								xmlns: "urn:xmpp:jingle:apps:grouping:0",
								semantics: i
							});
							for (let t = 0; t < n.length; t++) e.c("content", {
								name: n[t]
							}).up();
							e.up()
						}));
						for (let n = 0; n < this.media.length; n++) {
							const i = Yr.parseMLine(this.media[n].split("\r\n")[0]);
							if ("audio" !== i.media && "video" !== i.media && "application" !== i.media) continue;
							let s;
							const r = Yr.findLine(this.media[n], "a=ssrc:");
							s = !!r && r.substring(7).split(" ")[0], e.c("content", {
								creator: t,
								name: i.media
							});
							const o = Yr.findLine(this.media[n], "a=mid:");
							if (o) {
								const t = Yr.parseMID(o);
								e.attrs({
									name: t
								})
							}
							if ("audio" === i.media || "video" === i.media) {
								e.c("description", {
									xmlns: "urn:xmpp:jingle:apps:rtp:1",
									media: i.media
								}), s && e.attrs({
									ssrc: s
								});
								for (let t = 0; t < i.fmt.length; t++) {
									const s = Yr.findLine(this.media[n], `a=rtpmap:${i.fmt[t]}`);
									e.c("payload-type", Yr.parseRTPMap(s));
									const r = Yr.findLine(this.media[n], `a=fmtp:${i.fmt[t]}`);
									if (r) {
										const t = Yr.parseFmtp(r);
										for (let n = 0; n < t.length; n++) e.c("parameter", t[n]).up()
									}
									this.rtcpFbToJingle(n, e, i.fmt[t]), e.up()
								}
								if (s) {
									const t = Yr.parseSSRC(this.media[n]);
									for (const [n, i] of t) {
										const t = Yr.parseSourceNameLine(i),
											s = Yr.parseVideoTypeLine(i);
										e.c("source", {
											ssrc: n,
											name: t,
											videoType: s,
											xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
										});
										const r = Yr.parseMSIDAttribute(i);
										r && (e.c("parameter"), e.attrs({
											name: "msid"
										}), e.attrs({
											value: r
										}), e.up()), e.up()
									}
									Yr.findLines(this.media[n], "a=ssrc-group:").forEach((t => {
										const n = t.indexOf(" "),
											i = t.substr(0, n).substr(13),
											s = t.substr(14 + i.length).split(" ");
										s.length && (e.c("ssrc-group", {
											semantics: i,
											xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
										}), s.forEach((t => e.c("source", {
											ssrc: t
										}).up())), e.up())
									}))
								}
								const t = Yr.findLines(this.media[n], "a=rid:");
								if (t.length && Wn.usesRidsForSimulcast()) {
									const i = t.map((e => e.split(":")[1])).map((e => e.split(" ")[0]));
									i.forEach((t => {
										e.c("source", {
											rid: t,
											xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
										}), e.up()
									})), Yr.findLine(this.media[n], "a=simulcast:") && (e.c("rid-group", {
										semantics: "SIM",
										xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
									}), i.forEach((t => {
										e.c("source", {
											rid: t
										}).up()
									})), e.up())
								}
								Yr.findLine(this.media[n], "a=rtcp-mux") && e.c("rtcp-mux").up(), this.rtcpFbToJingle(n, e, "*");
								const r = Yr.findLines(this.media[n], "a=extmap:");
								for (let t = 0; t < r.length; t++) {
									const n = Yr.parseExtmap(r[t]);
									if (e.c("rtp-hdrext", {
											xmlns: "urn:xmpp:jingle:apps:rtp:rtp-hdrext:0",
											uri: n.uri,
											id: n.value
										}), n.hasOwnProperty("direction")) switch (n.direction) {
										case Br.SENDONLY:
											e.attrs({
												senders: "responder"
											});
											break;
										case Br.RECVONLY:
											e.attrs({
												senders: "initiator"
											});
											break;
										case Br.SENDRECV:
											e.attrs({
												senders: "both"
											});
											break;
										case Br.INACTIVE:
											e.attrs({
												senders: "none"
											})
									}
									e.up()
								}
								Yr.findLine(this.media[n], "a=extmap-allow-mixed", this.session) && (e.c("extmap-allow-mixed", {
									xmlns: "urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"
								}), e.up()), e.up()
							}
							this.transportToJingle(n, e);
							const a = this.media[n];
							Yr.findLine(a, `a=${Br.SENDRECV}`, this.session) ? e.attrs({
								senders: "both"
							}) : Yr.findLine(a, `a=${Br.SENDONLY}`, this.session) ? e.attrs({
								senders: "initiator"
							}) : Yr.findLine(a, `a=${Br.RECVONLY}`, this.session) ? e.attrs({
								senders: "responder"
							}) : Yr.findLine(a, `a=${Br.INACTIVE}`, this.session) && e.attrs({
								senders: "none"
							}), "0" !== i.port || Yr.findLine(a, "a=bundle-only", this.session) || e.attrs({
								senders: "rejected"
							}), e.up()
						}
						return e.up(), e
					}, Qr.prototype.transportToJingle = function(e, t) {
						t.c("transport");
						const n = Yr.findLine(this.media[e], "a=sctp-port:", this.session),
							i = Yr.findLine(this.media[e], "a=sctpmap:", this.session);
						if (n) {
							const e = Yr.parseSCTPPort(n);
							t.c("sctpmap", {
								xmlns: "urn:xmpp:jingle:transports:dtls-sctp:1",
								number: e,
								protocol: "webrtc-datachannel"
							}), t.attrs({
								streams: 0
							}), t.up()
						} else if (i) {
							const e = Yr.parseSCTPMap(i);
							t.c("sctpmap", {
								xmlns: "urn:xmpp:jingle:transports:dtls-sctp:1",
								number: e[0],
								protocol: e[1]
							}), e.length > 2 ? t.attrs({
								streams: e[2]
							}) : t.attrs({
								streams: 0
							}), t.up()
						}
						Yr.findLines(this.media[e], "a=fingerprint:", this.session).forEach((n => {
							const i = Yr.parseFingerprint(n);
							i.xmlns = "urn:xmpp:jingle:apps:dtls:0", t.c("fingerprint").t(i.fingerprint), delete i.fingerprint;
							const s = Yr.findLine(this.media[e], "a=setup:", this.session);
							s && (i.setup = s.substr(8)), t.attrs(i), t.up()
						}));
						const s = Yr.iceparams(this.media[e], this.session);
						s && (s.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.attrs(s), Yr.findLines(this.media[e], "a=candidate:", this.session).forEach((e => {
							const n = Yr.candidateToJingle(e);
							this.failICE && (n.ip = "1.1.1.1");
							const i = n && "string" == typeof n.protocol ? n.protocol.toLowerCase() : "";
							this.removeTcpCandidates && ("tcp" === i || "ssltcp" === i) || this.removeUdpCandidates && "udp" === i || t.c("candidate", n).up()
						}))), t.up()
					}, Qr.prototype.rtcpFbToJingle = function(e, t, n) {
						Yr.findLines(this.media[e], `a=rtcp-fb:${n}`).forEach((e => {
							const n = Yr.parseRTCPFB(e);
							"trr-int" === n.type ? (t.c("rtcp-fb-trr-int", {
								xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
								value: n.params[0]
							}), t.up()) : (t.c("rtcp-fb", {
								xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
								type: n.type
							}), n.params.length > 0 && t.attrs({
								subtype: n.params[0]
							}), t.up())
						}))
					}, Qr.prototype.rtcpFbFromJingle = function(e, t) {
						let n = "";
						const i = e.find('>rtcp-fb-trr-int[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
						return i.length && (n += "a=rtcp-fb:* trr-int ", i.attr("value") ? n += i.attr("value") : n += "0", n += "\r\n"), e.find('>rtcp-fb[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]').each(((e, i) => {
							n += `a=rtcp-fb:${t} ${i.getAttribute("type")}`, i.hasAttribute("subtype") && (n += ` ${i.getAttribute("subtype")}`), n += "\r\n"
						})), n
					}, Qr.prototype.fromJingle = function(e) {
						const t = Date.now();
						this.raw = `v=0\r\no=- ${t} 2 IN IP4 0.0.0.0\r\ns=-\r\nt=0 0\r\n`;
						const n = ft()(e).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]');
						n.length && n.each(((e, t) => {
							const n = ft()(t).find(">content").map(((e, t) => t.getAttribute("name"))).get();
							n.length > 0 && (this.raw += `a=group:${t.getAttribute("semantics")||t.getAttribute("type")} ${n.join(" ")}\r\n`)
						})), this.session = this.raw, e.find(">content").each(((e, t) => {
							const n = this.jingle2media(ft()(t));
							this.media.push(n)
						})), this.raw = this.session + this.media.join("")
					}, Qr.prototype.jingle2media = function(e) {
						const t = e.find(">description"),
							n = e.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]');
						let i = "";
						const s = n.find('>sctpmap[xmlns="urn:xmpp:jingle:transports:dtls-sctp:1"]'),
							r = {
								media: t.attr("media"),
								port: "9"
							};
						switch ("rejected" === e.attr("senders") && (r.port = "0"), n.find('>fingerprint[xmlns="urn:xmpp:jingle:apps:dtls:0"]').length ? r.proto = s.length ? "UDP/DTLS/SCTP" : "UDP/TLS/RTP/SAVPF" : r.proto = "UDP/TLS/RTP/SAVPF", s.length ? (i += `m=application ${r.port} UDP/DTLS/SCTP webrtc-datachannel\r\n`, i += `a=sctp-port:${s.attr("number")}\r\n`, i += "a=max-message-size:262144\r\n") : (r.fmt = t.find(">payload-type").map(((e, t) => t.getAttribute("id"))).get(), i += `${Yr.buildMLine(r)}\r\n`), i += "c=IN IP4 0.0.0.0\r\n", s.length || (i += "a=rtcp:1 IN IP4 0.0.0.0\r\n"), n.length && (n.attr("ufrag") && (i += `${Yr.buildICEUfrag(n.attr("ufrag"))}\r\n`), n.attr("pwd") && (i += `${Yr.buildICEPwd(n.attr("pwd"))}\r\n`), n.find('>fingerprint[xmlns="urn:xmpp:jingle:apps:dtls:0"]').each(((e, t) => {
							i += `a=fingerprint:${t.getAttribute("hash")}`, i += ` ${ft()(t).text()}`, i += "\r\n", t.hasAttribute("setup") && (i += `a=setup:${t.getAttribute("setup")}\r\n`)
						}))), n.find(">candidate").each(((e, t) => {
							let n = t.getAttribute("protocol");
							n = "string" == typeof n ? n.toLowerCase() : "", this.removeTcpCandidates && ("tcp" === n || "ssltcp" === n) || this.removeUdpCandidates && "udp" === n || (this.failICE && t.setAttribute("ip", "1.1.1.1"), i += Yr.candidateFromJingle(t))
						})), e.attr("senders")) {
							case "initiator":
								i += `a=${Br.SENDONLY}\r\n`;
								break;
							case "responder":
								i += `a=${Br.RECVONLY}\r\n`;
								break;
							case "none":
								i += `a=${Br.INACTIVE}\r\n`;
								break;
							case "both":
								i += `a=${Br.SENDRECV}\r\n`
						}
						i += `a=mid:${e.attr("name")}\r\n`, t.find(">rtcp-mux").length && (i += "a=rtcp-mux\r\n"), t.find(">payload-type").each(((e, t) => {
							i += `${Yr.buildRTPMap(t)}\r\n`, ft()(t).find(">parameter").length && (i += `a=fmtp:${t.getAttribute("id")} `, i += ft()(t).find(">parameter").map(((e, t) => {
								const n = t.getAttribute("name");
								return (n ? `${n}=` : "") + t.getAttribute("value")
							})).get().join(";"), i += "\r\n"), i += this.rtcpFbFromJingle(ft()(t), t.getAttribute("id"))
						})), i += this.rtcpFbFromJingle(t, "*"), t.find('>rtp-hdrext[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]').each(((e, t) => {
							i += `a=extmap:${t.getAttribute("id")} ${t.getAttribute("uri")}\r\n`
						})), t.find('>extmap-allow-mixed[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]').length > 0 && (i += "a=extmap-allow-mixed\r\n"), t.find('>ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(((e, t) => {
							const n = t.getAttribute("semantics"),
								s = ft()(t).find(">source").map(((e, t) => t.getAttribute("ssrc"))).get();
							s.length && (i += `a=ssrc-group:${n} ${s.join(" ")}\r\n`)
						}));
						let o = "",
							a = "";
						return t.find('>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(((e, t) => {
							const n = t.getAttribute("ssrc");
							let i = !0,
								s = "";
							ft()(t).find(">parameter").each(((e, t) => {
								var r;
								const o = t.getAttribute("name");
								let a = t.getAttribute("value");
								a = Yr.filterSpecialChars(a), s += `a=ssrc:${n} ${o}`, a && a.length && (s += `:${a}`), s += "\r\n", null !== (r = a) && void 0 !== r && r.includes("mixedmslabel") && (i = !1)
							})), i ? o += s : a += s
						})), i += a + o, i
					}, eo.prototype.getNewMedia = function() {
						const e = this.mySDP.getMediaSsrcMap(),
							t = this.otherSDP.getMediaSsrcMap(),
							n = {};
						return Object.keys(t).forEach((i => {
							const s = e[i],
								r = t[i];
							s || !r ? (Object.keys(r.ssrcs).forEach((e => {
								(-1 === Object.keys(s.ssrcs).indexOf(e) || r.ssrcs[e].lines && s.ssrcs[e].lines && void 0 !== s.ssrcs[e].lines.find((e => -1 !== e.indexOf("msid"))) != (void 0 !== r.ssrcs[e].lines.find((e => -1 !== e.indexOf("msid"))))) && (n[i] || (n[i] = {
									mediaindex: r.mediaindex,
									mid: r.mid,
									ssrcs: {},
									ssrcGroups: []
								}), n[i].ssrcs[e] = r.ssrcs[e])
							})), r.ssrcGroups.forEach((e => {
								let t = !1;
								for (let n = 0; n < s.ssrcGroups.length; n++) {
									const i = s.ssrcGroups[n];
									if (e.semantics === i.semantics && Zr(e.ssrcs, i.ssrcs)) {
										t = !0;
										break
									}
								}
								t || (n[i] || (n[i] = {
									mediaindex: r.mediaindex,
									mid: r.mid,
									ssrcs: {},
									ssrcGroups: []
								}), n[i].ssrcGroups.push(e))
							}))) : n[i] = r
						})), n
					}, eo.prototype.toJingle = function(e) {
						const t = this.getNewMedia();
						let n = !1;
						return Object.keys(t).forEach((i => {
							n = !0;
							const s = t[i];
							e.c("content", {
								name: s.mid
							}), e.c("description", {
								xmlns: "urn:xmpp:jingle:apps:rtp:1",
								media: s.mid
							}), Object.keys(s.ssrcs).forEach((t => {
								const n = s.ssrcs[t],
									i = n.lines,
									r = Yr.parseSourceNameLine(i),
									o = Yr.parseVideoTypeLine(i);
								e.c("source", {
									xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
								}), e.attrs({
									name: r,
									videoType: o,
									ssrc: n.ssrc
								});
								const a = Yr.parseMSIDAttribute(i);
								a && (e.c("parameter"), e.attrs({
									name: "msid"
								}), e.attrs({
									value: a
								}), e.up()), e.up()
							})), s.ssrcGroups.forEach((t => {
								t.ssrcs.length && (e.c("ssrc-group", {
									semantics: t.semantics,
									xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
								}), t.ssrcs.forEach((t => {
									e.c("source", {
										ssrc: t
									}).up()
								})), e.up())
							})), e.up(), e.up()
						})), n
					};
					var to = "function" == typeof queueMicrotask && queueMicrotask,
						no = "function" == typeof setImmediate && setImmediate,
						io = "object" == typeof process && "function" == typeof process.nextTick;

					function so(e) {
						setTimeout(e, 0)
					}

					function ro(e) {
						return (t, ...n) => e((() => t(...n)))
					}
					var oo = ro(to ? queueMicrotask : no ? setImmediate : io ? process.nextTick : so);

					function ao(e, t) {
						return e.then((e => {
							co(t, null, e)
						}), (e => {
							co(t, e && e.message ? e : new Error(e))
						}))
					}

					function co(e, t, n) {
						try {
							e(t, n)
						} catch (e) {
							oo((e => {
								throw e
							}), e)
						}
					}

					function lo(e) {
						return "AsyncFunction" === e[Symbol.toStringTag]
					}

					function uo(e) {
						if ("function" != typeof e) throw new Error("expected a function");
						return lo(e) ? lo(t = e) ? function(...e) {
							const n = e.pop();
							return ao(t.apply(this, e), n)
						} : (n = function(e, n) {
							var i;
							try {
								i = t.apply(this, e)
							} catch (e) {
								return n(e)
							}
							if (i && "function" == typeof i.then) return ao(i, n);
							n(null, i)
						}, function(...e) {
							var t = e.pop();
							return n.call(this, e, t)
						}) : e;
						var t, n
					}

					function ho(e, t = e.length) {
						if (!t) throw new Error("arity is undefined");
						return function(...n) {
							return "function" == typeof n[t - 1] ? e.apply(this, n) : new Promise(((i, s) => {
								n[t - 1] = (e, ...t) => {
									if (e) return s(e);
									i(t.length > 1 ? t : t[0])
								}, e.apply(this, n)
							}))
						}
					}

					function po(e) {
						return function(t, ...n) {
							return ho((function(i) {
								var s = this;
								return e(t, ((e, t) => {
									uo(e).apply(s, n.concat(t))
								}), i)
							}))
						}
					}

					function mo(e, t, n, i) {
						t = t || [];
						var s = [],
							r = 0,
							o = uo(n);
						return e(t, ((e, t, n) => {
							var i = r++;
							o(e, ((e, t) => {
								s[i] = t, n(e)
							}))
						}), (e => {
							i(e, s)
						}))
					}

					function fo(e) {
						return e && "number" == typeof e.length && e.length >= 0 && e.length % 1 == 0
					}
					const go = {};

					function _o(e) {
						function t(...t) {
							if (null !== e) {
								var n = e;
								e = null, n.apply(this, t)
							}
						}
						return Object.assign(t, e), t
					}

					function vo(e) {
						return function(...t) {
							if (null === e) throw new Error("Callback was already called.");
							var n = e;
							e = null, n.apply(this, t)
						}
					}

					function So(e, t, n, i) {
						let s = !1,
							r = !1,
							o = !1,
							a = 0,
							c = 0;

						function d() {
							a >= t || o || s || (o = !0, e.next().then((({
								value: e,
								done: t
							}) => {
								if (!r && !s) {
									if (o = !1, t) return s = !0, void(a <= 0 && i(null));
									a++, n(e, c, l), c++, d()
								}
							})).catch(u))
						}

						function l(e, t) {
							if (a -= 1, !r) return e ? u(e) : !1 === e ? (s = !0, void(r = !0)) : t === go || s && a <= 0 ? (s = !0, i(null)) : void d()
						}

						function u(e) {
							r || (o = !1, s = !0, i(e))
						}
						d()
					}
					var Eo = e => (t, n, i) => {
							if (i = _o(i), e <= 0) throw new RangeError("concurrency limit cannot be less than 1");
							if (!t) return i(null);
							if ("AsyncGenerator" === t[Symbol.toStringTag]) return So(t, e, n, i);
							if (function(e) {
									return "function" == typeof e[Symbol.asyncIterator]
								}(t)) return So(t[Symbol.asyncIterator](), e, n, i);
							var s = function(e) {
									if (fo(e)) return function(e) {
										var t = -1,
											n = e.length;
										return function() {
											return ++t < n ? {
												value: e[t],
												key: t
											} : null
										}
									}(e);
									var t, n, i, s, r = function(e) {
										return e[Symbol.iterator] && e[Symbol.iterator]()
									}(e);
									return r ? function(e) {
										var t = -1;
										return function() {
											var n = e.next();
											return n.done ? null : (t++, {
												value: n.value,
												key: t
											})
										}
									}(r) : (n = (t = e) ? Object.keys(t) : [], i = -1, s = n.length, function e() {
										var r = n[++i];
										return "__proto__" === r ? e() : i < s ? {
											value: t[r],
											key: r
										} : null
									})
								}(t),
								r = !1,
								o = !1,
								a = 0,
								c = !1;

							function d(e, t) {
								if (!o)
									if (a -= 1, e) r = !0, i(e);
									else if (!1 === e) r = !0, o = !0;
								else {
									if (t === go || r && a <= 0) return r = !0, i(null);
									c || l()
								}
							}

							function l() {
								for (c = !0; a < e && !r;) {
									var t = s();
									if (null === t) return r = !0, void(a <= 0 && i(null));
									a += 1, n(t.value, t.key, vo(d))
								}
								c = !1
							}
							l()
						},
						yo = ho((function(e, t, n, i) {
							return Eo(t)(e, uo(n), i)
						}), 4);

					function To(e, t, n) {
						n = _o(n);
						var i = 0,
							s = 0,
							{
								length: r
							} = e,
							o = !1;

						function a(e, t) {
							!1 === e && (o = !0), !0 !== o && (e ? n(e) : ++s !== r && t !== go || n(null))
						}
						for (0 === r && n(null); i < r; i++) t(e[i], i, vo(a))
					}

					function Co(e, t, n) {
						return yo(e, 1 / 0, t, n)
					}
					var bo = ho((function(e, t, n) {
							return (fo(e) ? To : Co)(e, uo(t), n)
						}), 3),
						Ao = ho((function(e, t, n) {
							return mo(bo, e, t, n)
						}), 3);
					po(Ao);
					var Ro = ho((function(e, t, n) {
						return yo(e, 1, t, n)
					}), 3);
					po(ho((function(e, t, n) {
						return mo(Ro, e, t, n)
					}), 3)), Symbol("promiseCallback");
					class Io {
						constructor() {
							this.head = this.tail = null, this.length = 0
						}
						removeLink(e) {
							return e.prev ? e.prev.next = e.next : this.head = e.next, e.next ? e.next.prev = e.prev : this.tail = e.prev, e.prev = e.next = null, this.length -= 1, e
						}
						empty() {
							for (; this.head;) this.shift();
							return this
						}
						insertAfter(e, t) {
							t.prev = e, t.next = e.next, e.next ? e.next.prev = t : this.tail = t, e.next = t, this.length += 1
						}
						insertBefore(e, t) {
							t.prev = e.prev, t.next = e, e.prev ? e.prev.next = t : this.head = t, e.prev = t, this.length += 1
						}
						unshift(e) {
							this.head ? this.insertBefore(this.head, e) : Po(this, e)
						}
						push(e) {
							this.tail ? this.insertAfter(this.tail, e) : Po(this, e)
						}
						shift() {
							return this.head && this.removeLink(this.head)
						}
						pop() {
							return this.tail && this.removeLink(this.tail)
						}
						toArray() {
							return [...this]
						}*[Symbol.iterator]() {
							for (var e = this.head; e;) yield e.data, e = e.next
						}
						remove(e) {
							for (var t = this.head; t;) {
								var {
									next: n
								} = t;
								e(t) && this.removeLink(t), t = n
							}
							return this
						}
					}

					function Po(e, t) {
						e.length = 1, e.head = e.tail = t
					}

					function Do(e, t, n) {
						if (null == t) t = 1;
						else if (0 === t) throw new RangeError("Concurrency must not be zero");
						var i = uo(e),
							s = 0,
							r = [];
						const o = {
							error: [],
							drain: [],
							saturated: [],
							unsaturated: [],
							empty: []
						};

						function a(e, t) {
							return e ? t ? void(o[e] = o[e].filter((e => e !== t))) : o[e] = [] : Object.keys(o).forEach((e => o[e] = []))
						}

						function c(e, ...t) {
							o[e].forEach((e => e(...t)))
						}
						var d = !1;

						function l(e, t, n, i) {
							if (null != i && "function" != typeof i) throw new Error("task callback must be a function");
							var s, r;

							function o(e, ...t) {
								return e ? n ? r(e) : s() : t.length <= 1 ? s(t[0]) : void s(t)
							}
							f.started = !0;
							var a = {
								data: e,
								callback: n ? o : i || o
							};
							if (t ? f._tasks.unshift(a) : f._tasks.push(a), d || (d = !0, oo((() => {
									d = !1, f.process()
								}))), n || !i) return new Promise(((e, t) => {
								s = e, r = t
							}))
						}

						function u(e) {
							return function(t, ...n) {
								s -= 1;
								for (var i = 0, o = e.length; i < o; i++) {
									var a = e[i],
										d = r.indexOf(a);
									0 === d ? r.shift() : d > 0 && r.splice(d, 1), a.callback(t, ...n), null != t && c("error", t, a.data)
								}
								s <= f.concurrency - f.buffer && c("unsaturated"), f.idle() && c("drain"), f.process()
							}
						}

						function h(e) {
							return !(0 !== e.length || !f.idle() || (oo((() => c("drain"))), 0))
						}
						const p = e => t => {
							if (!t) return new Promise(((t, n) => {
								! function(e, i) {
									const s = (...i) => {
										a(e, s), ((e, i) => {
											if (e) return n(e);
											t(i)
										})(...i)
									};
									o[e].push(s)
								}(e)
							}));
							a(e),
								function(e, t) {
									o[e].push(t)
								}(e, t)
						};
						var m = !1,
							f = {
								_tasks: new Io,
								*[Symbol.iterator]() {
									yield* f._tasks[Symbol.iterator]()
								},
								concurrency: t,
								payload: n,
								buffer: t / 4,
								started: !1,
								paused: !1,
								push(e, t) {
									if (Array.isArray(e)) {
										if (h(e)) return;
										return e.map((e => l(e, !1, !1, t)))
									}
									return l(e, !1, !1, t)
								},
								pushAsync(e, t) {
									if (Array.isArray(e)) {
										if (h(e)) return;
										return e.map((e => l(e, !1, !0, t)))
									}
									return l(e, !1, !0, t)
								},
								kill() {
									a(), f._tasks.empty()
								},
								unshift(e, t) {
									if (Array.isArray(e)) {
										if (h(e)) return;
										return e.map((e => l(e, !0, !1, t)))
									}
									return l(e, !0, !1, t)
								},
								unshiftAsync(e, t) {
									if (Array.isArray(e)) {
										if (h(e)) return;
										return e.map((e => l(e, !0, !0, t)))
									}
									return l(e, !0, !0, t)
								},
								remove(e) {
									f._tasks.remove(e)
								},
								process() {
									if (!m) {
										for (m = !0; !f.paused && s < f.concurrency && f._tasks.length;) {
											var e = [],
												t = [],
												n = f._tasks.length;
											f.payload && (n = Math.min(n, f.payload));
											for (var o = 0; o < n; o++) {
												var a = f._tasks.shift();
												e.push(a), r.push(a), t.push(a.data)
											}
											s += 1, 0 === f._tasks.length && c("empty"), s === f.concurrency && c("saturated");
											var d = vo(u(e));
											i(t, d)
										}
										m = !1
									}
								},
								length: () => f._tasks.length,
								running: () => s,
								workersList: () => r,
								idle: () => f._tasks.length + s === 0,
								pause() {
									f.paused = !0
								},
								resume() {
									!1 !== f.paused && (f.paused = !1, oo(f.process))
								}
							};
						return Object.defineProperties(f, {
							saturated: {
								writable: !1,
								value: p("saturated")
							},
							unsaturated: {
								writable: !1,
								value: p("unsaturated")
							},
							empty: {
								writable: !1,
								value: p("empty")
							},
							drain: {
								writable: !1,
								value: p("drain")
							},
							error: {
								writable: !1,
								value: p("error")
							}
						}), f
					}
					ho((function(e, t, n, i) {
						i = _o(i);
						var s = uo(n);
						return Ro(e, ((e, n, i) => {
							s(t, e, ((e, n) => {
								t = n, i(e)
							}))
						}), (e => i(e, t)))
					}), 4);
					var wo = ho((function(e, t, n, i) {
							return mo(Eo(t), e, n, i)
						}), 4),
						Oo = ho((function(e, t, n, i) {
							var s = uo(n);
							return wo(e, t, ((e, t) => {
								s(e, ((e, ...n) => e ? t(e) : t(e, n)))
							}), ((e, t) => {
								for (var n = [], s = 0; s < t.length; s++) t[s] && (n = n.concat(...t[s]));
								return i(e, n)
							}))
						}), 4);

					function No(e, t) {
						return (n, i, s, r) => {
							var o, a = !1;
							const c = uo(s);
							n(i, ((n, i, s) => {
								c(n, ((i, r) => i || !1 === i ? s(i) : e(r) && !o ? (a = !0, o = t(!0, n), s(null, go)) : void s()))
							}), (e => {
								if (e) return r(e);
								r(null, a ? o : t(!1))
							}))
						}
					}

					function Mo(e) {
						return (t, ...n) => uo(t)(...n, ((t, ...n) => {
							"object" == typeof console && (t ? console.error && console.error(t) : console[e] && n.forEach((t => console[e](t))))
						}))
					}

					function Lo(e) {
						return (t, n, i) => e(t, i)
					}
					ho((function(e, t, n) {
						return Oo(e, 1 / 0, t, n)
					}), 3), ho((function(e, t, n) {
						return Oo(e, 1, t, n)
					}), 3), ho((function(e, t, n) {
						return No((e => e), ((e, t) => t))(bo, e, t, n)
					}), 3), ho((function(e, t, n, i) {
						return No((e => e), ((e, t) => t))(Eo(t), e, n, i)
					}), 4), ho((function(e, t, n) {
						return No((e => e), ((e, t) => t))(Eo(1), e, t, n)
					}), 3), Mo("dir"), ho((function(e, t, n) {
						n = vo(n);
						var i, s = uo(e),
							r = uo(t);

						function o(e, ...t) {
							if (e) return n(e);
							!1 !== e && (i = t, r(...t, a))
						}

						function a(e, t) {
							return e ? n(e) : !1 !== e ? t ? void s(o) : n(null, ...i) : void 0
						}
						return a(null, !0)
					}), 3), ho((function(e, t, n) {
						return bo(e, Lo(uo(t)), n)
					}), 3);
					var ko = ho((function(e, t, n, i) {
							return Eo(t)(e, Lo(uo(n)), i)
						}), 4),
						xo = ho((function(e, t, n) {
							return ko(e, 1, t, n)
						}), 3);

					function Fo(e, t, n, i) {
						var s = new Array(t.length);
						e(t, ((e, t, i) => {
							n(e, ((e, n) => {
								s[t] = !!n, i(e)
							}))
						}), (e => {
							if (e) return i(e);
							for (var n = [], r = 0; r < t.length; r++) s[r] && n.push(t[r]);
							i(null, n)
						}))
					}

					function Vo(e, t, n, i) {
						var s = [];
						e(t, ((e, t, i) => {
							n(e, ((n, r) => {
								if (n) return i(n);
								r && s.push({
									index: t,
									value: e
								}), i(n)
							}))
						}), (e => {
							if (e) return i(e);
							i(null, s.sort(((e, t) => e.index - t.index)).map((e => e.value)))
						}))
					}

					function Uo(e, t, n, i) {
						return (fo(t) ? Fo : Vo)(e, t, uo(n), i)
					}

					function jo(e, t, n, i) {
						const s = uo(n);
						return Uo(e, t, ((e, t) => {
							s(e, ((e, n) => {
								t(e, !n)
							}))
						}), i)
					}
					ho((function(e, t, n) {
						return No((e => !e), (e => !e))(bo, e, t, n)
					}), 3), ho((function(e, t, n, i) {
						return No((e => !e), (e => !e))(Eo(t), e, n, i)
					}), 4), ho((function(e, t, n) {
						return No((e => !e), (e => !e))(Ro, e, t, n)
					}), 3), ho((function(e, t, n) {
						return Uo(bo, e, t, n)
					}), 3), ho((function(e, t, n, i) {
						return Uo(Eo(t), e, n, i)
					}), 4), ho((function(e, t, n) {
						return Uo(Ro, e, t, n)
					}), 3), ho((function(e, t) {
						var n = vo(t),
							i = uo(function(e) {
								return lo(e) ? e : function(...t) {
									var n = t.pop(),
										i = !0;
									t.push(((...e) => {
										i ? oo((() => n(...e))) : n(...e)
									})), e.apply(this, t), i = !1
								}
							}(e));
						return function e(t) {
							if (t) return n(t);
							!1 !== t && i(e)
						}()
					}), 2), ho((function(e, t, n, i) {
						var s = uo(n);
						return wo(e, t, ((e, t) => {
							s(e, ((n, i) => n ? t(n) : t(n, {
								key: i,
								val: e
							})))
						}), ((e, t) => {
							for (var n = {}, {
									hasOwnProperty: s
								} = Object.prototype, r = 0; r < t.length; r++)
								if (t[r]) {
									var {
										key: o
									} = t[r], {
										val: a
									} = t[r];
									s.call(n, o) ? n[o].push(a) : n[o] = [a]
								} return i(e, n)
						}))
					}), 4), Mo("log"), ho((function(e, t, n, i) {
						i = _o(i);
						var s = {},
							r = uo(n);
						return Eo(t)(e, ((e, t, n) => {
							r(e, t, ((e, i) => {
								if (e) return n(e);
								s[t] = i, n(e)
							}))
						}), (e => i(e, s)))
					}), 4), ro(io ? process.nextTick : no ? setImmediate : so), ho(((e, t, n) => {
						var i = fo(t) ? [] : {};
						e(t, ((e, t, n) => {
							uo(e)(((e, ...s) => {
								s.length < 2 && ([s] = s), i[t] = s, n(e)
							}))
						}), (e => n(e, i)))
					}), 3), Symbol.iterator, ho((function(e, t) {
						if (t = _o(t), !Array.isArray(e)) return t(new TypeError("First argument to race must be an array of functions"));
						if (!e.length) return t();
						for (var n = 0, i = e.length; n < i; n++) uo(e[n])(t)
					}), 2), ho((function(e, t, n) {
						return jo(bo, e, t, n)
					}), 3), ho((function(e, t, n, i) {
						return jo(Eo(t), e, n, i)
					}), 4), ho((function(e, t, n) {
						return jo(Ro, e, t, n)
					}), 3), ho((function(e, t, n) {
						return No(Boolean, (e => e))(bo, e, t, n)
					}), 3), ho((function(e, t, n, i) {
						return No(Boolean, (e => e))(Eo(t), e, n, i)
					}), 4), ho((function(e, t, n) {
						return No(Boolean, (e => e))(Ro, e, t, n)
					}), 3), ho((function(e, t, n) {
						var i = uo(t);
						return Ao(e, ((e, t) => {
							i(e, ((n, i) => {
								if (n) return t(n);
								t(n, {
									value: e,
									criteria: i
								})
							}))
						}), ((e, t) => {
							if (e) return n(e);
							n(null, t.sort(s).map((e => e.value)))
						}));

						function s(e, t) {
							var n = e.criteria,
								i = t.criteria;
							return n < i ? -1 : n > i ? 1 : 0
						}
					}), 3), ho((function(e, t) {
						var n, i = null;
						return xo(e, ((e, t) => {
							uo(e)(((e, ...s) => {
								if (!1 === e) return t(e);
								s.length < 2 ? [n] = s : n = s, i = e, t(e ? null : {})
							}))
						}), (() => t(i, n)))
					})), ho((function(e, t, n) {
						n = vo(n);
						var i = uo(t),
							s = uo(e),
							r = [];

						function o(e, ...t) {
							if (e) return n(e);
							r = t, !1 !== e && s(a)
						}

						function a(e, t) {
							return e ? n(e) : !1 !== e ? t ? void i(o) : n(null, ...r) : void 0
						}
						return s(a)
					}), 3), ho((function(e, t) {
						if (t = _o(t), !Array.isArray(e)) return t(new Error("First argument to waterfall must be an array of functions"));
						if (!e.length) return t();
						var n = 0;

						function i(t) {
							uo(e[n++])(...t, vo(s))
						}

						function s(s, ...r) {
							if (!1 !== s) return s || n === e.length ? t(s, ...r) : void i(r)
						}
						i([])
					}));
					const Ho = (0, S.getLogger)("modules/util/AsyncQueue.js");
					class Bo {
						constructor() {
							var e, t, n;
							this._queue = (e = this._processQueueTasks.bind(this), t = 1, n = uo(e), Do(((e, t) => {
								n(e[0], t)
							}), t, 1)), this._stopped = !1
						}
						clear() {
							this._queue.kill()
						}
						_processQueueTasks(e, t) {
							try {
								e(t)
							} catch (e) {
								Ho.error(`Task failed: ${null==e?void 0:e.stack}`), t(e)
							}
						}
						push(e, t) {
							this._stopped ? t && t(new Error("The queue has been stopped")) : this._queue.push(e, t)
						}
						shutdown() {
							this._stopped = !0
						}
					}
					var $o = n(2593);
					let Jo;
					! function(e) {
						e.PENDING = "pending", e.ACTIVE = "active", e.ENDED = "ended"
					}(Jo || (Jo = {}));
					const Go = Jo.PENDING,
						qo = Jo.ACTIVE,
						Ko = Jo.ENDED,
						Wo = (0, S.getLogger)("modules/xmpp/JingleSession.js");
					class Xo extends Yi {
						constructor(e, t, n, i, s, r, o) {
							super(), this.sid = e, this.localJid = t, this.remoteJid = n, this.connection = i, this.mediaConstraints = s, this.pcConfig = r, this.isInitiator = o, this.usedrip = !0, this.dripContainer = [], this.room = null, this._signalingLayer = null, this.state = null, this.rtc = null
						}
						get initiatorJid() {
							return this.isInitiator ? this.localJid : this.remoteJid
						}
						get responderJid() {
							return this.isInitiator ? this.remoteJid : this.localJid
						}
						initialize(e, t, n, i) {
							if (null !== this.state) {
								const e = `attempt to initiate on session ${this.sid}\n                   in state ${this.state}`;
								throw Wo.error(e), new Error(e)
							}
							this.room = e, this.rtc = t, this._signalingLayer = n, this.state = Go, this.doInitialize(i)
						}
						doInitialize(e) {}
						addIceCandidates(e) {}
						getState() {
							return this.state
						}
						addSources(e) {}
						removeSources(e) {}
						terminate(e, t, n) {}
						acceptOffer(e, t, n) {}
					}
					var zo;
					! function(e) {
						e.REMOTE_SOURCE_CONSTRAINTS_CHANGED = "media_session.REMOTE_SOURCE_CONSTRAINTS_CHANGED"
					}(zo || (zo = {}));
					const Yo = zo,
						Qo = (0, S.getLogger)("modules/xmpp/JingleSessionPC.js"),
						Zo = 1e4;

					function ea(e, t, n, i) {
						e.c("source", {
							xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
							ssrc: n,
							name: t.source
						}).c("parameter", {
							name: "msid",
							value: i
						}).up().c("ssrc-info", {
							xmlns: "http://jitsi.org/jitmeet",
							owner: t.owner
						}).up().up()
					}
					class ta extends Xo {
						static parseVideoSenders(e) {
							const t = e.find('>content[name="video"]');
							if (t.length) {
								const e = t[0].getAttribute("senders");
								if ("both" === e || "initiator" === e || "responder" === e || "none" === e) return e
							}
							return null
						}
						static parseSourceMaxFrameHeight(e) {
							const t = [],
								n = e.find('>content[name="video"]>source-frame-height');
							let i, s;
							return n.length ? (n.each(((e, n) => {
								s = n.getAttribute("sourceName"), i = n.getAttribute("maxHeight"), t.push({
									maxHeight: i,
									sourceName: s
								})
							})), t) : null
						}
						constructor(e, t, n, i, s, r, o, a) {
							super(e, t, n, i, s, r, a), this._bridgeSessionId = null, this._cachedOldLocalSdp = void 0, this._cachedNewLocalSdp = void 0, this._iceCheckingStartedTimestamp = null, this._gatheringStartedTimestamp = null, this._sourceReceiverConstraints = void 0, this._localVideoActive = !0, this._remoteVideoActive = !0, this._gatheringReported = !1, this.lasticecandidate = !1, this.closed = !1, this.isP2P = o, this.remoteRecvMaxFrameHeight = void 0, this.numRemoteVideoSources = 0, this.numRemoteAudioSources = 0, this.remoteSourceMaxFrameHeights = void 0, this.modificationQueue = new Bo, this.wasConnected = !1, this.establishmentDuration = void 0, this._xmppListeners = [], this._xmppListeners.push(i.addEventListener(Qs.Events.CONN_STATUS_CHANGED, this.onXmppStatusChanged.bind(this))), this._removeSenderVideoConstraintsChangeListener = void 0
						}
						_assertNotEnded() {
							return this.state !== Ko
						}
						doInitialize(e) {
							var t, n, i;
							this.failICE = Boolean(e.failICE), this.lasticecandidate = !1, this.options = e, this.isReconnect = !1, this.wasstable = !1, this.webrtcIceUdpDisable = Boolean(e.webrtcIceUdpDisable), this.webrtcIceTcpDisable = Boolean(e.webrtcIceTcpDisable);
							const s = {
								disableRtx: e.disableRtx
							};
							if (e.gatherStats && (s.maxstats = 300), s.capScreenshareBitrate = !1, s.enableInsertableStreams = e.enableInsertableStreams, s.videoQuality = e.videoQuality, s.forceTurnRelay = e.forceTurnRelay, s.audioQuality = e.audioQuality, s.usesUnifiedPlan = this.usesUnifiedPlan = Wn.supportsUnifiedPlan() && (!Wn.isChromiumBased() || (Wn.isChromiumBased() && this.isP2P ? null === (t = null === (n = e.p2p) || void 0 === n ? void 0 : n.enableUnifiedOnChrome) || void 0 === t || t : null === (i = e.enableUnifiedOnChrome) || void 0 === i || i)), this.isP2P) {
								s.disableSimulcast = !0;
								const t = this._abtestSuspendVideoEnabled(e);
								void 0 !== t && (s.abtestSuspendVideo = t)
							} else {
								var r, o, a;
								s.disableSimulcast = e.disableSimulcast || (null === (r = e.videoQuality) || void 0 === r ? void 0 : r.preferredCodec) === jr.H264, s.capScreenshareBitrate = s.disableSimulcast || !("number" == typeof(null === (o = e.desktopSharingFrameRate) || void 0 === o ? void 0 : o.max) && (null === (a = e.desktopSharingFrameRate) || void 0 === a ? void 0 : a.max) > 5)
							}
							e.startSilent && (s.startSilent = !0), this.peerconnection = this.rtc.createPeerConnection(this._signalingLayer, this.pcConfig, this.isP2P, s), this.peerconnection.onicecandidate = e => {
								if (!e) return;
								const t = e.candidate,
									n = window.performance.now();
								if (t) {
									null === this._gatheringStartedTimestamp && (this._gatheringStartedTimestamp = n);
									let e = t.protocol;
									if ("string" == typeof e)
										if (e = e.toLowerCase(), "tcp" === e || "ssltcp" === e) {
											if (this.webrtcIceTcpDisable) return
										} else if ("udp" === e && this.webrtcIceUdpDisable) return
								} else this._gatheringReported || (Pi.sendAnalytics(pn, {
									phase: "gathering",
									value: n - this._gatheringStartedTimestamp,
									p2p: this.isP2P,
									initiator: this.isInitiator
								}), this._gatheringReported = !0);
								this.isP2P && this.sendIceCandidate(t)
							}, this.peerconnection.onsignalingstatechange = () => {
								"stable" === this.peerconnection.signalingState ? this.wasstable = !0 : "closed" !== this.peerconnection.signalingState && "closed" !== this.peerconnection.connectionState || this.room.eventEmitter.emit(ki.XMPPEvents.SUSPEND_DETECTED, this)
							}, this.peerconnection.oniceconnectionstatechange = () => {
								const e = window.performance.now();
								let t = !1;
								switch (this.isP2P || (this.room.connectionTimes[`ice.state.${this.peerconnection.iceConnectionState}`] = e), Qo.log(`(TIME) ICE ${this.peerconnection.iceConnectionState} ${this.isP2P?"P2P":"JVB"}:\t`, e), Pi.sendAnalytics(fn, {
									p2p: this.isP2P,
									state: this.peerconnection.iceConnectionState,
									signaling_state: this.peerconnection.signalingState,
									reconnect: this.isReconnect,
									value: e
								}), this.room.eventEmitter.emit(ki.XMPPEvents.ICE_CONNECTION_STATE_CHANGED, this, this.peerconnection.iceConnectionState), this.peerconnection.iceConnectionState) {
									case "checking":
										this._iceCheckingStartedTimestamp = e;
										break;
									case "connected":
										if ("stable" === this.peerconnection.signalingState) {
											t = !0;
											const e = !this.options.enableIceRestart && this.room.supportsRestartByTerminate();
											(this.isReconnect || e) && this.room.eventEmitter.emit(ki.XMPPEvents.CONNECTION_RESTORED, this)
										}
										if (!this.wasConnected && (this.wasstable || t || this.usesUnifiedPlan && this.isInitiator && (Wn.isChromiumBased() || Wn.isReactNative()))) {
											Pi.sendAnalytics(pn, {
												phase: "checking",
												value: e - this._iceCheckingStartedTimestamp,
												p2p: this.isP2P,
												initiator: this.isInitiator
											});
											const t = Math.min(this._iceCheckingStartedTimestamp, this._gatheringStartedTimestamp);
											this.establishmentDuration = e - t, Pi.sendAnalytics(pn, {
												phase: "establishment",
												value: this.establishmentDuration,
												p2p: this.isP2P,
												initiator: this.isInitiator
											}), this.wasConnected = !0, this.room.eventEmitter.emit(ki.XMPPEvents.CONNECTION_ESTABLISHED, this)
										}
										this.isReconnect = !1;
										break;
									case "disconnected":
										this.isReconnect = !0, this.wasstable && this.room.eventEmitter.emit(ki.XMPPEvents.CONNECTION_INTERRUPTED, this);
										break;
									case "failed":
										this.room.eventEmitter.emit(ki.XMPPEvents.CONNECTION_ICE_FAILED, this)
								}
							}, this.peerconnection.onconnectionstatechange = () => {
								const e = this.peerconnection.iceConnectionState;
								"failed" === this.peerconnection.connectionState && "disconnected" === e && this.room.eventEmitter.emit(ki.XMPPEvents.CONNECTION_ICE_FAILED, this)
							}, this.peerconnection.onnegotiationneeded = () => {
								const e = this.peerconnection.signalingState,
									t = this.peerconnection.remoteDescription;
								if (this.usesUnifiedPlan && !this.isP2P && "stable" === e && t && "string" == typeof t.sdp) {
									Qo.info(`${this} onnegotiationneeded fired on ${this.peerconnection}`);
									const e = e => {
										const t = new Qr(this.peerconnection.localDescription.sdp);
										this._renegotiate().then((() => this.peerconnection.configureSenderVideoEncodings())).then((() => {
											const e = new Qr(this.peerconnection.localDescription.sdp);
											this.notifyMySSRCUpdate(t, e)
										})).then((() => e()), (t => e(t)))
									};
									this.modificationQueue.push(e, (e => {
										e ? Qo.error(`${this} onnegotiationneeded error`, e) : Qo.debug(`${this} onnegotiationneeded executed - OK`)
									}))
								}
							}
						}
						getRemoteRecvMaxFrameHeight() {
							if (this.isP2P) return this.remoteRecvMaxFrameHeight
						}
						getRemoteSourcesRecvMaxFrameHeight() {
							if (this.isP2P) return this.remoteSourceMaxFrameHeights
						}
						sendIceCandidate(e) {
							const t = new Qr(this.peerconnection.localDescription.sdp);
							if (e && e.candidate.length && !this.lasticecandidate) {
								const n = Yr.iceparams(t.media[e.sdpMLineIndex], t.session),
									i = Yr.candidateToJingle(e.candidate);
								if (!n || !i) {
									const e = "failed to get ice && jcand";
									return ei().callErrorHandler(new Error(e)), void Qo.error(e)
								}
								n.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", this.usedrip ? (0 === this.dripContainer.length && setTimeout((() => {
									0 !== this.dripContainer.length && (this.sendIceCandidates(this.dripContainer), this.dripContainer = [])
								}), 150), this.dripContainer.push(e)) : this.sendIceCandidates([e])
							} else Qo.log(`${this} sendIceCandidate: last candidate`), this.lasticecandidate = !0
						}
						sendIceCandidates(e) {
							if (!this._assertNotEnded("sendIceCandidates")) return;
							Qo.log(`${this} sendIceCandidates ${JSON.stringify(e)}`);
							const t = (0, vt.$iq)({
									to: this.remoteJid,
									type: "set"
								}).c("jingle", {
									xmlns: "urn:xmpp:jingle:1",
									action: "transport-info",
									initiator: this.initiatorJid,
									sid: this.sid
								}),
								n = new Qr(this.peerconnection.localDescription.sdp);
							for (let i = 0; i < n.media.length; i++) {
								const s = e.filter((e => e.sdpMLineIndex === i)),
									r = Yr.parseMLine(n.media[i].split("\r\n")[0]);
								if (s.length > 0) {
									const e = Yr.iceparams(n.media[i], n.session);
									e.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.c("content", {
										creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
										name: s[0].sdpMid ? s[0].sdpMid : r.media
									}).c("transport", e);
									for (let e = 0; e < s.length; e++) {
										const n = Yr.candidateToJingle(s[e].candidate);
										this.failICE && (n.ip = "1.1.1.1"), t.c("candidate", n).up()
									}
									const o = Yr.findLine(n.media[i], "a=fingerprint:", n.session);
									if (o) {
										const e = Yr.parseFingerprint(o);
										e.required = !0, t.c("fingerprint", {
											xmlns: "urn:xmpp:jingle:apps:dtls:0"
										}).t(e.fingerprint), delete e.fingerprint, t.attrs(e), t.up()
									}
									t.up(), t.up()
								}
							}
							this.connection.sendIQ(t, null, this.newJingleErrorHandler(t), Zo)
						}
						sendIceFailedNotification() {
							const e = (0, vt.$iq)({
								to: this.remoteJid,
								type: "set"
							}).c("jingle", {
								xmlns: "urn:xmpp:jingle:1",
								action: "session-info",
								initiator: this.initiatorJid,
								sid: this.sid
							}).c("ice-state", {
								xmlns: "http://jitsi.org/protocol/focus"
							}).t("failed").up();
							this._bridgeSessionId && e.c("bridge-session", {
								xmlns: "http://jitsi.org/protocol/focus",
								id: this._bridgeSessionId
							}), this.connection.sendIQ2(e, {
								timeout: 65
							}).catch(this.newJingleErrorHandler(e))
						}
						addIceCandidates(e) {
							if ("closed" === this.peerconnection.signalingState) return void Qo.warn(`${this} Ignored add ICE candidate when in closed state`);
							const t = [];
							e.find(">content>transport>candidate").each(((e, n) => {
								let i = Yr.candidateFromJingle(n);
								i = i.replace("\r\n", "").replace("a=", "");
								const s = new RTCIceCandidate({
									sdpMLineIndex: 0,
									sdpMid: "",
									candidate: i
								});
								t.push(s)
							})), t.length ? (Qo.debug(`${this} Queued add (${t.length}) ICE candidates task`), this.modificationQueue.push((e => {
								for (const e of t) this.peerconnection.addIceCandidate(e).then((() => Qo.debug(`${this} addIceCandidate ok!`)), (e => Qo.error(`${this} addIceCandidate failed!`, e)));
								e(), Qo.debug(`${this} ICE candidates task finished`)
							}))) : Qo.error(`${this} No ICE candidates to add ?`, e[0] && e[0].outerHTML)
						}
						readSsrcInfo(e) {
							ft()(e).find('>description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(((e, t) => {
								const n = Number(t.getAttribute("ssrc"));
								if (t.hasAttribute("name")) {
									const e = t.getAttribute("name");
									this._signalingLayer.setTrackSourceName(n, e)
								}
								this.isP2P ? this._signalingLayer.setSSRCOwner(n, vt.Strophe.getResourceFromJid(this.remoteJid)) : ft()(t).find('>ssrc-info[xmlns="http://jitsi.org/jitmeet"]').each(((e, t) => {
									const i = t.getAttribute("owner");
									var s;
									null != i && i.length && (isNaN(n) || n < 0 ? Qo.warn(`${this} Invalid SSRC ${n} value received for ${i}`) : this._signalingLayer.setSSRCOwner(n, (s = i, vt.Strophe.getResourceFromJid(s) || s)))
								}))
							}))
						}
						generateRecvonlySsrc() {
							this.peerconnection ? this.peerconnection.generateRecvonlySsrc() : Qo.error(`${this} Unable to generate recvonly SSRC - no peerconnection`)
						}
						getConfiguredVideoCodec() {
							return this.peerconnection.getConfiguredVideoCodec()
						}
						acceptOffer(e, t, n, i) {
							this.setOfferAnswerCycle(e, (() => {
								this.sendSessionAccept((() => {
									t(), this.room.eventEmitter.emit(ki.XMPPEvents.SESSION_ACCEPT, this);
									const e = i.filter((e => e.getType() === _i.VIDEO));
									e.length && e.splice(0, 1), Ns.isMultiStreamSendSupportEnabled() && e.length && this.addTracks(e)
								}), (e => {
									n(e), this.room.eventEmitter.emit(ki.XMPPEvents.SESSION_ACCEPT_ERROR, this, e)
								}))
							}), n, i)
						}
						invite() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
							if (!this.isInitiator) throw new Error("Trying to invite from the responder session");
							Qo.debug(`${this} Queued invite task`), this.modificationQueue.push((t => {
								const n = [];
								for (const t of e) n.push(this.peerconnection.addTrack(t, this.isInitiator));
								Promise.all(n).then((() => this.peerconnection.createOffer(this.mediaConstraints))).then((e => this.peerconnection.setLocalDescription(e))).then((() => {
									this.peerconnection.processLocalSdpForTransceiverInfo(e), this.sendSessionInitiate(this.peerconnection.localDescription.sdp)
								})).then((() => t()), (e => t(e)))
							}), (e => {
								e ? Qo.error(`${this} invite error`, e) : Qo.debug(`${this} invite executed - OK`)
							}))
						}
						sendSessionInitiate(e) {
							let t = (0, vt.$iq)({
								to: this.remoteJid,
								type: "set"
							}).c("jingle", {
								xmlns: "urn:xmpp:jingle:1",
								action: "session-initiate",
								initiator: this.initiatorJid,
								sid: this.sid
							});
							new Qr(e).toJingle(t, this.isInitiator ? "initiator" : "responder"), t = t.tree(), Qo.debug(`${this} Session-initiate: `, t), this.connection.sendIQ(t, (() => {
								Qo.info(`${this} Got RESULT for "session-initiate"`)
							}), (e => {
								Qo.error(`${this} "session-initiate" error`, e)
							}), Zo)
						}
						setAnswer(e) {
							if (!this.isInitiator) throw new Error("Trying to set an answer on the responder session");
							Qo.debug(`${this} Queued setAnswer task`), this.modificationQueue.push((t => {
								const n = this._processNewJingleOfferIq(e),
									i = new Qr(this.peerconnection.localDescription.sdp),
									s = new RTCSessionDescription({
										type: "answer",
										sdp: n.raw
									});
								this.peerconnection.setRemoteDescription(s).then((() => {
									if (this.state === Go) {
										this.state = qo;
										const e = new Qr(this.peerconnection.localDescription.sdp);
										this.sendContentModify(), this.notifyMySSRCUpdate(i, e)
									}
								})).then((() => t()), (e => t(e)))
							}), (e => {
								e ? Qo.error(`${this} setAnswer task failed: ${e}`) : Qo.debug(`${this} setAnswer task done`)
							}))
						}
						setOfferAnswerCycle(e, t, n) {
							let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [];
							Qo.debug(`${this} Queued setOfferAnswerCycle task`), this.modificationQueue.push((t => {
								const n = [],
									s = i.filter((e => e.getType() === _i.AUDIO)),
									r = i.filter((e => e.getType() === _i.VIDEO));
								let o = i;
								Ns.isMultiStreamSendSupportEnabled() && r.length > 1 && (o = [...s, r[0]]);
								for (const e of o) n.push(this.peerconnection.addTrack(e, this.isInitiator));
								const a = this._processNewJingleOfferIq(e),
									c = this.peerconnection.localDescription.sdp,
									d = ft()(e).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("id");
								d !== this._bridgeSessionId && (this._bridgeSessionId = d);
								const l = new RTCSessionDescription({
									type: "offer",
									sdp: a.raw
								});
								Promise.all(n).then((() => this._responderRenegotiate(l))).then((() => {
									if (this.peerconnection.processLocalSdpForTransceiverInfo(o), this.state === Go && (this.state = qo, !this.isP2P || this._localVideoActive && !this._sourceReceiverConstraints || this.sendContentModify()), c) {
										const e = new Qr(this.peerconnection.localDescription.sdp);
										this.notifyMySSRCUpdate(new Qr(c), e)
									}
								})).then((() => t()), (e => t(e)))
							}), (e => {
								e ? (Qo.error(`${this} setOfferAnswerCycle task failed: ${e}`), n(e)) : (Qo.debug(`${this} setOfferAnswerCycle task done`), t())
							}))
						}
						setVideoCodecs() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
								t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
							if (this._assertNotEnded()) {
								Qo.info(`${this} setVideoCodecs: preferred=${e}, disabled=${t}`), this.peerconnection.setVideoCodecs(e, t);
								const n = e => {
									this._renegotiate().then((() => (Qo.debug(`${this} setVideoCodecs task is done`), e())), (t => (Qo.error(`${this} setVideoCodecs task failed: ${t}`), e(t))))
								};
								Qo.debug(`${this} Queued setVideoCodecs task`), this.modificationQueue.push(n)
							}
						}
						replaceTransport(e, t, n) {
							if (this.options.enableForcedReload) {
								const e = new Qr(this.peerconnection.localDescription.sdp);
								return this.sendTransportAccept(e, t, n), void this.room.eventEmitter.emit(ki.XMPPEvents.CONNECTION_RESTARTED, this)
							}
							this.room.eventEmitter.emit(ki.XMPPEvents.ICE_RESTARTING, this);
							const i = e.clone();
							e.find(">content[name='data']").attr("senders", "rejected"), e.find(">content>description>source").remove(), e.find(">content>description>ssrc-group").remove();
							const s = e.find(">content>transport>fingerprint");
							s.attr("hash", "sha-1"), s.text("00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00"), this.setOfferAnswerCycle(e, (() => {
								this.setOfferAnswerCycle(i, (() => {
									const e = new Qr(this.peerconnection.localDescription.sdp);
									this.sendTransportAccept(e, t, n), this.room.eventEmitter.emit(ki.XMPPEvents.ICE_RESTART_SUCCESS, this, i)
								}), n)
							}), n)
						}
						sendSessionAccept(e, t) {
							const n = new Qr(this.peerconnection.localDescription.sdp),
								i = (0, vt.$iq)({
									to: this.remoteJid,
									type: "set"
								}).c("jingle", {
									xmlns: "urn:xmpp:jingle:1",
									action: "session-accept",
									initiator: this.initiatorJid,
									responder: this.responderJid,
									sid: this.sid
								});
							this.webrtcIceTcpDisable && (n.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (n.removeUdpCandidates = !0), this.failICE && (n.failICE = !0), n.toJingle(i, this.initiatorJid === this.localJid ? "initiator" : "responder"), Qo.info(`${this} Sending session-accept`), Qo.debug(i.tree()), this.connection.sendIQ(i, e, this.newJingleErrorHandler(i, (e => {
								t(e), this.room.eventEmitter.emit(ki.XMPPEvents.SESSION_ACCEPT_TIMEOUT, this)
							})), Zo)
						}
						sendContentModify() {
							const e = this._localVideoActive ? "both" : "none",
								t = (0, vt.$iq)({
									to: this.remoteJid,
									type: "set"
								}).c("jingle", {
									xmlns: "urn:xmpp:jingle:1",
									action: "content-modify",
									initiator: this.initiatorJid,
									sid: this.sid
								}).c("content", {
									name: _i.VIDEO,
									senders: e
								});
							void 0 !== this._sourceReceiverConstraints && this._sourceReceiverConstraints.forEach(((e, n) => {
								t.c("source-frame-height", {
									xmlns: "http://jitsi.org/jitmeet/video"
								}).attrs({
									sourceName: n,
									maxHeight: e
								}), t.up(), Qo.info(`${this} sending content-modify for source-name: ${n}, maxHeight: ${e}`)
							})), Qo.debug(t.tree()), this.connection.sendIQ(t, null, this.newJingleErrorHandler(t), Zo)
						}
						setReceiverVideoConstraint(e) {
							Qo.info(`${this} setReceiverVideoConstraint - constraints: ${JSON.stringify(e)}`), this._sourceReceiverConstraints = e, this.isP2P && this.state === qo && this.sendContentModify()
						}
						sendTransportAccept(e, t, n) {
							const i = (0, vt.$iq)({
								to: this.remoteJid,
								type: "set"
							}).c("jingle", {
								xmlns: "urn:xmpp:jingle:1",
								action: "transport-accept",
								initiator: this.initiatorJid,
								sid: this.sid
							});
							e.media.forEach(((t, n) => {
								const s = Yr.parseMLine(t.split("\r\n")[0]);
								i.c("content", {
									creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
									name: s.media
								}), e.transportToJingle(n, i), i.up()
							})), Qo.info(`${this} Sending transport-accept`), Qo.debug(i.tree()), this.connection.sendIQ(i, t, this.newJingleErrorHandler(i, n), Zo)
						}
						sendTransportReject(e, t) {
							const n = (0, vt.$iq)({
								to: this.remoteJid,
								type: "set"
							}).c("jingle", {
								xmlns: "urn:xmpp:jingle:1",
								action: "transport-reject",
								initiator: this.initiatorJid,
								sid: this.sid
							});
							Qo.info(`${this} Sending 'transport-reject'`), Qo.debug(n.tree()), this.connection.sendIQ(n, e, this.newJingleErrorHandler(n, t), Zo)
						}
						setSenderVideoConstraint(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
							if (this._assertNotEnded()) {
								Qo.info(`${this} setSenderVideoConstraint: ${e}, sourceName: ${t}`);
								const n = t ? this.rtc.getLocalVideoTracks().find((e => e.getSourceName() === t)) : this.rtc.getLocalVideoTrack();
								return this.peerconnection.setSenderVideoConstraints(e, n)
							}
							return Promise.resolve()
						}
						terminate(e, t, n) {
							if (this.state !== Ko) {
								if (!n || Boolean(n.sendSessionTerminate)) {
									const i = (0, vt.$iq)({
										to: this.remoteJid,
										type: "set"
									}).c("jingle", {
										xmlns: "urn:xmpp:jingle:1",
										action: "session-terminate",
										initiator: this.initiatorJid,
										sid: this.sid
									}).c("reason").c(n && n.reason || "success").up();
									n && n.reasonDescription ? i.c("text").t(n.reasonDescription).up().up() : i.up(), this._bridgeSessionId && i.c("bridge-session", {
										xmlns: "http://jitsi.org/protocol/focus",
										id: this._bridgeSessionId,
										restart: n && !0 === n.requestRestart
									}).up(), Qo.info(`${this} Sending session-terminate`), Qo.debug(i.tree()), this.connection.sendIQ(i, e, this.newJingleErrorHandler(i, t), Zo)
								} else Qo.info(`${this} Skipped sending session-terminate`);
								this.connection.jingle.terminate(this.sid)
							}
						}
						onTerminated(e, t) {
							Qo.info(`${this} Session terminated`, e, t), this._xmppListeners.forEach((e => e())), this._xmppListeners = [], this._removeSenderVideoConstraintsChangeListener && this._removeSenderVideoConstraintsChangeListener(), Ns.isSsrcRewritingSupported() && this.peerconnection && this.peerconnection.getRemoteTracks().forEach((e => {
								this.room.eventEmitter.emit(St.TRACK_REMOVED, e)
							})), this.close()
						}
						onXmppStatusChanged(e) {
							e === Qs.Status.CONNECTED && this._cachedOldLocalSdp && (Qo.info(`${this} Sending SSRC update on reconnect`), this.notifyMySSRCUpdate(this._cachedOldLocalSdp, this._cachedNewLocalSdp))
						}
						_parseSsrcInfoFromSourceAdd(e, t) {
							const n = [],
								i = this;
							return ft()(e).each(((e, s) => {
								const r = ft()(s).attr("name");
								let o = "";
								ft()(s).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
									const e = this.getAttribute("semantics"),
										t = ft()(this).find(">source").map((function() {
											return this.getAttribute("ssrc")
										})).get();
									t.length && (o += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
								})), ft()(s).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
									const e = ft()(this).attr("ssrc");
									t.containsSSRC(e) ? (!i.usesUnifiedPlan || !i.isP2P) && Qo.warn(`${i} Source-add request for existing SSRC: ${e}`) : ft()(this).find(">parameter").each((function() {
										o += `a=ssrc:${e} ${ft()(this).attr("name")}`, ft()(this).attr("value") && ft()(this).attr("value").length && (o += `:${ft()(this).attr("value")}`), o += "\r\n"
									}))
								}));
								let a = !1;
								t.media.forEach(((e, t) => {
									Yr.findLine(e, `a=mid:${r}`) && (n[t] || (n[t] = ""), n[t] += o, a = !0)
								})), !a && this.isP2P && (n[r] = o)
							})), n
						}
						addRemoteStream(e) {
							this._addOrRemoveRemoteStream(!0, e)
						}
						removeRemoteStream(e) {
							this._addOrRemoveRemoteStream(!1, e)
						}
						processSourceMap(e, t) {
							const n = [];
							for (const i of e.mappedSources)
								if (this.peerconnection.addRemoteSsrc(i.ssrc)) n.push(i);
								else {
									const {
										owner: e,
										source: n,
										ssrc: s,
										videoType: r
									} = i, o = this.peerconnection.getTrackBySSRC(s);
									if (o) {
										if (Qo.debug(`Existing SSRC ${s}: new owner=${e}, source-name=${n}`), this._signalingLayer.setSSRCOwner(s, e), o.setSourceName(n), o.setOwner(e), t === _i.VIDEO) {
											const e = "CAMERA" === r ? Ni.VideoType.CAMERA : Ni.VideoType.DESKTOP;
											o._setVideoType(e)
										}
									} else Qo.error(`Remote track attached to a remote SSRC=${s} not found`)
								} if (n.length) {
								let e = (0, vt.$build)("content", {
									xmlns: "urn:xmpp:jingle:1",
									name: t
								}).c("description", {
									xmlns: "urn:xmpp:jingle:apps:rtp:1",
									media: t
								});
								for (const i of n) {
									const {
										rtx: n,
										ssrc: s
									} = i;
									let r;
									if (t === _i.VIDEO) {
										const t = ++this.numRemoteVideoSources;
										r = `remote-video-${t} remote-video-${t}`, "-1" !== n && (ea(e, i, n, r), e.c("ssrc-group", {
											xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
											semantics: "FID"
										}).c("source", {
											xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
											ssrc: s
										}).up().c("source", {
											xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
											ssrc: n
										}).up().up())
									} else {
										const e = ++this.numRemoteAudioSources;
										r = `remote-audio-${e} remote-audio-${e}`
									}
									ea(e, i, s, r)
								}
								e = e.up(), this._addOrRemoveRemoteStream(!0, e.node)
							}
						}
						removeRemoteStreamsOnLeave(e) {
							Qo.debug(`${this} Queued removeRemoteStreamsOnLeave task for participant ${e}`), this.modificationQueue.push((t => {
								const n = this.peerconnection.getRemoteSourceInfoByParticipant(e);
								if (n.length) {
									const e = new Qr(this.peerconnection.localDescription.sdp),
										i = this._processRemoteRemoveSource(n);
									this._renegotiate(i.raw).then((() => {
										const n = new Qr(this.peerconnection.localDescription.sdp);
										this.notifyMySSRCUpdate(e, n), t()
									})).catch((e => t(e)))
								} else t()
							}), (e => {
								e ? Qo.error(`${this} removeRemoteStreamsOnLeave error:`, e) : Qo.info(`${this} removeRemoteStreamsOnLeave done!`)
							}))
						}
						_addOrRemoveRemoteStream(e, t) {
							const n = e ? "addRemoteStream" : "removeRemoteStream";
							e && this.readSsrcInfo(t), Qo.debug(`${this} Queued ${n} task`), this.modificationQueue.push((i => {
								if (!this.peerconnection.localDescription || !this.peerconnection.localDescription.sdp) {
									const e = `${n} - localDescription not ready yet`;
									return Qo.error(e), void i(e)
								}
								Qo.log(`${this} Processing ${n}`);
								const s = new Qr(this.peerconnection.localDescription.sdp),
									r = new Qr(this.peerconnection.remoteDescription.sdp),
									o = e ? this._parseSsrcInfoFromSourceAdd(t, r) : this._parseSsrcInfoFromSourceRemove(t, r),
									a = e ? this._processRemoteAddSource(o) : this._processRemoteRemoveSource(o),
									c = new RTCSessionDescription({
										type: "offer",
										sdp: a.raw
									});
								this._responderRenegotiate(c).then((() => {
									const e = new Qr(this.peerconnection.localDescription.sdp);
									Qo.log(`${this} ${n} - OK`), this.notifyMySSRCUpdate(s, e), i()
								}), (e => {
									Qo.error(`${this} ${n} failed:`, e), i(e)
								}))
							}))
						}
						_processNewJingleOfferIq(e) {
							const t = new Qr("");
							return this.webrtcIceTcpDisable && (t.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (t.removeUdpCandidates = !0), this.failICE && (t.failICE = !0), t.fromJingle(e), this.readSsrcInfo(ft()(e).find(">content")), t
						}
						_processRemoteRemoveSource(e) {
							var t;
							const n = this.usesUnifiedPlan ? new Qr(this.peerconnection.peerconnection.remoteDescription.sdp) : new Qr(this.peerconnection.remoteDescription.sdp);
							let i;
							return e.forEach(((e, t) => {
								if ((e = e.split("\r\n")).pop(), i = e.map((e => {
										var t;
										return Number(null === (t = e.split("a=ssrc:")[1]) || void 0 === t ? void 0 : t.split(" ")[0])
									})), this.usesUnifiedPlan) {
									let t;
									if (e.forEach((e => {
											if (t = n.media.findIndex((t => t.includes(e))), t > -1)
												if (n.media[t] = n.media[t].replace(`${e}\r\n`, ""), this.isP2P) {
													var i;
													const e = null === (i = Yr.parseMLine(n.media[t].split("\r\n")[0])) || void 0 === i ? void 0 : i.media,
														s = this.peerconnection.getDesiredMediaDirection(e, !1);
													[Br.SENDRECV, Br.SENDONLY].forEach((e => {
														n.media[t] = n.media[t].replace(`a=${e}`, `a=${s}`)
													}))
												} else n.media[t] = n.media[t].replace(`a=${Br.SENDONLY}`, `a=${Br.INACTIVE}`)
										})), t > -1 && !this.isP2P && Ns.isMultiStreamSendSupportEnabled()) {
										const {
											media: e,
											port: i
										} = Yr.parseMLine(n.media[t].split("\r\n")[0]);
										n.media[t] = n.media[t].replace(`m=${e} ${i}`, `m=${e} 0`)
									}
								} else e.forEach((e => {
									n.media[t] = n.media[t].replace(`${e}\r\n`, "")
								}))
							})), (null === (t = i) || void 0 === t ? void 0 : t.length) && this._signalingLayer.removeSSRCOwners(i), n.raw = n.session + n.media.join(""), n
						}
						_processRemoteAddSource(e) {
							let t = new Qr(this.peerconnection.remoteDescription.sdp);
							return e.length > t.media.length && this.isP2P && this.usesUnifiedPlan && (t.addMlineForNewLocalSource(_i.VIDEO), t = new Qr(t.raw)), e.forEach(((e, n) => {
								if (t.media[n] += e, this.isP2P && this.usesUnifiedPlan) {
									var i;
									const e = null === (i = Yr.parseMLine(t.media[n].split("\r\n")[0])) || void 0 === i ? void 0 : i.media,
										s = this.peerconnection.getDesiredMediaDirection(e, !0);
									[Br.RECVONLY, Br.INACTIVE].forEach((e => {
										t.media[n] = t.media[n].replace(`a=${e}`, `a=${s}`)
									}))
								}
							})), t.raw = t.session + t.media.join(""), t
						}
						_renegotiate(e) {
							if ("closed" === this.peerconnection.signalingState) {
								const e = new Error("Attempted to renegotiate in state closed");
								return this.room.eventEmitter.emit(ki.XMPPEvents.RENEGOTIATION_FAILED, e, this), Promise.reject(e)
							}
							const t = e || this.peerconnection.remoteDescription.sdp;
							if (!t) {
								const e = new Error(`Can not renegotiate without remote description, current state: ${this.state}`);
								return this.room.eventEmitter.emit(ki.XMPPEvents.RENEGOTIATION_FAILED, e, this), Promise.reject(e)
							}
							const n = new RTCSessionDescription({
								type: this.isInitiator ? "answer" : "offer",
								sdp: t
							});
							return this.isInitiator ? this._initiatorRenegotiate(n) : this._responderRenegotiate(n)
						}
						_responderRenegotiate(e) {
							return Qo.debug(`${this} Renegotiate: setting remote description`), this.peerconnection.setRemoteDescription(e).then((() => (Qo.debug(`${this} Renegotiate: creating answer`), this.peerconnection.createAnswer(this.mediaConstraints).then((e => (Qo.debug(`${this} Renegotiate: setting local description`), this.peerconnection.setLocalDescription(e)))))))
						}
						_initiatorRenegotiate(e) {
							return Qo.debug(`${this} Renegotiate: creating offer`), this.peerconnection.createOffer(this.mediaConstraints).then((t => (Qo.debug(`${this} Renegotiate: setting local description`), this.peerconnection.setLocalDescription(t).then((() => (Qo.debug(`${this} Renegotiate: setting remote description`), this.peerconnection.setRemoteDescription(e)))))))
						}
						addTracks() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
							if (!Ns.isMultiStreamSendSupportEnabled() || null == e || !e.length || e.find((e => e.getType() !== _i.VIDEO))) return Promise.reject(new Error("Multiple tracks of the given media type are not supported"));
							const t = [],
								n = n => {
									const i = new Qr(this.peerconnection.localDescription.sdp),
										s = new Qr(this.peerconnection.peerconnection.remoteDescription.sdp),
										r = this.peerconnection.peerconnection.getTransceivers().find((e => e.receiver.track.kind === _i.VIDEO && e.direction === Br.RECVONLY && e.currentDirection === Br.RECVONLY));
									for (const t of e) this.isP2P && r || s.addMlineForNewLocalSource(t.getType());
									const o = new RTCSessionDescription({
										type: "offer",
										sdp: s.raw
									});
									this._responderRenegotiate(o).then((() => {
										for (const n of e) t.push(this.peerconnection.replaceTrack(null, n));
										return Promise.all(t)
									})).then((() => this._renegotiate())).then((() => {
										const e = new Qr(this.peerconnection.localDescription.sdp);
										this.notifyMySSRCUpdate(i, e), n()
									})).catch((e => n(e)))
								};
							return new Promise(((e, t) => {
								Qo.debug(`${this} Queued renegotiation after addTrack`), this.modificationQueue.push(n, (n => {
									n ? (Qo.error(`${this} renegotiation after addTrack error`, n), t(n)) : (Qo.debug(`${this} renegotiation after addTrack executed - OK`), e())
								}))
							}))
						}
						replaceTrack(e, t) {
							const n = n => {
								Qo.debug(`${this} replaceTrack worker started. oldTrack = ${e}, newTrack = ${t}`);
								const i = this.peerconnection.localDescription.sdp;
								this.usesUnifiedPlan || (this.peerconnection.options.capScreenshareBitrate && e && t && t.isVideoTrack() && this.peerconnection.clearRecvonlySsrc(), !e && t && t.isVideoTrack() ? this.peerconnection.clearRecvonlySsrc() : e && e.isVideoTrack() && !t && (this.peerconnection.clearRecvonlySsrc(), this.peerconnection.generateRecvonlySsrc())), this.peerconnection.replaceTrack(e, t).then((n => {
									let s = Promise.resolve();
									if (Qo.debug(`${this} TPC.replaceTrack finished. shouldRenegotiate = ${n}, JingleSessionState = ${this.state}`), n && (e || t) && this.state === qo) {
										const e = this.peerconnection.remoteDescription.sdp,
											t = new RTCSessionDescription({
												type: "offer",
												sdp: e
											});
										s = this._responderRenegotiate(t).then((() => {
											const e = new Qr(this.peerconnection.localDescription.sdp);
											this.notifyMySSRCUpdate(new Qr(i), e)
										}))
									}
									return s.then((() => {
										if (e && t && e.isVideoTrack() && t.setSourceName(e.getSourceName()), null != t && t.isVideoTrack()) return Qo.debug(`${this} replaceTrack worker: configuring video stream`), this.peerconnection.configureSenderVideoEncodings(t)
									}))
								})).then((() => n()), (e => n(e)))
							};
							return new Promise(((i, s) => {
								Qo.debug(`${this} Queued replaceTrack task. Old track = ${e}, new track = ${t}`), this.modificationQueue.push(n, (e => {
									e ? (Qo.error(`${this} Replace track error:`, e), s(e)) : (Qo.info(`${this}  Replace track done!`), i())
								}))
							}))
						}
						_parseSsrcInfoFromSourceRemove(e, t) {
							const n = [];
							return ft()(e).each(((e, i) => {
								const s = ft()(i).attr("name");
								let r = "";
								ft()(i).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
									const e = this.getAttribute("semantics"),
										t = ft()(this).find(">source").map((function() {
											return this.getAttribute("ssrc")
										})).get();
									t.length && (r += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
								}));
								const o = [];
								ft()(i).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
									const e = ft()(this).attr("ssrc");
									o.push(e)
								})), t.media.forEach(((e, t) => {
									Yr.findLine(e, `a=mid:${s}`) && (n[t] || (n[t] = ""), o.forEach((i => {
										const s = Yr.findLines(e, `a=ssrc:${i}`);
										s.length && (n[t] += `${s.join("\r\n")}\r\n`)
									})), n[t] += r)
								}))
							})), n
						}
						_verifyNoSSRCChanged(e, t) {
							const n = new Qr(this.peerconnection.localDescription.sdp);
							let i = new eo(t, n);
							const s = i.getNewMedia();
							if (Object.keys(s).length) return Qo.error(`${this} - some SSRC were added on ${e}`, s), !1;
							i = new eo(n, t);
							const r = i.getNewMedia();
							return !Object.keys(r).length || (Qo.error(`${this} - some SSRCs were removed on ${e}`, r), !1)
						}
						addTrackToPc(e) {
							return this._addRemoveTrack(!1, e).then((() => {
								if (e.isVideoTrack()) return this.peerconnection.configureSenderVideoEncodings(e)
							}))
						}
						removeTrackFromPc(e) {
							return this._addRemoveTrack(!0, e)
						}
						_addRemoveTrack(e, t) {
							if (!t) return Promise.reject('invalid "track" argument value');
							const n = e ? "removeTrack" : "addTrack",
								i = i => {
									const s = this.peerconnection;
									if (!s) return void i(`Error:  tried ${n} track with no active peer connection`);
									const r = s.localDescription.sdp;
									(e ? s.removeTrackFromPc(t) : s.addTrackToPc(t)).then((e => {
										e && r && s.remoteDescription.sdp ? this._renegotiate().then((() => {
											!this.usesUnifiedPlan && this._verifyNoSSRCChanged(n, new Qr(r));
											const e = s.localDescription.sdp;
											this.notifyMySSRCUpdate(new Qr(r), new Qr(e)), i()
										})) : i()
									}), i)
								};
							return Qo.debug(`${this} Queued ${n} task`), new Promise(((e, t) => {
								this.modificationQueue.push(i, (i => {
									i ? (Qo.error(`${this} ${n} failed`), t(i)) : (Qo.debug(`${this} ${n} done`), e())
								}))
							}))
						}
						setMediaTransferActive(e, t) {
							if (!this.peerconnection) return Promise.reject('Can not modify transfer active state, before "initialize" is called');
							const n = e ? "audio active" : "audio inactive",
								i = t ? "video active" : "video inactive";
							Qo.info(`${this} Queued make ${i}, ${n} task`);
							const s = n => {
								const i = this.state === qo,
									s = this.peerconnection.setAudioTransferActive(e);
								this._localVideoActive !== t && (this._localVideoActive = t, this.isP2P && i && this.sendContentModify());
								const r = this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive);
								i && (s || r) ? this._renegotiate().then(n, n) : n()
							};
							return new Promise(((e, t) => {
								this.modificationQueue.push(s, (s => {
									s ? (Qo.error(`${this} Make ${i}, ${n} task failed!`), t(s)) : (Qo.debug(`${this} Make ${i}, ${n} task done!`), e())
								}))
							}))
						}
						modifyContents(e) {
							const t = ta.parseVideoSenders(e),
								n = ta.parseSourceMaxFrameHeight(e);
							n && (this.remoteSourceMaxFrameHeights = n, this.eventEmitter.emit(Yo.REMOTE_SOURCE_CONSTRAINTS_CHANGED, this, n)), null !== t ? (Qo.debug(`${this} queued "content-modify" task(video senders="${t}")`), this.modificationQueue.push((e => {
								this._assertNotEnded() && this._modifyRemoteVideoActive(t) ? this._renegotiate().then(e, e) : e()
							}), (e => {
								e ? Qo.error(`${this} "content-modify" failed`, e) : Qo.debug(`${this} "content-modify" task(video senders="${t}") done`)
							}))) : Qo.error(`${this} - failed to parse video "senders" attribute in "content-modify" action`)
						}
						_modifyRemoteVideoActive(e) {
							const t = "both" === e || "initiator" === e && this.isInitiator || "responder" === e && !this.isInitiator;
							return t !== this._remoteVideoActive && (Qo.debug(`${this} new remote video active: ${t}`), this._remoteVideoActive = t), this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive)
						}
						notifyMySSRCUpdate(e, t) {
							if (this.state !== qo) return void Qo.warn(`${this} Skipping SSRC update in '${this.state} ' state.`);
							if (!this.connection.connected) return this._cachedOldLocalSdp || (this._cachedOldLocalSdp = e), this._cachedNewLocalSdp = t, void Qo.warn(`${this} Not sending SSRC update while the signaling is disconnected`);
							this._cachedOldLocalSdp = void 0, this._cachedNewLocalSdp = void 0;
							const n = e => {
								const t = e.getNewMedia();
								let n = [],
									i = null;
								return Object.keys(t).forEach((e => {
									const s = Object.keys(t[e].ssrcs);
									i = t[e].mid, null != s && s.length && (n = n.concat(s))
								})), {
									mediaType: i,
									ssrcs: n
								}
							};
							let i = new eo(t, e);
							const s = (0, vt.$iq)({
								to: this.remoteJid,
								type: "set"
							}).c("jingle", {
								xmlns: "urn:xmpp:jingle:1",
								action: "source-remove",
								initiator: this.initiatorJid,
								sid: this.sid
							});
							i.toJingle(s);
							const r = {},
								o = n(i);
							o.ssrcs.length && (Qo.info(`${this} Sending source-remove for ${o.mediaType} ssrcs=${o.ssrcs}`), this.connection.sendIQ(s, (() => {
								this.room.eventEmitter.emit(ki.XMPPEvents.SOURCE_REMOVE, this, r)
							}), this.newJingleErrorHandler(s, (e => {
								this.room.eventEmitter.emit(ki.XMPPEvents.SOURCE_REMOVE_ERROR, this, e, r)
							})), Zo)), i = new eo(e, t);
							const a = (0, vt.$iq)({
								to: this.remoteJid,
								type: "set"
							}).c("jingle", {
								xmlns: "urn:xmpp:jingle:1",
								action: "source-add",
								initiator: this.initiatorJid,
								sid: this.sid
							});
							i.toJingle(a);
							const c = n(i);
							c.ssrcs.length && (Qo.info(`${this} Sending source-add for ${c.mediaType} ssrcs=${c.ssrcs}`), this.connection.sendIQ(a, (() => {
								this.room.eventEmitter.emit(ki.XMPPEvents.SOURCE_ADD, this, r)
							}), this.newJingleErrorHandler(a, (e => {
								this.room.eventEmitter.emit(ki.XMPPEvents.SOURCE_ADD_ERROR, this, e, c.mediaType, r)
							})), Zo))
						}
						newJingleErrorHandler(e, t) {
							return e => {
								const n = {},
									i = ft()(e).find("error");
								if (i.length) {
									n.code = i.attr("code");
									const t = ft()(e).find("error :first");
									t.length && (n.reason = t[0].tagName);
									const s = i.find(">text");
									s.length && (n.msg = s.text())
								}
								e || (n.reason = "timeout"), n.session = this.toString(), t ? t(n) : this.state === Ko && "item-not-found" === n.reason ? Qo.debug(`${this} Jingle error: ${JSON.stringify(n)}`) : ei().callErrorHandler(new Error(`Jingle error: ${JSON.stringify(n)}`))
							}
						}
						getIceConnectionState() {
							return this.peerconnection.getConnectionState()
						}
						close() {
							this.state = Ko, this.establishmentDuration = void 0, this.peerconnection && (this.peerconnection.onicecandidate = null, this.peerconnection.oniceconnectionstatechange = null, this.peerconnection.onnegotiationneeded = null, this.peerconnection.onsignalingstatechange = null), Qo.debug(`${this} Clearing modificationQueue`), this.modificationQueue.clear(), Qo.debug(`${this} Queued PC close task`), this.modificationQueue.push((e => {
								this.peerconnection && this.peerconnection.close(), e(), Qo.debug(`${this} PC close task done!`)
							})), Qo.debug(`${this} Shutdown modificationQueue!`), this.modificationQueue.shutdown()
						}
						toString() {
							return `JingleSessionPC[session=${this.isP2P?"P2P":"JVB"},initiator=${this.isInitiator},sid=${this.sid}]`
						}
						_abtestSuspendVideoEnabled(e) {
							let {
								abTesting: t
							} = e;
							if (t && t.enableSuspendVideoTest) return (0, $o.integerHash)(this.initiatorJid) % 2 == 0
						}
					}
					const na = (0, S.getLogger)("modules/xmpp/strophe.jingle.js");

					function ia(e) {
						const t = ft()(e).find(">candidate"),
							n = [];
						return t.each(((e, t) => {
							const i = t.attributes,
								s = [];
							for (let e = 0; e < i.length; e++) {
								const t = i[e];
								s.push(`${t.name}: ${t.value}`)
							}
							n.push(s.join(" "))
						})), n
					}
					class sa extends Ks {
						constructor(e, t, n) {
							super(), this.xmpp = e, this.eventEmitter = t, this.sessions = {}, this.jvbIceConfig = n.jvb, this.p2pIceConfig = n.p2p, this.mediaConstraints = {
								offerToReceiveAudio: !0,
								offerToReceiveVideo: !0
							}
						}
						init(e) {
							super.init(e), this.connection.addHandler(this.onJingle.bind(this), "urn:xmpp:jingle:1", "iq", "set", null, null)
						}
						onJingle(e) {
							const t = ft()(e).find("jingle").attr("sid"),
								n = ft()(e).find("jingle").attr("action"),
								i = e.getAttribute("from"),
								s = (0, vt.$iq)({
									type: "result",
									to: i,
									id: e.getAttribute("id")
								});
							let r = this.sessions[t];
							if ("session-initiate" !== n) {
								if (!r) return s.attrs({
									type: "error"
								}), s.c("error", {
									type: "cancel"
								}).c("item-not-found", {
									xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
								}).up().c("unknown-session", {
									xmlns: "urn:xmpp:jingle:errors:1"
								}), na.warn(`invalid session id: ${t}`), na.debug(e), this.connection.send(s), !0;
								if (i !== r.remoteJid) return na.warn("jid mismatch for session id", t, r.remoteJid, e), s.attrs({
									type: "error"
								}), s.c("error", {
									type: "cancel"
								}).c("item-not-found", {
									xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
								}).up().c("unknown-session", {
									xmlns: "urn:xmpp:jingle:errors:1"
								}), this.connection.send(s), !0
							} else if (void 0 !== r) return s.attrs({
								type: "error"
							}), s.c("error", {
								type: "cancel"
							}).c("service-unavailable", {
								xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
							}).up(), na.warn("duplicate session id", t, e), this.connection.send(s), !0;
							const o = window.performance.now(),
								a = "focus" !== vt.Strophe.getResourceFromJid(i),
								c = ft()(e).find("jingle>json-message");
							if (null != c && c.length) {
								var d;
								let t;
								na.info(`Found a JSON-encoded element in ${n}, translating to standard Jingle.`);
								for (let n = 0; n < c.length; n++) t = Ur(e, c[n]);
								if (null !== (d = t) && void 0 !== d && d.size) {
									const e = [];
									for (const n of t.keys()) e.push(`${n}:[${t.get(n)}]`);
									na.debug(`Received ${n} from ${i} with sources=${e.join(", ")}`)
								}
							}
							switch (n) {
								case "session-initiate": {
									na.log("(TIME) received session-initiate:\t", o);
									const t = ft()(e).find("jingle>startmuted");
									if (a && na.debug(`Received ${n} from ${i}`), null != t && t.length) {
										const e = t.attr(_i.AUDIO),
											n = t.attr(_i.VIDEO);
										this.eventEmitter.emit(ki.XMPPEvents.START_MUTED_FROM_FOCUS, "true" === e, "true" === n)
									}
									const s = a ? this.p2pIceConfig : this.jvbIceConfig;
									r = new ta(ft()(e).find("jingle").attr("sid"), ft()(e).attr("to"), i, this.connection, this.mediaConstraints, JSON.parse(JSON.stringify(s)), a, !1), this.sessions[r.sid] = r, this.eventEmitter.emit(ki.XMPPEvents.CALL_INCOMING, r, ft()(e).find(">jingle"), o);
									break
								}
								case "session-accept": {
									const t = [],
										s = ft()(e).find("jingle>content");
									for (const e of s) {
										const n = ft()(e).find("description").attr("ssrc");
										n && t.push(n)
									}
									na.debug(`Received ${n} from ${i} with ssrcs=${t}`), this.eventEmitter.emit(ki.XMPPEvents.CALL_ACCEPTED, r, ft()(e).find(">jingle"));
									break
								}
								case "content-modify":
									na.debug(`Received ${n} from ${i}`), r.modifyContents(ft()(e).find(">jingle"));
									break;
								case "transport-info": {
									const t = ia(ft()(e).find("jingle>content>transport"));
									na.debug(`Received ${n} from ${i} for candidates=${t.join(", ")}`), this.eventEmitter.emit(ki.XMPPEvents.TRANSPORT_INFO, r, ft()(e).find(">jingle"));
									break
								}
								case "session-terminate": {
									na.log("terminating...", r.sid);
									let t = null,
										s = null;
									ft()(e).find(">jingle>reason").length && (t = ft()(e).find(">jingle>reason>:first")[0].tagName, s = ft()(e).find(">jingle>reason>text").text()), na.debug(`Received ${n} from ${i} disconnect reason=${s}`), this.terminate(r.sid, t, s), this.eventEmitter.emit(ki.XMPPEvents.CALL_ENDED, r, t, s);
									break
								}
								case "transport-replace": {
									var l;
									na.info("(TIME) Start transport replace:\t", o);
									const t = ft()(e).find("jingle>content>transport"),
										s = ia(t),
										c = ft()(t).attr("ufrag"),
										d = ft()(t).attr("pwd"),
										u = null === (l = ft()(t).find(">fingerprint")) || void 0 === l ? void 0 : l.text();
									na.debug(`Received ${n} from ${i} with iceUfrag=${c}, icePwd=${d}, DTLS fingerprint=${u}, candidates=${s.join(", ")}`), Pi.sendAnalytics(yn(sn, {
										p2p: a,
										value: o
									})), r.replaceTransport(ft()(e).find(">jingle"), (() => {
										const e = window.performance.now();
										na.info("(TIME) Transport replace success:\t", e), Pi.sendAnalytics(yn(rn, {
											p2p: a,
											value: e
										}))
									}), (e => {
										ei().callErrorHandler(e), na.error("Transport replace failed", e), r.sendTransportReject()
									}));
									break
								}
								case "source-add":
									r.addRemoteStream(ft()(e).find(">jingle>content"));
									break;
								case "source-remove":
									r.removeRemoteStream(ft()(e).find(">jingle>content"));
									break;
								default:
									na.warn("jingle action not implemented", n), s.attrs({
										type: "error"
									}), s.c("error", {
										type: "cancel"
									}).c("bad-request", {
										xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
									}).up()
							}
							return this.connection.send(s), !0
						}
						newP2PJingleSession(e, t) {
							const n = new ta(Ls().randomHexString(12), e, t, this.connection, this.mediaConstraints, this.p2pIceConfig, !0, !0);
							return this.sessions[n.sid] = n, n
						}
						terminate(e, t, n) {
							this.sessions.hasOwnProperty(e) && ("ended" !== this.sessions[e].state && this.sessions[e].onTerminated(t, n), delete this.sessions[e])
						}
						getStunAndTurnCredentials() {
							this.connection.sendIQ((0, vt.$iq)({
								type: "get",
								to: this.xmpp.options.hosts.domain
							}).c("services", {
								xmlns: "urn:xmpp:extdisco:2"
							}), (e => this.onReceiveStunAndTurnCredentials(e)), (() => {
								na.warn("getting turn credentials with extdisco:2 failed, trying extdisco:1"), this.connection.sendIQ((0, vt.$iq)({
									type: "get",
									to: this.xmpp.options.hosts.domain
								}).c("services", {
									xmlns: "urn:xmpp:extdisco:1"
								}), (e => this.onReceiveStunAndTurnCredentials(e)), (() => {
									na.warn("getting turn credentials failed"), na.warn("is mod_turncredentials or similar installed and configured?")
								}))
							}))
						}
						onReceiveStunAndTurnCredentials(e) {
							const t = [];
							ft()(e).find(">services>service").each(((e, n) => {
								const i = {},
									s = (n = ft()(n)).attr("type");
								switch (s) {
									case "stun":
										i.urls = `stun:${n.attr("host")}`, n.attr("port") && (i.urls += `:${n.attr("port")}`), t.push(i);
										break;
									case "turn":
									case "turns": {
										i.urls = `${s}:`, i.username = n.attr("username"), i.urls += n.attr("host"), n.attr("port") && (i.urls += `:${n.attr("port")}`);
										const e = n.attr("transport");
										e && "udp" !== e && (i.urls += `?transport=${e}`), i.credential = n.attr("password") || i.credential, t.push(i);
										break
									}
								}
							}));
							const n = this.xmpp.options;
							for (let e = t.length - 1; e > 0; e--) {
								const n = Math.floor(Math.random() * (e + 1)),
									i = t[e];
								t[e] = t[n], t[n] = i
							}
							let i;
							return i = n.useTurnUdp ? e => e.urls.startsWith("turn") : e => e.urls.startsWith("turn") && e.urls.indexOf("transport=tcp") >= 0, this.jvbIceConfig.iceServers = t.filter(i), this.p2pIceConfig.iceServers = t, t.length > 0
						}
						getLog() {
							const e = {};
							return Object.keys(this.sessions).forEach((t => {
								const n = this.sessions[t].peerconnection;
								n && n.updateLog && (e[`jingle_${t}`] = {
									updateLog: n.updateLog,
									stats: n.stats,
									url: window.location.href
								})
							})), e
						}
					}
					class ra extends Ks {
						constructor() {
							super(), this.log = []
						}
						init(e) {
							super.init(e), this.connection.rawInput = this.logIncoming.bind(this), this.connection.rawOutput = this.logOutgoing.bind(this)
						}
						logIncoming(e) {
							this.log.push([(new Date).getTime(), "incoming", e])
						}
						logOutgoing(e) {
							this.log.push([(new Date).getTime(), "outgoing", e])
						}
					}
					const oa = (0, S.getLogger)("modules/xmpp/strophe.rayo.js"),
						aa = "urn:xmpp:rayo:1";
					class ca extends Ks {
						init(e) {
							super.init(e), this.connection.addHandler(this.onRayo.bind(this), aa, "iq", "set", null, null)
						}
						onRayo(e) {
							oa.info("Rayo IQ", e)
						}
						dial(e, t, n, i, s) {
							return new Promise(((r, o) => {
								if (!s) return void o(new Error("Internal error!"));
								const a = (0, vt.$iq)({
									type: "set",
									to: s
								});
								a.c("dial", {
									xmlns: aa,
									to: e,
									from: t
								}), a.c("header", {
									name: "JvbRoomName",
									value: n
								}).up(), i && i.length && a.c("header", {
									name: "JvbRoomPassword",
									value: i
								}).up(), this.connection.sendIQ(a, (e => {
									oa.info("Dial result ", e);
									const t = ft()(e).find("ref").attr("uri");
									this.callResource = t.substr("xmpp:".length), oa.info(`Received call resource: ${this.callResource}`), r()
								}), (e => {
									oa.info("Dial error ", e), o(e)
								}))
							}))
						}
						hangup() {
							return new Promise(((e, t) => {
								if (!this.callResource) return t(new Error("No call in progress")), void oa.warn("No call in progress");
								const n = (0, vt.$iq)({
									type: "set",
									to: this.callResource
								});
								n.c("hangup", {
									xmlns: aa
								}), this.connection.sendIQ(n, (t => {
									oa.info("Hangup result ", t), this.callResource = null, e()
								}), (e => {
									oa.info("Hangup error ", e), this.callResource = null, t(new Error("Hangup error "))
								}))
							}))
						}
					}
					const da = (0, S.getLogger)("modules/xmpp/strophe.util.js");
					let la = -1;
					const ua = /request id \d+.\d+ got 200/,
						ha = /request errored, status: (\d+), number of errors: \d+/,
						pa = (0, S.getLogger)("modules/xmpp/xmpp.js"),
						ma = /<failure.*><not-allowed\/><text>(.*)<\/text><\/failure>/gi;
					const fa = [{
							urls: "stun:meet-jit-si-turnrelay.jitsi.net:443"
						}],
						ga = "type",
						_a = "http://jitsi.org/protocol/jigasi",
						va = "https://jitsi.org/meet/e2ee";
					class Sa extends Yi {
						constructor(e, t) {
							super(), this.connection = null, this.disconnectInProgress = !1, this.connectionTimes = {}, this.options = e, this.token = t, this.authenticatedUser = !1, this.options.deploymentInfo || (this.options.deploymentInfo = {}), this._components = [], vt.Strophe.log = function(e, t) {
								switch (da.trace("Strophe", e, t), "string" == typeof t && -1 !== t.indexOf("Request ") && -1 !== t.indexOf("timed out (secondary), restarting") && (e = vt.Strophe.LogLevel.WARN), e) {
									case vt.Strophe.LogLevel.DEBUG:
										-1 !== la && ua.test(t) && (da.debug("Reset lastErrorStatus"), la = -1);
										break;
									case vt.Strophe.LogLevel.WARN:
										da.warn(`Strophe: ${t}`);
										const e = ha.exec(t);
										e && 2 === e.length && (la = parseInt(e[1], 10), da.debug(`lastErrorStatus set to: ${la}`));
										break;
									case vt.Strophe.LogLevel.ERROR:
									case vt.Strophe.LogLevel.FATAL:
										t = `Strophe: ${t}`, ei().callErrorHandler(new Error(t)), da.error(t)
								}
							}, vt.Strophe.getLastErrorStatus = function() {
								return la
							}, vt.Strophe.getStatusString = function(e) {
								switch (e) {
									case vt.Strophe.Status.BINDREQUIRED:
										return "BINDREQUIRED";
									case vt.Strophe.Status.ERROR:
										return "ERROR";
									case vt.Strophe.Status.CONNECTING:
										return "CONNECTING";
									case vt.Strophe.Status.CONNFAIL:
										return "CONNFAIL";
									case vt.Strophe.Status.AUTHENTICATING:
										return "AUTHENTICATING";
									case vt.Strophe.Status.AUTHFAIL:
										return "AUTHFAIL";
									case vt.Strophe.Status.CONNECTED:
										return "CONNECTED";
									case vt.Strophe.Status.DISCONNECTED:
										return "DISCONNECTED";
									case vt.Strophe.Status.DISCONNECTING:
										return "DISCONNECTING";
									case vt.Strophe.Status.ATTACHED:
										return "ATTACHED";
									default:
										return "unknown"
								}
							}, vt.Strophe.addConnectionPlugin("logger", new ra);
							const n = e.xmppPing || {};
							n.domain = e.hosts.domain, this.connection = function(e) {
								let {
									enableWebsocketResume: t,
									serviceUrl: n = "/http-bind",
									shard: i,
									token: s,
									websocketKeepAlive: r,
									websocketKeepAliveUrl: o,
									xmppPing: a
								} = e;
								return s && (n += `${-1===n.indexOf("?")?"?":"&"}token=${s}`), new Qs({
									enableWebsocketResume: t,
									serviceUrl: n,
									websocketKeepAlive: r,
									websocketKeepAliveUrl: o,
									xmppPing: a,
									shard: i
								})
							}({
								enableWebsocketResume: e.enableWebsocketResume,
								serviceUrl: e.serviceUrl || e.bosh,
								token: t,
								websocketKeepAlive: e.websocketKeepAlive,
								websocketKeepAliveUrl: e.websocketKeepAliveUrl,
								xmppPing: n,
								shard: e.deploymentInfo.shard
							}), this.connection.on(Qs.Events.CONN_SHARD_CHANGED, (() => {
								const e = {
									shard_changed: !0,
									suspend_time: this.connection.ping.getPingSuspendTime(),
									time_since_last_success: this.connection.getTimeSinceLastSuccess()
								};
								this.eventEmitter.emit(Bi, Ki, void 0, void 0, e)
							})), this._initStrophePlugins(), this.caps = new Us(this.connection, "https://jitsi.org/jitsi-meet"), this.initFeaturesList(), ft()(window).on((this.options.disableBeforeUnloadHandlers ? "" : "beforeunload ") + "unload", (e => {
								this.disconnect(e).catch((() => {}))
							}))
						}
						initFeaturesList() {
							this.caps.addFeature("urn:xmpp:jingle:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:1"), this.caps.addFeature("urn:xmpp:jingle:transports:ice-udp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:dtls:0"), this.caps.addFeature("urn:xmpp:jingle:transports:dtls-sctp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:audio"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:video"), this.caps.addFeature("http://jitsi.org/json-encoded-sources"), !this.options.disableRtx && Wn.supportsRTX() && this.caps.addFeature("urn:ietf:rfc:4588"), !0 === this.options.enableOpusRed && Wn.supportsAudioRed() && this.caps.addFeature("http://jitsi.org/opus-red"), (void 0 === this.options.enableRemb || this.options.enableRemb) && this.caps.addFeature("http://jitsi.org/remb"), Wn.isFirefox() || void 0 !== this.options.enableTcc && !this.options.enableTcc || this.caps.addFeature("http://jitsi.org/tcc"), Wn.isChromiumBased() && !0 === this.options.enableLipSync && (pa.info("Lip-sync enabled !"), this.caps.addFeature("http://jitsi.org/meet/lipsync")), this.connection.rayo && this.caps.addFeature("urn:xmpp:rayo:client:1"), Os.isSupported(this.options) && this.caps.addFeature(va, !1, !0), pa.debug("Source-name signaling is enabled"), this.caps.addFeature("http://jitsi.org/source-name"), pa.debug("Receiving multiple video streams is enabled"), this.caps.addFeature("http://jitsi.org/receive-multiple-video-streams"), Ns.isSsrcRewritingSupported() && this.caps.addFeature("http://jitsi.org/ssrc-rewriting-1")
						}
						getConnection() {
							return this.connection
						}
						connectionHandler() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
								t = arguments.length > 1 ? arguments[1] : void 0,
								n = arguments.length > 2 ? arguments[2] : void 0;
							const i = window.performance.now(),
								s = vt.Strophe.getStatusString(t).toLowerCase();
							if (this.connectionTimes[s] = i, pa.log(`(TIME) Strophe ${s}${n?`[${n}]`:""}:\t`, i), this.eventEmitter.emit(ki.XMPPEvents.CONNECTION_STATUS_CHANGED, e, t, n), this._maybeSendDeploymentInfoStat(), t === vt.Strophe.Status.CONNECTED || t === vt.Strophe.Status.ATTACHED) this._sysMessageHandler && (this.connection._stropheConn.deleteHandler(this._sysMessageHandler), this._sysMessageHandler = null), this.sendDiscoInfo && this.connection.jingle.getStunAndTurnCredentials(), pa.info(`My Jabber ID: ${this.connection.jid}`), this._resetState(), this.sendDeploymentInfo = !1, this.sendDiscoInfo && this.caps.getFeaturesAndIdentities(this.options.hosts.domain).then((e => {
								let {
									features: t,
									identities: n
								} = e;
								t.has(vt.Strophe.NS.PING) || pa.error(`Ping NOT supported by ${this.options.hosts.domain} - please enable ping in your XMPP server config`), this._processDiscoInfoIdentities(n, void 0)
							})).catch((e => {
								const t = "Feature discovery error";
								ei().callErrorHandler(new Error(`${t}: ${e}`)), pa.error(t, e), this._maybeSendDeploymentInfoStat(!0)
							})), this.sendDiscoInfo = !1, e.password && (this.authenticatedUser = !0), this.connection && this.connection.connected && vt.Strophe.getResourceFromJid(this.connection.jid) && this.eventEmitter.emit(Hi, vt.Strophe.getResourceFromJid(this.connection.jid));
							else if (t === vt.Strophe.Status.CONNFAIL) "x-strophe-bad-non-anon-jid" === n ? this.anonymousConnectionFailed = !0 : this.connectionFailed = !0, this.lastErrorMsg = n, "giving-up" === n && this.eventEmitter.emit(Bi, Ki, n);
							else if (t === vt.Strophe.Status.ERROR) this.lastErrorMsg = n;
							else if (t === vt.Strophe.Status.DISCONNECTED) {
								this.connection.ping.stopInterval();
								const e = Boolean(this.disconnectInProgress),
									t = n || this.lastErrorMsg;
								if (this.anonymousConnectionFailed) this.eventEmitter.emit(Bi, Wi);
								else if (this.connectionFailed) this.eventEmitter.emit(Bi, Ki, t, void 0, this._getConnectionFailedReasonDetails());
								else if (e) this.eventEmitter.emit(ji, t);
								else {
									pa.error("XMPP connection dropped!");
									const e = vt.Strophe.getLastErrorStatus();
									e >= 500 && e < 600 ? this.eventEmitter.emit(Bi, Xi, t || "server-error", void 0, this._getConnectionFailedReasonDetails()) : this.eventEmitter.emit(Bi, qi, t || "connection-dropped-error", void 0, this._getConnectionFailedReasonDetails())
								}
							} else if (t === vt.Strophe.Status.AUTHFAIL) {
								const t = this.getConnection().getLastFailedMessage();
								this.eventEmitter.emit(Bi, Wi, n || this._parseConnectionFailedMessage(t), e)
							}
						}
						_processDiscoInfoIdentities(e, t) {
							e.forEach((e => {
								if ("av_moderation" === e.type && (this.avModerationComponentAddress = e.name, this._components.push(this.avModerationComponentAddress)), "end_conference" === e.type && (this.endConferenceComponentAddress = e.name, this._components.push(this.endConferenceComponentAddress)), "speakerstats" === e.type && (this.speakerStatsComponentAddress = e.name, this._components.push(this.speakerStatsComponentAddress)), "conference_duration" === e.type && (this.conferenceDurationComponentAddress = e.name, this._components.push(this.conferenceDurationComponentAddress)), "lobbyrooms" === e.type) {
									this.lobbySupported = !0;
									const n = e => {
										e.forEach((e => {
											e.endsWith("#displayname_required") && this.eventEmitter.emit(Ji)
										}))
									};
									t ? n(t) : e.name && this.caps.getFeaturesAndIdentities(e.name, e.type).then((e => {
										let {
											features: t
										} = e;
										return n(t)
									})).catch((e => pa.warn("Error getting features from lobby.", e && e.message)))
								}
								"shard" === e.type && (this.options.deploymentInfo.shard = this.connection.shard = e.name), "region" === e.type && (this.options.deploymentInfo.region = this.connection.region = e.name), "release" === e.type && (this.options.deploymentInfo.backendRelease = e.name), "breakout_rooms" === e.type && (this.breakoutRoomsComponentAddress = e.name, this._components.push(this.breakoutRoomsComponentAddress)), "room_metadata" === e.type && (this.roomMetadataComponentAddress = e.name, this._components.push(this.roomMetadataComponentAddress))
							})), this._maybeSendDeploymentInfoStat(!0), this._components.length > 0 && this.connection.addHandler(this._onPrivateMessage.bind(this), null, "message", null, null)
						}
						_parseConnectionFailedMessage(e) {
							if (!e) return null;
							const t = ma.exec(e);
							return t ? t[1] : null
						}
						_connect(e, t) {
							this._resetState(), this.sendDiscoInfo = !0, this.sendDeploymentInfo = !0, this.connection._stropheConn && this.connection._stropheConn._addSysHandler ? this._sysMessageHandler = this.connection._stropheConn._addSysHandler(this._onSystemMessage.bind(this), null, "message") : pa.warn("Cannot attach strophe system handler, jiconop cannot operate"), this.connection.connect(e, t, this.connectionHandler.bind(this, {
								jid: e,
								password: t
							}))
						}
						_onSystemMessage(e) {
							if (0 === ft()(e).find(">services").length && 0 === ft()(e).find(">query").length) return;
							this.sendDiscoInfo = !1;
							const t = this.connection.jingle.onReceiveStunAndTurnCredentials(e),
								{
									features: n,
									identities: i
								} = Vs(e);
							this._processDiscoInfoIdentities(i, n), (t || i.size > 0 || n.size > 0) && (this.connection._stropheConn.deleteHandler(this._sysMessageHandler), this._sysMessageHandler = null)
						}
						attach(e) {
							this._resetState(), this.sendDiscoInfo = !0;
							const t = this.connectionTimes.attaching = window.performance.now();
							pa.log("(TIME) Strophe Attaching:\t", t), this.connection.attach(e.jid, e.sid, parseInt(e.rid, 10) + 1, this.connectionHandler.bind(this, {
								jid: e.jid,
								password: e.password
							}))
						}
						_resetState() {
							this.anonymousConnectionFailed = !1, this.connectionFailed = !1, this.lastErrorMsg = void 0, this.disconnectInProgress = void 0
						}
						connect(e, t) {
							if (!e) {
								const {
									anonymousdomain: t,
									domain: n
								} = this.options.hosts;
								let i = t || n;
								const {
									location: s
								} = window;
								if (t) {
									const e = s && s.search;
									(e && -1 !== e.indexOf("login=true") || this.token) && (i = n)
								}
								e = i || s && s.hostname
							}
							return this._connect(e, t)
						}
						createRoom(e, t, n) {
							const i = e.domain || t.customDomain;
							let s = `${this.getRoomJid(e,i)}/`;
							const r = n ? n(this.connection.jid, this.authenticatedUser) : Ls().randomHexString(8).toLowerCase();
							return pa.info(`JID ${this.connection.jid} using MUC nickname ${r}`), s += r, this.connection.emuc.createRoom(s, null, t)
						}
						getRoomJid(e, t) {
							return `${e}@${t||this.options.hosts.muc.toLowerCase()}`
						}
						isRoomCreated(e, t) {
							return this.connection.emuc.isRoomCreated(this.getRoomJid(e, t))
						}
						getJid() {
							return this.connection.jid
						}
						getJingleLog() {
							const e = this.connection.jingle;
							return e ? e.getLog() : {}
						}
						getXmppLog() {
							return (this.connection.logger || {}).log || null
						}
						dial() {
							this.connection.rayo.dial(...arguments)
						}
						ping(e) {
							return new Promise(((t, n) => {
								this.connection.ping.ping(this.connection.pingDomain, t, n, e)
							}))
						}
						getSessions() {
							return this.connection.jingle.sessions
						}
						disconnect(e) {
							return this.disconnectInProgress ? this.disconnectInProgress : this.connection ? (this.disconnectInProgress = new Promise((e => {
								const t = (n, i) => {
									i === vt.Strophe.Status.DISCONNECTED && (e(), this.eventEmitter.removeListener(ki.XMPPEvents.CONNECTION_STATUS_CHANGED, t))
								};
								this.eventEmitter.on(ki.XMPPEvents.CONNECTION_STATUS_CHANGED, t)
							})), this._cleanupXmppConnection(e), this.disconnectInProgress) : Promise.resolve()
						}
						_cleanupXmppConnection(e) {
							if (!this.connection.isUsingWebSocket && this.connection.flush(), !this.connection.isUsingWebSocket && null != e) {
								const t = e.type;
								if (("beforeunload" === t || "unload" === t) && (this.connection.options.sync = !0, this.connection.sendUnavailableBeacon())) return
							}
							this.connection.disconnect(), !0 !== this.connection.options.sync && this.connection.flush()
						}
						_initStrophePlugins() {
							const e = {
									jvb: {
										iceServers: []
									},
									p2p: {
										iceServers: []
									}
								},
								t = this.options.p2p && this.options.p2p.stunServers || fa;
							Array.isArray(t) && (pa.info("P2P STUN servers: ", t), e.p2p.iceServers = t), this.options.p2p && this.options.p2p.iceTransportPolicy && (pa.info("P2P ICE transport policy: ", this.options.p2p.iceTransportPolicy), e.p2p.iceTransportPolicy = this.options.p2p.iceTransportPolicy), this.connection.addConnectionPlugin("emuc", new Lr(this)), this.connection.addConnectionPlugin("jingle", new sa(this, this.eventEmitter, e)), this.connection.addConnectionPlugin("rayo", new ca)
						}
						_getConnectionFailedReasonDetails() {
							const e = {};
							if (this.options.deploymentInfo && this.options.deploymentInfo.shard && this.connection.lastResponseHeaders) {
								const t = this.connection.lastResponseHeaders.trim().split(/[\r\n]+/),
									n = {};
								t.forEach((e => {
									const t = e.split(": "),
										i = t.shift(),
										s = t.join(": ");
									n[i] = s
								})), e.shard_changed = this.options.deploymentInfo.shard !== n["x-jitsi-shard"]
							}
							return e.suspend_time = this.connection.ping.getPingSuspendTime(), e.time_since_last_success = this.connection.getTimeSinceLastSuccess(), e
						}
						sendDominantSpeakerEvent(e, t) {
							if (!this.speakerStatsComponentAddress || !e) return;
							const n = (0, vt.$msg)({
								to: this.speakerStatsComponentAddress
							});
							n.c("speakerstats", {
								xmlns: "http://jitsi.org/jitmeet",
								room: e,
								silence: t
							}).up(), this.connection.send(n)
						}
						sendFaceLandmarksEvent(e, t) {
							if (!this.speakerStatsComponentAddress || !e) return;
							const n = (0, vt.$msg)({
								to: this.speakerStatsComponentAddress
							});
							n.c("faceLandmarks", {
								xmlns: "http://jitsi.org/jitmeet",
								room: e,
								faceExpression: t.faceExpression,
								timestamp: t.timestamp,
								duration: t.duration
							}).up(), this.connection.send(n)
						}
						tryParseJSONAndVerify(e) {
							if (!e) return !1;
							try {
								const t = JSON.parse(e);
								if (t && "object" == typeof t) {
									const e = t[ga];
									if (void 0 !== e) return t;
									pa.debug("parsing valid json but does not have correct structure", "topic: ", e)
								}
							} catch (t) {
								return pa.error(`Error parsing json ${e}`, t), !1
							}
							return !1
						}
						_onPrivateMessage(e) {
							const t = e.getAttribute("from");
							if (!this._components.includes(t)) return !0;
							const n = ft()(e).find(">json-message").text(),
								i = this.tryParseJSONAndVerify(n);
							return !i || ("speakerstats" === i[ga] && i.users ? this.eventEmitter.emit(ki.XMPPEvents.SPEAKER_STATS_RECEIVED, i.users) : "conference_duration" === i[ga] && i.created_timestamp ? this.eventEmitter.emit(ki.XMPPEvents.CONFERENCE_TIMESTAMP_RECEIVED, i.created_timestamp) : "av_moderation" === i[ga] ? this.eventEmitter.emit(ki.XMPPEvents.AV_MODERATION_RECEIVED, i) : "breakout_rooms" === i[ga] ? this.eventEmitter.emit(ki.XMPPEvents.BREAKOUT_ROOMS_EVENT, i) : "room_metadata" === i[ga] && this.eventEmitter.emit(ki.XMPPEvents.ROOM_METADATA_EVENT, i), !0)
						}
						_maybeSendDeploymentInfoStat(e) {
							const t = [vt.Strophe.Status.ERROR, vt.Strophe.Status.CONNFAIL, vt.Strophe.Status.AUTHFAIL, vt.Strophe.Status.DISCONNECTED, vt.Strophe.Status.CONNTIMEOUT];
							if (!(e || t.includes(this.connection.status) && this.sendDeploymentInfo)) return;
							const n = this.options.deploymentInfo;
							if (n && Object.keys(n).length > 0) {
								const e = {};
								for (const t in n) n.hasOwnProperty(t) && (e[t] = n[t]);
								Pi.analytics.addPermanentProperties({
									...e
								}), e.id = "deployment_info", Pi.sendLog(JSON.stringify(e))
							}
							this.sendDeploymentInfo = !1
						}
					}

					function Ea(e) {
						let t, {
								id: n,
								password: i,
								onCreateResource: s,
								onLoginSuccessful: r
							} = e,
							o = !1,
							a = new Sa(this.connection.options);
						const c = new Promise(((e, c) => {
							t = c, a.addListener(ji, (() => {
								a = void 0
							})), a.addListener(Hi, (() => {
								o || (r && r(), a.createRoom(this.options.name, this.options.config, s).moderator.authenticate().then((() => {
									a && a.disconnect(), o || (this.room.moderator.allocateConferenceFocus(), e())
								})).catch((e => {
									let {
										error: t,
										message: n
									} = e;
									a.disconnect(), c({
										authenticationError: t,
										message: n
									})
								})))
							})), a.addListener(Bi, ((e, t, n) => {
								c({
									connectionError: e,
									credentials: n,
									message: t
								}), a = void 0
							})), o || a.connect(n, i)
						}));
						return c.cancel = () => {
							o = !0, t({}), a && a.disconnect()
						}, c
					}
					const ya = (0, S.getLogger)("modules/RTC/CodecSelection.js");
					class Ta {
						constructor(e, t) {
							this.conference = e, this.options = t, this.enforcePreferredCodec = t.enforcePreferredCodec, this.p2pDisabledCodec = t.p2pDisabledCodec !== Hr().VP8 && this._isCodecSupported(t.p2pDisabledCodec) && t.p2pDisabledCodec, this.jvbDisabledCodec = t.jvbDisabledCodec !== Hr().VP8 && this._isCodecSupported(t.jvbDisabledCodec) && t.jvbDisabledCodec, this.p2pPreferredCodec = this._isCodecSupported(t.p2pPreferredCodec) && t.p2pPreferredCodec !== t.p2pDisabledCodec ? t.p2pPreferredCodec : Hr().VP8, this.jvbPreferredCodec = this._isCodecSupported(t.jvbPreferredCodec) && t.jvbPreferredCodec !== t.jvbDisabledCodec ? t.jvbPreferredCodec : Hr().VP8, ya.debug(`Codec preferences for the conference are JVB: preferred=${this.jvbPreferredCodec},disabled=${this.jvbDisabledCodec} P2P: preferred=${this.p2pPreferredCodec},disabled=${this.p2pDisabledCodec}`), this.conference.on(Xe, (() => this._selectPreferredCodec())), this.conference.on(ze, (() => this._selectPreferredCodec())), this.conference.on(Te, (e => this._selectPreferredCodec(e)))
						}
						_isCodecSupported(e) {
							return !!e && !(e === Hr().VP9 && !this.enforcePreferredCodec && !Wn.supportsVP9()) && (!!Wn.isFirefox() || window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("video").codecs.some((t => t.mimeType.toLowerCase() === `video/${e}`)))
						}
						_selectPreferredCodec(e) {
							const t = e || this.conference.jvbJingleSession;
							if (!t) return;
							const n = t.isP2P ? this.p2pPreferredCodec : this.jvbPreferredCodec,
								i = t.isP2P ? this.p2pDisabledCodec : this.jvbDisabledCodec,
								s = null == t ? void 0 : t.peerconnection.getConfiguredVideoCodec();
							let r = null != n ? n : s;
							if (!this.enforcePreferredCodec) {
								const e = this.conference.getParticipants().map((e => e.getId())),
									n = (null == e ? void 0 : e.map((e => {
										const n = t._signalingLayer.getPeerMediaInfo(e, _i.VIDEO);
										return null == n ? void 0 : n.codecType
									}))).filter((e => e !== r && e !== i));
								var o;
								n.length && (r = null !== (o = n.find((e => e === Hr().VP8))) && void 0 !== o ? o : n.find((e => this._isCodecSupported(e))))
							}(r !== s || i) && t.setVideoCodecs(r, i)
						}
						getPreferredCodec() {
							return this.jvbPreferredCodec
						}
					}
					const Ca = (0, S.getLogger)("modules/RTC/BridgeChannel.js");
					class ba {
						constructor(e, t, n) {
							if (!e && !t) throw new TypeError("At least peerconnection or wsUrl must be given");
							if (e && t) throw new TypeError("Just one of peerconnection or wsUrl must be given");
							if (e ? Ca.debug("constructor() with peerconnection") : Ca.debug(`constructor() with wsUrl:"${t}"`), this._channel = null, this._connected = void 0, this._eventEmitter = n, this._mode = null, this._areRetriesEnabled = !1, this._closedFromClient = !1, e) {
								const t = e.createDataChannel("JVB data channel", {
									protocol: "http://jitsi.org/protocols/colibri"
								});
								this._handleChannel(t), this._mode = "datachannel"
							} else t && (this._areRetriesEnabled = !0, this._wsUrl = t, this._initWebSocket())
						}
						_initWebSocket() {
							const e = new WebSocket(this._wsUrl);
							this._handleChannel(e), this._mode = "websocket"
						}
						_startConnectionRetries() {
							let e = 1;
							const t = () => {
								!this._channel || "connecting" !== this._channel.readyState && this._channel.readyState !== WebSocket.CONNECTING ? this.isOpen() || (this._initWebSocket(this._wsUrl), e = Math.min(2 * e, 60), this._retryTimeout = setTimeout(t, 1e3 * e)) : this._retryTimeout = setTimeout(t, 1e3 * e)
							};
							this._retryTimeout = setTimeout(t, 1e3 * e)
						}
						_stopConnectionRetries() {
							this._retryTimeout && (clearTimeout(this._retryTimeout), this._retryTimeout = void 0)
						}
						_retryWebSocketConnection(e) {
							if (!this._areRetriesEnabled) return;
							const {
								code: t,
								reason: n
							} = e;
							Pi.sendAnalytics(((e, t) => ({
								type: Kt.TYPE_OPERATIONAL,
								action: "bridge-channel.error",
								attributes: {
									code: e,
									reason: t
								}
							}))(t, n)), this._areRetriesEnabled = !1, this._eventEmitter.once(Oi.default.DATA_CHANNEL_OPEN, (() => {
								this._stopConnectionRetries(), this._areRetriesEnabled = !0
							})), this._startConnectionRetries()
						}
						get mode() {
							return this._mode
						}
						close() {
							if (this._closedFromClient = !0, this._stopConnectionRetries(), this._areRetriesEnabled = !1, this._channel) {
								try {
									this._channel.close()
								} catch (e) {}
								this._channel = null
							}
						}
						isOpen() {
							return this._channel && ("open" === this._channel.readyState || this._channel.readyState === WebSocket.OPEN)
						}
						sendEndpointStatsMessage(e) {
							this._send({
								colibriClass: "EndpointStats",
								...e
							})
						}
						sendMessage(e, t) {
							this._send({
								colibriClass: "EndpointMessage",
								msgPayload: t,
								to: e
							})
						}
						sendSetLastNMessage(e) {
							Ca.log(`Sending lastN=${e}.`), this._send({
								colibriClass: "LastNChangedEvent",
								lastN: e
							})
						}
						sendReceiverVideoConstraintsMessage(e) {
							Ca.log(`Sending ReceiverVideoConstraints with ${JSON.stringify(e)}`), this._send({
								colibriClass: "ReceiverVideoConstraints",
								...e
							})
						}
						sendSourceVideoTypeMessage(e, t) {
							Ca.info(`Sending SourceVideoTypeMessage with video type ${e}: ${t}`), this._send({
								colibriClass: "SourceVideoTypeMessage",
								sourceName: e,
								videoType: t
							})
						}
						_handleChannel(e) {
							const t = this._eventEmitter;
							e.onopen = () => {
								Ca.info(`${this._mode} channel opened`), this._connected = !0, t.emit(Oi.default.DATA_CHANNEL_OPEN)
							}, e.onerror = e => {
								"websocket" !== this._mode && Ca.error(`Channel error: ${e.message}`)
							}, e.onmessage = e => {
								let n, {
									data: i
								} = e;
								try {
									n = JSON.parse(i)
								} catch (e) {
									return ei().callErrorHandler(e), void Ca.error("Failed to parse channel message as JSON: ", i, e)
								}
								const s = n.colibriClass;
								switch (s) {
									case "DominantSpeakerEndpointChangeEvent": {
										const {
											dominantSpeakerEndpoint: e,
											previousSpeakers: i = [],
											silence: s
										} = n;
										Ca.debug(`Dominant speaker: ${e}, previous speakers: ${i}`), t.emit(Oi.default.DOMINANT_SPEAKER_CHANGED, e, i, s);
										break
									}
									case "EndpointConnectivityStatusChangeEvent": {
										const e = n.endpoint,
											i = "true" === n.active;
										Ca.info(`Endpoint connection status changed: ${e} active=${i}`), t.emit(Oi.default.ENDPOINT_CONN_STATUS_CHANGED, e, i);
										break
									}
									case "EndpointMessage":
										t.emit(Oi.default.ENDPOINT_MESSAGE_RECEIVED, n.from, n.msgPayload);
										break;
									case "EndpointStats":
										t.emit(Oi.default.ENDPOINT_STATS_RECEIVED, n.from, n);
										break;
									case "ForwardedSources": {
										const e = n.forwardedSources;
										Ca.info(`New forwarded sources: ${e}`), t.emit(Oi.default.FORWARDED_SOURCES_CHANGED, e);
										break
									}
									case "SenderSourceConstraints":
										"string" == typeof n.sourceName && "number" == typeof n.maxHeight ? (Ca.info(`SenderSourceConstraints: ${n.sourceName} - ${n.maxHeight}`), t.emit(Oi.default.SENDER_VIDEO_CONSTRAINTS_CHANGED, n)) : Ca.error(`Invalid SenderSourceConstraints: ${n.sourceName} - ${n.maxHeight}`);
										break;
									case "ServerHello":
										Ca.info(`Received ServerHello, version=${n.version}.`);
										break;
									case "VideoSourcesMap":
										Ca.info(`Received VideoSourcesMap: ${JSON.stringify(n.mappedSources)}`), t.emit(Oi.default.VIDEO_SSRCS_REMAPPED, n);
										break;
									case "AudioSourcesMap":
										Ca.info(`Received AudioSourcesMap: ${JSON.stringify(n.mappedSources)}`), t.emit(Oi.default.AUDIO_SSRCS_REMAPPED, n);
										break;
									default:
										Ca.debug("Channel JSON-formatted message: ", n), t.emit(`rtc.datachannel.${s}`, n)
								}
							}, e.onclose = n => {
								if (Ca.debug("Channel closed by " + (this._closedFromClient ? "client" : "server")), e === this._channel) {
									if (!this._closedFromClient && 1001 !== n.code) {
										const {
											code: e,
											reason: i
										} = n;
										Ca.error(`Channel closed: ${e} ${i}`), "websocket" === this._mode && this._retryWebSocketConnection(n), !1 !== this._connected && t.emit(Oi.default.DATA_CHANNEL_CLOSED, {
											code: e,
											reason: i
										})
									}
									this._connected = !1, this._channel = null
								} else Ca.debug("Skip close handler, channel instance is not equal to stored one")
							}, this._channel = e
						}
						_send(e) {
							const t = this._channel;
							if (!this.isOpen()) throw Ca.error("Bridge Channel send: no opened channel."), new Error("No opened channel");
							t.send(JSON.stringify(e))
						}
					}
					var Aa = n(4940),
						Ra = n.n(Aa);
					let Ia = !0,
						Pa = !0;

					function Da(e, t, n) {
						const i = e.match(t);
						return i && i.length >= n && parseInt(i[n], 10)
					}

					function wa(e, t, n) {
						if (!e.RTCPeerConnection) return;
						const i = e.RTCPeerConnection.prototype,
							s = i.addEventListener;
						i.addEventListener = function(e, i) {
							if (e !== t) return s.apply(this, arguments);
							const r = e => {
								const t = n(e);
								t && (i.handleEvent ? i.handleEvent(t) : i(t))
							};
							return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(i, r), s.apply(this, [e, r])
						};
						const r = i.removeEventListener;
						i.removeEventListener = function(e, n) {
							if (e !== t || !this._eventMap || !this._eventMap[t]) return r.apply(this, arguments);
							if (!this._eventMap[t].has(n)) return r.apply(this, arguments);
							const i = this._eventMap[t].get(n);
							return this._eventMap[t].delete(n), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, r.apply(this, [e, i])
						}, Object.defineProperty(i, "on" + t, {
							get() {
								return this["_on" + t]
							},
							set(e) {
								this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e)
							},
							enumerable: !0,
							configurable: !0
						})
					}

					function Oa(e) {
						return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (Ia = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled")
					}

					function Na(e) {
						return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (Pa = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled"))
					}

					function Ma() {
						if ("object" == typeof window) {
							if (Ia) return;
							"undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments)
						}
					}

					function La(e, t) {
						Pa && console.warn(e + " is deprecated, please use " + t + " instead.")
					}

					function ka(e) {
						const t = {
							browser: null,
							version: null
						};
						if (void 0 === e || !e.navigator) return t.browser = "Not a browser.", t;
						const {
							navigator: n
						} = e;
						if (n.mozGetUserMedia) t.browser = "firefox", t.version = Da(n.userAgent, /Firefox\/(\d+)\./, 1);
						else if (n.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = Da(n.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
						else {
							if (!e.RTCPeerConnection || !n.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t;
							t.browser = "safari", t.version = Da(n.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype
						}
						return t
					}

					function xa(e) {
						return "[object Object]" === Object.prototype.toString.call(e)
					}

					function Fa(e) {
						return xa(e) ? Object.keys(e).reduce((function(t, n) {
							const i = xa(e[n]),
								s = i ? Fa(e[n]) : e[n],
								r = i && !Object.keys(s).length;
							return void 0 === s || r ? t : Object.assign(t, {
								[n]: s
							})
						}), {}) : e
					}

					function Va(e, t, n) {
						t && !n.has(t.id) && (n.set(t.id, t), Object.keys(t).forEach((i => {
							i.endsWith("Id") ? Va(e, e.get(t[i]), n) : i.endsWith("Ids") && t[i].forEach((t => {
								Va(e, e.get(t), n)
							}))
						})))
					}

					function Ua(e, t, n) {
						const i = n ? "outbound-rtp" : "inbound-rtp",
							s = new Map;
						if (null === t) return s;
						const r = [];
						return e.forEach((e => {
							"track" === e.type && e.trackIdentifier === t.id && r.push(e)
						})), r.forEach((t => {
							e.forEach((n => {
								n.type === i && n.trackId === t.id && Va(e, n, s)
							}))
						})), s
					}
					const ja = Ma;

					function Ha(e, t) {
						const n = e && e.navigator;
						if (!n.mediaDevices) return;
						const i = function(e) {
								if ("object" != typeof e || e.mandatory || e.optional) return e;
								const t = {};
								return Object.keys(e).forEach((n => {
									if ("require" === n || "advanced" === n || "mediaSource" === n) return;
									const i = "object" == typeof e[n] ? e[n] : {
										ideal: e[n]
									};
									void 0 !== i.exact && "number" == typeof i.exact && (i.min = i.max = i.exact);
									const s = function(e, t) {
										return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t
									};
									if (void 0 !== i.ideal) {
										t.optional = t.optional || [];
										let e = {};
										"number" == typeof i.ideal ? (e[s("min", n)] = i.ideal, t.optional.push(e), e = {}, e[s("max", n)] = i.ideal, t.optional.push(e)) : (e[s("", n)] = i.ideal, t.optional.push(e))
									}
									void 0 !== i.exact && "number" != typeof i.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[s("", n)] = i.exact) : ["min", "max"].forEach((e => {
										void 0 !== i[e] && (t.mandatory = t.mandatory || {}, t.mandatory[s(e, n)] = i[e])
									}))
								})), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t
							},
							s = function(e, s) {
								if (t.version >= 61) return s(e);
								if ((e = JSON.parse(JSON.stringify(e))) && "object" == typeof e.audio) {
									const t = function(e, t, n) {
										t in e && !(n in e) && (e[n] = e[t], delete e[t])
									};
									t((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), t(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = i(e.audio)
								}
								if (e && "object" == typeof e.video) {
									let r = e.video.facingMode;
									r = r && ("object" == typeof r ? r : {
										ideal: r
									});
									const o = t.version < 66;
									if (r && ("user" === r.exact || "environment" === r.exact || "user" === r.ideal || "environment" === r.ideal) && (!n.mediaDevices.getSupportedConstraints || !n.mediaDevices.getSupportedConstraints().facingMode || o)) {
										let t;
										if (delete e.video.facingMode, "environment" === r.exact || "environment" === r.ideal ? t = ["back", "rear"] : "user" !== r.exact && "user" !== r.ideal || (t = ["front"]), t) return n.mediaDevices.enumerateDevices().then((n => {
											let o = (n = n.filter((e => "videoinput" === e.kind))).find((e => t.some((t => e.label.toLowerCase().includes(t)))));
											return !o && n.length && t.includes("back") && (o = n[n.length - 1]), o && (e.video.deviceId = r.exact ? {
												exact: o.deviceId
											} : {
												ideal: o.deviceId
											}), e.video = i(e.video), ja("chrome: " + JSON.stringify(e)), s(e)
										}))
									}
									e.video = i(e.video)
								}
								return ja("chrome: " + JSON.stringify(e)), s(e)
							},
							r = function(e) {
								return t.version >= 64 ? e : {
									name: {
										PermissionDeniedError: "NotAllowedError",
										PermissionDismissedError: "NotAllowedError",
										InvalidStateError: "NotAllowedError",
										DevicesNotFoundError: "NotFoundError",
										ConstraintNotSatisfiedError: "OverconstrainedError",
										TrackStartError: "NotReadableError",
										MediaDeviceFailedDueToShutdown: "NotAllowedError",
										MediaDeviceKillSwitchOn: "NotAllowedError",
										TabCaptureError: "AbortError",
										ScreenCaptureError: "AbortError",
										DeviceCaptureError: "AbortError"
									} [e.name] || e.name,
									message: e.message,
									constraint: e.constraint || e.constraintName,
									toString() {
										return this.name + (this.message && ": ") + this.message
									}
								}
							};
						if (n.getUserMedia = function(e, t, i) {
								s(e, (e => {
									n.webkitGetUserMedia(e, t, (e => {
										i && i(r(e))
									}))
								}))
							}.bind(n), n.mediaDevices.getUserMedia) {
							const e = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
							n.mediaDevices.getUserMedia = function(t) {
								return s(t, (t => e(t).then((e => {
									if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach((e => {
										e.stop()
									})), new DOMException("", "NotFoundError");
									return e
								}), (e => Promise.reject(r(e))))))
							}
						}
					}

					function Ba(e, t) {
						e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && ("function" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function(n) {
							return t(n).then((t => {
								const i = n.video && n.video.width,
									s = n.video && n.video.height,
									r = n.video && n.video.frameRate;
								return n.video = {
									mandatory: {
										chromeMediaSource: "desktop",
										chromeMediaSourceId: t,
										maxFrameRate: r || 3
									}
								}, i && (n.video.mandatory.maxWidth = i), s && (n.video.mandatory.maxHeight = s), e.navigator.mediaDevices.getUserMedia(n)
							}))
						} : console.error("shimGetDisplayMedia: getSourceId argument is not a function"))
					}

					function $a(e) {
						e.MediaStream = e.MediaStream || e.webkitMediaStream
					}

					function Ja(e) {
						if ("object" == typeof e && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) {
							Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", {
								get() {
									return this._ontrack
								},
								set(e) {
									this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e)
								},
								enumerable: !0,
								configurable: !0
							});
							const t = e.RTCPeerConnection.prototype.setRemoteDescription;
							e.RTCPeerConnection.prototype.setRemoteDescription = function() {
								return this._ontrackpoly || (this._ontrackpoly = t => {
									t.stream.addEventListener("addtrack", (n => {
										let i;
										i = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e => e.track && e.track.id === n.track.id)) : {
											track: n.track
										};
										const s = new Event("track");
										s.track = n.track, s.receiver = i, s.transceiver = {
											receiver: i
										}, s.streams = [t.stream], this.dispatchEvent(s)
									})), t.stream.getTracks().forEach((n => {
										let i;
										i = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e => e.track && e.track.id === n.id)) : {
											track: n
										};
										const s = new Event("track");
										s.track = n, s.receiver = i, s.transceiver = {
											receiver: i
										}, s.streams = [t.stream], this.dispatchEvent(s)
									}))
								}, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments)
							}
						} else wa(e, "track", (e => (e.transceiver || Object.defineProperty(e, "transceiver", {
							value: {
								receiver: e.receiver
							}
						}), e)))
					}

					function Ga(e) {
						if ("object" == typeof e && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) {
							const t = function(e, t) {
								return {
									track: t,
									get dtmf() {
										return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf
									},
									_pc: e
								}
							};
							if (!e.RTCPeerConnection.prototype.getSenders) {
								e.RTCPeerConnection.prototype.getSenders = function() {
									return this._senders = this._senders || [], this._senders.slice()
								};
								const n = e.RTCPeerConnection.prototype.addTrack;
								e.RTCPeerConnection.prototype.addTrack = function(e, i) {
									let s = n.apply(this, arguments);
									return s || (s = t(this, e), this._senders.push(s)), s
								};
								const i = e.RTCPeerConnection.prototype.removeTrack;
								e.RTCPeerConnection.prototype.removeTrack = function(e) {
									i.apply(this, arguments);
									const t = this._senders.indexOf(e); - 1 !== t && this._senders.splice(t, 1)
								}
							}
							const n = e.RTCPeerConnection.prototype.addStream;
							e.RTCPeerConnection.prototype.addStream = function(e) {
								this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach((e => {
									this._senders.push(t(this, e))
								}))
							};
							const i = e.RTCPeerConnection.prototype.removeStream;
							e.RTCPeerConnection.prototype.removeStream = function(e) {
								this._senders = this._senders || [], i.apply(this, [e]), e.getTracks().forEach((e => {
									const t = this._senders.find((t => t.track === e));
									t && this._senders.splice(this._senders.indexOf(t), 1)
								}))
							}
						} else if ("object" == typeof e && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) {
							const t = e.RTCPeerConnection.prototype.getSenders;
							e.RTCPeerConnection.prototype.getSenders = function() {
								const e = t.apply(this, []);
								return e.forEach((e => e._pc = this)), e
							}, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
								get() {
									return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf
								}
							})
						}
					}

					function qa(e) {
						if (!e.RTCPeerConnection) return;
						const t = e.RTCPeerConnection.prototype.getStats;
						e.RTCPeerConnection.prototype.getStats = function() {
							const [e, n, i] = arguments;
							if (arguments.length > 0 && "function" == typeof e) return t.apply(this, arguments);
							if (0 === t.length && (0 === arguments.length || "function" != typeof e)) return t.apply(this, []);
							const s = function(e) {
									const t = {};
									return e.result().forEach((e => {
										const n = {
											id: e.id,
											timestamp: e.timestamp,
											type: {
												localcandidate: "local-candidate",
												remotecandidate: "remote-candidate"
											} [e.type] || e.type
										};
										e.names().forEach((t => {
											n[t] = e.stat(t)
										})), t[n.id] = n
									})), t
								},
								r = function(e) {
									return new Map(Object.keys(e).map((t => [t, e[t]])))
								};
							if (arguments.length >= 2) {
								const i = function(e) {
									n(r(s(e)))
								};
								return t.apply(this, [i, e])
							}
							return new Promise(((e, n) => {
								t.apply(this, [function(t) {
									e(r(s(t)))
								}, n])
							})).then(n, i)
						}
					}

					function Ka(e) {
						if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;
						if (!("getStats" in e.RTCRtpSender.prototype)) {
							const t = e.RTCPeerConnection.prototype.getSenders;
							t && (e.RTCPeerConnection.prototype.getSenders = function() {
								const e = t.apply(this, []);
								return e.forEach((e => e._pc = this)), e
							});
							const n = e.RTCPeerConnection.prototype.addTrack;
							n && (e.RTCPeerConnection.prototype.addTrack = function() {
								const e = n.apply(this, arguments);
								return e._pc = this, e
							}), e.RTCRtpSender.prototype.getStats = function() {
								const e = this;
								return this._pc.getStats().then((t => Ua(t, e.track, !0)))
							}
						}
						if (!("getStats" in e.RTCRtpReceiver.prototype)) {
							const t = e.RTCPeerConnection.prototype.getReceivers;
							t && (e.RTCPeerConnection.prototype.getReceivers = function() {
								const e = t.apply(this, []);
								return e.forEach((e => e._pc = this)), e
							}), wa(e, "track", (e => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function() {
								const e = this;
								return this._pc.getStats().then((t => Ua(t, e.track, !1)))
							}
						}
						if (!("getStats" in e.RTCRtpSender.prototype) || !("getStats" in e.RTCRtpReceiver.prototype)) return;
						const t = e.RTCPeerConnection.prototype.getStats;
						e.RTCPeerConnection.prototype.getStats = function() {
							if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {
								const e = arguments[0];
								let t, n, i;
								return this.getSenders().forEach((n => {
									n.track === e && (t ? i = !0 : t = n)
								})), this.getReceivers().forEach((t => (t.track === e && (n ? i = !0 : n = t), t.track === e))), i || t && n ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t ? t.getStats() : n ? n.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"))
							}
							return t.apply(this, arguments)
						}
					}

					function Wa(e) {
						e.RTCPeerConnection.prototype.getLocalStreams = function() {
							return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e => this._shimmedLocalStreams[e][0]))
						};
						const t = e.RTCPeerConnection.prototype.addTrack;
						e.RTCPeerConnection.prototype.addTrack = function(e, n) {
							if (!n) return t.apply(this, arguments);
							this._shimmedLocalStreams = this._shimmedLocalStreams || {};
							const i = t.apply(this, arguments);
							return this._shimmedLocalStreams[n.id] ? -1 === this._shimmedLocalStreams[n.id].indexOf(i) && this._shimmedLocalStreams[n.id].push(i) : this._shimmedLocalStreams[n.id] = [n, i], i
						};
						const n = e.RTCPeerConnection.prototype.addStream;
						e.RTCPeerConnection.prototype.addStream = function(e) {
							this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach((e => {
								if (this.getSenders().find((t => t.track === e))) throw new DOMException("Track already exists.", "InvalidAccessError")
							}));
							const t = this.getSenders();
							n.apply(this, arguments);
							const i = this.getSenders().filter((e => -1 === t.indexOf(e)));
							this._shimmedLocalStreams[e.id] = [e].concat(i)
						};
						const i = e.RTCPeerConnection.prototype.removeStream;
						e.RTCPeerConnection.prototype.removeStream = function(e) {
							return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], i.apply(this, arguments)
						};
						const s = e.RTCPeerConnection.prototype.removeTrack;
						e.RTCPeerConnection.prototype.removeTrack = function(e) {
							return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach((t => {
								const n = this._shimmedLocalStreams[t].indexOf(e); - 1 !== n && this._shimmedLocalStreams[t].splice(n, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t]
							})), s.apply(this, arguments)
						}
					}

					function Xa(e, t) {
						if (!e.RTCPeerConnection) return;
						if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return Wa(e);
						const n = e.RTCPeerConnection.prototype.getLocalStreams;
						e.RTCPeerConnection.prototype.getLocalStreams = function() {
							const e = n.apply(this);
							return this._reverseStreams = this._reverseStreams || {}, e.map((e => this._reverseStreams[e.id]))
						};
						const i = e.RTCPeerConnection.prototype.addStream;
						e.RTCPeerConnection.prototype.addStream = function(t) {
							if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach((e => {
									if (this.getSenders().find((t => t.track === e))) throw new DOMException("Track already exists.", "InvalidAccessError")
								})), !this._reverseStreams[t.id]) {
								const n = new e.MediaStream(t.getTracks());
								this._streams[t.id] = n, this._reverseStreams[n.id] = t, t = n
							}
							i.apply(this, [t])
						};
						const s = e.RTCPeerConnection.prototype.removeStream;

						function r(e, t) {
							let n = t.sdp;
							return Object.keys(e._reverseStreams || []).forEach((t => {
								const i = e._reverseStreams[t],
									s = e._streams[i.id];
								n = n.replace(new RegExp(s.id, "g"), i.id)
							})), new RTCSessionDescription({
								type: t.type,
								sdp: n
							})
						}

						function o(e, t) {
							let n = t.sdp;
							return Object.keys(e._reverseStreams || []).forEach((t => {
								const i = e._reverseStreams[t],
									s = e._streams[i.id];
								n = n.replace(new RegExp(i.id, "g"), s.id)
							})), new RTCSessionDescription({
								type: t.type,
								sdp: n
							})
						}
						e.RTCPeerConnection.prototype.removeStream = function(e) {
							this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, s.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id]
						}, e.RTCPeerConnection.prototype.addTrack = function(t, n) {
							if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
							const i = [].slice.call(arguments, 1);
							if (1 !== i.length || !i[0].getTracks().find((e => e === t))) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
							const s = this.getSenders().find((e => e.track === t));
							if (s) throw new DOMException("Track already exists.", "InvalidAccessError");
							this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
							const r = this._streams[n.id];
							if (r) r.addTrack(t), Promise.resolve().then((() => {
								this.dispatchEvent(new Event("negotiationneeded"))
							}));
							else {
								const i = new e.MediaStream([t]);
								this._streams[n.id] = i, this._reverseStreams[i.id] = n, this.addStream(i)
							}
							return this.getSenders().find((e => e.track === t))
						}, ["createOffer", "createAnswer"].forEach((function(t) {
							const n = e.RTCPeerConnection.prototype[t],
								i = {
									[t]() {
										const e = arguments;
										return arguments.length && "function" == typeof arguments[0] ? n.apply(this, [t => {
											const n = r(this, t);
											e[0].apply(null, [n])
										}, t => {
											e[1] && e[1].apply(null, t)
										}, arguments[2]]) : n.apply(this, arguments).then((e => r(this, e)))
									}
								};
							e.RTCPeerConnection.prototype[t] = i[t]
						}));
						const a = e.RTCPeerConnection.prototype.setLocalDescription;
						e.RTCPeerConnection.prototype.setLocalDescription = function() {
							return arguments.length && arguments[0].type ? (arguments[0] = o(this, arguments[0]), a.apply(this, arguments)) : a.apply(this, arguments)
						};
						const c = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription");
						Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", {
							get() {
								const e = c.get.apply(this);
								return "" === e.type ? e : r(this, e)
							}
						}), e.RTCPeerConnection.prototype.removeTrack = function(e) {
							if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
							if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
							if (e._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
							let t;
							this._streams = this._streams || {}, Object.keys(this._streams).forEach((n => {
								this._streams[n].getTracks().find((t => e.track === t)) && (t = this._streams[n])
							})), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded")))
						}
					}

					function za(e, t) {
						!e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
							const n = e.RTCPeerConnection.prototype[t],
								i = {
									[t]() {
										return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments)
									}
								};
							e.RTCPeerConnection.prototype[t] = i[t]
						}))
					}

					function Ya(e, t) {
						wa(e, "negotiationneeded", (e => {
							const n = e.target;
							if (!(t.version < 72 || n.getConfiguration && "plan-b" === n.getConfiguration().sdpSemantics) || "stable" === n.signalingState) return e
						}))
					}

					function Qa(e, t) {
						const n = e && e.navigator,
							i = e && e.MediaStreamTrack;
						if (n.getUserMedia = function(e, t, i) {
								La("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), n.mediaDevices.getUserMedia(e).then(t, i)
							}, !(t.version > 55 && "autoGainControl" in n.mediaDevices.getSupportedConstraints())) {
							const e = function(e, t, n) {
									t in e && !(n in e) && (e[n] = e[t], delete e[t])
								},
								t = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
							if (n.mediaDevices.getUserMedia = function(n) {
									return "object" == typeof n && "object" == typeof n.audio && (n = JSON.parse(JSON.stringify(n)), e(n.audio, "autoGainControl", "mozAutoGainControl"), e(n.audio, "noiseSuppression", "mozNoiseSuppression")), t(n)
								}, i && i.prototype.getSettings) {
								const t = i.prototype.getSettings;
								i.prototype.getSettings = function() {
									const n = t.apply(this, arguments);
									return e(n, "mozAutoGainControl", "autoGainControl"), e(n, "mozNoiseSuppression", "noiseSuppression"), n
								}
							}
							if (i && i.prototype.applyConstraints) {
								const t = i.prototype.applyConstraints;
								i.prototype.applyConstraints = function(n) {
									return "audio" === this.kind && "object" == typeof n && (n = JSON.parse(JSON.stringify(n)), e(n, "autoGainControl", "mozAutoGainControl"), e(n, "noiseSuppression", "mozNoiseSuppression")), t.apply(this, [n])
								}
							}
						}
					}

					function Za(e, t) {
						e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function(n) {
							if (!n || !n.video) {
								const e = new DOMException("getDisplayMedia without video constraints is undefined");
								return e.name = "NotFoundError", e.code = 8, Promise.reject(e)
							}
							return !0 === n.video ? n.video = {
								mediaSource: t
							} : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n)
						})
					}

					function ec(e) {
						"object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
							get() {
								return {
									receiver: this.receiver
								}
							}
						})
					}

					function tc(e, t) {
						if ("object" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return;
						!e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
							const n = e.RTCPeerConnection.prototype[t],
								i = {
									[t]() {
										return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments)
									}
								};
							e.RTCPeerConnection.prototype[t] = i[t]
						}));
						const n = {
								inboundrtp: "inbound-rtp",
								outboundrtp: "outbound-rtp",
								candidatepair: "candidate-pair",
								localcandidate: "local-candidate",
								remotecandidate: "remote-candidate"
							},
							i = e.RTCPeerConnection.prototype.getStats;
						e.RTCPeerConnection.prototype.getStats = function() {
							const [e, s, r] = arguments;
							return i.apply(this, [e || null]).then((e => {
								if (t.version < 53 && !s) try {
									e.forEach((e => {
										e.type = n[e.type] || e.type
									}))
								} catch (t) {
									if ("TypeError" !== t.name) throw t;
									e.forEach(((t, i) => {
										e.set(i, Object.assign({}, t, {
											type: n[t.type] || t.type
										}))
									}))
								}
								return e
							})).then(s, r)
						}
					}

					function nc(e) {
						if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
						if (e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return;
						const t = e.RTCPeerConnection.prototype.getSenders;
						t && (e.RTCPeerConnection.prototype.getSenders = function() {
							const e = t.apply(this, []);
							return e.forEach((e => e._pc = this)), e
						});
						const n = e.RTCPeerConnection.prototype.addTrack;
						n && (e.RTCPeerConnection.prototype.addTrack = function() {
							const e = n.apply(this, arguments);
							return e._pc = this, e
						}), e.RTCRtpSender.prototype.getStats = function() {
							return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map)
						}
					}

					function ic(e) {
						if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
						if (e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return;
						const t = e.RTCPeerConnection.prototype.getReceivers;
						t && (e.RTCPeerConnection.prototype.getReceivers = function() {
							const e = t.apply(this, []);
							return e.forEach((e => e._pc = this)), e
						}), wa(e, "track", (e => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function() {
							return this._pc.getStats(this.track)
						}
					}

					function sc(e) {
						e.RTCPeerConnection && !("removeStream" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function(e) {
							La("removeStream", "removeTrack"), this.getSenders().forEach((t => {
								t.track && e.getTracks().includes(t.track) && this.removeTrack(t)
							}))
						})
					}

					function rc(e) {
						e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel)
					}

					function oc(e) {
						if ("object" != typeof e || !e.RTCPeerConnection) return;
						const t = e.RTCPeerConnection.prototype.addTransceiver;
						t && (e.RTCPeerConnection.prototype.addTransceiver = function() {
							this.setParametersPromises = [];
							const e = arguments[1],
								n = e && "sendEncodings" in e;
							n && e.sendEncodings.forEach((e => {
								if ("rid" in e && !/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError("Invalid RID value provided.");
								if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
								if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0")
							}));
							const i = t.apply(this, arguments);
							if (n) {
								const {
									sender: t
								} = i, n = t.getParameters();
								(!("encodings" in n) || 1 === n.encodings.length && 0 === Object.keys(n.encodings[0]).length) && (n.encodings = e.sendEncodings, t.sendEncodings = e.sendEncodings, this.setParametersPromises.push(t.setParameters(n).then((() => {
									delete t.sendEncodings
								})).catch((() => {
									delete t.sendEncodings
								}))))
							}
							return i
						})
					}

					function ac(e) {
						if ("object" != typeof e || !e.RTCRtpSender) return;
						const t = e.RTCRtpSender.prototype.getParameters;
						t && (e.RTCRtpSender.prototype.getParameters = function() {
							const e = t.apply(this, arguments);
							return "encodings" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e
						})
					}

					function cc(e) {
						if ("object" != typeof e || !e.RTCPeerConnection) return;
						const t = e.RTCPeerConnection.prototype.createOffer;
						e.RTCPeerConnection.prototype.createOffer = function() {
							return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((() => t.apply(this, arguments))).finally((() => {
								this.setParametersPromises = []
							})) : t.apply(this, arguments)
						}
					}

					function dc(e) {
						if ("object" != typeof e || !e.RTCPeerConnection) return;
						const t = e.RTCPeerConnection.prototype.createAnswer;
						e.RTCPeerConnection.prototype.createAnswer = function() {
							return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((() => t.apply(this, arguments))).finally((() => {
								this.setParametersPromises = []
							})) : t.apply(this, arguments)
						}
					}

					function lc(e) {
						if ("object" == typeof e && e.RTCPeerConnection) {
							if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function() {
									return this._localStreams || (this._localStreams = []), this._localStreams
								}), !("addStream" in e.RTCPeerConnection.prototype)) {
								const t = e.RTCPeerConnection.prototype.addTrack;
								e.RTCPeerConnection.prototype.addStream = function(e) {
									this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach((n => t.call(this, n, e))), e.getVideoTracks().forEach((n => t.call(this, n, e)))
								}, e.RTCPeerConnection.prototype.addTrack = function(e) {
									for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++) i[s - 1] = arguments[s];
									return i && i.forEach((e => {
										this._localStreams ? this._localStreams.includes(e) || this._localStreams.push(e) : this._localStreams = [e]
									})), t.apply(this, arguments)
								}
							}
							"removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(e) {
								this._localStreams || (this._localStreams = []);
								const t = this._localStreams.indexOf(e);
								if (-1 === t) return;
								this._localStreams.splice(t, 1);
								const n = e.getTracks();
								this.getSenders().forEach((e => {
									n.includes(e.track) && this.removeTrack(e)
								}))
							})
						}
					}

					function uc(e) {
						if ("object" == typeof e && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function() {
								return this._remoteStreams ? this._remoteStreams : []
							}), !("onaddstream" in e.RTCPeerConnection.prototype))) {
							Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", {
								get() {
									return this._onaddstream
								},
								set(e) {
									this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = e => {
										e.streams.forEach((e => {
											if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e)) return;
											this._remoteStreams.push(e);
											const t = new Event("addstream");
											t.stream = e, this.dispatchEvent(t)
										}))
									})
								}
							});
							const t = e.RTCPeerConnection.prototype.setRemoteDescription;
							e.RTCPeerConnection.prototype.setRemoteDescription = function() {
								const e = this;
								return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t) {
									t.streams.forEach((t => {
										if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return;
										e._remoteStreams.push(t);
										const n = new Event("addstream");
										n.stream = t, e.dispatchEvent(n)
									}))
								}), t.apply(e, arguments)
							}
						}
					}

					function hc(e) {
						if ("object" != typeof e || !e.RTCPeerConnection) return;
						const t = e.RTCPeerConnection.prototype,
							n = t.createOffer,
							i = t.createAnswer,
							s = t.setLocalDescription,
							r = t.setRemoteDescription,
							o = t.addIceCandidate;
						t.createOffer = function(e, t) {
							const i = arguments.length >= 2 ? arguments[2] : arguments[0],
								s = n.apply(this, [i]);
							return t ? (s.then(e, t), Promise.resolve()) : s
						}, t.createAnswer = function(e, t) {
							const n = arguments.length >= 2 ? arguments[2] : arguments[0],
								s = i.apply(this, [n]);
							return t ? (s.then(e, t), Promise.resolve()) : s
						};
						let a = function(e, t, n) {
							const i = s.apply(this, [e]);
							return n ? (i.then(t, n), Promise.resolve()) : i
						};
						t.setLocalDescription = a, a = function(e, t, n) {
							const i = r.apply(this, [e]);
							return n ? (i.then(t, n), Promise.resolve()) : i
						}, t.setRemoteDescription = a, a = function(e, t, n) {
							const i = o.apply(this, [e]);
							return n ? (i.then(t, n), Promise.resolve()) : i
						}, t.addIceCandidate = a
					}

					function pc(e) {
						const t = e && e.navigator;
						if (t.mediaDevices && t.mediaDevices.getUserMedia) {
							const e = t.mediaDevices,
								n = e.getUserMedia.bind(e);
							t.mediaDevices.getUserMedia = e => n(mc(e))
						}!t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function(e, n, i) {
							t.mediaDevices.getUserMedia(e).then(n, i)
						}.bind(t))
					}

					function mc(e) {
						return e && void 0 !== e.video ? Object.assign({}, e, {
							video: Fa(e.video)
						}) : e
					}

					function fc(e) {
						if (!e.RTCPeerConnection) return;
						const t = e.RTCPeerConnection;
						e.RTCPeerConnection = function(e, n) {
							if (e && e.iceServers) {
								const t = [];
								for (let n = 0; n < e.iceServers.length; n++) {
									let i = e.iceServers[n];
									!i.hasOwnProperty("urls") && i.hasOwnProperty("url") ? (La("RTCIceServer.url", "RTCIceServer.urls"), i = JSON.parse(JSON.stringify(i)), i.urls = i.url, delete i.url, t.push(i)) : t.push(e.iceServers[n])
								}
								e.iceServers = t
							}
							return new t(e, n)
						}, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
							get: () => t.generateCertificate
						})
					}

					function gc(e) {
						"object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
							get() {
								return {
									receiver: this.receiver
								}
							}
						})
					}

					function _c(e) {
						const t = e.RTCPeerConnection.prototype.createOffer;
						e.RTCPeerConnection.prototype.createOffer = function(e) {
							if (e) {
								void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio);
								const t = this.getTransceivers().find((e => "audio" === e.receiver.track.kind));
								!1 === e.offerToReceiveAudio && t ? "sendrecv" === t.direction ? t.setDirection ? t.setDirection("sendonly") : t.direction = "sendonly" : "recvonly" === t.direction && (t.setDirection ? t.setDirection("inactive") : t.direction = "inactive") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver("audio", {
									direction: "recvonly"
								}), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo);
								const n = this.getTransceivers().find((e => "video" === e.receiver.track.kind));
								!1 === e.offerToReceiveVideo && n ? "sendrecv" === n.direction ? n.setDirection ? n.setDirection("sendonly") : n.direction = "sendonly" : "recvonly" === n.direction && (n.setDirection ? n.setDirection("inactive") : n.direction = "inactive") : !0 !== e.offerToReceiveVideo || n || this.addTransceiver("video", {
									direction: "recvonly"
								})
							}
							return t.apply(this, arguments)
						}
					}

					function vc(e) {
						"object" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext)
					}
					var Sc = n(5483),
						Ec = n.n(Sc);

					function yc(e) {
						if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return;
						const t = e.RTCIceCandidate;
						e.RTCIceCandidate = function(e) {
							if ("object" == typeof e && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) {
								const n = new t(e),
									i = Ec().parseCandidate(e.candidate),
									s = Object.assign(n, i);
								return s.toJSON = function() {
									return {
										candidate: s.candidate,
										sdpMid: s.sdpMid,
										sdpMLineIndex: s.sdpMLineIndex,
										usernameFragment: s.usernameFragment
									}
								}, s
							}
							return new t(e)
						}, e.RTCIceCandidate.prototype = t.prototype, wa(e, "icecandidate", (t => (t.candidate && Object.defineProperty(t, "candidate", {
							value: new e.RTCIceCandidate(t.candidate),
							writable: "false"
						}), t)))
					}

					function Tc(e, t) {
						if (!e.RTCPeerConnection) return;
						"sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", {
							get() {
								return void 0 === this._sctp ? null : this._sctp
							}
						});
						const n = function(e) {
								if (!e || !e.sdp) return !1;
								const t = Ec().splitSections(e.sdp);
								return t.shift(), t.some((e => {
									const t = Ec().parseMLine(e);
									return t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP")
								}))
							},
							i = function(e) {
								const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
								if (null === t || t.length < 2) return -1;
								const n = parseInt(t[1], 10);
								return n != n ? -1 : n
							},
							s = function(e) {
								let n = 65536;
								return "firefox" === t.browser && (n = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), n
							},
							r = function(e, n) {
								let i = 65536;
								"firefox" === t.browser && 57 === t.version && (i = 65535);
								const s = Ec().matchPrefix(e.sdp, "a=max-message-size:");
								return s.length > 0 ? i = parseInt(s[0].substr(19), 10) : "firefox" === t.browser && -1 !== n && (i = 2147483637), i
							},
							o = e.RTCPeerConnection.prototype.setRemoteDescription;
						e.RTCPeerConnection.prototype.setRemoteDescription = function() {
							if (this._sctp = null, "chrome" === t.browser && t.version >= 76) {
								const {
									sdpSemantics: e
								} = this.getConfiguration();
								"plan-b" === e && Object.defineProperty(this, "sctp", {
									get() {
										return void 0 === this._sctp ? null : this._sctp
									},
									enumerable: !0,
									configurable: !0
								})
							}
							if (n(arguments[0])) {
								const e = i(arguments[0]),
									t = s(e),
									n = r(arguments[0], e);
								let o;
								o = 0 === t && 0 === n ? Number.POSITIVE_INFINITY : 0 === t || 0 === n ? Math.max(t, n) : Math.min(t, n);
								const a = {};
								Object.defineProperty(a, "maxMessageSize", {
									get: () => o
								}), this._sctp = a
							}
							return o.apply(this, arguments)
						}
					}

					function Cc(e) {
						if (!e.RTCPeerConnection || !("createDataChannel" in e.RTCPeerConnection.prototype)) return;

						function t(e, t) {
							const n = e.send;
							e.send = function() {
								const i = arguments[0],
									s = i.length || i.size || i.byteLength;
								if ("open" === e.readyState && t.sctp && s > t.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)");
								return n.apply(e, arguments)
							}
						}
						const n = e.RTCPeerConnection.prototype.createDataChannel;
						e.RTCPeerConnection.prototype.createDataChannel = function() {
							const e = n.apply(this, arguments);
							return t(e, this), e
						}, wa(e, "datachannel", (e => (t(e.channel, e.target), e)))
					}

					function bc(e) {
						if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return;
						const t = e.RTCPeerConnection.prototype;
						Object.defineProperty(t, "connectionState", {
							get() {
								return {
									completed: "connected",
									checking: "connecting"
								} [this.iceConnectionState] || this.iceConnectionState
							},
							enumerable: !0,
							configurable: !0
						}), Object.defineProperty(t, "onconnectionstatechange", {
							get() {
								return this._onconnectionstatechange || null
							},
							set(e) {
								this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e)
							},
							enumerable: !0,
							configurable: !0
						}), ["setLocalDescription", "setRemoteDescription"].forEach((e => {
							const n = t[e];
							t[e] = function() {
								return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => {
									const t = e.target;
									if (t._lastConnectionState !== t.connectionState) {
										t._lastConnectionState = t.connectionState;
										const n = new Event("connectionstatechange", e);
										t.dispatchEvent(n)
									}
									return e
								}, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments)
							}
						}))
					}

					function Ac(e, t) {
						if (!e.RTCPeerConnection) return;
						if ("chrome" === t.browser && t.version >= 71) return;
						if ("safari" === t.browser && t.version >= 605) return;
						const n = e.RTCPeerConnection.prototype.setRemoteDescription;
						e.RTCPeerConnection.prototype.setRemoteDescription = function(t) {
							if (t && t.sdp && -1 !== t.sdp.indexOf("\na=extmap-allow-mixed")) {
								const n = t.sdp.split("\n").filter((e => "a=extmap-allow-mixed" !== e.trim())).join("\n");
								e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({
									type: t.type,
									sdp: n
								}) : t.sdp = n
							}
							return n.apply(this, arguments)
						}
					}

					function Rc(e, t) {
						if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
						const n = e.RTCPeerConnection.prototype.addIceCandidate;
						n && 0 !== n.length && (e.RTCPeerConnection.prototype.addIceCandidate = function() {
							return arguments[0] ? ("chrome" === t.browser && t.version < 78 || "firefox" === t.browser && t.version < 68 || "safari" === t.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : n.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
						})
					}

					function Ic(e, t) {
						if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
						const n = e.RTCPeerConnection.prototype.setLocalDescription;
						n && 0 !== n.length && (e.RTCPeerConnection.prototype.setLocalDescription = function() {
							let e = arguments[0] || {};
							if ("object" != typeof e || e.type && e.sdp) return n.apply(this, arguments);
							if (e = {
									type: e.type,
									sdp: e.sdp
								}, !e.type) switch (this.signalingState) {
								case "stable":
								case "have-local-offer":
								case "have-remote-pranswer":
									e.type = "offer";
									break;
								default:
									e.type = "answer"
							}
							if (e.sdp || "offer" !== e.type && "answer" !== e.type) return n.apply(this, [e]);
							const t = "offer" === e.type ? this.createOffer : this.createAnswer;
							return t.apply(this).then((e => n.apply(this, [e])))
						})
					}! function() {
						let {
							window: e
						} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
							shimChrome: !0,
							shimFirefox: !0,
							shimSafari: !0
						};
						const n = Ma,
							i = ka(e),
							s = {
								browserDetails: i,
								commonShim: p,
								extractVersion: Da,
								disableLog: Oa,
								disableWarnings: Na,
								sdp: Sc
							};
						switch (i.browser) {
							case "chrome":
								if (!l || !za || !t.shimChrome) return n("Chrome shim is not included in this adapter release."), s;
								if (null === i.version) return n("Chrome shim can not determine version, not shimming."), s;
								n("adapter.js shimming chrome."), s.browserShim = l, Rc(e, i), Ic(e), Ha(e, i), $a(e), za(e, i), Ja(e), Xa(e, i), Ga(e), qa(e), Ka(e), Ya(e, i), yc(e), bc(e), Tc(e, i), Cc(e), Ac(e, i);
								break;
							case "firefox":
								if (!u || !tc || !t.shimFirefox) return n("Firefox shim is not included in this adapter release."), s;
								n("adapter.js shimming firefox."), s.browserShim = u, Rc(e, i), Ic(e), Qa(e, i), tc(e, i), ec(e), sc(e), nc(e), ic(e), rc(e), oc(e), ac(e), cc(e), dc(e), yc(e), bc(e), Tc(e, i), Cc(e);
								break;
							case "safari":
								if (!h || !t.shimSafari) return n("Safari shim is not included in this adapter release."), s;
								n("adapter.js shimming safari."), s.browserShim = h, Rc(e, i), Ic(e), fc(e), _c(e), hc(e), lc(e), uc(e), gc(e), pc(e), vc(e), yc(e), Tc(e, i), Cc(e), Ac(e, i);
								break;
							default:
								n("Unsupported browser!")
						}
					}({
						window: "undefined" == typeof window ? void 0 : window
					});
					var Pc = n(6125),
						Dc = n.n(Pc);
					const wc = (0, S.getLogger)("modules/RTC/RTCUtils.js"),
						Oc = new(pt()),
						Nc = {
							video: {
								height: {
									ideal: 720,
									max: 720,
									min: 180
								},
								width: {
									ideal: 1280,
									max: 1280,
									min: 320
								}
							}
						};
					let Mc = "default",
						Lc = !1,
						kc = !1,
						xc = !1,
						Fc = !1,
						Vc = !1,
						Uc = null;
					const jc = document.createElement("audio"),
						Hc = void 0 !== jc.setSinkId;
					let Bc, $c = [];

					function Jc() {}

					function Gc(e, t) {
						const n = Boolean(t) && t.getAudioTracks().length > 0,
							i = Boolean(t) && t.getVideoTracks().length > 0,
							s = {}; - 1 !== e.indexOf("video") && (s.video = i), -1 !== e.indexOf("audio") && (s.audio = n), Oc.emit(Oi.default.PERMISSIONS_CHANGED, s)
					}

					function qc(e) {
						const t = e.filter((e => "audioinput" === e.kind)).length,
							n = e.filter((e => "audiooutput" === e.kind)).length,
							i = e.filter((e => "videoinput" === e.kind)).length,
							s = e.filter((e => "videooutput" === e.kind)).length;
						e.forEach((e => {
							const r = {
								audio_input_device_count: t,
								audio_output_device_count: n,
								video_input_device_count: i,
								video_output_device_count: s,
								device_id: e.deviceId,
								device_group_id: e.groupId,
								device_kind: e.kind,
								device_label: e.label
							};
							Pi.sendAnalytics(ln, r)
						}))
					}

					function Kc(e) {
						(function(e) {
							return e.length !== $c.length || e.map(t).sort().join("") !== $c.map(t).sort().join("");

							function t(e) {
								return JSON.stringify({
									kind: e.kind,
									deviceId: e.deviceId,
									groupId: e.groupId,
									label: e.label,
									facing: e.facing
								})
							}
						})(e) && ($c = e.slice(0), wc.info("list of media devices has changed:", $c), qc($c), Oc.emit(Oi.default.DEVICE_LIST_WILL_CHANGE, $c), Oc.emit(Oi.default.DEVICE_LIST_CHANGED, $c))
					}
					const Wc = new class extends Yi {
							constructor() {
								super(Oc)
							}
							init() {
								var e;
								let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
								var n;
								"boolean" == typeof t.disableAEC && (xc = t.disableAEC, wc.info(`Disable AEC: ${xc}`)), "boolean" == typeof t.disableNS && (Fc = t.disableNS, wc.info(`Disable NS: ${Fc}`)), "boolean" == typeof t.disableAP && (kc = t.disableAP, wc.info(`Disable AP: ${kc}`)), "boolean" == typeof t.disableAGC && (Vc = t.disableAGC, wc.info(`Disable AGC: ${Vc}`)), "boolean" == typeof(null === (e = t.audioQuality) || void 0 === e ? void 0 : e.stereo) && (Uc = t.audioQuality.stereo, wc.info(`Stereo: ${Uc}`)), window.clearInterval(Bc), Bc = void 0, Wn.isReactNative() || (this.attachMediaStream = (n = (e, t) => {
									e && (e.srcObject = t)
								}, function(e, t) {
									const i = n.apply(Wc, arguments);
									return t && Wc.isDeviceChangeAvailable("output") && t.getAudioTracks && t.getAudioTracks().length && Lc && e.setSinkId(Wc.getAudioOutputDevice()).catch((function(t) {
										const n = new qt(t, null, ["audiooutput"]);
										ei().callUnhandledRejectionHandler({
											promise: this,
											reason: n
										}), wc.warn("Failed to set audio output device for the element. Default audio output device will be used instead", e, n)
									})), i
								})), this.pcConstraints = {}, Gr.init(t), this.isDeviceListAvailable() && this.enumerateDevices((e => {
									$c = e.slice(0), wc.debug("Available devices: ", $c), qc($c), Oc.emit(Oi.default.DEVICE_LIST_AVAILABLE, $c), Wn.supportsDeviceChangeEvent() ? navigator.mediaDevices.addEventListener("devicechange", (() => this.enumerateDevices(Jc))) : Bc = window.setInterval((() => this.enumerateDevices(Jc)), 3e3)
								}))
							}
							enumerateDevices(e) {
								navigator.mediaDevices.enumerateDevices().then((t => {
									Kc(t), e(t)
								})).catch((t => {
									wc.warn(`Failed to  enumerate devices. ${t}`), Kc([]), e([])
								}))
							}
							_getUserMedia(e) {
								let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
									n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
								return new Promise(((i, s) => {
									let r, o = !1;
									"number" == typeof n && !isNaN(n) && n > 0 && (r = setTimeout((() => {
										o = !0, r = void 0, s(new qt(jt))
									}), n)), navigator.mediaDevices.getUserMedia(t).then((t => {
										wc.log("onUserMediaSuccess"), Gc(e, t), o || (void 0 !== r && clearTimeout(r), i(t))
									})).catch((n => {
										wc.warn(`Failed to get access to local media. ${n} ${JSON.stringify(t)}`);
										const i = new qt(n, t, e);
										o || (void 0 !== r && clearTimeout(r), s(i)), i.name === Ft && Gc(e, void 0)
									}))
								}))
							}
							_getDesktopMedia(e) {
								return Gr.isSupported() ? new Promise(((t, n) => {
									Gr.obtainStream((e => {
										t(e)
									}), (e => {
										n(e)
									}), e)
								})) : Promise.reject(new Error("Desktop sharing is not supported!"))
							}
							_getMissingTracks() {
								let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
									t = arguments.length > 1 ? arguments[1] : void 0;
								const n = [],
									i = e.includes("audio"),
									s = t && t.getAudioTracks().length > 0;
								i && !s && n.push("audio");
								const r = e.includes("video"),
									o = t && t.getVideoTracks().length > 0;
								return r && !o && n.push("video"), n
							}
							obtainAudioAndVideoPermissions(e) {
								const {
									timeout: t,
									...n
								} = e, i = [], s = function() {
									if (-1 === (n.devices || []).indexOf("desktop")) return Promise.resolve();
									const {
										desktopSharingSourceDevice: e,
										desktopSharingSources: i
									} = n;
									if (e) {
										const n = $c && $c.find((t => "videoinput" === t.kind && (t.deviceId === e || t.label === e)));
										if (!n) return Promise.reject(new qt({
											name: "ConstraintNotSatisfiedError"
										}, {}, [e]));
										const i = ["video"],
											s = {
												video: {
													deviceId: n.deviceId
												}
											};
										return this._getUserMedia(i, s, t).then((e => ({
											sourceType: "device",
											stream: e
										})))
									}
									return this._getDesktopMedia({
										desktopSharingSources: i
									})
								}.bind(this), r = function() {
									const e = (n.devices || ["audio", "video"]).filter((e => "audio" === e || "video" === e));
									if (!e.length) return Promise.resolve();
									const i = function() {
										let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
											t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
										const n = Kr()(t.constraints || Nc);
										if (e.indexOf("video") >= 0) {
											if (Dc()[t.resolution]) {
												const e = Dc()[t.resolution];
												n.video.height = {
													ideal: e.height
												}, n.video.width = {
													ideal: e.width
												}
											}
											if (n.video || (n.video = {}), Wn.isWebKitBased() && (n.video.height && n.video.height.ideal ? n.video.height = {
													ideal: n.video.height.ideal
												} : wc.warn("Ideal camera height missing, camera may not start properly"), n.video.width && n.video.width.ideal ? n.video.width = {
													ideal: n.video.width.ideal
												} : wc.warn("Ideal camera width missing, camera may not start properly")), t.cameraDeviceId) n.video.deviceId = t.cameraDeviceId;
											else {
												const e = t.facingMode || Ra().USER;
												n.video.facingMode = e
											}
										} else n.video = !1;
										return e.indexOf("audio") >= 0 ? (n.audio && "boolean" != typeof n.audio || (n.audio = {}), n.audio = {
											autoGainControl: !Vc && !kc,
											deviceId: t.micDeviceId,
											echoCancellation: !xc && !kc,
											noiseSuppression: !Fc && !kc
										}, Uc && Object.assign(n.audio, {
											channelCount: 2
										})) : n.audio = !1, n
									}(e, n);
									return wc.info("Got media constraints: ", JSON.stringify(i)), this._getUserMedia(e, i, t)
								}.bind(this);
								return s().then((function(e) {
									if (!e) return;
									const {
										stream: t,
										sourceId: n,
										sourceType: s
									} = e, r = t.getAudioTracks();
									if (r.length) {
										const e = new MediaStream(r);
										i.push({
											stream: e,
											sourceId: n,
											sourceType: s,
											track: e.getAudioTracks()[0]
										})
									}
									const o = t.getVideoTracks();
									if (o.length) {
										const e = new MediaStream(o);
										i.push({
											stream: e,
											sourceId: n,
											sourceType: s,
											track: e.getVideoTracks()[0],
											videoType: Ni.VideoType.DESKTOP
										})
									}
								})).then(r).then((function(e) {
									if (!e) return;
									const t = e.getAudioTracks();
									if (t.length) {
										const e = new MediaStream(t);
										i.push({
											stream: e,
											track: e.getAudioTracks()[0],
											effects: n.effects
										})
									}
									const s = e.getVideoTracks();
									if (s.length) {
										const e = new MediaStream(s);
										i.push({
											stream: e,
											track: e.getVideoTracks()[0],
											videoType: Ni.VideoType.CAMERA,
											effects: n.effects
										})
									}
								})).then((() => i)).catch((e => (i.forEach((e => {
									let {
										stream: t
									} = e;
									this.stopMediaStream(t)
								})), Promise.reject(e))))
							}
							isDeviceListAvailable() {
								return Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices)
							}
							isDeviceChangeAvailable(e) {
								return "output" !== e && "audiooutput" !== e || Hc
							}
							stopMediaStream(e) {
								e && (e.getTracks().forEach((e => {
									e.stop && e.stop()
								})), e.stop && e.stop(), e.release && e.release())
							}
							isDesktopSharingEnabled() {
								return Gr.isSupported()
							}
							setAudioOutputDevice(e) {
								return this.isDeviceChangeAvailable("output") ? jc.setSinkId(e).then((() => {
									Mc = e, Lc = !0, wc.log(`Audio output device set to ${e}`), Oc.emit(Oi.default.AUDIO_OUTPUT_DEVICE_CHANGED, e)
								})) : Promise.reject(new Error("Audio output device change is not supported"))
							}
							setDesktopSharingFrameRate(e) {
								Gr.setDesktopSharingFrameRate(e)
							}
							getAudioOutputDevice() {
								return Mc
							}
							getCurrentlyAvailableMediaDevices() {
								return $c
							}
							arePermissionsGrantedForAvailableDevices() {
								return $c.some((e => Boolean(e.label)))
							}
							getEventDataForActiveDevice(e) {
								const t = [],
									n = {
										deviceId: e.deviceId,
										kind: e.kind,
										label: e.label,
										groupId: e.groupId
									};
								return t.push(n), {
									deviceList: t
								}
							}
						},
						Xc = Wc,
						zc = (0, S.getLogger)("modules/RTC/JitsiTrack.js"),
						Yc = {
							track_mute: "onmute",
							track_unmute: "onunmute",
							track_ended: "onended"
						};
					class Qc extends(pt()) {
						constructor(e, t, n, i, s, r) {
							super(), this.addEventListener = this.addListener, this.removeEventListener = this.off = this.removeListener, this.containers = [], this.conference = e, this.audioLevel = -1, this.type = s, this.track = n, this.videoType = r, this.handlers = new Map, this.disposed = !1, this._streamInactiveHandler = i, this._setStream(t)
						}
						_addMediaStreamInactiveHandler(e) {
							Wn.isFirefox() ? this.track.onended = e : this.stream.oninactive = e
						}
						_attachTTFMTracker(e) {}
						_maybeFireTrackAttached(e) {
							this.conference && e && this.conference._onTrackAttach(this, e)
						}
						_onTrackAttach(e) {}
						_onTrackDetach(e) {}
						_setHandler(e, t) {
							if (Yc.hasOwnProperty(e)) {
								if (t ? this.handlers.set(e, t) : this.handlers.delete(e), this.stream)
									for (const n of this.stream.getTracks()) n[Yc[e]] = t
							} else zc.error(`Invalid handler type ${e}`)
						}
						_setStream(e) {
							if (this.stream !== e && (this.stream = e, this.stream)) {
								for (const e of this.handlers.keys()) this._setHandler(e, this.handlers.get(e));
								this._streamInactiveHandler && this._addMediaStreamInactiveHandler(this._streamInactiveHandler)
							}
						}
						_unregisterHandlers() {
							if (this.stream) {
								for (const e of this.handlers.keys())
									for (const t of this.stream.getVideoTracks()) t[Yc[e]] = void 0;
								this._streamInactiveHandler && this._addMediaStreamInactiveHandler(void 0)
							} else zc.warn(`${this}: unable to unregister handlers - no stream object`)
						}
						attach(e) {
							this.stream && (this._onTrackAttach(e), Xc.attachMediaStream(e, this.stream)), this.containers.push(e), this._maybeFireTrackAttached(e), this._attachTTFMTracker(e)
						}
						detach(e) {
							for (let t = this.containers, n = t.length - 1; n >= 0; --n) {
								const i = t[n];
								e || (this._onTrackDetach(i), Xc.attachMediaStream(i, null)), e && i !== e || t.splice(n, 1)
							}
							e && (this._onTrackDetach(e), Xc.attachMediaStream(e, null))
						}
						dispose() {
							return this.removeAllListeners(), this.disposed = !0, Promise.resolve()
						}
						getId() {
							return this.getStreamId()
						}
						getMSID() {
							const e = this.getStreamId(),
								t = this.getTrackId();
							return e && t ? `${e} ${t}` : null
						}
						getOriginalStream() {
							return this.stream
						}
						getSourceName() {}
						getStreamId() {
							return this.stream ? this.stream.id : null
						}
						getTrack() {
							return this.track
						}
						getTrackLabel() {
							return this.track.label
						}
						getTrackId() {
							return this.track ? this.track.id : null
						}
						getType() {
							return this.type
						}
						getUsageLabel() {
							return this.isAudioTrack() ? "mic" : this.videoType ? this.videoType : "default"
						}
						getVideoType() {
							return this.videoType
						}
						isActive() {
							return void 0 === this.stream.active || this.stream.active
						}
						isAudioTrack() {
							return this.getType() === _i.AUDIO
						}
						isLocal() {
							throw new Error("Not implemented by subclass")
						}
						isLocalAudioTrack() {
							return this.isAudioTrack() && this.isLocal()
						}
						isVideoTrack() {
							return this.getType() === _i.VIDEO
						}
						isWebRTCTrackMuted() {
							return this.track && this.track.muted
						}
						setAudioLevel(e, t) {
							let n = e;
							Wn.supportsReceiverStats() && void 0 !== t && this.isMuted() && (n = 0), this.audioLevel !== n ? (this.audioLevel = n, this.emit(yt, n, t)) : 0 === this.audioLevel && 0 === n && this.isLocal() && !this.isWebRTCTrackMuted() && this.emit(Rt, n)
						}
						setAudioOutput(e) {
							return Xc.isDeviceChangeAvailable("output") ? this.isVideoTrack() ? Promise.resolve() : Promise.all(this.containers.map((t => t.setSinkId(e).catch((e => {
								throw zc.warn("Failed to change audio output device on element. Default or previously set audio output device will be used.", t, e), e
							}))))).then((() => {
								this.emit(Tt, e)
							})) : Promise.reject(new Error("Audio output device change is not supported"))
						}
						setSourceName(e) {}
					}
					const Zc = (0, S.getLogger)("modules/RTC/JitsiLocalTrack.js");
					class ed extends Qc {
						constructor(e) {
							let {
								deviceId: t,
								facingMode: n,
								mediaType: i,
								resolution: s,
								rtcId: r,
								sourceId: o,
								sourceType: a,
								stream: c,
								track: d,
								videoType: l,
								effects: u = []
							} = e;
							super(null, c, d, (() => this.emit(Et, this)), i, l), this._setEffectInProgress = !1;
							const h = u.find((e => e.isEnabled(this)));
							h && this._startStreamEffect(h);
							const p = l === Ni.VideoType.DESKTOP ? d.getSettings().displaySurface : null;
							this.metadata = {
								timestamp: Date.now(),
								...p ? {
									displaySurface: p
								} : {}
							}, this.rtcId = r, this.sourceId = o, this.sourceType = null != a ? a : p, this.resolution = d.getSettings().height, this.maxEnabledResolution = s, this._constraints = d.getConstraints(), Object.keys(this._constraints).length || l !== Ni.VideoType.CAMERA || (this._constraints = {
								height: d.getSettings().height,
								width: d.getSettings().width
							}), this.deviceId = t, this._prevSetMuted = Promise.resolve(), this._facingMode = n, this._trackEnded = !1, this._hasSentData = !1, this._testDataSent = !0, this._realDeviceId = "" === this.deviceId ? void 0 : this.deviceId, this._sourceName = null, this._trackMutedTS = 0, this._onDeviceListWillChange = e => {
								const t = this._realDeviceId;
								this._setRealDeviceIdFromDeviceList(e), (void 0 === this.getTrack().readyState && void 0 !== this._realDeviceId && !e.find((e => e.deviceId === this._realDeviceId)) || void 0 !== t && void 0 === this._realDeviceId) && (this._trackEnded = !0)
							}, this.isAudioTrack() && Xc.isDeviceChangeAvailable("output") && (this._onAudioOutputDeviceChanged = this.setAudioOutput.bind(this), Xc.addListener(Oi.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged)), Xc.addListener(Oi.default.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._initNoDataFromSourceHandlers()
						}
						_addStreamToConferenceAsUnmute() {
							return this.conference ? new Promise(((e, t) => {
								this.conference._addLocalTrackToPc(this).then(e, (e => t(new Error(e))))
							})) : Promise.resolve()
						}
						_fireNoDataFromSourceEvent() {
							const e = !this.isReceivingData();
							this.emit(At, e), Pi.sendAnalytics(((e, t) => ({
								attributes: {
									media_type: e,
									value: t
								},
								action: "track.no.data.from.source",
								type: Kt.TYPE_OPERATIONAL
							}))(this.getType(), e)), Pi.sendLog(JSON.stringify({
								name: At,
								log: e
							}))
						}
						_initNoDataFromSourceHandlers() {
							this._isNoDataFromSourceEventsEnabled() && (this._setHandler("track_mute", (() => {
								this._trackMutedTS = window.performance.now(), this._fireNoDataFromSourceEvent()
							})), this._setHandler("track_unmute", (() => {
								this._fireNoDataFromSourceEvent(), Pi.sendAnalyticsAndLog(_n, {
									media_type: this.getType(),
									track_type: "local",
									value: window.performance.now() - this._trackMutedTS
								})
							})), this.isVideoTrack() && this.videoType === Ni.VideoType.CAMERA && this._setHandler("track_ended", (() => {
								this.isReceivingData() || this._fireNoDataFromSourceEvent()
							})))
						}
						_isNoDataFromSourceEventsEnabled() {
							return !this.isVideoTrack() || this.videoType !== Ni.VideoType.DESKTOP
						}
						_queueSetMuted(e) {
							const t = this._setMuted.bind(this, e);
							return this._prevSetMuted = this._prevSetMuted.then(t, t), this._prevSetMuted
						}
						_removeStreamFromConferenceAsMute(e, t) {
							this.conference ? this.conference._removeLocalTrackFromPc(this).then(e, (e => t(new Error(e)))) : e()
						}
						_sendMuteStatus(e) {
							this.conference && this.conference._setTrackMuteStatus(this.getType(), this, e) && this.conference.room.sendPresence()
						}
						_setMuted(e) {
							if (this.isMuted() === e && (this.videoType !== Ni.VideoType.DESKTOP || !Ns.isMultiStreamSendSupportEnabled())) return Promise.resolve();
							if (this.disposed) return Promise.reject(new qt(Ht));
							let t = Promise.resolve();
							const n = () => Zc.info(`Mute ${this}: ${e}`),
								i = Wn.isReactNative() ? this.videoType === Ni.VideoType.DESKTOP : Wn.doesVideoMuteByStreamRemove();
							if (this.isAudioTrack() || this.videoType === Ni.VideoType.DESKTOP && !Ns.isMultiStreamSendSupportEnabled() || !i) n(), this._streamEffect && this._streamEffect.setMuted ? this._streamEffect.setMuted(e) : this.track && (this.track.enabled = !e);
							else if (e) t = new Promise(((e, t) => {
								n(), this._removeStreamFromConferenceAsMute((() => {
									this._streamEffect && this._stopStreamEffect(), this._unregisterHandlers(), this.stopStream(), this._setStream(null), e()
								}), t)
							}));
							else {
								n();
								const e = {
									cameraDeviceId: this.getDeviceId(),
									devices: [_i.VIDEO],
									effects: this._streamEffect ? [this._streamEffect] : [],
									facingMode: this.getCameraFacingMode()
								};
								t = Xc.obtainAudioAndVideoPermissions(Object.assign({}, e, {
									constraints: {
										video: this._constraints
									}
								})), t = t.then((e => {
									const t = e.find((e => e.track.kind === this.getType()));
									if (!t) throw new qt(Bt);
									return this._setStream(t.stream), this.track = t.track, this.videoType !== t.videoType && (Zc.warn(`${this}: video type has changed after unmute!`, this.videoType, t.videoType), this.videoType = t.videoType), this._streamEffect && this._startStreamEffect(this._streamEffect), this.containers.map((e => Xc.attachMediaStream(e, this.stream))), this._addStreamToConferenceAsUnmute()
								}))
							}
							return t.then((() => {
								this._sendMuteStatus(e), this.isVideoTrack() && this.conference && this.conference._sendBridgeVideoTypeMessage(this), this.emit(Ct, this)
							}))
						}
						_setRealDeviceIdFromDeviceList(e) {
							const t = this.getTrack(),
								n = `${t.kind}input`;
							let i = e.find((e => e.kind === n && e.label === t.label && e.deviceId === this.deviceId));
							if (!i && "default" === this._realDeviceId) {
								const s = (t.label || "").replace("Default - ", "");
								i = e.find((e => e.kind === n && e.label === s))
							}
							this._realDeviceId = i ? i.deviceId : void 0
						}
						_setStream(e) {
							super._setStream(e), e ? (this.storedMSID = this.getMSID(), Zc.debug(`Setting new MSID: ${this.storedMSID} on ${this}`)) : Zc.debug(`Setting 'null' stream on ${this}`)
						}
						_startStreamEffect(e) {
							this._streamEffect = e, this._originalStream = this.stream, this._setStream(this._streamEffect.startEffect(this._originalStream)), this.track = this.stream.getTracks()[0]
						}
						_stopStreamEffect() {
							this._streamEffect && (this._streamEffect.stopEffect(), this._setStream(this._originalStream), this._originalStream = null, this.track = this.stream ? this.stream.getTracks()[0] : null)
						}
						_switchCamera() {
							this.isVideoTrack() && this.videoType === Ni.VideoType.CAMERA && "function" == typeof this.track._switchCamera && (this.track._switchCamera(), this._facingMode = this._facingMode === Ra().ENVIRONMENT ? Ra().USER : Ra().ENVIRONMENT)
						}
						_switchStreamEffect(e) {
							this._streamEffect && (this._stopStreamEffect(), this._streamEffect = void 0), e && this._startStreamEffect(e)
						}
						async dispose() {
							return this._streamEffect && await this.setEffect(), this.conference && await this.conference.removeTrack(this), this.stream && (this.stopStream(), this.detach()), Xc.removeListener(Oi.default.DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._onAudioOutputDeviceChanged && Xc.removeListener(Oi.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged), super.dispose()
						}
						getCameraFacingMode() {
							if (this.isVideoTrack() && this.videoType === Ni.VideoType.CAMERA) {
								var e, t;
								const n = null === (e = (t = this.track).getSettings) || void 0 === e ? void 0 : e.call(t);
								return n && "facingMode" in n ? n.facingMode : void 0 !== this._facingMode ? this._facingMode : Ra().USER
							}
						}
						getDeviceId() {
							return this._realDeviceId || this.deviceId
						}
						getDuration() {
							return Date.now() / 1e3 - this.metadata.timestamp / 1e3
						}
						getParticipantId() {
							return this.conference && this.conference.myUserId()
						}
						getSourceName() {
							return this._sourceName
						}
						isEnded() {
							return this.isVideoTrack() && this.isMuted() ? this._trackEnded : "ended" === this.getTrack().readyState || this._trackEnded
						}
						isLocal() {
							return !0
						}
						isMuted() {
							return !this.stream || !(!this.isVideoTrack() || this.isActive()) || (this._streamEffect && this._streamEffect.isMuted ? this._streamEffect.isMuted() : !this.track || !this.track.enabled)
						}
						isReceivingData() {
							return !(!this.isVideoTrack() || !this.isMuted() && !this._stopStreamInProgress && this.videoType !== Ni.VideoType.DESKTOP) || !!this.stream && (this._effectEnabled ? this._originalStream : this.stream).getTracks().some((e => !("readyState" in e && "live" !== e.readyState || "muted" in e && !0 === e.muted)))
						}
						mute() {
							return this._queueSetMuted(!0)
						}
						onByteSentStatsReceived(e, t) {
							t > 0 && (this._hasSentData = !0);
							const n = e.getConnectionState();
							this._testDataSent && "connected" === n && (setTimeout((() => {
								this._hasSentData || (Zc.warn(`${this} 'bytes sent' <= 0:                         ${t}`), Pi.analytics.sendEvent(gn, {
									media_type: this.getType()
								}))
							}), 3e3), this._testDataSent = !1)
						}
						setConference(e) {
							this.conference = e;
							for (let e = 0; e < this.containers.length; e++) this._maybeFireTrackAttached(this.containers[e])
						}
						setEffect(e) {
							if (void 0 === this._streamEffect && void 0 === e) return Promise.resolve();
							if (void 0 !== e && !e.isEnabled(this)) return Promise.reject(new Error("Incompatible effect instance!"));
							if (!0 === this._setEffectInProgress) return Promise.reject(new Error("setEffect already in progress!"));
							if (this.isMuted() && !this.isAudioTrack()) return this._streamEffect = e, Promise.resolve();
							const t = this.conference;
							return t ? (this._setEffectInProgress = !0, t._removeLocalTrackFromPc(this).then((() => (this._switchStreamEffect(e), this.isVideoTrack() && this.containers.forEach((e => Xc.attachMediaStream(e, this.stream))), t._addLocalTrackToPc(this)))).then((() => {
								this._setEffectInProgress = !1
							})).catch((e => {
								throw this._setEffectInProgress = !1, this._switchStreamEffect(), Zc.error("Failed to switch to the new stream!", e), e
							}))) : (this._switchStreamEffect(e), this.isVideoTrack() && this.containers.forEach((e => Xc.attachMediaStream(e, this.stream))), Promise.resolve())
						}
						setSourceName(e) {
							this._sourceName = e
						}
						stopStream() {
							this._stopStreamInProgress = !0;
							try {
								Xc.stopMediaStream(this.stream)
							} finally {
								this._stopStreamInProgress = !1
							}
						}
						toString() {
							return `LocalTrack[${this.rtcId},${this.getType()}]`
						}
						unmute() {
							return this._queueSetMuted(!1)
						}
					}
					var td = n(6561);
					const nd = function(e, t) {
							return void 0 !== e && void 0 !== e.media && Array.isArray(e.media) && e.media.forEach((e => {
								e.sources && e.sources.length && (e.ssrcs = [], e.sources.forEach((t => {
									Object.keys(t).forEach((n => {
										"id" !== n && e.ssrcs.push({
											id: t.id,
											attribute: n,
											value: t[n]
										})
									}))
								})), delete e.sources), e.ssrcGroups && e.ssrcGroups.length && e.ssrcGroups.forEach((e => {
									void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.ssrcs = e.ssrcs.join(" "))
								}))
							})), td.write(e, t)
						},
						id = function(e) {
							const t = td.parse(e);
							return void 0 !== t && void 0 !== t.media && Array.isArray(t.media) && t.media.forEach((e => {
								void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.sources = [], e.ssrcs.forEach((t => {
									const n = e.sources.findIndex((e => e.id === t.id));
									if (n > -1) e.sources[n][t.attribute] = t.value;
									else {
										const n = {
											id: t.id
										};
										n[t.attribute] = t.value, e.sources.push(n)
									}
								})), delete e.ssrcs), void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach((e => {
									"string" == typeof e.ssrcs && (e.ssrcs = e.ssrcs.split(" "))
								}))
							})), t
						},
						sd = ["audio", "video", "data"],
						rd = e => e.find((e => "SIM" === e.semantics)),
						od = e => e.find((e => "FID" === e.semantics));

					function ad(e, t, n, i) {
						if (!e || !t) return;
						const s = e => i.find((t => t.id.toString() === e));
						t.ssrcs.forEach((t => {
							e.sources.push(s(t));
							const i = n[parseInt(t, 10)].find((e => "FID" === e.semantics));
							if (i) {
								const n = i.ssrcs.find((e => e !== t));
								e.sources.push(s(n)), e.ssrcGroups.push(i)
							}
						})), e.ssrcGroups.push(t)
					}

					function cd(e, t, n, i) {
						if (!e || !t) return;
						if (e.sources = [], e.ssrcGroups = [], !n[t.id]) return e.sources.push(t), void(e.msid = t.msid);
						const s = rd(n[t.id]),
							r = od(n[t.id]);
						if (s) ad(e, s, n, i);
						else if (r) {
							const s = r.ssrcs.find((e => e !== t)),
								o = rd(n[s]);
							o ? ad(e, o, n, i) : (r.ssrcs.forEach((t => {
								e.sources.push((e => i.find((t => t.id.toString() === e)))(t))
							})), e.ssrcGroups.push(r))
						}
						e.msid = e.sources[0].msid
					}

					function dd(e, t, n) {
						if (!n.find((t => !!t.sources && t.sources.some((t => t.id === e.id))))) {
							if (!t[e.id]) return !1;
							const i = rd(t[e.id]),
								s = od(t[e.id]);
							return i ? n.some((e => e.sources && e.sources.some((e => e.id.toString() === i.ssrcs[0])))) : !(!s || e.id.toString() === s.ssrcs[0]) && dd({
								id: s.ssrcs[0]
							}, t, n)
						}
						return !0
					}
					class ld {
						toPlanB(e) {
							if (!e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
							const t = id(e.sdp);
							if (!t.media || !t.media.length) return console.warn("The description has no media."), e;
							if (t.media.every((e => -1 !== sd.indexOf(e.mid)))) return console.warn("The description does not look like unified plan sdp"), e;
							const n = {},
								i = t.media;
							t.media = [], i.forEach((e => {
								const t = e.type;
								if ("application" === t) return e.mid = "data", void(n[e.mid] = e);
								if (void 0 === n[t]) {
									const i = qr(e);
									i.sources && Array.isArray(i.sources) && i.sources.forEach((t => {
										e.msid ? t.msid = e.msid : delete t.msid
									})), i.ssrcGroups && e.msid || (i.ssrcGroups = []), delete i.msid, i.mid = t, n[t] = i
								} else if (e.msid) {
									const i = qr(e);
									i.sources && Array.isArray(i.sources) && (i.sources.forEach((t => {
										t.msid = e.msid
									})), n[t].sources = (n[t].sources || []).concat(i.sources)), void 0 !== i.ssrcGroups && Array.isArray(i.ssrcGroups) && (n[t].ssrcGroups = (n[t].ssrcGroups || []).concat(i.ssrcGroups))
								}
							})), t.media = Object.values(n);
							const s = [];
							Object.values(n).forEach((e => {
								"inactive" !== e.direction && s.push(e.mid)
							})), t.groups.forEach((e => {
								"BUNDLE" === e.type && (e.mids = s.join(" "))
							})), t.msidSemantic = {
								semantic: "WMS",
								token: "*"
							};
							const r = nd(t);
							return new RTCSessionDescription({
								type: e.type,
								sdp: r
							})
						}
						toUnifiedPlan(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
							if (!e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
							const n = id(e.sdp);
							if (!n.media || !n.media.length) return console.warn("The description has no media."), e;
							if (n.media.length > 3 || n.media.every((e => -1 === sd.indexOf(e.mid)))) return console.warn("The description does not look like plan-b"), e;
							const i = t ? id(t.sdp) : null,
								s = function(e, t) {
									if (!e || !t || 0 === e.media.length || 0 === t.media.length) return !1;
									const n = e.media[0],
										i = t.media[0];
									return n.iceUfrag !== i.iceUfrag || n.icePwd !== i.icePwd
								}(n, i),
								r = n.media[0].iceUfrag,
								o = n.media[0].icePwd,
								a = n.media[0].fingerprint,
								c = {};
							n.media.forEach((e => {
								const t = e.type;
								if ("application" === t) {
									if (!i || !i.media) {
										const t = qr(e);
										return t.mid = Object.keys(c).length.toString(), void(c[e.mid] = t)
									}
									const n = i.media.findIndex((e => e.type === t));
									return void(n && (i.media[n] = e, i.media[n].mid = n))
								}
								const n = function(e) {
									const t = {};
									return e && Array.isArray(e) ? (e.forEach((e => {
										e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach((n => {
											void 0 === t[n] && (t[n] = []), t[n].push(e)
										}))
									})), t) : t
								}(e.ssrcGroups);
								if (e.sources) e.sources.forEach(((t, s) => {
									if (!t.msid) return;
									if (!i || !i.media) {
										if (dd(t, n, Object.values(c))) return;
										const i = qr(e);
										return i.mid = Object.keys(c).length.toString(), i.direction = s || "sendonly" === e.direction ? "sendonly" : "sendrecv", i.bundleOnly = void 0, cd(i, t, n, e.sources), void(c[i.mid] = i)
									}
									if (dd(t, n, i.media)) return;
									const r = qr(e);
									r.mid = i.media.length.toString(), r.direction = "sendonly", cd(r, t, n, e.sources), i.media.push(r)
								}));
								else if (!i) {
									const t = qr(e);
									t.mid = Object.keys(c).length.toString(), c[e.mid] = t
								}
							})), n.media = i ? i.media : Object.values(c);
							const d = [];
							n.media.forEach((e => {
								d.push(e.mid), s && (e.iceUfrag = r, e.icePwd = o, e.fingerprint = a)
							})), n.groups.forEach((e => {
								"BUNDLE" === e.type && (e.mids = d.join(" "))
							})), n.msidSemantic = {
								semantic: "WMS",
								token: "*"
							}, n.origin.sessionVersion++;
							const l = nd(n);
							return new RTCSessionDescription({
								type: e.type,
								sdp: l
							})
						}
					}
					let ud;
					! function(e) {
						e.PEER_MUTED_CHANGED = "signaling.peerMuted", e.PEER_VIDEO_TYPE_CHANGED = "signaling.peerVideoType", e.SOURCE_MUTED_CHANGED = "signaling.sourceMuted", e.SOURCE_UPDATED = "signaling.sourceUpdated", e.SOURCE_VIDEO_TYPE_CHANGED = "signaling.sourceVideoType"
					}(ud || (ud = {}));
					const hd = ud.PEER_MUTED_CHANGED,
						pd = ud.PEER_VIDEO_TYPE_CHANGED,
						md = ud.SOURCE_MUTED_CHANGED,
						fd = ud.SOURCE_UPDATED,
						gd = ud.SOURCE_VIDEO_TYPE_CHANGED;

					function _d(e, t, n) {
						return `${e}-${t.substring(0,1)}${n}`
					}

					function vd(e) {
						const t = e.lastIndexOf("-") + 1;
						if (t <= 0) throw new Error(`Invalid source name: ${e}`);
						const n = e.substr(t, 1);
						for (const e of Object.values(_i))
							if (e.substr(0, 1) === n) return e;
						throw new Error(`Invalid source name: ${e}`)
					}

					function Sd(e) {
						const t = e.split("-"),
							n = Number(t[t.length - 1].substring(1));
						if (Number.isNaN(n)) throw new Error(`Failed to parse track idx for source name: ${e}`);
						return n
					}
					class Ed extends Yi {
						getPeerMediaInfo(e, t, n) {
							throw new Error("not implemented")
						}
						getPeerSourceInfo(e, t) {
							throw new Error("not implemented")
						}
						getSSRCOwner(e) {
							throw new Error("not implemented")
						}
						getTrackSourceName(e) {
							throw new Error("not implemented")
						}
						removeSSRCOwners(e) {}
						setSSRCOwner(e, t) {}
						setTrackMuteStatus(e, t) {}
						setTrackSourceName(e, t) {}
						setTrackVideoType(e, t) {}
						updateSsrcOwnersOnLeave(e) {}
					}

					function yd(e) {
						return parseInt(e.ssrcs.split(" ")[0], 10)
					}

					function Td(e) {
						return parseInt(e.ssrcs.split(" ")[1], 10)
					}

					function Cd(e) {
						return e.ssrcs ? e.ssrcs.map((e => e.id)).filter(((e, t, n) => n.indexOf(e) === t)).length : 0
					}
					class bd {
						constructor(e) {
							if (!e) throw new Error("mLine is undefined");
							this.mLine = e
						}
						get ssrcs() {
							return this.mLine.ssrcs || (this.mLine.ssrcs = []), this.mLine.ssrcs
						}
						set ssrcs(e) {
							this.mLine.ssrcs = e
						}
						get direction() {
							return this.mLine.direction
						}
						set direction(e) {
							this.mLine.direction = e
						}
						get ssrcGroups() {
							return this.mLine.ssrcGroups || (this.mLine.ssrcGroups = []), this.mLine.ssrcGroups
						}
						set ssrcGroups(e) {
							this.mLine.ssrcGroups = e
						}
						getSSRCAttrValue(e, t) {
							const n = this.ssrcs.find((n => n.id === e && n.attribute === t));
							return n && n.value
						}
						removeSSRC(e) {
							this.mLine.ssrcs && this.mLine.ssrcs.length && (this.mLine.ssrcs = this.mLine.ssrcs.filter((t => t.id !== e)))
						}
						addSSRCAttribute(e) {
							this.ssrcs.push(e)
						}
						findGroup(e, t) {
							return this.ssrcGroups.find((n => n.semantics === e && (!t || t === n.ssrcs)))
						}
						findGroups(e) {
							return this.ssrcGroups.filter((t => t.semantics === e))
						}
						findGroupByPrimarySSRC(e, t) {
							return this.ssrcGroups.find((n => n.semantics === e && yd(n) === t))
						}
						findSSRCByMSID(e) {
							return this.ssrcs.find((t => "msid" === t.attribute && (null === e || t.value === e)))
						}
						getSSRCCount() {
							return Cd(this.mLine)
						}
						containsAnySSRCGroups() {
							return void 0 !== this.mLine.ssrcGroups
						}
						getPrimaryVideoSsrc() {
							const e = this.mLine.type;
							if ("video" !== e) throw new Error(`getPrimarySsrc doesn't work with '${e}'`);
							if (1 === Cd(this.mLine)) return this.mLine.ssrcs[0].id;
							if (this.mLine.ssrcGroups) {
								const e = this.findGroup("SIM");
								if (e) return yd(e);
								const t = this.findGroup("FID");
								if (t) return yd(t);
								const n = this.findGroup("FEC-FR");
								if (n) return yd(n)
							}
						}
						getRtxSSRC(e) {
							const t = this.findGroupByPrimarySSRC("FID", e);
							return t && Td(t)
						}
						getSSRCs() {
							return this.ssrcs.map((e => e.id)).filter(((e, t, n) => n.indexOf(e) === t))
						}
						getPrimaryVideoSSRCs() {
							const e = this.mLine.type;
							if ("video" !== e) throw new Error(`getPrimaryVideoSSRCs doesn't work with ${e}`);
							const t = this.getSSRCs();
							for (const e of this.ssrcGroups)
								if ("FID" === e.semantics || "FEC-FR" === e.semantics) {
									const n = Td(e);
									t.splice(t.indexOf(n), 1)
								} return t
						}
						dumpSSRCGroups() {
							return JSON.stringify(this.mLine.ssrcGroups)
						}
						removeGroupsWithSSRC(e) {
							this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter((t => -1 === t.ssrcs.indexOf(`${e}`))))
						}
						removeGroupsBySemantics(e) {
							this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter((t => t.semantics !== e)))
						}
						replaceSSRC(e, t) {
							this.mLine.ssrcs && this.mLine.ssrcs.forEach((n => {
								n.id === e && (n.id = t)
							}))
						}
						addSSRCGroup(e) {
							this.ssrcGroups.push(e)
						}
					}
					class Ad {
						constructor(e) {
							this.parsedSDP = Wr.parse(e)
						}
						selectMedia(e) {
							const t = this.parsedSDP.media.filter((t => t.type === e)).map((e => new bd(e)));
							return null != t ? t : null
						}
						toRawSDP() {
							return Wr.write(this.parsedSDP)
						}
					}
					const Rd = (0, S.getLogger)("modules/sdp/LocalSdpMunger.js");
					class Id {
						constructor(e, t) {
							this.tpc = e, this.localEndpointId = t, this.audioSourcesToMsidMap = new Map, this.videoSourcesToMsidMap = new Map
						}
						_addMutedLocalVideoTracksToSDP(e) {
							var t;
							const n = this.tpc.getLocalTracks(_i.VIDEO);
							if (!n.length) return !1;
							1 !== n.length && Rd.error(`${this.tpc} there is more than 1 video track ! Strange things may happen !`, n);
							const i = null === (t = e.selectMedia(_i.VIDEO)) || void 0 === t ? void 0 : t[0];
							if (!i) return Rd.debug(`${this.tpc} unable to hack local video track SDP- no "video" media`), !1;
							let s = !1;
							for (const e of n) {
								const t = e.isMuted(),
									n = e.getOriginalStream(),
									r = e.videoType === Ni.VideoType.CAMERA,
									o = n && this.tpc.isMediaStreamInPc(n);
								if (!r || !t && o) continue;
								const a = this.tpc.isSimulcastOn() ? this.tpc.simulcast.ssrcCache : [this.tpc.sdpConsistency.cachedPrimarySsrc];
								if (!a.length) {
									Rd.error(`No SSRCs stored for: ${e} in ${this.tpc}`);
									continue
								}
								s = !0, i.direction = Br.SENDRECV;
								const c = `injected-${a[0]}`;
								for (const t of a) i.removeSSRC(t), i.addSSRCAttribute({
									id: t,
									attribute: "cname",
									value: c
								}), i.addSSRCAttribute({
									id: t,
									attribute: "msid",
									value: e.storedMSID
								});
								if (a.length > 1) {
									const e = {
										ssrcs: a.join(" "),
										semantics: "SIM"
									};
									i.findGroup(e.semantics, e.ssrcs) || i.addSSRCGroup(e)
								}
								this.tpc.options.disableRtx || this.tpc.rtxModifier.modifyRtxSsrcs2(i)
							}
							return s
						}
						_generateMsidAttribute(e, t) {
							let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
							if (!e || !t) return Rd.error(`Unable to munge local MSID - track id=${t} or media type=${e} is missing`), null;
							const i = this.tpc.id;
							return "-" !== n && n ? `${n}-${i} ${t}-${i}` : `${this.localEndpointId}-${e}-${i} ${t}-${i}`
						}
						_transformMediaIdentifiers(e) {
							var t, n, i, s, r;
							const o = null === (t = e.mLine) || void 0 === t ? void 0 : t.type,
								a = this.tpc.id;
							for (const t of e.ssrcs) switch (t.attribute) {
								case "cname":
								case "label":
								case "mslabel":
									t.value = t.value && `${t.value}-${a}`;
									break;
								case "msid":
									if (t.value) {
										const e = t.value.split(" ");
										let n = e[0];
										const i = e[1];
										n = `${this.localEndpointId}-${o}`, o === _i.VIDEO ? this.videoSourcesToMsidMap.has(i) || (n = `${n}-${this.videoSourcesToMsidMap.size}`, this.videoSourcesToMsidMap.set(i, n)) : this.audioSourcesToMsidMap.has(i) || (n = `${n}-${this.audioSourcesToMsidMap.size}`, this.audioSourcesToMsidMap.set(i, n)), n = o === _i.VIDEO ? this.videoSourcesToMsidMap.get(i) : this.audioSourcesToMsidMap.get(i), t.value = this._generateMsidAttribute(o, i, n)
									} else Rd.warn(`Unable to munge local MSID - weird format detected: ${t.value}`)
							}
							if (!this.tpc.usesUnifiedPlan()) return;
							const c = null === (n = e.mLine) || void 0 === n ? void 0 : n.direction;
							!Wn.isFirefox() || c !== Br.RECVONLY && c !== Br.INACTIVE || (o !== _i.VIDEO || this.tpc._hasHadVideoTrack) && (o !== _i.AUDIO || this.tpc._hasHadAudioTrack) || (e.ssrcs = void 0, e.ssrcGroups = void 0);
							const d = null === (i = e.mLine) || void 0 === i ? void 0 : i.msid,
								l = d && d.split(" ")[1],
								u = [...new Set(null === (s = e.mLine) || void 0 === s || null === (r = s.ssrcs) || void 0 === r ? void 0 : r.map((e => e.id)))];
							for (const t of u)
								if (!e.ssrcs.find((e => e.id === t && "msid" === e.attribute)) && l) {
									const n = this._generateMsidAttribute(o, l);
									e.ssrcs.push({
										id: t,
										attribute: "msid",
										value: n
									})
								}
						}
						maybeAddMutedLocalVideoTracksToSDP(e) {
							if (!e) throw new Error("No local description passed in.");
							const t = new Ad(e.sdp);
							return this._addMutedLocalVideoTracksToSDP(t) ? new RTCSessionDescription({
								type: e.type,
								sdp: t.toRawSDP()
							}) : e
						}
						transformStreamIdentifiers(e) {
							var t;
							if (!e || !e.sdp || !e.type) return e;
							const n = new Ad(e.sdp),
								i = null === (t = n.selectMedia(_i.AUDIO)) || void 0 === t ? void 0 : t[0];
							i && (this._transformMediaIdentifiers(i), this._injectSourceNames(i));
							const s = n.selectMedia(_i.VIDEO);
							Ns.isMultiStreamSendSupportEnabled() || s.splice(1);
							for (const e of s) this._transformMediaIdentifiers(e), this._injectSourceNames(e);
							return this.tpc._usesUnifiedPlan || (this.audioSourcesToMsidMap.clear(), this.videoSourcesToMsidMap.clear()), new RTCSessionDescription({
								type: e.type,
								sdp: n.toRawSDP()
							})
						}
						_injectSourceNames(e) {
							var t, n, i;
							const s = [...new Set(null === (t = e.mLine) || void 0 === t || null === (n = t.ssrcs) || void 0 === n ? void 0 : n.map((e => e.id)))],
								r = null === (i = e.mLine) || void 0 === i ? void 0 : i.type;
							if (!r) throw new Error("_transformMediaIdentifiers - no media type in mediaSection");
							for (const t of s) {
								var o;
								const n = e.ssrcs.find((e => e.id === t && "name" === e.attribute)),
									i = null === (o = e.ssrcs.find((e => e.id === t && "msid" === e.attribute))) || void 0 === o ? void 0 : o.value;
								let s;
								if (i) {
									const e = i.split(" ")[0].split("-");
									s = e[e.length - 2]
								}
								const c = _d(this.localEndpointId, r, s);
								if (n || e.ssrcs.push({
										id: t,
										attribute: "name",
										value: c
									}), r === _i.VIDEO) {
									var a;
									const n = null === (a = this.tpc.getLocalVideoTracks().find((e => e.getSourceName() === c))) || void 0 === a ? void 0 : a.getVideoType();
									n && e.ssrcs.push({
										id: t,
										attribute: "videoType",
										value: n
									})
								}
							}
						}
					}
					const Pd = (0, S.getLogger)("modules/sdp/RtxModifier.js");

					function Dd(e, t, n) {
						const i = t.id,
							s = t.msid,
							r = t.cname,
							o = e.getRtxSSRC(i);
						o !== n && (o && (e.removeSSRC(o), e.removeGroupsWithSSRC(o)), e.addSSRCAttribute({
							id: n,
							attribute: "cname",
							value: r
						}), e.addSSRCAttribute({
							id: n,
							attribute: "msid",
							value: s
						}), e.addSSRCGroup({
							semantics: "FID",
							ssrcs: `${i} ${n}`
						}))
					}
					class wd {
						constructor() {
							this.correspondingRtxSsrcs = new Map
						}
						clearSsrcCache() {
							this.correspondingRtxSsrcs.clear()
						}
						setSsrcCache(e) {
							Pd.debug("Setting ssrc cache to ", e), this.correspondingRtxSsrcs = e
						}
						modifyRtxSsrcs(e) {
							let t = !1;
							const n = new Ad(e),
								i = n.selectMedia(_i.VIDEO);
							if (null == i || !i.length) return Pd.debug(`No 'video' media found in the sdp: ${e}`), e;
							for (const e of i) this.modifyRtxSsrcs2(e) && (t = !0);
							return t ? n.toRawSDP() : e
						}
						modifyRtxSsrcs2(e) {
							if (e.direction === Br.RECVONLY) return !1;
							if (e.getSSRCCount() < 1) return !1;
							const t = e.getPrimaryVideoSSRCs();
							for (const n of t) {
								const t = e.getSSRCAttrValue(n, "msid"),
									i = e.getSSRCAttrValue(n, "cname");
								let s = this.correspondingRtxSsrcs.get(n);
								if (!s) {
									s = e.getRtxSSRC(n) || Yr.generateSsrc(), this.correspondingRtxSsrcs.set(n, s)
								}
								Dd(e, {
									id: n,
									cname: i,
									msid: t
								}, s)
							}
							return !0
						}
						stripRtx(e) {
							const t = new Ad(e),
								n = t.selectMedia(_i.VIDEO);
							if (null == n || !n.length) return Pd.debug(`No 'video' media found in the sdp: ${e}`), e;
							for (const e of n)
								if (e.direction !== Br.RECVONLY && e.getSSRCCount() && e.containsAnySSRCGroups()) {
									const t = e.findGroups("FID");
									e.removeGroupsBySemantics("FID");
									for (const n of t) {
										const t = Td(n);
										e.removeSSRC(t)
									}
								} return t.toRawSDP()
						}
					}
					const Od = (0, S.getLogger)("modules/sdp/SdpConsistency.js");
					class Nd {
						constructor(e) {
							this.clearVideoSsrcCache(), this.logPrefix = e
						}
						clearVideoSsrcCache() {
							this.cachedPrimarySsrc = null, this.injectRecvOnly = !1
						}
						setPrimarySsrc(e) {
							if ("number" != typeof e) throw new Error("Primary SSRC must be a number!");
							this.cachedPrimarySsrc = e
						}
						hasPrimarySsrcCached() {
							return Boolean(this.cachedPrimarySsrc)
						}
						makeVideoPrimarySsrcsConsistent(e) {
							var t;
							const n = new Ad(e),
								i = null === (t = n.selectMedia(_i.VIDEO)) || void 0 === t ? void 0 : t[0];
							if (!i) return Od.debug(`${this.logPrefix} no 'video' media found in the sdp: ${e}`), e;
							if ("recvonly" === i.direction) this.cachedPrimarySsrc && this.injectRecvOnly ? i.addSSRCAttribute({
								id: this.cachedPrimarySsrc,
								attribute: "cname",
								value: `recvonly-${this.cachedPrimarySsrc}`
							}) : Od.info(`${this.logPrefix} no SSRC found for the recvonly video stream!`);
							else {
								const t = i.getPrimaryVideoSsrc();
								if (!t) return Od.info(`${this.logPrefix} sdp-consistency couldn't parse new primary ssrc`), e;
								if (this.cachedPrimarySsrc) {
									i.replaceSSRC(t, this.cachedPrimarySsrc);
									for (const e of i.ssrcGroups)
										if ("FID" === e.semantics) {
											const n = yd(e),
												i = Td(e);
											n === t && (e.ssrcs = `${this.cachedPrimarySsrc} ${i}`)
										}
								} else this.cachedPrimarySsrc = t;
								this.injectRecvOnly = !0
							}
							return n.toRawSDP()
						}
					}
					class Md {
						constructor(e) {
							this._options = e, this._ssrcCache = new Map, this._options.numOfLayers || (this._options.numOfLayers = 3)
						}
						_fillSsrcsFromCache(e) {
							const t = e.mid,
								n = this._ssrcCache.get(t),
								i = this._parseSimLayers(e),
								s = this._getSsrcAttribute(e, i[0], "msid"),
								r = this._getSsrcAttribute(e, i[0], "cname");
							e.ssrcs = [], e.ssrcGroups = [];
							for (const t of n) e.ssrcs.push({
								id: t,
								attribute: "msid",
								value: s
							}), e.ssrcs.push({
								id: t,
								attribute: "cname",
								value: r
							});
							return e.ssrcGroups.push({
								semantics: "SIM",
								ssrcs: n.join(" ")
							}), e
						}
						_generateNewSsrcsForSimulcast(e, t) {
							const n = this._getSsrcAttribute(e, t, "cname");
							let i = this._getSsrcAttribute(e, t, "msid");
							const s = (e, t) => {
								e.ssrcs.push({
									id: t,
									attribute: "cname",
									value: n
								}), e.ssrcs.push({
									id: t,
									attribute: "msid",
									value: i
								})
							};
							i || (i = e.msid, e.ssrcs.forEach((t => {
								e.ssrcs.push({
									id: t.id,
									attribute: "msid",
									value: i
								})
							})));
							const r = [];
							for (let t = 0; t < this._options.numOfLayers - 1; ++t) {
								const t = this._generateSsrc();
								s(e, t), r.push(t)
							}
							return e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
								semantics: "SIM",
								ssrcs: t + " " + r.join(" ")
							}), e
						}
						_generateSsrc() {
							return Math.floor(4294967295 * Math.random())
						}
						_getSsrcAttribute(e, t, n) {
							var i, s;
							return null === (i = e.ssrcs) || void 0 === i || null === (s = i.find((e => Number(e.id) === t && e.attribute === n))) || void 0 === s ? void 0 : s.value
						}
						_parseSimLayers(e) {
							var t, n;
							const i = null === (t = e.ssrcGroups) || void 0 === t ? void 0 : t.find((e => "SIM" === e.semantics));
							return i ? i.ssrcs.split(" ").map((e => Number(e))) : null !== (n = e.ssrcs) && void 0 !== n && n.length ? [Number(e.ssrcs[0].id)] : null
						}
						mungeLocalDescription(e) {
							if (!e || !e.sdp) return e;
							const t = Wr.parse(e.sdp);
							for (let e of t.media) {
								var n, i, s;
								if (e.direction === Br.RECVONLY || e.direction === Br.INACTIVE) continue;
								if (e.type !== _i.VIDEO) continue;
								const t = e.mid,
									o = new Set(null === (n = e.ssrcs) || void 0 === n ? void 0 : n.map((e => e.id))),
									a = null !== (i = null === (s = e.ssrcGroups) || void 0 === s ? void 0 : s.length) && void 0 !== i ? i : 0;
								let c;
								if (!(0 === o.size || o.size > 2 || 2 === o.size && 0 === a)) {
									if (1 === o.size) {
										var r;
										c = Number(null === (r = e.ssrcs[0]) || void 0 === r ? void 0 : r.id)
									} else {
										const t = e.ssrcGroups.find((e => "FID" === e.semantics));
										t && (c = Number(t.ssrcs.split(" ")[0]))
									}
									if (this._ssrcCache.has(t)) e = this._fillSsrcsFromCache(e);
									else {
										e = this._generateNewSsrcsForSimulcast(e, c);
										const n = this._parseSimLayers(e);
										this._ssrcCache.set(t, n)
									}
								}
							}
							return new RTCSessionDescription({
								type: e.type,
								sdp: Wr.write(t)
							})
						}
					}
					let Ld;
					! function(e) {
						e.ACTIVE = "active", e.INACTIVE = "inactive", e.INTERRUPTED = "interrupted", e.RESTORING = "restoring"
					}(Ld || (Ld = {}));
					const kd = (0, S.getLogger)("modules/connectivity/TrackStreamingStatus.ts");
					class xd {
						static _getNewStateForJvbMode(e, t, n, i) {
							return n ? Ld.ACTIVE : Wn.supportsVideoMuteOnConnInterrupted() ? i ? e ? t ? Ld.INTERRUPTED : Ld.RESTORING : Ld.INACTIVE : Ld.ACTIVE : e ? Ld.ACTIVE : Ld.INACTIVE
						}
						static _getNewStateForP2PMode(e, t) {
							return Wn.supportsVideoMuteOnConnInterrupted() ? e || !t ? Ld.ACTIVE : Ld.INTERRUPTED : Ld.ACTIVE
						}
						constructor(e, t, n, i) {
							this.rtc = e, this.conference = t, this.track = n, this.restoringTimer = null, this.rtcMutedTimestamp = null, this.streamingStatusMap = {}, this.trackTimer = null, this.outOfForwardedSourcesTimeout = "number" == typeof i.outOfForwardedSourcesTimeout ? i.outOfForwardedSourcesTimeout : 500, this.p2pRtcMuteTimeout = "number" == typeof i.p2pRtcMuteTimeout ? i.p2pRtcMuteTimeout : 2500, this.rtcMuteTimeout = "number" == typeof i.rtcMuteTimeout ? i.rtcMuteTimeout : 1e4, kd.info(`RtcMuteTimeout set to: ${this.rtcMuteTimeout}`)
						}
						_getVideoFrozenTimeout() {
							const e = this.track.getSourceName();
							return this.rtc.isInForwardedSources(e) ? this.rtcMuteTimeout : this.conference.isP2PActive() ? this.p2pRtcMuteTimeout : this.outOfForwardedSourcesTimeout
						}
						init() {
							this._onP2PStatus = this.figureOutStreamingStatus.bind(this), this.conference.on($.P2P_STATUS, this._onP2PStatus), this._onUserLeft = this.onUserLeft.bind(this), this.conference.on($.USER_LEFT, this._onUserLeft), Wn.supportsVideoMuteOnConnInterrupted() && (this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this), this.rtc.addListener(Oi.default.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this), this.rtc.addListener(Oi.default.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this._onSignallingMuteChanged = this.onSignallingMuteChanged.bind(this), this.track.on(Ct, this._onSignallingMuteChanged), this._onTrackVideoTypeChanged = this.onTrackVideoTypeChanged.bind(this), this.track.on(bt, this._onTrackVideoTypeChanged)), this._onForwardedSourcesChanged = this.onForwardedSourcesChanged.bind(this), this.conference.on($.FORWARDED_SOURCES_CHANGED, this._onForwardedSourcesChanged), this._onLastNValueChanged = this.figureOutStreamingStatus.bind(this), this.rtc.on(Oi.default.LASTN_VALUE_CHANGED, this._onLastNValueChanged)
						}
						dispose() {
							Wn.supportsVideoMuteOnConnInterrupted() && (this.rtc.removeListener(Oi.default.REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this.rtc.removeListener(Oi.default.REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this.track.off(Ct, this._onSignallingMuteChanged)), this.conference.off($.FORWARDED_SOURCES_CHANGED, this._onForwardedSourcesChanged), this.conference.off($.P2P_STATUS, this._onP2PStatus), this.conference.off($.USER_LEFT, this._onUserLeft), this.rtc.removeListener(Oi.default.LASTN_VALUE_CHANGED, this._onLastNValueChanged), this.clearTimeout(), this.clearRtcMutedTimestamp(), this.maybeSendTrackStreamingStatusEvent(Date.now()), this.figureOutStreamingStatus()
						}
						_changeStreamingStatus(e) {
							if (this.track.getTrackStreamingStatus() !== e) {
								const t = this.track.getSourceName();
								this.track._setTrackStreamingStatus(e), kd.debug(`Emit track streaming status(${Date.now()}) ${t}: ${e}`), Pi.sendLog(JSON.stringify({
									id: "track.streaming.status",
									track: t,
									status: e
								})), this.track.emit(It, this.track, e)
							}
						}
						clearTimeout() {
							this.trackTimer && (window.clearTimeout(this.trackTimer), this.trackTimer = null)
						}
						clearRtcMutedTimestamp() {
							this.rtcMutedTimestamp = null
						}
						isVideoTrackFrozen() {
							if (!Wn.supportsVideoMuteOnConnInterrupted()) return !1;
							const e = this.track.isWebRTCTrackMuted(),
								t = this.rtcMutedTimestamp,
								n = this._getVideoFrozenTimeout();
							return e && "number" == typeof t && Date.now() - t >= n
						}
						figureOutStreamingStatus() {
							const e = this.track.getSourceName(),
								t = this.conference.isP2PActive(),
								n = this._isRestoringTimedout(),
								i = 0 === this.conference.getLastN(),
								s = this.track.isMuted() || i,
								r = this.isVideoTrackFrozen(),
								o = this.rtc.isInForwardedSources(e),
								a = t ? xd._getNewStateForP2PMode(s, r) : xd._getNewStateForJvbMode(o, n, s, r);
							a !== Ld.RESTORING && this._clearRestoringTimer(), kd.debug(`Figure out conn status for ${e}, is video muted: ${s} video track frozen: ${r} p2p mode: ${t} is in forwarded sources: ${o} currentStatus => newStatus: ${this.track.getTrackStreamingStatus()} => ${a}`);
							const c = this.streamingStatusMap || {};
							if (!("p2p" in c) || !("streamingStatus" in c) || c.p2p !== t || c.streamingStatus !== a) {
								const e = Date.now();
								this.maybeSendTrackStreamingStatusEvent(e), this.streamingStatusMap = {
									...c,
									streamingStatus: a,
									p2p: t,
									startedMs: e
								}, "videoType" in this.streamingStatusMap || (this.streamingStatusMap.videoType = this.track.getVideoType())
							}
							this._changeStreamingStatus(a)
						}
						maybeSendTrackStreamingStatusEvent(e) {
							const t = this.streamingStatusMap;
							t && "startedMs" in t && "videoType" in t && "streamingStatus" in t && "p2p" in t && (t.value = e - t.startedMs, Pi.sendAnalytics(function() {
								let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
								return {
									type: Kt.TYPE_OPERATIONAL,
									source: "track.streaming.status",
									action: "duration",
									attributes: e
								}
							}(t)))
						}
						onForwardedSourcesChanged() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
								t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
								n = arguments.length > 2 ? arguments[2] : void 0;
							const i = this.track.getSourceName();
							Wn.supportsVideoMuteOnConnInterrupted() || this.figureOutStreamingStatus(), e.includes(i) && (this.track._clearEnteredForwardedSourcesTimestamp(), this._clearRestoringTimer(), Wn.supportsVideoMuteOnConnInterrupted() && this.figureOutStreamingStatus()), t.includes(i) && (this.track._setEnteredForwardedSourcesTimestamp(n), Wn.supportsVideoMuteOnConnInterrupted() && this.figureOutStreamingStatus())
						}
						_clearRestoringTimer() {
							const e = this.restoringTimer;
							e && (clearTimeout(e), this.restoringTimer = null)
						}
						_isRestoringTimedout() {
							const e = this.track._getEnteredForwardedSourcesTimestamp();
							return !!(e && Date.now() - e >= 1e4) || (this.restoringTimer || (this.restoringTimer = setTimeout((() => this.figureOutStreamingStatus()), 1e4)), !1)
						}
						_isCurrentTrack(e) {
							return e.getSourceName() === this.track.getSourceName()
						}
						onUserLeft(e) {
							this.track.getParticipantId() === e && (this.maybeSendTrackStreamingStatusEvent(Date.now()), this.streamingStatusMap = {})
						}
						onTrackRtcMuted(e) {
							if (!this._isCurrentTrack(e)) return;
							const t = e.getSourceName();
							if (kd.debug(`Detector track RTC muted: ${t}`, Date.now()), this.rtcMutedTimestamp = Date.now(), !e.isMuted()) {
								this.clearTimeout();
								const e = this._getVideoFrozenTimeout();
								this.trackTimer = window.setTimeout((() => {
									kd.debug(`Set track RTC muted for: ${t} after the timeout of ${e} ms`), this.clearTimeout(), this.figureOutStreamingStatus()
								}), e)
							}
						}
						onTrackRtcUnmuted(e) {
							if (!this._isCurrentTrack(e)) return;
							const t = this.track.getSourceName();
							kd.debug(`Detector track RTC unmuted: ${t}`, Date.now()), this.clearTimeout(), this.clearRtcMutedTimestamp(), this.figureOutStreamingStatus()
						}
						onSignallingMuteChanged(e) {
							if (!this._isCurrentTrack(e)) return;
							const t = this.track.getSourceName();
							kd.debug(`Detector on track signalling mute changed: ${t}`, e.isMuted()), this.figureOutStreamingStatus()
						}
						onTrackVideoTypeChanged(e) {
							const t = Date.now();
							this.maybeSendTrackStreamingStatusEvent(t), this.streamingStatusMap = {
								...this.streamingStatusMap || {},
								videoType: e,
								startedMs: t
							}
						}
					}
					const Fd = xd,
						Vd = n(5810).getLogger("modules/RTC/JitsiRemoteTrack.js"),
						Ud = n(9987);
					let jd = !1,
						Hd = !1;
					const Bd = ["abort", "canplaythrough", "ended", "error"];
					class $d extends Qc {
						constructor(e, t, n, i, s, r, o, a, c, d, l) {
							if (super(t, i, s, (() => {}), r, o), this.rtc = e, "number" != typeof a) throw new TypeError(`SSRC ${a} is not a number`);
							this.ssrc = a, this.ownerEndpointId = n, this.muted = c, this.isP2P = d, this._sourceName = l, this._trackStreamingStatus = null, this._trackStreamingStatusImpl = null, this._enteredForwardedSourcesTimestamp = null, this.addEventListener = this.on = this._addEventListener.bind(this), this.removeEventListener = this.off = this._removeEventListener.bind(this), Vd.debug(`New remote track created: ${this}`), this.hasBeenMuted = c, this.rtc && this.track && this._bindTrackHandlers(), this._containerHandlers = {}, Bd.forEach((e => {
								this._containerHandlers[e] = this._containerEventHandler.bind(this, e)
							}))
						}
						_bindTrackHandlers() {
							this.track.addEventListener("mute", (() => this._onTrackMute())), this.track.addEventListener("unmute", (() => this._onTrackUnmute())), this.track.addEventListener("ended", (() => {
								Vd.debug(`"onended" event(${Date.now()}): ${this}`)
							}))
						}
						_addEventListener(e, t) {
							super.addListener(e, t), e === It && this.listenerCount(It) && !this._trackStreamingStatusImpl && (this._initTrackStreamingStatus(), Vd.debug(`Initializing track streaming status: ${this._sourceName}`))
						}
						_removeEventListener(e, t) {
							super.removeListener(e, t), e !== It || this.listenerCount(It) || (this._disposeTrackStreamingStatus(), Vd.debug(`Disposing track streaming status: ${this._sourceName}`))
						}
						_onTrackMute() {
							Vd.debug(`"onmute" event(${Date.now()}): ${this}`), this.rtc.eventEmitter.emit(Ud.REMOTE_TRACK_MUTE, this)
						}
						_onTrackUnmute() {
							Vd.debug(`"onunmute" event(${Date.now()}): ${this}`), this.rtc.eventEmitter.emit(Ud.REMOTE_TRACK_UNMUTE, this)
						}
						dispose() {
							return this._disposeTrackStreamingStatus(), super.dispose()
						}
						setMute(e) {
							this.muted !== e && (e && (this.hasBeenMuted = !0), this.stream && (this.stream.muted = e), this.muted = e, this.emit(Ct, this))
						}
						isMuted() {
							return this.muted
						}
						getParticipantId() {
							return this.ownerEndpointId
						}
						isLocal() {
							return !1
						}
						getSSRC() {
							return this.ssrc
						}
						getSourceName() {
							return this._sourceName
						}
						setOwner(e) {
							this.ownerEndpointId = e, this.emit(Pt, e)
						}
						setSourceName(e) {
							this._sourceName = e
						}
						_setVideoType(e) {
							this.videoType !== e && (this.videoType = e, this.emit(bt, e))
						}
						_playCallback() {
							if (!this.conference.room) return;
							const e = this.isVideoTrack() ? "video" : "audio",
								t = window.performance.now();
							console.log(`(TIME) Render ${e}:\t`, t), this.conference.getConnectionTimes()[`${e}.render`] = t;
							const n = window.connectionTimes["obtainPermissions.start"],
								i = window.connectionTimes["obtainPermissions.end"],
								s = isNaN(i) || isNaN(n) ? 0 : i - n,
								r = t - (this.conference.getConnectionTimes()["session.initiate"] - this.conference.getConnectionTimes()["muc.joined"]) - s;
							var o;
							this.conference.getConnectionTimes()[`${e}.ttfm`] = r, console.log(`(TIME) TTFM ${e}:\t`, r), Pi.sendAnalytics((o = {
								media_type: e,
								muted: this.hasBeenMuted,
								value: r
							}, Sn("ttfm", o)))
						}
						_attachTTFMTracker(e) {
							jd && this.isAudioTrack() || Hd && this.isVideoTrack() || (this.isAudioTrack() && (jd = !0), this.isVideoTrack() && (Hd = !0), e.addEventListener("canplay", this._playCallback.bind(this)))
						}
						_onTrackAttach(e) {
							Bd.forEach((t => {
								e.addEventListener(t, this._containerHandlers[t])
							}))
						}
						_onTrackDetach(e) {
							Bd.forEach((t => {
								e.removeEventListener(t, this._containerHandlers[t])
							}))
						}
						_containerEventHandler(e) {
							Vd.debug(`${e} handler was called for a container with attached ${this}`)
						}
						_getStatus() {
							const {
								enabled: e,
								muted: t,
								readyState: n
							} = this.track;
							return `readyState: ${n}, muted: ${t}, enabled: ${e}`
						}
						_initTrackStreamingStatus() {
							const e = this.conference.options.config;
							this._trackStreamingStatus = Ld.ACTIVE, this._trackStreamingStatusImpl = new Fd(this.rtc, this.conference, this, {
								p2pRtcMuteTimeout: e._p2pConnStatusRtcMuteTimeout,
								rtcMuteTimeout: e._peerConnStatusRtcMuteTimeout,
								outOfForwardedSourcesTimeout: e._peerConnStatusOutOfLastNTimeout
							}), this._trackStreamingStatusImpl.init(), !this._trackStreamingStatusImpl.isVideoTrackFrozen() && this.rtc.eventEmitter.emit(It, this, this._trackStreamingStatus)
						}
						_disposeTrackStreamingStatus() {
							this._trackStreamingStatusImpl && (this._trackStreamingStatusImpl.dispose(), this._trackStreamingStatusImpl = null, this._trackStreamingStatus = null)
						}
						_setTrackStreamingStatus(e) {
							this._trackStreamingStatus = e
						}
						getTrackStreamingStatus() {
							return this._trackStreamingStatus
						}
						_clearEnteredForwardedSourcesTimestamp() {
							this._enteredForwardedSourcesTimestamp = null
						}
						_setEnteredForwardedSourcesTimestamp(e) {
							this._enteredForwardedSourcesTimestamp = e
						}
						_getEnteredForwardedSourcesTimestamp() {
							return this._enteredForwardedSourcesTimestamp
						}
						toString() {
							return `RemoteTrack[userID: ${this.getParticipantId()}, type: ${this.getType()}, ssrc: ${this.getSSRC()}, p2p: ${this.isP2P}, sourceName: ${this._sourceName}, status: {${this._getStatus()}}]`
						}
					}
					const Jd = (0, S.getLogger)("modules/RTC/TPCUtils.js"),
						Gd = 25e5,
						qd = ["1", "2", "3"];
					class Kd {
						constructor(e) {
							var t, n, i;
							this.pc = e;
							const s = null === (t = this.pc.options) || void 0 === t || null === (n = t.videoQuality) || void 0 === n ? void 0 : n.maxBitratesVideo,
								r = {
									low: 2e5,
									standard: 7e5,
									high: Gd,
									ssHigh: Gd
								};
							this.videoBitrates = null != s ? s : r, this.encodingBitrates = null !== (i = this.videoBitrates.VP8) && void 0 !== i ? i : this.videoBitrates
						}
						_getStreamEncodings(e) {
							return this.pc.isSimulcastOn() && e.isVideoTrack() ? this._getVideoStreamEncodings(e.getVideoType()) : e.isVideoTrack() ? [{
								active: !0,
								maxBitrate: this.videoBitrates.high
							}] : [{
								active: !0
							}]
						}
						_getVideoStreamEncodings(e) {
							const t = e === Ni.VideoType.DESKTOP && this.encodingBitrates.ssHigh ? this.encodingBitrates.ssHigh : this.encodingBitrates.high;
							return [{
								active: !0,
								maxBitrate: Wn.isFirefox() ? t : this.encodingBitrates.low,
								rid: "1",
								scaleResolutionDownBy: Wn.isFirefox() ? 1 : 4
							}, {
								active: !0,
								maxBitrate: this.encodingBitrates.standard,
								rid: "2",
								scaleResolutionDownBy: 2
							}, {
								active: !0,
								maxBitrate: Wn.isFirefox() ? this.encodingBitrates.low : t,
								rid: "3",
								scaleResolutionDownBy: Wn.isFirefox() ? 4 : 1
							}]
						}
						ensureCorrectOrderOfSsrcs(e) {
							const t = Wr.parse(e.sdp);
							return t.media.forEach((e => {
								if (e.type === _i.AUDIO) return;
								if (!e.ssrcGroups || !e.ssrcGroups.length) return;
								let t = [];
								const n = new Set;
								e.ssrcGroups.map((e => e.ssrcs.split(" ").filter(Boolean).forEach((e => n.add(e))))), n.forEach((n => {
									const i = e.ssrcs.filter((e => e.id.toString() === n));
									t = t.concat(i)
								})), e.ssrcs = t
							})), new RTCSessionDescription({
								type: e.type,
								sdp: Wr.write(t)
							})
						}
						findTransceiver(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
							return null != t && t.track && t.getOriginalStream() ? this.pc.peerconnection.getTransceivers().find((e => {
								var n, i;
								return (null === (n = e.sender) || void 0 === n || null === (i = n.track) || void 0 === i ? void 0 : i.id) === t.getTrackId()
							})) : this.pc.peerconnection.getTransceivers().find((t => {
								var n, i;
								return (null === (n = t.receiver) || void 0 === n || null === (i = n.track) || void 0 === i ? void 0 : i.kind) === e
							}))
						}
						insertUnifiedPlanSimulcastReceive(e) {
							if (Wn.usesSdpMungingForSimulcast()) return e;
							const t = Wr.parse(e.sdp),
								n = t.media.findIndex((e => e.type === _i.VIDEO));
							if (t.media[n].rids && (t.media[n].simulcast_03 || t.media[n].simulcast)) return t.media.forEach(((e, i) => {
								e.type === _i.VIDEO && i !== n && (t.media[i].rids = void 0, t.media[i].simulcast = void 0, t.media[i].simulcast_03 = void 0)
							})), new RTCSessionDescription({
								type: e.type,
								sdp: Wr.write(t)
							});
							t.media[n].rids = [{
								id: "1",
								direction: "recv"
							}, {
								id: "2",
								direction: "recv"
							}, {
								id: "3",
								direction: "recv"
							}];
							const i = Wn.isFirefox() && Wn.isVersionGreaterThan(71) ? `recv ${qd.join(";")}` : `recv rid=${qd.join(";")}`;
							return t.media[n].simulcast_03 = {
								value: i
							}, new RTCSessionDescription({
								type: e.type,
								sdp: Wr.write(t)
							})
						}
						addTrack(e, t) {
							const n = e.getTrack();
							if (t) {
								const t = [];
								e.getOriginalStream() && t.push(e.getOriginalStream());
								const i = {
									direction: Br.SENDRECV,
									streams: t,
									sendEncodings: []
								};
								Wn.isFirefox() || (i.sendEncodings = this._getStreamEncodings(e)), this.pc.peerconnection.addTransceiver(n, i)
							} else this.pc.peerconnection.addTrack(n)
						}
						calculateEncodingsActiveState(e, t) {
							const n = e.getTrack(),
								{
									height: i
								} = n.getSettings(),
								s = this._getVideoStreamEncodings(e.getVideoType());
							return s.map((e => i / e.scaleResolutionDownBy)).map(((n, i) => {
								var r;
								let o = e.getVideoType() !== Ni.VideoType.CAMERA || t > 0 && 4 === (null === (r = s[i]) || void 0 === r ? void 0 : r.scaleResolutionDownBy) || n <= t;
								return e.getVideoType() === Ni.VideoType.DESKTOP && this.pc._capScreenshareBitrate && this.pc.usesUnifiedPlan() && !Wn.isWebKitBased() && 1 !== s[i].scaleResolutionDownBy && (o = !1), o
							}))
						}
						calculateEncodingsBitrates(e) {
							var t, n;
							const i = e.getVideoType(),
								s = (null === (t = this.pc.options) || void 0 === t || null === (n = t.videoQuality) || void 0 === n ? void 0 : n.desktopBitrate) || 5e5,
								r = e.getVideoType() === Ni.VideoType.DESKTOP && this.pc._capScreenshareBitrate && !Wn.isWebKitBased();
							return this._getVideoStreamEncodings(e.getVideoType()).map((e => r ? s : i === Ni.VideoType.DESKTOP && Wn.isChromiumBased() && !this.pc.usesUnifiedPlan() ? void 0 : e.maxBitrate))
						}
						replaceTrack(e, t) {
							var n, i;
							const s = null !== (n = null == t ? void 0 : t.getType()) && void 0 !== n ? n : null == e ? void 0 : e.getType(),
								r = this.pc.getLocalTracks(s),
								o = null !== (i = null == t ? void 0 : t.getTrack()) && void 0 !== i ? i : null,
								a = Ns.isMultiStreamSendSupportEnabled() && (null == r ? void 0 : r.length) && !e && t && !r.find((e => e === t));
							let c;
							if (e && !e.isMuted()) c = this.pc.peerconnection.getTransceivers().find((t => t.sender.track === e.getTrack()));
							else if (a) c = this.pc.peerconnection.getTransceivers().find((e => e.receiver.track.kind === s && e.direction === Br.RECVONLY && (this.pc.isP2P && e.currentDirection === Br.RECVONLY || e.currentDirection === Br.INACTIVE && !e.stopped)));
							else {
								var d;
								c = this.pc.peerconnection.getTransceivers().find((e => e.receiver.track.kind === s));
								const n = null !== (d = null == t ? void 0 : t.getSourceName()) && void 0 !== d ? d : null == e ? void 0 : e.getSourceName();
								if (n) {
									const t = Sd(n);
									if (this.pc.isP2P) c = this.pc.peerconnection.getTransceivers().filter((e => e.receiver.track.kind === s))[t];
									else if (e) {
										const t = this.pc._localTrackTransceiverMids.get(e.rtcId);
										c = this.pc.peerconnection.getTransceivers().find((e => e.mid === t))
									} else t && (c = this.pc.peerconnection.getTransceivers().filter((e => e.receiver.track.kind === s && e.direction !== Br.RECVONLY))[t])
								}
							}
							return c ? (Jd.debug(`${this.pc} Replacing ${e} with ${t}`), c.sender.replaceTrack(o).then((() => Promise.resolve(c)))) : Promise.reject(new Error(`Replace track failed - no transceiver for old: ${e}, new: ${t}`))
						}
						setAudioTransferActive(e) {
							this.setMediaTransferActive(_i.AUDIO, e)
						}
						setEncodings(e) {
							var t, n;
							const i = e.getType(),
								s = this.findTransceiver(i, e),
								r = null == s || null === (t = s.sender) || void 0 === t ? void 0 : t.getParameters();
							return null != r && null !== (n = r.encodings) && void 0 !== n && n.length ? (r.encodings = this._getStreamEncodings(e), s.sender.setParameters(r)) : Promise.resolve()
						}
						setMediaTransferActive(e, t) {
							const n = this.pc.peerconnection.getTransceivers().filter((t => t.receiver && t.receiver.track && t.receiver.track.kind === e));
							Jd.info(`${this.pc} ${t?"Enabling":"Suspending"} ${e} media transfer.`), n.forEach((e => {
								t ? Array.from(this.pc._localTrackTransceiverMids).find((t => t[1] === e.mid)) ? e.direction = Br.SENDRECV : e.direction = Br.RECVONLY : e.direction = Br.INACTIVE
							}))
						}
						setVideoTransferActive(e) {
							this.setMediaTransferActive(_i.VIDEO, e)
						}
						updateEncodingsResolution(e, t) {
							var n;
							if (Wn.isWebKitBased() && t.encodings && Array.isArray(t.encodings) && (n = t.encodings).every((e => void 0 !== e.scaleResolutionDownBy && e.scaleResolutionDownBy === n[0].scaleResolutionDownBy))) {
								const n = this._getVideoStreamEncodings(e.getVideoType());
								t.encodings.forEach(((e, t) => {
									e.scaleResolutionDownBy = n[t].scaleResolutionDownBy
								}))
							}
						}
					}
					const Wd = (0, S.getLogger)("modules/RTC/TraceablePeerConnection.js");

					function Xd(e, t, i, s, r, o, a) {
						this.audioTransferActive = !(!0 === a.startSilent), this._dtmfSender = void 0, this._dtmfTonesQueue = [], this.videoTransferActive = !0, this.rtc = e, this.id = t, this.isP2P = o, this.remoteTracks = new Map, this.localTracks = new Map, this._addedStreams = [], this.localSSRCs = new Map, this.remoteSSRCs = new Set, this.localUfrag = null, this.remoteUfrag = null, this._dtlsTransport = null, this.signalingLayer = i, this._peerVideoTypeChanged = this._peerVideoTypeChanged.bind(this), this.signalingLayer.on(pd, this._peerVideoTypeChanged), this._peerMutedChanged = this._peerMutedChanged.bind(this), this.signalingLayer.on(hd, this._peerMutedChanged), this.options = a, this.signalingLayer.on(md, ((e, t) => this._sourceMutedChanged(e, t))), this.signalingLayer.on(gd, ((e, t) => this._sourceVideoTypeChanged(e, t)));
						const c = r || {};
						if (c.optional = c.optional || [], Array.isArray(c.optional) ? c.optional.push({
								rtcStatsSFUP2P: this.isP2P
							}) : Wd.warn("Optional param is not an array, rtcstats p2p data is omitted."), this.peerconnection = new RTCPeerConnection(s, c), this.tpcUtils = new Kd(this), this.updateLog = [], this.stats = {}, this.statsinterval = null, this._capScreenshareBitrate = this.options.capScreenshareBitrate, this._usesUnifiedPlan = a.usesUnifiedPlan, this._usesTransceiverCodecPreferences = Wn.supportsCodecPreferences() && this._usesUnifiedPlan, this._usesTransceiverCodecPreferences && Wd.info("Using RTCRtpTransceiver#setCodecPreferences for codec selection"), this._usesUnifiedPlan && (this._hasHadAudioTrack = !1, this._hasHadVideoTrack = !1), this.maxstats = a.maxstats, this.interop = new ld, this._usesUnifiedPlan) this.simulcast = new Md({
							numOfLayers: qd.length
						});
						else {
							const e = n(6234);
							this.simulcast = new e({
								numOfLayers: qd.length,
								explodeRemoteSimulcast: !1,
								usesUnifiedPlan: !1
							})
						}
						this.sdpConsistency = new Nd(this.toString()), this.localSdpMunger = new Id(this, this.rtc.getLocalEndpointId()), this.eventEmitter = e.eventEmitter, this.rtxModifier = new wd, this._senderVideoMaxHeight = 2160, this._senderMaxHeights = new Map, this._localTrackTransceiverMids = new Map, this.trace = (e, t) => {
							Wd.debug(e, t), this.updateLog.push({
								time: new Date,
								type: e,
								value: t || ""
							})
						}, this.onicecandidate = null, this.peerconnection.onicecandidate = e => {
							this.trace("onicecandidate", JSON.stringify(e.candidate, null, " ")), null !== this.onicecandidate && this.onicecandidate(e)
						}, this._usesUnifiedPlan ? (this.onTrack = e => {
							const t = e.streams[0];
							this._remoteTrackAdded(t, e.track, e.transceiver), t.addEventListener("removetrack", (e => {
								this._remoteTrackRemoved(t, e.track)
							}))
						}, this.peerconnection.addEventListener("track", this.onTrack)) : (this.peerconnection.onaddstream = e => this._remoteStreamAdded(e.stream), this.peerconnection.onremovestream = e => this._remoteStreamRemoved(e.stream)), this.onsignalingstatechange = null, this.peerconnection.onsignalingstatechange = e => {
							this.trace("onsignalingstatechange", this.signalingState), null !== this.onsignalingstatechange && this.onsignalingstatechange(e)
						}, this.oniceconnectionstatechange = null, this.peerconnection.oniceconnectionstatechange = e => {
							this.trace("oniceconnectionstatechange", this.iceConnectionState), null !== this.oniceconnectionstatechange && this.oniceconnectionstatechange(e)
						}, this.onnegotiationneeded = null, this.peerconnection.onnegotiationneeded = e => {
							this.trace("onnegotiationneeded"), null !== this.onnegotiationneeded && this.onnegotiationneeded(e)
						}, this.onconnectionstatechange = null, this.peerconnection.onconnectionstatechange = e => {
							this.trace("onconnectionstatechange", this.connectionState), null !== this.onconnectionstatechange && this.onconnectionstatechange(e)
						}, this.ondatachannel = null, this.peerconnection.ondatachannel = e => {
							this.trace("ondatachannel"), null !== this.ondatachannel && this.ondatachannel(e)
						}, this.maxstats && (this.statsinterval = window.setInterval((() => {
							this.getStats().then((e => {
								if ("function" == typeof(null == e ? void 0 : e.result)) {
									const t = e.result();
									for (let e = 0; e < t.length; ++e) {
										const n = t[e];
										n.names().forEach((e => {
											this._processStat(n, e, n.stat(e))
										}))
									}
								} else e.forEach((e => this._processStat(e, "", e)))
							}))
						}), 1e3)), Wd.info(`Create new ${this}`)
					}
					Xd.prototype._processStat = function(e, t, n) {
						const i = `${e.id}-${t}`;
						let s = this.stats[i];
						const r = new Date;
						s || (this.stats[i] = s = {
							startTime: r,
							endTime: r,
							values: [],
							times: []
						}), s.values.push(n), s.times.push(r.getTime()), s.values.length > this.maxstats && (s.values.shift(), s.times.shift()), s.endTime = r
					};
					const zd = function(e) {
						return null == e ? "" : `type: ${e.type}\r\n${e.sdp}`
					};
					Xd.prototype.getConnectionState = function() {
						const e = this.peerconnection.iceConnectionState;
						return "completed" === e ? "connected" : e
					}, Xd.prototype.getDesiredMediaDirection = function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						const n = this.hasAnyTracksOfType(e);
						if (this._usesUnifiedPlan) return t ? n ? Br.SENDRECV : Br.SENDONLY : n ? Br.RECVONLY : Br.INACTIVE;
						const i = e === _i.AUDIO ? this.audioTransferActive : this.videoTransferActive;
						return i ? n ? Br.SENDRECV : Br.RECVONLY : Br.INACTIVE
					}, Xd.prototype._getDesktopTrackMid = function() {
						const e = this.getLocalVideoTracks().find((e => e.getVideoType() === Ni.VideoType.DESKTOP));
						return e ? Number(this._localTrackTransceiverMids.get(e.rtcId)) : null
					}, Xd.prototype._getReceiversByEndpointIds = function(e, t) {
						let n = [],
							i = [];
						for (const i of e) n = n.concat(this.getRemoteTracks(i, t));
						const s = n.map((e => {
							var t;
							return null === (t = e.track) || void 0 === t ? void 0 : t.id
						}));
						return i = this.peerconnection.getReceivers().filter((e => e.track && e.track.kind === t && s.find((t => t === e.track.id)))), i
					}, Xd.prototype.isSimulcastOn = function() {
						return !this.options.disableSimulcast
					}, Xd.prototype._peerVideoTypeChanged = function(e, t) {
						if (!e) return void Wd.error(`${this} No endpointID on peerVideoTypeChanged`);
						const n = this.getRemoteTracks(e, _i.VIDEO);
						n.length && n[0]._setVideoType(t)
					}, Xd.prototype._peerMutedChanged = function(e, t, n) {
						if (!e) return void Wd.error(`${this} On peerMuteChanged - no endpoint ID`);
						const i = this.getRemoteTracks(e, t);
						i.length && i[0].setMute(n)
					}, Xd.prototype._sourceMutedChanged = function(e, t) {
						const n = this.getRemoteTracks().find((t => t.getSourceName() === e));
						n && n.setMute(t)
					}, Xd.prototype._sourceVideoTypeChanged = function(e, t) {
						const n = this.getRemoteTracks().find((t => t.getSourceName() === e));
						n && n._setVideoType(t)
					}, Xd.prototype.getAudioLevels = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
						const t = {},
							n = e.length ? this._getReceiversByEndpointIds(e, _i.AUDIO) : this.peerconnection.getReceivers().filter((e => e.track && e.track.kind === _i.AUDIO && e.track.enabled));
						return n.forEach((e => {
							const n = e.getSynchronizationSources();
							n && n.length && (t[n[0].source] = n[0].audioLevel)
						})), t
					}, Xd.prototype.getLocalTracks = function(e) {
						let t = Array.from(this.localTracks.values());
						return void 0 !== e && (t = t.filter((t => t.getType() === e))), t
					}, Xd.prototype.getLocalVideoTracks = function() {
						return this.getLocalTracks(_i.VIDEO)
					}, Xd.prototype.hasAnyTracksOfType = function(e) {
						if (!e) throw new Error('"mediaType" is required');
						return this.getLocalTracks(e).length > 0
					}, Xd.prototype.getRemoteTracks = function(e, t) {
						let n = [];
						const i = e ? [e] : this.remoteTracks.keys();
						for (const e of i) {
							const i = this.remoteTracks.get(e);
							if (i)
								for (const e of i.keys()) t && t !== e || (n = n.concat(Array.from(i.get(e))))
						}
						return n
					}, Xd.prototype.getRemoteSourceInfoByParticipant = function(e) {
						const t = [],
							n = this.getRemoteTracks(e);
						if (null == n || !n.length) return t;
						const i = n.map((e => e.getSSRC())),
							s = new Qr(this.remoteDescription.sdp);
						return i.forEach(((e, n) => {
							for (const i of s.media) {
								let s = "",
									r = Yr.findLines(i, `a=ssrc:${e}`);
								if (r.length) {
									t[n] || (t[n] = "");
									const o = Yr.findLines(i, `a=ssrc-group:FID ${e}`);
									if (o.length) {
										const e = o[0].split(" ")[2];
										s += `${o[0]}\r\n`, r = r.concat(Yr.findLines(i, `a=ssrc:${e}`))
									}
									t[n] += `${r.join("\r\n")}\r\n`, t[n] += s
								}
							}
						})), t
					}, Xd.prototype.getTargetVideoBitrates = function() {
						const e = this.getConfiguredVideoCodec();
						return this.tpcUtils.videoBitrates[e.toUpperCase()] || this.tpcUtils.videoBitrates
					}, Xd.prototype.getTrackBySSRC = function(e) {
						if ("number" != typeof e) throw new Error(`SSRC ${e} is not a number`);
						for (const t of this.localTracks.values())
							if (this.getLocalSSRC(t) === e) return t;
						for (const t of this.getRemoteTracks())
							if (t.getSSRC() === e) return t;
						return null
					}, Xd.prototype.getSsrcByTrackId = function(e) {
						const t = t => t.getTrack().id === e,
							n = this.getLocalTracks().find(t);
						if (n) return this.getLocalSSRC(n);
						const i = this.getRemoteTracks().find(t);
						return i ? i.getSSRC() : null
					}, Xd.prototype._remoteStreamAdded = function(e) {
						const t = e.id;
						if (!il.isUserStreamById(t)) return;
						Wn.isChromiumBased() && (e.onaddtrack = t => {
							this._remoteTrackAdded(e, t.track)
						}, e.onremovetrack = t => {
							this._remoteTrackRemoved(e, t.track)
						});
						const n = e.getAudioTracks();
						for (const t of n) this._remoteTrackAdded(e, t);
						const i = e.getVideoTracks();
						for (const t of i) this._remoteTrackAdded(e, t)
					}, Xd.prototype._remoteTrackAdded = function(e, t) {
						let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
						const i = e.id,
							s = t.kind;
						if (!this.isP2P && !il.isUserStreamById(i)) return;
						if (Wd.info(`${this} Received track event for remote stream[id=${i},type=${s}]`), !s) return void Zn.callErrorHandler(new Error(`MediaType undefined for remote track, stream id: ${i}, track creation failed!`));
						const r = this._usesUnifiedPlan ? new Qr(this.peerconnection.remoteDescription.sdp) : new Qr(this.remoteDescription.sdp);
						let o;
						if (this._usesUnifiedPlan)
							if (null != n && n.mid) {
								const e = n.mid;
								o = r.media.find((t => Yr.findLine(t, `a=mid:${e}`)))
							} else o = r.media.find((e => {
								const t = Yr.findLine(e, "a=msid:");
								return "string" == typeof t && i === t.substring(7).split(" ")[0]
							}));
						else o = r.media.find((e => e.startsWith(`m=${s}`)));
						if (!o) return void Zn.callErrorHandler(new Error(`Matching media line not found in remote SDP for remote stream[id=${i},type=${s}],track creation failed!`));
						let a = Yr.findLines(o, "a=ssrc:");
						if (a = a.filter((e => -1 !== e.indexOf(`msid:${i}`))), !a.length) return void Zn.callErrorHandler(new Error(`No SSRC lines found in remote SDP for remote stream[msid=${i},type=${s}]track creation failed!`));
						const c = a[0].substring(7).split(" ")[0],
							d = Number(c),
							l = this.signalingLayer.getSSRCOwner(d);
						if (isNaN(d) || d < 0) return void Zn.callErrorHandler(new Error(`Invalid SSRC for remote stream[ssrc=${d},id=${i},type=${s}]track creation failed!`));
						if (!l) return void Zn.callErrorHandler(new Error(`No SSRC owner known for remote stream[ssrc=${d},id=${i},type=${s}]track creation failed!`));
						const u = this.signalingLayer.getTrackSourceName(d),
							h = this.signalingLayer.getPeerMediaInfo(l, s, u);
						let p = !0,
							m = Ni.VideoType.CAMERA;
						h ? (p = h.muted, m = h.videoType) : Wd.info(`${this}: no source-info available for ${l}:${u}, assuming default state`), this._createRemoteTrack(l, e, t, s, m, d, p, u)
					}, Xd.prototype._createRemoteTrack = function(e, t, n, i, s, r, o, a) {
						Wd.info(`${this} creating remote track[endpoint=${e},ssrc=${r},type=${i},sourceName=${a}]`);
						let c = this.remoteTracks.get(e);
						c || (c = new Map, c.set(_i.AUDIO, new Set), c.set(_i.VIDEO, new Set), this.remoteTracks.set(e, c));
						const d = c.get(i);
						if (null != d && d.size && Array.from(d).find((e => e.getTrack() === n))) return void Wd.info(`${this} ignored duplicated track event for track[endpoint=${e},type=${i}]`);
						const l = new $d(this.rtc, this.rtc.conference, e, t, n, i, s, r, o, this.isP2P, a);
						d.add(l), this.eventEmitter.emit(Oi.default.REMOTE_TRACK_ADDED, l, this)
					}, Xd.prototype._remoteStreamRemoved = function(e) {
						if (!il.isUserStream(e)) return void Wd.info(`Ignored remote 'stream removed' event for stream[id=${e.id}]`);
						const t = e.getVideoTracks();
						for (const n of t) this._remoteTrackRemoved(e, n);
						const n = e.getAudioTracks();
						for (const t of n) this._remoteTrackRemoved(e, t)
					}, Xd.prototype._remoteTrackRemoved = function(e, t) {
						const n = e.id,
							i = null == t ? void 0 : t.id;
						if (!il.isUserStreamById(n)) return;
						if (!n) return void Zn.callErrorHandler(new Error(`${this} remote track removal failed - no stream ID`));
						if (!i) return void Zn.callErrorHandler(new Error(`${this} remote track removal failed - no track ID`));
						const s = this.getRemoteTracks().find((e => e.getStreamId() === n && e.getTrackId() === i));
						s ? this._removeRemoteTrack(s) : Zn.callErrorHandler(new Error(`${this} remote track removal failed - track not found`))
					}, Xd.prototype.removeRemoteTracks = function(e) {
						let t = [];
						const n = this.remoteTracks.get(e);
						return n && (t = t.concat(Array.from(n.get(_i.AUDIO))), t = t.concat(Array.from(n.get(_i.VIDEO))), this.remoteTracks.delete(e)), Wd.debug(`${this} removed remote tracks[endpoint=${e},count=${t.length}`), t
					}, Xd.prototype._removeRemoteTrack = function(e) {
						var t;
						Wd.info(`${this} Removing remote track stream[id=${e.getStreamId()},trackId=${e.getTrackId()}]`), e.dispose();
						const n = e.getParticipantId(),
							i = this.remoteTracks.get(n);
						i ? null !== (t = i.get(e.getType())) && void 0 !== t && t.delete(e) || Wd.error(`${this} Failed to remove ${e} - type mapping messed up ?`) : Wd.error(`${this} removeRemoteTrack: no remote tracks map for endpoint=${n}`), this.eventEmitter.emit(Oi.default.REMOTE_TRACK_REMOVED, e)
					}, Xd.prototype._extractSSRCMap = function(e) {
						const t = new Map,
							n = new Map;
						if ("object" != typeof e || null === e || "string" != typeof e.sdp) return Wd.warn("An empty description was passed as an argument"), t;
						const i = Wr.parse(e.sdp);
						if (!Array.isArray(i.media)) return t;
						let s = i.media;
						this._usesUnifiedPlan ? s = s.filter((e => e.direction === Br.SENDONLY || e.direction === Br.SENDRECV)) : (s = [], [_i.AUDIO, _i.VIDEO].forEach((e => {
							const t = i.media.find((t => t.type === e));
							t && s.push(t)
						})));
						let r = 0;
						for (const e of s) {
							if (!Array.isArray(e.ssrcs)) continue;
							if (Array.isArray(e.ssrcGroups))
								for (const t of e.ssrcGroups)
									if (void 0 !== t.semantics && void 0 !== t.ssrcs) {
										const e = t.ssrcs.split(" ").map((e => parseInt(e, 10))),
											i = e[0];
										t.ssrcs = e, n.has(i) || n.set(i, []), n.get(i).push(t)
									} let i = e.ssrcs;
							i = this._usesUnifiedPlan ? i.filter((e => "cname" === e.attribute)) : i.filter((e => "msid" === e.attribute));
							for (const s of i) {
								const i = this._usesUnifiedPlan ? `${e.type}-${r}` : s.value,
									o = s.id;
								let a = t.get(i);
								if (a || (a = {
										ssrcs: [],
										groups: [],
										msid: i
									}, t.set(i, a)), a.ssrcs.push(o), n.has(o)) {
									const e = n.get(o);
									for (const t of e) a.groups.push(t)
								}
							}
							e.type === _i.VIDEO && r++
						}
						return t
					};
					Xd.prototype.getLocalSSRC = function(e) {
						const t = this._getSSRC(e.rtcId);
						return t && t.ssrcs[0]
					}, Xd.prototype._injectSsrcGroupForUnifiedSimulcast = function(e) {
						const t = Wr.parse(e.sdp),
							n = t.media.find((e => "video" === e.type));
						n.ssrcGroups = n.ssrcGroups || [];
						const i = n.ssrcGroups.filter((e => "FID" === e.semantics));
						if (n.simulcast || n.simulcast_03) {
							const t = [];
							if (i && i.length ? i.forEach((e => {
									t.push(e.ssrcs.split(" ")[0])
								})) : n.ssrcs.forEach((e => {
									"msid" === e.attribute && t.push(e.id)
								})), n.ssrcGroups.find((e => "SIM" === e.semantics))) return e;
							for (let e = 0; e < t.length; e += 3) {
								const i = t.slice(e, e + 3);
								n.ssrcGroups.push({
									semantics: "SIM",
									ssrcs: i.join(" ")
								})
							}
						}
						return new RTCSessionDescription({
							type: e.type,
							sdp: Wr.write(t)
						})
					};
					const Yd = {
						signalingState() {
							return this.peerconnection.signalingState
						},
						iceConnectionState() {
							return this.peerconnection.iceConnectionState
						},
						connectionState() {
							return this.peerconnection.connectionState
						},
						localDescription() {
							let e = this.peerconnection.localDescription;
							return e ? (this.trace("getLocalDescription::preTransform", zd(e)), this._usesUnifiedPlan && !this.isP2P ? (e = this.interop.toPlanB(e), this.trace("getLocalDescription::postTransform (Plan B)", zd(e)), e = this._injectSsrcGroupForUnifiedSimulcast(e), this.trace("getLocalDescription::postTransform (inject ssrc group)", zd(e))) : this._usesUnifiedPlan || (Wn.doesVideoMuteByStreamRemove() && (e = this.localSdpMunger.maybeAddMutedLocalVideoTracksToSDP(e), Wd.debug("getLocalDescription::postTransform (munge local SDP)", e)), e = function(e, t) {
								var n, i;
								if (!e) throw new Error("No local description passed in.");
								const s = new Ad(e.sdp),
									r = null === (n = s.selectMedia(_i.AUDIO)) || void 0 === n ? void 0 : n[0];
								let o = !1;
								r && r.direction !== Br.SENDRECV && (t.startSilent ? r.direction = Br.INACTIVE : r.direction = Br.SENDRECV, o = !0);
								const a = null === (i = s.selectMedia(_i.VIDEO)) || void 0 === i ? void 0 : i[0];
								return a && a.direction !== Br.SENDRECV && (a.direction = Br.SENDRECV, o = !0), o ? new RTCSessionDescription({
									type: e.type,
									sdp: s.toRawSDP()
								}) : e
							}(e, this.options)), e = this.localSdpMunger.transformStreamIdentifiers(e), e) : (Wd.debug(`${this} getLocalDescription no localDescription found`), {})
						},
						remoteDescription() {
							let e = this.peerconnection.remoteDescription;
							return e ? (this.trace("getRemoteDescription::preTransform", zd(e)), this._usesUnifiedPlan && (this.isP2P ? e = this._adjustRemoteMediaDirection(e) : (e = this.interop.toPlanB(e), this.trace("getRemoteDescription::postTransform (Plan B)", zd(e)))), e) : (Wd.debug(`${this} getRemoteDescription no remoteDescription found`), {})
						}
					};
					Object.keys(Yd).forEach((e => {
						Object.defineProperty(Xd.prototype, e, {
							get: Yd[e]
						})
					})), Xd.prototype._getSSRC = function(e) {
						return this.localSSRCs.get(e)
					}, Xd.prototype.isSharingLowFpsScreen = function() {
						return this._isSharingScreen() && this._capScreenshareBitrate
					}, Xd.prototype._isSharingScreen = function() {
						const e = this.getLocalVideoTracks();
						return Boolean(e.find((e => e.videoType === Ni.VideoType.DESKTOP)))
					}, Xd.prototype._mungeCodecOrder = function(e) {
						if (!this.codecPreference) return e;
						const t = Wr.parse(e.sdp),
							n = t.media.filter((e => e.type === this.codecPreference.mediaType));
						if (!n.length) return e;
						for (const e of n) this.codecPreference.disabledCodecMimeType && Yr.stripCodec(e, this.codecPreference.disabledCodecMimeType), this.codecPreference.mimeType !== this.codecPreference.disabledCodecMimeType && (Yr.preferCodec(e, this.codecPreference.mimeType), this.codecPreference.mimeType === jr.H264 && Wn.isReactNative() && this.isP2P && Yr.stripCodec(e, this.codecPreference.mimeType, !0));
						return new RTCSessionDescription({
							type: e.type,
							sdp: Wr.write(t)
						})
					}, Xd.prototype.addTrack = function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						const n = e.rtcId;
						if (Wd.info(`${this} adding ${e}`), this.localTracks.has(n)) return Promise.reject(new Error(`${e} is already in ${this}`));
						this.localTracks.set(n, e);
						const i = e.getOriginalStream();
						if (this._usesUnifiedPlan) {
							Wd.debug(`${this} TPC.addTrack using unified plan`);
							try {
								this.tpcUtils.addTrack(e, t), e && (e.isAudioTrack() ? this._hasHadAudioTrack = !0 : this._hasHadVideoTrack = !0)
							} catch (t) {
								return Wd.error(`${this} Adding track=${e} failed: ${null==t?void 0:t.message}`), Promise.reject(t)
							}
						} else {
							if (i) this._addStream(i);
							else if (!Wn.doesVideoMuteByStreamRemove() || e.isAudioTrack() || e.isVideoTrack() && !e.isMuted()) return Promise.reject(new Error(`${this} no WebRTC stream for track=${e}`));
							if (Wn.doesVideoMuteByStreamRemove() && e.isVideoTrack() && e.isMuted()) {
								const t = this.generateNewStreamSSRCInfo(e);
								this.sdpConsistency.setPrimarySsrc(t.ssrcs[0]);
								const n = t.groups.find((e => "SIM" === e.semantics));
								n && this.simulcast.setSsrcCache(n.ssrcs);
								const i = t.groups.filter((e => "FID" === e.semantics));
								if (i) {
									const e = new Map;
									i.forEach((t => {
										const n = t.ssrcs[0],
											i = t.ssrcs[1];
										e.set(n, i)
									})), this.rtxModifier.setSsrcCache(e)
								}
							}
						}
						let s = Promise.resolve();
						return Wn.isFirefox() && (s = s.then((() => i && this.tpcUtils.setEncodings(e)))), s
					}, Xd.prototype.addTrackToPc = function(e) {
						if (Wd.info(`${this} Adding track=${e} to PC`), !this._assertTrackBelongs("addTrackToPc", e)) return Promise.reject("Track not found on the peerconnection");
						const t = e.getOriginalStream();
						return t ? this._usesUnifiedPlan ? this.tpcUtils.replaceTrack(null, e).then((() => (e && (e.isAudioTrack() ? this._hasHadAudioTrack = !0 : this._hasHadVideoTrack = !0), !1))) : (this._addStream(t), Promise.resolve(!0)) : (Wd.error(`${this} Unable to add track=${e} to PC - no WebRTC stream`), Promise.reject("Stream not found"))
					}, Xd.prototype._addStream = function(e) {
						this.peerconnection.addStream(e), this._addedStreams.push(e)
					}, Xd.prototype._removeStream = function(e) {
						this.peerconnection.removeStream(e), this._addedStreams = this._addedStreams.filter((t => t !== e))
					}, Xd.prototype._assertTrackBelongs = function(e, t) {
						const n = this.localTracks.has(null == t ? void 0 : t.rtcId);
						return n || Wd.error(`${this} ${e}: track=${t} does not belong to pc`), n
					}, Xd.prototype.getConfiguredVideoCodec = function() {
						var e;
						const t = null === (e = this.peerconnection.localDescription) || void 0 === e ? void 0 : e.sdp,
							n = jr.VP8;
						if (!t) return n;
						const i = Wr.parse(t).media.find((e => e.type === _i.VIDEO)).rtp[0].codec;
						return i ? Object.values(jr).find((e => e === i.toLowerCase())) : n
					}, Xd.prototype.setDesktopSharingFrameRate = function(e) {
						const t = e <= 5;
						this._capScreenshareBitrate = this.isSimulcastOn() && t
					}, Xd.prototype.setVideoCodecs = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
							t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
						this.codecPreference && (e || t) ? (this.codecPreference.mimeType = e, this.codecPreference.disabledCodecMimeType = t) : e || t ? this.codecPreference = {
							mediaType: _i.VIDEO,
							mimeType: e,
							disabledCodecMimeType: t
						} : Wd.warn(`${this} Invalid codec settings[preferred=${e},disabled=${t}],\n            atleast one value is needed`)
					}, Xd.prototype.isMediaStreamInPc = function(e) {
						return this._addedStreams.indexOf(e) > -1
					}, Xd.prototype.removeTrack = function(e) {
						const t = e.getOriginalStream();
						this.trace("removeStream", e.rtcId, t ? t.id : void 0), this._assertTrackBelongs("removeStream", e) && (this.localTracks.delete(e.rtcId), this.localSSRCs.delete(e.rtcId), t && this.peerconnection.removeStream(t))
					}, Xd.prototype.findSenderByKind = function(e) {
						if (this.peerconnection.getSenders) return this.peerconnection.getSenders().find((t => t.track && t.track.kind === e))
					}, Xd.prototype.findReceiverForTrack = function(e) {
						return this.peerconnection.getReceivers().find((t => t.track === e))
					}, Xd.prototype.findSenderForTrack = function(e) {
						if (this.peerconnection.getSenders) return this.peerconnection.getSenders().find((t => t.track === e))
					}, Xd.prototype.processLocalSdpForTransceiverInfo = function(e) {
						var t;
						const n = null === (t = this.peerconnection.localDescription) || void 0 === t ? void 0 : t.sdp;
						n && [_i.AUDIO, _i.VIDEO].forEach((t => {
							const i = e.filter((e => e.getType() === t)),
								s = Wr.parse(n).media.filter((e => e.type === t));
							i.forEach(((e, t) => {
								this._localTrackTransceiverMids.has(e.rtcId) || this._localTrackTransceiverMids.set(e.rtcId, s[t].mid.toString())
							}))
						}))
					}, Xd.prototype.replaceTrack = function(e, t) {
						if (!e && !t) return Wd.info(`${this} replaceTrack called with no new track and no old track`), Promise.resolve();
						if (this._usesUnifiedPlan) {
							var n;
							Wd.debug(`${this} TPC.replaceTrack using unified plan`);
							const i = null !== (n = null == t ? void 0 : t.getType()) && void 0 !== n ? n : null == e ? void 0 : e.getType();
							return this.tpcUtils.replaceTrack(e, t).then((n => {
								var s;
								if (e && (this.localTracks.delete(e.rtcId), this._localTrackTransceiverMids.delete(e.rtcId)), t && (t.isAudioTrack() ? this._hasHadAudioTrack = !0 : this._hasHadVideoTrack = !0, this._localTrackTransceiverMids.set(t.rtcId, null == n || null === (s = n.mid) || void 0 === s ? void 0 : s.toString()), this.localTracks.set(t.rtcId, t)), e && t) {
									const n = this.localSSRCs.get(e.rtcId);
									n && (this.localSSRCs.delete(e.rtcId), this.localSSRCs.set(t.rtcId, n))
								}
								const r = i === _i.AUDIO ? this.audioTransferActive : this.videoTransferActive;
								return n && r ? n.direction = t || Wn.isFirefox() ? Br.SENDRECV : Br.RECVONLY : n && (n.direction = Br.INACTIVE), (Wn.usesSdpMungingForSimulcast() || !t ? Promise.resolve() : this.tpcUtils.setEncodings(t)).then((() => this.isP2P))
							}))
						}
						Wd.debug(`${this} TPC.replaceTrack using plan B`);
						let i = Promise.resolve();
						return e && this.removeTrack(e), t && (i = this.addTrack(t)), i.then((() => !0))
					}, Xd.prototype.removeTrackFromPc = function(e) {
						const t = e.getOriginalStream();
						return this.trace("removeTrack", e.rtcId, t ? t.id : null), this._assertTrackBelongs("removeTrack", e) ? this._usesUnifiedPlan ? this.tpcUtils.replaceTrack(e, null).then((() => !1)) : t ? (Wd.info(`${this} Removing track=${e} from PC`), this._removeStream(t), Promise.resolve(!0)) : (Wd.error(`${this} removeTrack - no WebRTC stream for track=${e}`), Promise.reject("Stream not found")) : Promise.reject("Track not found in the peerconnection")
					}, Xd.prototype.createDataChannel = function(e, t) {
						return this.trace("createDataChannel", e, t), this.peerconnection.createDataChannel(e, t)
					}, Xd.prototype._ensureSimulcastGroupIsLast = function(e) {
						let t = e.sdp;
						const n = t.indexOf("m=video"),
							i = t.indexOf("a=ssrc-group:SIM", n);
						let s = t.lastIndexOf("a=ssrc-group");
						if (-1 === i || -1 === s || s === i) return e;
						const r = t.indexOf("\r\n", i),
							o = t.substring(i, r + 2);
						t = t.replace(o, ""), s = t.lastIndexOf("a=ssrc-group");
						const a = t.indexOf("\r\n", s),
							c = t.slice(0, a),
							d = o.trim(),
							l = t.slice(a);
						return t = `${c}\r\n${d}${l}`, new RTCSessionDescription({
							type: e.type,
							sdp: t
						})
					}, Xd.prototype._adjustLocalMediaDirection = function(e) {
						var t, n;
						const i = new Ad(e.sdp);
						let s = !1;
						const r = null === (t = i.selectMedia(_i.AUDIO)) || void 0 === t ? void 0 : t[0];
						if (r) {
							const e = this.getDesiredMediaDirection(_i.AUDIO);
							r.direction !== e && (r.direction = e, Wd.info(`${this} Adjusted local audio direction to ${e}`), s = !0)
						} else Wd.warn(`${this} No "audio" media found in the local description`);
						const o = null === (n = i.selectMedia(_i.VIDEO)) || void 0 === n ? void 0 : n[0];
						if (o) {
							const e = this.getDesiredMediaDirection(_i.VIDEO);
							o.direction !== e && (o.direction = e, Wd.info(`${this} Adjusted local video direction to ${e}`), s = !0)
						} else Wd.warn(`${this} No "video" media found in the local description`);
						return s ? new RTCSessionDescription({
							type: e.type,
							sdp: i.toRawSDP()
						}) : e
					}, Xd.prototype._adjustRemoteMediaDirection = function(e) {
						const t = new Ad(e.sdp);
						return [_i.AUDIO, _i.VIDEO].forEach((e => {
							const n = t.selectMedia(e),
								i = this.getLocalTracks(e).length,
								s = this.getRemoteTracks(null, e).length;
							n.forEach(((e, t) => {
								e.direction = i && i === s ? Br.SENDRECV : i || s ? i ? s ? i > s ? t ? Br.RECVONLY : Br.SENDRECV : t ? Br.SENDONLY : Br.SENDRECV : Br.RECVONLY : Br.SENDONLY : Br.INACTIVE
							}))
						})), new RTCSessionDescription({
							type: e.type,
							sdp: t.toRawSDP()
						})
					}, Xd.prototype._mungeOpus = function(e) {
						const {
							audioQuality: t
						} = this.options;
						if (!(null != t && t.enableOpusDtx || null != t && t.stereo || null != t && t.opusMaxAverageBitrate)) return e;
						const n = Wr.parse(e.sdp),
							i = n.media;
						for (const e of i)
							if ("audio" === e.type) {
								const {
									payload: n
								} = e.rtp.find((e => e.codec === jr.OPUS));
								if (!n) continue;
								let i = e.fmtp.find((e => e.payload === n));
								i || (i = {
									payload: n,
									config: ""
								});
								const s = Wr.parseParams(i.config);
								let r = !1;
								if (null != t && t.stereo && (s.stereo = 1, r = !0), null != t && t.opusMaxAverageBitrate && (s.maxaveragebitrate = t.opusMaxAverageBitrate, r = !0), !Wn.isFirefox() && null != t && t.enableOpusDtx && (s.usedtx = 1, r = !0), !r) continue;
								let o = "";
								for (const e of Object.keys(s)) o += `${e}=${s[e]}; `;
								i.config = o.trim()
							} return new RTCSessionDescription({
							type: e.type,
							sdp: Wr.write(n)
						})
					}, Xd.prototype._mungeInactive = function(e) {
						const t = Wr.parse(e.sdp),
							n = t.media;
						for (const e of n) e.direction = Br.INACTIVE, e.ssrcs = void 0, e.ssrcGroups = void 0;
						return new RTCSessionDescription({
							type: e.type,
							sdp: Wr.write(t)
						})
					}, Xd.prototype._initializeDtlsTransport = function() {
						if (!this.peerconnection.getSenders || this._dtlsTransport) return;
						const e = this.peerconnection.getSenders();
						0 !== e.length && e[0].transport && (this._dtlsTransport = e[0].transport, this._dtlsTransport.onerror = e => {
							Wd.error(`${this} DtlsTransport error: ${e}`)
						}, this._dtlsTransport.onstatechange = () => {
							this.trace("dtlsTransport.onstatechange", this._dtlsTransport.state)
						})
					}, Xd.prototype._setVp9MaxBitrates = function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						if (!this.codecPreference) return e;
						const n = Wr.parse(e.sdp),
							i = t ? Br.RECVONLY : Br.SENDONLY,
							s = n.media.filter((e => e.type === _i.VIDEO && e.direction !== i));
						for (const e of s)
							if (this.codecPreference.mimeType === jr.VP9) {
								const t = this.tpcUtils.videoBitrates.VP9 || this.tpcUtils.videoBitrates,
									n = t.high ? t.high : Gd,
									i = t.ssHigh ? t.ssHigh : Gd,
									s = e.mid,
									r = Ns.isMultiStreamSendSupportEnabled() ? s === this._getDesktopTrackMid() : this._isSharingScreen(),
									o = Math.floor((r ? i : n) / 1e3);
								e.bandwidth = [{
									type: "AS",
									limit: o
								}]
							} else e.bandwidth = void 0;
						return new RTCSessionDescription({
							type: e.type,
							sdp: Wr.write(n)
						})
					}, Xd.prototype.configureSenderVideoEncodings = function() {
						let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
						if (e) return this.setSenderVideoConstraints(this._senderMaxHeights.get(e.getSourceName()), e);
						const t = [];
						for (const e of this.getLocalVideoTracks()) t.push(this.setSenderVideoConstraints(this._senderMaxHeights.get(e.getSourceName()), e));
						return Promise.allSettled(t)
					}, Xd.prototype.setLocalDescription = function(e) {
						let t = e;
						return this.trace("setLocalDescription::preTransform", zd(t)), t = this._mungeOpus(t), this._usesUnifiedPlan || (t = this._adjustLocalMediaDirection(t), t = this._ensureSimulcastGroupIsLast(t)), t = this._mungeCodecOrder(t), t = this._setVp9MaxBitrates(t, !0), this.trace("setLocalDescription::postTransform", zd(t)), new Promise(((e, n) => {
							this.peerconnection.setLocalDescription(t).then((() => {
								this.trace("setLocalDescriptionOnSuccess");
								const n = Yr.getUfrag(t.sdp);
								n !== this.localUfrag && (this.localUfrag = n, this.eventEmitter.emit(Oi.default.LOCAL_UFRAG_CHANGED, this, n)), this._initializeDtlsTransport(), e()
							}), (e => {
								this.trace("setLocalDescriptionOnFailure", e), this.eventEmitter.emit(Oi.default.SET_LOCAL_DESCRIPTION_FAILED, e, this), n(e)
							}))
						}))
					}, Xd.prototype.setAudioTransferActive = function(e) {
						Wd.debug(`${this} audio transfer active: ${e}`);
						const t = this.audioTransferActive !== e;
						return this.audioTransferActive = e, this._usesUnifiedPlan ? (this.tpcUtils.setAudioTransferActive(e), !1) : t
					}, Xd.prototype.setRemoteDescription = function(e) {
						let t = e;
						if (this.trace("setRemoteDescription::preTransform", zd(e)), t = this._mungeOpus(t), this._usesUnifiedPlan) {
							if (!this.isP2P) {
								const e = this.peerconnection.remoteDescription;
								t = this.interop.toUnifiedPlan(t, e), this.trace("setRemoteDescription::postTransform (Unified)", zd(t))
							}
							this.isSimulcastOn() && (t = this.tpcUtils.insertUnifiedPlanSimulcastReceive(t), this.trace("setRemoteDescription::postTransform (sim receive)", zd(t))), t = this.tpcUtils.ensureCorrectOrderOfSsrcs(t), this.trace("setRemoteDescription::postTransform (correct ssrc order)", zd(t))
						} else this.isSimulcastOn() && (t = this.simulcast.mungeRemoteDescription(t, !0), this.trace("setRemoteDescription::postTransform (simulcast)", zd(t))), t = function(e) {
							if ("object" != typeof e || null === e || "string" != typeof e.sdp) return Wd.warn("An empty description was passed as an argument"), e;
							const t = n(8310),
								i = t.parse(e.sdp);
							void 0 !== i && void 0 !== i.media && Array.isArray(i.media) && i.media.forEach((e => {
								const t = [],
									n = [];
								if (void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach((e => {
										void 0 !== e.semantics && "FID" === e.semantics && void 0 !== e.ssrcs && t.push(Number(e.ssrcs.split(" ")[0]))
									})), Array.isArray(e.ssrcs)) {
									let i;
									for (i = 0; i < e.ssrcs.length; i++) "object" == typeof e.ssrcs[i] && void 0 !== e.ssrcs[i].id && t.indexOf(e.ssrcs[i].id) >= 0 && (n.push(e.ssrcs[i]), delete e.ssrcs[i]);
									for (i = 0; i < e.ssrcs.length; i++) void 0 !== e.ssrcs[i] && n.push(e.ssrcs[i]);
									e.ssrcs = function() {
										let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
										if (!Wn.isChrome() || !Wn.isVersionGreaterThan(70)) return e;
										let t = [...e];
										return e.filter((e => "mslabel" === e.attribute && "-" === e.value)).map((e => e.id)).forEach((e => {
											const n = t.find((t => t.id === e && "cname" === t.attribute));
											n.value = `${Br.RECVONLY}-${e}`, t = t.filter((t => t.id !== e)), t.push(n)
										})), t
									}(n)
								}
							}));
							const s = t.write(i);
							return new RTCSessionDescription({
								type: e.type,
								sdp: s
							})
						}(t);
						return t = this._mungeCodecOrder(t), t = this._setVp9MaxBitrates(t), this.trace("setRemoteDescription::postTransform (munge codec order)", zd(t)), new Promise(((e, n) => {
							this.peerconnection.setRemoteDescription(t).then((() => {
								this.trace("setRemoteDescriptionOnSuccess");
								const n = Yr.getUfrag(t.sdp);
								n !== this.remoteUfrag && (this.remoteUfrag = n, this.eventEmitter.emit(Oi.default.REMOTE_UFRAG_CHANGED, this, n)), this._initializeDtlsTransport(), e()
							}), (e => {
								this.trace("setRemoteDescriptionOnFailure", e), this.eventEmitter.emit(Oi.default.SET_REMOTE_DESCRIPTION_FAILED, e, this), n(e)
							}))
						}))
					}, Xd.prototype.setSenderVideoConstraints = function(e, t) {
						var n;
						if (e < 0) throw new Error(`Invalid frameHeight: ${e}`);
						const i = t.getSourceName();
						if (this._senderMaxHeights.get(i) === e) return Promise.resolve();
						if (this._senderMaxHeights.set(i, e), !t || t.isMuted()) return Promise.resolve();
						const s = this.findSenderForTrack(t.getTrack());
						if (!s) return Promise.resolve();
						const r = s.getParameters();
						if (null == r || null === (n = r.encodings) || void 0 === n || !n.length) return Promise.resolve();
						const o = t.getVideoType() === Ni.VideoType.DESKTOP && this._capScreenshareBitrate,
							a = o ? "maintain-resolution" : "maintain-framerate";
						r.degradationPreference = a, Wd.info(`${this} Setting degradation preference [preference=${a},track=${t}`), this.encodingsEnabledState = this.tpcUtils.calculateEncodingsActiveState(t, e);
						const c = this.tpcUtils.calculateEncodingsBitrates(t),
							d = t.getVideoType();
						if (this.isSimulcastOn()) {
							for (const e in r.encodings) {
								var l, u;
								r.encodings.hasOwnProperty(e) && (r.encodings[e].active = this.encodingsEnabledState[e], Wn.isFirefox() && (r.encodings[e].degradationPreference = a), this.getConfiguredVideoCodec() === jr.VP8 && (null !== (l = this.options) && void 0 !== l && null !== (u = l.videoQuality) && void 0 !== u && u.maxBitratesVideo || o || this._usesUnifiedPlan) && (r.encodings[e].maxBitrate = c[e]))
							}
							this.tpcUtils.updateEncodingsResolution(t, r)
						} else if (e > 0) {
							var h, p;
							let n = 1;
							if (d === Ni.VideoType.CAMERA && t.resolution > e && (n = Math.floor(t.resolution / e)), r.encodings[0].active = !0, r.encodings[0].scaleResolutionDownBy = n, Wn.isFirefox() && (r.encodings[0].degradationPreference = a), this.getConfiguredVideoCodec() === jr.VP8 && null !== (h = this.options) && void 0 !== h && null !== (p = h.videoQuality) && void 0 !== p && p.maxBitratesVideo) {
								var m;
								let e = null === (m = this.getTargetVideoBitrates()) || void 0 === m ? void 0 : m.high;
								var f, g;
								d === Ni.VideoType.CAMERA && (e = null !== (f = null === (g = this.tpcUtils._getVideoStreamEncodings(t.getVideoType()).find((e => e.scaleResolutionDownBy === n))) || void 0 === g ? void 0 : g.maxBitrate) && void 0 !== f ? f : e), r.encodings[0].maxBitrate = e
							}
						} else r.encodings[0].active = !1;
						return Wd.info(`${this} setting max height=${e},encodings=${JSON.stringify(r.encodings)}`), s.setParameters(r).then((() => {
							t.maxEnabledResolution = e, this.eventEmitter.emit(Oi.default.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED, t)
						}))
					}, Xd.prototype.setVideoTransferActive = function(e) {
						Wd.debug(`${this} video transfer active: ${e}`);
						const t = this.videoTransferActive !== e;
						return this.videoTransferActive = e, this._usesUnifiedPlan ? (this.tpcUtils.setVideoTransferActive(e), !1) : t
					}, Xd.prototype.sendTones = function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 200,
							n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 200;
						if (!this._dtmfSender) {
							if (this.peerconnection.getSenders) {
								const e = this.peerconnection.getSenders().find((e => e.dtmf));
								this._dtmfSender = e && e.dtmf, this._dtmfSender && Wd.info(`${this} initialized DTMFSender using getSenders`)
							}
							if (!this._dtmfSender) {
								const e = Array.from(this.localTracks.values()).find((e => e.isAudioTrack()));
								this.peerconnection.createDTMFSender && e && (this._dtmfSender = this.peerconnection.createDTMFSender(e.getTrack())), this._dtmfSender && Wd.info(`${this} initialized DTMFSender using deprecated createDTMFSender`)
							}
							this._dtmfSender && (this._dtmfSender.ontonechange = this._onToneChange.bind(this))
						}
						if (this._dtmfSender) {
							if (this._dtmfSender.toneBuffer) return void this._dtmfTonesQueue.push({
								tones: e,
								duration: t,
								interToneGap: n
							});
							this._dtmfSender.insertDTMF(e, t, n)
						} else Wd.warn(`${this} sendTones - failed to select DTMFSender`)
					}, Xd.prototype._onToneChange = function(e) {
						if (this._dtmfSender && "" === e.tone && this._dtmfTonesQueue.length) {
							const {
								tones: e,
								duration: t,
								interToneGap: n
							} = this._dtmfTonesQueue.shift();
							this._dtmfSender.insertDTMF(e, t, n)
						}
					}, Xd.prototype.generateRecvonlySsrc = function() {
						const e = Yr.generateSsrc();
						Wd.info(`${this} generated new recvonly SSRC=${e}`), this.sdpConsistency.setPrimarySsrc(e)
					}, Xd.prototype.clearRecvonlySsrc = function() {
						Wd.info(`${this} Clearing primary video SSRC!`), this.sdpConsistency.clearVideoSsrcCache()
					}, Xd.prototype.close = function() {
						this.trace("stop"), this.signalingLayer.off(hd, this._peerMutedChanged), this.signalingLayer.off(pd, this._peerVideoTypeChanged), this._usesUnifiedPlan && this.peerconnection.removeEventListener("track", this.onTrack);
						for (const e of this.remoteTracks.values())
							for (const t of e.values())
								for (const e of t) this._removeRemoteTrack(e);
						this.remoteTracks.clear(), this._addedStreams = [], this._dtmfSender = null, this._dtmfTonesQueue = [], this.rtc._removePeerConnection(this) || Wd.error(`${this} RTC._removePeerConnection returned false`), null !== this.statsinterval && (window.clearInterval(this.statsinterval), this.statsinterval = null), Wd.info(`${this} Closing peerconnection`), this.peerconnection.close()
					}, Xd.prototype.createAnswer = function(e) {
						return this._createOfferOrAnswer(!1, e)
					}, Xd.prototype.createOffer = function(e) {
						return this._createOfferOrAnswer(!0, e)
					}, Xd.prototype._createOfferOrAnswer = function(e, t) {
						const n = e ? "Offer" : "Answer";
						this.trace(`create${n}`, JSON.stringify(t, null, " "));
						const i = (e, t, i) => {
								try {
									this.trace(`create${n}OnSuccess::preTransform`, zd(e)), this._usesUnifiedPlan || (this.hasAnyTracksOfType(_i.VIDEO) || this.sdpConsistency.hasPrimarySsrcCached() || this.generateRecvonlySsrc(), e = new RTCSessionDescription({
										type: e.type,
										sdp: this.sdpConsistency.makeVideoPrimarySsrcsConsistent(e.sdp)
									}), this.trace(`create${n}OnSuccess::postTransform (make primary audio/video ssrcs consistent)`, zd(e)));
									const i = this.getLocalVideoTracks()[0];
									this.isSimulcastOn() && Wn.usesSdpMungingForSimulcast() && ((null == i ? void 0 : i.getVideoType()) === Ni.VideoType.CAMERA || this._usesUnifiedPlan) && (e = this.simulcast.mungeLocalDescription(e), this.trace(`create${n} OnSuccess::postTransform (simulcast)`, zd(e))), !this.options.disableRtx && Wn.usesSdpMungingForSimulcast() && (e = new RTCSessionDescription({
										type: e.type,
										sdp: this.rtxModifier.modifyRtxSsrcs(e.sdp)
									}), this.trace(`create${n}OnSuccess::postTransform (rtx modifier)`, zd(e)));
									const s = this._extractSSRCMap(e);
									this._processLocalSSRCsMap(s), t(e)
								} catch (t) {
									this.trace(`create${n}OnError`, t), this.trace(`create${n}OnError`, zd(e)), Wd.error(`${this} create${n}OnError`, t, zd(e)), i(t)
								}
							},
							s = (t, i) => {
								this.trace(`create${n}OnFailure`, t);
								const s = e ? Oi.default.CREATE_OFFER_FAILED : Oi.default.CREATE_ANSWER_FAILED;
								this.eventEmitter.emit(s, t, this), i(t)
							};
						if (this._usesTransceiverCodecPreferences) {
							const e = this.peerconnection.getTransceivers().find((e => {
								var t, n;
								return e.receiver && (null === (t = e.receiver) || void 0 === t || null === (n = t.track) || void 0 === n ? void 0 : n.kind) === _i.VIDEO
							}));
							if (e) {
								var r, o, a;
								let t = null === (r = RTCRtpReceiver.getCapabilities(_i.VIDEO)) || void 0 === r ? void 0 : r.codecs;
								const n = null === (o = this.codecPreference) || void 0 === o ? void 0 : o.disabledCodecMimeType,
									i = null === (a = this.codecPreference) || void 0 === a ? void 0 : a.mimeType;
								t && n && (t = t.filter((e => e.mimeType.toLowerCase() !== `${_i.VIDEO}/${n}`))), t && i && i !== n && t.sort((e => e.mimeType.toLowerCase() === `${_i.VIDEO}/${i}` ? -1 : 1)), Wn.isChromiumBased() && (t = t.filter((e => e.mimeType.toLowerCase() !== `${_i.VIDEO}/${jr.ULPFEC}`)));
								try {
									e.setCodecPreferences(t)
								} catch (e) {
									Wd.warn(`${this} Setting codec[preference=${i},disabledCodecMimeType=${n}] failed`, e)
								}
							}
						}
						return new Promise(((n, r) => {
							let o;
							o = e ? this.peerconnection.createOffer(t) : this.peerconnection.createAnswer(t), o.then((e => i(e, n, r)), (e => s(e, r)))
						}))
					}, Xd.prototype._extractPrimarySSRC = function(e) {
						return e && e.groups && e.groups.length ? e.groups[0].ssrcs[0] : e && e.ssrcs && e.ssrcs.length ? e.ssrcs[0] : null
					}, Xd.prototype._processLocalSSRCsMap = function(e) {
						for (const t of this.localTracks.values()) {
							const n = Sd(t.getSourceName()),
								i = this._usesUnifiedPlan ? `${t.getType()}-${n}` : t.storedMSID;
							if (e.has(i)) {
								const n = e.get(i);
								if (!n) return void Wd.error(`${this} No SSRC found for stream=${i}`);
								const s = this.localSSRCs.get(t.rtcId),
									r = this._extractPrimarySSRC(n),
									o = this._extractPrimarySSRC(s);
								r !== o && (o && Wd.error(`${this} Overwriting SSRC for track=${t}] with ssrc=${n}`), this.localSSRCs.set(t.rtcId, n), this.eventEmitter.emit(Oi.default.LOCAL_TRACK_SSRC_UPDATED, t, r))
							} else t.isVideoTrack() || t.isMuted() || Wd.warn(`${this} No SSRCs found in the local SDP for track=${t}, stream=${i}`)
						}
					}, Xd.prototype.addRemoteSsrc = function(e) {
						const t = this.remoteSSRCs.has(e);
						return t || this.remoteSSRCs.add(e), !t
					}, Xd.prototype.addIceCandidate = function(e) {
						return this.trace("addIceCandidate", JSON.stringify({
							candidate: e.candidate,
							sdpMid: e.sdpMid,
							sdpMLineIndex: e.sdpMLineIndex,
							usernameFragment: e.usernameFragment
						}, null, " ")), this.peerconnection.addIceCandidate(e)
					}, Xd.prototype.getActiveSimulcastStreams = function() {
						let e = 1;
						var t;
						return this.isSimulcastOn() && this.encodingsEnabledState ? e = null === (t = this.encodingsEnabledState.filter((e => Boolean(e)))) || void 0 === t ? void 0 : t.length : this.isSimulcastOn() && (e = qd.length), e
					}, Xd.prototype.getStats = function() {
						return this.peerconnection.getStats()
					}, Xd.prototype.generateNewStreamSSRCInfo = function(e) {
						const t = e.rtcId;
						let n = this._getSSRC(t);
						if (n && Wd.error(`${this} Overwriting local SSRCs for track id=${t}`), !this.isSimulcastOn() || e.getVideoType() !== Ni.VideoType.CAMERA && this.isSharingLowFpsScreen()) n = {
							ssrcs: [Yr.generateSsrc()],
							groups: []
						};
						else {
							n = {
								ssrcs: [],
								groups: []
							};
							for (let e = 0; e < qd.length; e++) n.ssrcs.push(Yr.generateSsrc());
							n.groups.push({
								ssrcs: n.ssrcs.slice(),
								semantics: "SIM"
							})
						}
						if (!this.options.disableRtx) {
							const e = n.ssrcs.length;
							for (let t = 0; t < e; ++t) {
								const e = n.ssrcs[t],
									i = Yr.generateSsrc();
								n.ssrcs.push(i), n.groups.push({
									ssrcs: [e, i],
									semantics: "FID"
								})
							}
						}
						return n.msid = e.storedMSID, this.localSSRCs.set(t, n), n
					}, Xd.prototype.usesUnifiedPlan = function() {
						return this._usesUnifiedPlan
					}, Xd.prototype.toString = function() {
						return `TPC[id=${this.id},type=${this.isP2P?"P2P":"JVB"}]`
					};
					const Qd = (0, S.getLogger)("modules/RTC/RTC.js");
					let Zd, el = 0,
						tl = 0;

					function nl() {
						let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
						return e.map((e => {
							const {
								sourceId: t,
								sourceType: n,
								stream: i,
								track: s,
								videoType: r,
								effects: o
							} = e, {
								deviceId: a,
								facingMode: c
							} = s.getSettings();
							return tl = ui(tl), new ed({
								deviceId: a,
								facingMode: c,
								mediaType: s.kind,
								rtcId: tl,
								sourceId: t,
								sourceType: n,
								stream: i,
								track: s,
								videoType: r || null,
								effects: o
							})
						}))
					}
					class il extends Yi {
						constructor(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
							super(), this.conference = e, this.peerConnections = new Map, this.localTracks = [], this.options = t, this._channel = null, this._lastN = void 0, this._forwardedSources = null, this._forwardedSourcesChangeListener = this._onForwardedSourcesChanged.bind(this), this._onDeviceListChanged = this._onDeviceListChanged.bind(this), this._updateAudioOutputForAudioTracks = this._updateAudioOutputForAudioTracks.bind(this), Xc.isDeviceChangeAvailable("output") && (Xc.addListener(Oi.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), Xc.addListener(Oi.default.DEVICE_LIST_CHANGED, this._onDeviceListChanged))
						}
						destroy() {
							Xc.removeListener(Oi.default.AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), Xc.removeListener(Oi.default.DEVICE_LIST_CHANGED, this._onDeviceListChanged), this._channelOpenListener && this.removeListener(Oi.default.DATA_CHANNEL_OPEN, this._channelOpenListener)
						}
						static createLocalTracks(e) {
							return nl(e)
						}
						static obtainAudioAndVideoPermissions(e) {
							return Xc.obtainAudioAndVideoPermissions(e).then((e => nl(e)))
						}
						initializeBridgeChannel(e, t) {
							this._channel = new ba(e, t, this.eventEmitter), this._channelOpenListener = () => {
								const e = (e, t, n) => {
									ei().callErrorHandler(e), Qd.error(`Cannot send ${t}(${JSON.stringify(n)}) endpoint message`, e)
								};
								if (this._receiverVideoConstraints) try {
									this._channel.sendReceiverVideoConstraintsMessage(this._receiverVideoConstraints)
								} catch (t) {
									e(t, "ReceiverVideoConstraints", this._receiverVideoConstraints)
								}
								if (void 0 !== this._lastN && -1 !== this._lastN) try {
									this._channel.sendSetLastNMessage(this._lastN)
								} catch (t) {
									e(t, "LastNChangedEvent", this._lastN)
								}
							}, this.addListener(Oi.default.DATA_CHANNEL_OPEN, this._channelOpenListener), this.addListener(Oi.default.FORWARDED_SOURCES_CHANGED, this._forwardedSourcesChangeListener)
						}
						_onDeviceListChanged() {
							this._updateAudioOutputForAudioTracks(Xc.getAudioOutputDevice())
						}
						_onForwardedSourcesChanged() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
							const t = this._forwardedSources || [];
							let n = [],
								i = [];
							const s = Date.now();
							this._forwardedSources = e, n = t.filter((e => !this.isInForwardedSources(e))), i = e.filter((e => -1 === t.indexOf(e))), Qd.debug(`Fowarded sources changed leaving=${n}, entering=${i} at ${s}`), this.conference.eventEmitter.emit(Se, n, i, s)
						}
						onCallEnded() {
							this._channel && (this._channel && "websocket" === this._channel.mode && this._channel.close(), this._channel = null)
						}
						setDesktopSharingFrameRate(e) {
							Xc.setDesktopSharingFrameRate(e)
						}
						setReceiverVideoConstraints(e) {
							this._receiverVideoConstraints = e, this._channel && this._channel.isOpen() && this._channel.sendReceiverVideoConstraintsMessage(e)
						}
						sendSourceVideoType(e, t) {
							this._channel && this._channel.isOpen() && this._channel.sendSourceVideoTypeMessage(e, t)
						}
						static addListener(e, t) {
							Xc.addListener(e, t)
						}
						static removeListener(e, t) {
							Xc.removeListener(e, t)
						}
						static init() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
							return this.options = e, Xc.init(this.options)
						}
						createPeerConnection(e, t, n, i) {
							const s = JSON.parse(JSON.stringify(Xc.pcConstraints));
							i.enableInsertableStreams && (Qd.debug("E2EE - setting insertable streams constraints"), t.encodedInsertableStreams = !0), Wn.isChromiumBased() && !i.usesUnifiedPlan && (Qd.debug("WebRTC application is running in plan-b mode"), t.sdpSemantics = "plan-b"), i.forceTurnRelay && (t.iceTransportPolicy = "relay"), t.bundlePolicy = "max-bundle", el = ui(el);
							const r = new Xd(this, el, e, t, s, n, i);
							return this.peerConnections.set(r.id, r), r
						}
						_removePeerConnection(e) {
							const t = e.id;
							return !!this.peerConnections.has(t) && (this.peerConnections.delete(t), !0)
						}
						addLocalTrack(e) {
							if (!e) throw new Error("track must not be null nor undefined");
							this.localTracks.push(e), e.conference = this.conference
						}
						getForwardedSources() {
							return this._forwardedSources
						}
						getLocalVideoTrack() {
							const e = this.getLocalTracks(_i.VIDEO);
							return e.length ? e[0] : void 0
						}
						getLocalVideoTracks() {
							return this.getLocalTracks(_i.VIDEO)
						}
						getLocalAudioTrack() {
							const e = this.getLocalTracks(_i.AUDIO);
							return e.length ? e[0] : void 0
						}
						getLocalEndpointId() {
							return this.conference.myUserId()
						}
						getLocalTracks(e) {
							let t = this.localTracks.slice();
							return void 0 !== e && (t = t.filter((t => t.getType() === e))), t
						}
						getRemoteTracks(e) {
							let t = [];
							for (const n of this.peerConnections.values()) {
								const i = n.getRemoteTracks(void 0, e);
								i && (t = t.concat(i))
							}
							return t
						}
						setAudioMute(e) {
							const t = [];
							return this.getLocalTracks(_i.AUDIO).forEach((n => {
								t.push(e ? n.mute() : n.unmute())
							})), Promise.all(t)
						}
						setVideoMute(e) {
							const t = [];
							return this.getLocalTracks(_i.VIDEO).forEach((n => {
								t.push(e ? n.mute() : n.unmute())
							})), Promise.all(t)
						}
						removeLocalTrack(e) {
							const t = this.localTracks.indexOf(e); - 1 !== t && this.localTracks.splice(t, 1)
						}
						static attachMediaStream(e, t) {
							return Xc.attachMediaStream(e, t)
						}
						static isDeviceListAvailable() {
							return Xc.isDeviceListAvailable()
						}
						static isDeviceChangeAvailable(e) {
							return Xc.isDeviceChangeAvailable(e)
						}
						static isWebRtcSupported() {
							return Wn.isSupported()
						}
						static getAudioOutputDevice() {
							return Xc.getAudioOutputDevice()
						}
						static getCurrentlyAvailableMediaDevices() {
							return Xc.getCurrentlyAvailableMediaDevices()
						}
						static arePermissionsGrantedForAvailableDevices() {
							return Xc.arePermissionsGrantedForAvailableDevices()
						}
						static getEventDataForActiveDevice(e) {
							return Xc.getEventDataForActiveDevice(e)
						}
						static setAudioOutputDevice(e) {
							return Xc.setAudioOutputDevice(e)
						}
						static isUserStream(e) {
							return il.isUserStreamById(e.id)
						}
						static isUserStreamById(e) {
							return e && "mixedmslabel" !== e && "default" !== e
						}
						static enumerateDevices(e) {
							Xc.enumerateDevices(e)
						}
						static stopMediaStream(e) {
							Xc.stopMediaStream(e)
						}
						static isDesktopSharingEnabled() {
							return Xc.isDesktopSharingEnabled()
						}
						closeBridgeChannel() {
							this._channel && (this._channel.close(), this._channel = null)
						}
						setAudioLevel(e, t, n, i) {
							const s = e.getTrackBySSRC(t);
							s && (s.isAudioTrack() ? (s.isLocal() !== i && Qd.error(`${s} was expected to ${i?"be":"not be"} local`), s.setAudioLevel(n, e)) : Qd.warn(`Received audio level for non-audio track: ${t}`))
						}
						sendChannelMessage(e, t) {
							if (!this._channel) throw new Error("Channel support is disabled!");
							this._channel.sendMessage(e, t)
						}
						sendEndpointStatsMessage(e) {
							this._channel && this._channel.isOpen() && this._channel.sendEndpointStatsMessage(e)
						}
						setLastN(e) {
							this._lastN !== e && (this._lastN = e, this._channel && this._channel.isOpen() && this._channel.sendSetLastNMessage(e), this.eventEmitter.emit(Oi.default.LASTN_VALUE_CHANGED, e))
						}
						isInForwardedSources(e) {
							return !this._forwardedSources || this._forwardedSources.indexOf(e) > -1
						}
						_updateAudioOutputForAudioTracks(e) {
							const t = this.getRemoteTracks(_i.AUDIO);
							for (const n of t) n.setAudioOutput(e)
						}
					}! function(e) {
						e.LOCAL_STATS_UPDATED = "cq.local_stats_updated", e.REMOTE_STATS_UPDATED = "cq.remote_stats_updated"
					}(Zd || (Zd = {}));
					const sl = Zd.LOCAL_STATS_UPDATED,
						rl = Zd.REMOTE_STATS_UPDATED,
						ol = n(6125),
						{
							VideoType: al
						} = n(3408),
						{
							XMPPEvents: cl
						} = n(609),
						dl = (0, S.getLogger)("modules/connectivity/ConnectionQuality.js"),
						ll = [{
							width: 1920,
							height: 1080,
							layers: 3,
							target: "high"
						}, {
							width: 1280,
							height: 720,
							layers: 3,
							target: "high"
						}, {
							width: 960,
							height: 540,
							layers: 3,
							target: "standard"
						}, {
							width: 640,
							height: 360,
							layers: 2,
							target: "standard"
						}, {
							width: 480,
							height: 270,
							layers: 2,
							target: "low"
						}, {
							width: 320,
							height: 180,
							layers: 1,
							target: "low"
						}];
					let ul = 800;
					class hl {
						constructor(e, t, n) {
							var i;
							this.eventEmitter = t, this._conference = e, this._localStats = {
								connectionQuality: 100,
								jvbRTT: void 0
							}, this._lastConnectionQualityUpdate = -1, this._options = n, this._remoteStats = {}, this._timeIceConnected = -1, this._timeVideoUnmuted = -1, (null === (i = this._options.config) || void 0 === i ? void 0 : i.startBitrate) > 0 && (ul = this._options.config.startBitrate), e.on(te, (() => {
								this._updateLocalConnectionQuality(0), this.eventEmitter.emit(sl, this._localStats), this._broadcastLocalStats()
							})), e.room.addListener(cl.ICE_CONNECTION_STATE_CHANGED, ((e, t) => {
								e.isP2P || "connected" !== t || (this._timeIceConnected = window.performance.now())
							})), e.on(de, ((e, t) => {
								"stats" === t.type && this._updateRemoteStats(e.getId(), t.values)
							})), e.on(le, ((e, t) => {
								this._updateRemoteStats(e.getId(), t)
							})), e.statistics.addConnectionStatsListener(this._updateLocalStats.bind(this)), e.on(Ge, (e => {
								e.isVideoTrack() && (e.isMuted() ? this._timeVideoUnmuted = -1 : this._maybeUpdateUnmuteTime())
							})), e.on($e, (e => {
								e.isVideoTrack() && !e.isMuted() && this._maybeUpdateUnmuteTime()
							})), e.rtc.on(Oi.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED, (e => {
								this._localStats.maxEnabledResolution = e.maxEnabledResolution
							})), e.on(ye, (e => {
								this._localStats.serverRegion = e
							})), e.on(Le, (e => {
								this._localStats.bridgeCount = Number((e || {})["bridge-count"])
							}))
						}
						_maybeUpdateUnmuteTime() {
							this._timeVideoUnmuted < 0 && (this._timeVideoUnmuted = window.performance.now())
						}
						_calculateConnectionQuality(e, t, n) {
							const i = ol[n];
							let s, r = 100;
							if (this._localStats.packetLoss && (s = this._localStats.packetLoss.upload, t && (s *= .5)), t || !i || e === al.DESKTOP || this._timeIceConnected < 0 || this._timeVideoUnmuted < 0) void 0 === s ? (dl.error("Cannot calculate connection quality, unknown packet loss."), r = 100) : r = s <= 2 ? 100 : s <= 4 ? 70 : s <= 6 ? 50 : s <= 8 ? 30 : s <= 12 ? 10 : 0;
							else {
								const e = this._conference.getActivePeerConnection();
								if (e) {
									var o, a;
									const t = e.isSimulcastOn(),
										n = e.getTargetVideoBitrates();
									n.codec = e.getConfiguredVideoCodec();
									const s = window.performance.now() - Math.max(this._timeVideoUnmuted, this._timeIceConnected),
										c = null !== (o = null === (a = this._options.config) || void 0 === a ? void 0 : a.pcStatsInterval) && void 0 !== o ? o : 1e4;
									let d = function(e, t, n, i) {
										let s = 0,
											r = Math.min(t.height, t.width),
											o = ll.find((e => e.height <= r));
										if (o && e && i.codec === Hr().VP8)
											for (r = o.height; r >= 180; r /= 2) {
												const e = r;
												if (o = ll.find((t => t.height === e)), !o) break;
												s += i[o.target]
											} else o && (s = i[o.target]);
										return Math.min(s / 1e3, function(e) {
											return e > 6e4 ? Number.MAX_SAFE_INTEGER : ul * Math.pow(1.08, e / 1e3)
										}(Math.max(0, n - 1e3)))
									}(t, i, s, n);
									d = Math.min(d, 2500), s > c && (r = 100 * this._localStats.bitrate.upload / d)
								}
								s && s >= 10 && (r = Math.min(r, 30))
							}
							if (this._lastConnectionQualityUpdate > 0) {
								const e = 2,
									t = this._localStats.connectionQuality,
									n = (window.performance.now() - this._lastConnectionQualityUpdate) / 1e3;
								r = Math.min(r, t + n * e)
							}
							return Math.min(100, r)
						}
						_updateLocalConnectionQuality(e) {
							this._localStats.connectionQuality = e, this._lastConnectionQualityUpdate = window.performance.now()
						}
						_broadcastLocalStats() {
							const e = {
								bitrate: this._localStats.bitrate,
								packetLoss: this._localStats.packetLoss,
								connectionQuality: this._localStats.connectionQuality,
								jvbRTT: this._localStats.jvbRTT,
								serverRegion: this._localStats.serverRegion,
								maxEnabledResolution: this._localStats.maxEnabledResolution,
								avgAudioLevels: this._localStats.localAvgAudioLevels
							};
							try {
								this._conference.sendEndpointStatsMessage(e)
							} catch (e) {}
						}
						_updateLocalStats(e, t) {
							if (!e.isP2P) {
								const e = t.transport && t.transport.length && t.transport[0].rtt;
								this._localStats.jvbRTT = e || void 0
							}
							if (e !== this._conference.getActivePeerConnection()) return;
							let n;
							const i = !this._conference.isConnectionInterrupted(),
								s = this._conference.getLocalVideoTrack(),
								r = s ? s.videoType : void 0,
								o = !s || s.isMuted(),
								a = s ? Math.min(s.resolution, s.maxEnabledResolution) : null;
							for (n in o || this._maybeUpdateUnmuteTime(), t) t.hasOwnProperty(n) && (this._localStats[n] = t[n]);
							i && this._updateLocalConnectionQuality(this._calculateConnectionQuality(r, o, a)), this.eventEmitter.emit(sl, this._localStats), this._broadcastLocalStats()
						}
						_updateRemoteStats(e, t) {
							this._remoteStats[e] = {
								bitrate: t.bitrate,
								packetLoss: t.packetLoss,
								connectionQuality: t.connectionQuality,
								jvbRTT: t.jvbRTT,
								serverRegion: t.serverRegion,
								maxEnabledResolution: t.maxEnabledResolution,
								avgAudioLevels: t.avgAudioLevels
							}, this.eventEmitter.emit(rl, e, this._remoteStats[e])
						}
						getStats() {
							return this._localStats
						}
					}
					const pl = (0, S.getLogger)("modules/connectivity/IceFailedHandling.js");
					class ml {
						constructor(e) {
							this._conference = e
						}
						_actOnIceFailed() {
							if (!this._conference.room) return;
							const {
								enableForcedReload: e,
								enableIceRestart: t
							} = this._conference.options.config, n = void 0 !== t && !t, i = this._conference.room.supportsRestartByTerminate(), s = i && !t;
							if (pl.info(`ICE failed, enableForcedReload: ${e}, enableIceRestart: ${t}, supports restart by terminate: ${i}`), n || !t && !i || e) {
								pl.info("ICE failed, but ICE restarts are disabled");
								const t = e ? P : k;
								return void this._conference.eventEmitter.emit(X, t)
							}
							const r = this._conference.jvbJingleSession,
								o = r && r.getIceConnectionState();
							r ? "connected" === o ? pl.info("ICE connection restored - not sending ICE failed") : (pl.info(`Sending ICE failed - the connection did not recover, ICE state: ${o}, use 'session-terminate': ${s}`), s ? this._conference.jvbJingleSession.terminate((() => {
								pl.info("session-terminate for ice restart - done")
							}), (e => {
								pl.error(`session-terminate for ice restart - error: ${e.message}`)
							}), {
								reason: "connectivity-error",
								reasonDescription: "ICE FAILED",
								requestRestart: !0,
								sendSessionTerminate: !0
							}) : this._conference.jvbJingleSession.sendIceFailedNotification()) : pl.warn("Not sending ICE failed - no JVB connection")
						}
						start() {
							this._conference.xmpp.ping(65e3).then((() => {
								this._canceled || (this._iceFailedTimeout = window.setTimeout((() => {
									this._iceFailedTimeout = void 0, this._actOnIceFailed()
								}), 2e3))
							}), (e => {
								pl.error("PING error/timeout - not sending ICE failed", e)
							}))
						}
						cancel() {
							this._canceled = !0, window.clearTimeout(this._iceFailedTimeout)
						}
					}
					let fl;
					! function(e) {
						e.DETECTOR_STATE_CHANGE = "detector_state_change", e.AUDIO_INPUT_STATE_CHANGE = "audio_input_state_changed", e.NO_AUDIO_INPUT = "no_audio_input_detected", e.VAD_NOISY_DEVICE = "detection.vad_noise_device", e.VAD_REPORT_PUBLISHED = "vad-report-published", e.VAD_SCORE_PUBLISHED = "detection.vad_score_published", e.VAD_TALK_WHILE_MUTED = "detection.vad_talk_while_muted"
					}(fl || (fl = {}));
					const gl = fl.DETECTOR_STATE_CHANGE,
						_l = fl.AUDIO_INPUT_STATE_CHANGE,
						vl = fl.NO_AUDIO_INPUT,
						Sl = fl.VAD_NOISY_DEVICE,
						El = fl.VAD_REPORT_PUBLISHED,
						yl = fl.VAD_SCORE_PUBLISHED,
						Tl = fl.VAD_TALK_WHILE_MUTED;
					class Cl extends(pt()) {
						constructor(e) {
							super(), this._conference = e, this._timeoutTrigger = null, this._hasAudioInput = null, Wn.supportsReceiverStats() || e.statistics.addAudioLevelListener(this._audioLevel.bind(this)), e.on($e, this._trackAdded.bind(this))
						}
						_clearTriggerTimeout() {
							clearTimeout(this._timeoutTrigger), this._timeoutTrigger = null
						}
						_handleAudioInputStateChange(e) {
							const t = 0 !== e;
							null !== this._hasAudioInput && this._hasAudioInput === t || (this._hasAudioInput = t, this.emit(_l, this._hasAudioInput))
						}
						_handleNoAudioInputDetection(e) {
							this._eventFired || (0 !== e || this._timeoutTrigger ? 0 !== e && this._timeoutTrigger && this._clearTriggerTimeout() : this._timeoutTrigger = setTimeout((() => {
								this._eventFired = !0, this.emit(vl)
							}), 4e3))
						}
						_audioLevel(e, t, n, i) {
							if (!i || !this._audioTrack) return;
							const s = e.localSSRCs.get(this._audioTrack.rtcId);
							s && s.ssrcs.includes(t) && (this._handleAudioInputStateChange(n), this._handleNoAudioInputDetection(n))
						}
						_trackAdded(e) {
							e.isLocalAudioTrack() && (this._audioTrack = e, this._eventFired = !1, this._clearTriggerTimeout(), Wn.supportsReceiverStats() && (e.on(Rt, (e => {
								this._handleNoAudioInputDetection(e)
							})), e.on(yt, (e => {
								this._handleNoAudioInputDetection(e), this._handleAudioInputStateChange(e)
							}))))
						}
					}
					class bl {
						constructor(e) {
							this.conference = e, e.addEventListener(Je, this._audioLevel.bind(this)), this.myUserID = this.conference.myUserId()
						}
						_audioLevel(e, t) {
							!this.conference.isP2PActive() || t <= .6 || e === this.myUserID && this.conference.getLocalAudioTrack().isMuted() || this.conference.rtc.eventEmitter.emit(Oi.default.DOMINANT_SPEAKER_CHANGED, e)
						}
					}

					function Al(e) {
						const t = window.AudioContext || window.webkitAudioContext;
						if (t) return new t(e)
					}
					class Rl extends(pt()) {
						constructor(e, t, n) {
							super(), this._procNodeSampleRate = e, this._vadProcessor = t, this._localTrack = n, this._bufferResidue = new Float32Array([]), this._audioContext = Al({
								sampleRate: t.getRequiredPCMFrequency()
							}), this._vadSampleSize = t.getSampleLength(), this._onAudioProcess = this._onAudioProcess.bind(this), this._initializeAudioContext()
						}
						static create(e, t, n) {
							return il.obtainAudioAndVideoPermissions({
								devices: ["audio"],
								micDeviceId: e
							}).then((i => {
								if (!i[0]) throw new Error(`Failed to create jitsi local track for device id: ${e}`);
								return new Rl(t, n, i[0])
							}))
						}
						_initializeAudioContext() {
							this._audioSource = this._audioContext.createMediaStreamSource(this._localTrack.stream), this._audioProcessingNode = this._audioContext.createScriptProcessor(this._procNodeSampleRate, 1, 1)
						}
						_onAudioProcess(e) {
							const t = e.inputBuffer.getChannelData(0),
								n = [...this._bufferResidue, ...t],
								i = Date.now();
							let s = 0;
							for (; s + this._vadSampleSize < n.length; s += this._vadSampleSize) {
								const e = n.slice(s, s + this._vadSampleSize),
									t = this._vadProcessor.calculateAudioFrameVAD(e.slice());
								this.emit(yl, {
									timestamp: i,
									score: t,
									pcmData: e,
									deviceId: this._localTrack.getDeviceId()
								})
							}
							this._bufferResidue = n.slice(s, n.length)
						}
						_connectAudioGraph() {
							this._audioProcessingNode.onaudioprocess = this._onAudioProcess, this._audioSource.connect(this._audioProcessingNode), this._audioProcessingNode.connect(this._audioContext.destination)
						}
						_disconnectAudioGraph() {
							this._audioProcessingNode.onaudioprocess = () => {}, this._audioProcessingNode.disconnect(), this._audioSource.disconnect()
						}
						_cleanupResources() {
							this._disconnectAudioGraph(), this._localTrack.stopStream()
						}
						getDeviceId() {
							return this._localTrack.getDeviceId()
						}
						getTrackLabel() {
							return this._localTrack.getDeviceLabel()
						}
						start() {
							this._connectAudioGraph()
						}
						stop() {
							this._disconnectAudioGraph(), this._bufferResidue = []
						}
						destroy() {
							this._destroyed || (this._cleanupResources(), this._destroyed = !0)
						}
					}
					const Il = (0, S.getLogger)("modules/detection/VADAudioAnalyser.js");
					class Pl extends ht.EventEmitter {
						constructor(e, t) {
							super(), this._createVADProcessor = t, this._vadEmitter = null, this._isVADEmitterRunning = !1, this._detectionServices = [], this._vadInitTracker = Promise.resolve(), this._processVADScore = this._processVADScore.bind(this), e.on($e, this._trackAdded.bind(this)), e.on(qe, this._trackRemoved.bind(this)), e.on(Ge, this._trackMuteChanged.bind(this))
						}
						addVADDetectionService(e) {
							this._detectionServices.push(e), e.on(gl, (() => {
								!this._detectionServices.filter((e => !0 === e.isActive())).length && this._isVADEmitterRunning ? this._stopVADEmitter() : this._isVADEmitterRunning || this._startVADEmitter()
							}))
						}
						_startVADEmitter() {
							this._vadEmitter && (this._vadEmitter.on(yl, this._processVADScore), this._vadEmitter.start(), this._isVADEmitterRunning = !0)
						}
						_stopVADEmitter() {
							this._vadEmitter && (this._vadEmitter.removeListener(yl, this._processVADScore), this._vadEmitter.stop()), this._isVADEmitterRunning = !1
						}
						_processVADScore(e) {
							for (const t of this._detectionServices) t.processVADScore(e)
						}
						_changeDetectorsMuteState(e) {
							for (const t of this._detectionServices) t.changeMuteState(e)
						}
						_trackAdded(e) {
							e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then((() => this._createVADProcessor())).then((t => Rl.create(e.getDeviceId(), 4096, t))).then((t => {
								Il.debug("Created VAD emitter for track: ", e.getTrackLabel()), this._vadEmitter = t, this._changeDetectorsMuteState(e.isMuted())
							})).catch((e => {
								Il.warn("Failed to start VADAudioAnalyser", e)
							})))
						}
						_trackMuteChanged(e) {
							e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then((() => {
								this._changeDetectorsMuteState(e.isMuted())
							})))
						}
						_trackRemoved(e) {
							e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then((() => {
								Il.debug("Removing track from VAD detection - ", e.getTrackLabel()), this._vadEmitter && (this._stopVADEmitter(), this._vadEmitter.destroy(), this._vadEmitter = null);
								for (const e of this._detectionServices) e.reset()
							})))
						}
					}
					class Dl extends ht.EventEmitter {
						constructor() {
							super(), this._processing = !1, this._scoreArray = [], this._audioLvlArray = [], this._active = !1, this._calculateNoisyScore = this._calculateNoisyScore.bind(this)
						}
						_calculateNoisyScore() {
							const e = hi(this._scoreArray),
								t = hi(this._audioLvlArray);
							e < .2 && t > .04 && (this.emit(Sl), this._setActiveState(!1)), this.reset()
						}
						_recordValues(e, t) {
							this._scoreArray.push(e), this._audioLvlArray.push(t)
						}
						_setActiveState(e) {
							this._active = e, this.emit(gl, this._active)
						}
						changeMuteState(e) {
							this._setActiveState(!e), this.reset()
						}
						isActive() {
							return this._active
						}
						reset() {
							this._processing = !1, this._scoreArray = [], this._audioLvlArray = [], clearTimeout(this._processTimeout)
						}
						processVADScore(e) {
							if (this._active)
								if (this._processing) {
									const t = pi(e.pcmData);
									this._recordValues(e.score, hi(t))
								} else if (e.score < .2) {
								const t = hi(pi(e.pcmData));
								t > .02 && (this._processing = !0, this._recordValues(e.score, t), this._processTimeout = setTimeout(this._calculateNoisyScore, 1500))
							}
						}
					}
					class wl extends ht.EventEmitter {
						constructor() {
							super(), this._processing = !1, this._scoreArray = [], this._active = !1, this._calculateVADScore = this._calculateVADScore.bind(this)
						}
						_calculateVADScore() {
							hi(this._scoreArray) > .6 && (this.emit(Tl), this._setActiveState(!1)), this.reset()
						}
						_setActiveState(e) {
							this._active = e, this.emit(gl, this._active)
						}
						changeMuteState(e) {
							this._setActiveState(e), this.reset()
						}
						isActive() {
							return this._active
						}
						processVADScore(e) {
							this._active && (this._processing ? this._scoreArray.push(e.score) : e.score > .9 && (this._processing = !0, this._scoreArray.push(e.score), this._processTimeout = setTimeout(this._calculateVADScore, 700)))
						}
						reset() {
							this._processing = !1, this._scoreArray = [], clearTimeout(this._processTimeout)
						}
					}
					let Ol;
					! function(e) {
						e.E2E_RTT_CHANGED = "e2eping.e2e_rtt_changed"
					}(Ol || (Ol = {}));
					const Nl = Ol.E2E_RTT_CHANGED,
						Ml = (0, S.getLogger)("modules/e2eping/e2eping.js"),
						Ll = "e2e-ping-request",
						kl = "e2e-ping-response";
					class xl {
						constructor(e, t) {
							this.participant = e, this.e2eping = t, this.id = e.getId(), this.requests = {}, this.lastRequestId = 1, this.sendRequest = this.sendRequest.bind(this), this.handleResponse = this.handleResponse.bind(this), this.maybeLogRttAndStop = this.maybeLogRttAndStop.bind(this), this.scheduleNext = this.scheduleNext.bind(this), this.stop = this.stop.bind(this), this.getDelay = this.getDelay.bind(this), this.timeout = this.scheduleNext()
						}
						scheduleNext() {
							return window.setTimeout(this.sendRequest, this.getDelay())
						}
						stop() {
							this.timeout && window.clearTimeout(this.timeout), this.e2eping.removeParticipant(this.id)
						}
						getDelay() {
							const e = this.e2eping.conference.getParticipants().length,
								t = e * (e - 1) / 2 * this.e2eping.numRequests / this.e2eping.maxMessagesPerSecond;
							return (1.5 - Math.random()) * Math.max(t / this.e2eping.numRequests * 1e3, 1e3)
						}
						sendRequest() {
							const e = this.lastRequestId++,
								t = {
									type: Ll,
									id: e
								};
							this.e2eping.sendMessage(t, this.id), this.requests[e] = {
								id: e,
								timeSent: window.performance.now()
							}
						}
						handleResponse(e) {
							const t = this.requests[e.id];
							t && (t.rtt = window.performance.now() - t.timeSent), this.maybeLogRttAndStop()
						}
						maybeLogRttAndStop() {
							let e, t, n = 1 / 0,
								i = 0,
								s = 0;
							for (t in this.requests) this.requests.hasOwnProperty(t) && (e = this.requests[t], s++, e.rtt && (i++, n = Math.min(n, e.rtt)));
							return i >= this.e2eping.numRequests ? (Ml.info(`Measured RTT=${n} ms to ${this.id} (in ${this.participant.getProperty("region")})`), this.stop(), void this.e2eping.conference.eventEmitter.emit(Nl, this.participant, n)) : s > 2 * this.e2eping.numRequests ? (Ml.info(`Stopping e2eping for ${this.id} because we sent ${s} with only ${i} responses.`), void this.stop()) : void(this.timeout = this.scheduleNext())
						}
					}
					class Fl {
						constructor(e, t, n) {
							this.conference = e, this.eventEmitter = e.eventEmitter, this.sendMessage = n, this.participants = {}, this.numRequests = 5, this.maxConferenceSize = 200, this.maxMessagesPerSecond = 250, t && t.e2eping && ("number" == typeof t.e2eping.numRequests && (this.numRequests = t.e2eping.numRequests), "number" == typeof t.e2eping.maxConferenceSize && (this.maxConferenceSize = t.e2eping.maxConferenceSize), "number" == typeof t.e2eping.maxMessagesPerSecond && (this.maxMessagesPerSecond = t.e2eping.maxMessagesPerSecond)), Ml.info(`Initializing e2e ping with numRequests=${this.numRequests}, maxConferenceSize=${this.maxConferenceSize}, maxMessagesPerSecond=${this.maxMessagesPerSecond}.`), this.participantJoined = this.participantJoined.bind(this), this.participantLeft = this.participantLeft.bind(this), e.on(ze, this.participantLeft), this.messageReceived = this.messageReceived.bind(this), e.on(de, this.messageReceived), this.conferenceJoined = this.conferenceJoined.bind(this), e.on(Y, this.conferenceJoined)
						}
						conferenceJoined() {
							this.conference.getParticipants().forEach((e => this.participantJoined(e.getId(), e))), this.conference.on(Xe, this.participantJoined)
						}
						messageReceived(e, t) {
							t.type === Ll ? this.handleRequest(e.getId(), t) : t.type === kl && this.handleResponse(e.getId(), t)
						}
						participantJoined(e, t) {
							this.participants[e] && (Ml.info(`Participant wrapper already exists for ${e}. Clearing.`), this.participants[e].stop()), this.conference.getParticipants().length > this.maxConferenceSize || this.conference.myUserId() > e && (Ml.info(`Starting e2eping for participant ${e}`), this.participants[e] = new xl(t, this))
						}
						removeParticipant(e) {
							this.participants[e] && delete this.participants[e]
						}
						participantLeft(e) {
							this.participants[e] && (this.participants[e].stop(), delete this.participants[e])
						}
						handleRequest(e, t) {
							if (t && t.id) {
								const n = {
									type: kl,
									id: t.id
								};
								this.sendMessage(n, e)
							} else Ml.info(`Received an invalid e2e ping request from ${e}.`)
						}
						handleResponse(e, t) {
							const n = this.participants[e];
							n && n.handleResponse(t)
						}
						stop() {
							Ml.info("Stopping e2eping"), this.conference.off(Xe, this.participantJoined), this.conference.off(ze, this.participantLeft), this.conference.off(de, this.messageReceived);
							for (const e in this.participants) this.participants.hasOwnProperty(e) && this.participants[e].stop();
							this.participants = {}
						}
					}
					const Vl = (0, S.getLogger)("modules/event/Jvb121EventGenerator.js");
					class Ul {
						constructor(e) {
							this._conference = e, this._jvb121 = !0, this._conference.addEventListener(Xe, (() => this.evaluateStatus())), this._conference.addEventListener(ze, (() => this.evaluateStatus())), this._conference.addEventListener(Ne, (() => this.evaluateStatus()))
						}
						evaluateStatus() {
							const e = this._jvb121,
								t = !this._conference.isP2PActive() && this._conference.getParticipantCount() <= 2;
							e !== t && (this._jvb121 = t, Vl.debug(`JVB121 status ${e} => ${t}`), this._conference.eventEmitter.emit(me, e, t))
						}
					}
					const jl = Symbol("kJitsiLiteMode"),
						Hl = (0, S.getLogger)("modules/litemode/LiteModeContext.js");
					class Bl {
						constructor(e) {
							this.enabled = Ns.isRunInLiteModeEnabled(), this.enabled && e.rtc.on(Oi.default.REMOTE_TRACK_ADDED, ((e, t) => this._setupLiteModeForTrack(t, e)))
						}
						_setupLiteModeForTrack(e, t) {
							if (!this.enabled) return;
							const n = e.findReceiverForTrack(t.track);
							if (!n) return void Hl.warn(`Could not set up lite mode for ${t}: receiver not found in: ${e}`);
							if (n[jl]) return;
							n[jl] = !0;
							const i = n.createEncodedStreams(),
								s = new TransformStream({
									transform: () => {}
								});
							i.readable.pipeThrough(s).pipeTo(i.writable)
						}
					}
					const $l = (0, S.getLogger)("modules/qualitycontrol/ReceiveVideoController.js"),
						Jl = 2160;
					class Gl {
						constructor(e) {
							this._lastN = null != e ? e : -1, this._maxFrameHeight = Jl, this._receiverVideoConstraints = {
								constraints: {},
								defaultConstraints: {
									maxHeight: this._maxFrameHeight
								},
								lastN: this._lastN
							}
						}
						get constraints() {
							var e;
							if (this._receiverVideoConstraints.lastN = this._lastN, null !== (e = Object.keys(this._receiverVideoConstraints.constraints)) && void 0 !== e && e.length)
								for (const [e, t] of Object.entries(this._receiverVideoConstraints.constraints)) t.maxHeight = this._maxFrameHeight;
							else this._receiverVideoConstraints.defaultConstraints = {
								maxHeight: this._maxFrameHeight
							};
							return this._receiverVideoConstraints
						}
						updateLastN(e) {
							const t = this._lastN !== e;
							return t && (this._lastN = e, $l.debug(`Updating ReceiverVideoConstraints lastN(${e})`)), t
						}
						updateReceiveResolution(e) {
							const t = this._maxFrameHeight !== e;
							return t && (this._maxFrameHeight = e, $l.debug(`Updating receive maxFrameHeight: ${e}`)), t
						}
						updateReceiverVideoConstraints(e) {
							const t = !_t()(this._receiverVideoConstraints, e);
							return t && (this._receiverVideoConstraints = e, $l.debug(`Updating ReceiverVideoConstraints ${JSON.stringify(e)}`)), t
						}
					}
					class ql {
						constructor(e, t) {
							var n;
							this._conference = e, this._rtc = t;
							const {
								config: i
							} = e.options;
							this._lastN = null !== (n = null == i ? void 0 : i.startLastN) && void 0 !== n ? n : (null == i ? void 0 : i.channelLastN) || -1, this._maxFrameHeight = Jl, this._sourceReceiverConstraints = new Map, this._receiverVideoConstraints = new Gl(this._lastN), this._conference.on(Te, (e => this._onMediaSessionStarted(e)))
						}
						_getDefaultSourceReceiverConstraints(e, t) {
							var n;
							const i = null != t ? t : Jl,
								s = (null === (n = e.peerconnection) || void 0 === n ? void 0 : n.getRemoteTracks(null, _i.VIDEO)) || [],
								r = new Map;
							for (const e of s) r.set(e.getSourceName(), i);
							return r
						}
						_onMediaSessionStarted(e) {
							e.isP2P ? e.setReceiverVideoConstraint(this._getDefaultSourceReceiverConstraints(e)) : this._rtc.setReceiverVideoConstraints(this._receiverVideoConstraints.constraints)
						}
						getLastN() {
							return this._lastN
						}
						setLastN(e) {
							this._lastN !== e && (this._lastN = e, this._receiverVideoConstraints.updateLastN(e) && this._rtc.setReceiverVideoConstraints(this._receiverVideoConstraints.constraints))
						}
						setPreferredReceiveMaxFrameHeight(e) {
							this._maxFrameHeight = e;
							for (const t of this._conference.getMediaSessions()) t.isP2P ? t.setReceiverVideoConstraint(this._getDefaultSourceReceiverConstraints(t, e)) : this._receiverVideoConstraints.updateReceiveResolution(e) && this._rtc.setReceiverVideoConstraints(this._receiverVideoConstraints.constraints)
						}
						setReceiverConstraints(e) {
							if (e) {
								if (Object.keys(e).includes("onStageEndpoints", "selectedEndpoints")) throw new Error('"onStageEndpoints" and "selectedEndpoints" are not supported when sourceNameSignaling is enabled.');
								if (this._receiverVideoConstraints.updateReceiverVideoConstraints(e)) {
									var t;
									this._lastN = null !== (t = e.lastN) && void 0 !== t ? t : this._lastN, this._rtc.setReceiverVideoConstraints(e);
									const n = this._conference.getMediaSessions().find((e => e.isP2P));
									if (!n) return;
									const i = Array.from(Object.entries(e.constraints)).map((e => (e[1] = e[1].maxHeight, e)));
									this._sourceReceiverConstraints = new Map(i), n.setReceiverVideoConstraint(this._sourceReceiverConstraints)
								}
							}
						}
					}
					const Kl = (0, S.getLogger)("modules/qualitycontrol/SendVideoController.js");
					class Wl {
						constructor(e, t) {
							this._conference = e, this._preferredSendMaxFrameHeight = 2160, this._rtc = t, this._sourceSenderConstraints = new Map, this._conference.on(Te, (e => this._onMediaSessionStarted(e))), this._conference.on(Ce, (() => this._configureConstraintsForLocalSources())), this._rtc.on(Oi.default.SENDER_VIDEO_CONSTRAINTS_CHANGED, (e => this._onSenderConstraintsReceived(e)))
						}
						_configureConstraintsForLocalSources() {
							for (const e of this._rtc.getLocalVideoTracks()) {
								const t = e.getSourceName();
								t && this._propagateSendMaxFrameHeight(t)
							}
						}
						_onMediaSessionStarted(e) {
							e.addListener(Yo.REMOTE_SOURCE_CONSTRAINTS_CHANGED, ((e, t) => {
								e === this._conference.getActiveMediaSession() && t.forEach((e => this._onSenderConstraintsReceived(e)))
							}))
						}
						_onSenderConstraintsReceived(e) {
							var t;
							const {
								maxHeight: n,
								sourceName: i
							} = e, s = null !== (t = this._conference.getLocalVideoTracks()) && void 0 !== t ? t : [];
							for (const e of s) e.getSourceName() === i && this._sourceSenderConstraints.get(i) !== n && (this._sourceSenderConstraints.set(i, -1 === n ? Math.min(2160, this._preferredSendMaxFrameHeight) : n), Kl.debug(`Sender constraints for source:${i} changed to maxHeight:${n}`), this._propagateSendMaxFrameHeight(i))
						}
						_propagateSendMaxFrameHeight(e) {
							if (!e) throw new Error("sourceName missing for calculating the sendMaxHeight for video tracks");
							const t = this._selectSendMaxFrameHeight(e),
								n = [];
							if (t >= 0)
								for (const i of this._conference.getMediaSessions()) n.push(i.setSenderVideoConstraint(t, e));
							return Promise.all(n)
						}
						_selectSendMaxFrameHeight(e) {
							if (!e) throw new Error("sourceName missing for calculating the sendMaxHeight for video tracks");
							const t = this._conference.getActiveMediaSession() ? this._sourceSenderConstraints.get(e) : void 0;
							return this._preferredSendMaxFrameHeight >= 0 && t >= 0 ? Math.min(this._preferredSendMaxFrameHeight, t) : t >= 0 ? t : this._preferredSendMaxFrameHeight
						}
						setPreferredSendMaxFrameHeight(e) {
							this._preferredSendMaxFrameHeight = e;
							const t = [];
							for (const e of this._sourceSenderConstraints.keys()) t.push(this._propagateSendMaxFrameHeight(e));
							return Promise.allSettled(t)
						}
					}
					const Xl = {
						getFocusRecordingUpdate(e) {
							const t = e && e.getElementsByTagName("jibri-recording-status")[0];
							if (t) return {
								error: t.getAttribute("failure_reason"),
								initiator: t.getAttribute("initiator"),
								recordingMode: t.getAttribute("recording_mode"),
								sessionID: t.getAttribute("session_id"),
								status: t.getAttribute("status")
							}
						},
						getHiddenDomainUpdate(e) {
							const t = e.getElementsByTagName("live-stream-view-url")[0],
								n = t && t.textContent,
								i = e.getElementsByTagName("mode")[0],
								s = i && i.textContent && i.textContent.toLowerCase(),
								r = e.getElementsByTagName("session_id")[0];
							return {
								liveStreamViewURL: n,
								mode: s,
								sessionID: r && r.textContent
							}
						},
						getSessionIdFromIq(e) {
							const t = e && e.getElementsByTagName("jibri")[0];
							return t && t.getAttribute("session_id")
						},
						getSessionId(e) {
							const t = e.getElementsByTagName("session_id")[0];
							return t && t.textContent
						},
						isFromFocus: e => e.getAttribute("from").includes("focus")
					};
					class zl {
						constructor() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
							this._connection = e.connection, this._mode = e.mode, this._jibriJid = null, this._statusFromJicofo = "", this._setSessionID(e.sessionID), this.setStatus(e.status)
						}
						getError() {
							return this._error
						}
						getID() {
							return this._sessionID
						}
						getInitiator() {
							return this._initiator
						}
						getLiveStreamViewURL() {
							return this._liveStreamViewURL
						}
						getStatus() {
							return this._status ? this._status : this._statusFromJicofo
						}
						getJibriJid() {
							return this._jibriJid
						}
						getTerminator() {
							return this._terminator
						}
						getMode() {
							return this._mode
						}
						setError(e) {
							this._error = e
						}
						setLiveStreamViewURL(e) {
							this._liveStreamViewURL = e
						}
						setStatus(e) {
							this._status = e
						}
						setStatusFromJicofo(e) {
							this._statusFromJicofo = e
						}
						setJibriJid(e) {
							this._jibriJid = e
						}
						setInitiator(e) {
							this._initiator = e
						}
						setTerminator(e) {
							this._terminator = e
						}
						start(e) {
							let {
								appData: t,
								broadcastId: n,
								focusMucJid: i,
								streamId: s
							} = e;
							return new Promise(((e, r) => {
								this._connection.sendIQ(this._createIQ({
									action: "start",
									appData: t,
									focusMucJid: i,
									broadcastId: n,
									streamId: s
								}), (t => {
									this.setStatus("pending"), this._setSessionID(Xl.getSessionIdFromIq(t)), e()
								}), (e => {
									this._setErrorFromIq(e), r(e)
								}))
							}))
						}
						stop(e) {
							let {
								focusMucJid: t
							} = e;
							return new Promise(((e, n) => {
								this._connection.sendIQ(this._createIQ({
									action: "stop",
									focusMucJid: t
								}), e, n)
							}))
						}
						_createIQ(e) {
							let {
								action: t,
								appData: n,
								broadcastId: i,
								focusMucJid: s,
								streamId: r
							} = e;
							return (0, vt.$iq)({
								to: s,
								type: "set"
							}).c("jibri", {
								xmlns: "http://jitsi.org/protocol/jibri",
								action: t,
								app_data: n,
								recording_mode: this._mode,
								streamid: r,
								you_tube_broadcast_id: i
							}).up()
						}
						_setErrorFromIq(e) {
							const t = e.getElementsByTagName("error")[0];
							this.setError(t.children[0].tagName)
						}
						_setSessionID(e) {
							this._sessionID = e
						}
					}
					const Yl = (0, S.getLogger)("modules/recording/RecordingManager.js"),
						Ql = (0, S.getLogger)("modules/statistics/AudioOutputProblemDetector.js");
					class Zl {
						constructor(e) {
							this._conference = e, this._localAudioLevelCache = {}, this._reportedParticipants = [], this._audioProblemCandidates = {}, this._numberOfRemoteAudioLevelsReceived = {}, this._onLocalAudioLevelsReport = this._onLocalAudioLevelsReport.bind(this), this._onRemoteAudioLevelReceived = this._onRemoteAudioLevelReceived.bind(this), this._clearUserData = this._clearUserData.bind(this), this._conference.on(rl, this._onRemoteAudioLevelReceived), this._conference.statistics.addConnectionStatsListener(this._onLocalAudioLevelsReport), this._conference.on(ze, this._clearUserData)
						}
						_onRemoteAudioLevelReceived(e, t) {
							let {
								avgAudioLevels: n
							} = t;
							const i = this._numberOfRemoteAudioLevelsReceived[e] + 1 || 0;
							if (this._numberOfRemoteAudioLevelsReceived[e] = i, -1 !== this._reportedParticipants.indexOf(e) || e in this._audioProblemCandidates || n <= 0 || i < 3) return;
							const s = this._conference.getParticipantById(e);
							if (s && s.getTracksByMediaType(_i.AUDIO).length > 0 && s.isAudioMuted()) return;
							const r = this._localAudioLevelCache[e];
							Array.isArray(r) && !r.every((e => 0 === e)) || (this._audioProblemCandidates[e] = {
								remoteAudioLevels: n,
								localAudioLevels: []
							})
						}
						_onLocalAudioLevelsReport(e, t) {
							let {
								avgAudioLevels: n
							} = t;
							e === this._conference.getActivePeerConnection() && (Object.keys(n).forEach((e => {
								if (-1 !== this._reportedParticipants.indexOf(e)) return;
								const t = this._localAudioLevelCache[e];
								Array.isArray(t) ? t.length >= 2 && t.shift() : this._localAudioLevelCache[e] = [], this._localAudioLevelCache[e].push(n[e])
							})), Object.keys(this._audioProblemCandidates).forEach((e => {
								const {
									localAudioLevels: t,
									remoteAudioLevels: i
								} = this._audioProblemCandidates[e];
								if (t.push(n[e]), 2 === t.length) {
									if (t.every((e => void 0 === e || 0 === e))) {
										const n = JSON.stringify(t);
										Pi.sendAnalytics(((e, t, n) => ({
											type: Kt.TYPE_OPERATIONAL,
											action: "audio.output.problem",
											attributes: {
												userID: e,
												localAudioLevels: t,
												remoteAudioLevels: n
											}
										}))(e, n, i)), Ql.warn(`A potential problem is detected with the audio output for participant ${e}, local audio levels: ${n}, remote audio levels: ${i}`), this._reportedParticipants.push(e), this._clearUserData(e)
									}
									delete this._audioProblemCandidates[e]
								}
							})))
						}
						_clearUserData(e) {
							delete this._localAudioLevelCache[e]
						}
						dispose() {
							this._conference.off(rl, this._onRemoteAudioLevelReceived), this._conference.off(ze, this._clearUserData), this._conference.statistics.removeConnectionStatsListener(this._onLocalAudioLevelsReport), this._localAudioLevelCache = void 0, this._audioProblemCandidates = void 0, this._reportedParticipants = void 0, this._numberOfRemoteAudioLevelsReceived = void 0, this._conference = void 0
						}
					}
					const eu = (0, S.getLogger)("modules/statistics/AvgRTPStatsReporter.js");
					class tu {
						constructor(e) {
							this.name = e, this.count = 0, this.sum = 0, this.samples = []
						}
						addNext(e) {
							void 0 !== e && ("number" != typeof e ? eu.error(`${this.name} - invalid value for idx: ${this.count}`, e) : isNaN(e) || (this.sum += e, this.samples.push(e), this.count += 1))
						}
						calculate() {
							return this.sum / this.count
						}
						appendReport(e) {
							e[`${this.name}_avg`] = this.calculate(), e[`${this.name}_samples`] = JSON.stringify(this.samples)
						}
						reset() {
							this.samples = [], this.sum = 0, this.count = 0
						}
					}
					class nu {
						constructor(e, t, n) {
							this.isP2P = t, this._n = n, this._sampleIdx = 0, this._avgRTT = new tu("rtt"), this._avgRemoteRTTMap = new Map, this._avgRtpStatsReporter = e, this._avgEnd2EndRTT = void 0, this._onConnectionStats = (e, t) => {
								this.isP2P === e.isP2P && this._calculateAvgStats(t)
							};
							const i = e._conference;
							i.statistics.addConnectionStatsListener(this._onConnectionStats), this.isP2P || (this._onUserLeft = e => this._avgRemoteRTTMap.delete(e), i.on(ze, this._onUserLeft), this._onRemoteStatsUpdated = (e, t) => this._processRemoteStats(e, t), i.on(rl, this._onRemoteStatsUpdated))
						}
						_calculateAvgStats(e) {
							if (e) {
								if (Wn.supportsRTTStatistics() && e.transport && e.transport.length && this._avgRTT.addNext(e.transport[0].rtt), this._sampleIdx += 1, this._sampleIdx >= this._n) {
									if (Wn.supportsRTTStatistics()) {
										const t = this._avgRtpStatsReporter._conference,
											n = {
												p2p: this.isP2P,
												conference_size: t.getParticipantCount()
											};
										if (e.transport && e.transport.length && Object.assign(n, {
												local_candidate_type: e.transport[0].localCandidateType,
												remote_candidate_type: e.transport[0].remoteCandidateType,
												transport_type: e.transport[0].type
											}), this._avgRTT.appendReport(n), this.isP2P) {
											const e = this._avgRtpStatsReporter.jvbStatsMonitor._avgEnd2EndRTT;
											isNaN(e) || (n.rtt_diff = this._avgRTT.calculate() - e)
										} else {
											const e = this._calculateAvgRemoteRTT(),
												t = this._avgRTT.calculate();
											this._avgEnd2EndRTT = t + e, isNaN(t) || isNaN(e) || (n.end2end_rtt_avg = this._avgEnd2EndRTT)
										}
										Pi.sendAnalytics(bn(n))
									}
									this._resetAvgStats()
								}
							} else eu.error("No stats")
						}
						_calculateAvgRemoteRTT() {
							let e = 0,
								t = 0;
							for (const n of this._avgRemoteRTTMap.values()) {
								const i = n.calculate();
								isNaN(i) || (t += i, e += 1, n.reset())
							}
							return t / e
						}
						_processRemoteStats(e, t) {
							const n = "number" == typeof t.jvbRTT;
							let i = this._avgRemoteRTTMap.get(e);
							!i && n && (i = new tu(`${e}_stat_rtt`), this._avgRemoteRTTMap.set(e, i)), n ? i.addNext(t.jvbRTT) : i && this._avgRemoteRTTMap.delete(e)
						}
						_resetAvgStats() {
							this._avgRTT.reset(), this._avgRemoteRTTMap && this._avgRemoteRTTMap.clear(), this._sampleIdx = 0
						}
						dispose() {
							const e = this._avgRtpStatsReporter._conference;
							e.statistics.removeConnectionStatsListener(this._onConnectionStats), this.isP2P || (e.off(rl, this._onRemoteStatsUpdated), e.off(ze, this._onUserLeft))
						}
					}
					class iu {
						constructor(e, t) {
							this._n = t, t > 0 ? (eu.info(`Avg RTP stats will be calculated every ${t} samples`), this._sampleIdx = 0, this._conference = e, this._avgAudioBitrateUp = new tu("bitrate_audio_upload"), this._avgAudioBitrateDown = new tu("bitrate_audio_download"), this._avgVideoBitrateUp = new tu("bitrate_video_upload"), this._avgVideoBitrateDown = new tu("bitrate_video_download"), this._avgBandwidthUp = new tu("bandwidth_upload"), this._avgBandwidthDown = new tu("bandwidth_download"), this._avgPacketLossTotal = new tu("packet_loss_total"), this._avgPacketLossUp = new tu("packet_loss_upload"), this._avgPacketLossDown = new tu("packet_loss_download"), this._avgRemoteFPS = new tu("framerate_remote"), this._avgRemoteScreenFPS = new tu("framerate_screen_remote"), this._avgLocalFPS = new tu("framerate_local"), this._avgLocalScreenFPS = new tu("framerate_screen_local"), this._avgRemoteCameraPixels = new tu("pixels_remote"), this._avgRemoteScreenPixels = new tu("pixels_screen_remote"), this._avgLocalCameraPixels = new tu("pixels_local"), this._avgLocalScreenPixels = new tu("pixels_screen_local"), this._avgCQ = new tu("connection_quality"), this._cachedTransportStats = void 0, this._onLocalStatsUpdated = e => {
								this._calculateAvgStats(e), this._maybeSendTransportAnalyticsEvent(e)
							}, e.on(sl, this._onLocalStatsUpdated), this._onP2PStatusChanged = () => {
								eu.debug("Resetting average stats calculation"), this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats(), this.p2pStatsMonitor._resetAvgStats()
							}, e.on(Ne, this._onP2PStatusChanged), this._onJvb121StatusChanged = (e, t) => {
								!0 === t && (eu.info("Resetting JVB avg RTP stats"), this._resetAvgJvbStats())
							}, e.on(me, this._onJvb121StatusChanged), this.jvbStatsMonitor = new nu(this, !1, t), this.p2pStatsMonitor = new nu(this, !0, t)) : eu.info("Avg RTP stats reports are disabled.")
						}
						_calculateAvgStats(e) {
							if (!e) return void eu.error("No stats");
							const t = this._conference.isP2PActive(),
								n = this._conference.getParticipantCount();
							if (!t && n < 2) return;
							const i = e.bitrate,
								s = e.bandwidth,
								r = e.packetLoss,
								o = e.framerate,
								a = e.resolution;
							if (i)
								if (s)
									if (r)
										if (o)
											if (a) {
												if (this._avgAudioBitrateUp.addNext(i.audio.upload), this._avgAudioBitrateDown.addNext(i.audio.download), this._avgVideoBitrateUp.addNext(i.video.upload), this._avgVideoBitrateDown.addNext(i.video.download), Wn.supportsBandwidthStatistics() && (this._avgBandwidthUp.addNext(s.upload), this._avgBandwidthDown.addNext(s.download)), this._avgPacketLossUp.addNext(r.upload), this._avgPacketLossDown.addNext(r.download), this._avgPacketLossTotal.addNext(r.total), this._avgCQ.addNext(e.connectionQuality), o && (this._avgRemoteFPS.addNext(this._calculateAvgVideoFps(o, !1, Ni.VideoType.CAMERA)), this._avgRemoteScreenFPS.addNext(this._calculateAvgVideoFps(o, !1, Ni.VideoType.DESKTOP)), this._avgLocalFPS.addNext(this._calculateAvgVideoFps(o, !0, Ni.VideoType.CAMERA)), this._avgLocalScreenFPS.addNext(this._calculateAvgVideoFps(o, !0, Ni.VideoType.DESKTOP))), a && (this._avgRemoteCameraPixels.addNext(this._calculateAvgVideoPixels(a, !1, Ni.VideoType.CAMERA)), this._avgRemoteScreenPixels.addNext(this._calculateAvgVideoPixels(a, !1, Ni.VideoType.DESKTOP)), this._avgLocalCameraPixels.addNext(this._calculateAvgVideoPixels(a, !0, Ni.VideoType.CAMERA)), this._avgLocalScreenPixels.addNext(this._calculateAvgVideoPixels(a, !0, Ni.VideoType.DESKTOP))), this._sampleIdx += 1, this._sampleIdx >= this._n) {
													const i = {
														p2p: t,
														conference_size: n
													};
													e.transport && e.transport.length && Object.assign(i, {
														local_candidate_type: e.transport[0].localCandidateType,
														remote_candidate_type: e.transport[0].remoteCandidateType,
														transport_type: e.transport[0].type
													}), this._avgAudioBitrateUp.appendReport(i), this._avgAudioBitrateDown.appendReport(i), this._avgVideoBitrateUp.appendReport(i), this._avgVideoBitrateDown.appendReport(i), Wn.supportsBandwidthStatistics() && (this._avgBandwidthUp.appendReport(i), this._avgBandwidthDown.appendReport(i)), this._avgPacketLossUp.appendReport(i), this._avgPacketLossDown.appendReport(i), this._avgPacketLossTotal.appendReport(i), this._avgRemoteFPS.appendReport(i), isNaN(this._avgRemoteScreenFPS.calculate()) || this._avgRemoteScreenFPS.appendReport(i), this._avgLocalFPS.appendReport(i), isNaN(this._avgLocalScreenFPS.calculate()) || this._avgLocalScreenFPS.appendReport(i), this._avgRemoteCameraPixels.appendReport(i), isNaN(this._avgRemoteScreenPixels.calculate()) || this._avgRemoteScreenPixels.appendReport(i), this._avgLocalCameraPixels.appendReport(i), isNaN(this._avgLocalScreenPixels.calculate()) || this._avgLocalScreenPixels.appendReport(i), this._avgCQ.appendReport(i), Pi.sendAnalytics(bn(i)), this._resetAvgStats()
												}
											} else eu.error("No resolution");
							else eu.error('No "framerate"');
							else eu.error('No "packetloss"');
							else eu.error('No "bandwidth"');
							else eu.error('No "bitrate"')
						}
						_calculateAvgVideoPixels(e, t, n) {
							let i = 0,
								s = 0;
							const r = this._conference.myUserId();
							for (const o of Object.keys(e))
								if (t ? o === r : o !== r) {
									const r = t ? null : this._conference.getParticipantById(o),
										a = e[o];
									if ((t || r) && a) {
										const e = this._calculatePeerAvgVideoPixels(a, r, n);
										isNaN(e) || (i += e, s += 1)
									}
								} return i / s
						}
						_calculatePeerAvgVideoPixels(e, t, n) {
							let i = Object.keys(e).map((e => Number(e))),
								s = null;
							const r = this._conference.getActivePeerConnection();
							t ? (s = t.getTracksByMediaType(_i.VIDEO), s && (i = i.filter((e => s.find((t => !t.isMuted() && t.getSSRC() === e && t.videoType === n)))))) : (s = this._conference.getLocalTracks(_i.VIDEO), i = i.filter((e => s.find((t => !t.isMuted() && r.getLocalSSRC(t) === e && t.videoType === n)))));
							let o = 0,
								a = 0;
							for (const t of i) {
								const n = Number(e[t].height) * Number(e[t].width);
								!isNaN(n) && n > 0 && (o += n, a += 1)
							}
							return o / a
						}
						_calculateAvgVideoFps(e, t, n) {
							let i = 0,
								s = 0;
							const r = this._conference.myUserId();
							for (const o of Object.keys(e))
								if (t ? o === r : o !== r) {
									const r = t ? null : this._conference.getParticipantById(o),
										a = e[o];
									if ((t || r) && a) {
										const e = this._calculatePeerAvgVideoFps(a, r, n);
										isNaN(e) || (i += e, s += 1)
									}
								} return i / s
						}
						_calculatePeerAvgVideoFps(e, t, n) {
							let i = Object.keys(e).map((e => Number(e))),
								s = null;
							const r = this._conference.getActivePeerConnection();
							t ? (s = t.getTracksByMediaType(_i.VIDEO), s && (i = i.filter((e => s.find((t => !t.isMuted() && t.getSSRC() === e && t.videoType === n)))))) : (s = this._conference.getLocalTracks(_i.VIDEO), i = i.filter((e => s.find((t => !t.isMuted() && r.getLocalSSRC(t) === e && t.videoType === n)))));
							let o = 0,
								a = 0;
							for (const t of i) {
								const n = Number(e[t]);
								!isNaN(n) && n > 0 && (o += n, a += 1)
							}
							return o / a
						}
						_maybeSendTransportAnalyticsEvent(e) {
							if (!e || !e.transport || !e.transport.length) return;
							const t = {
								p2p: e.transport[0].p2p,
								local_candidate_type: e.transport[0].localCandidateType,
								remote_candidate_type: e.transport[0].remoteCandidateType,
								transport_type: e.transport[0].type
							};
							var n;
							this._cachedTransportStats && _t()(t, this._cachedTransportStats) || (this._cachedTransportStats = t, Pi.sendAnalytics((n = t, {
								type: Kt.TYPE_OPERATIONAL,
								action: "transport.stats",
								attributes: n
							})))
						}
						_resetAvgJvbStats() {
							this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats()
						}
						_resetAvgStats() {
							this._avgAudioBitrateUp.reset(), this._avgAudioBitrateDown.reset(), this._avgVideoBitrateUp.reset(), this._avgVideoBitrateDown.reset(), this._avgBandwidthUp.reset(), this._avgBandwidthDown.reset(), this._avgPacketLossUp.reset(), this._avgPacketLossDown.reset(), this._avgPacketLossTotal.reset(), this._avgRemoteFPS.reset(), this._avgRemoteScreenFPS.reset(), this._avgLocalFPS.reset(), this._avgLocalScreenFPS.reset(), this._avgRemoteCameraPixels.reset(), this._avgRemoteScreenPixels.reset(), this._avgLocalCameraPixels.reset(), this._avgLocalScreenPixels.reset(), this._avgCQ.reset(), this._sampleIdx = 0
						}
						dispose() {
							this._conference.off(Ne, this._onP2PStatusChanged), this._conference.off(sl, this._onLocalStatsUpdated), this._conference.off(me, this._onJvb121StatusChanged), this.jvbStatsMonitor.dispose(), this.p2pStatsMonitor.dispose()
						}
					}
					var su = n(2444),
						ru = n.n(su);
					class ou {
						constructor(e) {
							this.stats = {
								users: {},
								dominantSpeakerId: null
							};
							const t = e.myUserId();
							this.stats.users[t] = new(ru())(t, null, !0), this.conference = e, e.addEventListener(oe, this._onDominantSpeaker.bind(this)), e.addEventListener(Xe, this._onUserJoin.bind(this)), e.addEventListener(ze, this._onUserLeave.bind(this)), e.addEventListener(re, this._onDisplayNameChange.bind(this)), e.on(de, ((e, t) => {
								let {
									type: n,
									faceLandmarks: i
								} = t;
								"face-landmarks" === n && this._onFaceLandmarkAdd(e.getId(), i)
							})), e.xmpp && e.xmpp.addListener(ki.XMPPEvents.SPEAKER_STATS_RECEIVED, this._updateStats.bind(this))
						}
						_onDominantSpeaker(e, t, n) {
							const i = this.stats.users[this.stats.dominantSpeakerId],
								s = this.stats.users[e];
							i && i.setDominantSpeaker(!1), s && s.setDominantSpeaker(!0, n), this.stats.dominantSpeakerId = e
						}
						_onUserJoin(e, t) {
							t.isHidden() || this.stats.users[e] || (this.stats.users[e] = new(ru())(e, t.getDisplayName()))
						}
						_onUserLeave(e) {
							const t = this.stats.users[e];
							t && t.markAsHasLeft()
						}
						_onDisplayNameChange(e, t) {
							const n = this.stats.users[e];
							n && n.setDisplayName(t)
						}
						_onFaceLandmarkAdd(e, t) {
							const n = this.stats.users[e];
							n && t && n.addFaceLandmarks(t)
						}
						getStats() {
							return this.stats.users
						}
						_updateStats(e) {
							for (const t in e) {
								let n;
								const i = this.conference.getParticipantById(t);
								i && i.isHidden() || (this.stats.users[t] ? (n = this.stats.users[t], n.getDisplayName() || n.setDisplayName(e[t].displayName)) : (n = new(ru())(t, e[t].displayName), this.stats.users[t] = n, n.markAsHasLeft()), n.totalDominantSpeakerTime = e[t].totalDominantSpeakerTime, Array.isArray(e[t].faceLandmarks) && n.setFaceLandmarks(e[t].faceLandmarks))
							}
						}
					}
					class au {
						constructor(e, t, n, i) {
							this.blob = e, this.name = t, this.startTime = n, this.wordArray = i
						}
					}
					class cu {
						constructor(e) {
							this.track = e, this.recorder = null, this.data = null, this.name = null, this.startTime = null
						}
					}
					const du = "audio/webm",
						lu = "audio/ogg";

					function uu(e) {
						if (void 0 === e.recorder) throw new Error("Passed an object to startRecorder which is not a TrackRecorder object");
						e.recorder.start(), e.startTime = new Date
					}

					function hu(e) {
						if (void 0 === e.recorder) throw new Error("Passed an object to stopRecorder which is not a TrackRecorder object");
						e.recorder.stop()
					}

					function pu() {
						if (MediaRecorder.isTypeSupported(du)) return du;
						if (MediaRecorder.isTypeSupported(lu)) return lu;
						throw new Error("unable to create a MediaRecorder with the right mimetype!")
					}

					function mu(e) {
						this.recorders = [], this.fileType = pu(), this.isRecording = !1, this.jitsiConference = e
					}
					mu.determineCorrectFileType = pu, mu.prototype.addTrack = function(e) {
						if (e.isAudioTrack()) {
							const t = this.instantiateTrackRecorder(e);
							this.recorders.push(t), this.updateNames(), this.isRecording && uu(t)
						}
					}, mu.prototype.instantiateTrackRecorder = function(e) {
						const t = new cu(e),
							n = t.track.getOriginalStream(),
							i = new MediaStream;
						return n.getAudioTracks().forEach((e => i.addTrack(e))), t.recorder = new MediaRecorder(i, {
							mimeType: this.fileType
						}), t.data = [], t.recorder.ondataavailable = function(e) {
							e.data.size > 0 && t.data.push(e.data)
						}, t
					}, mu.prototype.removeTrack = function(e) {
						if (e.isVideoTrack()) return;
						const t = this.recorders;
						let n;
						for (n = 0; n < t.length; n++)
							if (t[n].track.getParticipantId() === e.getParticipantId()) {
								const e = t[n];
								this.isRecording ? hu(e) : t.splice(n, 1)
							} this.updateNames()
					}, mu.prototype.updateNames = function() {
						const e = this.jitsiConference;
						this.recorders.forEach((t => {
							if (t.track.isLocal()) t.name = "the transcriber";
							else {
								const n = t.track.getParticipantId(),
									i = e.getParticipantById(n).getDisplayName();
								"undefined" !== i && (t.name = i)
							}
						}))
					}, mu.prototype.start = function() {
						if (this.isRecording) throw new Error("audiorecorder is already recording");
						this.isRecording = !0, this.recorders.forEach((e => uu(e))), console.log(`Started the recording of the audio. There are currently ${this.recorders.length} recorders active.`)
					}, mu.prototype.stop = function() {
						this.isRecording = !1, this.recorders.forEach((e => hu(e))), console.log("stopped recording")
					}, mu.prototype.download = function() {
						this.recorders.forEach((e => {
							const t = new Blob(e.data, {
									type: this.fileType
								}),
								n = URL.createObjectURL(t),
								i = document.createElement("a");
							document.body.appendChild(i), i.style = "display: none", i.href = n, i.download = `test.${this.fileType.split("/")[1]}`, i.click(), window.URL.revokeObjectURL(n)
						}))
					}, mu.prototype.getRecordingResults = function() {
						if (this.isRecording) throw new Error("cannot get blobs because the AudioRecorder is still recording!");
						this.updateNames();
						const e = [];
						return this.recorders.forEach((t => e.push(new au(new Blob(t.data, {
							type: this.fileType
						}), t.name, t.startTime)))), e
					}, mu.prototype.getFileType = function() {
						return this.fileType
					};
					const fu = mu;
					class gu {
						constructor(e, t, n) {
							this.word = e, this.begin = t, this.end = n
						}
						getWord() {
							return this.word
						}
						getBeginTime() {
							return this.begin
						}
						getEndTime() {
							return this.end
						}
					}
					class _u extends class {
						constructor() {
							throw new Error("TranscriptionService is abstract and cannot be created")
						}
						send(e, t) {
							this.sendRequest(e.blob, (n => {
								this.verify(n) ? e.wordArray = this.formatResponse(n) : (console.log("the retrieved response from the server is not valid!"), e.wordArray = []), t(e)
							}))
						}
						sendRequest(e, t) {
							throw new Error("TranscriptionService.sendRequest is abstract")
						}
						formatResponse(e) {
							throw new Error("TranscriptionService.format is abstract")
						}
						verify(e) {
							throw new Error("TranscriptionService.verify is abstract")
						}
					} {
						constructor() {
							super(), this.url = function() {
								const e = "config does not contain an url to a Sphinx4 https server";
								if (void 0 === config.sphinxURL) console.log(e);
								else {
									const t = config.sphinxURL;
									if (void 0 !== t.includes && t.includes("https://")) return t;
									console.log(e)
								}
							}()
						}
						sendRequest(e, t) {
							console.log(`sending an audio file  to ${this.url}`), console.log(`the audio file being sent: ${e}`);
							const n = new XMLHttpRequest;
							n.onreadystatechange = function() {
								if (n.readyState === XMLHttpRequest.DONE && 200 === n.status) t(n.responseText);
								else if (n.readyState === XMLHttpRequest.DONE) throw new Error(`unable to accept response from sphinx server. status: ${n.status}`)
							}, n.open("POST", this.url), n.setRequestHeader("Content-Type", fu.determineCorrectFileType()), n.send(e), console.log(`send ${e}`)
						}
						formatResponse(e) {
							const t = JSON.parse(e).objects;
							t.shift();
							const n = [];
							return t.forEach((e => e.filler || n.push(new gu(e.word, e.start, e.end)))), n
						}
						verify(e) {
							if (console.log(`response from server:${e.toString()}`), "string" != typeof e) return !1;
							let t;
							try {
								t = JSON.parse(e)
							} catch (e) {
								return console.log(e), !1
							}
							if (void 0 === t.objects) return !1;
							const n = t.objects;
							return !(!n[0] || !n[0]["session-id"])
						}
					}
					const vu = "before",
						Su = "recording",
						Eu = "transcribing",
						yu = "finished";

					function Tu() {
						this.audioRecorder = new fu, this.transcriptionService = new _u, this.counter = null, this.startTime = null, this.transcription = null, this.callback = null, this.results = [], this.state = vu, this.lineLength = 0
					}

					function Cu(e, t) {
						if (console.log(`retrieved an answer from the transcription service. The answer has an array of length: ${t.wordArray.length}`), t.wordArray.length > 0) {
							let n = t.startTime.getUTCMilliseconds() - e.startTime.getUTCMilliseconds();
							n < 0 && (n = 0);
							let i = "[";
							t.wordArray.forEach((e => {
								e.begin += n, e.end += n, i += `${e.word},`
							})), i += "]", console.log(i), t.wordArray.name = t.name
						}
						e.results.push(t.wordArray), e.counter--, console.log(`current counter: ${e.counter}`), e.maybeMerge()
					}

					function bu(e) {
						for (let t = 0; t < e.length; t++) 0 === e[t].length && e.splice(t, 1);
						return e.length > 0
					}
					Tu.prototype.start = function() {
						if (this.state !== vu) throw new Error(`The transcription can only start when it's in the "before" state. It's currently in the "${this.state}" state`);
						this.state = Su, this.audioRecorder.start(), this.startTime = new Date
					}, Tu.prototype.stop = function(e) {
						if (this.state !== Su) throw new Error(`The transcription can only stop when it's in the "recording" state. It's currently in the "${this.state}" state`);
						console.log("stopping recording and sending audio files"), this.audioRecorder.stop();
						const t = Cu.bind(null, this);
						this.audioRecorder.getRecordingResults().forEach((e => {
							this.transcriptionService.send(e, t), this.counter++
						})), this.state = Eu, this.callback = e
					}, Tu.prototype.maybeMerge = function() {
						this.state === Eu && 0 === this.counter && this.merge()
					}, Tu.prototype.merge = function() {
						console.log(`starting merge process!\n The length of the array: ${this.results.length}`), this.transcription = "";
						const e = this.results,
							t = [];
						for (bu(e), e.forEach((e => function(e, t) {
								if (0 === e.length) e.push(t);
								else {
									if (e[e.length - 1].begin <= t.begin) return void e.push(t);
									for (let n = 0; n < e.length; n++)
										if (t.begin < e[n].begin) return void e.splice(n, 0, t);
									e.push(t)
								}
							}(t, e))); bu(e);) {
							let t = e[0];
							e.forEach((e => {
								e[0].begin < t[0].begin && (t = e)
							}));
							let n = t.shift();
							for (this.updateTranscription(n, t.name); t.length > 0;) {
								let i = !1;
								const s = t[0].begin;
								if (e.forEach((e => {
										e[0].begin < s && (i = !0)
									})), i) break;
								n = t.shift(), this.updateTranscription(n, null)
							}
						}
						this.state = yu, this.callback && this.callback(this.transcription)
					}, Tu.prototype.updateTranscription = function(e, t) {
						null != t && (this.transcription += `\n${t}:`, this.lineLength = t.length + 1), this.lineLength + e.word.length > 80 && (this.transcription += "\n    ", this.lineLength = 4), this.transcription += ` ${e.word}`, this.lineLength += e.word.length + 1
					}, Tu.prototype.addTrack = function(e) {
						this.audioRecorder.addTrack(e)
					}, Tu.prototype.removeTrack = function(e) {
						this.audioRecorder.removeTrack(e)
					}, Tu.prototype.getTranscription = function() {
						if (this.state !== yu) throw new Error(`The transcription can only be retrieved when it's in the "finished" state. It's currently in the "${this.state}" state`);
						return this.transcription
					}, Tu.prototype.getState = function() {
						return this.state
					}, Tu.prototype.reset = function() {
						this.state = vu, this.counter = null, this.transcription = null, this.startTime = null, this.callback = null, this.results = [], this.lineLength = 0
					};
					const Au = Tu,
						Ru = n(5810).getLogger("modules/version/ComponentsVersions.js");

					function Iu(e) {
						this.versions = {}, this.conference = e, this.conference.addCommandListener("versions", this.processVersions.bind(this))
					}
					let Pu, Du, wu;
					Iu.prototype.processVersions = function(e, t, n) {
							if (!this.conference.isFocus(n)) return void Ru.warn(`Received versions not from the focus user: ${e}`, n);
							const i = [];
							e.children.forEach((e => {
								const t = e.attributes.name,
									n = e.value;
								this.versions[t] !== n && (this.versions[t] = n, Ru.info(`Got ${t} version: ${n}`), i.push({
									id: "component_version",
									component: t,
									version: n
								}))
							})), i.length > 0 && Pi.sendLog(JSON.stringify(i))
						}, Iu.prototype.getComponentVersion = function(e) {
							return this.versions[e]
						},
						function(e) {
							e.STATUS_AVAILABLE = "available", e.STATUS_UNDEFINED = "undefined", e.STATUS_BUSY = "busy"
						}(Pu || (Pu = {})),
						function(e) {
							e.STATE_ON = "on", e.STATE_OFF = "off", e.STATE_PENDING = "pending", e.STATE_RETRYING = "retrying", e.STATE_FAILED = "failed"
						}(Du || (Du = {})),
						function(e) {
							e.ERROR_NO_CONNECTION = "error_no_connection", e.ERROR_SESSION_EXISTS = "error_session_already_exists"
						}(wu || (wu = {}));
					const Ou = Pu.STATUS_AVAILABLE,
						Nu = Pu.STATUS_UNDEFINED,
						Mu = Pu.STATUS_BUSY,
						Lu = Du.STATE_ON,
						ku = Du.STATE_OFF,
						xu = Du.STATE_PENDING,
						Fu = Du.STATE_RETRYING,
						Vu = Du.STATE_FAILED,
						Uu = wu.ERROR_NO_CONNECTION,
						ju = wu.ERROR_SESSION_EXISTS,
						Hu = (0, S.getLogger)("modules/videosipgw/JitsiVideoSIPGWSession.js"),
						Bu = "STATE_CHANGED";
					class $u extends Yi {
						constructor(e, t, n) {
							super(), this.sipAddress = e, this.displayName = t, this.chatRoom = n, this.state = void 0
						}
						stop() {
							this.state !== ku && this.state !== Vu ? this._sendJibriIQ("stop") : Hu.warn("Video SIP GW session already stopped or failed!")
						}
						start() {
							this.state !== Lu && this.state !== ku && this.state !== xu && this.state !== Fu ? this._sendJibriIQ("start") : Hu.warn("Video SIP GW session already started!")
						}
						setState(e, t) {
							if (e === this.state) return;
							const n = this.state;
							this.state = e, this.eventEmitter.emit(Bu, {
								address: this.sipAddress,
								failureReason: t,
								oldState: n,
								newState: this.state,
								displayName: this.displayName
							})
						}
						addStateListener(e) {
							this.addListener(Bu, e)
						}
						removeStateListener(e) {
							this.removeListener(Bu, e)
						}
						_sendJibriIQ(e) {
							const t = {
								xmlns: "http://jitsi.org/protocol/jibri",
								action: e,
								sipaddress: this.sipAddress
							};
							t.displayname = this.displayName;
							const n = (0, vt.$iq)({
								to: this.chatRoom.focusMucJid,
								type: "set"
							}).c("jibri", t).up();
							Hu.debug(`${e} video SIP GW session`, n.nodeTree), this.chatRoom.connection.sendIQ(n, (() => {}), (t => {
								Hu.error(`Failed to ${e} video SIP GW session, error: `, t), this.setState(Vu)
							}))
						}
					}
					const Ju = (0, S.getLogger)("modules/videosipgw/VideoSIPGW.js");
					class Gu {
						constructor(e) {
							this.chatRoom = e, this.eventEmitter = e.eventEmitter, Ju.debug("creating VideoSIPGW"), this.sessions = {}, this.sessionStateChangeListener = this.sessionStateChanged.bind(this), e.addPresenceListener("jibri-sip-call-state", this.handleJibriSIPState.bind(this))
						}
						handleJibriSIPState(e) {
							const t = e.attributes;
							if (!t) return;
							Ju.debug("Handle video sip gw state : ", t);
							const n = t.state;
							if (n !== this.state) switch (n) {
								case Lu:
								case ku:
								case xu:
								case Fu:
								case Vu: {
									const e = t.sipaddress;
									if (!e) return;
									const i = this.sessions[e];
									i ? i.setState(n, t.failure_reason) : Ju.warn("Video SIP GW session not found:", e)
								}
							}
						}
						createVideoSIPGWSession(e, t) {
							if (this.sessions[e]) return Ju.warn("There was already a Video SIP GW session for address", e), new Error(ju);
							const n = new $u(e, t, this.chatRoom);
							return n.addStateListener(this.sessionStateChangeListener), this.sessions[e] = n, n
						}
						sessionStateChanged(e) {
							const t = e.address;
							if (e.newState === ku || e.newState === Vu) {
								const e = this.sessions[t];
								if (!e) return void Ju.error("Missing Video SIP GW session with address:", t);
								e.removeStateListener(this.sessionStateChangeListener), delete this.sessions[t]
							}
							this.eventEmitter.emit(ki.XMPPEvents.VIDEO_SIP_GW_SESSION_STATE_CHANGED, e)
						}
					}
					const qu = (0, S.getLogger)("modules/xmpp/SignalingLayerImpl.js"),
						Ku = "SourceInfo";
					class Wu extends Ed {
						constructor() {
							super(), this.ssrcOwners = new Map, this.chatRoom = null, this._localSourceState = {}, this._remoteSourceState = {}, this._sourceNames = new Map
						}
						_addLocalSourceInfoToPresence() {
							return !!this.chatRoom && this.chatRoom.addOrReplaceInPresence(Ku, {
								value: JSON.stringify(this._localSourceState)
							})
						}
						_bindChatRoomEventHandlers(e) {
							const t = (e, t) => {
								this.eventEmitter.emit(hd, e, _i.AUDIO, t)
							};
							this._audioMuteHandler = (e, n) => {
								this._doesEndpointSendNewSourceInfo(n) || t(n, "true" === e.value)
							}, e.addPresenceListener("audiomuted", this._audioMuteHandler);
							const n = (e, t) => {
								this.eventEmitter.emit(hd, e, _i.VIDEO, t)
							};
							this._videoMuteHandler = (e, t) => {
								this._doesEndpointSendNewSourceInfo(t) || n(t, "true" === e.value)
							}, e.addPresenceListener("videomuted", this._videoMuteHandler);
							const i = (e, t) => {
								this.eventEmitter.emit(pd, e, t)
							};
							this._videoTypeHandler = (e, t) => {
								this._doesEndpointSendNewSourceInfo(t) || i(t, e.value)
							}, e.addPresenceListener("videoType", this._videoTypeHandler), this._sourceInfoHandler = (e, t) => {
								const n = t,
									{
										value: i
									} = e,
									s = JSON.parse(i),
									r = this._doesEndpointSendNewSourceInfo(n),
									o = this._remoteSourceState[n] || (this._remoteSourceState[n] = {});
								for (const e of Object.keys(s)) {
									var a;
									let n = !1;
									const i = vd(e),
										c = Boolean(s[e].muted),
										d = o[e] || (o[e] = {
											sourceName: e
										});
									d.muted !== c && (n = !0, d.muted = c, r && !this._localSourceState[e] && this.eventEmitter.emit(md, e, c));
									const l = i === _i.VIDEO ? null !== (a = s[e].videoType) && void 0 !== a ? a : Ni.VideoType.CAMERA : void 0;
									d.videoType !== l && (d.videoType = l, n = !0, r && !this._localSourceState[e] && this.eventEmitter.emit(gd, e, l)), n && Ns.isSsrcRewritingSupported() && this.eventEmitter.emit(fd, e, t, c, l)
								}
								const c = Object.keys(s);
								for (const e of Object.keys(o)) - 1 === c.indexOf(e) && delete o[e]
							}, e.addPresenceListener("SourceInfo", this._sourceInfoHandler), this._memberLeftHandler = e => {
								const t = vt.Strophe.getResourceFromJid(e);
								delete this._remoteSourceState[t];
								for (const [e, n] of this.ssrcOwners.entries()) n === t && delete this._sourceNames[e]
							}, e.addEventListener(ki.XMPPEvents.MUC_MEMBER_LEFT, this._memberLeftHandler)
						}
						_doesEndpointSendNewSourceInfo(e) {
							var t;
							const n = null === (t = this.chatRoom) || void 0 === t ? void 0 : t.getLastPresence(e);
							return Boolean(n && n.find((e => e.tagName === Ku)))
						}
						_logOwnerChangedMessage(e) {
							Ns.isSsrcRewritingSupported() ? qu.debug(e) : qu.error(e)
						}
						getPeerMediaInfo(e, t, n) {
							var i;
							const s = null === (i = this.chatRoom) || void 0 === i ? void 0 : i.getLastPresence(e);
							if (!s) return void qu.warn(`getPeerMediaInfo - no presence stored for: ${e}`);
							if (!this._doesEndpointSendNewSourceInfo(e)) return (() => {
								if (this.chatRoom) return this.chatRoom.getMediaPresenceInfo(e, t);
								qu.warn("Requested peer media info, before room was set")
							})();
							if (n) return this.getPeerSourceInfo(e, n);
							const r = {
								muted: !0
							};
							if (t === _i.VIDEO) {
								r.videoType = void 0;
								const e = wr(s, "jitsi_participant_codecType");
								e.length > 0 && (r.codecType = e[0].value)
							}
							return r
						}
						getPeerSourceInfo(e, t) {
							var n;
							const i = {
								muted: !0,
								videoType: Ni.VideoType.CAMERA
							};
							return this._remoteSourceState[e] ? null !== (n = this._remoteSourceState[e][t]) && void 0 !== n ? n : i : void 0
						}
						getSSRCOwner(e) {
							return this.ssrcOwners.get(e)
						}
						getTrackSourceName(e) {
							return this._sourceNames.get(e)
						}
						removeSSRCOwners(e) {
							if (null != e && e.length)
								for (const t of e) this.ssrcOwners.delete(t)
						}
						setChatRoom(e) {
							const t = this.chatRoom;
							this.chatRoom = e, t && (t.removePresenceListener("audiomuted", this._audioMuteHandler), t.removePresenceListener("videomuted", this._videoMuteHandler), t.removePresenceListener("videoType", this._videoTypeHandler), this._sourceInfoHandler && t.removePresenceListener(Ku, this._sourceInfoHandler), this._memberLeftHandler && t.removeEventListener(ki.XMPPEvents.MUC_MEMBER_LEFT, this._memberLeftHandler)), e && (this._bindChatRoomEventHandlers(e), this._addLocalSourceInfoToPresence())
						}
						setSSRCOwner(e, t) {
							if ("number" != typeof e) throw new TypeError(`SSRC(${e}) must be a number`);
							const n = this.ssrcOwners.get(e);
							n && n !== t && this._logOwnerChangedMessage(`SSRC owner re-assigned from ${n} to ${t}`), this.ssrcOwners.set(e, t)
						}
						setTrackMuteStatus(e, t) {
							return this._localSourceState[e] || (this._localSourceState[e] = {}), this._localSourceState[e].muted = t, !!this.chatRoom && this._addLocalSourceInfoToPresence()
						}
						setTrackSourceName(e, t) {
							if ("number" != typeof e) throw new TypeError(`SSRC(${e}) must be a number`);
							const n = this._sourceNames.get(e);
							n && n !== t && this._logOwnerChangedMessage(`SSRC(${e}) sourceName re-assigned from ${n} to ${t}`), this._sourceNames.set(e, t)
						}
						setTrackVideoType(e, t) {
							return this._localSourceState[e] || (this._localSourceState[e] = {}), this._localSourceState[e].videoType !== t && (this._localSourceState[e].videoType = t === Ni.VideoType.CAMERA ? void 0 : t, this._addLocalSourceInfoToPresence())
						}
						updateSsrcOwnersOnLeave(e) {
							const t = Array.from(this.ssrcOwners).filter((t => t[1] === e)).map((e => e[0]));
							null != t && t.length && this.removeSSRCOwners(t)
						}
					}
					var Xu = n(7318),
						zu = n.n(Xu);
					const Yu = (0, S.getLogger)("JitsiConference.js");

					function Qu(e) {
						return "string" == typeof e ? Object.values(Hr()).find((t => t === e.toLowerCase())) : null
					}

					function Zu(e) {
						var t;
						if (!e.name || e.name.toLowerCase() !== e.name.toString()) {
							const e = "Invalid conference name (no conference name passed or it contains invalid characters like capital letters)!";
							throw Yu.error(e), new Error(e)
						}
						if (this.connection = e.connection, this.xmpp = null === (t = this.connection) || void 0 === t ? void 0 : t.xmpp, this.xmpp.isRoomCreated(e.name, e.customDomain)) {
							const e = "A conference with the same name has already been created!";
							throw delete this.connection, delete this.xmpp, Yu.error(e), new Error(e)
						}
						this.eventEmitter = new(pt()), this.options = e, this.eventManager = new Fi(this), this.participants = new Map, this._signalingLayer = new Wu, this._init(e), this.componentsVersions = new Iu(this), this.jvbJingleSession = null, this.lastDominantSpeaker = null, this.dtmfManager = null, this.somebodySupportsDTMF = !1, this.authEnabled = !1, this.startAudioMuted = !1, this.startVideoMuted = !1, this.startMutedPolicy = {
							audio: !1,
							video: !1
						}, this.isMutedByFocus = !1, this.mutedByFocusActor = null, this.isVideoMutedByFocus = !1, this.mutedVideoByFocusActor = null, this.wasStopped = !1, this.properties = {}, this.connectionQuality = new hl(this, this.eventEmitter, e), this.avgRtpStatsReporter = new iu(this, e.config.avgRtpStatsN || 15), e.config.disableAudioLevels || (this._audioOutputProblemDetector = new Zl(this)), this.isJvbConnectionInterrupted = !1, this.speakerStatsCollector = new ou(this), this.deferredStartP2PTask = null;
						const n = parseInt(e.config.p2p && e.config.p2p.backToP2PDelay, 10);
						this.backToP2PDelay = isNaN(n) ? 5 : n, Yu.info(`backToP2PDelay: ${this.backToP2PDelay}`), this.isP2PConnectionInterrupted = !1, this.p2p = !1, this.p2pJingleSession = null, this.videoSIPGWHandler = new Gu(this.room), this.recordingManager = new class {
							constructor(e) {
								this._sessions = {}, this._chatRoom = e, this.onPresence = this.onPresence.bind(this), this.onMemberLeft = this.onMemberLeft.bind(this), this._chatRoom.eventEmitter.addListener(ki.XMPPEvents.PRESENCE_RECEIVED, this.onPresence), this._chatRoom.eventEmitter.addListener(ki.XMPPEvents.MUC_MEMBER_LEFT, this.onMemberLeft)
							}
							getSession(e) {
								return this._sessions[e]
							}
							getSessionByJibriJid(e) {
								let t;
								return Object.values(this._sessions).forEach((n => {
									n.getJibriJid() === e && (t = n)
								})), t
							}
							onPresence(e) {
								let {
									fromHiddenDomain: t,
									presence: n
								} = e;
								Xl.isFromFocus(n) ? this._handleFocusPresence(n) : t && this._handleJibriPresence(n)
							}
							onMemberLeft(e) {
								const t = this.getSessionByJibriJid(e);
								if (t) {
									const e = t.getStatus();
									t.setStatus(""), t.setJibriJid(null), t.getStatus() !== e && this._emitSessionUpdate(t)
								}
							}
							startRecording(e) {
								const t = new zl({
									...e,
									connection: this._chatRoom.connection
								});
								return t.start({
									appData: e.appData,
									broadcastId: e.broadcastId,
									focusMucJid: this._chatRoom.focusMucJid,
									streamId: e.streamId
								}).then((() => (this.getSession(t.getID()) || (this._addSession(t), this._emitSessionUpdate(t)), t))).catch((e => (this._emitSessionUpdate(t), Promise.reject(e))))
							}
							stopRecording(e) {
								const t = this.getSession(e);
								return t ? t.stop({
									focusMucJid: this._chatRoom.focusMucJid
								}) : Promise.reject(new Error("Could not find session"))
							}
							_addSession(e) {
								this._sessions[e.getID()] = e
							}
							_createSession(e, t, n) {
								const i = new zl({
									connection: this._chatRoom.connection,
									focusMucJid: this._chatRoom.focusMucJid,
									mode: n,
									sessionID: e,
									status: t
								});
								return this._addSession(i), i
							}
							_emitSessionUpdate(e, t) {
								this._chatRoom.eventEmitter.emit(ki.XMPPEvents.RECORDER_STATE_CHANGED, e, t)
							}
							_handleFocusPresence(e) {
								const t = Xl.getFocusRecordingUpdate(e);
								if (!t) return;
								const {
									error: n,
									initiator: i,
									recordingMode: s,
									sessionID: r,
									status: o
								} = t;
								let a = this.getSession(r);
								a || "off" !== o ? a && a.getStatus() === o && a.getError() === n ? Yl.warn("Ignoring duplicate presence update: ", JSON.stringify(t)) : (a || (a = this._createSession(r, o, s)), a.setStatusFromJicofo(o), n && a.setError(n), this._emitSessionUpdate(a, i)) : Yl.warn("Ignoring recording presence update", "Received a new session with status off.")
							}
							_handleJibriPresence(e) {
								const {
									liveStreamViewURL: t,
									mode: n,
									sessionID: i
								} = Xl.getHiddenDomainUpdate(e);
								if (!i) return void Yl.warn("Ignoring potential jibri presence due to no session id.");
								let s = this.getSession(i);
								s || (s = this._createSession(i, "on", n)), s.setStatus("on"), s.setJibriJid(e.getAttribute("from")), s.setLiveStreamViewURL(t), this._emitSessionUpdate(s)
							}
						}(this.room), this._conferenceJoinAnalyticsEventSent = void 0, this.isE2EESupported() && (Yu.info("End-to-End Encryption is supported"), this._e2eEncryption = new Os(this)), Ns.isRunInLiteModeEnabled() && (Yu.info("Lite mode enabled"), this._liteModeContext = new Bl(this)), this._audioSenderLimitReached = void 0, this._videoSenderLimitReached = void 0
					}

					function eh(e, t, n) {
						this.appID = e, this.token = t, this.options = n, this.xmpp = new Sa(n, t), this.addEventListener(Bi, ((e, t, n, i) => {
							Pi.sendAnalyticsAndLog(((e, t, n) => ({
								type: Kt.TYPE_OPERATIONAL,
								action: "connection.failed",
								attributes: {
									error_type: e,
									error_message: t,
									...n
								}
							}))(e, t, i))
						})), this.addEventListener(ji, (e => {
							e && Pi.sendAnalytics(un, {
								message: e
							}), Pi.sendLog(JSON.stringify({
								id: un,
								msg: e
							}))
						}))
					}
					let th;
					Zu.prototype.constructor = Zu, Zu.resourceCreator = function(e, t) {
						let n;
						if (t) n = Ls().randomHexString(8).toLowerCase();
						else {
							var i;
							n = null === (i = vt.Strophe.getNodeFromJid(e)) || void 0 === i ? void 0 : i.substr(0, 8).toLowerCase();
							const t = /[0-9a-f]{8}/g;
							n && t.test(n) || (n = Ls().randomHexString(8).toLowerCase())
						}
						return n
					}, Zu.prototype._init = function() {
						var e, t, n, i, s, r;
						let o = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
						this.eventManager.setupXMPPListeners();
						const {
							config: a
						} = this.options, c = {
							jvbDisabledCodec: Qu(null === (e = a.videoQuality) || void 0 === e ? void 0 : e.disabledCodec),
							p2pDisabledCodec: Qu(null === (t = a.p2p) || void 0 === t ? void 0 : t.disabledCodec),
							enforcePreferredCodec: null === (n = a.videoQuality) || void 0 === n ? void 0 : n.enforcePreferredCodec,
							jvbPreferredCodec: Qu(null === (i = a.videoQuality) || void 0 === i ? void 0 : i.preferredCodec),
							p2pPreferredCodec: Qu(null === (s = a.p2p) || void 0 === s ? void 0 : s.preferredCodec)
						};
						this.codecSelection = new Ta(this, c), this._statsCurrentId = a.statisticsId ? a.statisticsId : Er.callStatsUserName, this.room = this.xmpp.createRoom(this.options.name, {
							...a,
							statsId: this._statsCurrentId
						}, Zu.resourceCreator), this._signalingLayer.setChatRoom(this.room), this._signalingLayer.on(ud.SOURCE_UPDATED, ((e, t, n, i) => {
							const s = this.participants.get(t),
								r = vd(e);
							s && (s._setSources(r, n, e, i), this.eventEmitter.emit(_e, s))
						})), this._onIceConnectionInterrupted = this._onIceConnectionInterrupted.bind(this), this.room.addListener(ki.XMPPEvents.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), this._onIceConnectionRestored = this._onIceConnectionRestored.bind(this), this.room.addListener(ki.XMPPEvents.CONNECTION_RESTORED, this._onIceConnectionRestored), this._onIceConnectionEstablished = this._onIceConnectionEstablished.bind(this), this.room.addListener(ki.XMPPEvents.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), this._updateProperties = this._updateProperties.bind(this), this.room.addListener(ki.XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), this._sendConferenceJoinAnalyticsEvent = this._sendConferenceJoinAnalyticsEvent.bind(this), this.room.addListener(ki.XMPPEvents.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent), this._removeLocalSourceOnReject = this._removeLocalSourceOnReject.bind(this), this._updateRoomPresence = this._updateRoomPresence.bind(this), this.room.addListener(ki.XMPPEvents.SESSION_ACCEPT, this._updateRoomPresence), this.room.addListener(ki.XMPPEvents.SOURCE_ADD, this._updateRoomPresence), this.room.addListener(ki.XMPPEvents.SOURCE_ADD_ERROR, this._removeLocalSourceOnReject), this.room.addListener(ki.XMPPEvents.SOURCE_REMOVE, this._updateRoomPresence), null !== (r = a.e2eping) && void 0 !== r && r.enabled && (this.e2eping = new Fl(this, a, ((e, t) => {
							try {
								this.sendMessage(e, t, !0)
							} catch (e) {
								Yu.warn("Failed to send E2E ping request or response.", e && e.msg)
							}
						}))), this.rtc || (this.rtc = new il(this, o), this.eventManager.setupRTCListeners(), this._registerRtcListeners(this.rtc)), this.receiveVideoController = new ql(this, this.rtc), this.sendVideoController = new Wl(this, this.rtc);
						let d = !0;
						if (a.testing && a.testing.callStatsThreshold && (d = 100 * Math.random() <= a.testing.callStatsThreshold), this.statistics || (this.statistics = new Pi(this.xmpp, {
								aliasName: this._statsCurrentId,
								userName: a.statisticsDisplayName ? a.statisticsDisplayName : this.myUserId(),
								confID: a.confID || `${this.connection.options.hosts.domain}/${this.options.name}`,
								siteID: a.siteID,
								customScriptUrl: a.callStatsCustomScriptUrl,
								callStatsID: a.callStatsID,
								callStatsSecret: a.callStatsSecret,
								callStatsApplicationLogsDisabled: a.callStatsApplicationLogsDisabled,
								enableCallStats: d,
								roomName: this.options.name,
								applicationName: a.applicationName,
								configParams: a.callStatsConfigParams
							}), Pi.analytics.addPermanentProperties({
								callstats_name: this._statsCurrentId
							}), a.longTasksStatsInterval && this.statistics.attachLongTasksStats(this)), this.eventManager.setupChatRoomListeners(), this.eventManager.setupStatisticsListeners(), a.enableTalkWhileMuted && Wn.supportsVADDetection())
							if (a.createVADProcessor) {
								Yu.info("Using VAD detection for generating talk while muted events"), this._audioAnalyser || (this._audioAnalyser = new Pl(this, a.createVADProcessor));
								const e = new wl;
								e.on(Tl, (() => this.eventEmitter.emit(Be))), this._audioAnalyser.addVADDetectionService(e)
							} else Yu.warn("No VAD Processor was provided. Talk while muted detection service was not initialized!");
						if (a.enableNoisyMicDetection && Wn.supportsVADDetection())
							if (a.createVADProcessor) {
								this._audioAnalyser || (this._audioAnalyser = new Pl(this, a.createVADProcessor));
								const e = new Dl;
								e.on(Sl, (() => this.eventEmitter.emit(Ie))), this._audioAnalyser.addVADDetectionService(e)
							} else Yu.warn("No VAD Processor was provided. Noisy microphone detection service was not initialized!");
						a.enableNoAudioDetection && (this._noAudioSignalDetection = new Cl(this), this._noAudioSignalDetection.on(vl, (() => {
							this.eventEmitter.emit(Re)
						})), this._noAudioSignalDetection.on(_l, (e => {
							this.eventEmitter.emit(J, e)
						}))), "channelLastN" in a && this.setLastN(a.channelLastN), this.jvb121Status = new Ul(this), this.p2pDominantSpeakerDetection = new bl(this), a && a.deploymentInfo && a.deploymentInfo.userRegion && this.setLocalParticipantProperty("region", a.deploymentInfo.userRegion), this.setLocalParticipantProperty("codecType", this.codecSelection.getPreferredCodec()), a && a.transcriptionLanguage && "en-US" !== a.transcriptionLanguage && this.setLocalParticipantProperty("transcription_language", a.transcriptionLanguage)
					}, Zu.prototype.join = function(e) {
						let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						this.room && this.room.join(e, t).then((() => this._maybeSetSITimeout()))
					}, Zu.prototype.authenticateAndUpgradeRole = function(e) {
						return Ea.call(this, {
							...e,
							onCreateResource: Zu.resourceCreator
						})
					}, Zu.prototype.isJoined = function() {
						return this.room && this.room.joined
					}, Zu.prototype.isP2PEnabled = function() {
						return Boolean(this.options.config.p2p && this.options.config.p2p.enabled) || void 0 === this.options.config.p2p
					}, Zu.prototype.isP2PTestModeEnabled = function() {
						return Boolean(this.options.config.testing && this.options.config.testing.p2pTestMode)
					}, Zu.prototype.leave = async function(e) {
							if (this.avgRtpStatsReporter && (this.avgRtpStatsReporter.dispose(), this.avgRtpStatsReporter = null), this._audioOutputProblemDetector && (this._audioOutputProblemDetector.dispose(), this._audioOutputProblemDetector = null), this.e2eping && (this.e2eping.stop(), this.e2eping = null), this.getLocalTracks().forEach((e => this.onLocalTrackRemoved(e))), this.rtc.closeBridgeChannel(), this._sendConferenceLeftAnalyticsEvent(), this.statistics && this.statistics.dispose(), this._delayedIceFailed && this._delayedIceFailed.cancel(), this._maybeClearSITimeout(), this.jvbJingleSession && (this.jvbJingleSession.close(), this.jvbJingleSession = null), this.p2pJingleSession && (this.p2pJingleSession.close(), this.p2pJingleSession = null), !this.room) throw new Error("You have already left the conference");
							const t = this.room;
							let n;
							t.removeListener(ki.XMPPEvents.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), t.removeListener(ki.XMPPEvents.CONNECTION_RESTORED, this._onIceConnectionRestored), t.removeListener(ki.XMPPEvents.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), t.removeListener(ki.XMPPEvents.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), t.removeListener(ki.XMPPEvents.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent), t.removeListener(ki.XMPPEvents.SESSION_ACCEPT, this._updateRoomPresence), t.removeListener(ki.XMPPEvents.SOURCE_ADD, this._updateRoomPresence), t.removeListener(ki.XMPPEvents.SOURCE_ADD_ERROR, this._removeLocalSourceOnReject), t.removeListener(ki.XMPPEvents.SOURCE_REMOVE, this._updateRoomPresence), this.eventManager.removeXMPPListeners(), this._signalingLayer.setChatRoom(null), this.room = null;
							try {
								await t.leave(e)
							} catch (e) {
								n = e, this.getParticipants().forEach((e => this.onMemberLeft(e.getJid())))
							}
							if (this.rtc && this.rtc.destroy(), n) throw n
						}, Zu.prototype.isEndConferenceSupported = function() {
							return Boolean(this.room && this.room.xmpp.endConferenceComponentAddress)
						}, Zu.prototype.end = function() {
							if (this.isEndConferenceSupported()) {
								if (!this.room) throw new Error("You have already left the conference");
								this.room.end()
							} else Yu.warn("Cannot end conference: is not supported.")
						}, Zu.prototype.getActiveMediaSession = function() {
							return this.isP2PActive() ? this.p2pJingleSession : this.jvbJingleSession
						}, Zu.prototype.getMediaSessions = function() {
							const e = [];
							return this.jvbJingleSession && e.push(this.jvbJingleSession), this.p2pJingleSession && e.push(this.p2pJingleSession), e
						}, Zu.prototype._registerRtcListeners = function(e) {
							e.addListener(Oi.default.DATA_CHANNEL_OPEN, (() => {
								for (const e of this.rtc.localTracks) e.isVideoTrack() && this._sendBridgeVideoTypeMessage(e)
							}))
						}, Zu.prototype._sendBridgeVideoTypeMessage = function(e) {
							let t = !e || e.isMuted() ? zu().NONE : e.getVideoType();
							t === zu().DESKTOP && this._desktopSharingFrameRate > 5 && (t = zu().DESKTOP_HIGH_FPS), e && this.rtc.sendSourceVideoType(e.getSourceName(), t)
						}, Zu.prototype.getName = function() {
							return this.options.name.toString()
						}, Zu.prototype.getConnection = function() {
							return this.connection
						}, Zu.prototype.isAuthEnabled = function() {
							return this.authEnabled
						}, Zu.prototype.isLoggedIn = function() {
							return Boolean(this.authIdentity)
						}, Zu.prototype.getAuthLogin = function() {
							return this.authIdentity
						}, Zu.prototype.isExternalAuthEnabled = function() {
							return this.room && this.room.moderator.isExternalAuthEnabled()
						}, Zu.prototype.getExternalAuthUrl = function(e) {
							return new Promise(((t, n) => {
								this.isExternalAuthEnabled() ? e ? this.room.moderator.getPopupLoginUrl(t, n) : this.room.moderator.getLoginUrl(t, n) : n()
							}))
						}, Zu.prototype.getLocalTracks = function(e) {
							let t = [];
							return this.rtc && (t = this.rtc.getLocalTracks(e)), t
						}, Zu.prototype.getLocalAudioTrack = function() {
							return this.rtc ? this.rtc.getLocalAudioTrack() : null
						}, Zu.prototype.getLocalVideoTrack = function() {
							return this.rtc ? this.rtc.getLocalVideoTrack() : null
						}, Zu.prototype.getLocalVideoTracks = function() {
							return this.rtc ? this.rtc.getLocalVideoTracks() : null
						}, Zu.prototype.getPerformanceStats = function() {
							return {
								longTasksStats: this.statistics.getLongTasksStats()
							}
						}, Zu.prototype.on = function(e, t) {
							this.eventEmitter && this.eventEmitter.on(e, t)
						}, Zu.prototype.off = function(e, t) {
							this.eventEmitter && this.eventEmitter.removeListener(e, t)
						}, Zu.prototype.addEventListener = Zu.prototype.on, Zu.prototype.removeEventListener = Zu.prototype.off, Zu.prototype.addCommandListener = function(e, t) {
							this.room && this.room.addPresenceListener(e, t)
						}, Zu.prototype.removeCommandListener = function(e, t) {
							this.room && this.room.removePresenceListener(e, t)
						}, Zu.prototype.sendTextMessage = function(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "body";
							this.room && this.room.sendMessage(e, t)
						}, Zu.prototype.sendPrivateTextMessage = function(e, t) {
							let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "body";
							this.room && this.room.sendPrivateMessage(e, t, n)
						}, Zu.prototype.sendCommand = function(e, t) {
							this.room ? this.room.addOrReplaceInPresence(e, t) && this.room.sendPresence() : Yu.warn("Not sending a command, room not initialized.")
						}, Zu.prototype.sendCommandOnce = function(e, t) {
							this.sendCommand(e, t), this.removeCommand(e)
						}, Zu.prototype.removeCommand = function(e) {
							this.room && this.room.removeFromPresence(e)
						}, Zu.prototype.setDisplayName = function(e) {
							if (this.room) {
								const t = "nick";
								e ? this.room.addOrReplaceInPresence(t, {
									attributes: {
										xmlns: "http://jabber.org/protocol/nick"
									},
									value: e
								}) && this.room.sendPresence() : this.room.getFromPresence(t) && (this.room.removeFromPresence(t), this.room.sendPresence())
							}
						}, Zu.prototype.setSubject = function(e) {
							this.room && this.isModerator() ? this.room.setSubject(e) : Yu.warn(`Failed to set subject, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
						}, Zu.prototype.getTranscriber = function() {
							if (void 0 === this.transcriber) {
								this.transcriber = new Au;
								const e = this.getLocalTracks(_i.AUDIO);
								for (const t of e) this.transcriber.addTrack(t);
								const t = this.rtc.getRemoteTracks(_i.AUDIO);
								for (const e of t) this.transcriber.addTrack(e)
							}
							return this.transcriber
						}, Zu.prototype.getTranscriptionStatus = function() {
							return this.room.transcriptionStatus
						}, Zu.prototype.addTrack = function(e) {
							const t = e.getType(),
								n = this.rtc.getLocalTracks(t);
							if (n.length > 0) {
								if (e === n[0]) return Promise.resolve(e);
								if (Ns.isMultiStreamSendSupportEnabled() && t === _i.VIDEO && !n.find((t => t.getVideoType() === e.getVideoType()))) {
									var i;
									const n = _d(this.myUserId(), t, null === (i = this.getLocalTracks(t)) || void 0 === i ? void 0 : i.length);
									e.setSourceName(n);
									const s = [];
									return this.p2pJingleSession && s.push(this.p2pJingleSession.addTracks([e])), this.jvbJingleSession && s.push(this.jvbJingleSession.addTracks([e])), Promise.all(s).then((() => {
										this._setupNewTrack(e), this._sendBridgeVideoTypeMessage(e), this._updateRoomPresence(this.getActiveMediaSession()), (this.isMutedByFocus || this.isVideoMutedByFocus) && this._fireMuteChangeEvent(e)
									}))
								}
								return Promise.reject(new Error(`Cannot add second ${t} track to the conference`))
							}
							return this.replaceTrack(null, e).then((() => {
								e.getVideoType() === Ni.VideoType.DESKTOP && Ns.isMultiStreamSendSupportEnabled() && this._updateRoomPresence(this.getActiveMediaSession())
							}))
						}, Zu.prototype._fireAudioLevelChangeEvent = function(e, t) {
							const n = this.getActivePeerConnection();
							t && n !== t || this.eventEmitter.emit(Je, this.myUserId(), e)
						}, Zu.prototype._fireMuteChangeEvent = function(e) {
							let t;
							if (this.isMutedByFocus && e.isAudioTrack() && !e.isMuted() ? (this.isMutedByFocus = !1, this.room.muteParticipant(this.room.myroomjid, !1, _i.AUDIO)) : this.isVideoMutedByFocus && e.isVideoTrack() && !e.isMuted() && (this.isVideoMutedByFocus = !1, this.room.muteParticipant(this.room.myroomjid, !1, _i.VIDEO)), this.mutedByFocusActor && e.isAudioTrack()) {
								const e = vt.Strophe.getResourceFromJid(this.mutedByFocusActor);
								t = this.participants.get(e)
							} else if (this.mutedVideoByFocusActor && e.isVideoTrack()) {
								const e = vt.Strophe.getResourceFromJid(this.mutedVideoByFocusActor);
								t = this.participants.get(e)
							}
							const n = Wn.isReactNative() ? e.videoType === Ni.VideoType.DESKTOP : Wn.doesVideoMuteByStreamRemove();
							e.isVideoTrack() && !n && this._sendBridgeVideoTypeMessage(e), this.eventEmitter.emit(Ge, e, t)
						}, Zu.prototype._getInitialLocalTracks = function() {
							return this.getLocalTracks().filter((e => {
								const t = e.getType();
								return !(t !== _i.AUDIO || this.isStartAudioMuted() && !Wn.isWebKitBased() && !Wn.isReactNative()) || t === _i.VIDEO && !this.isStartVideoMuted()
							}))
						}, Zu.prototype.onLocalTrackRemoved = function(e) {
							e.setConference(null), this.rtc.removeLocalTrack(e), e.removeEventListener(Ct, e.muteHandler), e.isAudioTrack() && e.removeEventListener(yt, e.audioLevelHandler), e.isVideoTrack() && e.videoType === Ni.VideoType.DESKTOP && this.statistics.sendScreenSharingEvent(!1), this.eventEmitter.emit(qe, e)
						}, Zu.prototype.removeTrack = function(e) {
							return this.replaceTrack(e, null)
						}, Zu.prototype.replaceTrack = function(e, t) {
							const n = null == e ? void 0 : e.getVideoType(),
								i = (null == e ? void 0 : e.getType()) || (null == t ? void 0 : t.getType()),
								s = null == t ? void 0 : t.getVideoType();
							if (Ns.isMultiStreamSendSupportEnabled() && e && t && n !== s) throw new Error(`Replacing a track of videoType=${n} with a track of videoType=${s} is not supported in this mode.`);
							if (t) {
								var r;
								const n = e ? e.getSourceName() : _d(this.myUserId(), i, null === (r = this.getLocalTracks(i)) || void 0 === r ? void 0 : r.length);
								t.setSourceName(n)
							}
							const o = this === (null == e ? void 0 : e.conference);
							return o && e.disposed || null != t && t.disposed ? Promise.reject(new qt(Ht)) : (e && !o && Yu.warn(`JitsiConference.replaceTrack oldTrack (${e} does not belong to this conference`), this._doReplaceTrack(o ? e : null, t).then((() => (!o || e.isMuted() || t || e._sendMuteStatus(!0), o && this.onLocalTrackRemoved(e), t && this._setupNewTrack(t), (o && null != e && e.isVideoTrack() || null != t && t.isVideoTrack()) && this._sendBridgeVideoTypeMessage(t), this._updateRoomPresence(this.getActiveMediaSession()), null !== t && (this.isMutedByFocus || this.isVideoMutedByFocus) && this._fireMuteChangeEvent(t), Promise.resolve()))).catch((e => (Yu.error(`replaceTrack failed: ${null==e?void 0:e.stack}`), Promise.reject(e)))))
						}, Zu.prototype._doReplaceTrack = function(e, t) {
							const n = [];
							return this.jvbJingleSession ? n.push(this.jvbJingleSession.replaceTrack(e, t)) : Yu.info("_doReplaceTrack - no JVB JingleSession"), this.p2pJingleSession ? n.push(this.p2pJingleSession.replaceTrack(e, t)) : Yu.info("_doReplaceTrack - no P2P JingleSession"), Promise.all(n)
						}, Zu.prototype._removeLocalSourceOnReject = function(e, t, n) {
							if (!e) return;
							Yu.warn(`Source-add rejected on ${e}, reason="${null==t?void 0:t.reason}", message="${null==t?void 0:t.msg}"`);
							const i = this.getLocalTracks(n)[0];
							this.eventEmitter.emit(Ke, i)
						}, Zu.prototype._setupNewTrack = function(e) {
							const t = e.getType();
							if (e.isAudioTrack() || e.isVideoTrack() && e.videoType !== Ni.VideoType.DESKTOP) {
								const t = il.getCurrentlyAvailableMediaDevices().find((t => t.kind === `${e.getTrack().kind}input` && t.label === e.getTrack().label));
								t && Pi.sendActiveDeviceListEvent(il.getEventDataForActiveDevice(t))
							}
							if (!e.getSourceName()) {
								var n;
								const i = _d(this.myUserId(), t, null === (n = this.getLocalTracks(t)) || void 0 === n ? void 0 : n.length);
								e.setSourceName(i)
							}
							this.rtc.addLocalTrack(e), e.setConference(this), e.muteHandler = this._fireMuteChangeEvent.bind(this, e), e.addEventListener(Ct, e.muteHandler), e.isAudioTrack() && (e.audioLevelHandler = this._fireAudioLevelChangeEvent.bind(this), e.addEventListener(yt, e.audioLevelHandler)), this.eventEmitter.emit($e, e)
						}, Zu.prototype._setNewVideoType = function(e) {
							let t = !1;
							return e && (t = this._signalingLayer.setTrackVideoType(e.getSourceName(), e.videoType)), t
						}, Zu.prototype._setTrackMuteStatus = function(e, t, n) {
							let i = !1;
							return t && (i = this._signalingLayer.setTrackMuteStatus(t.getSourceName(), n)), i
						}, Zu.prototype._addLocalTrackToPc = function(e) {
							const t = [];
							return this.jvbJingleSession ? t.push(this.jvbJingleSession.addTrackToPc(e)) : Yu.debug("Add local MediaStream - no JVB Jingle session started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.addTrackToPc(e)) : Yu.debug("Add local MediaStream - no P2P Jingle session started yet"), Promise.allSettled(t)
						}, Zu.prototype._removeLocalTrackFromPc = function(e) {
							const t = [];
							return this.jvbJingleSession ? t.push(this.jvbJingleSession.removeTrackFromPc(e)) : Yu.debug("Remove local MediaStream - no JVB JingleSession started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.removeTrackFromPc(e)) : Yu.debug("Remove local MediaStream - no P2P JingleSession started yet"), Promise.allSettled(t)
						}, Zu.prototype.getRole = function() {
							return this.room.role
						}, Zu.prototype.isHidden = function() {
							return this.connection ? vt.Strophe.getDomainFromJid(this.connection.getJid()) === this.options.config.hiddenDomain : null
						}, Zu.prototype.isModerator = function() {
							return this.room ? this.room.isModerator() : null
						}, Zu.prototype.lock = function(e) {
							return this.isModerator() ? new Promise(((t, n) => {
								this.room.lockRoom(e || "", (() => t()), (e => n(e)), (() => n(V)))
							})) : Promise.reject(new Error("You are not moderator."))
						}, Zu.prototype.unlock = function() {
							return this.lock()
						}, Zu.prototype.getLastN = function() {
							return this.receiveVideoController.getLastN()
						}, Zu.prototype.getForwardedSources = function() {
							return this.rtc.getForwardedSources()
						}, Zu.prototype.setLastN = function(e) {
							if (!Number.isInteger(e) && !Number.parseInt(e, 10)) throw new Error(`Invalid value for lastN: ${e}`);
							const t = Number(e);
							if (t < -1) throw new RangeError("lastN cannot be smaller than -1");
							if (this.receiveVideoController.setLastN(t), this.p2pJingleSession) {
								const e = 0 !== t;
								this.p2pJingleSession.setMediaTransferActive(!0, e).catch((t => {
									Yu.error(`Failed to adjust video transfer status (${e})`, t)
								}))
							}
						}, Zu.prototype.getParticipants = function() {
							return Array.from(this.participants.values())
						}, Zu.prototype.getParticipantCount = function() {
							let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
								t = this.getParticipants();
							return e || (t = t.filter((e => !e.isHidden()))), t.length + 1
						}, Zu.prototype.getParticipantById = function(e) {
							return this.participants.get(e)
						}, Zu.prototype.grantOwner = function(e) {
							const t = this.getParticipantById(e);
							t && this.room.setAffiliation(t.getConnectionJid(), "owner")
						}, Zu.prototype.revokeOwner = function(e) {
							const t = this.getParticipantById(e),
								n = this.myUserId() === e,
								i = this.isMembersOnly() ? "member" : "none";
							n ? this.room.setAffiliation(this.connection.getJid(), i) : t && this.room.setAffiliation(t.getConnectionJid(), i)
						}, Zu.prototype.kickParticipant = function(e, t) {
							const n = this.getParticipantById(e);
							n && this.room.kick(n.getJid(), t)
						}, Zu.prototype._maybeClearSITimeout = function() {
							this._sessionInitiateTimeout && (this.jvbJingleSession || this.getParticipantCount() < 2) && (window.clearTimeout(this._sessionInitiateTimeout), this._sessionInitiateTimeout = null)
						}, Zu.prototype._maybeSetSITimeout = function() {
							!this.jvbJingleSession && this.getParticipantCount() >= 2 && !this._sessionInitiateTimeout && (this._sessionInitiateTimeout = window.setTimeout((() => {
								this._sessionInitiateTimeout = null, Pi.sendAnalytics(yn(tn, {
									p2p: !1,
									value: 5e3
								}))
							}), 5e3))
						}, Zu.prototype.muteParticipant = function(e, t) {
							const n = t || _i.AUDIO;
							if (n !== _i.AUDIO && n !== _i.VIDEO) return void Yu.error(`Unsupported media type: ${n}`);
							const i = this.getParticipantById(e);
							i && this.room.muteParticipant(i.getJid(), !0, n)
						}, Zu.prototype.onMemberJoined = function(e, t, n, i, s, r, o, a, c, d, l) {
							var u, h, p, m;
							const f = vt.Strophe.getResourceFromJid(e);
							if ("focus" === f || this.myUserId() === f) return;
							const g = new Vi(e, this, t, i, s, r, o);
							g.setConnectionJid(c), g.setRole(n), g.setBotType(a), g.setFeatures(d), g.setIsReplacing(l);
							const _ = this.isP2PActive() ? null !== (u = null === (h = this.p2pJingleSession) || void 0 === h ? void 0 : h.peerconnection.getRemoteTracks(f)) && void 0 !== u ? u : [] : null !== (p = null === (m = this.jvbJingleSession) || void 0 === m ? void 0 : m.peerconnection.getRemoteTracks(f)) && void 0 !== p ? p : [];
							for (const e of _) g._tracks.push(e);
							this.participants.set(f, g), this.eventEmitter.emit(Xe, f, g), this._updateFeatures(g), this.isJoined() && this._maybeStartOrStopP2P(), this._maybeSetSITimeout()
						}, Zu.prototype._onMucJoined = function() {
							this._maybeStartOrStopP2P()
						}, Zu.prototype._updateFeatures = function(e) {
							e.getFeatures().then((t => {
								e._supportsDTMF = t.has("urn:xmpp:jingle:dtmf:0"), this.updateDTMFSupport(), t.has(_a) && e.setProperty("features_jigasi", !0), t.has(va) && e.setProperty("features_e2ee", !0)
							})).catch((() => !1))
						}, Zu.prototype._onMemberBotTypeChanged = function(e, t) {
							const n = this.getParticipants().find((t => t.getJid() === e));
							if (n) {
								n.setBotType(t);
								const i = vt.Strophe.getResourceFromJid(e);
								this.eventEmitter.emit(et, i, t)
							}
							n.getBotType() || this._maybeStartOrStopP2P()
						}, Zu.prototype.onMemberLeft = function(e, t) {
							const n = vt.Strophe.getResourceFromJid(e);
							if ("focus" === n || this.myUserId() === n) return;
							if (!Ns.isSsrcRewritingSupported()) {
								const e = this.getMediaSessions();
								let t = [];
								for (const i of e) {
									const e = i.peerconnection.getRemoteTracks(n);
									e && (t = [...t, ...e]), i._signalingLayer.updateSsrcOwnersOnLeave(n), i.removeRemoteStreamsOnLeave(n)
								}
								t.forEach((e => {
									this.eventEmitter.emit(qe, e)
								}))
							}
							const i = this.participants.get(n);
							i && (this.participants.delete(n), this.eventEmitter.emit(ze, n, i, t)), null !== this.room && (this._maybeStartOrStopP2P(!0), this._maybeClearSITimeout())
						}, Zu.prototype.onMemberKicked = function(e, t, n, i, s) {
							if (t === this.myUserId()) return;
							const r = this.participants.get(t);
							if (e) return this.eventEmitter.emit(fe, r, i, s), void this.leave();
							const o = this.participants.get(n);
							o.setIsReplaced(s), this.eventEmitter.emit(ge, r, o, i)
						}, Zu.prototype.onLocalRoleChanged = function(e) {
							this.eventEmitter.emit(Ye, this.myUserId(), e)
						}, Zu.prototype.onUserRoleChanged = function(e, t) {
							const n = vt.Strophe.getResourceFromJid(e),
								i = this.getParticipantById(n);
							i && (i.setRole(t), this.eventEmitter.emit(Ye, n, t))
						}, Zu.prototype.onDisplayNameChanged = function(e, t) {
							const n = vt.Strophe.getResourceFromJid(e),
								i = this.getParticipantById(n);
							i && i._displayName !== t && (i._displayName = t, this.eventEmitter.emit(re, n, t))
						}, Zu.prototype.onRemoteTrackAdded = function(e) {
							if (e.isP2P && !this.isP2PActive()) return void Yu.info("Trying to add remote P2P track, when not in P2P - IGNORED");
							if (!e.isP2P && this.isP2PActive()) return void Yu.info("Trying to add remote JVB track, when in P2P - IGNORED");
							const t = e.getParticipantId(),
								n = this.getParticipantById(t);
							n ? n._tracks.push(e) : Yu.info(`Source signaling received before presence for ${t}`), this.transcriber && this.transcriber.addTrack(e);
							const i = this.eventEmitter;
							e.addEventListener(Ct, (() => i.emit(Ge, e))), e.isAudioTrack() && e.addEventListener(yt, ((e, n) => {
								this.getActivePeerConnection() === n && i.emit(Je, t, e)
							})), i.emit($e, e)
						}, Zu.prototype.onCallAccepted = function(e, t) {
							this.p2pJingleSession === e && (Yu.info("P2P setAnswer"), this.p2pJingleSession.setAnswer(t), this.eventEmitter.emit(Te, this.p2pJingleSession))
						}, Zu.prototype.onTransportInfo = function(e, t) {
							this.p2pJingleSession === e && (Yu.info("P2P addIceCandidates"), this.p2pJingleSession.addIceCandidates(t))
						}, Zu.prototype.onRemoteTrackRemoved = function(e) {
							this.getParticipants().forEach((t => {
								const n = t.getTracks();
								for (let i = 0; i < n.length; i++)
									if (n[i] === e) {
										t._tracks.splice(i, 1), this.eventEmitter.emit(qe, e), this.transcriber && this.transcriber.removeTrack(e);
										break
									}
							}), this)
						}, Zu.prototype._onIncomingCallP2P = function(e, t) {
							var n;
							let i;
							const s = Wn.supportsUnifiedPlan() && (!Wn.isChromiumBased() || null === (n = this.options.config.enableUnifiedOnChrome) || void 0 === n || n),
								r = t.find(">content").attr("name");
							s !== ("0" === r || "1" === r) ? i = {
								reason: "decline",
								reasonDescription: "P2P disabled",
								errorMsg: "P2P across two endpoints in different SDP modes is disabled"
							} : !this.isP2PEnabled() && !this.isP2PTestModeEnabled() || Wn.isFirefox() || Wn.isWebKitBased() ? i = {
								reason: "decline",
								reasonDescription: "P2P disabled",
								errorMsg: "P2P mode disabled in the configuration or browser unsupported"
							} : this.p2pJingleSession ? i = {
								reason: "busy",
								reasonDescription: "P2P already in progress",
								errorMsg: 'Duplicated P2P "session-initiate"'
							} : this._shouldBeInP2PMode() || (i = {
								reason: "decline",
								reasonDescription: "P2P requirements not met",
								errorMsg: 'Received P2P "session-initiate" when should not be in P2P mode'
							}, Pi.sendAnalytics(yn(on))), i ? this._rejectIncomingCall(e, i) : this._acceptP2PIncomingCall(e, t)
						}, Zu.prototype.onIncomingCall = function(e, t, n) {
							if (e.isP2P) this._onIncomingCallP2P(e, t);
							else {
								if (!this.isFocus(e.remoteJid)) {
									const t = "Rejecting session-initiate from non-focus.";
									return void this._rejectIncomingCall(e, {
										reason: "security-error",
										reasonDescription: t,
										errorMsg: t
									})
								}
								this._acceptJvbIncomingCall(e, t, n)
							}
						}, Zu.prototype._acceptJvbIncomingCall = function(e, t, n) {
							this.jvbJingleSession = e, this.room.connectionTimes["session.initiate"] = n, this._sendConferenceJoinAnalyticsEvent(), this.wasStopped && Pi.sendAnalyticsAndLog(yn(Qt, {
								p2p: !1
							}));
							const i = ft()(t).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("region");
							this.eventEmitter.emit(ye, i), this._maybeClearSITimeout(), Pi.sendAnalytics(yn(en, {
								p2p: !1,
								value: n
							}));
							try {
								e.initialize(this.room, this.rtc, this._signalingLayer, {
									...this.options.config,
									enableInsertableStreams: this.isE2EEEnabled() || Ns.isRunInLiteModeEnabled()
								})
							} catch (e) {
								return ei().callErrorHandler(e), void Yu.error(e)
							}
							this._setBridgeChannel(t, e.peerconnection);
							const s = this._getInitialLocalTracks();
							try {
								e.acceptOffer(t, (() => {
									this.isP2PActive() && this.jvbJingleSession && this._suspendMediaTransferForJvbConnection(), this.eventEmitter.emit(Te, e), this.isP2PActive() || this.eventEmitter.emit(Ce, e)
								}), (e => {
									ei().callErrorHandler(e), Yu.error("Failed to accept incoming Jingle session", e)
								}), s), this._desktopSharingFrameRate && e.peerconnection.setDesktopSharingFrameRate(this._desktopSharingFrameRate), Yu.info("Starting CallStats for JVB connection..."), this.statistics.startCallStats(this.jvbJingleSession.peerconnection, "jitsi"), this.statistics.startRemoteStats(this.jvbJingleSession.peerconnection)
							} catch (e) {
								ei().callErrorHandler(e), Yu.error(e)
							}
						}, Zu.prototype._setBridgeChannel = function(e, t) {
							var n, i, s;
							const r = null === (n = this.connection) || void 0 === n || null === (i = n.options) || void 0 === i || null === (s = i.bridgeChannel) || void 0 === s ? void 0 : s.ignoreDomain;
							let o = null;
							if (ft()(e).find(">content>transport>web-socket").toArray().map((e => e.getAttribute("url"))).forEach((e => {
									o || r && r === new URL(e).hostname ? o || Yu.info(`Ignoring colibri-ws url with domain ${r}`) : (o = e, Yu.info(`Using colibri-ws url ${e}`))
								})), !o) {
								const t = ft()(e).find(">content>transport>web-socket").first();
								1 === t.length && (o = t[0].getAttribute("url"), Yu.info(`Falling back to ${o}`))
							}
							o ? this.rtc.initializeBridgeChannel(null, o) : (Yu.info("No colibri-ws found."), this.rtc.initializeBridgeChannel(t, null))
						}, Zu.prototype._rejectIncomingCall = function(e, t) {
							null != t && t.errorMsg && Yu.warn(t.errorMsg), e.terminate(null, (e => {
								Yu.warn("An error occurred while trying to terminate invalid Jingle session", e)
							}), {
								reason: t && t.reason,
								reasonDescription: t && t.reasonDescription,
								sendSessionTerminate: !0
							})
						}, Zu.prototype.onCallEnded = function(e, t, n) {
							if (Yu.info(`Call ended: ${t} - ${n} P2P ?${e.isP2P}`), e === this.jvbJingleSession) this.wasStopped = !0, Pi.sendAnalytics(yn(nn, {
								p2p: !1
							})), this.statistics && (this.statistics.stopRemoteStats(this.jvbJingleSession.peerconnection), Yu.info("Stopping JVB CallStats"), this.statistics.stopCallStats(this.jvbJingleSession.peerconnection)), this.jvbJingleSession = null, this.rtc.onCallEnded();
							else if (e === this.p2pJingleSession) {
								const e = {};
								"decline" === t && "force JVB121" === n ? (Yu.info("In forced JVB 121 mode..."), Pi.analytics.addPermanentProperties({
									forceJvb121: !0
								})) : "connectivity-error" === t && "ICE FAILED" === n ? Pi.analytics.addPermanentProperties({
									p2pFailed: !0
								}) : "success" === t && "restart" === n && (e.requestRestart = !0), this._stopP2PSession(e)
							} else Yu.error("Received onCallEnded for invalid session", e.sid, e.remoteJid, t, n)
						}, Zu.prototype.onSuspendDetected = function(e) {
							e.isP2P || (this.leave(), this.eventEmitter.emit(He))
						}, Zu.prototype.updateDTMFSupport = function() {
							let e = !1;
							const t = this.getParticipants();
							for (let n = 0; n < t.length; n += 1)
								if (t[n].supportsDTMF()) {
									e = !0;
									break
								} e !== this.somebodySupportsDTMF && (this.somebodySupportsDTMF = e, this.eventEmitter.emit(ce, e))
						}, Zu.prototype.isDTMFSupported = function() {
							return this.somebodySupportsDTMF
						}, Zu.prototype.myUserId = function() {
							return this.room && this.room.myroomjid ? vt.Strophe.getResourceFromJid(this.room.myroomjid) : null
						}, Zu.prototype.sendTones = function(e, t, n) {
							const i = this.getActivePeerConnection();
							i ? i.sendTones(e, t, n) : Yu.warn("cannot sendTones: no peer connection")
						}, Zu.prototype.startRecording = function(e) {
							return this.room ? this.recordingManager.startRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
						}, Zu.prototype.stopRecording = function(e) {
							return this.room ? this.recordingManager.stopRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
						}, Zu.prototype.isSIPCallingSupported = function() {
							var e, t, n;
							return null !== (e = null === (t = this.room) || void 0 === t || null === (n = t.moderator) || void 0 === n ? void 0 : n.isSipGatewayEnabled()) && void 0 !== e && e
						}, Zu.prototype.dial = function(e) {
							return this.room ? this.room.dial(e) : new Promise(((e, t) => {
								t(new Error("The conference is not created yet!"))
							}))
						}, Zu.prototype.hangup = function() {
							return this.room ? this.room.hangup() : new Promise(((e, t) => {
								t(new Error("The conference is not created yet!"))
							}))
						}, Zu.prototype.startTranscriber = function() {
							return this.dial("jitsi_meet_transcribe")
						}, Zu.prototype.stopTranscriber = Zu.prototype.hangup, Zu.prototype.getPhoneNumber = function() {
							return this.room ? this.room.getPhoneNumber() : null
						}, Zu.prototype.getPhonePin = function() {
							return this.room ? this.room.getPhonePin() : null
						}, Zu.prototype.getMeetingUniqueId = function() {
							if (this.room) return this.room.getMeetingId()
						}, Zu.prototype.getActivePeerConnection = function() {
							const e = this.isP2PActive() ? this.p2pJingleSession : this.jvbJingleSession;
							return e ? e.peerconnection : null
						}, Zu.prototype.getConnectionState = function() {
							const e = this.getActivePeerConnection();
							return e ? e.getConnectionState() : null
						}, Zu.prototype.setStartMutedPolicy = function(e) {
							this.isModerator() ? (this.startMutedPolicy = e, this.room.addOrReplaceInPresence("startmuted", {
								attributes: {
									audio: e.audio,
									video: e.video,
									xmlns: "http://jitsi.org/jitmeet/start-muted"
								}
							}) && this.room.sendPresence()) : Yu.warn(`Failed to set start muted policy, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
						}, Zu.prototype.getStartMutedPolicy = function() {
							return this.startMutedPolicy
						}, Zu.prototype.isStartAudioMuted = function() {
							return this.startAudioMuted
						}, Zu.prototype.isStartVideoMuted = function() {
							return this.startVideoMuted
						}, Zu.prototype.getConnectionTimes = function() {
							return this.room.connectionTimes
						}, Zu.prototype.setLocalParticipantProperty = function(e, t) {
							this.sendCommand(`jitsi_participant_${e}`, {
								value: t
							})
						}, Zu.prototype.removeLocalParticipantProperty = function(e) {
							this.removeCommand(`jitsi_participant_${e}`), this.room.sendPresence()
						}, Zu.prototype.getLocalParticipantProperty = function(e) {
							const t = this.room.presMap.nodes.find((t => t.tagName === `jitsi_participant_${e}`));
							return t ? t.value : void 0
						}, Zu.prototype.sendFeedback = function(e, t) {
							return this.statistics.sendFeedback(e, t)
						}, Zu.prototype.isCallstatsEnabled = function() {
							return this.statistics.isCallstatsEnabled()
						}, Zu.prototype.getSsrcByTrack = function(e) {
							var t;
							return e.isLocal() ? null === (t = this.getActivePeerConnection()) || void 0 === t ? void 0 : t.getLocalSSRC(e) : e.getSSRC()
						}, Zu.prototype._onTrackAttach = function(e, t) {
							const n = e.isLocal();
							let i = null;
							const s = e.isP2P,
								r = s ? e.getParticipantId() : "jitsi",
								o = s ? this.p2pJingleSession && this.p2pJingleSession.peerconnection : this.jvbJingleSession && this.jvbJingleSession.peerconnection;
							n ? o && (i = o.getLocalSSRC(e)) : i = e.getSSRC(), t.id && i && o && this.statistics.associateStreamWithVideoTag(o, i, n, r, e.getUsageLabel(), t.id)
						}, Zu.prototype.sendApplicationLog = function(e) {
							Pi.sendLog(e)
						}, Zu.prototype.isFocus = function(e) {
							return this.room ? this.room.isFocus(e) : null
						}, Zu.prototype._fireIncompatibleVersionsEvent = function() {
							this.eventEmitter.emit(X, x)
						}, Zu.prototype.sendEndpointMessage = function(e, t) {
							this.rtc.sendChannelMessage(e, t)
						}, Zu.prototype.sendEndpointStatsMessage = function(e) {
							this.rtc.sendEndpointStatsMessage(e)
						}, Zu.prototype.broadcastEndpointMessage = function(e) {
							this.sendEndpointMessage("", e)
						}, Zu.prototype.sendMessage = function(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
								n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
							const i = typeof e;
							if ("object" === i || !n && "string" === i)
								if (n) this.sendEndpointMessage(t, e);
								else {
									let n = e,
										s = "body";
									if ("object" === i) {
										s = "json-message", n.hasOwnProperty(ga) || (n[ga] = "");
										try {
											n = JSON.stringify(n)
										} catch (e) {
											return void Yu.error("Can not send a message, stringify failed: ", e)
										}
									}
									t ? this.sendPrivateTextMessage(t, n, s) : this.sendTextMessage(n, s)
								}
							else Yu.error(`Can not send a message of type ${i}`)
						}, Zu.prototype.isConnectionInterrupted = function() {
							return this.isP2PActive() ? this.isP2PConnectionInterrupted : this.isJvbConnectionInterrupted
						}, Zu.prototype._onConferenceRestarted = function(e) {
							!e.isP2P && this.options.config.enableForcedReload && this.eventEmitter.emit(X, P)
						}, Zu.prototype._onIceConnectionInterrupted = function(e) {
							e.isP2P ? this.isP2PConnectionInterrupted = !0 : this.isJvbConnectionInterrupted = !0, e.isP2P === this.isP2PActive() && this.eventEmitter.emit(te)
						}, Zu.prototype._onIceConnectionFailed = function(e) {
							e.isP2P ? (Pi.analytics.addPermanentProperties({
								p2pFailed: !0
							}), this.p2pJingleSession && Pi.sendAnalyticsAndLog(Tn(cn, {
								initiator: this.p2pJingleSession.isInitiator
							})), this._stopP2PSession({
								reason: "connectivity-error",
								reasonDescription: "ICE FAILED"
							})) : e && this.jvbJingleSession === e && (this._delayedIceFailed = new ml(this), this._delayedIceFailed.start(e))
						}, Zu.prototype._onIceConnectionRestored = function(e) {
							e.isP2P ? this.isP2PConnectionInterrupted = !1 : (this.isJvbConnectionInterrupted = !1, this._delayedIceFailed && this._delayedIceFailed.cancel()), e.isP2P === this.isP2PActive() && this.eventEmitter.emit(ne)
						}, Zu.prototype._acceptP2PIncomingCall = function(e, t) {
							this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = e, this._sendConferenceJoinAnalyticsEvent(), this.p2pJingleSession.initialize(this.room, this.rtc, this._signalingLayer, {
								...this.options.config,
								enableInsertableStreams: this.isE2EEEnabled() || Ns.isRunInLiteModeEnabled()
							}), Yu.info("Starting CallStats for P2P connection...");
							let n = vt.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);
							const i = this.participants.get(n);
							i && (n = i.getStatsID() || n), this.statistics.startCallStats(this.p2pJingleSession.peerconnection, n);
							const s = this.getLocalTracks();
							this.p2pJingleSession.acceptOffer(t, (() => {
								Yu.debug('Got RESULT for P2P "session-accept"'), this.eventEmitter.emit(Te, e)
							}), (e => {
								Yu.error("Failed to accept incoming P2P Jingle session", e)
							}), s)
						}, Zu.prototype._addRemoteJVBTracks = function() {
							this._addRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
						}, Zu.prototype._addRemoteP2PTracks = function() {
							this._addRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
						}, Zu.prototype._addRemoteTracks = function(e, t) {
							for (const n of t) Yu.info(`Adding remote ${e} track: ${n}`), this.onRemoteTrackAdded(n)
						}, Zu.prototype._onIceConnectionEstablished = function(e) {
							null !== this.p2pJingleSession && (this.p2pEstablishmentDuration = this.p2pJingleSession.establishmentDuration), null !== this.jvbJingleSession && (this.jvbEstablishmentDuration = this.jvbJingleSession.establishmentDuration);
							let t = !1;
							const n = this.options.config.forceJVB121Ratio;
							if (e.isP2P ? this.p2pJingleSession !== e ? (Yu.error("CONNECTION_ESTABLISHED - wrong P2P session instance ?!"), t = !0) : !e.isInitiator && "number" == typeof n && Math.random() < n && (Yu.info(`Forcing JVB 121 mode (ratio=${n})...`), Pi.analytics.addPermanentProperties({
									forceJvb121: !0
								}), this._stopP2PSession({
									reason: "decline",
									reasonDescription: "force JVB121"
								}), t = !0) : t = !0, !isNaN(this.p2pEstablishmentDuration) && !isNaN(this.jvbEstablishmentDuration)) {
								const e = this.p2pEstablishmentDuration - this.jvbEstablishmentDuration;
								Pi.sendAnalytics(mn, {
									value: e
								})
							}
							e.isP2P === this.isP2PActive() && this.eventEmitter.emit(ee), t || (this._setP2PStatus(!0), this.jvbJingleSession ? this._removeRemoteJVBTracks() : Yu.info("Not removing remote JVB tracks - no session yet"), this._addRemoteP2PTracks(), this.jvbJingleSession && this._suspendMediaTransferForJvbConnection(), Yu.info("Starting remote stats with p2p connection"), this.statistics.startRemoteStats(this.p2pJingleSession.peerconnection), Pi.sendAnalyticsAndLog(Tn(an, {
								initiator: this.p2pJingleSession.isInitiator
							})))
						}, Zu.prototype._updateProperties = function() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
							const t = !_t()(e, this.properties);
							if (this.properties = e, t) {
								this.eventEmitter.emit(Le, this.properties);
								const t = "true" === this.properties["audio-limit-reached"],
									n = "true" === this.properties["video-limit-reached"];
								this._audioSenderLimitReached !== t && (this._audioSenderLimitReached = t, this.eventEmitter.emit(G, t), Yu.info(`Audio unmute permissions set by Jicofo to ${t}`)), this._videoSenderLimitReached !== n && (this._videoSenderLimitReached = n, this.eventEmitter.emit(Ze, n), Yu.info(`Video unmute permissions set by Jicofo to ${n}`)), ["bridge-count"].forEach((t => {
									void 0 !== e[t] && Pi.analytics.addPermanentProperties({
										[t.replace("-", "_")]: e[t]
									})
								}))
							}
						}, Zu.prototype.getProperty = function(e) {
							return this.properties[e]
						}, Zu.prototype._maybeClearDeferredStartP2P = function() {
							this.deferredStartP2PTask && (Yu.info("Cleared deferred start P2P task"), clearTimeout(this.deferredStartP2PTask), this.deferredStartP2PTask = null)
						}, Zu.prototype._removeRemoteJVBTracks = function() {
							this._removeRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
						}, Zu.prototype._removeRemoteP2PTracks = function() {
							this._removeRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
						}, Zu.prototype._removeRemoteTracks = function(e, t) {
							for (const n of t) Yu.info(`Removing remote ${e} track: ${n}`), this.onRemoteTrackRemoved(n)
						}, Zu.prototype._resumeMediaTransferForJvbConnection = function() {
							Yu.info("Resuming media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!0, !0).then((() => {
								Yu.info("Resumed media transfer over the JVB connection!")
							}), (e => {
								Yu.error("Failed to resume media transfer over the JVB connection:", e)
							}))
						}, Zu.prototype._setP2PStatus = function(e) {
							if (this.p2p !== e) {
								if (this.p2p = e, e) {
									Yu.info("Peer to peer connection established!"), Pi.analytics.addPermanentProperties({
										p2pFailed: !1,
										forceJvb121: !1
									});
									const e = 0 !== this.getLastN();
									this.p2pJingleSession.setMediaTransferActive(!0, e).catch((t => {
										Yu.error(`Failed to sync up P2P video transfer status(${e})`, t)
									}))
								} else Yu.info("Peer to peer connection closed!");
								this.jvbJingleSession && this.statistics.sendConnectionResumeOrHoldEvent(this.jvbJingleSession.peerconnection, !e), this.dtmfManager = null, this.eventEmitter.emit(Ne, this, this.p2p), this.eventEmitter.emit(Ce, this.getActiveMediaSession()), this.eventEmitter.emit(this.isConnectionInterrupted() ? te : ne)
							} else Yu.debug(`Called _setP2PStatus with the same status: ${e}`)
						}, Zu.prototype._startP2PSession = function(e) {
							if (this._maybeClearDeferredStartP2P(), this.p2pJingleSession) return void Yu.error("P2P session already started!");
							this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = this.xmpp.connection.jingle.newP2PJingleSession(this.room.myroomjid, e), Yu.info("Created new P2P JingleSession", this.room.myroomjid, e), this._sendConferenceJoinAnalyticsEvent(), this.p2pJingleSession.initialize(this.room, this.rtc, this._signalingLayer, {
								...this.options.config,
								enableInsertableStreams: this.isE2EEEnabled() || Ns.isRunInLiteModeEnabled()
							}), Yu.info("Starting CallStats for P2P connection...");
							let t = vt.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);
							const n = this.participants.get(t);
							n && (t = n.getStatsID() || t), this.statistics.startCallStats(this.p2pJingleSession.peerconnection, t);
							const i = this.getLocalTracks();
							this.p2pJingleSession.invite(i)
						}, Zu.prototype._suspendMediaTransferForJvbConnection = function() {
							Yu.info("Suspending media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!1, !1).then((() => {
								Yu.info("Suspended media transfer over the JVB connection !")
							}), (e => {
								Yu.error("Failed to suspend media transfer over the JVB connection:", e)
							}))
						}, Zu.prototype._maybeStartOrStopP2P = function(e) {
							if (!this.isP2PEnabled() || this.isP2PTestModeEnabled() || Wn.isFirefox() || Wn.isWebKitBased() || this.isE2EEEnabled()) return void Yu.info("Auto P2P disabled");
							const t = this.getParticipants(),
								n = t.length,
								i = this._shouldBeInP2PMode();
							if (!i && this.deferredStartP2PTask && this._maybeClearDeferredStartP2P(), !this.p2pJingleSession && i) {
								const i = n && t[0],
									s = this.myUserId(),
									r = i.getId();
								if (s > r) return void Yu.debug("I'm the bigger peersId - the other peer should start P2P", s, r);
								if (s === r) return void Yu.error("The same IDs ? ", s, r);
								const o = i.getJid();
								if (e) {
									if (this.deferredStartP2PTask) return void Yu.error("Deferred start P2P task's been set already!");
									Yu.info(`Will start P2P with: ${o} after ${this.backToP2PDelay} seconds...`), this.deferredStartP2PTask = setTimeout(this._startP2PSession.bind(this, o), 1e3 * this.backToP2PDelay)
								} else Yu.info(`Will start P2P with: ${o}`), this._startP2PSession(o)
							} else this.p2pJingleSession && !i && (Yu.info(`Will stop P2P with: ${this.p2pJingleSession.remoteJid}`), this.p2pJingleSession.isInitiator && n > 1 && Pi.sendAnalyticsAndLog(Tn(dn)), this._stopP2PSession())
						}, Zu.prototype._shouldBeInP2PMode = function() {
							const e = this.getParticipants(),
								t = e.length,
								n = void 0 !== e.find((e => "poltergeist" === e.getBotType() || e.hasFeature(_a))),
								i = 1 === t && !n;
							return Yu.debug(`P2P? peerCount: ${t}, hasBotPeer: ${n} => ${i}`), i
						}, Zu.prototype._stopP2PSession = function() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
							const {
								reason: t = "success",
								reasonDescription: n = "Turning off P2P session",
								requestRestart: i = !1
							} = e;
							if (!this.p2pJingleSession) return void Yu.error("No P2P session to be stopped!");
							const s = this.isP2PActive();
							s && (this.jvbJingleSession && !i && this._resumeMediaTransferForJvbConnection(), this._removeRemoteP2PTracks()), Yu.info("Stopping remote stats for P2P connection"), this.statistics.stopRemoteStats(this.p2pJingleSession.peerconnection), Yu.info("Stopping CallStats for P2P connection"), this.statistics.stopCallStats(this.p2pJingleSession.peerconnection), this.p2pJingleSession.terminate((() => {
								Yu.info("P2P session terminate RESULT")
							}), (e => {
								"success" !== t && Yu.error("An error occurred while trying to terminate P2P Jingle session", e)
							}), {
								reason: t,
								reasonDescription: n,
								sendSessionTerminate: this.room && this.getParticipantById(vt.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid))
							}), this.p2pJingleSession = null, this._setP2PStatus(!1), s && (this.jvbJingleSession && !i ? this._addRemoteJVBTracks() : Yu.info("Not adding remote JVB tracks - no session yet"))
						}, Zu.prototype._updateRoomPresence = function(e, t) {
							if (!e) return;
							if (t) {
								if (t.skip) return;
								t.skip = !0
							}
							let n, i, s = !1;
							const r = e.peerconnection.getLocalTracks();
							for (const e of r) n = this._setTrackMuteStatus(e.getType(), e, e.isMuted()), e.getType() === _i.VIDEO && (i = this._setNewVideoType(e)), s = s || n || i;
							s && this.room.sendPresence()
						}, Zu.prototype.isP2PActive = function() {
							return this.p2p
						}, Zu.prototype.getP2PConnectionState = function() {
							return this.isP2PActive() ? this.p2pJingleSession.peerconnection.getConnectionState() : null
						}, Zu.prototype.setDesktopSharingFrameRate = function(e) {
							return "number" != typeof e || isNaN(e) ? (Yu.error(`Invalid value ${e} specified for desktop capture frame rate`), !1) : (this._desktopSharingFrameRate = e, this.jvbJingleSession && this.jvbJingleSession.peerconnection.setDesktopSharingFrameRate(e), this.rtc.setDesktopSharingFrameRate(e), !0)
						}, Zu.prototype.startP2PSession = function() {
							const e = this.getParticipants();
							if (1 !== e.length) throw new Error("There must be exactly 1 participant to start the P2P session !"); {
								const t = e[0].getJid();
								this._startP2PSession(t)
							}
						}, Zu.prototype.stopP2PSession = function(e) {
							this._stopP2PSession(e)
						}, Zu.prototype.getSpeakerStats = function() {
							return this.speakerStatsCollector.getStats()
						}, Zu.prototype.sendFaceLandmarks = function(e) {
							e.faceExpression && this.xmpp.sendFaceLandmarksEvent(this.room.roomjid, e)
						}, Zu.prototype.setReceiverConstraints = function(e) {
							this.receiveVideoController.setReceiverConstraints(e)
						}, Zu.prototype.setReceiverVideoConstraint = function(e) {
							this.receiveVideoController.setPreferredReceiveMaxFrameHeight(e)
						}, Zu.prototype.setSenderVideoConstraint = function(e) {
							return this.sendVideoController.setPreferredSendMaxFrameHeight(e)
						}, Zu.prototype.createVideoSIPGWSession = function(e, t) {
							return this.room ? this.videoSIPGWHandler.createVideoSIPGWSession(e, t) : new Error(Uu)
						}, Zu.prototype._sendConferenceJoinAnalyticsEvent = function() {
							const e = this.getMeetingUniqueId();
							!this._conferenceJoinAnalyticsEventSent && e && null !== this.getActivePeerConnection() && (Pi.sendAnalytics(vn("joined", {
								meetingId: e,
								participantId: `${e}.${this._statsCurrentId}`
							})), this._conferenceJoinAnalyticsEventSent = Date.now())
						}, Zu.prototype._sendConferenceLeftAnalyticsEvent = function() {
							const e = this.getMeetingUniqueId();
							e && this._conferenceJoinAnalyticsEventSent && Pi.sendAnalytics(vn("left", {
								meetingId: e,
								participantId: `${e}.${this._statsCurrentId}`,
								stats: {
									duration: Math.floor((Date.now() - this._conferenceJoinAnalyticsEventSent) / 1e3),
									perf: this.getPerformanceStats()
								}
							}))
						}, Zu.prototype._restartMediaSessions = function() {
							this.p2pJingleSession && this._stopP2PSession({
								reasonDescription: "restart",
								requestRestart: !0
							}), this.jvbJingleSession && this.jvbJingleSession.terminate(null, (e => {
								Yu.warn("An error occurred while trying to terminate the JVB session", e)
							}), {
								reason: "success",
								reasonDescription: "restart required",
								requestRestart: !0,
								sendSessionTerminate: !0
							}), this._maybeStartOrStopP2P(!1)
						}, Zu.prototype.isE2EEEnabled = function() {
							return Boolean(this._e2eEncryption && this._e2eEncryption.isEnabled())
						}, Zu.prototype.isE2EESupported = function() {
							return Os.isSupported(this.options.config)
						}, Zu.prototype.toggleE2EE = function(e) {
							this.isE2EESupported() ? this._e2eEncryption.setEnabled(e) : Yu.warn("Cannot enable / disable E2EE: platform is not supported.")
						}, Zu.prototype.setMediaEncryptionKey = function(e) {
							this._e2eEncryption.setEncryptionKey(e)
						}, Zu.prototype.startVerification = function(e) {
							const t = this.getParticipantById(e);
							t && this._e2eEncryption.startVerification(t)
						}, Zu.prototype.markParticipantVerified = function(e, t) {
							const n = this.getParticipantById(e);
							n && this._e2eEncryption.markParticipantVerified(n, t)
						}, Zu.prototype.isLobbySupported = function() {
							return Boolean(this.room && this.room.getLobby().isSupported())
						}, Zu.prototype.isMembersOnly = function() {
							return Boolean(this.room && this.room.membersOnlyEnabled)
						}, Zu.prototype.enableLobby = function() {
							return this.room && this.isModerator() ? this.room.getLobby().enable() : Promise.reject(new Error("The conference not started or user is not moderator"))
						}, Zu.prototype.disableLobby = function() {
							this.room && this.isModerator() ? this.room.getLobby().disable() : Yu.warn(`Failed to disable lobby, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
						}, Zu.prototype.joinLobby = function(e, t) {
							return this.room ? this.room.getLobby().join(e, t) : Promise.reject(new Error("The conference not started"))
						}, Zu.prototype.myLobbyUserId = function() {
							if (this.room) return this.room.getLobby().getLocalId()
						}, Zu.prototype.sendLobbyMessage = function(e, t) {
							if (this.room) return t ? this.room.getLobby().sendPrivateMessage(t, e) : this.room.getLobby().sendMessage(e)
						}, Zu.prototype.addLobbyMessageListener = function(e) {
							if (this.room) return this.room.getLobby().addMessageListener(e)
						}, Zu.prototype.removeLobbyMessageHandler = function(e) {
							if (this.room) return this.room.getLobby().removeMessageHandler(e)
						}, Zu.prototype.lobbyDenyAccess = function(e) {
							this.room && this.room.getLobby().denyAccess(e)
						}, Zu.prototype.lobbyApproveAccess = function(e) {
							this.room && this.room.getLobby().approveAccess(e)
						}, Zu.prototype.isAVModerationSupported = function() {
							return Boolean(this.room && this.room.getAVModeration().isSupported())
						}, Zu.prototype.enableAVModeration = function(e) {
							this.room && this.isModerator() && (e === _i.AUDIO || e === _i.VIDEO) ? this.room.getAVModeration().enable(!0, e) : Yu.warn(`Failed to enable AV moderation, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
						}, Zu.prototype.disableAVModeration = function(e) {
							this.room && this.isModerator() && (e === _i.AUDIO || e === _i.VIDEO) ? this.room.getAVModeration().enable(!1, e) : Yu.warn(`Failed to disable AV moderation, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
						}, Zu.prototype.avModerationApprove = function(e, t) {
							if (this.room && this.isModerator() && (e === _i.AUDIO || e === _i.VIDEO)) {
								const n = this.getParticipantById(t);
								if (!n) return;
								this.room.getAVModeration().approve(e, n.getJid())
							} else Yu.warn(`AV moderation approve skipped , ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
						}, Zu.prototype.avModerationReject = function(e, t) {
							if (this.room && this.isModerator() && (e === _i.AUDIO || e === _i.VIDEO)) {
								const n = this.getParticipantById(t);
								if (!n) return;
								this.room.getAVModeration().reject(e, n.getJid())
							} else Yu.warn(`AV moderation reject skipped , ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
						}, Zu.prototype.getBreakoutRooms = function() {
							var e;
							return null === (e = this.room) || void 0 === e ? void 0 : e.getBreakoutRooms()
						}, Zu.prototype.getMetadataHandler = function() {
							var e;
							return null === (e = this.room) || void 0 === e ? void 0 : e.getMetadataHandler()
						}, eh.prototype.connect = function() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
							this.xmpp.connect(e.id, e.password)
						}, eh.prototype.attach = function(e) {
							this.xmpp.attach(e)
						}, eh.prototype.disconnect = function() {
							return this.xmpp.disconnect(...arguments)
						}, eh.prototype.getJid = function() {
							return this.xmpp.getJid()
						}, eh.prototype.setToken = function(e) {
							this.token = e
						}, eh.prototype.initJitsiConference = function(e, t) {
							return new Zu({
								name: e,
								config: t,
								connection: this
							})
						}, eh.prototype.addEventListener = function(e, t) {
							this.xmpp.addListener(e, t)
						}, eh.prototype.removeEventListener = function(e, t) {
							this.xmpp.removeListener(e, t)
						}, eh.prototype.getConnectionTimes = function() {
							return this.xmpp.connectionTimes
						}, eh.prototype.addFeature = function(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
							this.xmpp.caps.addFeature(e, t, !0)
						}, eh.prototype.removeFeature = function(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
							this.xmpp.caps.removeFeature(e, t, !0)
						}, eh.prototype.getLogs = function() {
							const e = this.xmpp.getJingleLog(),
								t = {};
							t.time = new Date, t.url = window.location.href, t.ua = navigator.userAgent;
							const n = this.xmpp.getXmppLog();
							return n && (t.xmpp = n), e.metadata = t, e
						},
						function(e) {
							e.DEVICE_LIST_CHANGED = "mediaDevices.devicechange", e.PERMISSIONS_CHANGED = "rtc.permissions_changed", e.PERMISSION_PROMPT_IS_SHOWN = "mediaDevices.permissionPromptIsShown", e.SLOW_GET_USER_MEDIA = "mediaDevices.slowGetUserMedia"
						}(th || (th = {}));
					const nh = th.DEVICE_LIST_CHANGED,
						ih = th.PERMISSIONS_CHANGED,
						sh = th.PERMISSION_PROMPT_IS_SHOWN,
						rh = th.SLOW_GET_USER_MEDIA,
						oh = "microphone",
						ah = "camera",
						ch = new class {
							constructor() {
								this._eventEmitter = new(pt()), this._permissions = {}, il.addListener(Oi.default.DEVICE_LIST_CHANGED, (e => this._eventEmitter.emit(nh, e))), il.addListener(Oi.default.DEVICE_LIST_AVAILABLE, (e => this._logOutputDevice(this.getAudioOutputDevice(), e))), il.addListener(Oi.default.PERMISSIONS_CHANGED, (e => this._handlePermissionsChange(e))), this._permissionsApiSupported = new Promise((e => {
									if (!navigator.permissions) return void e(!1);
									const t = this,
										n = [];
									n.push(navigator.permissions.query({
										name: ah
									}).then((e => (this._handlePermissionsChange({
										[_i.VIDEO]: this._parsePermissionState(e)
									}), e.onchange = function() {
										try {
											t._handlePermissionsChange({
												[_i.VIDEO]: t._parsePermissionState(this)
											})
										} catch (e) {}
									}, !0))).catch((() => !1))), n.push(navigator.permissions.query({
										name: oh
									}).then((e => (this._handlePermissionsChange({
										[_i.AUDIO]: this._parsePermissionState(e)
									}), e.onchange = function() {
										try {
											t._handlePermissionsChange({
												[_i.AUDIO]: t._parsePermissionState(this)
											})
										} catch (e) {}
									}, !0))).catch((() => !1))), Promise.all(n).then((t => e(t.every((e => e)))))
								}))
							}
							_parsePermissionState() {
								let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
								const t = e.state || e.status;
								if ("string" != typeof t) throw new TypeError;
								return "granted" === t
							}
							_handlePermissionsChange(e) {
								[_i.AUDIO, _i.VIDEO].some((t => t in e && e[t] !== this._permissions[t])) && (this._permissions = {
									...this._permissions,
									...e
								}, this._eventEmitter.emit(ih, this._permissions), (this._permissions[_i.AUDIO] || this._permissions[_i.VIDEO]) && this.enumerateDevices((() => {})))
							}
							_logOutputDevice(e, t) {
								const n = t.find((t => "audiooutput" === t.kind && t.deviceId === e));
								n && Pi.sendActiveDeviceListEvent(il.getEventDataForActiveDevice(n))
							}
							enumerateDevices(e) {
								il.enumerateDevices(e)
							}
							isDeviceListAvailable() {
								return il.isDeviceListAvailable()
							}
							isDeviceChangeAvailable(e) {
								return il.isDeviceChangeAvailable(e)
							}
							isDevicePermissionGranted(e) {
								return new Promise((t => {
									e in this._permissions ? t(this._permissions[e]) : this._permissionsApiSupported.then((n => {
										if (!n) return void t(!1);
										const i = [];
										switch (e) {
											case _i.VIDEO:
												i.push(navigator.permissions.query({
													name: ah
												}));
												break;
											case _i.AUDIO:
												i.push(navigator.permissions.query({
													name: oh
												}));
												break;
											default:
												i.push(navigator.permissions.query({
													name: ah
												})), i.push(navigator.permissions.query({
													name: oh
												}))
										}
										Promise.all(i).then((e => t(e.every((e => {
											try {
												return this._parsePermissionState(e)
											} catch {
												return !1
											}
										})))), (() => t(!1)))
									}))
								}))
							}
							isMultipleAudioInputSupported() {
								return !(Wn.isFirefox() && Wn.isVersionLessThan("101") || Wn.isIosBrowser())
							}
							getAudioOutputDevice() {
								return il.getAudioOutputDevice()
							}
							setAudioOutputDevice(e) {
								return il.getCurrentlyAvailableMediaDevices().length > 0 && this._logOutputDevice(e, il.getCurrentlyAvailableMediaDevices()), il.setAudioOutputDevice(e)
							}
							addEventListener(e, t) {
								this._eventEmitter.addListener(e, t)
							}
							removeEventListener(e, t) {
								this._eventEmitter.removeListener(e, t)
							}
							emitEvent(e) {
								for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
								this._eventEmitter.emit(e, ...n)
							}
						},
						dh = (0, S.getLogger)("modules/detection/ActiveDeviceDetector.js");

					function lh(e) {
						for (const t of e) t.stopStream()
					}
					const uh = (0, S.getLogger)("modules/proxyconnection/CustomSignalingLayer.js");
					class hh extends Ed {
						constructor() {
							super(), this.ssrcOwners = new Map, this.chatRoom = null
						}
						getPeerMediaInfo(e, t, n) {
							return {}
						}
						getPeerSourceInfo(e, t) {}
						getSSRCOwner(e) {
							return this.ssrcOwners.get(e)
						}
						getTrackSourceName(e) {}
						removeSSRCOwners(e) {
							if (null != e && e.length)
								for (const t of e) this.ssrcOwners.delete(t)
						}
						setChatRoom(e) {
							this.chatRoom = e
						}
						setSSRCOwner(e, t) {
							if ("number" != typeof e) throw new TypeError(`SSRC(${e}) must be a number`);
							const n = this.ssrcOwners.get(e);
							n && n !== t && uh.error(`SSRC owner re-assigned from ${n} to ${t}`), this.ssrcOwners.set(e, t)
						}
						setTrackMuteStatus(e, t) {
							return !1
						}
						setTrackVideoType(e, t) {
							return !1
						}
						setTrackSourceName(e, t) {}
						updateSsrcOwnersOnLeave(e) {
							const t = Array.from(this.ssrcOwners).filter((t => t[1] === e)).map((e => e[0]));
							null != t && t.length && this.removeSSRCOwners(t)
						}
					}
					let ph;
					! function(e) {
						e.ACCEPT = "session-accept", e.CONNECTION_ERROR = "connection-error-encountered", e.INITIATE = "session-initiate", e.TERMINATE = "session-terminate", e.TRANSPORT_INFO = "transport-info", e.UNAVAILABLE = "unavailable"
					}(ph || (ph = {}));
					const mh = (0, S.getLogger)("modules/proxyconnection/ProxyConnectionPC.js");
					class fh {
						constructor() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
							this._options = {
								pcConfig: {},
								isInitiator: !1,
								receiveAudio: !1,
								receiveVideo: !1,
								...e
							}, this._tracks = [], this._peerConnection = null, this._onError = this._onError.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this), this._onSendMessage = this._onSendMessage.bind(this)
						}
						getPeerJid() {
							return this._options.peerJid
						}
						processMessage(e) {
							switch (e.attr("action")) {
								case ph.ACCEPT:
									this._onSessionAccept(e);
									break;
								case ph.INITIATE:
									this._onSessionInitiate(e);
									break;
								case ph.TERMINATE:
									this._onSessionTerminate(e);
									break;
								case ph.TRANSPORT_INFO:
									this._onTransportInfo(e)
							}
						}
						start() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
							this._peerConnection || (this._tracks = this._tracks.concat(e), this._peerConnection = this._createPeerConnection(), this._peerConnection.invite(e))
						}
						stop() {
							this._peerConnection && this._peerConnection.terminate(), this._onSessionTerminate()
						}
						_createPeerConnection() {
							const e = {
									connected: !0,
									jingle: {
										terminate: () => {}
									},
									sendIQ: this._onSendMessage,
									addEventListener: () => () => {}
								},
								t = {
									iceServers: fa,
									...this._options.pcConfig
								},
								n = {
									addEventListener: () => {},
									addPresenceListener: () => {},
									connectionTimes: [],
									eventEmitter: {
										emit: e => {
											switch (e) {
												case ki.XMPPEvents.CONNECTION_ICE_FAILED:
												case ki.XMPPEvents.CONNECTION_FAILED:
													this._onError(ph.CONNECTION_ERROR, e)
											}
										}
									},
									removeEventListener: () => {},
									removePresenceListener: () => {},
									supportsRestartByTerminate: () => !1
								};
							this._rtc = new il({
								myUserId: () => ""
							}, {}), this._rtc.addListener(Oi.default.REMOTE_TRACK_ADDED, this._onRemoteStream);
							const i = new ta(void 0, void 0, this._options.peerJid, e, {
									offerToReceiveAudio: this._options.receiveAudio,
									offerToReceiveVideo: this._options.receiveVideo
								}, t, !0, this._options.isInitiator),
								s = new hh;
							return s.setChatRoom(n), i.initialize(n, this._rtc, s, {}), i
						}
						_onError(e) {
							let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
							this._options.onError(this._options.peerJid, e, t)
						}
						_onRemoteStream(e) {
							this._tracks.push(e), this._options.onRemoteStream(e)
						}
						_onSendMessage(e) {
							this._options.onSendMessage(this._options.peerJid, e)
						}
						_onSessionAccept(e) {
							this._peerConnection ? this._peerConnection.setAnswer(e) : mh.error("Received an answer when no peer connection exists.")
						}
						_onSessionInitiate(e) {
							this._peerConnection ? mh.error("Received an offer when an offer was already sent.") : (this._peerConnection = this._createPeerConnection(), this._peerConnection.acceptOffer(e, (() => {}), (() => this._onError(this._options.peerJid, ph.CONNECTION_ERROR, "session initiate error"))))
						}
						_onSessionTerminate() {
							this._tracks.forEach((e => e.dispose())), this._tracks = [], this._peerConnection && this._peerConnection.onTerminated(), this._rtc && (this._rtc.removeListener(Oi.default.REMOTE_TRACK_ADDED, this._onRemoteStream), this._rtc.destroy())
						}
						_onTransportInfo(e) {
							this._peerConnection.addIceCandidates(e)
						}
					}
					const gh = (0, S.getLogger)("modules/proxyconnection/ProxyConnectionService.js"),
						_h = "preCallTestResults",
						vh = new(pt());
					let Sh = !1,
						Eh = null;
					const yh = {
						init: async function(e) {
							if (Sh) throw new Error("Precall Test already initialized");
							const {
								callStatsID: t,
								callStatsSecret: n,
								disableThirdPartyRequests: i
							} = e;
							if (!t || !n || i) throw new Error("Callstats is disabled");
							return await
							function(e) {
								if (!Wn.isReactNative()) return new Promise((t => {
									zn().loadScript(e.callStatsCustomScriptUrl || wt, !0, !0, void 0, t)
								}))
							}(e), Eh = new window.callstats,
								function(e) {
									return new Promise(((t, n) => {
										const i = e.callStatsID,
											s = e.callStatsSecret,
											r = e.statisticsId || e.statisticsDisplayName || Er.callStatsUserName;
										Eh.initialize(i, s, r, ((e, i) => {
											"success" === e ? (Eh.on(_h, (function() {
												for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
												vh.emit(_h, ...t)
											})), Sh = !0, t()) : n({
												status: e,
												message: i
											})
										}), null, {
											disablePrecalltest: !0
										})
									}))
								}(e)
						},
						execute: function() {
							return Sh ? new Promise(((e, t) => {
								vh.on(_h, ((n, i) => {
									"success" === n ? e(i) : t({
										status: n,
										payload: i
									})
								})), Eh.makePrecallTest()
							})) : Promise.reject("uninitialized")
						}
					};
					var Th = n(4424),
						Ch = n.n(Th);
					const bh = (0, S.getLogger)("modules/webaudio/AudioMixer.js");
					class Ah {
						constructor() {
							this._started = !1, this._streamsToMix = [], this._streamMSSArray = []
						}
						addMediaStream(e) {
							e.getAudioTracks() || bh.warn("Added MediaStream doesn't contain audio tracks."), this._streamsToMix.push(e)
						}
						start() {
							if (this._started) return this._mixedMSD.stream;
							if (this._audioContext = Al(), !this._streamsToMix.length) return bh.warn("No MediaStream's added to AudioMixer, nothing will happen."), null;
							this._started = !0, this._mixedMSD = this._audioContext.createMediaStreamDestination();
							for (const e of this._streamsToMix) {
								const t = this._audioContext.createMediaStreamSource(e);
								t.connect(this._mixedMSD), this._streamMSSArray.push(t)
							}
							return this._mixedMSD.stream
						}
						reset() {
							this._started = !1, this._streamsToMix = [];
							for (const e of this._streamMSSArray) e.disconnect();
							this._streamMSSArray = [], this._audioContext && (this._audioContext = void 0)
						}
					}
					const Rh = E().getLogger("JitsiMeetJS.ts");

					function Ih(e) {
						const t = {};
						return t.audio_requested = e.devices.includes("audio"), t.video_requested = e.devices.includes("video"), t.screen_sharing_requested = e.devices.includes("desktop"), t.video_requested && (t.resolution = e.resolution), t
					}
					const Ph = {
						version: "931ca368",
						JitsiConnection: eh,
						ProxyConnectionService: class {
							constructor() {
								let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
								const {
									jitsiConnection: t,
									...n
								} = e;
								this._options = {
									pcConfig: t && t.xmpp.connection.jingle.p2pIceConfig,
									...n
								}, this._peerConnection = null, this._onFatalError = this._onFatalError.bind(this), this._onSendMessage = this._onSendMessage.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this)
							}
							processMessage(e) {
								const t = e.from;
								if (!t) return;
								if (this._peerConnection && this._peerConnection.getPeerJid() !== t) return void this._onFatalError(t, ph.CONNECTION_ERROR, "rejected");
								const n = this._convertStringToXML(e.data.iq),
									i = n && n.find("jingle"),
									s = i && i.attr("action");
								s === ph.INITIATE && (this._peerConnection = this._createPeerConnection(t, {
									isInitiator: !1,
									receiveVideo: !0
								})), this._peerConnection && this._peerConnection.processMessage(i), s !== ph.CONNECTION_ERROR && s !== ph.UNAVAILABLE && s !== ph.TERMINATE || this._selfCloseConnection()
							}
							start(e) {
								let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
								this._peerConnection = this._createPeerConnection(e, {
									isInitiator: !0,
									receiveVideo: !1
								}), t.forEach(((e, t) => {
									const n = _d("peer", e.getType(), t);
									e.setSourceName(n)
								})), this._peerConnection.start(t)
							}
							stop() {
								this._peerConnection && this._peerConnection.stop(), this._peerConnection = null
							}
							_convertStringToXML(e) {
								try {
									const t = (new DOMParser).parseFromString(e, "text/xml");
									return ft()(t)
								} catch (e) {
									return gh.error("Attempted to convert incorrectly formatted xml"), null
								}
							}
							_createPeerConnection(e) {
								let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
								if (!e) throw new Error("Cannot create ProxyConnectionPC without a peer.");
								const n = {
									pcConfig: this._options.pcConfig,
									onError: this._onFatalError,
									onRemoteStream: this._onRemoteStream,
									onSendMessage: this._onSendMessage,
									peerJid: e,
									...t
								};
								return new fh(n)
							}
							_onFatalError(e, t) {
								let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
								gh.error("Received a proxy connection error", e, t, n);
								const i = (0, vt.$iq)({
									to: e,
									type: "set"
								}).c("jingle", {
									xmlns: "urn:xmpp:jingle:1",
									action: t
								}).c("details").t(n).up();
								this._onSendMessage(e, i), this._peerConnection && this._peerConnection.getPeerJid() === e && this._selfCloseConnection()
							}
							_onRemoteStream(e) {
								if (!this._options.onRemoteStream) return gh.error("Remote track received without callback."), void e.dispose();
								const t = e.isVideoTrack();
								let n;
								t && (n = this._options.convertVideoToDesktop ? Ni.VideoType.DESKTOP : Ni.VideoType.CAMERA);
								const i = e.getOriginalStream(),
									s = il.createLocalTracks([{
										deviceId: `proxy:${this._peerConnection.getPeerJid()}`,
										mediaType: t ? _i.VIDEO : _i.AUDIO,
										sourceType: "proxy",
										stream: i,
										track: i.getVideoTracks()[0],
										videoType: n
									}]);
								this._options.onRemoteStream(s[0])
							}
							_onSendMessage(e, t) {
								if (this._options.onSendMessage) try {
									const n = (new XMLSerializer).serializeToString(t.nodeTree || t);
									this._options.onSendMessage(e, {
										iq: n
									})
								} catch (e) {
									gh.error("Attempted to send an incorrectly formatted iq.")
								}
							}
							_selfCloseConnection() {
								this.stop(), this._options.onConnectionClosed && this._options.onConnectionClosed()
							}
						},
						constants: {
							recording: {
								error: {
									BUSY: "busy",
									ERROR: "error",
									RESOURCE_CONSTRAINT: "resource-constraint",
									UNEXPECTED_REQUEST: "unexpected-request",
									SERVICE_UNAVAILABLE: "service-unavailable"
								},
								mode: {
									FILE: "file",
									STREAM: "stream"
								},
								status: {
									OFF: "off",
									ON: "on",
									PENDING: "pending"
								}
							},
							sipVideoGW: _,
							transcriptionStatus: d,
							trackStreamingStatus: Ld
						},
						events: {
							conference: s,
							connection: a,
							detection: f,
							track: r,
							mediaDevices: v,
							connectionQuality: m,
							e2eping: g
						},
						errors: {
							conference: i,
							connection: c,
							track: o
						},
						errorTypes: {
							JitsiTrackError: qt
						},
						logLevels: E().levels,
						mediaDevices: ch,
						analytics: Pi.analytics,
						init() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
							Er.init(e.externalStorage), Pi.init(e);
							const t = e.flags || {};
							if (Ns.init(t), window.connectionTimes || (window.connectionTimes = {}), !0 !== e.enableAnalyticsLogging && (Rh.warn("Analytics disabled, disposing."), this.analytics.dispose()), e.enableWindowOnErrorHandler && ei().addHandler(this.getGlobalOnErrorHandler.bind(this)), this.version) {
								const e = {
									id: "component_version",
									component: "lib-jitsi-meet",
									version: this.version
								};
								Pi.sendLog(JSON.stringify(e))
							}
							return il.init(e)
						},
						isDesktopSharingEnabled: () => il.isDesktopSharingEnabled(),
						isWebRtcSupported: () => il.isWebRtcSupported(),
						setLogLevel(e) {
							E().setLogLevel(e)
						},
						setLogLevelById(e, t) {
							E().setLogLevelById(e, t)
						},
						addGlobalLogTransport(e) {
							E().addGlobalTransport(e)
						},
						removeGlobalLogTransport(e) {
							E().removeGlobalTransport(e)
						},
						setGlobalLogOptions(e) {
							E().setGlobalOptions(e)
						},
						createLocalTracks() {
							let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
								t = arguments.length > 1 ? arguments[1] : void 0,
								n = !1;
							const {
								firePermissionPromptIsShownEvent: i,
								fireSlowPromiseEvent: s,
								...r
							} = e;
							return !i && !t || il.arePermissionsGrantedForAvailableDevices() ? s && window.setTimeout((() => {
								n || ch.emitEvent(rh)
							}), 1e3) : ch.emitEvent(sh, Wn.getName()), window.connectionTimes || (window.connectionTimes = {}), window.connectionTimes["obtainPermissions.start"] = window.performance.now(), il.obtainAudioAndVideoPermissions(r).then((e => {
								if (n = !0, window.connectionTimes["obtainPermissions.end"] = window.performance.now(), Pi.sendAnalytics(En("success", Ih(r))), !il.options.disableAudioLevels)
									for (let t = 0; t < e.length; t++) {
										const n = e[t];
										n.getType() === _i.AUDIO && Pi.startLocalStats(n, n.setAudioLevel.bind(n))
									}
								const t = il.getCurrentlyAvailableMediaDevices();
								if (t)
									for (let n = 0; n < e.length; n++) e[n]._setRealDeviceIdFromDeviceList(t);
								for (const t of e) t.type === _i.VIDEO && "desktop" === t.videoType && this.setVideoTrackContentHints(t.track, "detail");
								return e
							})).catch((t => {
								if (n = !0, t.name === Ut) {
									const e = {
										id: "screensharing_user_canceled",
										message: t.message
									};
									Pi.sendLog(JSON.stringify(e)), Pi.sendAnalytics(En("warning", {
										reason: "extension install user canceled"
									}))
								} else if (t.name === xt) {
									const n = {
										id: "usermedia_missing_device",
										status: t.gum.devices
									};
									Pi.sendLog(JSON.stringify(n));
									const i = Ih(e);
									i.reason = "device not found", i.devices = t.gum.devices.join("."), Pi.sendAnalytics(En("error", i))
								} else {
									Pi.sendGetUserMediaFailed(t);
									const n = Ih(e);
									n.reason = t.name, Pi.sendAnalytics(En("error", n))
								}
								return window.connectionTimes["obtainPermissions.end"] = window.performance.now(), Promise.reject(t)
							}))
						},
						createTrackVADEmitter: (e, t, n) => Rl.create(e, t, n),
						createAudioMixer: () => new Ah,
						getActiveAudioDevice: () => new Promise((e => {
							il.enumerateDevices((t => {
								const n = t.filter((e => "audioinput" === e.kind)),
									i = [];
								for (const e of n) {
									const t = il.obtainAudioAndVideoPermissions({
										devices: ["audio"],
										micDeviceId: e.deviceId
									}).then((e => {
										const t = e[0];
										return Pi.startLocalStats(t, t.setAudioLevel.bind(t)), t
									}));
									i.push(t)
								}
								Promise.allSettled(i).then((t => {
									const n = t.filter((e => "fulfilled" === e.status)),
										i = t.filter((e => "rejected" === e.status)),
										s = n.map((e => e.value)),
										r = i.map((e => e.value));
									for (const e of r) dh.error("Failed to acquire audio device with error: ", e);
									for (const t of s) t.on(yt, (n => {
										n > .008 && (lh(s), e({
											deviceId: t.deviceId,
											deviceLabel: t.track.label
										}))
									}));
									setTimeout((() => {
										lh(s), e({
											deviceId: "",
											deviceLabel: ""
										})
									}), 3e3)
								}))
							}))
						})),
						isDeviceListAvailable() {
							return Rh.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceListAvailable instead"), this.mediaDevices.isDeviceListAvailable()
						},
						isDeviceChangeAvailable(e) {
							return Rh.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead"), this.mediaDevices.isDeviceChangeAvailable(e)
						},
						isMultipleAudioInputSupported() {
							return this.mediaDevices.isMultipleAudioInputSupported()
						},
						isCollectingLocalStats: () => Pi.audioLevelsEnabled && li.isLocalStatsSupported(),
						enumerateDevices(e) {
							Rh.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.enumerateDevices instead"), this.mediaDevices.enumerateDevices(e)
						},
						getGlobalOnErrorHandler(e, t, n, i, s) {
							Rh.error(`UnhandledError: ${e}`, `Script: ${t}`, `Line: ${n}`, `Column: ${i}`, "StackTrace: ", s), Pi.reportGlobalError(s)
						},
						setNetworkInfo(e) {
							let {
								isOnline: t
							} = e;
							Bs.updateNetworkInfo({
								isOnline: t
							})
						},
						setVideoTrackContentHints(e, t) {
							"contentHint" in e ? (e.contentHint = t, e.contentHint !== t && Rh.debug("Invalid video track contentHint")) : Rh.debug("MediaStreamTrack contentHint attribute not supported")
						},
						precallTest: yh,
						util: {
							AuthUtil: Ch(),
							ScriptUtil: zn(),
							browser: Wn
						}
					}
				}
			},
			__webpack_module_cache__ = {};

		function __webpack_require__(e) {
			var t = __webpack_module_cache__[e];
			if (void 0 !== t) return t.exports;
			var n = __webpack_module_cache__[e] = {
				id: e,
				loaded: !1,
				exports: {}
			};
			return __webpack_modules__[e].call(n.exports, n, n.exports, __webpack_require__), n.loaded = !0, n.exports
		}
		__webpack_require__.amdO = {}, __webpack_require__.n = e => {
			var t = e && e.__esModule ? () => e.default : () => e;
			return __webpack_require__.d(t, {
				a: t
			}), t
		}, __webpack_require__.d = (e, t) => {
			for (var n in t) __webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, {
				enumerable: !0,
				get: t[n]
			})
		}, __webpack_require__.g = function() {
			if ("object" == typeof globalThis) return globalThis;
			try {
				return this || new Function("return this")()
			} catch (e) {
				if ("object" == typeof window) return window
			}
		}(), __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), __webpack_require__.r = e => {
			"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
				value: "Module"
			}), Object.defineProperty(e, "__esModule", {
				value: !0
			})
		}, __webpack_require__.nmd = e => (e.paths = [], e.children || (e.children = []), e);
		var __webpack_exports__ = __webpack_require__(4449);
		return __webpack_exports__
	})()
}));