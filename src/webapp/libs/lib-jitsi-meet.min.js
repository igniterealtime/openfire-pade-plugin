/*! For license information please see lib-jitsi-meet.min.js.LICENSE.txt */ ! function(e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.JitsiMeetJS = t() : e.JitsiMeetJS = t()
}(self, (function() {
    return (() => {
        var __webpack_modules__ = {
                6522: (module, exports, __webpack_require__) => {
                    var __WEBPACK_AMD_DEFINE_RESULT__;
                    (function() {
                        "use strict";
                        var ERROR = "input is invalid type",
                            WINDOW = "object" == typeof window,
                            root = WINDOW ? window : {};
                        root.JS_MD5_NO_WINDOW && (WINDOW = !1);
                        var WEB_WORKER = !WINDOW && "object" == typeof self,
                            NODE_JS = !root.JS_MD5_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node;
                        NODE_JS ? root = __webpack_require__.g : WEB_WORKER && (root = self);
                        var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && module.exports,
                            AMD = __webpack_require__.amdO,
                            ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer,
                            HEX_CHARS = "0123456789abcdef".split(""),
                            EXTRA = [128, 32768, 8388608, -2147483648],
                            SHIFT = [0, 8, 16, 24],
                            OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"],
                            BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),
                            blocks = [],
                            buffer8;
                        if (ARRAY_BUFFER) {
                            var buffer = new ArrayBuffer(68);
                            buffer8 = new Uint8Array(buffer), blocks = new Uint32Array(buffer)
                        }!root.JS_MD5_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
                            return "[object Array]" === Object.prototype.toString.call(e)
                        }), !ARRAY_BUFFER || !root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
                            return "object" == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
                        });
                        var createOutputMethod = function(e) {
                                return function(t) {
                                    return new Md5(!0).update(t)[e]()
                                }
                            },
                            createMethod = function() {
                                var e = createOutputMethod("hex");
                                NODE_JS && (e = nodeWrap(e)), e.create = function() {
                                    return new Md5
                                }, e.update = function(t) {
                                    return e.create().update(t)
                                };
                                for (var t = 0; t < OUTPUT_TYPES.length; ++t) {
                                    var n = OUTPUT_TYPES[t];
                                    e[n] = createOutputMethod(n)
                                }
                                return e
                            },
                            nodeWrap = function(method) {
                                var crypto = eval("require('crypto')"),
                                    Buffer = eval("require('buffer').Buffer"),
                                    nodeMethod = function(e) {
                                        if ("string" == typeof e) return crypto.createHash("md5").update(e, "utf8").digest("hex");
                                        if (null == e) throw ERROR;
                                        return e.constructor === ArrayBuffer && (e = new Uint8Array(e)), Array.isArray(e) || ArrayBuffer.isView(e) || e.constructor === Buffer ? crypto.createHash("md5").update(new Buffer(e)).digest("hex") : method(e)
                                    };
                                return nodeMethod
                            };

                        function Md5(e) {
                            if (e) blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks, this.buffer8 = buffer8;
                            else if (ARRAY_BUFFER) {
                                var t = new ArrayBuffer(68);
                                this.buffer8 = new Uint8Array(t), this.blocks = new Uint32Array(t)
                            } else this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                            this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0
                        }
                        Md5.prototype.update = function(e) {
                            if (!this.finalized) {
                                var t, n = typeof e;
                                if ("string" !== n) {
                                    if ("object" !== n) throw ERROR;
                                    if (null === e) throw ERROR;
                                    if (ARRAY_BUFFER && e.constructor === ArrayBuffer) e = new Uint8Array(e);
                                    else if (!(Array.isArray(e) || ARRAY_BUFFER && ArrayBuffer.isView(e))) throw ERROR;
                                    t = !0
                                }
                                for (var i, s, r = 0, o = e.length, a = this.blocks, c = this.buffer8; r < o;) {
                                    if (this.hashed && (this.hashed = !1, a[0] = a[16], a[16] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = a[9] = a[10] = a[11] = a[12] = a[13] = a[14] = a[15] = 0), t)
                                        if (ARRAY_BUFFER)
                                            for (s = this.start; r < o && s < 64; ++r) c[s++] = e[r];
                                        else
                                            for (s = this.start; r < o && s < 64; ++r) a[s >> 2] |= e[r] << SHIFT[3 & s++];
                                    else if (ARRAY_BUFFER)
                                        for (s = this.start; r < o && s < 64; ++r)(i = e.charCodeAt(r)) < 128 ? c[s++] = i : i < 2048 ? (c[s++] = 192 | i >> 6, c[s++] = 128 | 63 & i) : i < 55296 || i >= 57344 ? (c[s++] = 224 | i >> 12, c[s++] = 128 | i >> 6 & 63, c[s++] = 128 | 63 & i) : (i = 65536 + ((1023 & i) << 10 | 1023 & e.charCodeAt(++r)), c[s++] = 240 | i >> 18, c[s++] = 128 | i >> 12 & 63, c[s++] = 128 | i >> 6 & 63, c[s++] = 128 | 63 & i);
                                    else
                                        for (s = this.start; r < o && s < 64; ++r)(i = e.charCodeAt(r)) < 128 ? a[s >> 2] |= i << SHIFT[3 & s++] : i < 2048 ? (a[s >> 2] |= (192 | i >> 6) << SHIFT[3 & s++], a[s >> 2] |= (128 | 63 & i) << SHIFT[3 & s++]) : i < 55296 || i >= 57344 ? (a[s >> 2] |= (224 | i >> 12) << SHIFT[3 & s++], a[s >> 2] |= (128 | i >> 6 & 63) << SHIFT[3 & s++], a[s >> 2] |= (128 | 63 & i) << SHIFT[3 & s++]) : (i = 65536 + ((1023 & i) << 10 | 1023 & e.charCodeAt(++r)), a[s >> 2] |= (240 | i >> 18) << SHIFT[3 & s++], a[s >> 2] |= (128 | i >> 12 & 63) << SHIFT[3 & s++], a[s >> 2] |= (128 | i >> 6 & 63) << SHIFT[3 & s++], a[s >> 2] |= (128 | 63 & i) << SHIFT[3 & s++]);
                                    this.lastByteIndex = s, this.bytes += s - this.start, s >= 64 ? (this.start = s - 64, this.hash(), this.hashed = !0) : this.start = s
                                }
                                return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this
                            }
                        }, Md5.prototype.finalize = function() {
                            if (!this.finalized) {
                                this.finalized = !0;
                                var e = this.blocks,
                                    t = this.lastByteIndex;
                                e[t >> 2] |= EXTRA[3 & t], t >= 56 && (this.hashed || this.hash(), e[0] = e[16], e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0), e[14] = this.bytes << 3, e[15] = this.hBytes << 3 | this.bytes >>> 29, this.hash()
                            }
                        }, Md5.prototype.hash = function() {
                            var e, t, n, i, s, r, o = this.blocks;
                            this.first ? t = ((t = ((e = ((e = o[0] - 680876937) << 7 | e >>> 25) - 271733879 << 0) ^ (n = ((n = (-271733879 ^ (i = ((i = (-1732584194 ^ 2004318071 & e) + o[1] - 117830708) << 12 | i >>> 20) + e << 0) & (-271733879 ^ e)) + o[2] - 1126478375) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[3] - 1316259209) << 22 | t >>> 10) + n << 0 : (e = this.h0, t = this.h1, n = this.h2, t = ((t += ((e = ((e += ((i = this.h3) ^ t & (n ^ i)) + o[0] - 680876936) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[1] - 389564586) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[2] + 606105819) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[3] - 1044525330) << 22 | t >>> 10) + n << 0), t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + o[4] - 176418897) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[5] + 1200080426) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[6] - 1473231341) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[7] - 45705983) << 22 | t >>> 10) + n << 0, t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + o[8] + 1770035416) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[9] - 1958414417) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[10] - 42063) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[11] - 1990404162) << 22 | t >>> 10) + n << 0, t = ((t += ((e = ((e += (i ^ t & (n ^ i)) + o[12] + 1804603682) << 7 | e >>> 25) + t << 0) ^ (n = ((n += (t ^ (i = ((i += (n ^ e & (t ^ n)) + o[13] - 40341101) << 12 | i >>> 20) + e << 0) & (e ^ t)) + o[14] - 1502002290) << 17 | n >>> 15) + i << 0) & (i ^ e)) + o[15] + 1236535329) << 22 | t >>> 10) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[1] - 165796510) << 5 | e >>> 27) + t << 0) ^ t)) + o[6] - 1069501632) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[11] + 643717713) << 14 | n >>> 18) + i << 0) ^ i)) + o[0] - 373897302) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[5] - 701558691) << 5 | e >>> 27) + t << 0) ^ t)) + o[10] + 38016083) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[15] - 660478335) << 14 | n >>> 18) + i << 0) ^ i)) + o[4] - 405537848) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[9] + 568446438) << 5 | e >>> 27) + t << 0) ^ t)) + o[14] - 1019803690) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[3] - 187363961) << 14 | n >>> 18) + i << 0) ^ i)) + o[8] + 1163531501) << 20 | t >>> 12) + n << 0, t = ((t += ((i = ((i += (t ^ n & ((e = ((e += (n ^ i & (t ^ n)) + o[13] - 1444681467) << 5 | e >>> 27) + t << 0) ^ t)) + o[2] - 51403784) << 9 | i >>> 23) + e << 0) ^ e & ((n = ((n += (e ^ t & (i ^ e)) + o[7] + 1735328473) << 14 | n >>> 18) + i << 0) ^ i)) + o[12] - 1926607734) << 20 | t >>> 12) + n << 0, t = ((t += ((r = (i = ((i += ((s = t ^ n) ^ (e = ((e += (s ^ i) + o[5] - 378558) << 4 | e >>> 28) + t << 0)) + o[8] - 2022574463) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (r ^ t) + o[11] + 1839030562) << 16 | n >>> 16) + i << 0)) + o[14] - 35309556) << 23 | t >>> 9) + n << 0, t = ((t += ((r = (i = ((i += ((s = t ^ n) ^ (e = ((e += (s ^ i) + o[1] - 1530992060) << 4 | e >>> 28) + t << 0)) + o[4] + 1272893353) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (r ^ t) + o[7] - 155497632) << 16 | n >>> 16) + i << 0)) + o[10] - 1094730640) << 23 | t >>> 9) + n << 0, t = ((t += ((r = (i = ((i += ((s = t ^ n) ^ (e = ((e += (s ^ i) + o[13] + 681279174) << 4 | e >>> 28) + t << 0)) + o[0] - 358537222) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (r ^ t) + o[3] - 722521979) << 16 | n >>> 16) + i << 0)) + o[6] + 76029189) << 23 | t >>> 9) + n << 0, t = ((t += ((r = (i = ((i += ((s = t ^ n) ^ (e = ((e += (s ^ i) + o[9] - 640364487) << 4 | e >>> 28) + t << 0)) + o[12] - 421815835) << 11 | i >>> 21) + e << 0) ^ e) ^ (n = ((n += (r ^ t) + o[15] + 530742520) << 16 | n >>> 16) + i << 0)) + o[2] - 995338651) << 23 | t >>> 9) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[0] - 198630844) << 6 | e >>> 26) + t << 0) | ~n)) + o[7] + 1126891415) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[14] - 1416354905) << 15 | n >>> 17) + i << 0) | ~e)) + o[5] - 57434055) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[12] + 1700485571) << 6 | e >>> 26) + t << 0) | ~n)) + o[3] - 1894986606) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[10] - 1051523) << 15 | n >>> 17) + i << 0) | ~e)) + o[1] - 2054922799) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[8] + 1873313359) << 6 | e >>> 26) + t << 0) | ~n)) + o[15] - 30611744) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[6] - 1560198380) << 15 | n >>> 17) + i << 0) | ~e)) + o[13] + 1309151649) << 21 | t >>> 11) + n << 0, t = ((t += ((i = ((i += (t ^ ((e = ((e += (n ^ (t | ~i)) + o[4] - 145523070) << 6 | e >>> 26) + t << 0) | ~n)) + o[11] - 1120210379) << 10 | i >>> 22) + e << 0) ^ ((n = ((n += (e ^ (i | ~t)) + o[2] + 718787259) << 15 | n >>> 17) + i << 0) | ~e)) + o[9] - 343485551) << 21 | t >>> 11) + n << 0, this.first ? (this.h0 = e + 1732584193 << 0, this.h1 = t - 271733879 << 0, this.h2 = n - 1732584194 << 0, this.h3 = i + 271733878 << 0, this.first = !1) : (this.h0 = this.h0 + e << 0, this.h1 = this.h1 + t << 0, this.h2 = this.h2 + n << 0, this.h3 = this.h3 + i << 0)
                        }, Md5.prototype.hex = function() {
                            this.finalize();
                            var e = this.h0,
                                t = this.h1,
                                n = this.h2,
                                i = this.h3;
                            return HEX_CHARS[e >> 4 & 15] + HEX_CHARS[15 & e] + HEX_CHARS[e >> 12 & 15] + HEX_CHARS[e >> 8 & 15] + HEX_CHARS[e >> 20 & 15] + HEX_CHARS[e >> 16 & 15] + HEX_CHARS[e >> 28 & 15] + HEX_CHARS[e >> 24 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[15 & t] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[15 & n] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[i >> 4 & 15] + HEX_CHARS[15 & i] + HEX_CHARS[i >> 12 & 15] + HEX_CHARS[i >> 8 & 15] + HEX_CHARS[i >> 20 & 15] + HEX_CHARS[i >> 16 & 15] + HEX_CHARS[i >> 28 & 15] + HEX_CHARS[i >> 24 & 15]
                        }, Md5.prototype.toString = Md5.prototype.hex, Md5.prototype.digest = function() {
                            this.finalize();
                            var e = this.h0,
                                t = this.h1,
                                n = this.h2,
                                i = this.h3;
                            return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255, 255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255, 255 & n, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255, 255 & i, i >> 8 & 255, i >> 16 & 255, i >> 24 & 255]
                        }, Md5.prototype.array = Md5.prototype.digest, Md5.prototype.arrayBuffer = function() {
                            this.finalize();
                            var e = new ArrayBuffer(16),
                                t = new Uint32Array(e);
                            return t[0] = this.h0, t[1] = this.h1, t[2] = this.h2, t[3] = this.h3, e
                        }, Md5.prototype.buffer = Md5.prototype.arrayBuffer, Md5.prototype.base64 = function() {
                            for (var e, t, n, i = "", s = this.array(), r = 0; r < 15;) e = s[r++], t = s[r++], n = s[r++], i += BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[63 & (e << 4 | t >>> 4)] + BASE64_ENCODE_CHAR[63 & (t << 2 | n >>> 6)] + BASE64_ENCODE_CHAR[63 & n];
                            return e = s[r], i + (BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[e << 4 & 63] + "==")
                        };
                        var exports = createMethod();
                        COMMON_JS ? module.exports = exports : (root.md5 = exports, AMD && (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                            return exports
                        }.call(exports, __webpack_require__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)))
                    })()
                },
                4615: e => {
                    var t = e.exports = {
                        v: [{
                            name: "version",
                            reg: /^(\d*)$/
                        }],
                        o: [{
                            name: "origin",
                            reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
                            names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
                            format: "%s %s %d %s IP%d %s"
                        }],
                        s: [{
                            name: "name"
                        }],
                        i: [{
                            name: "description"
                        }],
                        u: [{
                            name: "uri"
                        }],
                        e: [{
                            name: "email"
                        }],
                        p: [{
                            name: "phone"
                        }],
                        z: [{
                            name: "timezones"
                        }],
                        r: [{
                            name: "repeats"
                        }],
                        t: [{
                            name: "timing",
                            reg: /^(\d*) (\d*)/,
                            names: ["start", "stop"],
                            format: "%d %d"
                        }],
                        c: [{
                            name: "connection",
                            reg: /^IN IP(\d) (\S*)/,
                            names: ["version", "ip"],
                            format: "IN IP%d %s"
                        }],
                        b: [{
                            push: "bandwidth",
                            reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
                            names: ["type", "limit"],
                            format: "%s:%s"
                        }],
                        m: [{
                            reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
                            names: ["type", "port", "protocol", "payloads"],
                            format: "%s %d %s %s"
                        }],
                        a: [{
                            push: "rtp",
                            reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
                            names: ["payload", "codec", "rate", "encoding"],
                            format: function(e) {
                                return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
                            }
                        }, {
                            push: "fmtp",
                            reg: /^fmtp:(\d*) ([\S| ]*)/,
                            names: ["payload", "config"],
                            format: "fmtp:%d %s"
                        }, {
                            name: "control",
                            reg: /^control:(.*)/,
                            format: "control:%s"
                        }, {
                            name: "rtcp",
                            reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                            names: ["port", "netType", "ipVer", "address"],
                            format: function(e) {
                                return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
                            }
                        }, {
                            push: "rtcpFbTrrInt",
                            reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                            names: ["payload", "value"],
                            format: "rtcp-fb:%s trr-int %d"
                        }, {
                            push: "rtcpFb",
                            reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                            names: ["payload", "type", "subtype"],
                            format: function(e) {
                                return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
                            }
                        }, {
                            push: "ext",
                            reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
                            names: ["value", "direction", "encrypt-uri", "uri", "config"],
                            format: function(e) {
                                return "extmap:%d" + (e.direction ? "/%s" : "%v") + (e["encrypt-uri"] ? " %s" : "%v") + " %s" + (e.config ? " %s" : "")
                            }
                        }, {
                            name: "extmapAllowMixed",
                            reg: /^(extmap-allow-mixed)/
                        }, {
                            push: "crypto",
                            reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                            names: ["id", "suite", "config", "sessionConfig"],
                            format: function(e) {
                                return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
                            }
                        }, {
                            name: "setup",
                            reg: /^setup:(\w*)/,
                            format: "setup:%s"
                        }, {
                            name: "connectionType",
                            reg: /^connection:(new|existing)/,
                            format: "connection:%s"
                        }, {
                            name: "mid",
                            reg: /^mid:([^\s]*)/,
                            format: "mid:%s"
                        }, {
                            name: "msid",
                            reg: /^msid:(.*)/,
                            format: "msid:%s"
                        }, {
                            name: "ptime",
                            reg: /^ptime:(\d*(?:\.\d*)*)/,
                            format: "ptime:%d"
                        }, {
                            name: "maxptime",
                            reg: /^maxptime:(\d*(?:\.\d*)*)/,
                            format: "maxptime:%d"
                        }, {
                            name: "direction",
                            reg: /^(sendrecv|recvonly|sendonly|inactive)/
                        }, {
                            name: "icelite",
                            reg: /^(ice-lite)/
                        }, {
                            name: "iceUfrag",
                            reg: /^ice-ufrag:(\S*)/,
                            format: "ice-ufrag:%s"
                        }, {
                            name: "icePwd",
                            reg: /^ice-pwd:(\S*)/,
                            format: "ice-pwd:%s"
                        }, {
                            name: "fingerprint",
                            reg: /^fingerprint:(\S*) (\S*)/,
                            names: ["type", "hash"],
                            format: "fingerprint:%s %s"
                        }, {
                            push: "candidates",
                            reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
                            names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
                            format: function(e) {
                                var t = "candidate:%s %d %s %d %s %d typ %s";
                                return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), (t += null != e["network-id"] ? " network-id %d" : "%v") + (null != e["network-cost"] ? " network-cost %d" : "%v")
                            }
                        }, {
                            name: "endOfCandidates",
                            reg: /^(end-of-candidates)/
                        }, {
                            name: "remoteCandidates",
                            reg: /^remote-candidates:(.*)/,
                            format: "remote-candidates:%s"
                        }, {
                            name: "iceOptions",
                            reg: /^ice-options:(\S*)/,
                            format: "ice-options:%s"
                        }, {
                            push: "ssrcs",
                            reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
                            names: ["id", "attribute", "value"],
                            format: function(e) {
                                var t = "ssrc:%d";
                                return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
                            }
                        }, {
                            push: "ssrcGroups",
                            reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
                            names: ["semantics", "ssrcs"],
                            format: "ssrc-group:%s %s"
                        }, {
                            name: "msidSemantic",
                            reg: /^msid-semantic:\s?(\w*) (\S*)/,
                            names: ["semantic", "token"],
                            format: "msid-semantic: %s %s"
                        }, {
                            push: "groups",
                            reg: /^group:(\w*) (.*)/,
                            names: ["type", "mids"],
                            format: "group:%s %s"
                        }, {
                            name: "rtcpMux",
                            reg: /^(rtcp-mux)/
                        }, {
                            name: "rtcpRsize",
                            reg: /^(rtcp-rsize)/
                        }, {
                            name: "sctpmap",
                            reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
                            names: ["sctpmapNumber", "app", "maxMessageSize"],
                            format: function(e) {
                                return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
                            }
                        }, {
                            name: "xGoogleFlag",
                            reg: /^x-google-flag:([^\s]*)/,
                            format: "x-google-flag:%s"
                        }, {
                            push: "rids",
                            reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
                            names: ["id", "direction", "params"],
                            format: function(e) {
                                return e.params ? "rid:%s %s %s" : "rid:%s %s"
                            }
                        }, {
                            push: "imageattrs",
                            reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
                            names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
                            format: function(e) {
                                return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
                            }
                        }, {
                            name: "simulcast",
                            reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
                            names: ["dir1", "list1", "dir2", "list2"],
                            format: function(e) {
                                return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
                            }
                        }, {
                            name: "simulcast_03",
                            reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
                            names: ["value"],
                            format: "simulcast: %s"
                        }, {
                            name: "framerate",
                            reg: /^framerate:(\d+(?:$|\.\d+))/,
                            format: "framerate:%s"
                        }, {
                            name: "sourceFilter",
                            reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
                            names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
                            format: "source-filter: %s %s %s %s %s"
                        }, {
                            name: "bundleOnly",
                            reg: /^(bundle-only)/
                        }, {
                            name: "label",
                            reg: /^label:(.+)/,
                            format: "label:%s"
                        }, {
                            name: "sctpPort",
                            reg: /^sctp-port:(\d+)$/,
                            format: "sctp-port:%s"
                        }, {
                            name: "maxMessageSize",
                            reg: /^max-message-size:(\d+)$/,
                            format: "max-message-size:%s"
                        }, {
                            push: "tsRefClocks",
                            reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
                            names: ["clksrc", "clksrcExt"],
                            format: function(e) {
                                return "ts-refclk:%s" + (null != e.clksrcExt ? "=%s" : "")
                            }
                        }, {
                            name: "mediaClk",
                            reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
                            names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
                            format: function(e) {
                                var t = "mediaclk:";
                                return t += null != e.id ? "id=%s %s" : "%v%s", t += null != e.mediaClockValue ? "=%s" : "", (t += null != e.rateNumerator ? " rate=%s" : "") + (null != e.rateDenominator ? "/%s" : "")
                            }
                        }, {
                            name: "keywords",
                            reg: /^keywds:(.+)$/,
                            format: "keywds:%s"
                        }, {
                            name: "content",
                            reg: /^content:(.+)/,
                            format: "content:%s"
                        }, {
                            name: "bfcpFloorCtrl",
                            reg: /^floorctrl:(c-only|s-only|c-s)/,
                            format: "floorctrl:%s"
                        }, {
                            name: "bfcpConfId",
                            reg: /^confid:(\d+)/,
                            format: "confid:%s"
                        }, {
                            name: "bfcpUserId",
                            reg: /^userid:(\d+)/,
                            format: "userid:%s"
                        }, {
                            name: "bfcpFloorId",
                            reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
                            names: ["id", "mStream"],
                            format: "floorid:%s mstrm:%s"
                        }, {
                            push: "invalid",
                            names: ["value"]
                        }]
                    };
                    Object.keys(t).forEach((function(e) {
                        t[e].forEach((function(e) {
                            e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
                        }))
                    }))
                },
                7546: (e, t, n) => {
                    var i = n(1620),
                        s = n(6226);
                    t.write = s, t.parse = i.parse, t.parseParams = i.parseParams, t.parseFmtpConfig = i.parseFmtpConfig, t.parsePayloads = i.parsePayloads, t.parseRemoteCandidates = i.parseRemoteCandidates, t.parseImageAttributes = i.parseImageAttributes, t.parseSimulcastStreamList = i.parseSimulcastStreamList
                },
                1620: (e, t, n) => {
                    var i = function(e) {
                            return String(Number(e)) === e ? Number(e) : e
                        },
                        s = function(e, t, n) {
                            var s = e.name && e.names;
                            e.push && !t[e.push] ? t[e.push] = [] : s && !t[e.name] && (t[e.name] = {});
                            var r = e.push ? {} : s ? t[e.name] : t;
                            ! function(e, t, n, s) {
                                if (s && !n) t[s] = i(e[1]);
                                else
                                    for (var r = 0; r < n.length; r += 1) null != e[r + 1] && (t[n[r]] = i(e[r + 1]))
                            }(n.match(e.reg), r, e.names, e.name), e.push && t[e.push].push(r)
                        },
                        r = n(4615),
                        o = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
                    t.parse = function(e) {
                        var t = {},
                            n = [],
                            i = t;
                        return e.split(/(\r\n|\r|\n)/).filter(o).forEach((function(e) {
                            var t = e[0],
                                o = e.slice(2);
                            "m" === t && (n.push({
                                rtp: [],
                                fmtp: []
                            }), i = n[n.length - 1]);
                            for (var a = 0; a < (r[t] || []).length; a += 1) {
                                var c = r[t][a];
                                if (c.reg.test(o)) return s(c, i, o)
                            }
                        })), t.media = n, t
                    };
                    var a = function(e, t) {
                        var n = t.split(/=(.+)/, 2);
                        return 2 === n.length ? e[n[0]] = i(n[1]) : 1 === n.length && t.length > 1 && (e[n[0]] = void 0), e
                    };
                    t.parseParams = function(e) {
                        return e.split(/;\s?/).reduce(a, {})
                    }, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e) {
                        return e.toString().split(" ").map(Number)
                    }, t.parseRemoteCandidates = function(e) {
                        for (var t = [], n = e.split(" ").map(i), s = 0; s < n.length; s += 3) t.push({
                            component: n[s],
                            ip: n[s + 1],
                            port: n[s + 2]
                        });
                        return t
                    }, t.parseImageAttributes = function(e) {
                        return e.split(" ").map((function(e) {
                            return e.substring(1, e.length - 1).split(",").reduce(a, {})
                        }))
                    }, t.parseSimulcastStreamList = function(e) {
                        return e.split(";").map((function(e) {
                            return e.split(",").map((function(e) {
                                var t, n = !1;
                                return "~" !== e[0] ? t = i(e) : (t = i(e.substring(1, e.length)), n = !0), {
                                    scid: t,
                                    paused: n
                                }
                            }))
                        }))
                    }
                },
                6226: (e, t, n) => {
                    var i = n(4615),
                        s = /%[sdv%]/g,
                        r = function(e) {
                            var t = 1,
                                n = arguments,
                                i = n.length;
                            return e.replace(s, (function(e) {
                                if (t >= i) return e;
                                var s = n[t];
                                switch (t += 1, e) {
                                    case "%%":
                                        return "%";
                                    case "%s":
                                        return String(s);
                                    case "%d":
                                        return Number(s);
                                    case "%v":
                                        return ""
                                }
                            }))
                        },
                        o = function(e, t, n) {
                            var i = [e + "=" + (t.format instanceof Function ? t.format(t.push ? n : n[t.name]) : t.format)];
                            if (t.names)
                                for (var s = 0; s < t.names.length; s += 1) {
                                    var o = t.names[s];
                                    t.name ? i.push(n[t.name][o]) : i.push(n[t.names[s]])
                                } else i.push(n[t.name]);
                            return r.apply(null, i)
                        },
                        a = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
                        c = ["i", "c", "b", "a"];
                    e.exports = function(e, t) {
                        t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
                            null == e.payloads && (e.payloads = "")
                        }));
                        var n = t.outerOrder || a,
                            s = t.innerOrder || c,
                            r = [];
                        return n.forEach((function(t) {
                            i[t].forEach((function(n) {
                                n.name in e && null != e[n.name] ? r.push(o(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                                    r.push(o(t, n, e))
                                }))
                            }))
                        })), e.media.forEach((function(e) {
                            r.push(o("m", i.m[0], e)), s.forEach((function(t) {
                                i[t].forEach((function(n) {
                                    n.name in e && null != e[n.name] ? r.push(o(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                                        r.push(o(t, n, e))
                                    }))
                                }))
                            }))
                        })), r.join("\r\n") + "\r\n"
                    }
                },
                9340: (e, t, n) => {
                    var i = n(1810),
                        s = n(4400),
                        r = s.parseSsrcs,
                        o = s.writeSsrcs;

                    function a(e, t, n) {
                        return e.ssrcs.filter((function(e) {
                            return e.id === t
                        })).filter((function(e) {
                            return e.attribute === n
                        })).map((function(e) {
                            return e.value
                        }))[0]
                    }

                    function c(e) {
                        this.options = e || {}, this.options.numOfLayers || (this.options.numOfLayers = 3), console.log("SdpSimulcast: using " + this.options.numOfLayers + " layers"), this.ssrcCache = []
                    }

                    function d(e, t) {
                        null != e && Array.isArray(e.media) && e.media.forEach((function(e) {
                            "video" === e.type && t(e)
                        }))
                    }

                    function l(e) {
                        return e && null != e && e.type && "" != e.type && e.sdp && "" != e.sdp
                    }
                    c.prototype.clearSsrcCache = function() {
                        this.ssrcCache = []
                    }, c.prototype.setSsrcCache = function(e) {
                        this.ssrcCache = e
                    }, c.prototype._parseSimLayers = function(e) {
                        var t = e.ssrcGroups && e.ssrcGroups.find((function(e) {
                            return "SIM" === e.semantics
                        }));
                        return t ? t.ssrcs.split(" ").map((function(e) {
                            return parseInt(e)
                        })) : [e.ssrcs[0].id]
                    }, c.prototype._buildNewToOldSsrcMap = function(e, t) {
                        for (var n = {}, i = 0; i < e.length; ++i) {
                            var s = e[i],
                                r = t[i] || null;
                            n[s] = r
                        }
                        return n
                    }, c.prototype._fillInSourceDataFromCache = function(e) {
                        console.log("SdpSimulcast restoring from cache: ", this.ssrcCache);
                        var t = this._parseSimLayers(e);
                        console.log("SdpSimulcast Parsed new sim ssrcs: ", t);
                        var n = a(e, t[0], "msid"),
                            i = a(e, t[0], "cname"),
                            s = this._buildNewToOldSsrcMap(t, this.ssrcCache);
                        console.log("SdpSimulcast built replacement map: ", s);
                        var r = this.ssrcCache.filter((function(e) {
                            return -1 === Object.values(s).indexOf(e)
                        }));
                        return console.log("SdpSimulcast built ssrcs to add: ", r), e.ssrcs.forEach((function(e) {
                            s[e.id] && (e.id = s[e.id])
                        })), r.forEach((function(t) {
                            e.ssrcs.push({
                                id: t,
                                attribute: "msid",
                                value: n
                            }), e.ssrcs.push({
                                id: t,
                                attribute: "cname",
                                value: i
                            })
                        })), e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
                            semantics: "SIM",
                            ssrcs: this.ssrcCache.join(" ")
                        }), e
                    }, c.prototype._generateSourceData = function(e, t) {
                        var n = function(e, t) {
                                e.ssrcs.push({
                                    id: t,
                                    attribute: "cname",
                                    value: s
                                }), e.ssrcs.push({
                                    id: t,
                                    attribute: "msid",
                                    value: i
                                })
                            },
                            i = a(e, t, "msid"),
                            s = a(e, t, "cname");
                        this.options.usesUnifiedPlan && !i && (i = e.msid, e.ssrcs.forEach((t => {
                            e.ssrcs.push({
                                id: t.id,
                                attribute: "msid",
                                value: i
                            })
                        })));
                        for (var r = [], o = 0; o < this.options.numOfLayers - 1; ++o) {
                            var c = Math.floor(4294967295 * Math.random()) + 0;
                            n(e, c), r.push(c)
                        }
                        return e.ssrcGroups = e.ssrcGroups || [], e.ssrcGroups.push({
                            semantics: "SIM",
                            ssrcs: t + " " + r.join(" ")
                        }), e
                    }, c.prototype._restoreSimulcast = function(e) {
                        var t, n = e.ssrcs && e.ssrcs.map((function(e) {
                                return e.id
                            })).filter((function(e, t, n) {
                                return n.indexOf(e) === t
                            })).length || 0,
                            i = e.ssrcGroups && e.ssrcGroups.length || 0;
                        if (0 === n || n > 2) return e;
                        if (2 == n && 0 === i) return e;
                        if (1 === n) t = e.ssrcs[0].id;
                        else {
                            var s = e.ssrcGroups.filter((function(e) {
                                return "FID" === e.semantics
                            }))[0];
                            if (!s) return e;
                            t = parseInt(s.ssrcs.split(" ")[0])
                        }
                        return console.log("SdpSimulcast: current ssrc cache: ", this.ssrcCache), console.log("SdpSimulcast: parsed primary ssrc " + t), -1 !== this.ssrcCache.indexOf(t) ? (console.log("SdpSimulcast: Have seen primary ssrc before, filling in data from cache"), e = this._fillInSourceDataFromCache(e)) : (console.log("SdpSimulcast: Have not seen primary ssrc before, generating source data"), e = this._generateSourceData(e, t)), this.ssrcCache = this._parseSimLayers(e), e
                    }, c.prototype.mungeRemoteDescription = function(e, t) {
                        if (!l(e)) return e;
                        var n = i.parse(e.sdp),
                            s = this;
                        return d(n, (function(e) {
                            s.options.explodeRemoteSimulcast ? function(e) {
                                if (e && Array.isArray(e.ssrcGroups))
                                    for (var t = r(e), n = [], i = e.ssrcGroups.length; i--;)
                                        if ("SIM" === e.ssrcGroups[i].semantics) {
                                            for (var s = e.ssrcGroups[i].ssrcs.split(" "), a = 0; a < s.length; a++) {
                                                var c = s[a];
                                                n.push(c);
                                                var d = t[c].msid.split(" ");
                                                t[c].msid = [d[0], "/", a, " ", d[1], "/", a].join(""), t[c].cname = [t[c].cname, "/", a].join(""), e.ssrcGroups.forEach((function(e) {
                                                    if ("SIM" !== e.semantics) {
                                                        var i = e.ssrcs.split(" "); - 1 !== i.indexOf(c) && i.forEach((function(e) {
                                                            t[e].msid = t[c].msid, t[e].cname = t[c].cname, e !== c && n.push(e)
                                                        }))
                                                    }
                                                }))
                                            }
                                            e.ssrcs = o(t, n), e.ssrcGroups.splice(i, 1)
                                        }
                            }(e) : function(e) {
                                if (e && Array.isArray(e.ssrcGroups)) {
                                    var t = r(e);
                                    e.ssrcGroups.forEach((function(n) {
                                        if ("SIM" === n.semantics) {
                                            console.info("Imploding SIM group: " + n.ssrcs), n.nuke = !0;
                                            for (var i = n.ssrcs.split(" "), s = 1; s < i.length; s++) {
                                                var r = i[s];
                                                delete t[r], e.ssrcGroups.forEach((function(e) {
                                                    if ("SIM" !== e.semantics) {
                                                        var n = e.ssrcs.split(" "); - 1 !== n.indexOf(r) && (n.forEach((function(e) {
                                                            delete t[e]
                                                        })), e.nuke = !0)
                                                    }
                                                }))
                                            }
                                        }
                                    })), e.ssrcs = o(t);
                                    for (var n = e.ssrcGroups.length; n--;) e.ssrcGroups[n].nuke && e.ssrcGroups.splice(n, 1)
                                } else console.info("Halt: There are no SSRC groups in the remote description.")
                            }(e), !s.options.usesUnifiedPlan && t ? function(e) {
                                e && (Array.isArray(e.invalid) || (e.invalid = []), e.invalid.some((function(e) {
                                    return "x-google-flag:conference" === e.value
                                })) || e.invalid.push({
                                    value: "x-google-flag:conference"
                                }))
                            }(e) : function(e) {
                                e && void 0 !== e.xGoogleFlag && (e.xGoogleFlag = void 0)
                            }(e)
                        })), new RTCSessionDescription({
                            type: e.type,
                            sdp: i.write(n)
                        })
                    }, c.prototype.mungeLocalDescription = function(e) {
                        if (!l(e)) return e;
                        var t = i.parse(e.sdp),
                            n = this;
                        return d(t, (function(e) {
                            "recvonly" != e.direction && "inactive" != e.direction && n._restoreSimulcast(e)
                        })), new RTCSessionDescription({
                            type: e.type,
                            sdp: i.write(t)
                        })
                    }, e.exports = c
                },
                4400: (e, t) => {
                    t.writeSsrcs = function(e, t) {
                        var n = [];
                        if (void 0 !== e && 0 !== Object.keys(e).length) {
                            Array.isArray(t) || (t = []);
                            for (var i = 0; i < t.length; i++) {
                                var s = t[i],
                                    r = e[s];
                                Object.keys(r).forEach((function(e) {
                                    n.push({
                                        id: s,
                                        attribute: e,
                                        value: r[e]
                                    })
                                }))
                            }
                            Object.keys(e).forEach((function(i) {
                                if (i = parseInt(i), !(t.indexOf(i) >= 0)) {
                                    var s = e[i];
                                    Object.keys(s).forEach((function(e) {
                                        n.push({
                                            id: i,
                                            attribute: e,
                                            value: s[e]
                                        })
                                    }))
                                }
                            }))
                        }
                        return n
                    }, t.parseSsrcs = function(e) {
                        var t = {};
                        return void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach((function(e) {
                            t[e.id] || (t[e.id] = {}), t[e.id][e.attribute] = e.value
                        })), t
                    }
                },
                8871: (e, t) => {
                    var n;
                    ! function() {
                        var i, s, r = {};

                        function o(e) {
                            var t = !1;
                            return function() {
                                if (t) throw new Error("Callback was already called.");
                                t = !0, e.apply(i, arguments)
                            }
                        }
                        null != (i = this) && (s = i.async), r.noConflict = function() {
                            return i.async = s, r
                        };
                        var a = Object.prototype.toString,
                            c = Array.isArray || function(e) {
                                return "[object Array]" === a.call(e)
                            },
                            d = function(e, t) {
                                if (e.forEach) return e.forEach(t);
                                for (var n = 0; n < e.length; n += 1) t(e[n], n, e)
                            },
                            l = function(e, t) {
                                if (e.map) return e.map(t);
                                var n = [];
                                return d(e, (function(e, i, s) {
                                    n.push(t(e, i, s))
                                })), n
                            },
                            h = function(e) {
                                if (Object.keys) return Object.keys(e);
                                var t = [];
                                for (var n in e) e.hasOwnProperty(n) && t.push(n);
                                return t
                            };
                        "undefined" != typeof process && process.nextTick ? (r.nextTick = process.nextTick, "undefined" != typeof setImmediate ? r.setImmediate = function(e) {
                            setImmediate(e)
                        } : r.setImmediate = r.nextTick) : "function" == typeof setImmediate ? (r.nextTick = function(e) {
                            setImmediate(e)
                        }, r.setImmediate = r.nextTick) : (r.nextTick = function(e) {
                            setTimeout(e, 0)
                        }, r.setImmediate = r.nextTick), r.each = function(e, t, n) {
                            if (n = n || function() {}, !e.length) return n();
                            var i = 0;

                            function s(t) {
                                t ? (n(t), n = function() {}) : (i += 1) >= e.length && n()
                            }
                            d(e, (function(e) {
                                t(e, o(s))
                            }))
                        }, r.forEach = r.each, r.eachSeries = function(e, t, n) {
                            if (n = n || function() {}, !e.length) return n();
                            var i = 0,
                                s = function() {
                                    t(e[i], (function(t) {
                                        t ? (n(t), n = function() {}) : (i += 1) >= e.length ? n() : s()
                                    }))
                                };
                            s()
                        }, r.forEachSeries = r.eachSeries, r.eachLimit = function(e, t, n, i) {
                            u(t).apply(null, [e, n, i])
                        }, r.forEachLimit = r.eachLimit;
                        var u = function(e) {
                                return function(t, n, i) {
                                    if (i = i || function() {}, !t.length || e <= 0) return i();
                                    var s = 0,
                                        r = 0,
                                        o = 0;
                                    ! function a() {
                                        if (s >= t.length) return i();
                                        for (; o < e && r < t.length;) o += 1, n(t[(r += 1) - 1], (function(e) {
                                            e ? (i(e), i = function() {}) : (o -= 1, (s += 1) >= t.length ? i() : a())
                                        }))
                                    }()
                                }
                            },
                            p = function(e) {
                                return function() {
                                    var t = Array.prototype.slice.call(arguments);
                                    return e.apply(null, [r.each].concat(t))
                                }
                            },
                            m = function(e) {
                                return function() {
                                    var t = Array.prototype.slice.call(arguments);
                                    return e.apply(null, [r.eachSeries].concat(t))
                                }
                            },
                            f = function(e, t, n, i) {
                                if (t = l(t, (function(e, t) {
                                        return {
                                            index: t,
                                            value: e
                                        }
                                    })), i) {
                                    var s = [];
                                    e(t, (function(e, t) {
                                        n(e.value, (function(n, i) {
                                            s[e.index] = i, t(n)
                                        }))
                                    }), (function(e) {
                                        i(e, s)
                                    }))
                                } else e(t, (function(e, t) {
                                    n(e.value, (function(e) {
                                        t(e)
                                    }))
                                }))
                            };
                        r.map = p(f), r.mapSeries = m(f), r.mapLimit = function(e, t, n, i) {
                            return g(t)(e, n, i)
                        };
                        var g = function(e) {
                            return function(e, t) {
                                return function() {
                                    var n = Array.prototype.slice.call(arguments);
                                    return t.apply(null, [u(e)].concat(n))
                                }
                            }(e, f)
                        };
                        r.reduce = function(e, t, n, i) {
                            r.eachSeries(e, (function(e, i) {
                                n(t, e, (function(e, n) {
                                    t = n, i(e)
                                }))
                            }), (function(e) {
                                i(e, t)
                            }))
                        }, r.inject = r.reduce, r.foldl = r.reduce, r.reduceRight = function(e, t, n, i) {
                            var s = l(e, (function(e) {
                                return e
                            })).reverse();
                            r.reduce(s, t, n, i)
                        }, r.foldr = r.reduceRight;
                        var _ = function(e, t, n, i) {
                            var s = [];
                            e(t = l(t, (function(e, t) {
                                return {
                                    index: t,
                                    value: e
                                }
                            })), (function(e, t) {
                                n(e.value, (function(n) {
                                    n && s.push(e), t()
                                }))
                            }), (function(e) {
                                i(l(s.sort((function(e, t) {
                                    return e.index - t.index
                                })), (function(e) {
                                    return e.value
                                })))
                            }))
                        };
                        r.filter = p(_), r.filterSeries = m(_), r.select = r.filter, r.selectSeries = r.filterSeries;
                        var v = function(e, t, n, i) {
                            var s = [];
                            e(t = l(t, (function(e, t) {
                                return {
                                    index: t,
                                    value: e
                                }
                            })), (function(e, t) {
                                n(e.value, (function(n) {
                                    n || s.push(e), t()
                                }))
                            }), (function(e) {
                                i(l(s.sort((function(e, t) {
                                    return e.index - t.index
                                })), (function(e) {
                                    return e.value
                                })))
                            }))
                        };
                        r.reject = p(v), r.rejectSeries = m(v);
                        var y = function(e, t, n, i) {
                            e(t, (function(e, t) {
                                n(e, (function(n) {
                                    n ? (i(e), i = function() {}) : t()
                                }))
                            }), (function(e) {
                                i()
                            }))
                        };
                        r.detect = p(y), r.detectSeries = m(y), r.some = function(e, t, n) {
                            r.each(e, (function(e, i) {
                                t(e, (function(e) {
                                    e && (n(!0), n = function() {}), i()
                                }))
                            }), (function(e) {
                                n(!1)
                            }))
                        }, r.any = r.some, r.every = function(e, t, n) {
                            r.each(e, (function(e, i) {
                                t(e, (function(e) {
                                    e || (n(!1), n = function() {}), i()
                                }))
                            }), (function(e) {
                                n(!0)
                            }))
                        }, r.all = r.every, r.sortBy = function(e, t, n) {
                            r.map(e, (function(e, n) {
                                t(e, (function(t, i) {
                                    t ? n(t) : n(null, {
                                        value: e,
                                        criteria: i
                                    })
                                }))
                            }), (function(e, t) {
                                if (e) return n(e);
                                n(null, l(t.sort((function(e, t) {
                                    var n = e.criteria,
                                        i = t.criteria;
                                    return n < i ? -1 : n > i ? 1 : 0
                                })), (function(e) {
                                    return e.value
                                })))
                            }))
                        }, r.auto = function(e, t) {
                            t = t || function() {};
                            var n = h(e),
                                i = n.length;
                            if (!i) return t();
                            var s = {},
                                o = [],
                                a = function(e) {
                                    o.unshift(e)
                                },
                                l = function() {
                                    i--, d(o.slice(0), (function(e) {
                                        e()
                                    }))
                                };
                            a((function() {
                                if (!i) {
                                    var e = t;
                                    t = function() {}, e(null, s)
                                }
                            })), d(n, (function(n) {
                                var i = c(e[n]) ? e[n] : [e[n]],
                                    u = function(e) {
                                        var i = Array.prototype.slice.call(arguments, 1);
                                        if (i.length <= 1 && (i = i[0]), e) {
                                            var o = {};
                                            d(h(s), (function(e) {
                                                o[e] = s[e]
                                            })), o[n] = i, t(e, o), t = function() {}
                                        } else s[n] = i, r.setImmediate(l)
                                    },
                                    p = i.slice(0, Math.abs(i.length - 1)) || [],
                                    m = function() {
                                        return t = function(e, t) {
                                            return e && s.hasOwnProperty(t)
                                        }, i = !0, ((e = p).reduce ? e.reduce(t, i) : (d(e, (function(e, n, s) {
                                            i = t(i, e)
                                        })), i)) && !s.hasOwnProperty(n);
                                        var e, t, i
                                    };
                                if (m()) i[i.length - 1](u, s);
                                else {
                                    var f = function() {
                                        m() && (function(e) {
                                            for (var t = 0; t < o.length; t += 1)
                                                if (o[t] === e) return void o.splice(t, 1)
                                        }(f), i[i.length - 1](u, s))
                                    };
                                    a(f)
                                }
                            }))
                        }, r.retry = function(e, t, n) {
                            var i = [];
                            "function" == typeof e && (n = t, t = e, e = 5), e = parseInt(e, 10) || 5;
                            var s = function(s, o) {
                                for (var a = function(e, t) {
                                        return function(n) {
                                            e((function(e, i) {
                                                n(!e || t, {
                                                    err: e,
                                                    result: i
                                                })
                                            }), o)
                                        }
                                    }; e;) i.push(a(t, !(e -= 1)));
                                r.series(i, (function(e, t) {
                                    t = t[t.length - 1], (s || n)(t.err, t.result)
                                }))
                            };
                            return n ? s() : s
                        }, r.waterfall = function(e, t) {
                            if (t = t || function() {}, !c(e)) {
                                var n = new Error("First argument to waterfall must be an array of functions");
                                return t(n)
                            }
                            if (!e.length) return t();
                            var i = function(e) {
                                return function(n) {
                                    if (n) t.apply(null, arguments), t = function() {};
                                    else {
                                        var s = Array.prototype.slice.call(arguments, 1),
                                            o = e.next();
                                        o ? s.push(i(o)) : s.push(t), r.setImmediate((function() {
                                            e.apply(null, s)
                                        }))
                                    }
                                }
                            };
                            i(r.iterator(e))()
                        };
                        var S = function(e, t, n) {
                            if (n = n || function() {}, c(t)) e.map(t, (function(e, t) {
                                e && e((function(e) {
                                    var n = Array.prototype.slice.call(arguments, 1);
                                    n.length <= 1 && (n = n[0]), t.call(null, e, n)
                                }))
                            }), n);
                            else {
                                var i = {};
                                e.each(h(t), (function(e, n) {
                                    t[e]((function(t) {
                                        var s = Array.prototype.slice.call(arguments, 1);
                                        s.length <= 1 && (s = s[0]), i[e] = s, n(t)
                                    }))
                                }), (function(e) {
                                    n(e, i)
                                }))
                            }
                        };
                        r.parallel = function(e, t) {
                            S({
                                map: r.map,
                                each: r.each
                            }, e, t)
                        }, r.parallelLimit = function(e, t, n) {
                            S({
                                map: g(t),
                                each: u(t)
                            }, e, n)
                        }, r.series = function(e, t) {
                            if (t = t || function() {}, c(e)) r.mapSeries(e, (function(e, t) {
                                e && e((function(e) {
                                    var n = Array.prototype.slice.call(arguments, 1);
                                    n.length <= 1 && (n = n[0]), t.call(null, e, n)
                                }))
                            }), t);
                            else {
                                var n = {};
                                r.eachSeries(h(e), (function(t, i) {
                                    e[t]((function(e) {
                                        var s = Array.prototype.slice.call(arguments, 1);
                                        s.length <= 1 && (s = s[0]), n[t] = s, i(e)
                                    }))
                                }), (function(e) {
                                    t(e, n)
                                }))
                            }
                        }, r.iterator = function(e) {
                            var t = function(n) {
                                var i = function() {
                                    return e.length && e[n].apply(null, arguments), i.next()
                                };
                                return i.next = function() {
                                    return n < e.length - 1 ? t(n + 1) : null
                                }, i
                            };
                            return t(0)
                        }, r.apply = function(e) {
                            var t = Array.prototype.slice.call(arguments, 1);
                            return function() {
                                return e.apply(null, t.concat(Array.prototype.slice.call(arguments)))
                            }
                        };
                        var E = function(e, t, n, i) {
                            var s = [];
                            e(t, (function(e, t) {
                                n(e, (function(e, n) {
                                    s = s.concat(n || []), t(e)
                                }))
                            }), (function(e) {
                                i(e, s)
                            }))
                        };
                        r.concat = p(E), r.concatSeries = m(E), r.whilst = function(e, t, n) {
                            e() ? t((function(i) {
                                if (i) return n(i);
                                r.whilst(e, t, n)
                            })) : n()
                        }, r.doWhilst = function(e, t, n) {
                            e((function(i) {
                                if (i) return n(i);
                                var s = Array.prototype.slice.call(arguments, 1);
                                t.apply(null, s) ? r.doWhilst(e, t, n) : n()
                            }))
                        }, r.until = function(e, t, n) {
                            e() ? n() : t((function(i) {
                                if (i) return n(i);
                                r.until(e, t, n)
                            }))
                        }, r.doUntil = function(e, t, n) {
                            e((function(i) {
                                if (i) return n(i);
                                var s = Array.prototype.slice.call(arguments, 1);
                                t.apply(null, s) ? n() : r.doUntil(e, t, n)
                            }))
                        }, r.queue = function(e, t) {
                            function n(e, t, n, i) {
                                if (e.started || (e.started = !0), c(t) || (t = [t]), 0 == t.length) return r.setImmediate((function() {
                                    e.drain && e.drain()
                                }));
                                d(t, (function(t) {
                                    var s = {
                                        data: t,
                                        callback: "function" == typeof i ? i : null
                                    };
                                    n ? e.tasks.unshift(s) : e.tasks.push(s), e.saturated && e.tasks.length === e.concurrency && e.saturated(), r.setImmediate(e.process)
                                }))
                            }
                            void 0 === t && (t = 1);
                            var i = 0,
                                s = {
                                    tasks: [],
                                    concurrency: t,
                                    saturated: null,
                                    empty: null,
                                    drain: null,
                                    started: !1,
                                    paused: !1,
                                    push: function(e, t) {
                                        n(s, e, !1, t)
                                    },
                                    kill: function() {
                                        s.drain = null, s.tasks = []
                                    },
                                    unshift: function(e, t) {
                                        n(s, e, !0, t)
                                    },
                                    process: function() {
                                        if (!s.paused && i < s.concurrency && s.tasks.length) {
                                            var t = s.tasks.shift();
                                            s.empty && 0 === s.tasks.length && s.empty(), i += 1;
                                            var n = o((function() {
                                                i -= 1, t.callback && t.callback.apply(t, arguments), s.drain && s.tasks.length + i === 0 && s.drain(), s.process()
                                            }));
                                            e(t.data, n)
                                        }
                                    },
                                    length: function() {
                                        return s.tasks.length
                                    },
                                    running: function() {
                                        return i
                                    },
                                    idle: function() {
                                        return s.tasks.length + i === 0
                                    },
                                    pause: function() {
                                        !0 !== s.paused && (s.paused = !0, s.process())
                                    },
                                    resume: function() {
                                        !1 !== s.paused && (s.paused = !1, s.process())
                                    }
                                };
                            return s
                        }, r.priorityQueue = function(e, t) {
                            function n(e, t) {
                                return e.priority - t.priority
                            }
                            var i = r.queue(e, t);
                            return i.push = function(e, t, s) {
                                ! function(e, t, i, s) {
                                    if (e.started || (e.started = !0), c(t) || (t = [t]), 0 == t.length) return r.setImmediate((function() {
                                        e.drain && e.drain()
                                    }));
                                    d(t, (function(t) {
                                        var o = {
                                            data: t,
                                            priority: i,
                                            callback: "function" == typeof s ? s : null
                                        };
                                        e.tasks.splice(function(e, t, n) {
                                            for (var i = -1, s = e.length - 1; i < s;) {
                                                var r = i + (s - i + 1 >>> 1);
                                                n(t, e[r]) >= 0 ? i = r : s = r - 1
                                            }
                                            return i
                                        }(e.tasks, o, n) + 1, 0, o), e.saturated && e.tasks.length === e.concurrency && e.saturated(), r.setImmediate(e.process)
                                    }))
                                }(i, e, t, s)
                            }, delete i.unshift, i
                        }, r.cargo = function(e, t) {
                            var n = !1,
                                i = [],
                                s = {
                                    tasks: i,
                                    payload: t,
                                    saturated: null,
                                    empty: null,
                                    drain: null,
                                    drained: !0,
                                    push: function(e, n) {
                                        c(e) || (e = [e]), d(e, (function(e) {
                                            i.push({
                                                data: e,
                                                callback: "function" == typeof n ? n : null
                                            }), s.drained = !1, s.saturated && i.length === t && s.saturated()
                                        })), r.setImmediate(s.process)
                                    },
                                    process: function r() {
                                        if (!n) {
                                            if (0 === i.length) return s.drain && !s.drained && s.drain(), void(s.drained = !0);
                                            var o = "number" == typeof t ? i.splice(0, t) : i.splice(0, i.length),
                                                a = l(o, (function(e) {
                                                    return e.data
                                                }));
                                            s.empty && s.empty(), n = !0, e(a, (function() {
                                                n = !1;
                                                var e = arguments;
                                                d(o, (function(t) {
                                                    t.callback && t.callback.apply(null, e)
                                                })), r()
                                            }))
                                        }
                                    },
                                    length: function() {
                                        return i.length
                                    },
                                    running: function() {
                                        return n
                                    }
                                };
                            return s
                        };
                        var b = function(e) {
                            return function(t) {
                                var n = Array.prototype.slice.call(arguments, 1);
                                t.apply(null, n.concat([function(t) {
                                    var n = Array.prototype.slice.call(arguments, 1);
                                    "undefined" != typeof console && (t ? console.error && console.error(t) : console[e] && d(n, (function(t) {
                                        console[e](t)
                                    })))
                                }]))
                            }
                        };
                        r.log = b("log"), r.dir = b("dir"), r.memoize = function(e, t) {
                            var n = {},
                                i = {};
                            t = t || function(e) {
                                return e
                            };
                            var s = function() {
                                var s = Array.prototype.slice.call(arguments),
                                    o = s.pop(),
                                    a = t.apply(null, s);
                                a in n ? r.nextTick((function() {
                                    o.apply(null, n[a])
                                })) : a in i ? i[a].push(o) : (i[a] = [o], e.apply(null, s.concat([function() {
                                    n[a] = arguments;
                                    var e = i[a];
                                    delete i[a];
                                    for (var t = 0, s = e.length; t < s; t++) e[t].apply(null, arguments)
                                }])))
                            };
                            return s.memo = n, s.unmemoized = e, s
                        }, r.unmemoize = function(e) {
                            return function() {
                                return (e.unmemoized || e).apply(null, arguments)
                            }
                        }, r.times = function(e, t, n) {
                            for (var i = [], s = 0; s < e; s++) i.push(s);
                            return r.map(i, t, n)
                        }, r.timesSeries = function(e, t, n) {
                            for (var i = [], s = 0; s < e; s++) i.push(s);
                            return r.mapSeries(i, t, n)
                        }, r.seq = function() {
                            var e = arguments;
                            return function() {
                                var t = this,
                                    n = Array.prototype.slice.call(arguments),
                                    i = n.pop();
                                r.reduce(e, n, (function(e, n, i) {
                                    n.apply(t, e.concat([function() {
                                        var e = arguments[0],
                                            t = Array.prototype.slice.call(arguments, 1);
                                        i(e, t)
                                    }]))
                                }), (function(e, n) {
                                    i.apply(t, [e].concat(n))
                                }))
                            }
                        }, r.compose = function() {
                            return r.seq.apply(null, Array.prototype.reverse.call(arguments))
                        };
                        var C = function(e, t) {
                            var n = function() {
                                var n = this,
                                    i = Array.prototype.slice.call(arguments),
                                    s = i.pop();
                                return e(t, (function(e, t) {
                                    e.apply(n, i.concat([t]))
                                }), s)
                            };
                            if (arguments.length > 2) {
                                var i = Array.prototype.slice.call(arguments, 2);
                                return n.apply(this, i)
                            }
                            return n
                        };
                        r.applyEach = p(C), r.applyEachSeries = m(C), r.forever = function(e, t) {
                            ! function n(i) {
                                if (i) {
                                    if (t) return t(i);
                                    throw i
                                }
                                e(n)
                            }()
                        }, e.exports ? e.exports = r : void 0 === (n = function() {
                            return r
                        }.apply(t, [])) || (e.exports = n)
                    }()
                },
                298: (e, t) => {
                    "use strict";
                    t.byteLength = function(e) {
                        var t = c(e),
                            n = t[0],
                            i = t[1];
                        return 3 * (n + i) / 4 - i
                    }, t.toByteArray = function(e) {
                        var t, n, r = c(e),
                            o = r[0],
                            a = r[1],
                            d = new s(function(e, t, n) {
                                return 3 * (t + n) / 4 - n
                            }(0, o, a)),
                            l = 0,
                            h = a > 0 ? o - 4 : o;
                        for (n = 0; n < h; n += 4) t = i[e.charCodeAt(n)] << 18 | i[e.charCodeAt(n + 1)] << 12 | i[e.charCodeAt(n + 2)] << 6 | i[e.charCodeAt(n + 3)], d[l++] = t >> 16 & 255, d[l++] = t >> 8 & 255, d[l++] = 255 & t;
                        return 2 === a && (t = i[e.charCodeAt(n)] << 2 | i[e.charCodeAt(n + 1)] >> 4, d[l++] = 255 & t), 1 === a && (t = i[e.charCodeAt(n)] << 10 | i[e.charCodeAt(n + 1)] << 4 | i[e.charCodeAt(n + 2)] >> 2, d[l++] = t >> 8 & 255, d[l++] = 255 & t), d
                    }, t.fromByteArray = function(e) {
                        for (var t, i = e.length, s = i % 3, r = [], o = 16383, a = 0, c = i - s; a < c; a += o) r.push(d(e, a, a + o > c ? c : a + o));
                        return 1 === s ? (t = e[i - 1], r.push(n[t >> 2] + n[t << 4 & 63] + "==")) : 2 === s && (t = (e[i - 2] << 8) + e[i - 1], r.push(n[t >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + "=")), r.join("")
                    };
                    for (var n = [], i = [], s = "undefined" != typeof Uint8Array ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, a = r.length; o < a; ++o) n[o] = r[o], i[r.charCodeAt(o)] = o;

                    function c(e) {
                        var t = e.length;
                        if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                        var n = e.indexOf("=");
                        return -1 === n && (n = t), [n, n === t ? 0 : 4 - n % 4]
                    }

                    function d(e, t, i) {
                        for (var s, r, o = [], a = t; a < i; a += 3) s = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), o.push(n[(r = s) >> 18 & 63] + n[r >> 12 & 63] + n[r >> 6 & 63] + n[63 & r]);
                        return o.join("")
                    }
                    i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63
                },
                6466: function(e) {
                    e.exports = function(e) {
                        var t = {};

                        function n(i) {
                            if (t[i]) return t[i].exports;
                            var s = t[i] = {
                                i,
                                l: !1,
                                exports: {}
                            };
                            return e[i].call(s.exports, s, s.exports, n), s.l = !0, s.exports
                        }
                        return n.m = e, n.c = t, n.d = function(e, t, i) {
                            n.o(e, t) || Object.defineProperty(e, t, {
                                enumerable: !0,
                                get: i
                            })
                        }, n.r = function(e) {
                            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                                value: "Module"
                            }), Object.defineProperty(e, "__esModule", {
                                value: !0
                            })
                        }, n.t = function(e, t) {
                            if (1 & t && (e = n(e)), 8 & t) return e;
                            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
                            var i = Object.create(null);
                            if (n.r(i), Object.defineProperty(i, "default", {
                                    enumerable: !0,
                                    value: e
                                }), 2 & t && "string" != typeof e)
                                for (var s in e) n.d(i, s, function(t) {
                                    return e[t]
                                }.bind(null, s));
                            return i
                        }, n.n = function(e) {
                            var t = e && e.__esModule ? function() {
                                return e.default
                            } : function() {
                                return e
                            };
                            return n.d(t, "a", t), t
                        }, n.o = function(e, t) {
                            return Object.prototype.hasOwnProperty.call(e, t)
                        }, n.p = "", n(n.s = 90)
                    }({
                        17: function(e, t, n) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var i = n(18),
                                s = function() {
                                    function e() {}
                                    return e.getFirstMatch = function(e, t) {
                                        var n = t.match(e);
                                        return n && n.length > 0 && n[1] || ""
                                    }, e.getSecondMatch = function(e, t) {
                                        var n = t.match(e);
                                        return n && n.length > 1 && n[2] || ""
                                    }, e.matchAndReturnConst = function(e, t, n) {
                                        if (e.test(t)) return n
                                    }, e.getWindowsVersionName = function(e) {
                                        switch (e) {
                                            case "NT":
                                                return "NT";
                                            case "XP":
                                            case "NT 5.1":
                                                return "XP";
                                            case "NT 5.0":
                                                return "2000";
                                            case "NT 5.2":
                                                return "2003";
                                            case "NT 6.0":
                                                return "Vista";
                                            case "NT 6.1":
                                                return "7";
                                            case "NT 6.2":
                                                return "8";
                                            case "NT 6.3":
                                                return "8.1";
                                            case "NT 10.0":
                                                return "10";
                                            default:
                                                return
                                        }
                                    }, e.getMacOSVersionName = function(e) {
                                        var t = e.split(".").splice(0, 2).map((function(e) {
                                            return parseInt(e, 10) || 0
                                        }));
                                        if (t.push(0), 10 === t[0]) switch (t[1]) {
                                            case 5:
                                                return "Leopard";
                                            case 6:
                                                return "Snow Leopard";
                                            case 7:
                                                return "Lion";
                                            case 8:
                                                return "Mountain Lion";
                                            case 9:
                                                return "Mavericks";
                                            case 10:
                                                return "Yosemite";
                                            case 11:
                                                return "El Capitan";
                                            case 12:
                                                return "Sierra";
                                            case 13:
                                                return "High Sierra";
                                            case 14:
                                                return "Mojave";
                                            case 15:
                                                return "Catalina";
                                            default:
                                                return
                                        }
                                    }, e.getAndroidVersionName = function(e) {
                                        var t = e.split(".").splice(0, 2).map((function(e) {
                                            return parseInt(e, 10) || 0
                                        }));
                                        if (t.push(0), !(1 === t[0] && t[1] < 5)) return 1 === t[0] && t[1] < 6 ? "Cupcake" : 1 === t[0] && t[1] >= 6 ? "Donut" : 2 === t[0] && t[1] < 2 ? "Eclair" : 2 === t[0] && 2 === t[1] ? "Froyo" : 2 === t[0] && t[1] > 2 ? "Gingerbread" : 3 === t[0] ? "Honeycomb" : 4 === t[0] && t[1] < 1 ? "Ice Cream Sandwich" : 4 === t[0] && t[1] < 4 ? "Jelly Bean" : 4 === t[0] && t[1] >= 4 ? "KitKat" : 5 === t[0] ? "Lollipop" : 6 === t[0] ? "Marshmallow" : 7 === t[0] ? "Nougat" : 8 === t[0] ? "Oreo" : 9 === t[0] ? "Pie" : void 0
                                    }, e.getVersionPrecision = function(e) {
                                        return e.split(".").length
                                    }, e.compareVersions = function(t, n, i) {
                                        void 0 === i && (i = !1);
                                        var s = e.getVersionPrecision(t),
                                            r = e.getVersionPrecision(n),
                                            o = Math.max(s, r),
                                            a = 0,
                                            c = e.map([t, n], (function(t) {
                                                var n = o - e.getVersionPrecision(t),
                                                    i = t + new Array(n + 1).join(".0");
                                                return e.map(i.split("."), (function(e) {
                                                    return new Array(20 - e.length).join("0") + e
                                                })).reverse()
                                            }));
                                        for (i && (a = o - Math.min(s, r)), o -= 1; o >= a;) {
                                            if (c[0][o] > c[1][o]) return 1;
                                            if (c[0][o] === c[1][o]) {
                                                if (o === a) return 0;
                                                o -= 1
                                            } else if (c[0][o] < c[1][o]) return -1
                                        }
                                    }, e.map = function(e, t) {
                                        var n, i = [];
                                        if (Array.prototype.map) return Array.prototype.map.call(e, t);
                                        for (n = 0; n < e.length; n += 1) i.push(t(e[n]));
                                        return i
                                    }, e.getBrowserAlias = function(e) {
                                        return i.BROWSER_ALIASES_MAP[e]
                                    }, e.getBrowserTypeByAlias = function(e) {
                                        return i.BROWSER_MAP[e] || ""
                                    }, e
                                }();
                            t.default = s, e.exports = t.default
                        },
                        18: function(e, t, n) {
                            "use strict";
                            t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0, t.BROWSER_ALIASES_MAP = {
                                "Amazon Silk": "amazon_silk",
                                "Android Browser": "android",
                                Bada: "bada",
                                BlackBerry: "blackberry",
                                Chrome: "chrome",
                                Chromium: "chromium",
                                Epiphany: "epiphany",
                                Firefox: "firefox",
                                Focus: "focus",
                                Generic: "generic",
                                "Google Search": "google_search",
                                Googlebot: "googlebot",
                                "Internet Explorer": "ie",
                                "K-Meleon": "k_meleon",
                                Maxthon: "maxthon",
                                "Microsoft Edge": "edge",
                                "MZ Browser": "mz",
                                "NAVER Whale Browser": "naver",
                                Opera: "opera",
                                "Opera Coast": "opera_coast",
                                PhantomJS: "phantomjs",
                                Puffin: "puffin",
                                QupZilla: "qupzilla",
                                QQ: "qq",
                                QQLite: "qqlite",
                                Safari: "safari",
                                Sailfish: "sailfish",
                                "Samsung Internet for Android": "samsung_internet",
                                SeaMonkey: "seamonkey",
                                Sleipnir: "sleipnir",
                                Swing: "swing",
                                Tizen: "tizen",
                                "UC Browser": "uc",
                                Vivaldi: "vivaldi",
                                "WebOS Browser": "webos",
                                WeChat: "wechat",
                                "Yandex Browser": "yandex",
                                Roku: "roku"
                            }, t.BROWSER_MAP = {
                                amazon_silk: "Amazon Silk",
                                android: "Android Browser",
                                bada: "Bada",
                                blackberry: "BlackBerry",
                                chrome: "Chrome",
                                chromium: "Chromium",
                                epiphany: "Epiphany",
                                firefox: "Firefox",
                                focus: "Focus",
                                generic: "Generic",
                                googlebot: "Googlebot",
                                google_search: "Google Search",
                                ie: "Internet Explorer",
                                k_meleon: "K-Meleon",
                                maxthon: "Maxthon",
                                edge: "Microsoft Edge",
                                mz: "MZ Browser",
                                naver: "NAVER Whale Browser",
                                opera: "Opera",
                                opera_coast: "Opera Coast",
                                phantomjs: "PhantomJS",
                                puffin: "Puffin",
                                qupzilla: "QupZilla",
                                qq: "QQ Browser",
                                qqlite: "QQ Browser Lite",
                                safari: "Safari",
                                sailfish: "Sailfish",
                                samsung_internet: "Samsung Internet for Android",
                                seamonkey: "SeaMonkey",
                                sleipnir: "Sleipnir",
                                swing: "Swing",
                                tizen: "Tizen",
                                uc: "UC Browser",
                                vivaldi: "Vivaldi",
                                webos: "WebOS Browser",
                                wechat: "WeChat",
                                yandex: "Yandex Browser"
                            }, t.PLATFORMS_MAP = {
                                tablet: "tablet",
                                mobile: "mobile",
                                desktop: "desktop",
                                tv: "tv"
                            }, t.OS_MAP = {
                                WindowsPhone: "Windows Phone",
                                Windows: "Windows",
                                MacOS: "macOS",
                                iOS: "iOS",
                                Android: "Android",
                                WebOS: "WebOS",
                                BlackBerry: "BlackBerry",
                                Bada: "Bada",
                                Tizen: "Tizen",
                                Linux: "Linux",
                                ChromeOS: "Chrome OS",
                                PlayStation4: "PlayStation 4",
                                Roku: "Roku"
                            }, t.ENGINE_MAP = {
                                EdgeHTML: "EdgeHTML",
                                Blink: "Blink",
                                Trident: "Trident",
                                Presto: "Presto",
                                Gecko: "Gecko",
                                WebKit: "WebKit"
                            }
                        },
                        90: function(e, t, n) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var i, s = (i = n(91)) && i.__esModule ? i : {
                                    default: i
                                },
                                r = n(18);

                            function o(e, t) {
                                for (var n = 0; n < t.length; n++) {
                                    var i = t[n];
                                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                                }
                            }
                            var a = function() {
                                function e() {}
                                var t, n;
                                return e.getParser = function(e, t) {
                                    if (void 0 === t && (t = !1), "string" != typeof e) throw new Error("UserAgent should be a string");
                                    return new s.default(e, t)
                                }, e.parse = function(e) {
                                    return new s.default(e).getResult()
                                }, t = e, n = [{
                                    key: "BROWSER_MAP",
                                    get: function() {
                                        return r.BROWSER_MAP
                                    }
                                }, {
                                    key: "ENGINE_MAP",
                                    get: function() {
                                        return r.ENGINE_MAP
                                    }
                                }, {
                                    key: "OS_MAP",
                                    get: function() {
                                        return r.OS_MAP
                                    }
                                }, {
                                    key: "PLATFORMS_MAP",
                                    get: function() {
                                        return r.PLATFORMS_MAP
                                    }
                                }], null && o(t.prototype, null), n && o(t, n), e
                            }();
                            t.default = a, e.exports = t.default
                        },
                        91: function(e, t, n) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var i = c(n(92)),
                                s = c(n(93)),
                                r = c(n(94)),
                                o = c(n(95)),
                                a = c(n(17));

                            function c(e) {
                                return e && e.__esModule ? e : {
                                    default: e
                                }
                            }
                            var d = function() {
                                function e(e, t) {
                                    if (void 0 === t && (t = !1), null == e || "" === e) throw new Error("UserAgent parameter can't be empty");
                                    this._ua = e, this.parsedResult = {}, !0 !== t && this.parse()
                                }
                                var t = e.prototype;
                                return t.getUA = function() {
                                    return this._ua
                                }, t.test = function(e) {
                                    return e.test(this._ua)
                                }, t.parseBrowser = function() {
                                    var e = this;
                                    this.parsedResult.browser = {};
                                    var t = i.default.find((function(t) {
                                        if ("function" == typeof t.test) return t.test(e);
                                        if (t.test instanceof Array) return t.test.some((function(t) {
                                            return e.test(t)
                                        }));
                                        throw new Error("Browser's test function is not valid")
                                    }));
                                    return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser
                                }, t.getBrowser = function() {
                                    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser()
                                }, t.getBrowserName = function(e) {
                                    return e ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || ""
                                }, t.getBrowserVersion = function() {
                                    return this.getBrowser().version
                                }, t.getOS = function() {
                                    return this.parsedResult.os ? this.parsedResult.os : this.parseOS()
                                }, t.parseOS = function() {
                                    var e = this;
                                    this.parsedResult.os = {};
                                    var t = s.default.find((function(t) {
                                        if ("function" == typeof t.test) return t.test(e);
                                        if (t.test instanceof Array) return t.test.some((function(t) {
                                            return e.test(t)
                                        }));
                                        throw new Error("Browser's test function is not valid")
                                    }));
                                    return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os
                                }, t.getOSName = function(e) {
                                    var t = this.getOS().name;
                                    return e ? String(t).toLowerCase() || "" : t || ""
                                }, t.getOSVersion = function() {
                                    return this.getOS().version
                                }, t.getPlatform = function() {
                                    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform()
                                }, t.getPlatformType = function(e) {
                                    void 0 === e && (e = !1);
                                    var t = this.getPlatform().type;
                                    return e ? String(t).toLowerCase() || "" : t || ""
                                }, t.parsePlatform = function() {
                                    var e = this;
                                    this.parsedResult.platform = {};
                                    var t = r.default.find((function(t) {
                                        if ("function" == typeof t.test) return t.test(e);
                                        if (t.test instanceof Array) return t.test.some((function(t) {
                                            return e.test(t)
                                        }));
                                        throw new Error("Browser's test function is not valid")
                                    }));
                                    return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform
                                }, t.getEngine = function() {
                                    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine()
                                }, t.getEngineName = function(e) {
                                    return e ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || ""
                                }, t.parseEngine = function() {
                                    var e = this;
                                    this.parsedResult.engine = {};
                                    var t = o.default.find((function(t) {
                                        if ("function" == typeof t.test) return t.test(e);
                                        if (t.test instanceof Array) return t.test.some((function(t) {
                                            return e.test(t)
                                        }));
                                        throw new Error("Browser's test function is not valid")
                                    }));
                                    return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine
                                }, t.parse = function() {
                                    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this
                                }, t.getResult = function() {
                                    return Object.assign({}, this.parsedResult)
                                }, t.satisfies = function(e) {
                                    var t = this,
                                        n = {},
                                        i = 0,
                                        s = {},
                                        r = 0;
                                    if (Object.keys(e).forEach((function(t) {
                                            var o = e[t];
                                            "string" == typeof o ? (s[t] = o, r += 1) : "object" == typeof o && (n[t] = o, i += 1)
                                        })), i > 0) {
                                        var o = Object.keys(n),
                                            a = o.find((function(e) {
                                                return t.isOS(e)
                                            }));
                                        if (a) {
                                            var c = this.satisfies(n[a]);
                                            if (void 0 !== c) return c
                                        }
                                        var d = o.find((function(e) {
                                            return t.isPlatform(e)
                                        }));
                                        if (d) {
                                            var l = this.satisfies(n[d]);
                                            if (void 0 !== l) return l
                                        }
                                    }
                                    if (r > 0) {
                                        var h = Object.keys(s).find((function(e) {
                                            return t.isBrowser(e, !0)
                                        }));
                                        if (void 0 !== h) return this.compareVersion(s[h])
                                    }
                                }, t.isBrowser = function(e, t) {
                                    void 0 === t && (t = !1);
                                    var n = this.getBrowserName().toLowerCase(),
                                        i = e.toLowerCase(),
                                        s = a.default.getBrowserTypeByAlias(i);
                                    return t && s && (i = s.toLowerCase()), i === n
                                }, t.compareVersion = function(e) {
                                    var t = [0],
                                        n = e,
                                        i = !1,
                                        s = this.getBrowserVersion();
                                    if ("string" == typeof s) return ">" === e[0] || "<" === e[0] ? (n = e.substr(1), "=" === e[1] ? (i = !0, n = e.substr(2)) : t = [], ">" === e[0] ? t.push(1) : t.push(-1)) : "=" === e[0] ? n = e.substr(1) : "~" === e[0] && (i = !0, n = e.substr(1)), t.indexOf(a.default.compareVersions(s, n, i)) > -1
                                }, t.isOS = function(e) {
                                    return this.getOSName(!0) === String(e).toLowerCase()
                                }, t.isPlatform = function(e) {
                                    return this.getPlatformType(!0) === String(e).toLowerCase()
                                }, t.isEngine = function(e) {
                                    return this.getEngineName(!0) === String(e).toLowerCase()
                                }, t.is = function(e) {
                                    return this.isBrowser(e) || this.isOS(e) || this.isPlatform(e)
                                }, t.some = function(e) {
                                    var t = this;
                                    return void 0 === e && (e = []), e.some((function(e) {
                                        return t.is(e)
                                    }))
                                }, e
                            }();
                            t.default = d, e.exports = t.default
                        },
                        92: function(e, t, n) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var i, s = (i = n(17)) && i.__esModule ? i : {
                                    default: i
                                },
                                r = /version\/(\d+(\.?_?\d+)+)/i,
                                o = [{
                                    test: [/googlebot/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Googlebot"
                                            },
                                            n = s.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/opera/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Opera"
                                            },
                                            n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/opr\/|opios/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Opera"
                                            },
                                            n = s.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/SamsungBrowser/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Samsung Internet for Android"
                                            },
                                            n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/Whale/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "NAVER Whale Browser"
                                            },
                                            n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/MZBrowser/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "MZ Browser"
                                            },
                                            n = s.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/focus/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Focus"
                                            },
                                            n = s.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/swing/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Swing"
                                            },
                                            n = s.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/coast/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Opera Coast"
                                            },
                                            n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/yabrowser/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Yandex Browser"
                                            },
                                            n = s.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/ucbrowser/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "UC Browser"
                                            },
                                            n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/Maxthon|mxios/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Maxthon"
                                            },
                                            n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/epiphany/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Epiphany"
                                            },
                                            n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/puffin/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Puffin"
                                            },
                                            n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/sleipnir/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Sleipnir"
                                            },
                                            n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/k-meleon/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "K-Meleon"
                                            },
                                            n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/micromessenger/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "WeChat"
                                            },
                                            n = s.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/qqbrowser/i],
                                    describe: function(e) {
                                        var t = {
                                                name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
                                            },
                                            n = s.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/msie|trident/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Internet Explorer"
                                            },
                                            n = s.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/\sedg\//i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Microsoft Edge"
                                            },
                                            n = s.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/edg([ea]|ios)/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Microsoft Edge"
                                            },
                                            n = s.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/vivaldi/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Vivaldi"
                                            },
                                            n = s.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/seamonkey/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "SeaMonkey"
                                            },
                                            n = s.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/sailfish/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Sailfish"
                                            },
                                            n = s.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/silk/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Amazon Silk"
                                            },
                                            n = s.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/phantom/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "PhantomJS"
                                            },
                                            n = s.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/slimerjs/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "SlimerJS"
                                            },
                                            n = s.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "BlackBerry"
                                            },
                                            n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/(web|hpw)[o0]s/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "WebOS Browser"
                                            },
                                            n = s.default.getFirstMatch(r, e) || s.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/bada/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Bada"
                                            },
                                            n = s.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/tizen/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Tizen"
                                            },
                                            n = s.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/qupzilla/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "QupZilla"
                                            },
                                            n = s.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/firefox|iceweasel|fxios/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Firefox"
                                            },
                                            n = s.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/chromium/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Chromium"
                                            },
                                            n = s.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/chrome|crios|crmo/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Chrome"
                                            },
                                            n = s.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/GSA/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Google Search"
                                            },
                                            n = s.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: function(e) {
                                        var t = !e.test(/like android/i),
                                            n = e.test(/android/i);
                                        return t && n
                                    },
                                    describe: function(e) {
                                        var t = {
                                                name: "Android Browser"
                                            },
                                            n = s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/playstation 4/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "PlayStation 4"
                                            },
                                            n = s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/safari|applewebkit/i],
                                    describe: function(e) {
                                        var t = {
                                                name: "Safari"
                                            },
                                            n = s.default.getFirstMatch(r, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/.*/i],
                                    describe: function(e) {
                                        var t = -1 !== e.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
                                        return {
                                            name: s.default.getFirstMatch(t, e),
                                            version: s.default.getSecondMatch(t, e)
                                        }
                                    }
                                }];
                            t.default = o, e.exports = t.default
                        },
                        93: function(e, t, n) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var i, s = (i = n(17)) && i.__esModule ? i : {
                                    default: i
                                },
                                r = n(18),
                                o = [{
                                    test: [/Roku\/DVP/],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
                                        return {
                                            name: r.OS_MAP.Roku,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: [/windows phone/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
                                        return {
                                            name: r.OS_MAP.WindowsPhone,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: [/windows/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e),
                                            n = s.default.getWindowsVersionName(t);
                                        return {
                                            name: r.OS_MAP.Windows,
                                            version: t,
                                            versionName: n
                                        }
                                    }
                                }, {
                                    test: [/macintosh/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."),
                                            n = s.default.getMacOSVersionName(t),
                                            i = {
                                                name: r.OS_MAP.MacOS,
                                                version: t
                                            };
                                        return n && (i.versionName = n), i
                                    }
                                }, {
                                    test: [/(ipod|iphone|ipad)/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
                                        return {
                                            name: r.OS_MAP.iOS,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        var t = !e.test(/like android/i),
                                            n = e.test(/android/i);
                                        return t && n
                                    },
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e),
                                            n = s.default.getAndroidVersionName(t),
                                            i = {
                                                name: r.OS_MAP.Android,
                                                version: t
                                            };
                                        return n && (i.versionName = n), i
                                    }
                                }, {
                                    test: [/(web|hpw)[o0]s/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e),
                                            n = {
                                                name: r.OS_MAP.WebOS
                                            };
                                        return t && t.length && (n.version = t), n
                                    }
                                }, {
                                    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || s.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || s.default.getFirstMatch(/\bbb(\d+)/i, e);
                                        return {
                                            name: r.OS_MAP.BlackBerry,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: [/bada/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
                                        return {
                                            name: r.OS_MAP.Bada,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: [/tizen/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
                                        return {
                                            name: r.OS_MAP.Tizen,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: [/linux/i],
                                    describe: function() {
                                        return {
                                            name: r.OS_MAP.Linux
                                        }
                                    }
                                }, {
                                    test: [/CrOS/],
                                    describe: function() {
                                        return {
                                            name: r.OS_MAP.ChromeOS
                                        }
                                    }
                                }, {
                                    test: [/PlayStation 4/],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
                                        return {
                                            name: r.OS_MAP.PlayStation4,
                                            version: t
                                        }
                                    }
                                }];
                            t.default = o, e.exports = t.default
                        },
                        94: function(e, t, n) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var i, s = (i = n(17)) && i.__esModule ? i : {
                                    default: i
                                },
                                r = n(18),
                                o = [{
                                    test: [/googlebot/i],
                                    describe: function() {
                                        return {
                                            type: "bot",
                                            vendor: "Google"
                                        }
                                    }
                                }, {
                                    test: [/huawei/i],
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/(can-l01)/i, e) && "Nova",
                                            n = {
                                                type: r.PLATFORMS_MAP.mobile,
                                                vendor: "Huawei"
                                            };
                                        return t && (n.model = t), n
                                    }
                                }, {
                                    test: [/nexus\s*(?:7|8|9|10).*/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tablet,
                                            vendor: "Nexus"
                                        }
                                    }
                                }, {
                                    test: [/ipad/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tablet,
                                            vendor: "Apple",
                                            model: "iPad"
                                        }
                                    }
                                }, {
                                    test: [/kftt build/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tablet,
                                            vendor: "Amazon",
                                            model: "Kindle Fire HD 7"
                                        }
                                    }
                                }, {
                                    test: [/silk/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tablet,
                                            vendor: "Amazon"
                                        }
                                    }
                                }, {
                                    test: [/tablet(?! pc)/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tablet
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        var t = e.test(/ipod|iphone/i),
                                            n = e.test(/like (ipod|iphone)/i);
                                        return t && !n
                                    },
                                    describe: function(e) {
                                        var t = s.default.getFirstMatch(/(ipod|iphone)/i, e);
                                        return {
                                            type: r.PLATFORMS_MAP.mobile,
                                            vendor: "Apple",
                                            model: t
                                        }
                                    }
                                }, {
                                    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.mobile,
                                            vendor: "Nexus"
                                        }
                                    }
                                }, {
                                    test: [/[^-]mobi/i],
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.mobile
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "blackberry" === e.getBrowserName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.mobile,
                                            vendor: "BlackBerry"
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "bada" === e.getBrowserName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.mobile
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "windows phone" === e.getBrowserName()
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.mobile,
                                            vendor: "Microsoft"
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        var t = Number(String(e.getOSVersion()).split(".")[0]);
                                        return "android" === e.getOSName(!0) && t >= 3
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tablet
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "android" === e.getOSName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.mobile
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "macos" === e.getOSName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.desktop,
                                            vendor: "Apple"
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "windows" === e.getOSName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.desktop
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "linux" === e.getOSName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.desktop
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "playstation 4" === e.getOSName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tv
                                        }
                                    }
                                }, {
                                    test: function(e) {
                                        return "roku" === e.getOSName(!0)
                                    },
                                    describe: function() {
                                        return {
                                            type: r.PLATFORMS_MAP.tv
                                        }
                                    }
                                }];
                            t.default = o, e.exports = t.default
                        },
                        95: function(e, t, n) {
                            "use strict";
                            t.__esModule = !0, t.default = void 0;
                            var i, s = (i = n(17)) && i.__esModule ? i : {
                                    default: i
                                },
                                r = n(18),
                                o = [{
                                    test: function(e) {
                                        return "microsoft edge" === e.getBrowserName(!0)
                                    },
                                    describe: function(e) {
                                        if (/\sedg\//i.test(e)) return {
                                            name: r.ENGINE_MAP.Blink
                                        };
                                        var t = s.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
                                        return {
                                            name: r.ENGINE_MAP.EdgeHTML,
                                            version: t
                                        }
                                    }
                                }, {
                                    test: [/trident/i],
                                    describe: function(e) {
                                        var t = {
                                                name: r.ENGINE_MAP.Trident
                                            },
                                            n = s.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: function(e) {
                                        return e.test(/presto/i)
                                    },
                                    describe: function(e) {
                                        var t = {
                                                name: r.ENGINE_MAP.Presto
                                            },
                                            n = s.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: function(e) {
                                        var t = e.test(/gecko/i),
                                            n = e.test(/like gecko/i);
                                        return t && !n
                                    },
                                    describe: function(e) {
                                        var t = {
                                                name: r.ENGINE_MAP.Gecko
                                            },
                                            n = s.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }, {
                                    test: [/(apple)?webkit\/537\.36/i],
                                    describe: function() {
                                        return {
                                            name: r.ENGINE_MAP.Blink
                                        }
                                    }
                                }, {
                                    test: [/(apple)?webkit/i],
                                    describe: function(e) {
                                        var t = {
                                                name: r.ENGINE_MAP.WebKit
                                            },
                                            n = s.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
                                        return n && (t.version = n), t
                                    }
                                }];
                            t.default = o, e.exports = t.default
                        }
                    })
                },
                6943: function(e, t) {
                    var n, i;
                    this || window, void 0 === (i = "function" == typeof(n = function() {
                        var e = /^(interactive|loaded|complete)$/,
                            t = window.location ? window.location.href : null,
                            n = t && t.replace(/#.*$/, "").replace(/\?.*$/, "") || null,
                            i = document.getElementsByTagName("script"),
                            s = "readyState" in (i[0] || document.createElement("script")),
                            r = !window.opera || "[object Opera]" !== window.opera.toString(),
                            o = "currentScript" in document;
                        "stackTraceLimit" in Error && Error.stackTraceLimit !== 1 / 0 && (Error.stackTraceLimit, Error.stackTraceLimit = 1 / 0);
                        var a = !1,
                            c = !1;

                        function d(e, t) {
                            var n, i = null,
                                s = "number" == typeof t;
                            return t = s ? Math.round(t) : 0, "string" == typeof e && e && (s ? n = e.match(/(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/) : (n = e.match(/^(?:|[^:@]*@|.+\)@(?=data:text\/javascript|blob|http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)) && n[1] || (n = e.match(/\)@(data:text\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/)), n && n[1] && (i = t > 0 ? d(e.slice(e.indexOf(n[0]) + n[0].length), t - 1) : n[1])), i
                        }

                        function l() {
                            if (0 === i.length) return null;
                            var t, h, u, p, m, f = [],
                                g = l.skipStackDepth || 1;
                            for (t = 0; t < i.length; t++) r && s ? e.test(i[t].readyState) && f.push(i[t]) : f.push(i[t]);
                            if (h = new Error, a && (u = h.stack), !u && c) try {
                                throw h
                            } catch (e) {
                                u = e.stack
                            }
                            if (u && !(m = function(e, t) {
                                    var n, s = null;
                                    if (t = t || i, "string" == typeof e && e)
                                        for (n = t.length; n--;)
                                            if (t[n].src === e) {
                                                s = t[n];
                                                break
                                            } return s
                                }(p = d(u, g), f)) && n && p === n && (m = function(e) {
                                    var t, n, s = null;
                                    for (t = 0, n = (e = e || i).length; t < n; t++)
                                        if (!e[t].hasAttribute("src")) {
                                            if (s) {
                                                s = null;
                                                break
                                            }
                                            s = e[t]
                                        } return s
                                }(f)), m || 1 === f.length && (m = f[0]), m || o && (m = document.currentScript), !m && r && s)
                                for (t = f.length; t--;)
                                    if ("interactive" === f[t].readyState) {
                                        m = f[t];
                                        break
                                    } return m || (m = f[f.length - 1] || null), m
                        }(function() {
                            try {
                                var e = new Error;
                                throw a = "string" == typeof e.stack && !!e.stack, e
                            } catch (e) {
                                c = "string" == typeof e.stack && !!e.stack
                            }
                        })(), l.skipStackDepth = 1;
                        var h = l;
                        return h.near = l, h.far = function() {
                            return null
                        }, h.origin = function() {
                            return null
                        }, h
                    }) ? n.apply(t, []) : n) || (e.exports = i)
                },
                7853: e => {
                    "use strict";
                    var t, n = "object" == typeof Reflect ? Reflect : null,
                        i = n && "function" == typeof n.apply ? n.apply : function(e, t, n) {
                            return Function.prototype.apply.call(e, t, n)
                        };
                    t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e) {
                        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
                    } : function(e) {
                        return Object.getOwnPropertyNames(e)
                    };
                    var s = Number.isNaN || function(e) {
                        return e != e
                    };

                    function r() {
                        r.init.call(this)
                    }
                    e.exports = r, e.exports.once = function(e, t) {
                        return new Promise((function(n, i) {
                            function s(n) {
                                e.removeListener(t, r), i(n)
                            }

                            function r() {
                                "function" == typeof e.removeListener && e.removeListener("error", s), n([].slice.call(arguments))
                            }
                            f(e, t, r, {
                                once: !0
                            }), "error" !== t && function(e, t, n) {
                                "function" == typeof e.on && f(e, "error", t, {
                                    once: !0
                                })
                            }(e, s)
                        }))
                    }, r.EventEmitter = r, r.prototype._events = void 0, r.prototype._eventsCount = 0, r.prototype._maxListeners = void 0;
                    var o = 10;

                    function a(e) {
                        if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
                    }

                    function c(e) {
                        return void 0 === e._maxListeners ? r.defaultMaxListeners : e._maxListeners
                    }

                    function d(e, t, n, i) {
                        var s, r, o, d;
                        if (a(n), void 0 === (r = e._events) ? (r = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== r.newListener && (e.emit("newListener", t, n.listener ? n.listener : n), r = e._events), o = r[t]), void 0 === o) o = r[t] = n, ++e._eventsCount;
                        else if ("function" == typeof o ? o = r[t] = i ? [n, o] : [o, n] : i ? o.unshift(n) : o.push(n), (s = c(e)) > 0 && o.length > s && !o.warned) {
                            o.warned = !0;
                            var l = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                            l.name = "MaxListenersExceededWarning", l.emitter = e, l.type = t, l.count = o.length, d = l, console && console.warn && console.warn(d)
                        }
                        return e
                    }

                    function l() {
                        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
                    }

                    function h(e, t, n) {
                        var i = {
                                fired: !1,
                                wrapFn: void 0,
                                target: e,
                                type: t,
                                listener: n
                            },
                            s = l.bind(i);
                        return s.listener = n, i.wrapFn = s, s
                    }

                    function u(e, t, n) {
                        var i = e._events;
                        if (void 0 === i) return [];
                        var s = i[t];
                        return void 0 === s ? [] : "function" == typeof s ? n ? [s.listener || s] : [s] : n ? function(e) {
                            for (var t = new Array(e.length), n = 0; n < t.length; ++n) t[n] = e[n].listener || e[n];
                            return t
                        }(s) : m(s, s.length)
                    }

                    function p(e) {
                        var t = this._events;
                        if (void 0 !== t) {
                            var n = t[e];
                            if ("function" == typeof n) return 1;
                            if (void 0 !== n) return n.length
                        }
                        return 0
                    }

                    function m(e, t) {
                        for (var n = new Array(t), i = 0; i < t; ++i) n[i] = e[i];
                        return n
                    }

                    function f(e, t, n, i) {
                        if ("function" == typeof e.on) i.once ? e.once(t, n) : e.on(t, n);
                        else {
                            if ("function" != typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
                            e.addEventListener(t, (function s(r) {
                                i.once && e.removeEventListener(t, s), n(r)
                            }))
                        }
                    }
                    Object.defineProperty(r, "defaultMaxListeners", {
                        enumerable: !0,
                        get: function() {
                            return o
                        },
                        set: function(e) {
                            if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
                            o = e
                        }
                    }), r.init = function() {
                        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
                    }, r.prototype.setMaxListeners = function(e) {
                        if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
                        return this._maxListeners = e, this
                    }, r.prototype.getMaxListeners = function() {
                        return c(this)
                    }, r.prototype.emit = function(e) {
                        for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
                        var s = "error" === e,
                            r = this._events;
                        if (void 0 !== r) s = s && void 0 === r.error;
                        else if (!s) return !1;
                        if (s) {
                            var o;
                            if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
                            var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
                            throw a.context = o, a
                        }
                        var c = r[e];
                        if (void 0 === c) return !1;
                        if ("function" == typeof c) i(c, this, t);
                        else {
                            var d = c.length,
                                l = m(c, d);
                            for (n = 0; n < d; ++n) i(l[n], this, t)
                        }
                        return !0
                    }, r.prototype.addListener = function(e, t) {
                        return d(this, e, t, !1)
                    }, r.prototype.on = r.prototype.addListener, r.prototype.prependListener = function(e, t) {
                        return d(this, e, t, !0)
                    }, r.prototype.once = function(e, t) {
                        return a(t), this.on(e, h(this, e, t)), this
                    }, r.prototype.prependOnceListener = function(e, t) {
                        return a(t), this.prependListener(e, h(this, e, t)), this
                    }, r.prototype.removeListener = function(e, t) {
                        var n, i, s, r, o;
                        if (a(t), void 0 === (i = this._events)) return this;
                        if (void 0 === (n = i[e])) return this;
                        if (n === t || n.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || t));
                        else if ("function" != typeof n) {
                            for (s = -1, r = n.length - 1; r >= 0; r--)
                                if (n[r] === t || n[r].listener === t) {
                                    o = n[r].listener, s = r;
                                    break
                                } if (s < 0) return this;
                            0 === s ? n.shift() : function(e, t) {
                                for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                                e.pop()
                            }(n, s), 1 === n.length && (i[e] = n[0]), void 0 !== i.removeListener && this.emit("removeListener", e, o || t)
                        }
                        return this
                    }, r.prototype.off = r.prototype.removeListener, r.prototype.removeAllListeners = function(e) {
                        var t, n, i;
                        if (void 0 === (n = this._events)) return this;
                        if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[e]), this;
                        if (0 === arguments.length) {
                            var s, r = Object.keys(n);
                            for (i = 0; i < r.length; ++i) "removeListener" !== (s = r[i]) && this.removeAllListeners(s);
                            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
                        }
                        if ("function" == typeof(t = n[e])) this.removeListener(e, t);
                        else if (void 0 !== t)
                            for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
                        return this
                    }, r.prototype.listeners = function(e) {
                        return u(this, e, !0)
                    }, r.prototype.rawListeners = function(e) {
                        return u(this, e, !1)
                    }, r.listenerCount = function(e, t) {
                        return "function" == typeof e.listenerCount ? e.listenerCount(t) : p.call(e, t)
                    }, r.prototype.listenerCount = p, r.prototype.eventNames = function() {
                        return this._eventsCount > 0 ? t(this._events) : []
                    }
                },
                9049: (e, t, n) => {
                    var i = n(268);

                    function s(e, t) {
                        this.logStorage = e, this.stringifyObjects = !(!t || !t.stringifyObjects) && t.stringifyObjects, this.storeInterval = t && t.storeInterval ? t.storeInterval : 3e4, this.maxEntryLength = t && t.maxEntryLength ? t.maxEntryLength : 1e4, Object.keys(i.levels).forEach(function(e) {
                            this[i.levels[e]] = function() {
                                this._log.apply(this, arguments)
                            }.bind(this, e)
                        }.bind(this)), this.storeLogsIntervalID = null, this.queue = [], this.totalLen = 0, this.outputCache = []
                    }
                    s.prototype.stringify = function(e) {
                        try {
                            return JSON.stringify(e)
                        } catch (e) {
                            return "[object with circular refs?]"
                        }
                    }, s.prototype.formatLogMessage = function(e) {
                        for (var t = "", n = 1, s = arguments.length; n < s; n++) {
                            var r = arguments[n];
                            !this.stringifyObjects && e !== i.levels.ERROR || "object" != typeof r || (r = this.stringify(r)), t += r, n !== s - 1 && (t += " ")
                        }
                        return t.length ? t : null
                    }, s.prototype._log = function() {
                        var e = arguments[1],
                            t = this.formatLogMessage.apply(this, arguments);
                        if (t) {
                            var n = this.queue[this.queue.length - 1],
                                i = n && n.text;
                            i === t ? n.count += 1 : (this.queue.push({
                                text: t,
                                timestamp: e,
                                count: 1
                            }), this.totalLen += t.length)
                        }
                        this.totalLen >= this.maxEntryLength && this._flush(!0, !0)
                    }, s.prototype.start = function() {
                        this._reschedulePublishInterval()
                    }, s.prototype._reschedulePublishInterval = function() {
                        this.storeLogsIntervalID && (window.clearTimeout(this.storeLogsIntervalID), this.storeLogsIntervalID = null), this.storeLogsIntervalID = window.setTimeout(this._flush.bind(this, !1, !0), this.storeInterval)
                    }, s.prototype.flush = function() {
                        this._flush(!1, !0)
                    }, s.prototype._flush = function(e, t) {
                        this.totalLen > 0 && (this.logStorage.isReady() || e) && (this.logStorage.isReady() ? (this.outputCache.length && (this.outputCache.forEach(function(e) {
                            this.logStorage.storeLogs(e)
                        }.bind(this)), this.outputCache = []), this.logStorage.storeLogs(this.queue)) : this.outputCache.push(this.queue), this.queue = [], this.totalLen = 0), t && this._reschedulePublishInterval()
                    }, s.prototype.stop = function() {
                        this._flush(!1, !1)
                    }, e.exports = s
                },
                268: e => {
                    var t = {
                        trace: 0,
                        debug: 1,
                        info: 2,
                        log: 3,
                        warn: 4,
                        error: 5
                    };
                    o.consoleTransport = console;
                    var n = [o.consoleTransport];
                    o.addGlobalTransport = function(e) {
                        -1 === n.indexOf(e) && n.push(e)
                    }, o.removeGlobalTransport = function(e) {
                        var t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                    };
                    var i = {};

                    function s() {
                        var e = {
                                methodName: "",
                                fileLocation: "",
                                line: null,
                                column: null
                            },
                            t = new Error,
                            n = t.stack ? t.stack.split("\n") : [];
                        if (!n || n.length < 3) return e;
                        var i = null;
                        return n[3] && (i = n[3].match(/\s*at\s*(.+?)\s*\((\S*)\s*:(\d*)\s*:(\d*)\)/)), !i || i.length <= 4 ? (0 === n[2].indexOf("log@") ? e.methodName = n[3].substr(0, n[3].indexOf("@")) : e.methodName = n[2].substr(0, n[2].indexOf("@")), e) : (e.methodName = i[1], e.fileLocation = i[2], e.line = i[3], e.column = i[4], e)
                    }

                    function r() {
                        var e = arguments[0],
                            r = arguments[1],
                            o = Array.prototype.slice.call(arguments, 2);
                        if (!(t[r] < e.level))
                            for (var a = !(e.options.disableCallerInfo || i.disableCallerInfo) && s(), c = n.concat(e.transports), d = 0; d < c.length; d++) {
                                var l = c[d],
                                    h = l[r];
                                if (h && "function" == typeof h) {
                                    var u = [];
                                    u.push((new Date).toISOString()), e.id && u.push("[" + e.id + "]"), a && a.methodName.length > 1 && u.push("<" + a.methodName + ">: ");
                                    var p = u.concat(o);
                                    h.bind(l).apply(l, p)
                                }
                            }
                    }

                    function o(e, n, i, s) {
                        this.id = n, this.options = s || {}, this.transports = i, this.transports || (this.transports = []), this.level = t[e];
                        for (var o = Object.keys(t), a = 0; a < o.length; a++) this[o[a]] = r.bind(null, this, o[a])
                    }
                    o.setGlobalOptions = function(e) {
                        i = e || {}
                    }, o.prototype.setLevel = function(e) {
                        this.level = t[e]
                    }, e.exports = o, o.levels = {
                        TRACE: "trace",
                        DEBUG: "debug",
                        INFO: "info",
                        LOG: "log",
                        WARN: "warn",
                        ERROR: "error"
                    }
                },
                7055: (e, t, n) => {
                    var i = n(268),
                        s = n(9049),
                        r = {},
                        o = [],
                        a = i.levels.TRACE;
                    e.exports = {
                        addGlobalTransport: function(e) {
                            i.addGlobalTransport(e)
                        },
                        removeGlobalTransport: function(e) {
                            i.removeGlobalTransport(e)
                        },
                        setGlobalOptions: function(e) {
                            i.setGlobalOptions(e)
                        },
                        getLogger: function(e, t, n) {
                            var s = new i(a, e, t, n);
                            return e ? (r[e] = r[e] || [], r[e].push(s)) : o.push(s), s
                        },
                        setLogLevelById: function(e, t) {
                            for (var n = t ? r[t] || [] : o, i = 0; i < n.length; i++) n[i].setLevel(e)
                        },
                        setLogLevel: function(e) {
                            a = e;
                            for (var t = 0; t < o.length; t++) o[t].setLevel(e);
                            for (var n in r) {
                                var i = r[n] || [];
                                for (t = 0; t < i.length; t++) i[t].setLevel(e)
                            }
                        },
                        levels: i.levels,
                        LogCollector: s
                    }
                },
                2809: (e, t, n) => {
                    e.exports = n(5571).default
                },
                9765: e => {
                    e.exports = class {
                        constructor(e, t, n) {
                            this._userId = e, this.setDisplayName(t), this._isLocalStats = n || !1, this.setDominantSpeaker(!1), this.totalDominantSpeakerTime = 0, this._dominantSpeakerStart = 0, this._hasLeft = !1
                        }
                        getUserId() {
                            return this._userId
                        }
                        getDisplayName() {
                            return this.displayName
                        }
                        setDisplayName(e) {
                            this.displayName = e
                        }
                        isLocalStats() {
                            return this._isLocalStats
                        }
                        isDominantSpeaker() {
                            return this._dominantSpeakerStart > 0
                        }
                        setDominantSpeaker(e) {
                            if (!this.isDominantSpeaker() && e) this._dominantSpeakerStart = Date.now();
                            else if (this.isDominantSpeaker() && !e) {
                                const e = Date.now() - this._dominantSpeakerStart;
                                this.totalDominantSpeakerTime += e, this._dominantSpeakerStart = 0
                            }
                        }
                        getTotalDominantSpeakerTime() {
                            let e = this.totalDominantSpeakerTime;
                            return this.isDominantSpeaker() && (e += Date.now() - this._dominantSpeakerStart), e
                        }
                        hasLeft() {
                            return this._hasLeft
                        }
                        markAsHasLeft() {
                            this._hasLeft = !0, this.setDominantSpeaker(!1)
                        }
                    }
                },
                6151: (e, t, n) => {
                    const i = n(2992),
                        s = "audio/webm",
                        r = "audio/ogg",
                        o = function(e) {
                            this.track = e, this.recorder = null, this.data = null, this.name = null, this.startTime = null
                        };

                    function a(e) {
                        if (void 0 === e.recorder) throw new Error("Passed an object to startRecorder which is not a TrackRecorder object");
                        e.recorder.start(), e.startTime = new Date
                    }

                    function c(e) {
                        if (void 0 === e.recorder) throw new Error("Passed an object to stopRecorder which is not a TrackRecorder object");
                        e.recorder.stop()
                    }

                    function d() {
                        if (MediaRecorder.isTypeSupported(s)) return s;
                        if (MediaRecorder.isTypeSupported(r)) return r;
                        throw new Error("unable to create a MediaRecorder with the right mimetype!")
                    }

                    function l(e) {
                        this.recorders = [], this.fileType = d(), this.isRecording = !1, this.jitsiConference = e
                    }
                    l.determineCorrectFileType = d, l.prototype.addTrack = function(e) {
                        if (e.isAudioTrack()) {
                            const t = this.instantiateTrackRecorder(e);
                            this.recorders.push(t), this.updateNames(), this.isRecording && a(t)
                        }
                    }, l.prototype.instantiateTrackRecorder = function(e) {
                        const t = new o(e),
                            n = t.track.getOriginalStream(),
                            i = new MediaStream;
                        return n.getAudioTracks().forEach((e => i.addTrack(e))), t.recorder = new MediaRecorder(i, {
                            mimeType: this.fileType
                        }), t.data = [], t.recorder.ondataavailable = function(e) {
                            e.data.size > 0 && t.data.push(e.data)
                        }, t
                    }, l.prototype.removeTrack = function(e) {
                        if (e.isVideoTrack()) return;
                        const t = this.recorders;
                        let n;
                        for (n = 0; n < t.length; n++)
                            if (t[n].track.getParticipantId() === e.getParticipantId()) {
                                const e = t[n];
                                this.isRecording ? c(e) : t.splice(n, 1)
                            } this.updateNames()
                    }, l.prototype.updateNames = function() {
                        const e = this.jitsiConference;
                        this.recorders.forEach((t => {
                            if (t.track.isLocal()) t.name = "the transcriber";
                            else {
                                const n = t.track.getParticipantId(),
                                    i = e.getParticipantById(n).getDisplayName();
                                "undefined" !== i && (t.name = i)
                            }
                        }))
                    }, l.prototype.start = function() {
                        if (this.isRecording) throw new Error("audiorecorder is already recording");
                        this.isRecording = !0, this.recorders.forEach((e => a(e))), console.log(`Started the recording of the audio. There are currently ${this.recorders.length} recorders active.`)
                    }, l.prototype.stop = function() {
                        this.isRecording = !1, this.recorders.forEach((e => c(e))), console.log("stopped recording")
                    }, l.prototype.download = function() {
                        this.recorders.forEach((e => {
                            const t = new Blob(e.data, {
                                    type: this.fileType
                                }),
                                n = URL.createObjectURL(t),
                                i = document.createElement("a");
                            document.body.appendChild(i), i.style = "display: none", i.href = n, i.download = `test.${this.fileType.split("/")[1]}`, i.click(), window.URL.revokeObjectURL(n)
                        }))
                    }, l.prototype.getRecordingResults = function() {
                        if (this.isRecording) throw new Error("cannot get blobs because the AudioRecorder is still recording!");
                        this.updateNames();
                        const e = [];
                        return this.recorders.forEach((t => e.push(new i(new Blob(t.data, {
                            type: this.fileType
                        }), t.name, t.startTime)))), e
                    }, l.prototype.getFileType = function() {
                        return this.fileType
                    }, e.exports = l
                },
                2992: e => {
                    e.exports = function(e, t, n, i) {
                        this.blob = e, this.name = t, this.startTime = n, this.wordArray = i
                    }
                },
                6563: (e, t, n) => {
                    const i = n(6151),
                        s = n(3747),
                        r = "before",
                        o = "recording",
                        a = "transcribing",
                        c = "finished";

                    function d() {
                        this.audioRecorder = new i, this.transcriptionService = new s, this.counter = null, this.startTime = null, this.transcription = null, this.callback = null, this.results = [], this.state = r, this.lineLength = 0
                    }

                    function l(e, t) {
                        if (console.log(`retrieved an answer from the transcription service. The answer has an array of length: ${t.wordArray.length}`), t.wordArray.length > 0) {
                            let n = t.startTime.getUTCMilliseconds() - e.startTime.getUTCMilliseconds();
                            n < 0 && (n = 0);
                            let i = "[";
                            t.wordArray.forEach((e => {
                                e.begin += n, e.end += n, i += `${e.word},`
                            })), i += "]", console.log(i), t.wordArray.name = t.name
                        }
                        e.results.push(t.wordArray), e.counter--, console.log(`current counter: ${e.counter}`), e.maybeMerge()
                    }

                    function h(e) {
                        for (let t = 0; t < e.length; t++) 0 === e[t].length && e.splice(t, 1);
                        return e.length > 0
                    }
                    d.prototype.start = function() {
                        if (this.state !== r) throw new Error(`The transcription can only start when it's in the "before" state. It's currently in the "${this.state}" state`);
                        this.state = o, this.audioRecorder.start(), this.startTime = new Date
                    }, d.prototype.stop = function(e) {
                        if (this.state !== o) throw new Error(`The transcription can only stop when it's in the "recording" state. It's currently in the "${this.state}" state`);
                        console.log("stopping recording and sending audio files"), this.audioRecorder.stop();
                        const t = l.bind(null, this);
                        this.audioRecorder.getRecordingResults().forEach((e => {
                            this.transcriptionService.send(e, t), this.counter++
                        })), this.state = a, this.callback = e
                    }, d.prototype.maybeMerge = function() {
                        this.state === a && 0 === this.counter && this.merge()
                    }, d.prototype.merge = function() {
                        console.log(`starting merge process!\n The length of the array: ${this.results.length}`), this.transcription = "";
                        const e = this.results,
                            t = [];
                        for (h(e), e.forEach((e => function(e, t) {
                                if (0 === e.length) e.push(t);
                                else {
                                    if (e[e.length - 1].begin <= t.begin) return void e.push(t);
                                    for (let n = 0; n < e.length; n++)
                                        if (t.begin < e[n].begin) return void e.splice(n, 0, t);
                                    e.push(t)
                                }
                            }(t, e))); h(e);) {
                            let t = e[0];
                            e.forEach((e => {
                                e[0].begin < t[0].begin && (t = e)
                            }));
                            let n = t.shift();
                            for (this.updateTranscription(n, t.name); t.length > 0;) {
                                let i = !1;
                                const s = t[0].begin;
                                if (e.forEach((e => {
                                        e[0].begin < s && (i = !0)
                                    })), i) break;
                                n = t.shift(), this.updateTranscription(n, null)
                            }
                        }
                        this.state = c, this.callback && this.callback(this.transcription)
                    }, d.prototype.updateTranscription = function(e, t) {
                        null != t && (this.transcription += `\n${t}:`, this.lineLength = t.length + 1), this.lineLength + e.word.length > 80 && (this.transcription += "\n    ", this.lineLength = 4), this.transcription += ` ${e.word}`, this.lineLength += e.word.length + 1
                    }, d.prototype.addTrack = function(e) {
                        this.audioRecorder.addTrack(e)
                    }, d.prototype.removeTrack = function(e) {
                        this.audioRecorder.removeTrack(e)
                    }, d.prototype.getTranscription = function() {
                        if (this.state !== c) throw new Error(`The transcription can only be retrieved when it's in the "finished" state. It's currently in the "${this.state}" state`);
                        return this.transcription
                    }, d.prototype.getState = function() {
                        return this.state
                    }, d.prototype.reset = function() {
                        this.state = r, this.counter = null, this.transcription = null, this.startTime = null, this.callback = null, this.results = [], this.lineLength = 0
                    }, e.exports = d
                },
                8281: e => {
                    const t = function() {
                        throw new Error("TranscriptionService is abstract and cannot becreated")
                    };
                    t.prototype.send = function(e, t) {
                        this.sendRequest(e.blob, (n => {
                            this.verify(n) ? e.wordArray = this.formatResponse(n) : (console.log("the retrieved response from the server is not valid!"), e.wordArray = []), t(e)
                        }))
                    }, t.prototype.sendRequest = function(e, t) {
                        throw new Error("TranscriptionService.sendRequest is abstract")
                    }, t.prototype.formatResponse = function(e) {
                        throw new Error("TranscriptionService.format is abstract")
                    }, t.prototype.verify = function(e) {
                        throw new Error("TranscriptionService.verify is abstract")
                    }, e.exports = t
                },
                3747: (e, t, n) => {
                    const i = n(5978),
                        s = n(6151),
                        r = n(8281),
                        o = function() {
                            this.url = function() {
                                const e = "config does not contain an url to a Sphinx4 https server";
                                if (void 0 === config.sphinxURL) console.log(e);
                                else {
                                    const t = config.sphinxURL;
                                    if (void 0 !== t.includes && t.includes("https://")) return t;
                                    console.log(e)
                                }
                            }()
                        };
                    o.prototype = Object.create(r.prototype), o.constructor = o, o.prototype.sendRequest = function(e, t) {
                        console.log(`sending an audio file  to ${this.url}`), console.log(`the audio file being sent: ${e}`);
                        const n = new XMLHttpRequest;
                        n.onreadystatechange = function() {
                            if (n.readyState === XMLHttpRequest.DONE && 200 === n.status) t(n.responseText);
                            else if (n.readyState === XMLHttpRequest.DONE) throw new Error(`unable to accept response from sphinx server. status: ${n.status}`)
                        }, n.open("POST", this.url), n.setRequestHeader("Content-Type", s.determineCorrectFileType()), n.send(e), console.log(`send ${e}`)
                    }, o.prototype.formatResponse = function(e) {
                        const t = JSON.parse(e).objects;
                        t.shift();
                        const n = [];
                        return t.forEach((e => e.filler || n.push(new i(e.word, e.start, e.end)))), n
                    }, o.prototype.verify = function(e) {
                        if (console.log(`response from server:${e.toString()}`), "string" != typeof e) return !1;
                        let t;
                        try {
                            t = JSON.parse(e)
                        } catch (e) {
                            return console.log(e), !1
                        }
                        if (void 0 === t.objects) return !1;
                        const n = t.objects;
                        return !(!n[0] || !n[0]["session-id"])
                    }, e.exports = o
                },
                5978: e => {
                    const t = function(e, t, n) {
                        this.word = e, this.begin = t, this.end = n
                    };
                    t.prototype.getWord = function() {
                        return this.word
                    }, t.prototype.getBeginTime = function() {
                        return this.begin
                    }, t.prototype.getEndTime = function() {
                        return this.end
                    }, e.exports = t
                },
                287: e => {
                    e.exports = {
                        getTokenAuthUrl: (e, t, n) => "string" != typeof e ? null : e.replace("{room}", t).replace("{roleUpgrade}", !0 === n)
                    }
                },
                1278: e => {
                    function t(e, t) {
                        if (!e || !t || "function" != typeof e.addListener || "function" != typeof t.emit) throw new Error("Invalid arguments passed to EventEmitterForwarder");
                        this.src = e, this.dest = t
                    }
                    t.prototype.forward = function(...e) {
                        const t = e[0];
                        e[0] = this.dest, this.src.addListener(t, Function.prototype.bind.apply(this.dest.emit, e))
                    }, e.exports = t
                },
                7024: e => {
                    const t = [],
                        n = window.onerror,
                        i = window.onunhandledrejection;
                    window.onerror = function(...e) {
                        t.forEach((t => t(...e))), n && n(...e)
                    }, window.onunhandledrejection = function(e) {
                        t.forEach((t => t(null, null, null, null, e.reason))), i && i(e)
                    };
                    const s = {
                        addHandler(e) {
                            t.push(e)
                        },
                        callErrorHandler(e) {
                            const t = window.onerror;
                            t && t(null, null, null, null, e)
                        },
                        callUnhandledRejectionHandler(e) {
                            const t = window.onunhandledrejection;
                            t && t(e)
                        }
                    };
                    e.exports = s
                },
                6630: e => {
                    function t(e, t) {
                        return Math.floor(Math.random() * (t - e + 1)) + e
                    }

                    function n(e) {
                        return e[t(0, e.length - 1)]
                    }
                    const i = {
                        randomHexDigit: () => n("0123456789abcdef"),
                        randomHexString(e) {
                            let t = "";
                            for (; e--;) t += this.randomHexDigit();
                            return t
                        },
                        randomElement: n,
                        randomAlphanumStr: function(e) {
                            let t = "";
                            for (let i = 0; i < e; i += 1) t += n("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
                            return t
                        },
                        randomInt: t
                    };
                    e.exports = i
                },
                1795: (e, t, n) => {
                    const i = n(6943),
                        s = {
                            loadScript(e, t, n, s, r, o) {
                                const a = document,
                                    c = "script",
                                    d = a.createElement(c),
                                    l = a.getElementsByTagName(c)[0];
                                if (d.async = t, s) {
                                    const t = i();
                                    if (t) {
                                        const n = t.src,
                                            i = n.substring(0, n.lastIndexOf("/") + 1);
                                        n && i && (e = i + e)
                                    }
                                }
                                r && (d.onload = r), o && (d.onerror = o), d.src = e, n ? l.parentNode.insertBefore(d, l) : l.parentNode.appendChild(d)
                            }
                        };
                    e.exports = s
                },
                7285: e => {
                    e.exports = {
                        integerHash: function(e) {
                            if (!e) return 0;
                            let t, n, i = 0;
                            for (n = 0; n < e.length; n++) t = e.charCodeAt(n), i += t * Math.pow(31, e.length - 1 - n), i = Math.abs(0 | i);
                            return i
                        }
                    }
                },
                9307: (e, t, n) => {
                    const i = n(6630),
                        s = ["Aaliyah", "Aaron", "Abagail", "Abbey", "Abbie", "Abbigail", "Abby", "Abdiel", "Abdul", "Abdullah", "Abe", "Abel", "Abelardo", "Abigail", "Abigale", "Abigayle", "Abner", "Abraham", "Ada", "Adah", "Adalberto", "Adaline", "Adam", "Adan", "Addie", "Addison", "Adela", "Adelbert", "Adele", "Adelia", "Adeline", "Adell", "Adella", "Adelle", "Aditya", "Adolf", "Adolfo", "Adolph", "Adolphus", "Adonis", "Adrain", "Adrian", "Adriana", "Adrianna", "Adriel", "Adrien", "Adrienne", "Afton", "Aglae", "Agnes", "Agustin", "Agustina", "Ahmad", "Ahmed", "Aida", "Aidan", "Aiden", "Aileen", "Aisha", "Aiyana", "Akeem", "Al", "Alaina", "Alan", "Alana", "Alanis", "Alanna", "Alayna", "Alba", "Albert", "Alberta", "Albertha", "Alberto", "Albin", "Albina", "Alda", "Alden", "Alec", "Aleen", "Alejandra", "Alejandrin", "Alek", "Alena", "Alene", "Alessandra", "Alessandro", "Alessia", "Aletha", "Alex", "Alexa", "Alexander", "Alexandra", "Alexandre", "Alexandrea", "Alexandria", "Alexandrine", "Alexandro", "Alexane", "Alexanne", "Alexie", "Alexis", "Alexys", "Alexzander", "Alf", "Alfonso", "Alfonzo", "Alford", "Alfred", "Alfreda", "Alfredo", "Ali", "Alia", "Alice", "Alicia", "Alisa", "Alisha", "Alison", "Alivia", "Aliya", "Aliyah", "Aliza", "Alize", "Allan", "Allen", "Allene", "Allie", "Allison", "Ally", "Alphonso", "Alta", "Althea", "Alva", "Alvah", "Alvena", "Alvera", "Alverta", "Alvina", "Alvis", "Alyce", "Alycia", "Alysa", "Alysha", "Alyson", "Alysson", "Amalia", "Amanda", "Amani", "Amara", "Amari", "Amaya", "Amber", "Ambrose", "Amelia", "Amelie", "Amely", "America", "Americo", "Amie", "Amina", "Amir", "Amira", "Amiya", "Amos", "Amparo", "Amy", "Amya", "Ana", "Anabel", "Anabelle", "Anahi", "Anais", "Anastacio", "Anastasia", "Anderson", "Andre", "Andreane", "Andreanne", "Andres", "Andrew", "Andy", "Angel", "Angela", "Angelica", "Angelina", "Angeline", "Angelita", "Angelo", "Angie", "Angus", "Anibal", "Anika", "Anissa", "Anita", "Aniya", "Aniyah", "Anjali", "Anna", "Annabel", "Annabell", "Annabelle", "Annalise", "Annamae", "Annamarie", "Anne", "Annetta", "Annette", "Annie", "Ansel", "Ansley", "Anthony", "Antoinette", "Antone", "Antonetta", "Antonette", "Antonia", "Antonietta", "Antonina", "Antonio", "Antwan", "Antwon", "Anya", "April", "Ara", "Araceli", "Aracely", "Arch", "Archibald", "Ardella", "Arden", "Ardith", "Arely", "Ari", "Ariane", "Arianna", "Aric", "Ariel", "Arielle", "Arjun", "Arlene", "Arlie", "Arlo", "Armand", "Armando", "Armani", "Arnaldo", "Arne", "Arno", "Arnold", "Arnoldo", "Arnulfo", "Aron", "Art", "Arthur", "Arturo", "Arvel", "Arvid", "Arvilla", "Aryanna", "Asa", "Asha", "Ashlee", "Ashleigh", "Ashley", "Ashly", "Ashlynn", "Ashton", "Ashtyn", "Asia", "Assunta", "Astrid", "Athena", "Aubree", "Aubrey", "Audie", "Audra", "Audreanne", "Audrey", "August", "Augusta", "Augustine", "Augustus", "Aurelia", "Aurelie", "Aurelio", "Aurore", "Austen", "Austin", "Austyn", "Autumn", "Ava", "Avery", "Avis", "Axel", "Ayana", "Ayden", "Ayla", "Aylin", "Baby", "Bailee", "Bailey", "Barbara", "Barney", "Baron", "Barrett", "Barry", "Bart", "Bartholome", "Barton", "Baylee", "Beatrice", "Beau", "Beaulah", "Bell", "Bella", "Belle", "Ben", "Benedict", "Benjamin", "Bennett", "Bennie", "Benny", "Benton", "Berenice", "Bernadette", "Bernadine", "Bernard", "Bernardo", "Berneice", "Bernhard", "Bernice", "Bernie", "Berniece", "Bernita", "Berry", "Bert", "Berta", "Bertha", "Bertram", "Bertrand", "Beryl", "Bessie", "Beth", "Bethany", "Bethel", "Betsy", "Bette", "Bettie", "Betty", "Bettye", "Beulah", "Beverly", "Bianka", "Bill", "Billie", "Billy", "Birdie", "Blair", "Blaise", "Blake", "Blanca", "Blanche", "Blaze", "Bo", "Bobbie", "Bobby", "Bonita", "Bonnie", "Boris", "Boyd", "Brad", "Braden", "Bradford", "Bradley", "Bradly", "Brady", "Braeden", "Brain", "Brandi", "Brando", "Brandon", "Brandt", "Brandy", "Brandyn", "Brannon", "Branson", "Brant", "Braulio", "Braxton", "Brayan", "Breana", "Breanna", "Breanne", "Brenda", "Brendan", "Brenden", "Brendon", "Brenna", "Brennan", "Brennon", "Brent", "Bret", "Brett", "Bria", "Brian", "Briana", "Brianne", "Brice", "Bridget", "Bridgette", "Bridie", "Brielle", "Brigitte", "Brionna", "Brisa", "Britney", "Brittany", "Brock", "Broderick", "Brody", "Brook", "Brooke", "Brooklyn", "Brooks", "Brown", "Bruce", "Bryana", "Bryce", "Brycen", "Bryon", "Buck", "Bud", "Buddy", "Buford", "Bulah", "Burdette", "Burley", "Burnice", "Buster", "Cade", "Caden", "Caesar", "Caitlyn", "Cale", "Caleb", "Caleigh", "Cali", "Calista", "Callie", "Camden", "Cameron", "Camila", "Camilla", "Camille", "Camren", "Camron", "Camryn", "Camylle", "Candace", "Candelario", "Candice", "Candida", "Candido", "Cara", "Carey", "Carissa", "Carlee", "Carleton", "Carley", "Carli", "Carlie", "Carlo", "Carlos", "Carlotta", "Carmel", "Carmela", "Carmella", "Carmelo", "Carmen", "Carmine", "Carol", "Carolanne", "Carole", "Carolina", "Caroline", "Carolyn", "Carolyne", "Carrie", "Carroll", "Carson", "Carter", "Cary", "Casandra", "Casey", "Casimer", "Casimir", "Casper", "Cassandra", "Cassandre", "Cassidy", "Cassie", "Catalina", "Caterina", "Catharine", "Catherine", "Cathrine", "Cathryn", "Cathy", "Cayla", "Ceasar", "Cecelia", "Cecil", "Cecile", "Cecilia", "Cedrick", "Celestine", "Celestino", "Celia", "Celine", "Cesar", "Chad", "Chadd", "Chadrick", "Chaim", "Chance", "Chandler", "Chanel", "Chanelle", "Charity", "Charlene", "Charles", "Charley", "Charlie", "Charlotte", "Chase", "Chasity", "Chauncey", "Chaya", "Chaz", "Chelsea", "Chelsey", "Chelsie", "Chesley", "Chester", "Chet", "Cheyanne", "Cheyenne", "Chloe", "Chris", "Christ", "Christa", "Christelle", "Christian", "Christiana", "Christina", "Christine", "Christop", "Christophe", "Christopher", "Christy", "Chyna", "Ciara", "Cicero", "Cielo", "Cierra", "Cindy", "Citlalli", "Clair", "Claire", "Clara", "Clarabelle", "Clare", "Clarissa", "Clark", "Claud", "Claude", "Claudia", "Claudie", "Claudine", "Clay", "Clemens", "Clement", "Clementina", "Clementine", "Clemmie", "Cleo", "Cleora", "Cleta", "Cletus", "Cleve", "Cleveland", "Clifford", "Clifton", "Clint", "Clinton", "Clotilde", "Clovis", "Cloyd", "Clyde", "Coby", "Cody", "Colby", "Cole", "Coleman", "Colin", "Colleen", "Collin", "Colt", "Colten", "Colton", "Columbus", "Concepcion", "Conner", "Connie", "Connor", "Conor", "Conrad", "Constance", "Constantin", "Consuelo", "Cooper", "Cora", "Coralie", "Corbin", "Cordelia", "Cordell", "Cordia", "Cordie", "Corene", "Corine", "Cornelius", "Cornell", "Corrine", "Cortez", "Cortney", "Cory", "Coty", "Courtney", "Coy", "Craig", "Crawford", "Creola", "Cristal", "Cristian", "Cristina", "Cristobal", "Cristopher", "Cruz", "Crystal", "Crystel", "Cullen", "Curt", "Curtis", "Cydney", "Cynthia", "Cyril", "Cyrus", "Dagmar", "Dahlia", "Daija", "Daisha", "Daisy", "Dakota", "Dale", "Dallas", "Dallin", "Dalton", "Damaris", "Dameon", "Damian", "Damien", "Damion", "Damon", "Dan", "Dana", "Dandre", "Dane", "D'angelo", "Dangelo", "Danial", "Daniela", "Daniella", "Danielle", "Danika", "Dannie", "Danny", "Dante", "Danyka", "Daphne", "Daphnee", "Daphney", "Darby", "Daren", "Darian", "Dariana", "Darien", "Dario", "Darion", "Darius", "Darlene", "Daron", "Darrel", "Darrell", "Darren", "Darrick", "Darrin", "Darrion", "Darron", "Darryl", "Darwin", "Daryl", "Dashawn", "Dasia", "Dave", "David", "Davin", "Davion", "Davon", "Davonte", "Dawn", "Dawson", "Dax", "Dayana", "Dayna", "Dayne", "Dayton", "Dean", "Deangelo", "Deanna", "Deborah", "Declan", "Dedric", "Dedrick", "Dee", "Deion", "Deja", "Dejah", "Dejon", "Dejuan", "Delaney", "Delbert", "Delfina", "Delia", "Delilah", "Dell", "Della", "Delmer", "Delores", "Delpha", "Delphia", "Delphine", "Delta", "Demarco", "Demarcus", "Demario", "Demetris", "Demetrius", "Demond", "Dena", "Denis", "Dennis", "Deon", "Deondre", "Deontae", "Deonte", "Dereck", "Derek", "Derick", "Deron", "Derrick", "Deshaun", "Deshawn", "Desiree", "Desmond", "Dessie", "Destany", "Destin", "Destinee", "Destiney", "Destini", "Destiny", "Devan", "Devante", "Deven", "Devin", "Devon", "Devonte", "Devyn", "Dewayne", "Dewitt", "Dexter", "Diamond", "Diana", "Dianna", "Diego", "Dillan", "Dillon", "Dimitri", "Dina", "Dino", "Dion", "Dixie", "Dock", "Dolly", "Dolores", "Domenic", "Domenica", "Domenick", "Domenico", "Domingo", "Dominic", "Dominique", "Don", "Donald", "Donato", "Donavon", "Donna", "Donnell", "Donnie", "Donny", "Dora", "Dorcas", "Dorian", "Doris", "Dorothea", "Dorothy", "Dorris", "Dortha", "Dorthy", "Doug", "Douglas", "Dovie", "Doyle", "Drake", "Drew", "Duane", "Dudley", "Dulce", "Duncan", "Durward", "Dustin", "Dusty", "Dwight", "Dylan", "Earl", "Earlene", "Earline", "Earnest", "Earnestine", "Easter", "Easton", "Ebba", "Ebony", "Ed", "Eda", "Edd", "Eddie", "Eden", "Edgar", "Edgardo", "Edison", "Edmond", "Edmund", "Edna", "Eduardo", "Edward", "Edwardo", "Edwin", "Edwina", "Edyth", "Edythe", "Effie", "Efrain", "Efren", "Eileen", "Einar", "Eino", "Eladio", "Elaina", "Elbert", "Elda", "Eldon", "Eldora", "Eldred", "Eldridge", "Eleanora", "Eleanore", "Eleazar", "Electa", "Elena", "Elenor", "Elenora", "Eleonore", "Elfrieda", "Eli", "Elian", "Eliane", "Elias", "Eliezer", "Elijah", "Elinor", "Elinore", "Elisa", "Elisabeth", "Elise", "Eliseo", "Elisha", "Elissa", "Eliza", "Elizabeth", "Ella", "Ellen", "Ellie", "Elliot", "Elliott", "Ellis", "Ellsworth", "Elmer", "Elmira", "Elmo", "Elmore", "Elna", "Elnora", "Elody", "Eloisa", "Eloise", "Elouise", "Eloy", "Elroy", "Elsa", "Else", "Elsie", "Elta", "Elton", "Elva", "Elvera", "Elvie", "Elvis", "Elwin", "Elwyn", "Elyse", "Elyssa", "Elza", "Emanuel", "Emelia", "Emelie", "Emely", "Emerald", "Emerson", "Emery", "Emie", "Emil", "Emile", "Emilia", "Emiliano", "Emilie", "Emilio", "Emily", "Emma", "Emmalee", "Emmanuel", "Emmanuelle", "Emmet", "Emmett", "Emmie", "Emmitt", "Emmy", "Emory", "Ena", "Enid", "Enoch", "Enola", "Enos", "Enrico", "Enrique", "Ephraim", "Era", "Eriberto", "Eric", "Erica", "Erich", "Erick", "Ericka", "Erik", "Erika", "Erin", "Erling", "Erna", "Ernest", "Ernestina", "Ernestine", "Ernesto", "Ernie", "Ervin", "Erwin", "Eryn", "Esmeralda", "Esperanza", "Esta", "Esteban", "Estefania", "Estel", "Estell", "Estella", "Estelle", "Estevan", "Esther", "Estrella", "Etha", "Ethan", "Ethel", "Ethelyn", "Ethyl", "Ettie", "Eudora", "Eugene", "Eugenia", "Eula", "Eulah", "Eulalia", "Euna", "Eunice", "Eusebio", "Eva", "Evalyn", "Evan", "Evangeline", "Evans", "Eve", "Eveline", "Evelyn", "Everardo", "Everett", "Everette", "Evert", "Evie", "Ewald", "Ewell", "Ezekiel", "Ezequiel", "Ezra", "Fabian", "Fabiola", "Fae", "Fannie", "Fanny", "Fatima", "Faustino", "Fausto", "Favian", "Fay", "Faye", "Federico", "Felicia", "Felicita", "Felicity", "Felipa", "Felipe", "Felix", "Felton", "Fermin", "Fern", "Fernando", "Ferne", "Fidel", "Filiberto", "Filomena", "Finn", "Fiona", "Flavie", "Flavio", "Fleta", "Fletcher", "Flo", "Florence", "Florencio", "Florian", "Florida", "Florine", "Flossie", "Floy", "Floyd", "Ford", "Forest", "Forrest", "Foster", "Frances", "Francesca", "Francesco", "Francis", "Francisca", "Francisco", "Franco", "Frank", "Frankie", "Franz", "Fred", "Freda", "Freddie", "Freddy", "Frederic", "Frederick", "Frederik", "Frederique", "Fredrick", "Fredy", "Freeda", "Freeman", "Freida", "Frida", "Frieda", "Friedrich", "Fritz", "Furman", "Gabe", "Gabriel", "Gabriella", "Gabrielle", "Gaetano", "Gage", "Gail", "Gardner", "Garett", "Garfield", "Garland", "Garnet", "Garnett", "Garret", "Garrett", "Garrick", "Garrison", "Garry", "Garth", "Gaston", "Gavin", "Gay", "Gayle", "Gaylord", "Gene", "General", "Genesis", "Genevieve", "Gennaro", "Genoveva", "Geo", "Geoffrey", "George", "Georgette", "Georgiana", "Georgianna", "Geovanni", "Geovanny", "Geovany", "Gerald", "Geraldine", "Gerard", "Gerardo", "Gerda", "Gerhard", "Germaine", "German", "Gerry", "Gerson", "Gertrude", "Gia", "Gianni", "Gideon", "Gilbert", "Gilberto", "Gilda", "Giles", "Gillian", "Gina", "Gino", "Giovani", "Giovanna", "Giovanni", "Giovanny", "Gisselle", "Giuseppe", "Gladyce", "Gladys", "Glen", "Glenda", "Glenna", "Glennie", "Gloria", "Godfrey", "Golda", "Golden", "Gonzalo", "Gordon", "Grace", "Gracie", "Graciela", "Grady", "Graham", "Grant", "Granville", "Grayce", "Grayson", "Green", "Greg", "Gregg", "Gregoria", "Gregorio", "Gregory", "Greta", "Gretchen", "Greyson", "Griffin", "Grover", "Guadalupe", "Gudrun", "Guido", "Guillermo", "Guiseppe", "Gunnar", "Gunner", "Gus", "Gussie", "Gust", "Gustave", "Guy", "Gwen", "Gwendolyn", "Hadley", "Hailee", "Hailey", "Hailie", "Hal", "Haleigh", "Haley", "Halie", "Halle", "Hallie", "Hank", "Hanna", "Hannah", "Hans", "Hardy", "Harley", "Harmon", "Harmony", "Harold", "Harrison", "Harry", "Harvey", "Haskell", "Hassan", "Hassie", "Hattie", "Haven", "Hayden", "Haylee", "Hayley", "Haylie", "Hazel", "Hazle", "Heath", "Heather", "Heaven", "Heber", "Hector", "Heidi", "Helen", "Helena", "Helene", "Helga", "Hellen", "Helmer", "Heloise", "Henderson", "Henri", "Henriette", "Henry", "Herbert", "Herman", "Hermann", "Hermina", "Herminia", "Herminio", "Hershel", "Herta", "Hertha", "Hester", "Hettie", "Hilario", "Hilbert", "Hilda", "Hildegard", "Hillard", "Hillary", "Hilma", "Hilton", "Hipolito", "Hiram", "Hobart", "Holden", "Hollie", "Hollis", "Holly", "Hope", "Horace", "Horacio", "Hortense", "Hosea", "Houston", "Howard", "Howell", "Hoyt", "Hubert", "Hudson", "Hugh", "Hulda", "Humberto", "Hunter", "Hyman", "Ian", "Ibrahim", "Icie", "Ida", "Idell", "Idella", "Ignacio", "Ignatius", "Ike", "Ila", "Ilene", "Iliana", "Ima", "Imani", "Imelda", "Immanuel", "Imogene", "Ines", "Irma", "Irving", "Irwin", "Isaac", "Isabel", "Isabell", "Isabella", "Isabelle", "Isac", "Isadore", "Isai", "Isaiah", "Isaias", "Isidro", "Ismael", "Isobel", "Isom", "Israel", "Issac", "Itzel", "Iva", "Ivah", "Ivory", "Ivy", "Izabella", "Izaiah", "Jabari", "Jace", "Jacey", "Jacinthe", "Jacinto", "Jack", "Jackeline", "Jackie", "Jacklyn", "Jackson", "Jacky", "Jaclyn", "Jacquelyn", "Jacques", "Jacynthe", "Jada", "Jade", "Jaden", "Jadon", "Jadyn", "Jaeden", "Jaida", "Jaiden", "Jailyn", "Jaime", "Jairo", "Jakayla", "Jake", "Jakob", "Jaleel", "Jalen", "Jalon", "Jalyn", "Jamaal", "Jamal", "Jamar", "Jamarcus", "Jamel", "Jameson", "Jamey", "Jamie", "Jamil", "Jamir", "Jamison", "Jammie", "Jan", "Jana", "Janae", "Jane", "Janelle", "Janessa", "Janet", "Janice", "Janick", "Janie", "Janis", "Janiya", "Jannie", "Jany", "Jaquan", "Jaquelin", "Jaqueline", "Jared", "Jaren", "Jarod", "Jaron", "Jarred", "Jarrell", "Jarret", "Jarrett", "Jarrod", "Jarvis", "Jasen", "Jasmin", "Jason", "Jasper", "Jaunita", "Javier", "Javon", "Javonte", "Jay", "Jayce", "Jaycee", "Jayda", "Jayde", "Jayden", "Jaydon", "Jaylan", "Jaylen", "Jaylin", "Jaylon", "Jayme", "Jayne", "Jayson", "Jazlyn", "Jazmin", "Jazmyn", "Jazmyne", "Jean", "Jeanette", "Jeanie", "Jeanne", "Jed", "Jedediah", "Jedidiah", "Jeff", "Jefferey", "Jeffery", "Jeffrey", "Jeffry", "Jena", "Jenifer", "Jennie", "Jennifer", "Jennings", "Jennyfer", "Jensen", "Jerad", "Jerald", "Jeramie", "Jeramy", "Jerel", "Jeremie", "Jeremy", "Jermain", "Jermaine", "Jermey", "Jerod", "Jerome", "Jeromy", "Jerrell", "Jerrod", "Jerrold", "Jerry", "Jess", "Jesse", "Jessica", "Jessie", "Jessika", "Jessy", "Jessyca", "Jesus", "Jett", "Jettie", "Jevon", "Jewel", "Jewell", "Jillian", "Jimmie", "Jimmy", "Jo", "Joan", "Joana", "Joanie", "Joanne", "Joannie", "Joanny", "Joany", "Joaquin", "Jocelyn", "Jodie", "Jody", "Joe", "Joel", "Joelle", "Joesph", "Joey", "Johan", "Johann", "Johanna", "Johathan", "John", "Johnathan", "Johnathon", "Johnnie", "Johnny", "Johnpaul", "Johnson", "Jolie", "Jon", "Jonas", "Jonatan", "Jonathan", "Jonathon", "Jordan", "Jordane", "Jordi", "Jordon", "Jordy", "Jordyn", "Jorge", "Jose", "Josefa", "Josefina", "Joseph", "Josephine", "Josh", "Joshua", "Joshuah", "Josiah", "Josiane", "Josianne", "Josie", "Josue", "Jovan", "Jovani", "Jovanny", "Jovany", "Joy", "Joyce", "Juana", "Juanita", "Judah", "Judd", "Jude", "Judge", "Judson", "Judy", "Jules", "Julia", "Julian", "Juliana", "Julianne", "Julie", "Julien", "Juliet", "Julio", "Julius", "June", "Junior", "Junius", "Justen", "Justice", "Justina", "Justine", "Juston", "Justus", "Justyn", "Juvenal", "Juwan", "Kacey", "Kaci", "Kacie", "Kade", "Kaden", "Kadin", "Kaela", "Kaelyn", "Kaia", "Kailee", "Kailey", "Kailyn", "Kaitlin", "Kaitlyn", "Kale", "Kaleb", "Kaleigh", "Kaley", "Kali", "Kallie", "Kameron", "Kamille", "Kamren", "Kamron", "Kamryn", "Kane", "Kara", "Kareem", "Karelle", "Karen", "Kari", "Kariane", "Karianne", "Karina", "Karine", "Karl", "Karlee", "Karley", "Karli", "Karlie", "Karolann", "Karson", "Kasandra", "Kasey", "Kassandra", "Katarina", "Katelin", "Katelyn", "Katelynn", "Katharina", "Katherine", "Katheryn", "Kathleen", "Kathlyn", "Kathryn", "Kathryne", "Katlyn", "Katlynn", "Katrina", "Katrine", "Kattie", "Kavon", "Kay", "Kaya", "Kaycee", "Kayden", "Kayla", "Kaylah", "Kaylee", "Kayleigh", "Kayley", "Kayli", "Kaylie", "Kaylin", "Keagan", "Keanu", "Keara", "Keaton", "Keegan", "Keeley", "Keely", "Keenan", "Keira", "Keith", "Kellen", "Kelley", "Kelli", "Kellie", "Kelly", "Kelsi", "Kelsie", "Kelton", "Kelvin", "Ken", "Kendall", "Kendra", "Kendrick", "Kenna", "Kennedi", "Kennedy", "Kenneth", "Kennith", "Kenny", "Kenton", "Kenya", "Kenyatta", "Kenyon", "Keon", "Keshaun", "Keshawn", "Keven", "Kevin", "Kevon", "Keyon", "Keyshawn", "Khalid", "Khalil", "Kian", "Kiana", "Kianna", "Kiara", "Kiarra", "Kiel", "Kiera", "Kieran", "Kiley", "Kim", "Kimberly", "King", "Kip", "Kira", "Kirk", "Kirsten", "Kirstin", "Kitty", "Kobe", "Koby", "Kody", "Kolby", "Kole", "Korbin", "Korey", "Kory", "Kraig", "Kris", "Krista", "Kristian", "Kristin", "Kristina", "Kristofer", "Kristoffer", "Kristopher", "Kristy", "Krystal", "Krystel", "Krystina", "Kurt", "Kurtis", "Kyla", "Kyle", "Kylee", "Kyleigh", "Kyler", "Kylie", "Kyra", "Lacey", "Lacy", "Ladarius", "Lafayette", "Laila", "Laisha", "Lamar", "Lambert", "Lamont", "Lance", "Landen", "Lane", "Laney", "Larissa", "Laron", "Larry", "Larue", "Laura", "Laurel", "Lauren", "Laurence", "Lauretta", "Lauriane", "Laurianne", "Laurie", "Laurine", "Laury", "Lauryn", "Lavada", "Lavern", "Laverna", "Laverne", "Lavina", "Lavinia", "Lavon", "Lavonne", "Lawrence", "Lawson", "Layla", "Layne", "Lazaro", "Lea", "Leann", "Leanna", "Leanne", "Leatha", "Leda", "Lee", "Leif", "Leila", "Leilani", "Lela", "Lelah", "Leland", "Lelia", "Lempi", "Lemuel", "Lenna", "Lennie", "Lenny", "Lenora", "Lenore", "Leo", "Leola", "Leon", "Leonard", "Leonardo", "Leone", "Leonel", "Leonie", "Leonor", "Leonora", "Leopold", "Leopoldo", "Leora", "Lera", "Lesley", "Leslie", "Lesly", "Lessie", "Lester", "Leta", "Letha", "Letitia", "Levi", "Lew", "Lewis", "Lexi", "Lexie", "Lexus", "Lia", "Liam", "Liana", "Libbie", "Libby", "Lila", "Lilian", "Liliana", "Liliane", "Lilla", "Lillian", "Lilliana", "Lillie", "Lilly", "Lily", "Lilyan", "Lina", "Lincoln", "Linda", "Lindsay", "Lindsey", "Linnea", "Linnie", "Linwood", "Lionel", "Lisa", "Lisandro", "Lisette", "Litzy", "Liza", "Lizeth", "Lizzie", "Llewellyn", "Lloyd", "Logan", "Lois", "Lola", "Lolita", "Loma", "Lon", "London", "Lonie", "Lonnie", "Lonny", "Lonzo", "Lora", "Loraine", "Loren", "Lorena", "Lorenz", "Lorenza", "Lorenzo", "Lori", "Lorine", "Lorna", "Lottie", "Lou", "Louie", "Louisa", "Lourdes", "Louvenia", "Lowell", "Loy", "Loyal", "Loyce", "Lucas", "Luciano", "Lucie", "Lucienne", "Lucile", "Lucinda", "Lucio", "Lucious", "Lucius", "Lucy", "Ludie", "Ludwig", "Lue", "Luella", "Luigi", "Luis", "Luisa", "Lukas", "Lula", "Lulu", "Luna", "Lupe", "Lura", "Lurline", "Luther", "Luz", "Lyda", "Lydia", "Lyla", "Lynn", "Lyric", "Lysanne", "Mabel", "Mabelle", "Mable", "Mac", "Macey", "Maci", "Macie", "Mack", "Mackenzie", "Macy", "Madaline", "Madalyn", "Maddison", "Madeline", "Madelyn", "Madelynn", "Madge", "Madie", "Madilyn", "Madisen", "Madison", "Madisyn", "Madonna", "Madyson", "Mae", "Maegan", "Maeve", "Mafalda", "Magali", "Magdalen", "Magdalena", "Maggie", "Magnolia", "Magnus", "Maia", "Maida", "Maiya", "Major", "Makayla", "Makenna", "Makenzie", "Malachi", "Malcolm", "Malika", "Malinda", "Mallie", "Mallory", "Malvina", "Mandy", "Manley", "Manuel", "Manuela", "Mara", "Marc", "Marcel", "Marcelina", "Marcelino", "Marcella", "Marcelle", "Marcellus", "Marcelo", "Marcia", "Marco", "Marcos", "Marcus", "Margaret", "Margarete", "Margarett", "Margaretta", "Margarette", "Margarita", "Marge", "Margie", "Margot", "Margret", "Marguerite", "Maria", "Mariah", "Mariam", "Marian", "Mariana", "Mariane", "Marianna", "Marianne", "Mariano", "Maribel", "Marie", "Mariela", "Marielle", "Marietta", "Marilie", "Marilou", "Marilyne", "Marina", "Mario", "Marion", "Marisa", "Marisol", "Maritza", "Marjolaine", "Marjorie", "Marjory", "Mark", "Markus", "Marlee", "Marlen", "Marlene", "Marley", "Marlin", "Marlon", "Marques", "Marquis", "Marquise", "Marshall", "Marta", "Martin", "Martina", "Martine", "Marty", "Marvin", "Mary", "Maryam", "Maryjane", "Maryse", "Mason", "Mateo", "Mathew", "Mathias", "Mathilde", "Matilda", "Matilde", "Matt", "Matteo", "Mattie", "Maud", "Maude", "Maudie", "Maureen", "Maurice", "Mauricio", "Maurine", "Maverick", "Mavis", "Max", "Maxie", "Maxime", "Maximilian", "Maximillia", "Maximillian", "Maximo", "Maximus", "Maxine", "Maxwell", "May", "Maya", "Maybell", "Maybelle", "Maye", "Maymie", "Maynard", "Mayra", "Mazie", "Mckayla", "Mckenna", "Mckenzie", "Meagan", "Meaghan", "Meda", "Megane", "Meggie", "Meghan", "Mekhi", "Melany", "Melba", "Melisa", "Melissa", "Mellie", "Melody", "Melvin", "Melvina", "Melyna", "Melyssa", "Mercedes", "Meredith", "Merl", "Merle", "Merlin", "Merritt", "Mertie", "Mervin", "Meta", "Mia", "Micaela", "Micah", "Michael", "Michaela", "Michale", "Micheal", "Michel", "Michele", "Michelle", "Miguel", "Mikayla", "Mike", "Mikel", "Milan", "Miles", "Milford", "Miller", "Millie", "Milo", "Milton", "Mina", "Minerva", "Minnie", "Miracle", "Mireille", "Mireya", "Misael", "Missouri", "Misty", "Mitchel", "Mitchell", "Mittie", "Modesta", "Modesto", "Mohamed", "Mohammad", "Mohammed", "Moises", "Mollie", "Molly", "Mona", "Monica", "Monique", "Monroe", "Monserrat", "Monserrate", "Montana", "Monte", "Monty", "Morgan", "Moriah", "Morris", "Mortimer", "Morton", "Mose", "Moses", "Moshe", "Mossie", "Mozell", "Mozelle", "Muhammad", "Muriel", "Murl", "Murphy", "Murray", "Mustafa", "Mya", "Myah", "Mylene", "Myles", "Myra", "Myriam", "Myrl", "Myrna", "Myron", "Myrtice", "Myrtie", "Myrtis", "Myrtle", "Nadia", "Nakia", "Name", "Nannie", "Naomi", "Naomie", "Napoleon", "Narciso", "Nash", "Nasir", "Nat", "Natalia", "Natalie", "Natasha", "Nathan", "Nathanael", "Nathanial", "Nathaniel", "Nathen", "Nayeli", "Neal", "Ned", "Nedra", "Neha", "Neil", "Nelda", "Nella", "Nelle", "Nellie", "Nels", "Nelson", "Neoma", "Nestor", "Nettie", "Neva", "Newell", "Newton", "Nia", "Nicholas", "Nicholaus", "Nichole", "Nick", "Nicklaus", "Nickolas", "Nico", "Nicola", "Nicolas", "Nicole", "Nicolette", "Nigel", "Nikita", "Nikki", "Nikko", "Niko", "Nikolas", "Nils", "Nina", "Noah", "Noble", "Noe", "Noel", "Noelia", "Noemi", "Noemie", "Noemy", "Nola", "Nolan", "Nona", "Nora", "Norbert", "Norberto", "Norene", "Norma", "Norris", "Norval", "Norwood", "Nova", "Novella", "Nya", "Nyah", "Nyasia", "Obie", "Oceane", "Ocie", "Octavia", "Oda", "Odell", "Odessa", "Odie", "Ofelia", "Okey", "Ola", "Olaf", "Ole", "Olen", "Oleta", "Olga", "Olin", "Oliver", "Ollie", "Oma", "Omari", "Omer", "Ona", "Onie", "Opal", "Ophelia", "Ora", "Oral", "Oran", "Oren", "Orie", "Orin", "Orion", "Orland", "Orlando", "Orlo", "Orpha", "Orrin", "Orval", "Orville", "Osbaldo", "Osborne", "Oscar", "Osvaldo", "Oswald", "Oswaldo", "Otha", "Otho", "Otilia", "Otis", "Ottilie", "Ottis", "Otto", "Ova", "Owen", "Ozella", "Pablo", "Paige", "Palma", "Pamela", "Pansy", "Paolo", "Paris", "Parker", "Pascale", "Pasquale", "Pat", "Patience", "Patricia", "Patrick", "Patsy", "Pattie", "Paul", "Paula", "Pauline", "Paxton", "Payton", "Pearl", "Pearlie", "Pearline", "Pedro", "Peggie", "Penelope", "Percival", "Percy", "Perry", "Pete", "Peter", "Petra", "Peyton", "Philip", "Phoebe", "Phyllis", "Pierce", "Pierre", "Pietro", "Pink", "Pinkie", "Piper", "Polly", "Porter", "Precious", "Presley", "Preston", "Price", "Prince", "Princess", "Priscilla", "Providenci", "Prudence", "Queen", "Queenie", "Quentin", "Quincy", "Quinn", "Quinten", "Quinton", "Rachael", "Rachel", "Rachelle", "Rae", "Raegan", "Rafael", "Rafaela", "Raheem", "Rahsaan", "Rahul", "Raina", "Raleigh", "Ralph", "Ramiro", "Ramon", "Ramona", "Randal", "Randall", "Randi", "Randy", "Ransom", "Raoul", "Raphael", "Raphaelle", "Raquel", "Rashad", "Rashawn", "Rasheed", "Raul", "Raven", "Ray", "Raymond", "Raymundo", "Reagan", "Reanna", "Reba", "Rebeca", "Rebecca", "Rebeka", "Rebekah", "Reece", "Reed", "Reese", "Regan", "Reggie", "Reginald", "Reid", "Reilly", "Reina", "Reinhold", "Remington", "Rene", "Renee", "Ressie", "Reta", "Retha", "Retta", "Reuben", "Reva", "Rex", "Rey", "Reyes", "Reymundo", "Reyna", "Reynold", "Rhea", "Rhett", "Rhianna", "Rhiannon", "Rhoda", "Ricardo", "Richard", "Richie", "Richmond", "Rick", "Rickey", "Rickie", "Ricky", "Rico", "Rigoberto", "Riley", "Rita", "River", "Robb", "Robbie", "Robert", "Roberta", "Roberto", "Robin", "Robyn", "Rocio", "Rocky", "Rod", "Roderick", "Rodger", "Rodolfo", "Rodrick", "Rodrigo", "Roel", "Rogelio", "Roger", "Rogers", "Rolando", "Rollin", "Roma", "Romaine", "Roman", "Ron", "Ronaldo", "Ronny", "Roosevelt", "Rory", "Rosa", "Rosalee", "Rosalia", "Rosalind", "Rosalinda", "Rosalyn", "Rosamond", "Rosanna", "Rosario", "Roscoe", "Rose", "Rosella", "Roselyn", "Rosemarie", "Rosemary", "Rosendo", "Rosetta", "Rosie", "Rosina", "Roslyn", "Ross", "Rossie", "Rowan", "Rowena", "Rowland", "Roxane", "Roxanne", "Roy", "Royal", "Royce", "Rozella", "Ruben", "Rubie", "Ruby", "Rubye", "Rudolph", "Rudy", "Rupert", "Russ", "Russel", "Russell", "Rusty", "Ruth", "Ruthe", "Ruthie", "Ryan", "Ryann", "Ryder", "Rylan", "Rylee", "Ryleigh", "Ryley", "Sabina", "Sabrina", "Sabryna", "Sadie", "Sadye", "Sage", "Saige", "Sallie", "Sally", "Salma", "Salvador", "Salvatore", "Sam", "Samanta", "Samantha", "Samara", "Samir", "Sammie", "Sammy", "Samson", "Sandra", "Sandrine", "Sandy", "Sanford", "Santa", "Santiago", "Santina", "Santino", "Santos", "Sarah", "Sarai", "Sarina", "Sasha", "Saul", "Savanah", "Savanna", "Savannah", "Savion", "Scarlett", "Schuyler", "Scot", "Scottie", "Scotty", "Seamus", "Sean", "Sebastian", "Sedrick", "Selena", "Selina", "Selmer", "Serena", "Serenity", "Seth", "Shad", "Shaina", "Shakira", "Shana", "Shane", "Shanel", "Shanelle", "Shania", "Shanie", "Shaniya", "Shanna", "Shannon", "Shanny", "Shanon", "Shany", "Sharon", "Shaun", "Shawn", "Shawna", "Shaylee", "Shayna", "Shayne", "Shea", "Sheila", "Sheldon", "Shemar", "Sheridan", "Sherman", "Sherwood", "Shirley", "Shyann", "Shyanne", "Sibyl", "Sid", "Sidney", "Sienna", "Sierra", "Sigmund", "Sigrid", "Sigurd", "Silas", "Sim", "Simeon", "Simone", "Sincere", "Sister", "Skye", "Skyla", "Skylar", "Sofia", "Soledad", "Solon", "Sonia", "Sonny", "Sonya", "Sophia", "Sophie", "Spencer", "Stacey", "Stacy", "Stan", "Stanford", "Stanley", "Stanton", "Stefan", "Stefanie", "Stella", "Stephan", "Stephania", "Stephanie", "Stephany", "Stephen", "Stephon", "Sterling", "Steve", "Stevie", "Stewart", "Stone", "Stuart", "Summer", "Sunny", "Susan", "Susana", "Susanna", "Susie", "Suzanne", "Sven", "Syble", "Sydnee", "Sydney", "Sydni", "Sydnie", "Sylvan", "Sylvester", "Sylvia", "Tabitha", "Tad", "Talia", "Talon", "Tamara", "Tamia", "Tania", "Tanner", "Tanya", "Tara", "Taryn", "Tate", "Tatum", "Tatyana", "Taurean", "Tavares", "Taya", "Taylor", "Teagan", "Ted", "Telly", "Terence", "Teresa", "Terrance", "Terrell", "Terrence", "Terrill", "Terry", "Tess", "Tessie", "Tevin", "Thad", "Thaddeus", "Thalia", "Thea", "Thelma", "Theo", "Theodora", "Theodore", "Theresa", "Therese", "Theresia", "Theron", "Thomas", "Thora", "Thurman", "Tia", "Tiana", "Tianna", "Tiara", "Tierra", "Tiffany", "Tillman", "Timmothy", "Timmy", "Timothy", "Tina", "Tito", "Titus", "Tobin", "Toby", "Tod", "Tom", "Tomas", "Tomasa", "Tommie", "Toney", "Toni", "Tony", "Torey", "Torrance", "Torrey", "Toy", "Trace", "Tracey", "Tracy", "Travis", "Travon", "Tre", "Tremaine", "Tremayne", "Trent", "Trenton", "Tressa", "Tressie", "Treva", "Trever", "Trevion", "Trevor", "Trey", "Trinity", "Trisha", "Tristian", "Tristin", "Triston", "Troy", "Trudie", "Trycia", "Trystan", "Turner", "Twila", "Tyler", "Tyra", "Tyree", "Tyreek", "Tyrel", "Tyrell", "Tyrese", "Tyrique", "Tyshawn", "Tyson", "Ubaldo", "Ulices", "Ulises", "Una", "Unique", "Urban", "Uriah", "Uriel", "Ursula", "Vada", "Valentin", "Valentina", "Valentine", "Valerie", "Vallie", "Van", "Vance", "Vanessa", "Vaughn", "Veda", "Velda", "Vella", "Velma", "Velva", "Vena", "Verda", "Verdie", "Vergie", "Verla", "Verlie", "Vern", "Verna", "Verner", "Vernice", "Vernie", "Vernon", "Verona", "Veronica", "Vesta", "Vicenta", "Vicente", "Vickie", "Vicky", "Victor", "Victoria", "Vida", "Vidal", "Vilma", "Vince", "Vincent", "Vincenza", "Vincenzo", "Vinnie", "Viola", "Violet", "Violette", "Virgie", "Virgil", "Virginia", "Virginie", "Vita", "Vito", "Viva", "Vivian", "Viviane", "Vivianne", "Vivien", "Vivienne", "Vladimir", "Wade", "Waino", "Waldo", "Walker", "Wallace", "Walter", "Walton", "Wanda", "Ward", "Warren", "Watson", "Wava", "Waylon", "Wayne", "Webster", "Weldon", "Wellington", "Wendell", "Wendy", "Werner", "Westley", "Weston", "Whitney", "Wilber", "Wilbert", "Wilburn", "Wiley", "Wilford", "Wilfred", "Wilfredo", "Wilfrid", "Wilhelm", "Wilhelmine", "Will", "Willa", "Willard", "William", "Willie", "Willis", "Willow", "Willy", "Wilma", "Wilmer", "Wilson", "Wilton", "Winfield", "Winifred", "Winnifred", "Winona", "Winston", "Woodrow", "Wyatt", "Wyman", "Xander", "Xavier", "Xzavier", "Yadira", "Yasmeen", "Yasmin", "Yasmine", "Yazmin", "Yesenia", "Yessenia", "Yolanda", "Yoshiko", "Yvette", "Yvonne", "Zachariah", "Zachary", "Zachery", "Zack", "Zackary", "Zackery", "Zakary", "Zander", "Zane", "Zaria", "Zechariah", "Zelda", "Zella", "Zelma", "Zena", "Zetta", "Zion", "Zita", "Zoe", "Zoey", "Zoie", "Zoila", "Zola", "Zora", "Zula"];
                    e.exports = {
                        generateUsername: function() {
                            return `${i.randomElement(s)}-${i.randomAlphanumStr(3)}`
                        }
                    }
                },
                8878: e => {
                    e.exports = {
                        CAMERA: "camera",
                        DESKTOP: "desktop",
                        DESKTOP_HIGH_FPS: "desktop_high_fps",
                        NONE: "none"
                    }
                },
                8774: e => {
                    e.exports = {
                        ENVIRONMENT: "environment",
                        USER: "user"
                    }
                },
                1002: e => {
                    e.exports = {
                        H264: "h264",
                        OPUS: "opus",
                        VP8: "vp8",
                        VP9: "vp9"
                    }
                },
                1435: e => {
                    e.exports = {
                        INACTIVE: "inactive",
                        RECVONLY: "recvonly",
                        SENDONLY: "sendonly",
                        SENDRECV: "sendrecv"
                    }
                },
                3907: e => {
                    e.exports = {
                        CREATE_ANSWER_FAILED: "rtc.create_answer_failed",
                        CREATE_OFFER_FAILED: "rtc.create_offer_failed",
                        DATA_CHANNEL_OPEN: "rtc.data_channel_open",
                        ENDPOINT_CONN_STATUS_CHANGED: "rtc.endpoint_conn_status_changed",
                        DOMINANT_SPEAKER_CHANGED: "rtc.dominant_speaker_changed",
                        LASTN_ENDPOINT_CHANGED: "rtc.lastn_endpoint_changed",
                        PERMISSIONS_CHANGED: "rtc.permissions_changed",
                        SENDER_VIDEO_CONSTRAINTS_CHANGED: "rtc.sender_video_constraints_changed",
                        LASTN_VALUE_CHANGED: "rtc.lastn_value_changed",
                        LOCAL_TRACK_SSRC_UPDATED: "rtc.local_track_ssrc_updated",
                        LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED: "rtc.local_track_max_enabled_resolution_changed",
                        TRACK_ATTACHED: "rtc.track_attached",
                        REMOTE_TRACK_ADDED: "rtc.remote_track_added",
                        REMOTE_TRACK_MUTE: "rtc.remote_track_mute",
                        REMOTE_TRACK_REMOVED: "rtc.remote_track_removed",
                        REMOTE_TRACK_UNMUTE: "rtc.remote_track_unmute",
                        SET_LOCAL_DESCRIPTION_FAILED: "rtc.set_local_description_failed",
                        SET_REMOTE_DESCRIPTION_FAILED: "rtc.set_remote_description_failed",
                        AUDIO_OUTPUT_DEVICE_CHANGED: "rtc.audio_output_device_changed",
                        DEVICE_LIST_CHANGED: "rtc.device_list_changed",
                        DEVICE_LIST_WILL_CHANGE: "rtc.device_list_will_change",
                        DEVICE_LIST_AVAILABLE: "rtc.device_list_available",
                        ENDPOINT_MESSAGE_RECEIVED: "rtc.endpoint_message_received",
                        ENDPOINT_STATS_RECEIVED: "rtc.endpoint_stats_received",
                        LOCAL_UFRAG_CHANGED: "rtc.local_ufrag_changed",
                        REMOTE_UFRAG_CHANGED: "rtc.remote_ufrag_changed"
                    }
                },
                1507: e => {
                    e.exports = {
                        2160: {
                            width: 3840,
                            height: 2160
                        },
                        "4k": {
                            width: 3840,
                            height: 2160
                        },
                        1080: {
                            width: 1920,
                            height: 1080
                        },
                        fullhd: {
                            width: 1920,
                            height: 1080
                        },
                        720: {
                            width: 1280,
                            height: 720
                        },
                        hd: {
                            width: 1280,
                            height: 720
                        },
                        540: {
                            width: 960,
                            height: 540
                        },
                        qhd: {
                            width: 960,
                            height: 540
                        },
                        480: {
                            width: 640,
                            height: 480
                        },
                        vga: {
                            width: 640,
                            height: 480
                        },
                        360: {
                            width: 640,
                            height: 360
                        },
                        240: {
                            width: 320,
                            height: 240
                        },
                        180: {
                            width: 320,
                            height: 180
                        }
                    }
                },
                3714: e => {
                    e.exports = {
                        CAMERA: "camera",
                        DESKTOP: "desktop"
                    }
                },
                702: e => {
                    e.exports = {
                        IDENTITY_UPDATED: "authentication.identity_updated"
                    }
                },
                3523: e => {
                    e.exports = {
                        LOCAL_JID: "local"
                    }
                },
                3786: e => {
                    e.exports = {
                        ADD_ICE_CANDIDATE_FAILED: "xmpp.add_ice_candidate_failed",
                        AUDIO_MUTED_BY_FOCUS: "xmpp.audio_muted_by_focus",
                        VIDEO_MUTED_BY_FOCUS: "xmpp.video_muted_by_focus",
                        AUTHENTICATION_REQUIRED: "xmpp.authentication_required",
                        BRIDGE_DOWN: "xmpp.bridge_down",
                        CALL_ACCEPTED: "xmpp.callaccepted.jingle",
                        CALL_INCOMING: "xmpp.callincoming.jingle",
                        CALL_ENDED: "xmpp.callended.jingle",
                        CHAT_ERROR_RECEIVED: "xmpp.chat_error_received",
                        CONFERENCE_PROPERTIES_CHANGED: "xmpp.conference_properties_changed",
                        CONNECTION_ESTABLISHED: "xmpp.connection.connected",
                        CONNECTION_FAILED: "xmpp.connection.failed",
                        CONNECTION_INTERRUPTED: "xmpp.connection.interrupted",
                        CONNECTION_RESTORED: "xmpp.connection.restored",
                        CONNECTION_ICE_FAILED: "xmpp.connection.ice.failed",
                        CONNECTION_RESTARTED: "xmpp.connection.restart",
                        CONNECTION_STATUS_CHANGED: "xmpp.connection.status.changed",
                        DISPLAY_NAME_CHANGED: "xmpp.display_name_changed",
                        EMUC_ROOM_ADDED: "xmpp.emuc_room_added",
                        EMUC_ROOM_REMOVED: "xmpp.emuc_room_removed",
                        ETHERPAD: "xmpp.etherpad",
                        FOCUS_DISCONNECTED: "xmpp.focus_disconnected",
                        FOCUS_LEFT: "xmpp.focus_left",
                        GRACEFUL_SHUTDOWN: "xmpp.graceful_shutdown",
                        ICE_RESTARTING: "rtc.ice_restarting",
                        ICE_RESTART_SUCCESS: "rtc.ice_restart_success",
                        KICKED: "xmpp.kicked",
                        LOCAL_ROLE_CHANGED: "xmpp.localrole_changed",
                        MEETING_ID_SET: "xmpp.meeting_id_set",
                        MESSAGE_RECEIVED: "xmpp.message_received",
                        INVITE_MESSAGE_RECEIVED: "xmpp.invite_message_received",
                        PRIVATE_MESSAGE_RECEIVED: "xmpp.private_message_received",
                        MUC_MEMBER_BOT_TYPE_CHANGED: "xmpp.muc_member_bot_type_changed",
                        MUC_DESTROYED: "xmpp.muc_destroyed",
                        MUC_JOINED: "xmpp.muc_joined",
                        MUC_MEMBER_JOINED: "xmpp.muc_member_joined",
                        MUC_MEMBER_LEFT: "xmpp.muc_member_left",
                        MUC_LOBBY_MEMBER_JOINED: "xmpp.muc_lobby_member_joined",
                        MUC_LOBBY_MEMBER_UPDATED: "xmpp.muc_lobby_member_updated",
                        MUC_LOBBY_MEMBER_LEFT: "xmpp.muc_lobby_member_left",
                        MUC_DENIED_ACCESS: "xmpp.muc_denied access",
                        MUC_LEFT: "xmpp.muc_left",
                        MUC_ROLE_CHANGED: "xmpp.muc_role_changed",
                        MUC_LOCK_CHANGED: "xmpp.muc_lock_changed",
                        MUC_MEMBERS_ONLY_CHANGED: "xmpp.muc_members_only_changed",
                        PARTICIPANT_AUDIO_MUTED: "xmpp.audio_muted",
                        PARTICIPANT_VIDEO_MUTED: "xmpp.video_muted",
                        PARTICIPANT_VIDEO_TYPE_CHANGED: "xmpp.video_type",
                        PARTICIPANT_FEATURES_CHANGED: "xmpp.participant_features_changed",
                        PASSWORD_REQUIRED: "xmpp.password_required",
                        PHONE_NUMBER_CHANGED: "conference.phoneNumberChanged",
                        PRESENCE_RECEIVED: "xmpp.presence_received",
                        PRESENCE_STATUS: "xmpp.presence_status",
                        PROMPT_FOR_LOGIN: "xmpp.prompt_for_login",
                        READY_TO_JOIN: "xmpp.ready_to_join",
                        RECORDER_STATE_CHANGED: "xmpp.recorderStateChanged",
                        REMOTE_STATS: "xmpp.remote_stats",
                        RENEGOTIATION_FAILED: "xmpp.renegotiation_failed",
                        RESERVATION_ERROR: "xmpp.room_reservation_error",
                        ROOM_CONNECT_ERROR: "xmpp.room_connect_error",
                        ROOM_CONNECT_NOT_ALLOWED_ERROR: "xmpp.room_connect_error.not_allowed",
                        ROOM_JOIN_ERROR: "xmpp.room_join_error",
                        ROOM_CONNECT_MEMBERS_ONLY_ERROR: "xmpp.room_connect_error.members_only",
                        ROOM_MAX_USERS_ERROR: "xmpp.room_max_users_error",
                        SENDING_CHAT_MESSAGE: "xmpp.sending_chat_message",
                        SENDING_PRIVATE_CHAT_MESSAGE: "xmpp.sending_private_chat_message",
                        SESSION_ACCEPT_TIMEOUT: "xmpp.session_accept_timeout",
                        SPEAKER_STATS_RECEIVED: "xmpp.speaker_stats_received",
                        CONFERENCE_TIMESTAMP_RECEIVED: "xmpp.conference_timestamp_received",
                        AV_MODERATION_APPROVED: "xmpp.av_moderation.approved",
                        AV_MODERATION_REJECTED: "xmpp.av_moderation.rejected",
                        AV_MODERATION_RECEIVED: "xmpp.av_moderation.received",
                        AV_MODERATION_CHANGED: "xmpp.av_moderation.changed",
                        AV_MODERATION_PARTICIPANT_APPROVED: "xmpp.av_moderation.participant.approved",
                        AV_MODERATION_PARTICIPANT_REJECTED: "xmpp.av_moderation.participant.rejected",
                        START_MUTED_FROM_FOCUS: "xmpp.start_muted_from_focus",
                        SUBJECT_CHANGED: "xmpp.subject_changed",
                        SUSPEND_DETECTED: "xmpp.suspend_detected",
                        TRANSCRIPTION_STATUS_CHANGED: "xmpp.transcription_status_changed",
                        TRANSPORT_INFO: "xmpp.transportinfo.jingle",
                        VIDEO_SIP_GW_AVAILABILITY_CHANGED: "xmpp.videoSIPGWAvailabilityChanged",
                        VIDEO_SIP_GW_SESSION_STATE_CHANGED: "xmpp.videoSIPGWSessionStateChanged",
                        ICE_CONNECTION_STATE_CHANGED: "xmpp.ice_connection_state_changed",
                        JSON_MESSAGE_RECEIVED: "xmmp.json_message_received"
                    }
                },
                4276: (e, t, n) => {
                    e = n.nmd(e);
                    var i = "__lodash_hash_undefined__",
                        s = 9007199254740991,
                        r = "[object Arguments]",
                        o = "[object Boolean]",
                        a = "[object Date]",
                        c = "[object Function]",
                        d = "[object GeneratorFunction]",
                        l = "[object Map]",
                        h = "[object Number]",
                        u = "[object Object]",
                        p = "[object Promise]",
                        m = "[object RegExp]",
                        f = "[object Set]",
                        g = "[object String]",
                        _ = "[object Symbol]",
                        v = "[object WeakMap]",
                        y = "[object ArrayBuffer]",
                        S = "[object DataView]",
                        E = "[object Float32Array]",
                        b = "[object Float64Array]",
                        C = "[object Int8Array]",
                        T = "[object Int16Array]",
                        R = "[object Int32Array]",
                        A = "[object Uint8Array]",
                        w = "[object Uint8ClampedArray]",
                        P = "[object Uint16Array]",
                        I = "[object Uint32Array]",
                        M = /\w*$/,
                        D = /^\[object .+?Constructor\]$/,
                        N = /^(?:0|[1-9]\d*)$/,
                        k = {};
                    k[r] = k["[object Array]"] = k[y] = k[S] = k[o] = k[a] = k[E] = k[b] = k[C] = k[T] = k[R] = k[l] = k[h] = k[u] = k[m] = k[f] = k[g] = k[_] = k[A] = k[w] = k[P] = k[I] = !0, k["[object Error]"] = k[c] = k[v] = !1;
                    var O = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
                        L = "object" == typeof self && self && self.Object === Object && self,
                        x = O || L || Function("return this")(),
                        F = t && !t.nodeType && t,
                        j = F && e && !e.nodeType && e,
                        $ = j && j.exports === F;

                    function B(e, t) {
                        return e.set(t[0], t[1]), e
                    }

                    function J(e, t) {
                        return e.add(t), e
                    }

                    function U(e, t, n, i) {
                        var s = -1,
                            r = e ? e.length : 0;
                        for (i && r && (n = e[++s]); ++s < r;) n = t(n, e[s], s, e);
                        return n
                    }

                    function V(e) {
                        var t = !1;
                        if (null != e && "function" != typeof e.toString) try {
                            t = !!(e + "")
                        } catch (e) {}
                        return t
                    }

                    function H(e) {
                        var t = -1,
                            n = Array(e.size);
                        return e.forEach((function(e, i) {
                            n[++t] = [i, e]
                        })), n
                    }

                    function G(e, t) {
                        return function(n) {
                            return e(t(n))
                        }
                    }

                    function q(e) {
                        var t = -1,
                            n = Array(e.size);
                        return e.forEach((function(e) {
                            n[++t] = e
                        })), n
                    }
                    var K, z = Array.prototype,
                        W = Function.prototype,
                        Q = Object.prototype,
                        X = x["__core-js_shared__"],
                        Y = (K = /[^.]+$/.exec(X && X.keys && X.keys.IE_PROTO || "")) ? "Symbol(src)_1." + K : "",
                        Z = W.toString,
                        ee = Q.hasOwnProperty,
                        te = Q.toString,
                        ne = RegExp("^" + Z.call(ee).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                        ie = $ ? x.Buffer : void 0,
                        se = x.Symbol,
                        re = x.Uint8Array,
                        oe = G(Object.getPrototypeOf, Object),
                        ae = Object.create,
                        ce = Q.propertyIsEnumerable,
                        de = z.splice,
                        le = Object.getOwnPropertySymbols,
                        he = ie ? ie.isBuffer : void 0,
                        ue = G(Object.keys, Object),
                        pe = xe(x, "DataView"),
                        me = xe(x, "Map"),
                        fe = xe(x, "Promise"),
                        ge = xe(x, "Set"),
                        _e = xe(x, "WeakMap"),
                        ve = xe(Object, "create"),
                        ye = Je(pe),
                        Se = Je(me),
                        Ee = Je(fe),
                        be = Je(ge),
                        Ce = Je(_e),
                        Te = se ? se.prototype : void 0,
                        Re = Te ? Te.valueOf : void 0;

                    function Ae(e) {
                        var t = -1,
                            n = e ? e.length : 0;
                        for (this.clear(); ++t < n;) {
                            var i = e[t];
                            this.set(i[0], i[1])
                        }
                    }

                    function we(e) {
                        var t = -1,
                            n = e ? e.length : 0;
                        for (this.clear(); ++t < n;) {
                            var i = e[t];
                            this.set(i[0], i[1])
                        }
                    }

                    function Pe(e) {
                        var t = -1,
                            n = e ? e.length : 0;
                        for (this.clear(); ++t < n;) {
                            var i = e[t];
                            this.set(i[0], i[1])
                        }
                    }

                    function Ie(e) {
                        this.__data__ = new we(e)
                    }

                    function Me(e, t, n) {
                        var i = e[t];
                        ee.call(e, t) && Ue(i, n) && (void 0 !== n || t in e) || (e[t] = n)
                    }

                    function De(e, t) {
                        for (var n = e.length; n--;)
                            if (Ue(e[n][0], t)) return n;
                        return -1
                    }

                    function Ne(e, t, n, i, s, p, v) {
                        var D;
                        if (i && (D = p ? i(e, s, p, v) : i(e)), void 0 !== D) return D;
                        if (!Ke(e)) return e;
                        var N = Ve(e);
                        if (N) {
                            if (D = function(e) {
                                    var t = e.length,
                                        n = e.constructor(t);
                                    return t && "string" == typeof e[0] && ee.call(e, "index") && (n.index = e.index, n.input = e.input), n
                                }(e), !t) return function(e, t) {
                                var n = -1,
                                    i = e.length;
                                for (t || (t = Array(i)); ++n < i;) t[n] = e[n];
                                return t
                            }(e, D)
                        } else {
                            var O = je(e),
                                L = O == c || O == d;
                            if (Ge(e)) return function(e, t) {
                                if (t) return e.slice();
                                var n = new e.constructor(e.length);
                                return e.copy(n), n
                            }(e, t);
                            if (O == u || O == r || L && !p) {
                                if (V(e)) return p ? e : {};
                                if (D = function(e) {
                                        return "function" != typeof e.constructor || Be(e) ? {} : Ke(t = oe(e)) ? ae(t) : {};
                                        var t
                                    }(L ? {} : e), !t) return function(e, t) {
                                    return Oe(e, Fe(e), t)
                                }(e, function(e, t) {
                                    return e && Oe(t, ze(t), e)
                                }(D, e))
                            } else {
                                if (!k[O]) return p ? e : {};
                                D = function(e, t, n, i) {
                                    var s, r = e.constructor;
                                    switch (t) {
                                        case y:
                                            return ke(e);
                                        case o:
                                        case a:
                                            return new r(+e);
                                        case S:
                                            return function(e, t) {
                                                var n = t ? ke(e.buffer) : e.buffer;
                                                return new e.constructor(n, e.byteOffset, e.byteLength)
                                            }(e, i);
                                        case E:
                                        case b:
                                        case C:
                                        case T:
                                        case R:
                                        case A:
                                        case w:
                                        case P:
                                        case I:
                                            return function(e, t) {
                                                var n = t ? ke(e.buffer) : e.buffer;
                                                return new e.constructor(n, e.byteOffset, e.length)
                                            }(e, i);
                                        case l:
                                            return function(e, t, n) {
                                                return U(t ? n(H(e), !0) : H(e), B, new e.constructor)
                                            }(e, i, n);
                                        case h:
                                        case g:
                                            return new r(e);
                                        case m:
                                            return function(e) {
                                                var t = new e.constructor(e.source, M.exec(e));
                                                return t.lastIndex = e.lastIndex, t
                                            }(e);
                                        case f:
                                            return function(e, t, n) {
                                                return U(t ? n(q(e), !0) : q(e), J, new e.constructor)
                                            }(e, i, n);
                                        case _:
                                            return s = e, Re ? Object(Re.call(s)) : {}
                                    }
                                }(e, O, Ne, t)
                            }
                        }
                        v || (v = new Ie);
                        var x = v.get(e);
                        if (x) return x;
                        if (v.set(e, D), !N) var F = n ? function(e) {
                            return function(e, t, n) {
                                var i = t(e);
                                return Ve(e) ? i : function(e, t) {
                                    for (var n = -1, i = t.length, s = e.length; ++n < i;) e[s + n] = t[n];
                                    return e
                                }(i, n(e))
                            }(e, ze, Fe)
                        }(e) : ze(e);
                        return function(e, t) {
                            for (var n = -1, i = e ? e.length : 0; ++n < i && !1 !== t(e[n], n););
                        }(F || e, (function(s, r) {
                            F && (s = e[r = s]), Me(D, r, Ne(s, t, n, i, r, e, v))
                        })), D
                    }

                    function ke(e) {
                        var t = new e.constructor(e.byteLength);
                        return new re(t).set(new re(e)), t
                    }

                    function Oe(e, t, n, i) {
                        n || (n = {});
                        for (var s = -1, r = t.length; ++s < r;) {
                            var o = t[s],
                                a = i ? i(n[o], e[o], o, n, e) : void 0;
                            Me(n, o, void 0 === a ? e[o] : a)
                        }
                        return n
                    }

                    function Le(e, t) {
                        var n, i, s = e.__data__;
                        return ("string" == (i = typeof(n = t)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? s["string" == typeof t ? "string" : "hash"] : s.map
                    }

                    function xe(e, t) {
                        var n = function(e, t) {
                            return null == e ? void 0 : e[t]
                        }(e, t);
                        return function(e) {
                            return !(!Ke(e) || (t = e, Y && Y in t)) && (qe(e) || V(e) ? ne : D).test(Je(e));
                            var t
                        }(n) ? n : void 0
                    }
                    Ae.prototype.clear = function() {
                        this.__data__ = ve ? ve(null) : {}
                    }, Ae.prototype.delete = function(e) {
                        return this.has(e) && delete this.__data__[e]
                    }, Ae.prototype.get = function(e) {
                        var t = this.__data__;
                        if (ve) {
                            var n = t[e];
                            return n === i ? void 0 : n
                        }
                        return ee.call(t, e) ? t[e] : void 0
                    }, Ae.prototype.has = function(e) {
                        var t = this.__data__;
                        return ve ? void 0 !== t[e] : ee.call(t, e)
                    }, Ae.prototype.set = function(e, t) {
                        return this.__data__[e] = ve && void 0 === t ? i : t, this
                    }, we.prototype.clear = function() {
                        this.__data__ = []
                    }, we.prototype.delete = function(e) {
                        var t = this.__data__,
                            n = De(t, e);
                        return !(n < 0 || (n == t.length - 1 ? t.pop() : de.call(t, n, 1), 0))
                    }, we.prototype.get = function(e) {
                        var t = this.__data__,
                            n = De(t, e);
                        return n < 0 ? void 0 : t[n][1]
                    }, we.prototype.has = function(e) {
                        return De(this.__data__, e) > -1
                    }, we.prototype.set = function(e, t) {
                        var n = this.__data__,
                            i = De(n, e);
                        return i < 0 ? n.push([e, t]) : n[i][1] = t, this
                    }, Pe.prototype.clear = function() {
                        this.__data__ = {
                            hash: new Ae,
                            map: new(me || we),
                            string: new Ae
                        }
                    }, Pe.prototype.delete = function(e) {
                        return Le(this, e).delete(e)
                    }, Pe.prototype.get = function(e) {
                        return Le(this, e).get(e)
                    }, Pe.prototype.has = function(e) {
                        return Le(this, e).has(e)
                    }, Pe.prototype.set = function(e, t) {
                        return Le(this, e).set(e, t), this
                    }, Ie.prototype.clear = function() {
                        this.__data__ = new we
                    }, Ie.prototype.delete = function(e) {
                        return this.__data__.delete(e)
                    }, Ie.prototype.get = function(e) {
                        return this.__data__.get(e)
                    }, Ie.prototype.has = function(e) {
                        return this.__data__.has(e)
                    }, Ie.prototype.set = function(e, t) {
                        var n = this.__data__;
                        if (n instanceof we) {
                            var i = n.__data__;
                            if (!me || i.length < 199) return i.push([e, t]), this;
                            n = this.__data__ = new Pe(i)
                        }
                        return n.set(e, t), this
                    };
                    var Fe = le ? G(le, Object) : function() {
                            return []
                        },
                        je = function(e) {
                            return te.call(e)
                        };

                    function $e(e, t) {
                        return !!(t = null == t ? s : t) && ("number" == typeof e || N.test(e)) && e > -1 && e % 1 == 0 && e < t
                    }

                    function Be(e) {
                        var t = e && e.constructor;
                        return e === ("function" == typeof t && t.prototype || Q)
                    }

                    function Je(e) {
                        if (null != e) {
                            try {
                                return Z.call(e)
                            } catch (e) {}
                            try {
                                return e + ""
                            } catch (e) {}
                        }
                        return ""
                    }

                    function Ue(e, t) {
                        return e === t || e != e && t != t
                    }(pe && je(new pe(new ArrayBuffer(1))) != S || me && je(new me) != l || fe && je(fe.resolve()) != p || ge && je(new ge) != f || _e && je(new _e) != v) && (je = function(e) {
                        var t = te.call(e),
                            n = t == u ? e.constructor : void 0,
                            i = n ? Je(n) : void 0;
                        if (i) switch (i) {
                            case ye:
                                return S;
                            case Se:
                                return l;
                            case Ee:
                                return p;
                            case be:
                                return f;
                            case Ce:
                                return v
                        }
                        return t
                    });
                    var Ve = Array.isArray;

                    function He(e) {
                        return null != e && function(e) {
                            return "number" == typeof e && e > -1 && e % 1 == 0 && e <= s
                        }(e.length) && !qe(e)
                    }
                    var Ge = he || function() {
                        return !1
                    };

                    function qe(e) {
                        var t = Ke(e) ? te.call(e) : "";
                        return t == c || t == d
                    }

                    function Ke(e) {
                        var t = typeof e;
                        return !!e && ("object" == t || "function" == t)
                    }

                    function ze(e) {
                        return He(e) ? function(e, t) {
                            var n = Ve(e) || function(e) {
                                    return function(e) {
                                        return function(e) {
                                            return !!e && "object" == typeof e
                                        }(e) && He(e)
                                    }(e) && ee.call(e, "callee") && (!ce.call(e, "callee") || te.call(e) == r)
                                }(e) ? function(e, t) {
                                    for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
                                    return i
                                }(e.length, String) : [],
                                i = n.length,
                                s = !!i;
                            for (var o in e) !t && !ee.call(e, o) || s && ("length" == o || $e(o, i)) || n.push(o);
                            return n
                        }(e) : function(e) {
                            if (!Be(e)) return ue(e);
                            var t = [];
                            for (var n in Object(e)) ee.call(e, n) && "constructor" != n && t.push(n);
                            return t
                        }(e)
                    }
                    e.exports = function(e) {
                        return Ne(e, !0, !0)
                    }
                },
                6448: (e, t, n) => {
                    var i = /^\s+|\s+$/g,
                        s = /^[-+]0x[0-9a-f]+$/i,
                        r = /^0b[01]+$/i,
                        o = /^0o[0-7]+$/i,
                        a = parseInt,
                        c = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
                        d = "object" == typeof self && self && self.Object === Object && self,
                        l = c || d || Function("return this")(),
                        h = Object.prototype.toString,
                        u = Math.max,
                        p = Math.min,
                        m = function() {
                            return l.Date.now()
                        };

                    function f(e) {
                        var t = typeof e;
                        return !!e && ("object" == t || "function" == t)
                    }

                    function g(e) {
                        if ("number" == typeof e) return e;
                        if (function(e) {
                                return "symbol" == typeof e || function(e) {
                                    return !!e && "object" == typeof e
                                }(e) && "[object Symbol]" == h.call(e)
                            }(e)) return NaN;
                        if (f(e)) {
                            var t = "function" == typeof e.valueOf ? e.valueOf() : e;
                            e = f(t) ? t + "" : t
                        }
                        if ("string" != typeof e) return 0 === e ? e : +e;
                        e = e.replace(i, "");
                        var n = r.test(e);
                        return n || o.test(e) ? a(e.slice(2), n ? 2 : 8) : s.test(e) ? NaN : +e
                    }
                    e.exports = function(e, t, n) {
                        var i, s, r, o, a, c, d = 0,
                            l = !1,
                            h = !1,
                            _ = !0;
                        if ("function" != typeof e) throw new TypeError("Expected a function");

                        function v(t) {
                            var n = i,
                                r = s;
                            return i = s = void 0, d = t, o = e.apply(r, n)
                        }

                        function y(e) {
                            return d = e, a = setTimeout(E, t), l ? v(e) : o
                        }

                        function S(e) {
                            var n = e - c;
                            return void 0 === c || n >= t || n < 0 || h && e - d >= r
                        }

                        function E() {
                            var e = m();
                            if (S(e)) return b(e);
                            a = setTimeout(E, function(e) {
                                var n = t - (e - c);
                                return h ? p(n, r - (e - d)) : n
                            }(e))
                        }

                        function b(e) {
                            return a = void 0, _ && i ? v(e) : (i = s = void 0, o)
                        }

                        function C() {
                            var e = m(),
                                n = S(e);
                            if (i = arguments, s = this, c = e, n) {
                                if (void 0 === a) return y(c);
                                if (h) return a = setTimeout(E, t), v(c)
                            }
                            return void 0 === a && (a = setTimeout(E, t)), o
                        }
                        return t = g(t) || 0, f(n) && (l = !!n.leading, r = (h = "maxWait" in n) ? u(g(n.maxWait) || 0, t) : r, _ = "trailing" in n ? !!n.trailing : _), C.cancel = function() {
                            void 0 !== a && clearTimeout(a), d = 0, i = c = s = a = void 0
                        }, C.flush = function() {
                            return void 0 === a ? o : b(m())
                        }, C
                    }
                },
                6847: (e, t, n) => {
                    e = n.nmd(e);
                    var i = "__lodash_hash_undefined__",
                        s = 9007199254740991,
                        r = "[object Arguments]",
                        o = "[object Array]",
                        a = "[object Boolean]",
                        c = "[object Date]",
                        d = "[object Error]",
                        l = "[object Function]",
                        h = "[object Map]",
                        u = "[object Number]",
                        p = "[object Object]",
                        m = "[object Promise]",
                        f = "[object RegExp]",
                        g = "[object Set]",
                        _ = "[object String]",
                        v = "[object WeakMap]",
                        y = "[object ArrayBuffer]",
                        S = "[object DataView]",
                        E = /^\[object .+?Constructor\]$/,
                        b = /^(?:0|[1-9]\d*)$/,
                        C = {};
                    C["[object Float32Array]"] = C["[object Float64Array]"] = C["[object Int8Array]"] = C["[object Int16Array]"] = C["[object Int32Array]"] = C["[object Uint8Array]"] = C["[object Uint8ClampedArray]"] = C["[object Uint16Array]"] = C["[object Uint32Array]"] = !0, C[r] = C[o] = C[y] = C[a] = C[S] = C[c] = C[d] = C[l] = C[h] = C[u] = C[p] = C[f] = C[g] = C[_] = C[v] = !1;
                    var T = "object" == typeof n.g && n.g && n.g.Object === Object && n.g,
                        R = "object" == typeof self && self && self.Object === Object && self,
                        A = T || R || Function("return this")(),
                        w = t && !t.nodeType && t,
                        P = w && e && !e.nodeType && e,
                        I = P && P.exports === w,
                        M = I && T.process,
                        D = function() {
                            try {
                                return M && M.binding && M.binding("util")
                            } catch (e) {}
                        }(),
                        N = D && D.isTypedArray;

                    function k(e, t) {
                        for (var n = -1, i = null == e ? 0 : e.length; ++n < i;)
                            if (t(e[n], n, e)) return !0;
                        return !1
                    }

                    function O(e) {
                        var t = -1,
                            n = Array(e.size);
                        return e.forEach((function(e, i) {
                            n[++t] = [i, e]
                        })), n
                    }

                    function L(e) {
                        var t = -1,
                            n = Array(e.size);
                        return e.forEach((function(e) {
                            n[++t] = e
                        })), n
                    }
                    var x, F, j, $ = Array.prototype,
                        B = Function.prototype,
                        J = Object.prototype,
                        U = A["__core-js_shared__"],
                        V = B.toString,
                        H = J.hasOwnProperty,
                        G = (x = /[^.]+$/.exec(U && U.keys && U.keys.IE_PROTO || "")) ? "Symbol(src)_1." + x : "",
                        q = J.toString,
                        K = RegExp("^" + V.call(H).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                        z = I ? A.Buffer : void 0,
                        W = A.Symbol,
                        Q = A.Uint8Array,
                        X = J.propertyIsEnumerable,
                        Y = $.splice,
                        Z = W ? W.toStringTag : void 0,
                        ee = Object.getOwnPropertySymbols,
                        te = z ? z.isBuffer : void 0,
                        ne = (F = Object.keys, j = Object, function(e) {
                            return F(j(e))
                        }),
                        ie = Pe(A, "DataView"),
                        se = Pe(A, "Map"),
                        re = Pe(A, "Promise"),
                        oe = Pe(A, "Set"),
                        ae = Pe(A, "WeakMap"),
                        ce = Pe(Object, "create"),
                        de = Ne(ie),
                        le = Ne(se),
                        he = Ne(re),
                        ue = Ne(oe),
                        pe = Ne(ae),
                        me = W ? W.prototype : void 0,
                        fe = me ? me.valueOf : void 0;

                    function ge(e) {
                        var t = -1,
                            n = null == e ? 0 : e.length;
                        for (this.clear(); ++t < n;) {
                            var i = e[t];
                            this.set(i[0], i[1])
                        }
                    }

                    function _e(e) {
                        var t = -1,
                            n = null == e ? 0 : e.length;
                        for (this.clear(); ++t < n;) {
                            var i = e[t];
                            this.set(i[0], i[1])
                        }
                    }

                    function ve(e) {
                        var t = -1,
                            n = null == e ? 0 : e.length;
                        for (this.clear(); ++t < n;) {
                            var i = e[t];
                            this.set(i[0], i[1])
                        }
                    }

                    function ye(e) {
                        var t = -1,
                            n = null == e ? 0 : e.length;
                        for (this.__data__ = new ve; ++t < n;) this.add(e[t])
                    }

                    function Se(e) {
                        var t = this.__data__ = new _e(e);
                        this.size = t.size
                    }

                    function Ee(e, t) {
                        for (var n = e.length; n--;)
                            if (ke(e[n][0], t)) return n;
                        return -1
                    }

                    function be(e) {
                        return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Z && Z in Object(e) ? function(e) {
                            var t = H.call(e, Z),
                                n = e[Z];
                            try {
                                e[Z] = void 0;
                                var i = !0
                            } catch (e) {}
                            var s = q.call(e);
                            return i && (t ? e[Z] = n : delete e[Z]), s
                        }(e) : function(e) {
                            return q.call(e)
                        }(e)
                    }

                    function Ce(e) {
                        return Be(e) && be(e) == r
                    }

                    function Te(e, t, n, i, s) {
                        return e === t || (null == e || null == t || !Be(e) && !Be(t) ? e != e && t != t : function(e, t, n, i, s, l) {
                            var m = Le(e),
                                v = Le(t),
                                E = m ? o : Me(e),
                                b = v ? o : Me(t),
                                C = (E = E == r ? p : E) == p,
                                T = (b = b == r ? p : b) == p,
                                R = E == b;
                            if (R && xe(e)) {
                                if (!xe(t)) return !1;
                                m = !0, C = !1
                            }
                            if (R && !C) return l || (l = new Se), m || Je(e) ? Re(e, t, n, i, s, l) : function(e, t, n, i, s, r, o) {
                                switch (n) {
                                    case S:
                                        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
                                        e = e.buffer, t = t.buffer;
                                    case y:
                                        return !(e.byteLength != t.byteLength || !r(new Q(e), new Q(t)));
                                    case a:
                                    case c:
                                    case u:
                                        return ke(+e, +t);
                                    case d:
                                        return e.name == t.name && e.message == t.message;
                                    case f:
                                    case _:
                                        return e == t + "";
                                    case h:
                                        var l = O;
                                    case g:
                                        var p = 1 & i;
                                        if (l || (l = L), e.size != t.size && !p) return !1;
                                        var m = o.get(e);
                                        if (m) return m == t;
                                        i |= 2, o.set(e, t);
                                        var v = Re(l(e), l(t), i, s, r, o);
                                        return o.delete(e), v;
                                    case "[object Symbol]":
                                        if (fe) return fe.call(e) == fe.call(t)
                                }
                                return !1
                            }(e, t, E, n, i, s, l);
                            if (!(1 & n)) {
                                var A = C && H.call(e, "__wrapped__"),
                                    w = T && H.call(t, "__wrapped__");
                                if (A || w) {
                                    var P = A ? e.value() : e,
                                        I = w ? t.value() : t;
                                    return l || (l = new Se), s(P, I, n, i, l)
                                }
                            }
                            return !!R && (l || (l = new Se), function(e, t, n, i, s, r) {
                                var o = 1 & n,
                                    a = Ae(e),
                                    c = a.length;
                                if (c != Ae(t).length && !o) return !1;
                                for (var d = c; d--;) {
                                    var l = a[d];
                                    if (!(o ? l in t : H.call(t, l))) return !1
                                }
                                var h = r.get(e);
                                if (h && r.get(t)) return h == t;
                                var u = !0;
                                r.set(e, t), r.set(t, e);
                                for (var p = o; ++d < c;) {
                                    var m = e[l = a[d]],
                                        f = t[l];
                                    if (i) var g = o ? i(f, m, l, t, e, r) : i(m, f, l, e, t, r);
                                    if (!(void 0 === g ? m === f || s(m, f, n, i, r) : g)) {
                                        u = !1;
                                        break
                                    }
                                    p || (p = "constructor" == l)
                                }
                                if (u && !p) {
                                    var _ = e.constructor,
                                        v = t.constructor;
                                    _ == v || !("constructor" in e) || !("constructor" in t) || "function" == typeof _ && _ instanceof _ && "function" == typeof v && v instanceof v || (u = !1)
                                }
                                return r.delete(e), r.delete(t), u
                            }(e, t, n, i, s, l))
                        }(e, t, n, i, Te, s))
                    }

                    function Re(e, t, n, i, s, r) {
                        var o = 1 & n,
                            a = e.length,
                            c = t.length;
                        if (a != c && !(o && c > a)) return !1;
                        var d = r.get(e);
                        if (d && r.get(t)) return d == t;
                        var l = -1,
                            h = !0,
                            u = 2 & n ? new ye : void 0;
                        for (r.set(e, t), r.set(t, e); ++l < a;) {
                            var p = e[l],
                                m = t[l];
                            if (i) var f = o ? i(m, p, l, t, e, r) : i(p, m, l, e, t, r);
                            if (void 0 !== f) {
                                if (f) continue;
                                h = !1;
                                break
                            }
                            if (u) {
                                if (!k(t, (function(e, t) {
                                        if (o = t, !u.has(o) && (p === e || s(p, e, n, i, r))) return u.push(t);
                                        var o
                                    }))) {
                                    h = !1;
                                    break
                                }
                            } else if (p !== m && !s(p, m, n, i, r)) {
                                h = !1;
                                break
                            }
                        }
                        return r.delete(e), r.delete(t), h
                    }

                    function Ae(e) {
                        return function(e, t, n) {
                            var i = t(e);
                            return Le(e) ? i : function(e, t) {
                                for (var n = -1, i = t.length, s = e.length; ++n < i;) e[s + n] = t[n];
                                return e
                            }(i, n(e))
                        }(e, Ue, Ie)
                    }

                    function we(e, t) {
                        var n, i, s = e.__data__;
                        return ("string" == (i = typeof(n = t)) || "number" == i || "symbol" == i || "boolean" == i ? "__proto__" !== n : null === n) ? s["string" == typeof t ? "string" : "hash"] : s.map
                    }

                    function Pe(e, t) {
                        var n = function(e, t) {
                            return null == e ? void 0 : e[t]
                        }(e, t);
                        return function(e) {
                            return !(!$e(e) || function(e) {
                                return !!G && G in e
                            }(e)) && (Fe(e) ? K : E).test(Ne(e))
                        }(n) ? n : void 0
                    }
                    ge.prototype.clear = function() {
                        this.__data__ = ce ? ce(null) : {}, this.size = 0
                    }, ge.prototype.delete = function(e) {
                        var t = this.has(e) && delete this.__data__[e];
                        return this.size -= t ? 1 : 0, t
                    }, ge.prototype.get = function(e) {
                        var t = this.__data__;
                        if (ce) {
                            var n = t[e];
                            return n === i ? void 0 : n
                        }
                        return H.call(t, e) ? t[e] : void 0
                    }, ge.prototype.has = function(e) {
                        var t = this.__data__;
                        return ce ? void 0 !== t[e] : H.call(t, e)
                    }, ge.prototype.set = function(e, t) {
                        var n = this.__data__;
                        return this.size += this.has(e) ? 0 : 1, n[e] = ce && void 0 === t ? i : t, this
                    }, _e.prototype.clear = function() {
                        this.__data__ = [], this.size = 0
                    }, _e.prototype.delete = function(e) {
                        var t = this.__data__,
                            n = Ee(t, e);
                        return !(n < 0 || (n == t.length - 1 ? t.pop() : Y.call(t, n, 1), --this.size, 0))
                    }, _e.prototype.get = function(e) {
                        var t = this.__data__,
                            n = Ee(t, e);
                        return n < 0 ? void 0 : t[n][1]
                    }, _e.prototype.has = function(e) {
                        return Ee(this.__data__, e) > -1
                    }, _e.prototype.set = function(e, t) {
                        var n = this.__data__,
                            i = Ee(n, e);
                        return i < 0 ? (++this.size, n.push([e, t])) : n[i][1] = t, this
                    }, ve.prototype.clear = function() {
                        this.size = 0, this.__data__ = {
                            hash: new ge,
                            map: new(se || _e),
                            string: new ge
                        }
                    }, ve.prototype.delete = function(e) {
                        var t = we(this, e).delete(e);
                        return this.size -= t ? 1 : 0, t
                    }, ve.prototype.get = function(e) {
                        return we(this, e).get(e)
                    }, ve.prototype.has = function(e) {
                        return we(this, e).has(e)
                    }, ve.prototype.set = function(e, t) {
                        var n = we(this, e),
                            i = n.size;
                        return n.set(e, t), this.size += n.size == i ? 0 : 1, this
                    }, ye.prototype.add = ye.prototype.push = function(e) {
                        return this.__data__.set(e, i), this
                    }, ye.prototype.has = function(e) {
                        return this.__data__.has(e)
                    }, Se.prototype.clear = function() {
                        this.__data__ = new _e, this.size = 0
                    }, Se.prototype.delete = function(e) {
                        var t = this.__data__,
                            n = t.delete(e);
                        return this.size = t.size, n
                    }, Se.prototype.get = function(e) {
                        return this.__data__.get(e)
                    }, Se.prototype.has = function(e) {
                        return this.__data__.has(e)
                    }, Se.prototype.set = function(e, t) {
                        var n = this.__data__;
                        if (n instanceof _e) {
                            var i = n.__data__;
                            if (!se || i.length < 199) return i.push([e, t]), this.size = ++n.size, this;
                            n = this.__data__ = new ve(i)
                        }
                        return n.set(e, t), this.size = n.size, this
                    };
                    var Ie = ee ? function(e) {
                            return null == e ? [] : (e = Object(e), function(t, n) {
                                for (var i = -1, s = null == t ? 0 : t.length, r = 0, o = []; ++i < s;) {
                                    var a = t[i];
                                    c = a, X.call(e, c) && (o[r++] = a)
                                }
                                var c;
                                return o
                            }(ee(e)))
                        } : function() {
                            return []
                        },
                        Me = be;

                    function De(e, t) {
                        return !!(t = null == t ? s : t) && ("number" == typeof e || b.test(e)) && e > -1 && e % 1 == 0 && e < t
                    }

                    function Ne(e) {
                        if (null != e) {
                            try {
                                return V.call(e)
                            } catch (e) {}
                            try {
                                return e + ""
                            } catch (e) {}
                        }
                        return ""
                    }

                    function ke(e, t) {
                        return e === t || e != e && t != t
                    }(ie && Me(new ie(new ArrayBuffer(1))) != S || se && Me(new se) != h || re && Me(re.resolve()) != m || oe && Me(new oe) != g || ae && Me(new ae) != v) && (Me = function(e) {
                        var t = be(e),
                            n = t == p ? e.constructor : void 0,
                            i = n ? Ne(n) : "";
                        if (i) switch (i) {
                            case de:
                                return S;
                            case le:
                                return h;
                            case he:
                                return m;
                            case ue:
                                return g;
                            case pe:
                                return v
                        }
                        return t
                    });
                    var Oe = Ce(function() {
                            return arguments
                        }()) ? Ce : function(e) {
                            return Be(e) && H.call(e, "callee") && !X.call(e, "callee")
                        },
                        Le = Array.isArray,
                        xe = te || function() {
                            return !1
                        };

                    function Fe(e) {
                        if (!$e(e)) return !1;
                        var t = be(e);
                        return t == l || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t
                    }

                    function je(e) {
                        return "number" == typeof e && e > -1 && e % 1 == 0 && e <= s
                    }

                    function $e(e) {
                        var t = typeof e;
                        return null != e && ("object" == t || "function" == t)
                    }

                    function Be(e) {
                        return null != e && "object" == typeof e
                    }
                    var Je = N ? function(e) {
                        return function(t) {
                            return e(t)
                        }
                    }(N) : function(e) {
                        return Be(e) && je(e.length) && !!C[be(e)]
                    };

                    function Ue(e) {
                        return null != (t = e) && je(t.length) && !Fe(t) ? function(e, t) {
                            var n = Le(e),
                                i = !n && Oe(e),
                                s = !n && !i && xe(e),
                                r = !n && !i && !s && Je(e),
                                o = n || i || s || r,
                                a = o ? function(e, t) {
                                    for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
                                    return i
                                }(e.length, String) : [],
                                c = a.length;
                            for (var d in e) !t && !H.call(e, d) || o && ("length" == d || s && ("offset" == d || "parent" == d) || r && ("buffer" == d || "byteLength" == d || "byteOffset" == d) || De(d, c)) || a.push(d);
                            return a
                        }(e) : function(e) {
                            if (n = (t = e) && t.constructor, t !== ("function" == typeof n && n.prototype || J)) return ne(e);
                            var t, n, i = [];
                            for (var s in Object(e)) H.call(e, s) && "constructor" != s && i.push(s);
                            return i
                        }(e);
                        var t
                    }
                    e.exports = function(e, t) {
                        return Te(e, t)
                    }
                },
                6140: e => {
                    var t = e.exports = {
                        v: [{
                            name: "version",
                            reg: /^(\d*)$/
                        }],
                        o: [{
                            name: "origin",
                            reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
                            names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
                            format: "%s %s %d %s IP%d %s"
                        }],
                        s: [{
                            name: "name"
                        }],
                        i: [{
                            name: "description"
                        }],
                        u: [{
                            name: "uri"
                        }],
                        e: [{
                            name: "email"
                        }],
                        p: [{
                            name: "phone"
                        }],
                        z: [{
                            name: "timezones"
                        }],
                        r: [{
                            name: "repeats"
                        }],
                        t: [{
                            name: "timing",
                            reg: /^(\d*) (\d*)/,
                            names: ["start", "stop"],
                            format: "%d %d"
                        }],
                        c: [{
                            name: "connection",
                            reg: /^IN IP(\d) (\S*)/,
                            names: ["version", "ip"],
                            format: "IN IP%d %s"
                        }],
                        b: [{
                            push: "bandwidth",
                            reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
                            names: ["type", "limit"],
                            format: "%s:%s"
                        }],
                        m: [{
                            reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
                            names: ["type", "port", "protocol", "payloads"],
                            format: "%s %d %s %s"
                        }],
                        a: [{
                            push: "rtp",
                            reg: /^rtpmap:(\d*) ([\w\-\.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
                            names: ["payload", "codec", "rate", "encoding"],
                            format: function(e) {
                                return e.encoding ? "rtpmap:%d %s/%s/%s" : e.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s"
                            }
                        }, {
                            push: "fmtp",
                            reg: /^fmtp:(\d*) ([\S| ]*)/,
                            names: ["payload", "config"],
                            format: "fmtp:%d %s"
                        }, {
                            name: "control",
                            reg: /^control:(.*)/,
                            format: "control:%s"
                        }, {
                            name: "rtcp",
                            reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                            names: ["port", "netType", "ipVer", "address"],
                            format: function(e) {
                                return null != e.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
                            }
                        }, {
                            push: "rtcpFbTrrInt",
                            reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                            names: ["payload", "value"],
                            format: "rtcp-fb:%d trr-int %d"
                        }, {
                            push: "rtcpFb",
                            reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                            names: ["payload", "type", "subtype"],
                            format: function(e) {
                                return null != e.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
                            }
                        }, {
                            push: "ext",
                            reg: /^extmap:(\d+)(?:\/(\w+))? (\S*)(?: (\S*))?/,
                            names: ["value", "direction", "uri", "config"],
                            format: function(e) {
                                return "extmap:%d" + (e.direction ? "/%s" : "%v") + " %s" + (e.config ? " %s" : "")
                            }
                        }, {
                            push: "crypto",
                            reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                            names: ["id", "suite", "config", "sessionConfig"],
                            format: function(e) {
                                return null != e.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
                            }
                        }, {
                            name: "setup",
                            reg: /^setup:(\w*)/,
                            format: "setup:%s"
                        }, {
                            name: "mid",
                            reg: /^mid:([^\s]*)/,
                            format: "mid:%s"
                        }, {
                            name: "msid",
                            reg: /^msid:(.*)/,
                            format: "msid:%s"
                        }, {
                            name: "ptime",
                            reg: /^ptime:(\d*)/,
                            format: "ptime:%d"
                        }, {
                            name: "maxptime",
                            reg: /^maxptime:(\d*)/,
                            format: "maxptime:%d"
                        }, {
                            name: "direction",
                            reg: /^(sendrecv|recvonly|sendonly|inactive)/
                        }, {
                            name: "icelite",
                            reg: /^(ice-lite)/
                        }, {
                            name: "iceUfrag",
                            reg: /^ice-ufrag:(\S*)/,
                            format: "ice-ufrag:%s"
                        }, {
                            name: "icePwd",
                            reg: /^ice-pwd:(\S*)/,
                            format: "ice-pwd:%s"
                        }, {
                            name: "fingerprint",
                            reg: /^fingerprint:(\S*) (\S*)/,
                            names: ["type", "hash"],
                            format: "fingerprint:%s %s"
                        }, {
                            push: "candidates",
                            reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
                            names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
                            format: function(e) {
                                var t = "candidate:%s %d %s %d %s %d typ %s";
                                return t += null != e.raddr ? " raddr %s rport %d" : "%v%v", t += null != e.tcptype ? " tcptype %s" : "%v", null != e.generation && (t += " generation %d"), (t += null != e["network-id"] ? " network-id %d" : "%v") + (null != e["network-cost"] ? " network-cost %d" : "%v")
                            }
                        }, {
                            name: "endOfCandidates",
                            reg: /^(end-of-candidates)/
                        }, {
                            name: "remoteCandidates",
                            reg: /^remote-candidates:(.*)/,
                            format: "remote-candidates:%s"
                        }, {
                            name: "iceOptions",
                            reg: /^ice-options:(\S*)/,
                            format: "ice-options:%s"
                        }, {
                            push: "ssrcs",
                            reg: /^ssrc:(\d*) ([\w_]*)(?::(.*))?/,
                            names: ["id", "attribute", "value"],
                            format: function(e) {
                                var t = "ssrc:%d";
                                return null != e.attribute && (t += " %s", null != e.value && (t += ":%s")), t
                            }
                        }, {
                            push: "ssrcGroups",
                            reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
                            names: ["semantics", "ssrcs"],
                            format: "ssrc-group:%s %s"
                        }, {
                            name: "msidSemantic",
                            reg: /^msid-semantic:\s?(\w*) (\S*)/,
                            names: ["semantic", "token"],
                            format: "msid-semantic: %s %s"
                        }, {
                            push: "groups",
                            reg: /^group:(\w*) (.*)/,
                            names: ["type", "mids"],
                            format: "group:%s %s"
                        }, {
                            name: "rtcpMux",
                            reg: /^(rtcp-mux)/
                        }, {
                            name: "rtcpRsize",
                            reg: /^(rtcp-rsize)/
                        }, {
                            name: "sctpmap",
                            reg: /^sctpmap:([\w_\/]*) (\S*)(?: (\S*))?/,
                            names: ["sctpmapNumber", "app", "maxMessageSize"],
                            format: function(e) {
                                return null != e.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s"
                            }
                        }, {
                            name: "xGoogleFlag",
                            reg: /^x-google-flag:([^\s]*)/,
                            format: "x-google-flag:%s"
                        }, {
                            push: "rids",
                            reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
                            names: ["id", "direction", "params"],
                            format: function(e) {
                                return e.params ? "rid:%s %s %s" : "rid:%s %s"
                            }
                        }, {
                            push: "imageattrs",
                            reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"),
                            names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
                            format: function(e) {
                                return "imageattr:%s %s %s" + (e.dir2 ? " %s %s" : "")
                            }
                        }, {
                            name: "simulcast",
                            reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"),
                            names: ["dir1", "list1", "dir2", "list2"],
                            format: function(e) {
                                return "simulcast:%s %s" + (e.dir2 ? " %s %s" : "")
                            }
                        }, {
                            name: "simulcast_03",
                            reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
                            names: ["value"],
                            format: "simulcast: %s"
                        }, {
                            name: "framerate",
                            reg: /^framerate:(\d+(?:$|\.\d+))/,
                            format: "framerate:%s"
                        }, {
                            push: "invalid",
                            names: ["value"]
                        }]
                    };
                    Object.keys(t).forEach((function(e) {
                        t[e].forEach((function(e) {
                            e.reg || (e.reg = /(.*)/), e.format || (e.format = "%s")
                        }))
                    }))
                },
                1810: (e, t, n) => {
                    var i = n(1106),
                        s = n(9583);
                    t.write = s, t.parse = i.parse, t.parseFmtpConfig = i.parseFmtpConfig, t.parseParams = i.parseParams, t.parsePayloads = i.parsePayloads, t.parseRemoteCandidates = i.parseRemoteCandidates, t.parseImageAttributes = i.parseImageAttributes, t.parseSimulcastStreamList = i.parseSimulcastStreamList
                },
                1106: (e, t, n) => {
                    var i = function(e) {
                            return String(Number(e)) === e ? Number(e) : e
                        },
                        s = function(e, t, n) {
                            var s = e.name && e.names;
                            e.push && !t[e.push] ? t[e.push] = [] : s && !t[e.name] && (t[e.name] = {});
                            var r = e.push ? {} : s ? t[e.name] : t;
                            ! function(e, t, n, s) {
                                if (s && !n) t[s] = i(e[1]);
                                else
                                    for (var r = 0; r < n.length; r += 1) null != e[r + 1] && (t[n[r]] = i(e[r + 1]))
                            }(n.match(e.reg), r, e.names, e.name), e.push && t[e.push].push(r)
                        },
                        r = n(6140),
                        o = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
                    t.parse = function(e) {
                        var t = {},
                            n = [],
                            i = t;
                        return e.split(/(\r\n|\r|\n)/).filter(o).forEach((function(e) {
                            var t = e[0],
                                o = e.slice(2);
                            "m" === t && (n.push({
                                rtp: [],
                                fmtp: []
                            }), i = n[n.length - 1]);
                            for (var a = 0; a < (r[t] || []).length; a += 1) {
                                var c = r[t][a];
                                if (c.reg.test(o)) return s(c, i, o)
                            }
                        })), t.media = n, t
                    };
                    var a = function(e, t) {
                        var n = t.split(/=(.+)/, 2);
                        return 2 === n.length && (e[n[0]] = i(n[1])), e
                    };
                    t.parseParams = function(e) {
                        return e.split(/\;\s?/).reduce(a, {})
                    }, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e) {
                        return e.split(" ").map(Number)
                    }, t.parseRemoteCandidates = function(e) {
                        for (var t = [], n = e.split(" ").map(i), s = 0; s < n.length; s += 3) t.push({
                            component: n[s],
                            ip: n[s + 1],
                            port: n[s + 2]
                        });
                        return t
                    }, t.parseImageAttributes = function(e) {
                        return e.split(" ").map((function(e) {
                            return e.substring(1, e.length - 1).split(",").reduce(a, {})
                        }))
                    }, t.parseSimulcastStreamList = function(e) {
                        return e.split(";").map((function(e) {
                            return e.split(",").map((function(e) {
                                var t, n = !1;
                                return "~" !== e[0] ? t = i(e) : (t = i(e.substring(1, e.length)), n = !0), {
                                    scid: t,
                                    paused: n
                                }
                            }))
                        }))
                    }
                },
                9583: (e, t, n) => {
                    var i = n(6140),
                        s = /%[sdv%]/g,
                        r = function(e) {
                            var t = 1,
                                n = arguments,
                                i = n.length;
                            return e.replace(s, (function(e) {
                                if (t >= i) return e;
                                var s = n[t];
                                switch (t += 1, e) {
                                    case "%%":
                                        return "%";
                                    case "%s":
                                        return String(s);
                                    case "%d":
                                        return Number(s);
                                    case "%v":
                                        return ""
                                }
                            }))
                        },
                        o = function(e, t, n) {
                            var i = [e + "=" + (t.format instanceof Function ? t.format(t.push ? n : n[t.name]) : t.format)];
                            if (t.names)
                                for (var s = 0; s < t.names.length; s += 1) {
                                    var o = t.names[s];
                                    t.name ? i.push(n[t.name][o]) : i.push(n[t.names[s]])
                                } else i.push(n[t.name]);
                            return r.apply(null, i)
                        },
                        a = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
                        c = ["i", "c", "b", "a"];
                    e.exports = function(e, t) {
                        t = t || {}, null == e.version && (e.version = 0), null == e.name && (e.name = " "), e.media.forEach((function(e) {
                            null == e.payloads && (e.payloads = "")
                        }));
                        var n = t.outerOrder || a,
                            s = t.innerOrder || c,
                            r = [];
                        return n.forEach((function(t) {
                            i[t].forEach((function(n) {
                                n.name in e && null != e[n.name] ? r.push(o(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                                    r.push(o(t, n, e))
                                }))
                            }))
                        })), e.media.forEach((function(e) {
                            r.push(o("m", i.m[0], e)), s.forEach((function(t) {
                                i[t].forEach((function(n) {
                                    n.name in e && null != e[n.name] ? r.push(o(t, n, e)) : n.push in e && null != e[n.push] && e[n.push].forEach((function(e) {
                                        r.push(o(t, n, e))
                                    }))
                                }))
                            }))
                        })), r.join("\r\n") + "\r\n"
                    }
                },
                5952: e => {
                    "use strict";
                    const t = {
                        generateIdentifier: function() {
                            return Math.random().toString(36).substr(2, 10)
                        }
                    };
                    t.localCName = t.generateIdentifier(), t.splitLines = function(e) {
                        return e.trim().split("\n").map((e => e.trim()))
                    }, t.splitSections = function(e) {
                        return e.split("\nm=").map(((e, t) => (t > 0 ? "m=" + e : e).trim() + "\r\n"))
                    }, t.getDescription = function(e) {
                        const n = t.splitSections(e);
                        return n && n[0]
                    }, t.getMediaSections = function(e) {
                        const n = t.splitSections(e);
                        return n.shift(), n
                    }, t.matchPrefix = function(e, n) {
                        return t.splitLines(e).filter((e => 0 === e.indexOf(n)))
                    }, t.parseCandidate = function(e) {
                        let t;
                        t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" ");
                        const n = {
                            foundation: t[0],
                            component: {
                                1: "rtp",
                                2: "rtcp"
                            } [t[1]] || t[1],
                            protocol: t[2].toLowerCase(),
                            priority: parseInt(t[3], 10),
                            ip: t[4],
                            address: t[4],
                            port: parseInt(t[5], 10),
                            type: t[7]
                        };
                        for (let e = 8; e < t.length; e += 2) switch (t[e]) {
                            case "raddr":
                                n.relatedAddress = t[e + 1];
                                break;
                            case "rport":
                                n.relatedPort = parseInt(t[e + 1], 10);
                                break;
                            case "tcptype":
                                n.tcpType = t[e + 1];
                                break;
                            case "ufrag":
                                n.ufrag = t[e + 1], n.usernameFragment = t[e + 1];
                                break;
                            default:
                                void 0 === n[t[e]] && (n[t[e]] = t[e + 1])
                        }
                        return n
                    }, t.writeCandidate = function(e) {
                        const t = [];
                        t.push(e.foundation);
                        const n = e.component;
                        "rtp" === n ? t.push(1) : "rtcp" === n ? t.push(2) : t.push(n), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port);
                        const i = e.type;
                        return t.push("typ"), t.push(i), "host" !== i && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ")
                    }, t.parseIceOptions = function(e) {
                        return e.substr(14).split(" ")
                    }, t.parseRtpMap = function(e) {
                        let t = e.substr(9).split(" ");
                        const n = {
                            payloadType: parseInt(t.shift(), 10)
                        };
                        return t = t[0].split("/"), n.name = t[0], n.clockRate = parseInt(t[1], 10), n.channels = 3 === t.length ? parseInt(t[2], 10) : 1, n.numChannels = n.channels, n
                    }, t.writeRtpMap = function(e) {
                        let t = e.payloadType;
                        void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);
                        const n = e.channels || e.numChannels || 1;
                        return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== n ? "/" + n : "") + "\r\n"
                    }, t.parseExtmap = function(e) {
                        const t = e.substr(9).split(" ");
                        return {
                            id: parseInt(t[0], 10),
                            direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv",
                            uri: t[1]
                        }
                    }, t.writeExtmap = function(e) {
                        return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n"
                    }, t.parseFmtp = function(e) {
                        const t = {};
                        let n;
                        const i = e.substr(e.indexOf(" ") + 1).split(";");
                        for (let e = 0; e < i.length; e++) n = i[e].trim().split("="), t[n[0].trim()] = n[1];
                        return t
                    }, t.writeFmtp = function(e) {
                        let t = "",
                            n = e.payloadType;
                        if (void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
                            const i = [];
                            Object.keys(e.parameters).forEach((t => {
                                void 0 !== e.parameters[t] ? i.push(t + "=" + e.parameters[t]) : i.push(t)
                            })), t += "a=fmtp:" + n + " " + i.join(";") + "\r\n"
                        }
                        return t
                    }, t.parseRtcpFb = function(e) {
                        const t = e.substr(e.indexOf(" ") + 1).split(" ");
                        return {
                            type: t.shift(),
                            parameter: t.join(" ")
                        }
                    }, t.writeRtcpFb = function(e) {
                        let t = "",
                            n = e.payloadType;
                        return void 0 !== e.preferredPayloadType && (n = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach((e => {
                            t += "a=rtcp-fb:" + n + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n"
                        })), t
                    }, t.parseSsrcMedia = function(e) {
                        const t = e.indexOf(" "),
                            n = {
                                ssrc: parseInt(e.substr(7, t - 7), 10)
                            },
                            i = e.indexOf(":", t);
                        return i > -1 ? (n.attribute = e.substr(t + 1, i - t - 1), n.value = e.substr(i + 1)) : n.attribute = e.substr(t + 1), n
                    }, t.parseSsrcGroup = function(e) {
                        const t = e.substr(13).split(" ");
                        return {
                            semantics: t.shift(),
                            ssrcs: t.map((e => parseInt(e, 10)))
                        }
                    }, t.getMid = function(e) {
                        const n = t.matchPrefix(e, "a=mid:")[0];
                        if (n) return n.substr(6)
                    }, t.parseFingerprint = function(e) {
                        const t = e.substr(14).split(" ");
                        return {
                            algorithm: t[0].toLowerCase(),
                            value: t[1].toUpperCase()
                        }
                    }, t.getDtlsParameters = function(e, n) {
                        return {
                            role: "auto",
                            fingerprints: t.matchPrefix(e + n, "a=fingerprint:").map(t.parseFingerprint)
                        }
                    }, t.writeDtlsParameters = function(e, t) {
                        let n = "a=setup:" + t + "\r\n";
                        return e.fingerprints.forEach((e => {
                            n += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n"
                        })), n
                    }, t.parseCryptoLine = function(e) {
                        const t = e.substr(9).split(" ");
                        return {
                            tag: parseInt(t[0], 10),
                            cryptoSuite: t[1],
                            keyParams: t[2],
                            sessionParams: t.slice(3)
                        }
                    }, t.writeCryptoLine = function(e) {
                        return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" == typeof e.keyParams ? t.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n"
                    }, t.parseCryptoKeyParams = function(e) {
                        if (0 !== e.indexOf("inline:")) return null;
                        const t = e.substr(7).split("|");
                        return {
                            keyMethod: "inline",
                            keySalt: t[0],
                            lifeTime: t[1],
                            mkiValue: t[2] ? t[2].split(":")[0] : void 0,
                            mkiLength: t[2] ? t[2].split(":")[1] : void 0
                        }
                    }, t.writeCryptoKeyParams = function(e) {
                        return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "")
                    }, t.getCryptoParameters = function(e, n) {
                        return t.matchPrefix(e + n, "a=crypto:").map(t.parseCryptoLine)
                    }, t.getIceParameters = function(e, n) {
                        const i = t.matchPrefix(e + n, "a=ice-ufrag:")[0],
                            s = t.matchPrefix(e + n, "a=ice-pwd:")[0];
                        return i && s ? {
                            usernameFragment: i.substr(12),
                            password: s.substr(10)
                        } : null
                    }, t.writeIceParameters = function(e) {
                        let t = "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n";
                        return e.iceLite && (t += "a=ice-lite\r\n"), t
                    }, t.parseRtpParameters = function(e) {
                        const n = {
                                codecs: [],
                                headerExtensions: [],
                                fecMechanisms: [],
                                rtcp: []
                            },
                            i = t.splitLines(e)[0].split(" ");
                        for (let s = 3; s < i.length; s++) {
                            const r = i[s],
                                o = t.matchPrefix(e, "a=rtpmap:" + r + " ")[0];
                            if (o) {
                                const i = t.parseRtpMap(o),
                                    s = t.matchPrefix(e, "a=fmtp:" + r + " ");
                                switch (i.parameters = s.length ? t.parseFmtp(s[0]) : {}, i.rtcpFeedback = t.matchPrefix(e, "a=rtcp-fb:" + r + " ").map(t.parseRtcpFb), n.codecs.push(i), i.name.toUpperCase()) {
                                    case "RED":
                                    case "ULPFEC":
                                        n.fecMechanisms.push(i.name.toUpperCase())
                                }
                            }
                        }
                        return t.matchPrefix(e, "a=extmap:").forEach((e => {
                            n.headerExtensions.push(t.parseExtmap(e))
                        })), n
                    }, t.writeRtpDescription = function(e, n) {
                        let i = "";
                        i += "m=" + e + " ", i += n.codecs.length > 0 ? "9" : "0", i += " UDP/TLS/RTP/SAVPF ", i += n.codecs.map((e => void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType)).join(" ") + "\r\n", i += "c=IN IP4 0.0.0.0\r\n", i += "a=rtcp:9 IN IP4 0.0.0.0\r\n", n.codecs.forEach((e => {
                            i += t.writeRtpMap(e), i += t.writeFmtp(e), i += t.writeRtcpFb(e)
                        }));
                        let s = 0;
                        return n.codecs.forEach((e => {
                            e.maxptime > s && (s = e.maxptime)
                        })), s > 0 && (i += "a=maxptime:" + s + "\r\n"), n.headerExtensions && n.headerExtensions.forEach((e => {
                            i += t.writeExtmap(e)
                        })), i
                    }, t.parseRtpEncodingParameters = function(e) {
                        const n = [],
                            i = t.parseRtpParameters(e),
                            s = -1 !== i.fecMechanisms.indexOf("RED"),
                            r = -1 !== i.fecMechanisms.indexOf("ULPFEC"),
                            o = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "cname" === e.attribute)),
                            a = o.length > 0 && o[0].ssrc;
                        let c;
                        const d = t.matchPrefix(e, "a=ssrc-group:FID").map((e => e.substr(17).split(" ").map((e => parseInt(e, 10)))));
                        d.length > 0 && d[0].length > 1 && d[0][0] === a && (c = d[0][1]), i.codecs.forEach((e => {
                            if ("RTX" === e.name.toUpperCase() && e.parameters.apt) {
                                let t = {
                                    ssrc: a,
                                    codecPayloadType: parseInt(e.parameters.apt, 10)
                                };
                                a && c && (t.rtx = {
                                    ssrc: c
                                }), n.push(t), s && (t = JSON.parse(JSON.stringify(t)), t.fec = {
                                    ssrc: a,
                                    mechanism: r ? "red+ulpfec" : "red"
                                }, n.push(t))
                            }
                        })), 0 === n.length && a && n.push({
                            ssrc: a
                        });
                        let l = t.matchPrefix(e, "b=");
                        return l.length && (l = 0 === l[0].indexOf("b=TIAS:") ? parseInt(l[0].substr(7), 10) : 0 === l[0].indexOf("b=AS:") ? 1e3 * parseInt(l[0].substr(5), 10) * .95 - 16e3 : void 0, n.forEach((e => {
                            e.maxBitrate = l
                        }))), n
                    }, t.parseRtcpParameters = function(e) {
                        const n = {},
                            i = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "cname" === e.attribute))[0];
                        i && (n.cname = i.value, n.ssrc = i.ssrc);
                        const s = t.matchPrefix(e, "a=rtcp-rsize");
                        n.reducedSize = s.length > 0, n.compound = 0 === s.length;
                        const r = t.matchPrefix(e, "a=rtcp-mux");
                        return n.mux = r.length > 0, n
                    }, t.writeRtcpParameters = function(e) {
                        let t = "";
                        return e.reducedSize && (t += "a=rtcp-rsize\r\n"), e.mux && (t += "a=rtcp-mux\r\n"), void 0 !== e.ssrc && e.cname && (t += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"), t
                    }, t.parseMsid = function(e) {
                        let n;
                        const i = t.matchPrefix(e, "a=msid:");
                        if (1 === i.length) return n = i[0].substr(7).split(" "), {
                            stream: n[0],
                            track: n[1]
                        };
                        const s = t.matchPrefix(e, "a=ssrc:").map((e => t.parseSsrcMedia(e))).filter((e => "msid" === e.attribute));
                        return s.length > 0 ? (n = s[0].value.split(" "), {
                            stream: n[0],
                            track: n[1]
                        }) : void 0
                    }, t.parseSctpDescription = function(e) {
                        const n = t.parseMLine(e),
                            i = t.matchPrefix(e, "a=max-message-size:");
                        let s;
                        i.length > 0 && (s = parseInt(i[0].substr(19), 10)), isNaN(s) && (s = 65536);
                        const r = t.matchPrefix(e, "a=sctp-port:");
                        if (r.length > 0) return {
                            port: parseInt(r[0].substr(12), 10),
                            protocol: n.fmt,
                            maxMessageSize: s
                        };
                        const o = t.matchPrefix(e, "a=sctpmap:");
                        if (o.length > 0) {
                            const e = o[0].substr(10).split(" ");
                            return {
                                port: parseInt(e[0], 10),
                                protocol: e[1],
                                maxMessageSize: s
                            }
                        }
                    }, t.writeSctpDescription = function(e, t) {
                        let n = [];
                        return n = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && n.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), n.join("")
                    }, t.generateSessionId = function() {
                        return Math.random().toString().substr(2, 21)
                    }, t.writeSessionBoilerplate = function(e, n, i) {
                        let s;
                        const r = void 0 !== n ? n : 2;
                        return s = e || t.generateSessionId(), "v=0\r\no=" + (i || "thisisadapterortc") + " " + s + " " + r + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"
                    }, t.getDirection = function(e, n) {
                        const i = t.splitLines(e);
                        for (let e = 0; e < i.length; e++) switch (i[e]) {
                            case "a=sendrecv":
                            case "a=sendonly":
                            case "a=recvonly":
                            case "a=inactive":
                                return i[e].substr(2)
                        }
                        return n ? t.getDirection(n) : "sendrecv"
                    }, t.getKind = function(e) {
                        return t.splitLines(e)[0].split(" ")[0].substr(2)
                    }, t.isRejected = function(e) {
                        return "0" === e.split(" ", 2)[1]
                    }, t.parseMLine = function(e) {
                        const n = t.splitLines(e)[0].substr(2).split(" ");
                        return {
                            kind: n[0],
                            port: parseInt(n[1], 10),
                            protocol: n[2],
                            fmt: n.slice(3).join(" ")
                        }
                    }, t.parseOLine = function(e) {
                        const n = t.matchPrefix(e, "o=")[0].substr(2).split(" ");
                        return {
                            username: n[0],
                            sessionId: n[1],
                            sessionVersion: parseInt(n[2], 10),
                            netType: n[3],
                            addressType: n[4],
                            address: n[5]
                        }
                    }, t.isValidSDP = function(e) {
                        if ("string" != typeof e || 0 === e.length) return !1;
                        const n = t.splitLines(e);
                        for (let e = 0; e < n.length; e++)
                            if (n[e].length < 2 || "=" !== n[e].charAt(1)) return !1;
                        return !0
                    }, e.exports = t
                },
                9230: function(e, t, n) {
                    e.exports = function() {
                        "use strict";
                        var e = void 0 !== n.g ? n.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};

                        function t(e) {
                            return t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                return typeof e
                            } : function(e) {
                                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                            }, t(e)
                        }

                        function i(e) {
                            return function(e) {
                                if (Array.isArray(e)) {
                                    for (var t = 0, n = new Array(e.length); t < e.length; t++) n[t] = e[t];
                                    return n
                                }
                            }(e) || function(e) {
                                if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
                            }(e) || function() {
                                throw new TypeError("Invalid attempt to spread non-iterable instance")
                            }()
                        }
                        var s = function(e, t) {
                                var n = (65535 & e) + (65535 & t);
                                return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                            },
                            r = function(e) {
                                if ("string" != typeof e) throw new Error("str2binl was passed a non-string");
                                for (var t = [], n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << n % 32;
                                return t
                            },
                            o = function(e, t, n, i, r, o) {
                                return s((a = s(s(t, e), s(i, o))) << (c = r) | a >>> 32 - c, n);
                                var a, c
                            },
                            a = function(e, t, n, i, s, r, a) {
                                return o(t & n | ~t & i, e, t, s, r, a)
                            },
                            c = function(e, t, n, i, s, r, a) {
                                return o(t & i | n & ~i, e, t, s, r, a)
                            },
                            d = function(e, t, n, i, s, r, a) {
                                return o(t ^ n ^ i, e, t, s, r, a)
                            },
                            l = function(e, t, n, i, s, r, a) {
                                return o(n ^ (t | ~i), e, t, s, r, a)
                            },
                            h = function(e, t) {
                                e[t >> 5] |= 128 << t % 32, e[14 + (t + 64 >>> 9 << 4)] = t;
                                for (var n, i, r, o, h = 1732584193, u = -271733879, p = -1732584194, m = 271733878, f = 0; f < e.length; f += 16) n = h, i = u, r = p, o = m, h = a(h, u, p, m, e[f + 0], 7, -680876936), m = a(m, h, u, p, e[f + 1], 12, -389564586), p = a(p, m, h, u, e[f + 2], 17, 606105819), u = a(u, p, m, h, e[f + 3], 22, -1044525330), h = a(h, u, p, m, e[f + 4], 7, -176418897), m = a(m, h, u, p, e[f + 5], 12, 1200080426), p = a(p, m, h, u, e[f + 6], 17, -1473231341), u = a(u, p, m, h, e[f + 7], 22, -45705983), h = a(h, u, p, m, e[f + 8], 7, 1770035416), m = a(m, h, u, p, e[f + 9], 12, -1958414417), p = a(p, m, h, u, e[f + 10], 17, -42063), u = a(u, p, m, h, e[f + 11], 22, -1990404162), h = a(h, u, p, m, e[f + 12], 7, 1804603682), m = a(m, h, u, p, e[f + 13], 12, -40341101), p = a(p, m, h, u, e[f + 14], 17, -1502002290), u = a(u, p, m, h, e[f + 15], 22, 1236535329), h = c(h, u, p, m, e[f + 1], 5, -165796510), m = c(m, h, u, p, e[f + 6], 9, -1069501632), p = c(p, m, h, u, e[f + 11], 14, 643717713), u = c(u, p, m, h, e[f + 0], 20, -373897302), h = c(h, u, p, m, e[f + 5], 5, -701558691), m = c(m, h, u, p, e[f + 10], 9, 38016083), p = c(p, m, h, u, e[f + 15], 14, -660478335), u = c(u, p, m, h, e[f + 4], 20, -405537848), h = c(h, u, p, m, e[f + 9], 5, 568446438), m = c(m, h, u, p, e[f + 14], 9, -1019803690), p = c(p, m, h, u, e[f + 3], 14, -187363961), u = c(u, p, m, h, e[f + 8], 20, 1163531501), h = c(h, u, p, m, e[f + 13], 5, -1444681467), m = c(m, h, u, p, e[f + 2], 9, -51403784), p = c(p, m, h, u, e[f + 7], 14, 1735328473), u = c(u, p, m, h, e[f + 12], 20, -1926607734), h = d(h, u, p, m, e[f + 5], 4, -378558), m = d(m, h, u, p, e[f + 8], 11, -2022574463), p = d(p, m, h, u, e[f + 11], 16, 1839030562), u = d(u, p, m, h, e[f + 14], 23, -35309556), h = d(h, u, p, m, e[f + 1], 4, -1530992060), m = d(m, h, u, p, e[f + 4], 11, 1272893353), p = d(p, m, h, u, e[f + 7], 16, -155497632), u = d(u, p, m, h, e[f + 10], 23, -1094730640), h = d(h, u, p, m, e[f + 13], 4, 681279174), m = d(m, h, u, p, e[f + 0], 11, -358537222), p = d(p, m, h, u, e[f + 3], 16, -722521979), u = d(u, p, m, h, e[f + 6], 23, 76029189), h = d(h, u, p, m, e[f + 9], 4, -640364487), m = d(m, h, u, p, e[f + 12], 11, -421815835), p = d(p, m, h, u, e[f + 15], 16, 530742520), u = d(u, p, m, h, e[f + 2], 23, -995338651), h = l(h, u, p, m, e[f + 0], 6, -198630844), m = l(m, h, u, p, e[f + 7], 10, 1126891415), p = l(p, m, h, u, e[f + 14], 15, -1416354905), u = l(u, p, m, h, e[f + 5], 21, -57434055), h = l(h, u, p, m, e[f + 12], 6, 1700485571), m = l(m, h, u, p, e[f + 3], 10, -1894986606), p = l(p, m, h, u, e[f + 10], 15, -1051523), u = l(u, p, m, h, e[f + 1], 21, -2054922799), h = l(h, u, p, m, e[f + 8], 6, 1873313359), m = l(m, h, u, p, e[f + 15], 10, -30611744), p = l(p, m, h, u, e[f + 6], 15, -1560198380), u = l(u, p, m, h, e[f + 13], 21, 1309151649), h = l(h, u, p, m, e[f + 4], 6, -145523070), m = l(m, h, u, p, e[f + 11], 10, -1120210379), p = l(p, m, h, u, e[f + 2], 15, 718787259), u = l(u, p, m, h, e[f + 9], 21, -343485551), h = s(h, n), u = s(u, i), p = s(p, r), m = s(m, o);
                                return [h, u, p, m]
                            },
                            u = {
                                hexdigest: function(e) {
                                    return function(e) {
                                        for (var t = "0123456789abcdef", n = "", i = 0; i < 4 * e.length; i++) n += t.charAt(e[i >> 2] >> i % 4 * 8 + 4 & 15) + t.charAt(e[i >> 2] >> i % 4 * 8 & 15);
                                        return n
                                    }(h(r(e), 8 * e.length))
                                },
                                hash: function(e) {
                                    return function(e) {
                                        for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> n % 32 & 255);
                                        return t
                                    }(h(r(e), 8 * e.length))
                                }
                            };

                        function p(e, t) {
                            e[t >> 5] |= 128 << 24 - t % 32, e[15 + (t + 64 >> 9 << 4)] = t;
                            var n, i, s, r, o, a, c, d, l = new Array(80),
                                h = 1732584193,
                                u = -271733879,
                                p = -1732584194,
                                g = 271733878,
                                y = -1009589776;
                            for (n = 0; n < e.length; n += 16) {
                                for (r = h, o = u, a = p, c = g, d = y, i = 0; i < 80; i++) l[i] = i < 16 ? e[n + i] : v(l[i - 3] ^ l[i - 8] ^ l[i - 14] ^ l[i - 16], 1), s = _(_(v(h, 5), m(i, u, p, g)), _(_(y, l[i]), f(i))), y = g, g = p, p = v(u, 30), u = h, h = s;
                                h = _(h, r), u = _(u, o), p = _(p, a), g = _(g, c), y = _(y, d)
                            }
                            return [h, u, p, g, y]
                        }

                        function m(e, t, n, i) {
                            return e < 20 ? t & n | ~t & i : e < 40 ? t ^ n ^ i : e < 60 ? t & n | t & i | n & i : t ^ n ^ i
                        }

                        function f(e) {
                            return e < 20 ? 1518500249 : e < 40 ? 1859775393 : e < 60 ? -1894007588 : -899497514
                        }

                        function g(e, t) {
                            var n = y(e);
                            n.length > 16 && (n = p(n, 8 * e.length));
                            for (var i = new Array(16), s = new Array(16), r = 0; r < 16; r++) i[r] = 909522486 ^ n[r], s[r] = 1549556828 ^ n[r];
                            var o = p(i.concat(y(t)), 512 + 8 * t.length);
                            return p(s.concat(o), 672)
                        }

                        function _(e, t) {
                            var n = (65535 & e) + (65535 & t);
                            return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                        }

                        function v(e, t) {
                            return e << t | e >>> 32 - t
                        }

                        function y(e) {
                            for (var t = [], n = 0; n < 8 * e.length; n += 8) t[n >> 5] |= (255 & e.charCodeAt(n / 8)) << 24 - n % 32;
                            return t
                        }

                        function S(e) {
                            for (var t, n, i = "", s = 0; s < 4 * e.length; s += 3)
                                for (t = (e[s >> 2] >> 8 * (3 - s % 4) & 255) << 16 | (e[s + 1 >> 2] >> 8 * (3 - (s + 1) % 4) & 255) << 8 | e[s + 2 >> 2] >> 8 * (3 - (s + 2) % 4) & 255, n = 0; n < 4; n++) 8 * s + 6 * n > 32 * e.length ? i += "=" : i += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(t >> 6 * (3 - n) & 63);
                            return i
                        }

                        function E(e) {
                            for (var t = "", n = 0; n < 32 * e.length; n += 8) t += String.fromCharCode(e[n >> 5] >>> 24 - n % 32 & 255);
                            return t
                        }
                        var b = {
                                b64_hmac_sha1: function(e, t) {
                                    return S(g(e, t))
                                },
                                b64_sha1: function(e) {
                                    return S(p(y(e), 8 * e.length))
                                },
                                binb2str: E,
                                core_hmac_sha1: g,
                                str_hmac_sha1: function(e, t) {
                                    return E(g(e, t))
                                },
                                str_sha1: function(e) {
                                    return E(p(y(e), 8 * e.length))
                                }
                            },
                            C = function(e) {
                                var t, n, i = "",
                                    s = e.length;
                                for (t = 0; t < s; t++)(n = e.charCodeAt(t)) >= 0 && n <= 127 ? i += e.charAt(t) : n > 2047 ? (i += String.fromCharCode(224 | n >> 12 & 15), i += String.fromCharCode(128 | n >> 6 & 63), i += String.fromCharCode(128 | n >> 0 & 63)) : (i += String.fromCharCode(192 | n >> 6 & 31), i += String.fromCharCode(128 | n >> 0 & 63));
                                return i
                            },
                            T = function(e) {
                                for (var n in e = e || {})
                                    if (Object.prototype.hasOwnProperty.call(e, n)) {
                                        var i = "",
                                            s = "",
                                            r = "",
                                            o = e[n],
                                            a = "object" === t(o),
                                            c = escape(unescape(a ? o.value : o));
                                        a && (i = o.expires ? ";expires=" + o.expires : "", s = o.domain ? ";domain=" + o.domain : "", r = o.path ? ";path=" + o.path : ""), document.cookie = n + "=" + c + i + s + r
                                    }
                            };

                        function R(e, t) {
                            return new P.Builder(e, t)
                        }

                        function A(e) {
                            return new P.Builder("iq", e)
                        }

                        function w(e) {
                            return new P.Builder("presence", e)
                        }
                        var P = {
                            VERSION: "@VERSION@",
                            NS: {
                                HTTPBIND: "http://jabber.org/protocol/httpbind",
                                BOSH: "urn:xmpp:xbosh",
                                CLIENT: "jabber:client",
                                AUTH: "jabber:iq:auth",
                                ROSTER: "jabber:iq:roster",
                                PROFILE: "jabber:iq:profile",
                                DISCO_INFO: "http://jabber.org/protocol/disco#info",
                                DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
                                MUC: "http://jabber.org/protocol/muc",
                                SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
                                STREAM: "http://etherx.jabber.org/streams",
                                FRAMING: "urn:ietf:params:xml:ns:xmpp-framing",
                                BIND: "urn:ietf:params:xml:ns:xmpp-bind",
                                SESSION: "urn:ietf:params:xml:ns:xmpp-session",
                                VERSION: "jabber:iq:version",
                                STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas",
                                XHTML_IM: "http://jabber.org/protocol/xhtml-im",
                                XHTML: "http://www.w3.org/1999/xhtml"
                            },
                            XHTML: {
                                tags: ["a", "blockquote", "br", "cite", "em", "img", "li", "ol", "p", "span", "strong", "ul", "body"],
                                attributes: {
                                    a: ["href"],
                                    blockquote: ["style"],
                                    br: [],
                                    cite: ["style"],
                                    em: [],
                                    img: ["src", "alt", "style", "height", "width"],
                                    li: ["style"],
                                    ol: ["style"],
                                    p: ["style"],
                                    span: ["style"],
                                    strong: [],
                                    ul: ["style"],
                                    body: []
                                },
                                css: ["background-color", "color", "font-family", "font-size", "font-style", "font-weight", "margin-left", "margin-right", "text-align", "text-decoration"],
                                validTag: function(e) {
                                    for (var t = 0; t < P.XHTML.tags.length; t++)
                                        if (e === P.XHTML.tags[t]) return !0;
                                    return !1
                                },
                                validAttribute: function(e, t) {
                                    if (void 0 !== P.XHTML.attributes[e] && P.XHTML.attributes[e].length > 0)
                                        for (var n = 0; n < P.XHTML.attributes[e].length; n++)
                                            if (t === P.XHTML.attributes[e][n]) return !0;
                                    return !1
                                },
                                validCSS: function(e) {
                                    for (var t = 0; t < P.XHTML.css.length; t++)
                                        if (e === P.XHTML.css[t]) return !0;
                                    return !1
                                }
                            },
                            Status: {
                                ERROR: 0,
                                CONNECTING: 1,
                                CONNFAIL: 2,
                                AUTHENTICATING: 3,
                                AUTHFAIL: 4,
                                CONNECTED: 5,
                                DISCONNECTED: 6,
                                DISCONNECTING: 7,
                                ATTACHED: 8,
                                REDIRECT: 9,
                                CONNTIMEOUT: 10,
                                BINDREQUIRED: 11
                            },
                            ErrorCondition: {
                                BAD_FORMAT: "bad-format",
                                CONFLICT: "conflict",
                                MISSING_JID_NODE: "x-strophe-bad-non-anon-jid",
                                NO_AUTH_MECH: "no-auth-mech",
                                UNKNOWN_REASON: "unknown"
                            },
                            LogLevel: {
                                DEBUG: 0,
                                INFO: 1,
                                WARN: 2,
                                ERROR: 3,
                                FATAL: 4
                            },
                            ElementType: {
                                NORMAL: 1,
                                TEXT: 3,
                                CDATA: 4,
                                FRAGMENT: 11
                            },
                            TIMEOUT: 1.1,
                            SECONDARY_TIMEOUT: .1,
                            addNamespace: function(e, t) {
                                P.NS[e] = t
                            },
                            forEachChild: function(e, t, n) {
                                for (var i = 0; i < e.childNodes.length; i++) {
                                    var s = e.childNodes[i];
                                    s.nodeType !== P.ElementType.NORMAL || t && !this.isTagEqual(s, t) || n(s)
                                }
                            },
                            isTagEqual: function(e, t) {
                                return e.tagName === t
                            },
                            _xmlGenerator: null,
                            _makeGenerator: function() {
                                var e;
                                return void 0 === document.implementation.createDocument || document.implementation.createDocument && document.documentMode && document.documentMode < 10 ? (e = this._getIEXmlDom()).appendChild(e.createElement("strophe")) : e = document.implementation.createDocument("jabber:client", "strophe", null), e
                            },
                            xmlGenerator: function() {
                                return P._xmlGenerator || (P._xmlGenerator = P._makeGenerator()), P._xmlGenerator
                            },
                            _getIEXmlDom: function() {
                                for (var e = null, t = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"], n = 0; n < t.length && null === e; n++) try {
                                    e = new ActiveXObject(t[n])
                                } catch (t) {
                                    e = null
                                }
                                return e
                            },
                            xmlElement: function(e) {
                                if (!e) return null;
                                for (var n = P.xmlGenerator().createElement(e), i = 1; i < arguments.length; i++) {
                                    var s = arguments[i];
                                    if (s)
                                        if ("string" == typeof s || "number" == typeof s) n.appendChild(P.xmlTextNode(s));
                                        else if ("object" === t(s) && "function" == typeof s.sort)
                                        for (var r = 0; r < s.length; r++) {
                                            var o = s[r];
                                            "object" === t(o) && "function" == typeof o.sort && void 0 !== o[1] && null !== o[1] && n.setAttribute(o[0], o[1])
                                        } else if ("object" === t(s))
                                            for (var a in s) Object.prototype.hasOwnProperty.call(s, a) && void 0 !== s[a] && null !== s[a] && n.setAttribute(a, s[a])
                                }
                                return n
                            },
                            xmlescape: function(e) {
                                return (e = (e = (e = (e = e.replace(/\&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/'/g, "&apos;")).replace(/"/g, "&quot;")
                            },
                            xmlunescape: function(e) {
                                return (e = (e = (e = (e = e.replace(/\&amp;/g, "&")).replace(/&lt;/g, "<")).replace(/&gt;/g, ">")).replace(/&apos;/g, "'")).replace(/&quot;/g, '"')
                            },
                            xmlTextNode: function(e) {
                                return P.xmlGenerator().createTextNode(e)
                            },
                            xmlHtmlNode: function(e) {
                                var t;
                                return DOMParser ? t = (new DOMParser).parseFromString(e, "text/xml") : ((t = new ActiveXObject("Microsoft.XMLDOM")).async = "false", t.loadXML(e)), t
                            },
                            getText: function(e) {
                                if (!e) return null;
                                var t = "";
                                0 === e.childNodes.length && e.nodeType === P.ElementType.TEXT && (t += e.nodeValue);
                                for (var n = 0; n < e.childNodes.length; n++) e.childNodes[n].nodeType === P.ElementType.TEXT && (t += e.childNodes[n].nodeValue);
                                return P.xmlescape(t)
                            },
                            copyElement: function(e) {
                                var t;
                                if (e.nodeType === P.ElementType.NORMAL) {
                                    t = P.xmlElement(e.tagName);
                                    for (var n = 0; n < e.attributes.length; n++) t.setAttribute(e.attributes[n].nodeName, e.attributes[n].value);
                                    for (var i = 0; i < e.childNodes.length; i++) t.appendChild(P.copyElement(e.childNodes[i]))
                                } else e.nodeType === P.ElementType.TEXT && (t = P.xmlGenerator().createTextNode(e.nodeValue));
                                return t
                            },
                            createHtml: function(e) {
                                var n;
                                if (e.nodeType === P.ElementType.NORMAL) {
                                    var i = e.nodeName.toLowerCase();
                                    if (P.XHTML.validTag(i)) try {
                                        n = P.xmlElement(i);
                                        for (var s = 0; s < P.XHTML.attributes[i].length; s++) {
                                            var r = P.XHTML.attributes[i][s],
                                                o = e.getAttribute(r);
                                            if (null != o && "" !== o && !1 !== o && 0 !== o)
                                                if ("style" === r && "object" === t(o) && void 0 !== o.cssText && (o = o.cssText), "style" === r) {
                                                    for (var a = [], c = o.split(";"), d = 0; d < c.length; d++) {
                                                        var l = c[d].split(":"),
                                                            h = l[0].replace(/^\s*/, "").replace(/\s*$/, "").toLowerCase();
                                                        if (P.XHTML.validCSS(h)) {
                                                            var u = l[1].replace(/^\s*/, "").replace(/\s*$/, "");
                                                            a.push(h + ": " + u)
                                                        }
                                                    }
                                                    a.length > 0 && (o = a.join("; "), n.setAttribute(r, o))
                                                } else n.setAttribute(r, o)
                                        }
                                        for (var p = 0; p < e.childNodes.length; p++) n.appendChild(P.createHtml(e.childNodes[p]))
                                    } catch (e) {
                                        n = P.xmlTextNode("")
                                    } else {
                                        n = P.xmlGenerator().createDocumentFragment();
                                        for (var m = 0; m < e.childNodes.length; m++) n.appendChild(P.createHtml(e.childNodes[m]))
                                    }
                                } else if (e.nodeType === P.ElementType.FRAGMENT) {
                                    n = P.xmlGenerator().createDocumentFragment();
                                    for (var f = 0; f < e.childNodes.length; f++) n.appendChild(P.createHtml(e.childNodes[f]))
                                } else e.nodeType === P.ElementType.TEXT && (n = P.xmlTextNode(e.nodeValue));
                                return n
                            },
                            escapeNode: function(e) {
                                return "string" != typeof e ? e : e.replace(/^\s+|\s+$/g, "").replace(/\\/g, "\\5c").replace(/ /g, "\\20").replace(/\"/g, "\\22").replace(/\&/g, "\\26").replace(/\'/g, "\\27").replace(/\//g, "\\2f").replace(/:/g, "\\3a").replace(/</g, "\\3c").replace(/>/g, "\\3e").replace(/@/g, "\\40")
                            },
                            unescapeNode: function(e) {
                                return "string" != typeof e ? e : e.replace(/\\20/g, " ").replace(/\\22/g, '"').replace(/\\26/g, "&").replace(/\\27/g, "'").replace(/\\2f/g, "/").replace(/\\3a/g, ":").replace(/\\3c/g, "<").replace(/\\3e/g, ">").replace(/\\40/g, "@").replace(/\\5c/g, "\\")
                            },
                            getNodeFromJid: function(e) {
                                return e.indexOf("@") < 0 ? null : e.split("@")[0]
                            },
                            getDomainFromJid: function(e) {
                                var t = P.getBareJidFromJid(e);
                                if (t.indexOf("@") < 0) return t;
                                var n = t.split("@");
                                return n.splice(0, 1), n.join("@")
                            },
                            getResourceFromJid: function(e) {
                                if (!e) return null;
                                var t = e.split("/");
                                return t.length < 2 ? null : (t.splice(0, 1), t.join("/"))
                            },
                            getBareJidFromJid: function(e) {
                                return e ? e.split("/")[0] : null
                            },
                            _handleError: function(e) {
                                void 0 !== e.stack && P.fatal(e.stack), e.sourceURL ? P.fatal("error: " + this.handler + " " + e.sourceURL + ":" + e.line + " - " + e.name + ": " + e.message) : e.fileName ? P.fatal("error: " + this.handler + " " + e.fileName + ":" + e.lineNumber + " - " + e.name + ": " + e.message) : P.fatal("error: " + e.message)
                            },
                            log: function(e, n) {
                                e === this.LogLevel.FATAL && "object" === t(window.console) && "function" == typeof window.console.error && window.console.error(n)
                            },
                            debug: function(e) {
                                this.log(this.LogLevel.DEBUG, e)
                            },
                            info: function(e) {
                                this.log(this.LogLevel.INFO, e)
                            },
                            warn: function(e) {
                                this.log(this.LogLevel.WARN, e)
                            },
                            error: function(e) {
                                this.log(this.LogLevel.ERROR, e)
                            },
                            fatal: function(e) {
                                this.log(this.LogLevel.FATAL, e)
                            },
                            serialize: function(e) {
                                if (!e) return null;
                                "function" == typeof e.tree && (e = e.tree());
                                var t = i(Array(e.attributes.length).keys()).map((function(t) {
                                    return e.attributes[t].nodeName
                                }));
                                t.sort();
                                var n = t.reduce((function(t, n) {
                                    return "".concat(t, " ").concat(n, '="').concat(P.xmlescape(e.attributes.getNamedItem(n).value), '"')
                                }), "<".concat(e.nodeName));
                                if (e.childNodes.length > 0) {
                                    n += ">";
                                    for (var s = 0; s < e.childNodes.length; s++) {
                                        var r = e.childNodes[s];
                                        switch (r.nodeType) {
                                            case P.ElementType.NORMAL:
                                                n += P.serialize(r);
                                                break;
                                            case P.ElementType.TEXT:
                                                n += P.xmlescape(r.nodeValue);
                                                break;
                                            case P.ElementType.CDATA:
                                                n += "<![CDATA[" + r.nodeValue + "]]>"
                                        }
                                    }
                                    n += "</" + e.nodeName + ">"
                                } else n += "/>";
                                return n
                            },
                            _requestId: 0,
                            _connectionPlugins: {},
                            addConnectionPlugin: function(e, t) {
                                P._connectionPlugins[e] = t
                            },
                            Builder: function(e, t) {
                                "presence" !== e && "message" !== e && "iq" !== e || (t && !t.xmlns ? t.xmlns = P.NS.CLIENT : t || (t = {
                                    xmlns: P.NS.CLIENT
                                })), this.nodeTree = P.xmlElement(e, t), this.node = this.nodeTree
                            }
                        };
                        P.Builder.prototype = {
                            tree: function() {
                                return this.nodeTree
                            },
                            toString: function() {
                                return P.serialize(this.nodeTree)
                            },
                            up: function() {
                                return this.node = this.node.parentNode, this
                            },
                            root: function() {
                                return this.node = this.nodeTree, this
                            },
                            attrs: function(e) {
                                for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (void 0 === e[t] ? this.node.removeAttribute(t) : this.node.setAttribute(t, e[t]));
                                return this
                            },
                            c: function(e, t, n) {
                                var i = P.xmlElement(e, t, n);
                                return this.node.appendChild(i), "string" != typeof n && "number" != typeof n && (this.node = i), this
                            },
                            cnode: function(e) {
                                var t, n = P.xmlGenerator();
                                try {
                                    t = void 0 !== n.importNode
                                } catch (e) {
                                    t = !1
                                }
                                var i = t ? n.importNode(e, !0) : P.copyElement(e);
                                return this.node.appendChild(i), this.node = i, this
                            },
                            t: function(e) {
                                var t = P.xmlTextNode(e);
                                return this.node.appendChild(t), this
                            },
                            h: function(e) {
                                var t = document.createElement("body");
                                t.innerHTML = e;
                                for (var n = P.createHtml(t); n.childNodes.length > 0;) this.node.appendChild(n.childNodes[0]);
                                return this
                            }
                        }, P.Handler = function(e, t, n, i, s, r, o) {
                            this.handler = e, this.ns = t, this.name = n, this.type = i, this.id = s, this.options = o || {
                                matchBareFromJid: !1,
                                ignoreNamespaceFragment: !1
                            }, this.options.matchBare && (P.warn('The "matchBare" option is deprecated, use "matchBareFromJid" instead.'), this.options.matchBareFromJid = this.options.matchBare, delete this.options.matchBare), this.options.matchBareFromJid ? this.from = r ? P.getBareJidFromJid(r) : null : this.from = r, this.user = !0
                        }, P.Handler.prototype = {
                            getNamespace: function(e) {
                                var t = e.getAttribute("xmlns");
                                return t && this.options.ignoreNamespaceFragment && (t = t.split("#")[0]), t
                            },
                            namespaceMatch: function(e) {
                                var t = this,
                                    n = !1;
                                return !this.ns || (P.forEachChild(e, null, (function(e) {
                                    t.getNamespace(e) === t.ns && (n = !0)
                                })), n || this.getNamespace(e) === this.ns)
                            },
                            isMatch: function(e) {
                                var t = e.getAttribute("from");
                                this.options.matchBareFromJid && (t = P.getBareJidFromJid(t));
                                var n = e.getAttribute("type");
                                return !(!this.namespaceMatch(e) || this.name && !P.isTagEqual(e, this.name) || this.type && (Array.isArray(this.type) ? -1 === this.type.indexOf(n) : n !== this.type) || this.id && e.getAttribute("id") !== this.id || this.from && t !== this.from)
                            },
                            run: function(e) {
                                var t = null;
                                try {
                                    t = this.handler(e)
                                } catch (e) {
                                    throw P._handleError(e), e
                                }
                                return t
                            },
                            toString: function() {
                                return "{Handler: " + this.handler + "(" + this.name + "," + this.id + "," + this.ns + ")}"
                            }
                        }, P.TimedHandler = function(e, t) {
                            this.period = e, this.handler = t, this.lastCalled = (new Date).getTime(), this.user = !0
                        }, P.TimedHandler.prototype = {
                            run: function() {
                                return this.lastCalled = (new Date).getTime(), this.handler()
                            },
                            reset: function() {
                                this.lastCalled = (new Date).getTime()
                            },
                            toString: function() {
                                return "{TimedHandler: " + this.handler + "(" + this.period + ")}"
                            }
                        }, P.Connection = function(e, t) {
                            var n = this;
                            this.service = e, this.options = t || {};
                            var i = this.options.protocol || "";
                            for (var s in 0 === e.indexOf("ws:") || 0 === e.indexOf("wss:") || 0 === i.indexOf("ws") ? this._proto = new P.Websocket(this) : this._proto = new P.Bosh(this), this.jid = "", this.domain = null, this.features = null, this._sasl_data = {}, this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.protocolErrorHandlers = {
                                    HTTP: {},
                                    websocket: {}
                                }, this._idleTimeout = null, this._disconnectTimeout = null, this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.do_authentication = !0, this.paused = !1, this.restored = !1, this._data = [], this._uniqueId = 0, this._sasl_success_handler = null, this._sasl_failure_handler = null, this._sasl_challenge_handler = null, this.maxRetries = 5, this._idleTimeout = setTimeout((function() {
                                    return n._onIdle()
                                }), 100), T(this.options.cookies), this.registerSASLMechanisms(this.options.mechanisms), P._connectionPlugins)
                                if (Object.prototype.hasOwnProperty.call(P._connectionPlugins, s)) {
                                    var r = function() {};
                                    r.prototype = P._connectionPlugins[s], this[s] = new r, this[s].init(this)
                                }
                        }, P.Connection.prototype = {
                            reset: function() {
                                this._proto._reset(), this.do_session = !1, this.do_bind = !1, this.timedHandlers = [], this.handlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this.authenticated = !1, this.connected = !1, this.disconnecting = !1, this.restored = !1, this._data = [], this._requests = [], this._uniqueId = 0
                            },
                            pause: function() {
                                this.paused = !0
                            },
                            resume: function() {
                                this.paused = !1
                            },
                            getUniqueId: function(e) {
                                var t = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(e) {
                                    var t = 16 * Math.random() | 0;
                                    return ("x" === e ? t : 3 & t | 8).toString(16)
                                }));
                                return "string" == typeof e || "number" == typeof e ? t + ":" + e : t + ""
                            },
                            addProtocolErrorHandler: function(e, t, n) {
                                this.protocolErrorHandlers[e][t] = n
                            },
                            connect: function(e, t, n, i, s, r, o) {
                                this.jid = e, this.authzid = P.getBareJidFromJid(this.jid), this.authcid = o || P.getNodeFromJid(this.jid), this.pass = t, this.servtype = "xmpp", this.connect_callback = n, this.disconnecting = !1, this.connected = !1, this.authenticated = !1, this.restored = !1, this.domain = P.getDomainFromJid(this.jid), this._changeConnectStatus(P.Status.CONNECTING, null), this._proto._connect(i, s, r)
                            },
                            attach: function(e, t, n, i, s, r, o) {
                                if (!(this._proto instanceof P.Bosh)) {
                                    var a = new Error('The "attach" method can only be used with a BOSH connection.');
                                    throw a.name = "StropheSessionError", a
                                }
                                this._proto._attach(e, t, n, i, s, r, o)
                            },
                            restore: function(e, t, n, i, s) {
                                if (!this._sessionCachingSupported()) {
                                    var r = new Error('The "restore" method can only be used with a BOSH connection.');
                                    throw r.name = "StropheSessionError", r
                                }
                                this._proto._restore(e, t, n, i, s)
                            },
                            _sessionCachingSupported: function() {
                                if (this._proto instanceof P.Bosh) {
                                    if (!JSON) return !1;
                                    try {
                                        sessionStorage.setItem("_strophe_", "_strophe_"), sessionStorage.removeItem("_strophe_")
                                    } catch (e) {
                                        return !1
                                    }
                                    return !0
                                }
                                return !1
                            },
                            xmlInput: function(e) {},
                            xmlOutput: function(e) {},
                            rawInput: function(e) {},
                            rawOutput: function(e) {},
                            nextValidRid: function(e) {},
                            send: function(e) {
                                if (null !== e) {
                                    if ("function" == typeof e.sort)
                                        for (var t = 0; t < e.length; t++) this._queueData(e[t]);
                                    else "function" == typeof e.tree ? this._queueData(e.tree()) : this._queueData(e);
                                    this._proto._send()
                                }
                            },
                            flush: function() {
                                clearTimeout(this._idleTimeout), this._onIdle()
                            },
                            sendPresence: function(e, t, n, i) {
                                var s = this,
                                    r = null;
                                "function" == typeof e.tree && (e = e.tree());
                                var o = e.getAttribute("id");
                                if (o || (o = this.getUniqueId("sendPresence"), e.setAttribute("id", o)), "function" == typeof t || "function" == typeof n) {
                                    var a = this.addHandler((function(e) {
                                        r && s.deleteTimedHandler(r), "error" === e.getAttribute("type") ? n && n(e) : t && t(e)
                                    }), null, "presence", null, o);
                                    i && (r = this.addTimedHandler(i, (function() {
                                        return s.deleteHandler(a), n && n(null), !1
                                    })))
                                }
                                return this.send(e), o
                            },
                            sendIQ: function(e, t, n, i) {
                                var s = this,
                                    r = null;
                                "function" == typeof e.tree && (e = e.tree());
                                var o = e.getAttribute("id");
                                if (o || (o = this.getUniqueId("sendIQ"), e.setAttribute("id", o)), "function" == typeof t || "function" == typeof n) {
                                    var a = this.addHandler((function(e) {
                                        r && s.deleteTimedHandler(r);
                                        var i = e.getAttribute("type");
                                        if ("result" === i) t && t(e);
                                        else {
                                            if ("error" !== i) {
                                                var o = new Error("Got bad IQ type of ".concat(i));
                                                throw o.name = "StropheError", o
                                            }
                                            n && n(e)
                                        }
                                    }), null, "iq", ["error", "result"], o);
                                    i && (r = this.addTimedHandler(i, (function() {
                                        return s.deleteHandler(a), n && n(null), !1
                                    })))
                                }
                                return this.send(e), o
                            },
                            _queueData: function(e) {
                                if (null === e || !e.tagName || !e.childNodes) {
                                    var t = new Error("Cannot queue non-DOMElement.");
                                    throw t.name = "StropheError", t
                                }
                                this._data.push(e)
                            },
                            _sendRestart: function() {
                                var e = this;
                                this._data.push("restart"), this._proto._sendRestart(), this._idleTimeout = setTimeout((function() {
                                    return e._onIdle()
                                }), 100)
                            },
                            addTimedHandler: function(e, t) {
                                var n = new P.TimedHandler(e, t);
                                return this.addTimeds.push(n), n
                            },
                            deleteTimedHandler: function(e) {
                                this.removeTimeds.push(e)
                            },
                            addHandler: function(e, t, n, i, s, r, o) {
                                var a = new P.Handler(e, t, n, i, s, r, o);
                                return this.addHandlers.push(a), a
                            },
                            deleteHandler: function(e) {
                                this.removeHandlers.push(e);
                                var t = this.addHandlers.indexOf(e);
                                t >= 0 && this.addHandlers.splice(t, 1)
                            },
                            registerSASLMechanisms: function(e) {
                                this.mechanisms = {}, (e = e || [P.SASLAnonymous, P.SASLExternal, P.SASLMD5, P.SASLOAuthBearer, P.SASLXOAuth2, P.SASLPlain, P.SASLSHA1]).forEach(this.registerSASLMechanism.bind(this))
                            },
                            registerSASLMechanism: function(e) {
                                this.mechanisms[e.prototype.name] = e
                            },
                            disconnect: function(e) {
                                if (this._changeConnectStatus(P.Status.DISCONNECTING, e), P.warn("Disconnect was called because: " + e), this.connected) {
                                    var t = !1;
                                    this.disconnecting = !0, this.authenticated && (t = w({
                                        xmlns: P.NS.CLIENT,
                                        type: "unavailable"
                                    })), this._disconnectTimeout = this._addSysTimedHandler(3e3, this._onDisconnectTimeout.bind(this)), this._proto._disconnect(t)
                                } else P.warn("Disconnect was called before Strophe connected to the server"), this._proto._abortAllRequests(), this._doDisconnect()
                            },
                            _changeConnectStatus: function(e, t, n) {
                                for (var i in P._connectionPlugins)
                                    if (Object.prototype.hasOwnProperty.call(P._connectionPlugins, i)) {
                                        var s = this[i];
                                        if (s.statusChanged) try {
                                            s.statusChanged(e, t)
                                        } catch (e) {
                                            P.error("".concat(i, " plugin caused an exception changing status: ").concat(e))
                                        }
                                    } if (this.connect_callback) try {
                                    this.connect_callback(e, t, n)
                                } catch (e) {
                                    P._handleError(e), P.error("User connection callback caused an exception: ".concat(e))
                                }
                            },
                            _doDisconnect: function(e) {
                                "number" == typeof this._idleTimeout && clearTimeout(this._idleTimeout), null !== this._disconnectTimeout && (this.deleteTimedHandler(this._disconnectTimeout), this._disconnectTimeout = null), P.debug("_doDisconnect was called"), this._proto._doDisconnect(), this.authenticated = !1, this.disconnecting = !1, this.restored = !1, this.handlers = [], this.timedHandlers = [], this.removeTimeds = [], this.removeHandlers = [], this.addTimeds = [], this.addHandlers = [], this._changeConnectStatus(P.Status.DISCONNECTED, e), this.connected = !1
                            },
                            _dataRecv: function(e, t) {
                                var n = this;
                                P.debug("_dataRecv called");
                                var i = this._proto._reqToData(e);
                                if (null !== i) {
                                    for (this.xmlInput !== P.Connection.prototype.xmlInput && (i.nodeName === this._proto.strip && i.childNodes.length ? this.xmlInput(i.childNodes[0]) : this.xmlInput(i)), this.rawInput !== P.Connection.prototype.rawInput && (t ? this.rawInput(t) : this.rawInput(P.serialize(i))); this.removeHandlers.length > 0;) {
                                        var s = this.removeHandlers.pop(),
                                            r = this.handlers.indexOf(s);
                                        r >= 0 && this.handlers.splice(r, 1)
                                    }
                                    for (; this.addHandlers.length > 0;) this.handlers.push(this.addHandlers.pop());
                                    if (this.disconnecting && this._proto._emptyQueue()) this._doDisconnect();
                                    else {
                                        var o = i.getAttribute("type");
                                        if (null !== o && "terminate" === o) {
                                            if (this.disconnecting) return;
                                            var a = i.getAttribute("condition"),
                                                c = i.getElementsByTagName("conflict");
                                            return null !== a ? ("remote-stream-error" === a && c.length > 0 && (a = "conflict"), this._changeConnectStatus(P.Status.CONNFAIL, a)) : this._changeConnectStatus(P.Status.CONNFAIL, P.ErrorCondition.UNKOWN_REASON), void this._doDisconnect(a)
                                        }
                                        P.forEachChild(i, null, (function(e) {
                                            var t = n.handlers;
                                            n.handlers = [];
                                            for (var i = 0; i < t.length; i++) {
                                                var s = t[i];
                                                try {
                                                    (!s.isMatch(e) || !n.authenticated && s.user || s.run(e)) && n.handlers.push(s)
                                                } catch (e) {
                                                    P.warn("Removing Strophe handlers due to uncaught exception: " + e.message)
                                                }
                                            }
                                        }))
                                    }
                                }
                            },
                            mechanisms: {},
                            _connect_cb: function(e, t, n) {
                                var i;
                                P.debug("_connect_cb was called"), this.connected = !0;
                                try {
                                    i = this._proto._reqToData(e)
                                } catch (e) {
                                    if (e.name !== P.ErrorCondition.BAD_FORMAT) throw e;
                                    this._changeConnectStatus(P.Status.CONNFAIL, P.ErrorCondition.BAD_FORMAT), this._doDisconnect(P.ErrorCondition.BAD_FORMAT)
                                }
                                if (i && (this.xmlInput !== P.Connection.prototype.xmlInput && (i.nodeName === this._proto.strip && i.childNodes.length ? this.xmlInput(i.childNodes[0]) : this.xmlInput(i)), this.rawInput !== P.Connection.prototype.rawInput && (n ? this.rawInput(n) : this.rawInput(P.serialize(i))), this._proto._connect_cb(i) !== P.Status.CONNFAIL))
                                    if (i.getElementsByTagNameNS ? i.getElementsByTagNameNS(P.NS.STREAM, "features").length > 0 : i.getElementsByTagName("stream:features").length > 0 || i.getElementsByTagName("features").length > 0) {
                                        var s = [],
                                            r = i.getElementsByTagName("mechanism");
                                        if (r.length > 0)
                                            for (var o = 0; o < r.length; o++) {
                                                var a = P.getText(r[o]);
                                                this.mechanisms[a] && s.push(this.mechanisms[a])
                                            }
                                        0 !== s.length || 0 !== i.getElementsByTagName("auth").length ? !1 !== this.do_authentication && this.authenticate(s) : this._proto._no_auth_received(t)
                                    } else this._proto._no_auth_received(t)
                            },
                            sortMechanismsByPriority: function(e) {
                                for (var t = 0; t < e.length - 1; ++t) {
                                    for (var n = t, i = t + 1; i < e.length; ++i) e[i].prototype.priority > e[n].prototype.priority && (n = i);
                                    if (n !== t) {
                                        var s = e[t];
                                        e[t] = e[n], e[n] = s
                                    }
                                }
                                return e
                            },
                            authenticate: function(e) {
                                this._attemptSASLAuth(e) || this._attemptLegacyAuth()
                            },
                            _attemptSASLAuth: function(e) {
                                e = this.sortMechanismsByPriority(e || []);
                                for (var t = !1, n = 0; n < e.length; ++n)
                                    if (e[n].prototype.test(this)) {
                                        this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, "success", null, null), this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, "failure", null, null), this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, "challenge", null, null), this._sasl_mechanism = new e[n], this._sasl_mechanism.onStart(this);
                                        var i = R("auth", {
                                            xmlns: P.NS.SASL,
                                            mechanism: this._sasl_mechanism.name
                                        });
                                        if (this._sasl_mechanism.isClientFirst) {
                                            var s = this._sasl_mechanism.onChallenge(this, null);
                                            i.t(btoa(s))
                                        }
                                        this.send(i.tree()), t = !0;
                                        break
                                    } return t
                            },
                            _sasl_challenge_cb: function(e) {
                                var t = atob(P.getText(e)),
                                    n = this._sasl_mechanism.onChallenge(this, t),
                                    i = R("response", {
                                        xmlns: P.NS.SASL
                                    });
                                return "" !== n && i.t(btoa(n)), this.send(i.tree()), !0
                            },
                            _attemptLegacyAuth: function() {
                                null === P.getNodeFromJid(this.jid) ? (this._changeConnectStatus(P.Status.CONNFAIL, P.ErrorCondition.MISSING_JID_NODE), this.disconnect(P.ErrorCondition.MISSING_JID_NODE)) : (this._changeConnectStatus(P.Status.AUTHENTICATING, null), this._addSysHandler(this._onLegacyAuthIQResult.bind(this), null, null, null, "_auth_1"), this.send(A({
                                    type: "get",
                                    to: this.domain,
                                    id: "_auth_1"
                                }).c("query", {
                                    xmlns: P.NS.AUTH
                                }).c("username", {}).t(P.getNodeFromJid(this.jid)).tree()))
                            },
                            _onLegacyAuthIQResult: function(e) {
                                var t = A({
                                    type: "set",
                                    id: "_auth_2"
                                }).c("query", {
                                    xmlns: P.NS.AUTH
                                }).c("username", {}).t(P.getNodeFromJid(this.jid)).up().c("password").t(this.pass);
                                return P.getResourceFromJid(this.jid) || (this.jid = P.getBareJidFromJid(this.jid) + "/strophe"), t.up().c("resource", {}).t(P.getResourceFromJid(this.jid)), this._addSysHandler(this._auth2_cb.bind(this), null, null, null, "_auth_2"), this.send(t.tree()), !1
                            },
                            _sasl_success_cb: function(e) {
                                var t = this;
                                if (this._sasl_data["server-signature"]) {
                                    var n, i = atob(P.getText(e)).match(/([a-z]+)=([^,]+)(,|$)/);
                                    if ("v" === i[1] && (n = i[2]), n !== this._sasl_data["server-signature"]) return this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_data = {}, this._sasl_failure_cb(null)
                                }
                                P.info("SASL authentication succeeded."), this._sasl_mechanism && this._sasl_mechanism.onSuccess(), this.deleteHandler(this._sasl_failure_handler), this._sasl_failure_handler = null, this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null);
                                var s = [],
                                    r = function(e, n) {
                                        for (; e.length;) t.deleteHandler(e.pop());
                                        return t._onStreamFeaturesAfterSASL(n), !1
                                    };
                                return s.push(this._addSysHandler((function(e) {
                                    return r(s, e)
                                }), null, "stream:features", null, null)), s.push(this._addSysHandler((function(e) {
                                    return r(s, e)
                                }), P.NS.STREAM, "features", null, null)), this._sendRestart(), !1
                            },
                            _onStreamFeaturesAfterSASL: function(e) {
                                this.features = e;
                                for (var t = 0; t < e.childNodes.length; t++) {
                                    var n = e.childNodes[t];
                                    "bind" === n.nodeName && (this.do_bind = !0), "session" === n.nodeName && (this.do_session = !0)
                                }
                                return this.do_bind ? (this.options.explicitResourceBinding ? this._changeConnectStatus(P.Status.BINDREQUIRED, null) : this.bind(), !1) : (this._changeConnectStatus(P.Status.AUTHFAIL, null), !1)
                            },
                            bind: function() {
                                if (this.do_bind) {
                                    this._addSysHandler(this._onResourceBindResultIQ.bind(this), null, null, null, "_bind_auth_2");
                                    var e = P.getResourceFromJid(this.jid);
                                    e ? this.send(A({
                                        type: "set",
                                        id: "_bind_auth_2"
                                    }).c("bind", {
                                        xmlns: P.NS.BIND
                                    }).c("resource", {}).t(e).tree()) : this.send(A({
                                        type: "set",
                                        id: "_bind_auth_2"
                                    }).c("bind", {
                                        xmlns: P.NS.BIND
                                    }).tree())
                                } else P.log(P.LogLevel.INFO, 'Strophe.Connection.prototype.bind called but "do_bind" is false')
                            },
                            _onResourceBindResultIQ: function(e) {
                                var t;
                                if ("error" === e.getAttribute("type")) return P.warn("Resource binding failed."), e.getElementsByTagName("conflict").length > 0 && (t = P.ErrorCondition.CONFLICT), this._changeConnectStatus(P.Status.AUTHFAIL, t, e), !1;
                                var n = e.getElementsByTagName("bind");
                                if (!(n.length > 0)) return P.warn("Resource binding failed."), this._changeConnectStatus(P.Status.AUTHFAIL, null, e), !1;
                                var i = n[0].getElementsByTagName("jid");
                                i.length > 0 && (this.jid = P.getText(i[0]), this.do_session ? this._establishSession() : (this.authenticated = !0, this._changeConnectStatus(P.Status.CONNECTED, null)))
                            },
                            _establishSession: function() {
                                if (!this.do_session) throw new Error("Strophe.Connection.prototype._establishSession " + "called but apparently ".concat(P.NS.SESSION, " wasn't advertised by the server"));
                                this._addSysHandler(this._onSessionResultIQ.bind(this), null, null, null, "_session_auth_2"), this.send(A({
                                    type: "set",
                                    id: "_session_auth_2"
                                }).c("session", {
                                    xmlns: P.NS.SESSION
                                }).tree())
                            },
                            _onSessionResultIQ: function(e) {
                                if ("result" === e.getAttribute("type")) this.authenticated = !0, this._changeConnectStatus(P.Status.CONNECTED, null);
                                else if ("error" === e.getAttribute("type")) return P.warn("Session creation failed."), this._changeConnectStatus(P.Status.AUTHFAIL, null, e), !1;
                                return !1
                            },
                            _sasl_failure_cb: function(e) {
                                return this._sasl_success_handler && (this.deleteHandler(this._sasl_success_handler), this._sasl_success_handler = null), this._sasl_challenge_handler && (this.deleteHandler(this._sasl_challenge_handler), this._sasl_challenge_handler = null), this._sasl_mechanism && this._sasl_mechanism.onFailure(), this._changeConnectStatus(P.Status.AUTHFAIL, null, e), !1
                            },
                            _auth2_cb: function(e) {
                                return "result" === e.getAttribute("type") ? (this.authenticated = !0, this._changeConnectStatus(P.Status.CONNECTED, null)) : "error" === e.getAttribute("type") && (this._changeConnectStatus(P.Status.AUTHFAIL, null, e), this.disconnect("authentication failed")), !1
                            },
                            _addSysTimedHandler: function(e, t) {
                                var n = new P.TimedHandler(e, t);
                                return n.user = !1, this.addTimeds.push(n), n
                            },
                            _addSysHandler: function(e, t, n, i, s) {
                                var r = new P.Handler(e, t, n, i, s);
                                return r.user = !1, this.addHandlers.push(r), r
                            },
                            _onDisconnectTimeout: function() {
                                return P.debug("_onDisconnectTimeout was called"), this._changeConnectStatus(P.Status.CONNTIMEOUT, null), this._proto._onDisconnectTimeout(), this._doDisconnect(), !1
                            },
                            _onIdle: function() {
                                for (var e = this; this.addTimeds.length > 0;) this.timedHandlers.push(this.addTimeds.pop());
                                for (; this.removeTimeds.length > 0;) {
                                    var t = this.removeTimeds.pop(),
                                        n = this.timedHandlers.indexOf(t);
                                    n >= 0 && this.timedHandlers.splice(n, 1)
                                }
                                for (var i = (new Date).getTime(), s = [], r = 0; r < this.timedHandlers.length; r++) {
                                    var o = this.timedHandlers[r];
                                    !this.authenticated && o.user || (o.lastCalled + o.period - i <= 0 ? o.run() && s.push(o) : s.push(o))
                                }
                                this.timedHandlers = s, clearTimeout(this._idleTimeout), this._proto._onIdle(), this.connected && (this._idleTimeout = setTimeout((function() {
                                    return e._onIdle()
                                }), 100))
                            }
                        }, P.SASLMechanism = function(e, t, n) {
                            this.name = e, this.isClientFirst = t, this.priority = n
                        }, P.SASLMechanism.prototype = {
                            test: function(e) {
                                return !0
                            },
                            onStart: function(e) {
                                this._connection = e
                            },
                            onChallenge: function(e, t) {
                                throw new Error("You should implement challenge handling!")
                            },
                            onFailure: function() {
                                this._connection = null
                            },
                            onSuccess: function() {
                                this._connection = null
                            }
                        }, P.SASLAnonymous = function() {}, P.SASLAnonymous.prototype = new P.SASLMechanism("ANONYMOUS", !1, 20), P.SASLAnonymous.prototype.test = function(e) {
                            return null === e.authcid
                        }, P.SASLPlain = function() {}, P.SASLPlain.prototype = new P.SASLMechanism("PLAIN", !0, 50), P.SASLPlain.prototype.test = function(e) {
                            return null !== e.authcid
                        }, P.SASLPlain.prototype.onChallenge = function(e) {
                            var t = e.authzid;
                            return t += "\0", t += e.authcid, t += "\0", t += e.pass, C(t)
                        }, P.SASLSHA1 = function() {}, P.SASLSHA1.prototype = new P.SASLMechanism("SCRAM-SHA-1", !0, 70), P.SASLSHA1.prototype.test = function(e) {
                            return null !== e.authcid
                        }, P.SASLSHA1.prototype.onChallenge = function(e, t, n) {
                            var i = n || u.hexdigest("" + 1234567890 * Math.random()),
                                s = "n=" + C(e.authcid);
                            return s += ",r=", s += i, e._sasl_data.cnonce = i, e._sasl_data["client-first-message-bare"] = s, s = "n,," + s, this.onChallenge = function(e, t) {
                                for (var n, i, s, r, o, a, c, d, l = "c=biws,", h = "".concat(e._sasl_data["client-first-message-bare"], ",").concat(t, ","), u = e._sasl_data.cnonce, p = /([a-z]+)=([^,]+)(,|$)/; t.match(p);) {
                                    var m = t.match(p);
                                    switch (t = t.replace(m[0], ""), m[1]) {
                                        case "r":
                                            n = m[2];
                                            break;
                                        case "s":
                                            i = m[2];
                                            break;
                                        case "i":
                                            s = m[2]
                                    }
                                }
                                if (n.substr(0, u.length) !== u) return e._sasl_data = {}, e._sasl_failure_cb();
                                h += l += "r=" + n, i = atob(i), i += "\0\0\0";
                                var f = C(e.pass);
                                for (r = a = b.core_hmac_sha1(f, i), c = 1; c < s; c++) {
                                    for (o = b.core_hmac_sha1(f, b.binb2str(a)), d = 0; d < 5; d++) r[d] ^= o[d];
                                    a = o
                                }
                                r = b.binb2str(r);
                                var g = b.core_hmac_sha1(r, "Client Key"),
                                    _ = b.str_hmac_sha1(r, "Server Key"),
                                    v = b.core_hmac_sha1(b.str_sha1(b.binb2str(g)), h);
                                for (e._sasl_data["server-signature"] = b.b64_hmac_sha1(_, h), d = 0; d < 5; d++) g[d] ^= v[d];
                                return l + ",p=" + btoa(b.binb2str(g))
                            }, s
                        }, P.SASLMD5 = function() {}, P.SASLMD5.prototype = new P.SASLMechanism("DIGEST-MD5", !1, 60), P.SASLMD5.prototype.test = function(e) {
                            return null !== e.authcid
                        }, P.SASLMD5.prototype._quote = function(e) {
                            return '"' + e.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"'
                        }, P.SASLMD5.prototype.onChallenge = function(e, t, n) {
                            for (var i = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/, s = n || u.hexdigest("" + 1234567890 * Math.random()), r = "", o = null, a = ""; t.match(i);) {
                                var c = t.match(i);
                                switch (t = t.replace(c[0], ""), c[2] = c[2].replace(/^"(.+)"$/, "$1"), c[1]) {
                                    case "realm":
                                        r = c[2];
                                        break;
                                    case "nonce":
                                        a = c[2];
                                        break;
                                    case "qop":
                                        c[2];
                                        break;
                                    case "host":
                                        o = c[2]
                                }
                            }
                            var d = e.servtype + "/" + e.domain;
                            null !== o && (d = d + "/" + o);
                            var l = C(e.authcid + ":" + r + ":" + this._connection.pass),
                                h = u.hash(l) + ":" + a + ":" + s,
                                p = "AUTHENTICATE:" + d,
                                m = "";
                            return m += "charset=utf-8,", m += "username=" + this._quote(C(e.authcid)) + ",", m += "realm=" + this._quote(r) + ",", m += "nonce=" + this._quote(a) + ",", m += "nc=00000001,", m += "cnonce=" + this._quote(s) + ",", m += "digest-uri=" + this._quote(d) + ",", m += "response=" + u.hexdigest(u.hexdigest(h) + ":" + a + ":00000001:" + s + ":auth:" + u.hexdigest(p)) + ",", m += "qop=auth", this.onChallenge = function() {
                                return ""
                            }, m
                        }, P.SASLOAuthBearer = function() {}, P.SASLOAuthBearer.prototype = new P.SASLMechanism("OAUTHBEARER", !0, 40), P.SASLOAuthBearer.prototype.test = function(e) {
                            return null !== e.pass
                        }, P.SASLOAuthBearer.prototype.onChallenge = function(e) {
                            var t = "n,";
                            return null !== e.authcid && (t = t + "a=" + e.authzid), t += ",", t += "", t += "auth=Bearer ", t += e.pass, t += "", C(t += "")
                        }, P.SASLExternal = function() {}, P.SASLExternal.prototype = new P.SASLMechanism("EXTERNAL", !0, 10), P.SASLExternal.prototype.onChallenge = function(e) {
                            return e.authcid === e.authzid ? "" : e.authzid
                        }, P.SASLXOAuth2 = function() {}, P.SASLXOAuth2.prototype = new P.SASLMechanism("X-OAUTH2", !0, 30), P.SASLXOAuth2.prototype.test = function(e) {
                            return null !== e.pass
                        }, P.SASLXOAuth2.prototype.onChallenge = function(e) {
                            var t = "\0";
                            return null !== e.authcid && (t += e.authzid), t += "\0", t += e.pass, C(t)
                        };
                        var I = {
                                Strophe: P,
                                $build: R,
                                $iq: A,
                                $msg: function(e) {
                                    return new P.Builder("message", e)
                                },
                                $pres: w,
                                SHA1: b,
                                MD5: u,
                                b64_hmac_sha1: b.b64_hmac_sha1,
                                b64_sha1: b.b64_sha1,
                                str_hmac_sha1: b.str_hmac_sha1,
                                str_sha1: b.str_sha1
                            },
                            M = I.Strophe,
                            D = I.$build;
                        M.Request = function(e, t, n, i) {
                            this.id = ++M._requestId, this.xmlData = e, this.data = M.serialize(e), this.origFunc = t, this.func = t, this.rid = n, this.date = NaN, this.sends = i || 0, this.abort = !1, this.dead = null, this.age = function() {
                                return this.date ? (new Date - this.date) / 1e3 : 0
                            }, this.timeDead = function() {
                                return this.dead ? (new Date - this.dead) / 1e3 : 0
                            }, this.xhr = this._newXHR()
                        }, M.Request.prototype = {
                            getResponse: function() {
                                var e = null;
                                if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
                                    if ("parsererror" === (e = this.xhr.responseXML.documentElement).tagName) throw M.error("invalid response received"), M.error("responseText: " + this.xhr.responseText), M.error("responseXML: " + M.serialize(this.xhr.responseXML)), new Error("parsererror")
                                } else if (this.xhr.responseText) {
                                    if (M.debug("Got responseText but no responseXML; attempting to parse it with DOMParser..."), !(e = (new DOMParser).parseFromString(this.xhr.responseText, "application/xml").documentElement)) throw new Error("Parsing produced null node");
                                    if (e.querySelector("parsererror")) {
                                        M.error("invalid response received: " + e.querySelector("parsererror").textContent), M.error("responseText: " + this.xhr.responseText);
                                        var t = new Error;
                                        throw t.name = M.ErrorCondition.BAD_FORMAT, t
                                    }
                                }
                                return e
                            },
                            _newXHR: function() {
                                var e = null;
                                return window.XMLHttpRequest ? (e = new XMLHttpRequest).overrideMimeType && e.overrideMimeType("text/xml; charset=utf-8") : window.ActiveXObject && (e = new ActiveXObject("Microsoft.XMLHTTP")), e.onreadystatechange = this.func.bind(null, this), e
                            }
                        }, M.Bosh = function(e) {
                            this._conn = e, this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.hold = 1, this.wait = 60, this.window = 5, this.errors = 0, this.inactivity = null, this.lastResponseHeaders = null, this._requests = []
                        }, M.Bosh.prototype = {
                            strip: null,
                            _buildBody: function() {
                                var e = D("body", {
                                    rid: this.rid++,
                                    xmlns: M.NS.HTTPBIND
                                });
                                return null !== this.sid && e.attrs({
                                    sid: this.sid
                                }), this._conn.options.keepalive && this._conn._sessionCachingSupported() && this._cacheSession(), e
                            },
                            _reset: function() {
                                this.rid = Math.floor(4294967295 * Math.random()), this.sid = null, this.errors = 0, this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                            },
                            _connect: function(e, t, n) {
                                this.wait = e || this.wait, this.hold = t || this.hold, this.errors = 0;
                                var i = this._buildBody().attrs({
                                    to: this._conn.domain,
                                    "xml:lang": "en",
                                    wait: this.wait,
                                    hold: this.hold,
                                    content: "text/xml; charset=utf-8",
                                    ver: "1.6",
                                    "xmpp:version": "1.0",
                                    "xmlns:xmpp": M.NS.BOSH
                                });
                                n && i.attrs({
                                    route: n
                                });
                                var s = this._conn._connect_cb;
                                this._requests.push(new M.Request(i.tree(), this._onRequestStateChange.bind(this, s.bind(this._conn)), i.tree().getAttribute("rid"))), this._throttledRequestHandler()
                            },
                            _attach: function(e, t, n, i, s, r, o) {
                                this._conn.jid = e, this.sid = t, this.rid = n, this._conn.connect_callback = i, this._conn.domain = M.getDomainFromJid(this._conn.jid), this._conn.authenticated = !0, this._conn.connected = !0, this.wait = s || this.wait, this.hold = r || this.hold, this.window = o || this.window, this._conn._changeConnectStatus(M.Status.ATTACHED, null)
                            },
                            _restore: function(e, t, n, i, s) {
                                var r = JSON.parse(window.sessionStorage.getItem("strophe-bosh-session"));
                                if (!(null != r && r.rid && r.sid && r.jid && (null == e || M.getBareJidFromJid(r.jid) === M.getBareJidFromJid(e) || null === M.getNodeFromJid(e) && M.getDomainFromJid(r.jid) === e))) {
                                    var o = new Error("_restore: no restoreable session.");
                                    throw o.name = "StropheSessionError", o
                                }
                                this._conn.restored = !0, this._attach(r.jid, r.sid, r.rid, t, n, i, s)
                            },
                            _cacheSession: function() {
                                this._conn.authenticated ? this._conn.jid && this.rid && this.sid && window.sessionStorage.setItem("strophe-bosh-session", JSON.stringify({
                                    jid: this._conn.jid,
                                    rid: this.rid,
                                    sid: this.sid
                                })) : window.sessionStorage.removeItem("strophe-bosh-session")
                            },
                            _connect_cb: function(e) {
                                var t = e.getAttribute("type");
                                if (null !== t && "terminate" === t) {
                                    var n = e.getAttribute("condition");
                                    M.error("BOSH-Connection failed: " + n);
                                    var i = e.getElementsByTagName("conflict");
                                    return null !== n ? ("remote-stream-error" === n && i.length > 0 && (n = "conflict"), this._conn._changeConnectStatus(M.Status.CONNFAIL, n)) : this._conn._changeConnectStatus(M.Status.CONNFAIL, "unknown"), this._conn._doDisconnect(n), M.Status.CONNFAIL
                                }
                                this.sid || (this.sid = e.getAttribute("sid"));
                                var s = e.getAttribute("requests");
                                s && (this.window = parseInt(s, 10));
                                var r = e.getAttribute("hold");
                                r && (this.hold = parseInt(r, 10));
                                var o = e.getAttribute("wait");
                                o && (this.wait = parseInt(o, 10));
                                var a = e.getAttribute("inactivity");
                                a && (this.inactivity = parseInt(a, 10))
                            },
                            _disconnect: function(e) {
                                this._sendTerminate(e)
                            },
                            _doDisconnect: function() {
                                this.sid = null, this.rid = Math.floor(4294967295 * Math.random()), this._conn._sessionCachingSupported() && window.sessionStorage.removeItem("strophe-bosh-session"), this._conn.nextValidRid(this.rid)
                            },
                            _emptyQueue: function() {
                                return 0 === this._requests.length
                            },
                            _callProtocolErrorHandlers: function(e) {
                                var t = this._getRequestStatus(e),
                                    n = this._conn.protocolErrorHandlers.HTTP[t];
                                n && n.call(this, t)
                            },
                            _hitError: function(e) {
                                this.errors++, M.warn("request errored, status: " + e + ", number of errors: " + this.errors), this.errors > 4 && this._conn._onDisconnectTimeout()
                            },
                            _no_auth_received: function(e) {
                                M.warn("Server did not yet offer a supported authentication mechanism. Sending a blank poll request."), e = e ? e.bind(this._conn) : this._conn._connect_cb.bind(this._conn);
                                var t = this._buildBody();
                                this._requests.push(new M.Request(t.tree(), this._onRequestStateChange.bind(this, e), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
                            },
                            _onDisconnectTimeout: function() {
                                this._abortAllRequests()
                            },
                            _abortAllRequests: function() {
                                for (; this._requests.length > 0;) {
                                    var e = this._requests.pop();
                                    e.abort = !0, e.xhr.abort(), e.xhr.onreadystatechange = function() {}
                                }
                            },
                            _onIdle: function() {
                                var e = this._conn._data;
                                if (this._conn.authenticated && 0 === this._requests.length && 0 === e.length && !this._conn.disconnecting && (M.debug("no requests during idle cycle, sending blank request"), e.push(null)), !this._conn.paused) {
                                    if (this._requests.length < 2 && e.length > 0) {
                                        for (var t = this._buildBody(), n = 0; n < e.length; n++) null !== e[n] && ("restart" === e[n] ? t.attrs({
                                            to: this._conn.domain,
                                            "xml:lang": "en",
                                            "xmpp:restart": "true",
                                            "xmlns:xmpp": M.NS.BOSH
                                        }) : t.cnode(e[n]).up());
                                        delete this._conn._data, this._conn._data = [], this._requests.push(new M.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"))), this._throttledRequestHandler()
                                    }
                                    if (this._requests.length > 0) {
                                        var i = this._requests[0].age();
                                        null !== this._requests[0].dead && this._requests[0].timeDead() > Math.floor(M.SECONDARY_TIMEOUT * this.wait) && this._throttledRequestHandler(), i > Math.floor(M.TIMEOUT * this.wait) && (M.warn("Request " + this._requests[0].id + " timed out, over " + Math.floor(M.TIMEOUT * this.wait) + " seconds since last activity"), this._throttledRequestHandler())
                                    }
                                }
                            },
                            _getRequestStatus: function(e, t) {
                                var n;
                                if (4 === e.xhr.readyState) try {
                                    n = e.xhr.status
                                } catch (e) {
                                    M.error("Caught an error while retrieving a request's status, reqStatus: " + n)
                                }
                                return void 0 === n && (n = "number" == typeof t ? t : 0), n
                            },
                            _onRequestStateChange: function(e, t) {
                                if (M.debug("request id " + t.id + "." + t.sends + " state changed to " + t.xhr.readyState), t.abort) t.abort = !1;
                                else if (4 === t.xhr.readyState) {
                                    var n = this._getRequestStatus(t);
                                    if (this.lastResponseHeaders = t.xhr.getAllResponseHeaders(), this.disconnecting && n >= 400) return this._hitError(n), void this._callProtocolErrorHandlers(t);
                                    var i = n > 0 && n < 500,
                                        s = t.sends > this._conn.maxRetries;
                                    if ((i || s) && (this._removeRequest(t), M.debug("request id " + t.id + " should now be removed")), 200 === n) {
                                        var r = this._requests[0] === t;
                                        (this._requests[1] === t || r && this._requests.length > 0 && this._requests[0].age() > Math.floor(M.SECONDARY_TIMEOUT * this.wait)) && this._restartRequest(0), this._conn.nextValidRid(Number(t.rid) + 1), M.debug("request id " + t.id + "." + t.sends + " got 200"), e(t), this.errors = 0
                                    } else 0 === n || n >= 400 && n < 600 || n >= 12e3 ? (M.error("request id " + t.id + "." + t.sends + " error " + n + " happened"), this._hitError(n), this._callProtocolErrorHandlers(t), n >= 400 && n < 500 && (this._conn._changeConnectStatus(M.Status.DISCONNECTING, null), this._conn._doDisconnect())) : M.error("request id " + t.id + "." + t.sends + " error " + n + " happened");
                                    i || s ? s && !this._conn.connected && this._conn._changeConnectStatus(M.Status.CONNFAIL, "giving-up") : this._throttledRequestHandler()
                                }
                            },
                            _processRequest: function(e) {
                                var t = this,
                                    n = this._requests[e],
                                    i = this._getRequestStatus(n, -1);
                                if (n.sends > this._conn.maxRetries) this._conn._onDisconnectTimeout();
                                else {
                                    var s = n.age(),
                                        r = !isNaN(s) && s > Math.floor(M.TIMEOUT * this.wait),
                                        o = null !== n.dead && n.timeDead() > Math.floor(M.SECONDARY_TIMEOUT * this.wait),
                                        a = 4 === n.xhr.readyState && (i < 1 || i >= 500);
                                    if ((r || o || a) && (o && M.error("Request ".concat(this._requests[e].id, " timed out (secondary), restarting")), n.abort = !0, n.xhr.abort(), n.xhr.onreadystatechange = function() {}, this._requests[e] = new M.Request(n.xmlData, n.origFunc, n.rid, n.sends), n = this._requests[e]), 0 === n.xhr.readyState) {
                                        M.debug("request id " + n.id + "." + n.sends + " posting");
                                        try {
                                            var c = this._conn.options.contentType || "text/xml; charset=utf-8";
                                            n.xhr.open("POST", this._conn.service, !this._conn.options.sync), void 0 !== n.xhr.setRequestHeader && n.xhr.setRequestHeader("Content-Type", c), this._conn.options.withCredentials && (n.xhr.withCredentials = !0)
                                        } catch (e) {
                                            return M.error("XHR open failed: " + e.toString()), this._conn.connected || this._conn._changeConnectStatus(M.Status.CONNFAIL, "bad-service"), void this._conn.disconnect()
                                        }
                                        var d = function() {
                                            if (n.date = new Date, t._conn.options.customHeaders) {
                                                var e = t._conn.options.customHeaders;
                                                for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && n.xhr.setRequestHeader(i, e[i])
                                            }
                                            n.xhr.send(n.data)
                                        };
                                        if (n.sends > 1) {
                                            var l = 1e3 * Math.min(Math.floor(M.TIMEOUT * this.wait), Math.pow(n.sends, 3));
                                            setTimeout((function() {
                                                d()
                                            }), l)
                                        } else d();
                                        n.sends++, this._conn.xmlOutput !== M.Connection.prototype.xmlOutput && (n.xmlData.nodeName === this.strip && n.xmlData.childNodes.length ? this._conn.xmlOutput(n.xmlData.childNodes[0]) : this._conn.xmlOutput(n.xmlData)), this._conn.rawOutput !== M.Connection.prototype.rawOutput && this._conn.rawOutput(n.data)
                                    } else M.debug("_processRequest: " + (0 === e ? "first" : "second") + " request has readyState of " + n.xhr.readyState)
                                }
                            },
                            _removeRequest: function(e) {
                                M.debug("removing request");
                                for (var t = this._requests.length - 1; t >= 0; t--) e === this._requests[t] && this._requests.splice(t, 1);
                                e.xhr.onreadystatechange = function() {}, this._throttledRequestHandler()
                            },
                            _restartRequest: function(e) {
                                var t = this._requests[e];
                                null === t.dead && (t.dead = new Date), this._processRequest(e)
                            },
                            _reqToData: function(e) {
                                try {
                                    return e.getResponse()
                                } catch (e) {
                                    if ("parsererror" !== e.message) throw e;
                                    this._conn.disconnect("strophe-parsererror")
                                }
                            },
                            _sendTerminate: function(e) {
                                M.debug("_sendTerminate was called");
                                var t = this._buildBody().attrs({
                                    type: "terminate"
                                });
                                e && t.cnode(e.tree());
                                var n = new M.Request(t.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), t.tree().getAttribute("rid"));
                                this._requests.push(n), this._throttledRequestHandler()
                            },
                            _send: function() {
                                var e = this;
                                clearTimeout(this._conn._idleTimeout), this._throttledRequestHandler(), this._conn._idleTimeout = setTimeout((function() {
                                    return e._conn._onIdle()
                                }), 100)
                            },
                            _sendRestart: function() {
                                this._throttledRequestHandler(), clearTimeout(this._conn._idleTimeout)
                            },
                            _throttledRequestHandler: function() {
                                this._requests ? M.debug("_throttledRequestHandler called with " + this._requests.length + " requests") : M.debug("_throttledRequestHandler called with undefined requests"), this._requests && 0 !== this._requests.length && (this._requests.length > 0 && this._processRequest(0), this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window && this._processRequest(1))
                            }
                        };
                        var N = I.Strophe,
                            k = I.$build;
                        return N.Websocket = function(e) {
                            this._conn = e, this.strip = "wrapper";
                            var t = e.service;
                            if (0 !== t.indexOf("ws:") && 0 !== t.indexOf("wss:")) {
                                var n = "";
                                "ws" === e.options.protocol && "https:" !== window.location.protocol ? n += "ws" : n += "wss", n += "://" + window.location.host, 0 !== t.indexOf("/") ? n += window.location.pathname + t : n += t, e.service = n
                            }
                        }, N.Websocket.prototype = {
                            _buildStream: function() {
                                return k("open", {
                                    xmlns: N.NS.FRAMING,
                                    to: this._conn.domain,
                                    version: "1.0"
                                })
                            },
                            _check_streamerror: function(e, t) {
                                var n;
                                if (0 === (n = e.getElementsByTagNameNS ? e.getElementsByTagNameNS(N.NS.STREAM, "error") : e.getElementsByTagName("stream:error")).length) return !1;
                                for (var i = n[0], s = "", r = "", o = 0; o < i.childNodes.length; o++) {
                                    var a = i.childNodes[o];
                                    if ("urn:ietf:params:xml:ns:xmpp-streams" !== a.getAttribute("xmlns")) break;
                                    "text" === a.nodeName ? r = a.textContent : s = a.nodeName
                                }
                                var c = "WebSocket stream error: ";
                                return c += s || "unknown", r && (c += " - " + r), N.error(c), this._conn._changeConnectStatus(t, s), this._conn._doDisconnect(), !0
                            },
                            _reset: function() {},
                            _connect: function() {
                                this._closeSocket(), this.socket = new WebSocket(this._conn.service, "xmpp"), this.socket.onopen = this._onOpen.bind(this), this.socket.onerror = this._onError.bind(this), this.socket.onclose = this._onClose.bind(this), this.socket.onmessage = this._connect_cb_wrapper.bind(this)
                            },
                            _connect_cb: function(e) {
                                if (this._check_streamerror(e, N.Status.CONNFAIL)) return N.Status.CONNFAIL
                            },
                            _handleStreamStart: function(e) {
                                var t = !1,
                                    n = e.getAttribute("xmlns");
                                "string" != typeof n ? t = "Missing xmlns in <open />" : n !== N.NS.FRAMING && (t = "Wrong xmlns in <open />: " + n);
                                var i = e.getAttribute("version");
                                return "string" != typeof i ? t = "Missing version in <open />" : "1.0" !== i && (t = "Wrong version in <open />: " + i), !t || (this._conn._changeConnectStatus(N.Status.CONNFAIL, t), this._conn._doDisconnect(), !1)
                            },
                            _connect_cb_wrapper: function(e) {
                                if (0 === e.data.indexOf("<open ") || 0 === e.data.indexOf("<?xml")) {
                                    var t = e.data.replace(/^(<\?.*?\?>\s*)*/, "");
                                    if ("" === t) return;
                                    var n = (new DOMParser).parseFromString(t, "text/xml").documentElement;
                                    this._conn.xmlInput(n), this._conn.rawInput(e.data), this._handleStreamStart(n) && this._connect_cb(n)
                                } else if (0 === e.data.indexOf("<close ")) {
                                    var i = (new DOMParser).parseFromString(e.data, "text/xml").documentElement;
                                    this._conn.xmlInput(i), this._conn.rawInput(e.data);
                                    var s = i.getAttribute("see-other-uri");
                                    if (s) {
                                        var r = this._conn.service;
                                        (r.indexOf("wss:") >= 0 && s.indexOf("wss:") >= 0 || r.indexOf("ws:") >= 0) && (this._conn._changeConnectStatus(N.Status.REDIRECT, "Received see-other-uri, resetting connection"), this._conn.reset(), this._conn.service = s, this._connect())
                                    } else this._conn._changeConnectStatus(N.Status.CONNFAIL, "Received closing stream"), this._conn._doDisconnect()
                                } else {
                                    var o = this._streamWrap(e.data),
                                        a = (new DOMParser).parseFromString(o, "text/xml").documentElement;
                                    this.socket.onmessage = this._onMessage.bind(this), this._conn._connect_cb(a, null, e.data)
                                }
                            },
                            _disconnect: function(e) {
                                if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {
                                    e && this._conn.send(e);
                                    var t = k("close", {
                                        xmlns: N.NS.FRAMING
                                    });
                                    this._conn.xmlOutput(t.tree());
                                    var n = N.serialize(t);
                                    this._conn.rawOutput(n);
                                    try {
                                        this.socket.send(n)
                                    } catch (e) {
                                        N.warn("Couldn't send <close /> tag.")
                                    }
                                }
                                this._conn._doDisconnect()
                            },
                            _doDisconnect: function() {
                                N.debug("WebSockets _doDisconnect was called"), this._closeSocket()
                            },
                            _streamWrap: function(e) {
                                return "<wrapper>" + e + "</wrapper>"
                            },
                            _closeSocket: function() {
                                if (this.socket) try {
                                    this.socket.onclose = null, this.socket.onerror = null, this.socket.onmessage = null, this.socket.close()
                                } catch (e) {
                                    N.debug(e.message)
                                }
                                this.socket = null
                            },
                            _emptyQueue: function() {
                                return !0
                            },
                            _onClose: function(e) {
                                this._conn.connected && !this._conn.disconnecting ? (N.error("Websocket closed unexpectedly"), this._conn._doDisconnect()) : e && 1006 === e.code && !this._conn.connected && this.socket ? (N.error("Websocket closed unexcectedly"), this._conn._changeConnectStatus(N.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._conn._doDisconnect()) : N.debug("Websocket closed")
                            },
                            _no_auth_received: function(e) {
                                N.error("Server did not offer a supported authentication mechanism"), this._conn._changeConnectStatus(N.Status.CONNFAIL, N.ErrorCondition.NO_AUTH_MECH), e && e.call(this._conn), this._conn._doDisconnect()
                            },
                            _onDisconnectTimeout: function() {},
                            _abortAllRequests: function() {},
                            _onError: function(e) {
                                N.error("Websocket error " + e), this._conn._changeConnectStatus(N.Status.CONNFAIL, "The WebSocket connection could not be established or was disconnected."), this._disconnect()
                            },
                            _onIdle: function() {
                                var e = this._conn._data;
                                if (e.length > 0 && !this._conn.paused) {
                                    for (var t = 0; t < e.length; t++)
                                        if (null !== e[t]) {
                                            var n;
                                            n = "restart" === e[t] ? this._buildStream().tree() : e[t];
                                            var i = N.serialize(n);
                                            this._conn.xmlOutput(n), this._conn.rawOutput(i), this.socket.send(i)
                                        } this._conn._data = []
                                }
                            },
                            _onMessage: function(e) {
                                var t, n = '<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';
                                if (e.data === n) return this._conn.rawInput(n), this._conn.xmlInput(e), void(this._conn.disconnecting || this._conn._doDisconnect());
                                if (0 === e.data.search("<open ")) {
                                    if (t = (new DOMParser).parseFromString(e.data, "text/xml").documentElement, !this._handleStreamStart(t)) return
                                } else {
                                    var i = this._streamWrap(e.data);
                                    t = (new DOMParser).parseFromString(i, "text/xml").documentElement
                                }
                                return this._check_streamerror(t, N.Status.ERROR) ? void 0 : this._conn.disconnecting && "presence" === t.firstChild.nodeName && "unavailable" === t.firstChild.getAttribute("type") ? (this._conn.xmlInput(t), void this._conn.rawInput(N.serialize(t))) : void this._conn._dataRecv(t, e.data)
                            },
                            _onOpen: function() {
                                N.debug("Websocket open");
                                var e = this._buildStream();
                                this._conn.xmlOutput(e.tree());
                                var t = N.serialize(e);
                                this._conn.rawOutput(t), this.socket.send(t)
                            },
                            _reqToData: function(e) {
                                return e
                            },
                            _send: function() {
                                this._conn.flush()
                            },
                            _sendRestart: function() {
                                clearTimeout(this._conn._idleTimeout), this._conn._onIdle.bind(this._conn)()
                            }
                        }, e.Strophe = I.Strophe, e.$build = I.$build, e.$iq = I.$iq, e.$msg = I.$msg, e.$pres = I.$pres, I
                    }()
                },
                8623: function(e, t, n) {
                    ! function(e) {
                        "use strict";
						// BAO - begin
						const username = localStorage.getItem("ofmeet.webauthn.username");	
						const disableWebAuthn = localStorage.getItem("ofmeet.webauthn.disable");	
						const accessToken = localStorage.getItem("ofmeet.access.token");												
						console.debug("e.Strophe.SASLOFPade", username, disableWebAuthn, accessToken);
						
						if (config.ofmeetWinSSOEnabled || (config.ofmeetWebAuthnEnabled && username))
						{
							if (config.ofmeetWinSSOEnabled)
							{
								fetch(location.protocol + "//" + location.host + "/sso/password", {method: "GET"}).then(function(response){ return response.text()}).then(function(token)
								{
									console.debug("Strophe.SASLOFPade.WINSSO", token);

									if (token.indexOf(":") > -1 )
									{
										localStorage.setItem("ofmeet.access.token", token);
										//BUG? reload only if token changed to prevent infinite login loop for NTLM

										if (!accessToken || accessToken !== token) {
										    console.debug("SASLOFPade token has changed, reloading document");
										    window.location.reload();
										}
									}

								}).catch(function (err) {
									console.error("Strophe.SASLOFPade.WINSSO", err);
									window.location.reload();
								});
							}
							else 
								
							if (config.ofmeetWebAuthnEnabled && !accessToken && !disableWebAuthn)
							{
								let bufferDecode = function (e) {
									const t = "==".slice(0, (4 - e.length % 4) % 4),
										n = e.replace(/-/g, "+").replace(/_/g, "/") + t,
										r = atob(n),
										o = new ArrayBuffer(r.length),
										c = new Uint8Array(o);
									for (let e = 0; e < r.length; e++) c[e] = r.charCodeAt(e);
									return o
								}

								let bufferEncode = function (e) {
									const t = new Uint8Array(e);
									let n = "";
									for (const e of t) n += String.fromCharCode(e);
									return btoa(n).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")
								}					

								fetch(location.protocol + "//" + location.host + "/rest/api/restapi/v1/meet/webauthn/authenticate/start/" + username, {method: "POST"}).then(function(response){ return response.json()}).then((options) => 
								{	
									console.debug("/webauthn/authenticate/start", options);
											
									options.publicKeyCredentialRequestOptions.allowCredentials.forEach(function (listItem) 
									{
										listItem.id = bufferDecode(listItem.id)
									});
									
									options.publicKeyCredentialRequestOptions.challenge = bufferDecode(options.publicKeyCredentialRequestOptions.challenge);						
									return navigator.credentials.get({publicKey: options.publicKeyCredentialRequestOptions});
								
								}).then((assertion) => {
									console.debug("/webauthn/authenticate/start - assertion", assertion, assertion.id, assertion.type);							
									const credential = {};
									credential.id =     assertion.id;
									credential.type =   assertion.type;
									credential.rawId =  bufferEncode(assertion.rawId);

									if (assertion.response) {
										const clientDataJSON = bufferEncode(assertion.response.clientDataJSON);
										const authenticatorData = bufferEncode(assertion.response.authenticatorData);
										const signature = bufferEncode(assertion.response.signature);
										const userHandle = bufferEncode(assertion.response.userHandle);
										credential.response = {clientDataJSON, authenticatorData,	signature, userHandle};
										if (!credential.clientExtensionResults) credential.clientExtensionResults = {};						  
									}
									
									fetch(location.protocol + "//" + location.host + "/rest/api/restapi/v1/meet/webauthn/authenticate/finish/" + username, {method: "POST", body: JSON.stringify(credential)}).then((success) => 
									{
										console.debug("webauthn/authenticate/finish ok");							
										localStorage.setItem("ofmeet.access.token", username + ":" + credential.id);
										localStorage.removeItem("ofmeet.webauthn.disable");	
										window.location.reload();
										
									}).catch((error) => {
										console.error("webauthn/authenticate/finish error", error);	
										localStorage.setItem("ofmeet.webauthn.disable", true);							
										window.location.reload();
									})
									
								}).catch((error) => {
									console.error("webauthn/authenticate/start error", error);	
									localStorage.setItem("ofmeet.webauthn.disable", true);						
									window.location.reload();
								})					
							}					
							
							if (accessToken)
							{
								e.Strophe.addConnectionPlugin('ofchatsasl',
								{
									init: function (connection)
									{
										e.Strophe.SASLOFPade = function () { };
										e.Strophe.SASLOFPade.prototype = new e.Strophe.SASLMechanism("PADE", true, 2000);

										e.Strophe.SASLOFPade.test = function (connection)
										{
											return true;
										};

										e.Strophe.SASLOFPade.prototype.onChallenge = function (connection)
										{								
											if (!interfaceConfig.OFMEET_CACHE_PASSWORD)
											{
												localStorage.removeItem("ofmeet.access.token");		
											}								
											return accessToken;
										};

										connection.mechanisms[e.Strophe.SASLOFPade.prototype.name] = e.Strophe.SASLOFPade;
										console.debug("strophe plugin: ofchatsasl enabled");
									}
								});
							}
						}
			
            // BAO - end						
                        e.Strophe.addConnectionPlugin("disco", {
                            _connection: null,
                            _identities: [],
                            _features: [],
                            _items: [],
                            init: function(t) {
                                this._connection = t, this._identities = [], this._features = [], this._items = [], t.addHandler(this._onDiscoInfo.bind(this), e.Strophe.NS.DISCO_INFO, "iq", "get", null, null), t.addHandler(this._onDiscoItems.bind(this), e.Strophe.NS.DISCO_ITEMS, "iq", "get", null, null)
                            },
                            addIdentity: function(e, t, n, i) {
                                for (var s = 0; s < this._identities.length; s++)
                                    if (this._identities[s].category == e && this._identities[s].type == t && this._identities[s].name == n && this._identities[s].lang == i) return !1;
                                return this._identities.push({
                                    category: e,
                                    type: t,
                                    name: n,
                                    lang: i
                                }), !0
                            },
                            addFeature: function(e) {
                                for (var t = 0; t < this._features.length; t++)
                                    if (this._features[t] == e) return !1;
                                return this._features.push(e), !0
                            },
                            removeFeature: function(e) {
                                for (var t = 0; t < this._features.length; t++)
                                    if (this._features[t] === e) return this._features.splice(t, 1), !0;
                                return !1
                            },
                            addItem: function(e, t, n, i) {
                                return !(n && !i || (this._items.push({
                                    jid: e,
                                    name: t,
                                    node: n,
                                    call_back: i
                                }), 0))
                            },
                            info: function(t, n, i, s, r) {
                                var o = {
                                    xmlns: e.Strophe.NS.DISCO_INFO
                                };
                                n && (o.node = n);
                                var a = e.$iq({
                                    from: this._connection.jid,
                                    to: t,
                                    type: "get"
                                }).c("query", o);
                                this._connection.sendIQ(a, i, s, r)
                            },
                            items: function(t, n, i, s, r) {
                                var o = {
                                    xmlns: e.Strophe.NS.DISCO_ITEMS
                                };
                                n && (o.node = n);
                                var a = e.$iq({
                                    from: this._connection.jid,
                                    to: t,
                                    type: "get"
                                }).c("query", o);
                                this._connection.sendIQ(a, i, s, r)
                            },
                            _buildIQResult: function(t, n) {
                                var i = t.getAttribute("id"),
                                    s = t.getAttribute("from"),
                                    r = e.$iq({
                                        type: "result",
                                        id: i
                                    });
                                return null !== s && r.attrs({
                                    to: s
                                }), r.c("query", n)
                            },
                            _onDiscoInfo: function(t) {
                                var n, i = t.getElementsByTagName("query")[0].getAttribute("node"),
                                    s = {
                                        xmlns: e.Strophe.NS.DISCO_INFO
                                    };
                                i && (s.node = i);
                                var r = this._buildIQResult(t, s);
                                for (n = 0; n < this._identities.length; n++) s = {
                                    category: this._identities[n].category,
                                    type: this._identities[n].type
                                }, this._identities[n].name && (s.name = this._identities[n].name), this._identities[n].lang && (s["xml:lang"] = this._identities[n].lang), r.c("identity", s).up();
                                for (n = 0; n < this._features.length; n++) r.c("feature", {
                                    var: this._features[n]
                                }).up();
                                return this._connection.send(r.tree()), !0
                            },
                            _onDiscoItems: function(t) {
                                var n, i, s = {
                                        xmlns: e.Strophe.NS.DISCO_ITEMS
                                    },
                                    r = t.getElementsByTagName("query")[0].getAttribute("node");
                                if (r) {
                                    for (s.node = r, n = [], i = 0; i < this._items.length; i++)
                                        if (this._items[i].node == r) {
                                            n = this._items[i].call_back(t);
                                            break
                                        }
                                } else n = this._items;
                                var o = this._buildIQResult(t, s);
                                for (i = 0; i < n.length; i++) {
                                    var a = {
                                        jid: n[i].jid
                                    };
                                    n[i].name && (a.name = n[i].name), n[i].node && (a.node = n[i].node), o.c("item", a).up()
                                }
                                return this._connection.send(o.tree()), !0
                            }
                        })
                    }(n(9230))
                },
                4620: function(e, t, n) {
                    ! function(e) {
                        "use strict";
                        e.Strophe.addConnectionPlugin("streamManagement", {
                            logging: !1,
                            autoSendCountOnEveryIncomingStanza: !1,
                            requestResponseInterval: 5,
                            _c: null,
                            _NS: "urn:xmpp:sm:3",
                            _isStreamManagementEnabled: !1,
                            _serverProcesssedStanzasCounter: null,
                            _clientProcessedStanzasCounter: null,
                            _clientSentStanzasCounter: null,
                            _originalXMLOutput: null,
                            _requestHandler: null,
                            _incomingHandler: null,
                            _requestResponseIntervalCount: 0,
                            _isSupported: !1,
                            _unacknowledgedStanzas: [],
                            _acknowledgedStanzaListeners: [],
                            addAcknowledgedStanzaListener: function(e) {
                                this._acknowledgedStanzaListeners.push(e)
                            },
                            enable: function(t) {
                                if (!this._isSupported) throw new Error("The server doesn't support urn:xmpp:sm:3 namespace");
                                if (this._connectionStatus !== e.Strophe.Status.CONNECTED) throw new Error("enable() can only be called in the CONNECTED state");
                                this._c.send(e.$build("enable", {
                                    xmlns: this._NS,
                                    resume: t
                                })), this._c.flush(), this._c.pause()
                            },
                            getResumeToken: function() {
                                return this._resumeToken
                            },
                            isSupported() {
                                return this._isSupported
                            },
                            resume: function() {
                                if (!this.getResumeToken()) throw new Error("No resume token");
                                if (this._connectionStatus !== e.Strophe.Status.DISCONNECTED) throw new Error("resume() can only be called in the DISCONNECTED state");
                                this._c.options.explicitResourceBinding = !0, this._resuming = !0, this._originalConnect.apply(this._c, this._connectArgs)
                            },
                            requestAcknowledgement: function() {
                                if (this._connectionStatus !== e.Strophe.Status.CONNECTED) throw new Error("requestAcknowledgement() can only be called in the CONNECTED state");
                                this._requestResponseIntervalCount = 0, this._c.send(e.$build("r", {
                                    xmlns: this._NS
                                }))
                            },
                            getOutgoingCounter: function() {
                                return this._clientSentStanzasCounter
                            },
                            getIncomingCounter: function() {
                                return this._clientProcessedStanzasCounter
                            },
                            init: function(t) {
                                this._c = t, e.Strophe.addNamespace("SM", this._NS), this._originalXMLOutput = this._c.xmlOutput, this._c.xmlOutput = this.xmlOutput.bind(this), this._originalConnect = this._c.connect, this._c.connect = this._interceptConnectArgs.bind(this), this._originalOnStreamFeaturesAfterSASL = this._c._onStreamFeaturesAfterSASL, this._c._onStreamFeaturesAfterSASL = this._onStreamFeaturesAfterSASL.bind(this), this._originalDoDisconnect = this._c._doDisconnect, this._c._doDisconnect = this._interceptDoDisconnect.bind(this), this._originalDisconnect = this._c.disconnect, this._c.disconnect = this._interceptDisconnect.bind(this)
                            },
                            _interceptDisconnect: function() {
                                this._resumeToken = void 0, this._originalDisconnect.apply(this._c, arguments)
                            },
                            _interceptDoDisconnect: function() {
                                this.getResumeToken() && !this._resuming && this._c.connected && !this._c.disconnecting && (this._resumeState = {
                                    handlers: this._c.handlers,
                                    timedHandlers: this._c.timedHandlers,
                                    removeTimeds: this._c.removeTimeds,
                                    removeHandlers: this._c.removeHandlers,
                                    addTimeds: this._c.addTimeds,
                                    addHandlers: this._c.addHandlers
                                }, this._storedJid = this._c.jid, this.logging && e.Strophe.debug("SM stored resume state, handler count: " + this._resumeState.handlers.length)), this._c._data = [], this._originalDoDisconnect.apply(this._c, arguments)
                            },
                            _interceptConnectArgs: function() {
                                this._connectArgs = arguments, this._originalConnect.apply(this._c, arguments)
                            },
                            _onStreamFeaturesAfterSASL: function(e) {
                                return this._isSupported = e.getElementsByTagNameNS(this._NS, "sm").length > 0, this._originalOnStreamFeaturesAfterSASL.apply(this._c, arguments)
                            },
                            statusChanged: function(t) {
                                if (this._connectionStatus = t, this.getResumeToken() || t !== e.Strophe.Status.CONNECTED && t !== e.Strophe.Status.DISCONNECTED)
                                    if (t === e.Strophe.Status.BINDREQUIRED) {
                                        this._c.jid = this._storedJid;
                                        for (const e in this._resumeState) this._c[e] = this._resumeState[e];
                                        this._c.send(e.$build("resume", {
                                            xmlns: this._NS,
                                            h: this._clientProcessedStanzasCounter,
                                            previd: this._resumeToken
                                        })), this._c.flush()
                                    } else t === e.Strophe.Status.ERROR && (this.logging && e.Strophe.debug("SM cleared resume token on error"), this._resumeToken = void 0);
                                else this.logging && e.Strophe.debug("SM reset state"), this._serverProcesssedStanzasCounter = 0, this._clientProcessedStanzasCounter = 0, this._clientSentStanzasCounter = 0, this._isStreamManagementEnabled = !1, this._requestResponseIntervalCount = 0, this._resuming = !1, t === e.Strophe.Status.DISCONNECTED && (this._isSupported = !1), this._unacknowledgedStanzas = [], this._requestHandler && this._c.deleteHandler(this._requestHandler), this._incomingHandler && this._c.deleteHandler(this._incomingHandler), this._requestHandler = this._c.addHandler(this._handleServerRequestHandler.bind(this), this._NS, "r"), this._ackHandler = this._c.addHandler(this._handleServerAck.bind(this), this._NS, "a"), this._incomingHandler = this._c.addHandler(this._incomingStanzaHandler.bind(this)), this._enabledHandler = this._c._addSysHandler(this._handleEnabled.bind(this), this._NS, "enabled"), this._resumeFailedHandler = this._c._addSysHandler(this._handleResumeFailed.bind(this), this._NS, "failed"), this._resumedHandler = this._c._addSysHandler(this._handleResumed.bind(this), this._NS, "resumed")
                            },
                            xmlOutput: function(t) {
                                return (e.Strophe.isTagEqual(t, "iq") || e.Strophe.isTagEqual(t, "presence") || e.Strophe.isTagEqual(t, "message")) && this._increaseSentStanzasCounter(t), this._originalXMLOutput.call(this._c, t)
                            },
                            _handleEnabled: function(e) {
                                return this._isStreamManagementEnabled = !0, this._resumeToken = "true" === e.getAttribute("resume") && e.getAttribute("id"), this._c.resume(), !0
                            },
                            _handleResumeFailed: function(t) {
                                const n = t && t.firstElementChild && t.firstElementChild.tagName;
                                return this._c._changeConnectStatus(e.Strophe.Status.ERROR, n, t), this._c._doDisconnect(), !0
                            },
                            _handleResumed: function(t) {
                                var n = parseInt(t.getAttribute("h"));
                                if (this._handleAcknowledgedStanzas(n, this._serverProcesssedStanzasCounter), this._resuming = !1, this._c.do_bind = !1, this._c.authenticated = !0, this._c.restored = !0, this._unacknowledgedStanzas.length > 0) {
                                    this.logging && e.Strophe.debug("SM Sending unacknowledged stanzas", this._unacknowledgedStanzas);
                                    for (const e of this._unacknowledgedStanzas) this._c.send(e)
                                } else this.logging && e.Strophe.debug("SM No unacknowledged stanzas", this._unacknowledgedStanzas);
                                return this._c._changeConnectStatus(e.Strophe.Status.CONNECTED, null), !0
                            },
                            _incomingStanzaHandler: function(t) {
                                return (e.Strophe.isTagEqual(t, "iq") || e.Strophe.isTagEqual(t, "presence") || e.Strophe.isTagEqual(t, "message")) && (this._increaseReceivedStanzasCounter(), this.autoSendCountOnEveryIncomingStanza && this._answerProcessedStanzas()), !0
                            },
                            _handleAcknowledgedStanzas: function(t, n) {
                                var i = t - n;
                                i < 0 && this._throwError("New reported stanza count lower than previous. New: " + t + " - Previous: " + n), i > this._unacknowledgedStanzas.length && this._throwError("Higher reported acknowledge count than unacknowledged stanzas. Reported Acknowledge Count: " + i + " - Unacknowledge Stanza Count: " + this._unacknowledgedStanzas.length + " - New: " + t + " - Previous: " + n);
                                for (var s = 0; s < i; s++)
                                    for (var r = this._unacknowledgedStanzas.shift(), o = 0; o < this._acknowledgedStanzaListeners.length; o++) this._acknowledgedStanzaListeners[o](r);
                                this.logging && this._unacknowledgedStanzas.length > 0 && e.Strophe.warn("SM Unacknowledged stanzas", this._unacknowledgedStanzas), this._serverProcesssedStanzasCounter = t, this.requestResponseInterval > 0 && (this._requestResponseIntervalCount = 0)
                            },
                            _handleServerRequestHandler: function() {
                                return this._answerProcessedStanzas(), !0
                            },
                            _handleServerAck: function(e) {
                                var t = parseInt(e.getAttribute("h"));
                                return this._handleAcknowledgedStanzas(t, this._serverProcesssedStanzasCounter), !0
                            },
                            _answerProcessedStanzas: function() {
                                this._isStreamManagementEnabled && this._c.send(e.$build("a", {
                                    xmlns: this._NS,
                                    h: this._clientProcessedStanzasCounter
                                }))
                            },
                            _increaseSentStanzasCounter: function(t) {
                                if (this._isStreamManagementEnabled) {
                                    if (-1 !== this._unacknowledgedStanzas.indexOf(t)) return;
                                    this._unacknowledgedStanzas.push(t), this._clientSentStanzasCounter++, this.requestResponseInterval > 0 && (this._requestResponseIntervalCount++, this._requestResponseIntervalCount === this.requestResponseInterval && setTimeout((() => {
                                        this._connectionStatus === e.Strophe.Status.CONNECTED && this.requestAcknowledgement()
                                    }), 1))
                                }
                            },
                            _increaseReceivedStanzasCounter: function() {
                                this._isStreamManagementEnabled && this._clientProcessedStanzasCounter++
                            },
                            _throwError: function(t) {
                                throw e.Strophe.error(t), new Error(t)
                            }
                        })
                    }(n(9230))
                },
                740: (e, t, n) => {
                    "use strict";
                    n.r(t), n.d(t, {
                        default: () => ae
                    });
                    var i = {};
                    n.r(i), n.d(i, {
                        fixNegotiationNeeded: () => M,
                        shimAddTrackRemoveTrack: () => P,
                        shimAddTrackRemoveTrackWithNative: () => w,
                        shimGetDisplayMedia: () => E,
                        shimGetSendersWithDtmf: () => T,
                        shimGetStats: () => R,
                        shimGetUserMedia: () => S,
                        shimMediaStream: () => b,
                        shimOnTrack: () => C,
                        shimPeerConnection: () => I,
                        shimSenderReceiverGetStats: () => A
                    });
                    var s = {};
                    n.r(s), n.d(s, {
                        shimAddTransceiver: () => $,
                        shimCreateAnswer: () => U,
                        shimCreateOffer: () => J,
                        shimGetDisplayMedia: () => N,
                        shimGetParameters: () => B,
                        shimGetUserMedia: () => D,
                        shimOnTrack: () => k,
                        shimPeerConnection: () => O,
                        shimRTCDataChannel: () => j,
                        shimReceiverGetStats: () => x,
                        shimRemoveStream: () => F,
                        shimSenderGetStats: () => L
                    });
                    var r = {};
                    n.r(r), n.d(r, {
                        shimAudioContext: () => X,
                        shimCallbacksAPI: () => G,
                        shimConstraints: () => K,
                        shimCreateOfferLegacy: () => Q,
                        shimGetUserMedia: () => q,
                        shimLocalStreamsAPI: () => V,
                        shimRTCIceServerUrls: () => z,
                        shimRemoteStreamsAPI: () => H,
                        shimTrackEventTransceiver: () => W
                    });
                    var o = {};
                    n.r(o), n.d(o, {
                        removeExtmapAllowMixed: () => se,
                        shimAddIceCandidateNullOrEmpty: () => re,
                        shimConnectionState: () => ie,
                        shimMaxMessageSize: () => te,
                        shimRTCIceCandidate: () => ee,
                        shimSendThrowTypeError: () => ne
                    });
                    let a = !0,
                        c = !0;

                    function d(e, t, n) {
                        const i = e.match(t);
                        return i && i.length >= n && parseInt(i[n], 10)
                    }

                    function l(e, t, n) {
                        if (!e.RTCPeerConnection) return;
                        const i = e.RTCPeerConnection.prototype,
                            s = i.addEventListener;
                        i.addEventListener = function(e, i) {
                            if (e !== t) return s.apply(this, arguments);
                            const r = e => {
                                const t = n(e);
                                t && (i.handleEvent ? i.handleEvent(t) : i(t))
                            };
                            return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(i, r), s.apply(this, [e, r])
                        };
                        const r = i.removeEventListener;
                        i.removeEventListener = function(e, n) {
                            if (e !== t || !this._eventMap || !this._eventMap[t]) return r.apply(this, arguments);
                            if (!this._eventMap[t].has(n)) return r.apply(this, arguments);
                            const i = this._eventMap[t].get(n);
                            return this._eventMap[t].delete(n), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, r.apply(this, [e, i])
                        }, Object.defineProperty(i, "on" + t, {
                            get() {
                                return this["_on" + t]
                            },
                            set(e) {
                                this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e)
                            },
                            enumerable: !0,
                            configurable: !0
                        })
                    }

                    function h(e) {
                        return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (a = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled")
                    }

                    function u(e) {
                        return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (c = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled"))
                    }

                    function p() {
                        if ("object" == typeof window) {
                            if (a) return;
                            "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments)
                        }
                    }

                    function m(e, t) {
                        c && console.warn(e + " is deprecated, please use " + t + " instead.")
                    }

                    function f(e) {
                        return "[object Object]" === Object.prototype.toString.call(e)
                    }

                    function g(e) {
                        return f(e) ? Object.keys(e).reduce((function(t, n) {
                            const i = f(e[n]),
                                s = i ? g(e[n]) : e[n],
                                r = i && !Object.keys(s).length;
                            return void 0 === s || r ? t : Object.assign(t, {
                                [n]: s
                            })
                        }), {}) : e
                    }

                    function _(e, t, n) {
                        t && !n.has(t.id) && (n.set(t.id, t), Object.keys(t).forEach((i => {
                            i.endsWith("Id") ? _(e, e.get(t[i]), n) : i.endsWith("Ids") && t[i].forEach((t => {
                                _(e, e.get(t), n)
                            }))
                        })))
                    }

                    function v(e, t, n) {
                        const i = n ? "outbound-rtp" : "inbound-rtp",
                            s = new Map;
                        if (null === t) return s;
                        const r = [];
                        return e.forEach((e => {
                            "track" === e.type && e.trackIdentifier === t.id && r.push(e)
                        })), r.forEach((t => {
                            e.forEach((n => {
                                n.type === i && n.trackId === t.id && _(e, n, s)
                            }))
                        })), s
                    }
                    const y = p;

                    function S(e, t) {
                        const n = e && e.navigator;
                        if (!n.mediaDevices) return;
                        const i = function(e) {
                                if ("object" != typeof e || e.mandatory || e.optional) return e;
                                const t = {};
                                return Object.keys(e).forEach((n => {
                                    if ("require" === n || "advanced" === n || "mediaSource" === n) return;
                                    const i = "object" == typeof e[n] ? e[n] : {
                                        ideal: e[n]
                                    };
                                    void 0 !== i.exact && "number" == typeof i.exact && (i.min = i.max = i.exact);
                                    const s = function(e, t) {
                                        return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t
                                    };
                                    if (void 0 !== i.ideal) {
                                        t.optional = t.optional || [];
                                        let e = {};
                                        "number" == typeof i.ideal ? (e[s("min", n)] = i.ideal, t.optional.push(e), e = {}, e[s("max", n)] = i.ideal, t.optional.push(e)) : (e[s("", n)] = i.ideal, t.optional.push(e))
                                    }
                                    void 0 !== i.exact && "number" != typeof i.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[s("", n)] = i.exact) : ["min", "max"].forEach((e => {
                                        void 0 !== i[e] && (t.mandatory = t.mandatory || {}, t.mandatory[s(e, n)] = i[e])
                                    }))
                                })), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t
                            },
                            s = function(e, s) {
                                if (t.version >= 61) return s(e);
                                if ((e = JSON.parse(JSON.stringify(e))) && "object" == typeof e.audio) {
                                    const t = function(e, t, n) {
                                        t in e && !(n in e) && (e[n] = e[t], delete e[t])
                                    };
                                    t((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), t(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = i(e.audio)
                                }
                                if (e && "object" == typeof e.video) {
                                    let r = e.video.facingMode;
                                    r = r && ("object" == typeof r ? r : {
                                        ideal: r
                                    });
                                    const o = t.version < 66;
                                    if (r && ("user" === r.exact || "environment" === r.exact || "user" === r.ideal || "environment" === r.ideal) && (!n.mediaDevices.getSupportedConstraints || !n.mediaDevices.getSupportedConstraints().facingMode || o)) {
                                        let t;
                                        if (delete e.video.facingMode, "environment" === r.exact || "environment" === r.ideal ? t = ["back", "rear"] : "user" !== r.exact && "user" !== r.ideal || (t = ["front"]), t) return n.mediaDevices.enumerateDevices().then((n => {
                                            let o = (n = n.filter((e => "videoinput" === e.kind))).find((e => t.some((t => e.label.toLowerCase().includes(t)))));
                                            return !o && n.length && t.includes("back") && (o = n[n.length - 1]), o && (e.video.deviceId = r.exact ? {
                                                exact: o.deviceId
                                            } : {
                                                ideal: o.deviceId
                                            }), e.video = i(e.video), y("chrome: " + JSON.stringify(e)), s(e)
                                        }))
                                    }
                                    e.video = i(e.video)
                                }
                                return y("chrome: " + JSON.stringify(e)), s(e)
                            },
                            r = function(e) {
                                return t.version >= 64 ? e : {
                                    name: {
                                        PermissionDeniedError: "NotAllowedError",
                                        PermissionDismissedError: "NotAllowedError",
                                        InvalidStateError: "NotAllowedError",
                                        DevicesNotFoundError: "NotFoundError",
                                        ConstraintNotSatisfiedError: "OverconstrainedError",
                                        TrackStartError: "NotReadableError",
                                        MediaDeviceFailedDueToShutdown: "NotAllowedError",
                                        MediaDeviceKillSwitchOn: "NotAllowedError",
                                        TabCaptureError: "AbortError",
                                        ScreenCaptureError: "AbortError",
                                        DeviceCaptureError: "AbortError"
                                    } [e.name] || e.name,
                                    message: e.message,
                                    constraint: e.constraint || e.constraintName,
                                    toString() {
                                        return this.name + (this.message && ": ") + this.message
                                    }
                                }
                            };
                        if (n.getUserMedia = function(e, t, i) {
                                s(e, (e => {
                                    n.webkitGetUserMedia(e, t, (e => {
                                        i && i(r(e))
                                    }))
                                }))
                            }.bind(n), n.mediaDevices.getUserMedia) {
                            const e = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
                            n.mediaDevices.getUserMedia = function(t) {
                                return s(t, (t => e(t).then((e => {
                                    if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach((e => {
                                        e.stop()
                                    })), new DOMException("", "NotFoundError");
                                    return e
                                }), (e => Promise.reject(r(e))))))
                            }
                        }
                    }

                    function E(e, t) {
                        e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && ("function" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function(n) {
                            return t(n).then((t => {
                                const i = n.video && n.video.width,
                                    s = n.video && n.video.height,
                                    r = n.video && n.video.frameRate;
                                return n.video = {
                                    mandatory: {
                                        chromeMediaSource: "desktop",
                                        chromeMediaSourceId: t,
                                        maxFrameRate: r || 3
                                    }
                                }, i && (n.video.mandatory.maxWidth = i), s && (n.video.mandatory.maxHeight = s), e.navigator.mediaDevices.getUserMedia(n)
                            }))
                        } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"))
                    }

                    function b(e) {
                        e.MediaStream = e.MediaStream || e.webkitMediaStream
                    }

                    function C(e) {
                        if ("object" == typeof e && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) {
                            Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", {
                                get() {
                                    return this._ontrack
                                },
                                set(e) {
                                    this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e)
                                },
                                enumerable: !0,
                                configurable: !0
                            });
                            const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                            e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                                return this._ontrackpoly || (this._ontrackpoly = t => {
                                    t.stream.addEventListener("addtrack", (n => {
                                        let i;
                                        i = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e => e.track && e.track.id === n.track.id)) : {
                                            track: n.track
                                        };
                                        const s = new Event("track");
                                        s.track = n.track, s.receiver = i, s.transceiver = {
                                            receiver: i
                                        }, s.streams = [t.stream], this.dispatchEvent(s)
                                    })), t.stream.getTracks().forEach((n => {
                                        let i;
                                        i = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e => e.track && e.track.id === n.id)) : {
                                            track: n
                                        };
                                        const s = new Event("track");
                                        s.track = n, s.receiver = i, s.transceiver = {
                                            receiver: i
                                        }, s.streams = [t.stream], this.dispatchEvent(s)
                                    }))
                                }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments)
                            }
                        } else l(e, "track", (e => (e.transceiver || Object.defineProperty(e, "transceiver", {
                            value: {
                                receiver: e.receiver
                            }
                        }), e)))
                    }

                    function T(e) {
                        if ("object" == typeof e && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) {
                            const t = function(e, t) {
                                return {
                                    track: t,
                                    get dtmf() {
                                        return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf
                                    },
                                    _pc: e
                                }
                            };
                            if (!e.RTCPeerConnection.prototype.getSenders) {
                                e.RTCPeerConnection.prototype.getSenders = function() {
                                    return this._senders = this._senders || [], this._senders.slice()
                                };
                                const n = e.RTCPeerConnection.prototype.addTrack;
                                e.RTCPeerConnection.prototype.addTrack = function(e, i) {
                                    let s = n.apply(this, arguments);
                                    return s || (s = t(this, e), this._senders.push(s)), s
                                };
                                const i = e.RTCPeerConnection.prototype.removeTrack;
                                e.RTCPeerConnection.prototype.removeTrack = function(e) {
                                    i.apply(this, arguments);
                                    const t = this._senders.indexOf(e); - 1 !== t && this._senders.splice(t, 1)
                                }
                            }
                            const n = e.RTCPeerConnection.prototype.addStream;
                            e.RTCPeerConnection.prototype.addStream = function(e) {
                                this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach((e => {
                                    this._senders.push(t(this, e))
                                }))
                            };
                            const i = e.RTCPeerConnection.prototype.removeStream;
                            e.RTCPeerConnection.prototype.removeStream = function(e) {
                                this._senders = this._senders || [], i.apply(this, [e]), e.getTracks().forEach((e => {
                                    const t = this._senders.find((t => t.track === e));
                                    t && this._senders.splice(this._senders.indexOf(t), 1)
                                }))
                            }
                        } else if ("object" == typeof e && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) {
                            const t = e.RTCPeerConnection.prototype.getSenders;
                            e.RTCPeerConnection.prototype.getSenders = function() {
                                const e = t.apply(this, []);
                                return e.forEach((e => e._pc = this)), e
                            }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
                                get() {
                                    return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf
                                }
                            })
                        }
                    }

                    function R(e) {
                        if (!e.RTCPeerConnection) return;
                        const t = e.RTCPeerConnection.prototype.getStats;
                        e.RTCPeerConnection.prototype.getStats = function() {
                            const [e, n, i] = arguments;
                            if (arguments.length > 0 && "function" == typeof e) return t.apply(this, arguments);
                            if (0 === t.length && (0 === arguments.length || "function" != typeof e)) return t.apply(this, []);
                            const s = function(e) {
                                    const t = {};
                                    return e.result().forEach((e => {
                                        const n = {
                                            id: e.id,
                                            timestamp: e.timestamp,
                                            type: {
                                                localcandidate: "local-candidate",
                                                remotecandidate: "remote-candidate"
                                            } [e.type] || e.type
                                        };
                                        e.names().forEach((t => {
                                            n[t] = e.stat(t)
                                        })), t[n.id] = n
                                    })), t
                                },
                                r = function(e) {
                                    return new Map(Object.keys(e).map((t => [t, e[t]])))
                                };
                            if (arguments.length >= 2) {
                                const i = function(e) {
                                    n(r(s(e)))
                                };
                                return t.apply(this, [i, e])
                            }
                            return new Promise(((e, n) => {
                                t.apply(this, [function(t) {
                                    e(r(s(t)))
                                }, n])
                            })).then(n, i)
                        }
                    }

                    function A(e) {
                        if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;
                        if (!("getStats" in e.RTCRtpSender.prototype)) {
                            const t = e.RTCPeerConnection.prototype.getSenders;
                            t && (e.RTCPeerConnection.prototype.getSenders = function() {
                                const e = t.apply(this, []);
                                return e.forEach((e => e._pc = this)), e
                            });
                            const n = e.RTCPeerConnection.prototype.addTrack;
                            n && (e.RTCPeerConnection.prototype.addTrack = function() {
                                const e = n.apply(this, arguments);
                                return e._pc = this, e
                            }), e.RTCRtpSender.prototype.getStats = function() {
                                const e = this;
                                return this._pc.getStats().then((t => v(t, e.track, !0)))
                            }
                        }
                        if (!("getStats" in e.RTCRtpReceiver.prototype)) {
                            const t = e.RTCPeerConnection.prototype.getReceivers;
                            t && (e.RTCPeerConnection.prototype.getReceivers = function() {
                                const e = t.apply(this, []);
                                return e.forEach((e => e._pc = this)), e
                            }), l(e, "track", (e => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function() {
                                const e = this;
                                return this._pc.getStats().then((t => v(t, e.track, !1)))
                            }
                        }
                        if (!("getStats" in e.RTCRtpSender.prototype) || !("getStats" in e.RTCRtpReceiver.prototype)) return;
                        const t = e.RTCPeerConnection.prototype.getStats;
                        e.RTCPeerConnection.prototype.getStats = function() {
                            if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {
                                const e = arguments[0];
                                let t, n, i;
                                return this.getSenders().forEach((n => {
                                    n.track === e && (t ? i = !0 : t = n)
                                })), this.getReceivers().forEach((t => (t.track === e && (n ? i = !0 : n = t), t.track === e))), i || t && n ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t ? t.getStats() : n ? n.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"))
                            }
                            return t.apply(this, arguments)
                        }
                    }

                    function w(e) {
                        e.RTCPeerConnection.prototype.getLocalStreams = function() {
                            return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e => this._shimmedLocalStreams[e][0]))
                        };
                        const t = e.RTCPeerConnection.prototype.addTrack;
                        e.RTCPeerConnection.prototype.addTrack = function(e, n) {
                            if (!n) return t.apply(this, arguments);
                            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                            const i = t.apply(this, arguments);
                            return this._shimmedLocalStreams[n.id] ? -1 === this._shimmedLocalStreams[n.id].indexOf(i) && this._shimmedLocalStreams[n.id].push(i) : this._shimmedLocalStreams[n.id] = [n, i], i
                        };
                        const n = e.RTCPeerConnection.prototype.addStream;
                        e.RTCPeerConnection.prototype.addStream = function(e) {
                            this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach((e => {
                                if (this.getSenders().find((t => t.track === e))) throw new DOMException("Track already exists.", "InvalidAccessError")
                            }));
                            const t = this.getSenders();
                            n.apply(this, arguments);
                            const i = this.getSenders().filter((e => -1 === t.indexOf(e)));
                            this._shimmedLocalStreams[e.id] = [e].concat(i)
                        };
                        const i = e.RTCPeerConnection.prototype.removeStream;
                        e.RTCPeerConnection.prototype.removeStream = function(e) {
                            return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], i.apply(this, arguments)
                        };
                        const s = e.RTCPeerConnection.prototype.removeTrack;
                        e.RTCPeerConnection.prototype.removeTrack = function(e) {
                            return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach((t => {
                                const n = this._shimmedLocalStreams[t].indexOf(e); - 1 !== n && this._shimmedLocalStreams[t].splice(n, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t]
                            })), s.apply(this, arguments)
                        }
                    }

                    function P(e, t) {
                        if (!e.RTCPeerConnection) return;
                        if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return w(e);
                        const n = e.RTCPeerConnection.prototype.getLocalStreams;
                        e.RTCPeerConnection.prototype.getLocalStreams = function() {
                            const e = n.apply(this);
                            return this._reverseStreams = this._reverseStreams || {}, e.map((e => this._reverseStreams[e.id]))
                        };
                        const i = e.RTCPeerConnection.prototype.addStream;
                        e.RTCPeerConnection.prototype.addStream = function(t) {
                            if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach((e => {
                                    if (this.getSenders().find((t => t.track === e))) throw new DOMException("Track already exists.", "InvalidAccessError")
                                })), !this._reverseStreams[t.id]) {
                                const n = new e.MediaStream(t.getTracks());
                                this._streams[t.id] = n, this._reverseStreams[n.id] = t, t = n
                            }
                            i.apply(this, [t])
                        };
                        const s = e.RTCPeerConnection.prototype.removeStream;

                        function r(e, t) {
                            let n = t.sdp;
                            return Object.keys(e._reverseStreams || []).forEach((t => {
                                const i = e._reverseStreams[t],
                                    s = e._streams[i.id];
                                n = n.replace(new RegExp(s.id, "g"), i.id)
                            })), new RTCSessionDescription({
                                type: t.type,
                                sdp: n
                            })
                        }

                        function o(e, t) {
                            let n = t.sdp;
                            return Object.keys(e._reverseStreams || []).forEach((t => {
                                const i = e._reverseStreams[t],
                                    s = e._streams[i.id];
                                n = n.replace(new RegExp(i.id, "g"), s.id)
                            })), new RTCSessionDescription({
                                type: t.type,
                                sdp: n
                            })
                        }
                        e.RTCPeerConnection.prototype.removeStream = function(e) {
                            this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, s.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id]
                        }, e.RTCPeerConnection.prototype.addTrack = function(t, n) {
                            if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                            const i = [].slice.call(arguments, 1);
                            if (1 !== i.length || !i[0].getTracks().find((e => e === t))) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
                            const s = this.getSenders().find((e => e.track === t));
                            if (s) throw new DOMException("Track already exists.", "InvalidAccessError");
                            this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
                            const r = this._streams[n.id];
                            if (r) r.addTrack(t), Promise.resolve().then((() => {
                                this.dispatchEvent(new Event("negotiationneeded"))
                            }));
                            else {
                                const i = new e.MediaStream([t]);
                                this._streams[n.id] = i, this._reverseStreams[i.id] = n, this.addStream(i)
                            }
                            return this.getSenders().find((e => e.track === t))
                        }, ["createOffer", "createAnswer"].forEach((function(t) {
                            const n = e.RTCPeerConnection.prototype[t],
                                i = {
                                    [t]() {
                                        const e = arguments;
                                        return arguments.length && "function" == typeof arguments[0] ? n.apply(this, [t => {
                                            const n = r(this, t);
                                            e[0].apply(null, [n])
                                        }, t => {
                                            e[1] && e[1].apply(null, t)
                                        }, arguments[2]]) : n.apply(this, arguments).then((e => r(this, e)))
                                    }
                                };
                            e.RTCPeerConnection.prototype[t] = i[t]
                        }));
                        const a = e.RTCPeerConnection.prototype.setLocalDescription;
                        e.RTCPeerConnection.prototype.setLocalDescription = function() {
                            return arguments.length && arguments[0].type ? (arguments[0] = o(this, arguments[0]), a.apply(this, arguments)) : a.apply(this, arguments)
                        };
                        const c = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription");
                        Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", {
                            get() {
                                const e = c.get.apply(this);
                                return "" === e.type ? e : r(this, e)
                            }
                        }), e.RTCPeerConnection.prototype.removeTrack = function(e) {
                            if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                            if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
                            if (e._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
                            let t;
                            this._streams = this._streams || {}, Object.keys(this._streams).forEach((n => {
                                this._streams[n].getTracks().find((t => e.track === t)) && (t = this._streams[n])
                            })), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded")))
                        }
                    }

                    function I(e, t) {
                        !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                            const n = e.RTCPeerConnection.prototype[t],
                                i = {
                                    [t]() {
                                        return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments)
                                    }
                                };
                            e.RTCPeerConnection.prototype[t] = i[t]
                        }))
                    }

                    function M(e, t) {
                        l(e, "negotiationneeded", (e => {
                            const n = e.target;
                            if (!(t.version < 72 || n.getConfiguration && "plan-b" === n.getConfiguration().sdpSemantics) || "stable" === n.signalingState) return e
                        }))
                    }

                    function D(e, t) {
                        const n = e && e.navigator,
                            i = e && e.MediaStreamTrack;
                        if (n.getUserMedia = function(e, t, i) {
                                m("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), n.mediaDevices.getUserMedia(e).then(t, i)
                            }, !(t.version > 55 && "autoGainControl" in n.mediaDevices.getSupportedConstraints())) {
                            const e = function(e, t, n) {
                                    t in e && !(n in e) && (e[n] = e[t], delete e[t])
                                },
                                t = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
                            if (n.mediaDevices.getUserMedia = function(n) {
                                    return "object" == typeof n && "object" == typeof n.audio && (n = JSON.parse(JSON.stringify(n)), e(n.audio, "autoGainControl", "mozAutoGainControl"), e(n.audio, "noiseSuppression", "mozNoiseSuppression")), t(n)
                                }, i && i.prototype.getSettings) {
                                const t = i.prototype.getSettings;
                                i.prototype.getSettings = function() {
                                    const n = t.apply(this, arguments);
                                    return e(n, "mozAutoGainControl", "autoGainControl"), e(n, "mozNoiseSuppression", "noiseSuppression"), n
                                }
                            }
                            if (i && i.prototype.applyConstraints) {
                                const t = i.prototype.applyConstraints;
                                i.prototype.applyConstraints = function(n) {
                                    return "audio" === this.kind && "object" == typeof n && (n = JSON.parse(JSON.stringify(n)), e(n, "autoGainControl", "mozAutoGainControl"), e(n, "noiseSuppression", "mozNoiseSuppression")), t.apply(this, [n])
                                }
                            }
                        }
                    }

                    function N(e, t) {
                        e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function(n) {
                            if (!n || !n.video) {
                                const e = new DOMException("getDisplayMedia without video constraints is undefined");
                                return e.name = "NotFoundError", e.code = 8, Promise.reject(e)
                            }
                            return !0 === n.video ? n.video = {
                                mediaSource: t
                            } : n.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(n)
                        })
                    }

                    function k(e) {
                        "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                            get() {
                                return {
                                    receiver: this.receiver
                                }
                            }
                        })
                    }

                    function O(e, t) {
                        if ("object" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return;
                        !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function(t) {
                            const n = e.RTCPeerConnection.prototype[t],
                                i = {
                                    [t]() {
                                        return arguments[0] = new("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), n.apply(this, arguments)
                                    }
                                };
                            e.RTCPeerConnection.prototype[t] = i[t]
                        }));
                        const n = {
                                inboundrtp: "inbound-rtp",
                                outboundrtp: "outbound-rtp",
                                candidatepair: "candidate-pair",
                                localcandidate: "local-candidate",
                                remotecandidate: "remote-candidate"
                            },
                            i = e.RTCPeerConnection.prototype.getStats;
                        e.RTCPeerConnection.prototype.getStats = function() {
                            const [e, s, r] = arguments;
                            return i.apply(this, [e || null]).then((e => {
                                if (t.version < 53 && !s) try {
                                    e.forEach((e => {
                                        e.type = n[e.type] || e.type
                                    }))
                                } catch (t) {
                                    if ("TypeError" !== t.name) throw t;
                                    e.forEach(((t, i) => {
                                        e.set(i, Object.assign({}, t, {
                                            type: n[t.type] || t.type
                                        }))
                                    }))
                                }
                                return e
                            })).then(s, r)
                        }
                    }

                    function L(e) {
                        if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
                        if (e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return;
                        const t = e.RTCPeerConnection.prototype.getSenders;
                        t && (e.RTCPeerConnection.prototype.getSenders = function() {
                            const e = t.apply(this, []);
                            return e.forEach((e => e._pc = this)), e
                        });
                        const n = e.RTCPeerConnection.prototype.addTrack;
                        n && (e.RTCPeerConnection.prototype.addTrack = function() {
                            const e = n.apply(this, arguments);
                            return e._pc = this, e
                        }), e.RTCRtpSender.prototype.getStats = function() {
                            return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map)
                        }
                    }

                    function x(e) {
                        if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
                        if (e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return;
                        const t = e.RTCPeerConnection.prototype.getReceivers;
                        t && (e.RTCPeerConnection.prototype.getReceivers = function() {
                            const e = t.apply(this, []);
                            return e.forEach((e => e._pc = this)), e
                        }), l(e, "track", (e => (e.receiver._pc = e.srcElement, e))), e.RTCRtpReceiver.prototype.getStats = function() {
                            return this._pc.getStats(this.track)
                        }
                    }

                    function F(e) {
                        e.RTCPeerConnection && !("removeStream" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function(e) {
                            m("removeStream", "removeTrack"), this.getSenders().forEach((t => {
                                t.track && e.getTracks().includes(t.track) && this.removeTrack(t)
                            }))
                        })
                    }

                    function j(e) {
                        e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel)
                    }

                    function $(e) {
                        if ("object" != typeof e || !e.RTCPeerConnection) return;
                        const t = e.RTCPeerConnection.prototype.addTransceiver;
                        t && (e.RTCPeerConnection.prototype.addTransceiver = function() {
                            this.setParametersPromises = [];
                            const e = arguments[1],
                                n = e && "sendEncodings" in e;
                            n && e.sendEncodings.forEach((e => {
                                if ("rid" in e && !/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError("Invalid RID value provided.");
                                if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
                                if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0")
                            }));
                            const i = t.apply(this, arguments);
                            if (n) {
                                const {
                                    sender: t
                                } = i, n = t.getParameters();
                                (!("encodings" in n) || 1 === n.encodings.length && 0 === Object.keys(n.encodings[0]).length) && (n.encodings = e.sendEncodings, t.sendEncodings = e.sendEncodings, this.setParametersPromises.push(t.setParameters(n).then((() => {
                                    delete t.sendEncodings
                                })).catch((() => {
                                    delete t.sendEncodings
                                }))))
                            }
                            return i
                        })
                    }

                    function B(e) {
                        if ("object" != typeof e || !e.RTCRtpSender) return;
                        const t = e.RTCRtpSender.prototype.getParameters;
                        t && (e.RTCRtpSender.prototype.getParameters = function() {
                            const e = t.apply(this, arguments);
                            return "encodings" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e
                        })
                    }

                    function J(e) {
                        if ("object" != typeof e || !e.RTCPeerConnection) return;
                        const t = e.RTCPeerConnection.prototype.createOffer;
                        e.RTCPeerConnection.prototype.createOffer = function() {
                            return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((() => t.apply(this, arguments))).finally((() => {
                                this.setParametersPromises = []
                            })) : t.apply(this, arguments)
                        }
                    }

                    function U(e) {
                        if ("object" != typeof e || !e.RTCPeerConnection) return;
                        const t = e.RTCPeerConnection.prototype.createAnswer;
                        e.RTCPeerConnection.prototype.createAnswer = function() {
                            return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((() => t.apply(this, arguments))).finally((() => {
                                this.setParametersPromises = []
                            })) : t.apply(this, arguments)
                        }
                    }

                    function V(e) {
                        if ("object" == typeof e && e.RTCPeerConnection) {
                            if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function() {
                                    return this._localStreams || (this._localStreams = []), this._localStreams
                                }), !("addStream" in e.RTCPeerConnection.prototype)) {
                                const t = e.RTCPeerConnection.prototype.addTrack;
                                e.RTCPeerConnection.prototype.addStream = function(e) {
                                    this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach((n => t.call(this, n, e))), e.getVideoTracks().forEach((n => t.call(this, n, e)))
                                }, e.RTCPeerConnection.prototype.addTrack = function(e, ...n) {
                                    return n && n.forEach((e => {
                                        this._localStreams ? this._localStreams.includes(e) || this._localStreams.push(e) : this._localStreams = [e]
                                    })), t.apply(this, arguments)
                                }
                            }
                            "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function(e) {
                                this._localStreams || (this._localStreams = []);
                                const t = this._localStreams.indexOf(e);
                                if (-1 === t) return;
                                this._localStreams.splice(t, 1);
                                const n = e.getTracks();
                                this.getSenders().forEach((e => {
                                    n.includes(e.track) && this.removeTrack(e)
                                }))
                            })
                        }
                    }

                    function H(e) {
                        if ("object" == typeof e && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function() {
                                return this._remoteStreams ? this._remoteStreams : []
                            }), !("onaddstream" in e.RTCPeerConnection.prototype))) {
                            Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", {
                                get() {
                                    return this._onaddstream
                                },
                                set(e) {
                                    this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = e => {
                                        e.streams.forEach((e => {
                                            if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e)) return;
                                            this._remoteStreams.push(e);
                                            const t = new Event("addstream");
                                            t.stream = e, this.dispatchEvent(t)
                                        }))
                                    })
                                }
                            });
                            const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                            e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                                const e = this;
                                return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t) {
                                    t.streams.forEach((t => {
                                        if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return;
                                        e._remoteStreams.push(t);
                                        const n = new Event("addstream");
                                        n.stream = t, e.dispatchEvent(n)
                                    }))
                                }), t.apply(e, arguments)
                            }
                        }
                    }

                    function G(e) {
                        if ("object" != typeof e || !e.RTCPeerConnection) return;
                        const t = e.RTCPeerConnection.prototype,
                            n = t.createOffer,
                            i = t.createAnswer,
                            s = t.setLocalDescription,
                            r = t.setRemoteDescription,
                            o = t.addIceCandidate;
                        t.createOffer = function(e, t) {
                            const i = arguments.length >= 2 ? arguments[2] : arguments[0],
                                s = n.apply(this, [i]);
                            return t ? (s.then(e, t), Promise.resolve()) : s
                        }, t.createAnswer = function(e, t) {
                            const n = arguments.length >= 2 ? arguments[2] : arguments[0],
                                s = i.apply(this, [n]);
                            return t ? (s.then(e, t), Promise.resolve()) : s
                        };
                        let a = function(e, t, n) {
                            const i = s.apply(this, [e]);
                            return n ? (i.then(t, n), Promise.resolve()) : i
                        };
                        t.setLocalDescription = a, a = function(e, t, n) {
                            const i = r.apply(this, [e]);
                            return n ? (i.then(t, n), Promise.resolve()) : i
                        }, t.setRemoteDescription = a, a = function(e, t, n) {
                            const i = o.apply(this, [e]);
                            return n ? (i.then(t, n), Promise.resolve()) : i
                        }, t.addIceCandidate = a
                    }

                    function q(e) {
                        const t = e && e.navigator;
                        if (t.mediaDevices && t.mediaDevices.getUserMedia) {
                            const e = t.mediaDevices,
                                n = e.getUserMedia.bind(e);
                            t.mediaDevices.getUserMedia = e => n(K(e))
                        }!t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function(e, n, i) {
                            t.mediaDevices.getUserMedia(e).then(n, i)
                        }.bind(t))
                    }

                    function K(e) {
                        return e && void 0 !== e.video ? Object.assign({}, e, {
                            video: g(e.video)
                        }) : e
                    }

                    function z(e) {
                        if (!e.RTCPeerConnection) return;
                        const t = e.RTCPeerConnection;
                        e.RTCPeerConnection = function(e, n) {
                            if (e && e.iceServers) {
                                const t = [];
                                for (let n = 0; n < e.iceServers.length; n++) {
                                    let i = e.iceServers[n];
                                    !i.hasOwnProperty("urls") && i.hasOwnProperty("url") ? (m("RTCIceServer.url", "RTCIceServer.urls"), i = JSON.parse(JSON.stringify(i)), i.urls = i.url, delete i.url, t.push(i)) : t.push(e.iceServers[n])
                                }
                                e.iceServers = t
                            }
                            return new t(e, n)
                        }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {
                            get: () => t.generateCertificate
                        })
                    }

                    function W(e) {
                        "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                            get() {
                                return {
                                    receiver: this.receiver
                                }
                            }
                        })
                    }

                    function Q(e) {
                        const t = e.RTCPeerConnection.prototype.createOffer;
                        e.RTCPeerConnection.prototype.createOffer = function(e) {
                            if (e) {
                                void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio);
                                const t = this.getTransceivers().find((e => "audio" === e.receiver.track.kind));
                                !1 === e.offerToReceiveAudio && t ? "sendrecv" === t.direction ? t.setDirection ? t.setDirection("sendonly") : t.direction = "sendonly" : "recvonly" === t.direction && (t.setDirection ? t.setDirection("inactive") : t.direction = "inactive") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver("audio"), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo);
                                const n = this.getTransceivers().find((e => "video" === e.receiver.track.kind));
                                !1 === e.offerToReceiveVideo && n ? "sendrecv" === n.direction ? n.setDirection ? n.setDirection("sendonly") : n.direction = "sendonly" : "recvonly" === n.direction && (n.setDirection ? n.setDirection("inactive") : n.direction = "inactive") : !0 !== e.offerToReceiveVideo || n || this.addTransceiver("video")
                            }
                            return t.apply(this, arguments)
                        }
                    }

                    function X(e) {
                        "object" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext)
                    }
                    var Y = n(5952),
                        Z = n.n(Y);

                    function ee(e) {
                        if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return;
                        const t = e.RTCIceCandidate;
                        e.RTCIceCandidate = function(e) {
                            if ("object" == typeof e && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) {
                                const n = new t(e),
                                    i = Z().parseCandidate(e.candidate),
                                    s = Object.assign(n, i);
                                return s.toJSON = function() {
                                    return {
                                        candidate: s.candidate,
                                        sdpMid: s.sdpMid,
                                        sdpMLineIndex: s.sdpMLineIndex,
                                        usernameFragment: s.usernameFragment
                                    }
                                }, s
                            }
                            return new t(e)
                        }, e.RTCIceCandidate.prototype = t.prototype, l(e, "icecandidate", (t => (t.candidate && Object.defineProperty(t, "candidate", {
                            value: new e.RTCIceCandidate(t.candidate),
                            writable: "false"
                        }), t)))
                    }

                    function te(e, t) {
                        if (!e.RTCPeerConnection) return;
                        "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", {
                            get() {
                                return void 0 === this._sctp ? null : this._sctp
                            }
                        });
                        const n = function(e) {
                                if (!e || !e.sdp) return !1;
                                const t = Z().splitSections(e.sdp);
                                return t.shift(), t.some((e => {
                                    const t = Z().parseMLine(e);
                                    return t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP")
                                }))
                            },
                            i = function(e) {
                                const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
                                if (null === t || t.length < 2) return -1;
                                const n = parseInt(t[1], 10);
                                return n != n ? -1 : n
                            },
                            s = function(e) {
                                let n = 65536;
                                return "firefox" === t.browser && (n = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), n
                            },
                            r = function(e, n) {
                                let i = 65536;
                                "firefox" === t.browser && 57 === t.version && (i = 65535);
                                const s = Z().matchPrefix(e.sdp, "a=max-message-size:");
                                return s.length > 0 ? i = parseInt(s[0].substr(19), 10) : "firefox" === t.browser && -1 !== n && (i = 2147483637), i
                            },
                            o = e.RTCPeerConnection.prototype.setRemoteDescription;
                        e.RTCPeerConnection.prototype.setRemoteDescription = function() {
                            if (this._sctp = null, "chrome" === t.browser && t.version >= 76) {
                                const {
                                    sdpSemantics: e
                                } = this.getConfiguration();
                                "plan-b" === e && Object.defineProperty(this, "sctp", {
                                    get() {
                                        return void 0 === this._sctp ? null : this._sctp
                                    },
                                    enumerable: !0,
                                    configurable: !0
                                })
                            }
                            if (n(arguments[0])) {
                                const e = i(arguments[0]),
                                    t = s(e),
                                    n = r(arguments[0], e);
                                let o;
                                o = 0 === t && 0 === n ? Number.POSITIVE_INFINITY : 0 === t || 0 === n ? Math.max(t, n) : Math.min(t, n);
                                const a = {};
                                Object.defineProperty(a, "maxMessageSize", {
                                    get: () => o
                                }), this._sctp = a
                            }
                            return o.apply(this, arguments)
                        }
                    }

                    function ne(e) {
                        if (!e.RTCPeerConnection || !("createDataChannel" in e.RTCPeerConnection.prototype)) return;

                        function t(e, t) {
                            const n = e.send;
                            e.send = function() {
                                const i = arguments[0],
                                    s = i.length || i.size || i.byteLength;
                                if ("open" === e.readyState && t.sctp && s > t.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)");
                                return n.apply(e, arguments)
                            }
                        }
                        const n = e.RTCPeerConnection.prototype.createDataChannel;
                        e.RTCPeerConnection.prototype.createDataChannel = function() {
                            const e = n.apply(this, arguments);
                            return t(e, this), e
                        }, l(e, "datachannel", (e => (t(e.channel, e.target), e)))
                    }

                    function ie(e) {
                        if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return;
                        const t = e.RTCPeerConnection.prototype;
                        Object.defineProperty(t, "connectionState", {
                            get() {
                                return {
                                    completed: "connected",
                                    checking: "connecting"
                                } [this.iceConnectionState] || this.iceConnectionState
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(t, "onconnectionstatechange", {
                            get() {
                                return this._onconnectionstatechange || null
                            },
                            set(e) {
                                this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e)
                            },
                            enumerable: !0,
                            configurable: !0
                        }), ["setLocalDescription", "setRemoteDescription"].forEach((e => {
                            const n = t[e];
                            t[e] = function() {
                                return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => {
                                    const t = e.target;
                                    if (t._lastConnectionState !== t.connectionState) {
                                        t._lastConnectionState = t.connectionState;
                                        const n = new Event("connectionstatechange", e);
                                        t.dispatchEvent(n)
                                    }
                                    return e
                                }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), n.apply(this, arguments)
                            }
                        }))
                    }

                    function se(e, t) {
                        if (!e.RTCPeerConnection) return;
                        if ("chrome" === t.browser && t.version >= 71) return;
                        if ("safari" === t.browser && t.version >= 605) return;
                        const n = e.RTCPeerConnection.prototype.setRemoteDescription;
                        e.RTCPeerConnection.prototype.setRemoteDescription = function(t) {
                            if (t && t.sdp && -1 !== t.sdp.indexOf("\na=extmap-allow-mixed")) {
                                const n = t.sdp.split("\n").filter((e => "a=extmap-allow-mixed" !== e.trim())).join("\n");
                                e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({
                                    type: t.type,
                                    sdp: n
                                }) : t.sdp = n
                            }
                            return n.apply(this, arguments)
                        }
                    }

                    function re(e, t) {
                        if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
                        const n = e.RTCPeerConnection.prototype.addIceCandidate;
                        n && 0 !== n.length && (e.RTCPeerConnection.prototype.addIceCandidate = function() {
                            return arguments[0] ? ("chrome" === t.browser && t.version < 78 || "firefox" === t.browser && t.version < 68 || "safari" === t.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : n.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve())
                        })
                    }
                    const oe = function({
                            window: e
                        } = {}, t = {
                            shimChrome: !0,
                            shimFirefox: !0,
                            shimSafari: !0
                        }) {
                            const n = p,
                                a = function(e) {
                                    const t = {
                                        browser: null,
                                        version: null
                                    };
                                    if (void 0 === e || !e.navigator) return t.browser = "Not a browser.", t;
                                    const {
                                        navigator: n
                                    } = e;
                                    if (n.mozGetUserMedia) t.browser = "firefox", t.version = d(n.userAgent, /Firefox\/(\d+)\./, 1);
                                    else if (n.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = d(n.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
                                    else {
                                        if (!e.RTCPeerConnection || !n.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t;
                                        t.browser = "safari", t.version = d(n.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype
                                    }
                                    return t
                                }(e),
                                c = {
                                    browserDetails: a,
                                    commonShim: o,
                                    extractVersion: d,
                                    disableLog: h,
                                    disableWarnings: u,
                                    sdp: Y
                                };
                            switch (a.browser) {
                                case "chrome":
                                    if (!i || !I || !t.shimChrome) return n("Chrome shim is not included in this adapter release."), c;
                                    if (null === a.version) return n("Chrome shim can not determine version, not shimming."), c;
                                    n("adapter.js shimming chrome."), c.browserShim = i, re(e, a), S(e, a), b(e), I(e, a), C(e), P(e, a), T(e), R(e), A(e), M(e, a), ee(e), ie(e), te(e, a), ne(e), se(e, a);
                                    break;
                                case "firefox":
                                    if (!s || !O || !t.shimFirefox) return n("Firefox shim is not included in this adapter release."), c;
                                    n("adapter.js shimming firefox."), c.browserShim = s, re(e, a), D(e, a), O(e, a), k(e), F(e), L(e), x(e), j(e), $(e), B(e), J(e), U(e), ee(e), ie(e), te(e, a), ne(e);
                                    break;
                                case "safari":
                                    if (!r || !t.shimSafari) return n("Safari shim is not included in this adapter release."), c;
                                    n("adapter.js shimming safari."), c.browserShim = r, re(e, a), z(e), Q(e), G(e), V(e), H(e), W(e), q(e), X(e), ee(e), te(e, a), ne(e), se(e, a);
                                    break;
                                default:
                                    n("Unsupported browser!")
                            }
                            return c
                        }({
                            window: "undefined" == typeof window ? void 0 : window
                        }),
                        ae = oe
                },
                825: (e, t) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    const n = [];
                    for (let e = 0; e < 256; ++e) n.push((e + 256).toString(16).substr(1));
                    t.default = function(e, t) {
                        const i = t || 0,
                            s = n;
                        return (s[e[i + 0]] + s[e[i + 1]] + s[e[i + 2]] + s[e[i + 3]] + "-" + s[e[i + 4]] + s[e[i + 5]] + "-" + s[e[i + 6]] + s[e[i + 7]] + "-" + s[e[i + 8]] + s[e[i + 9]] + "-" + s[e[i + 10]] + s[e[i + 11]] + s[e[i + 12]] + s[e[i + 13]] + s[e[i + 14]] + s[e[i + 15]]).toLowerCase()
                    }
                },
                7593: (e, t, n) => {
                    "use strict";
                    Object.defineProperty(t, "v1", {
                        enumerable: !0,
                        get: function() {
                            return i.default
                        }
                    }), Object.defineProperty(t, "v3", {
                        enumerable: !0,
                        get: function() {
                            return s.default
                        }
                    }), Object.defineProperty(t, "v4", {
                        enumerable: !0,
                        get: function() {
                            return r.default
                        }
                    }), Object.defineProperty(t, "v5", {
                        enumerable: !0,
                        get: function() {
                            return o.default
                        }
                    });
                    var i = a(n(4922)),
                        s = a(n(6964)),
                        r = a(n(8509)),
                        o = a(n(5669));

                    function a(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    }
                },
                489: (e, t) => {
                    "use strict";

                    function n(e) {
                        return 14 + (e + 64 >>> 9 << 4) + 1
                    }

                    function i(e, t) {
                        const n = (65535 & e) + (65535 & t);
                        return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n
                    }

                    function s(e, t, n, s, r, o) {
                        return i((a = i(i(t, e), i(s, o))) << (c = r) | a >>> 32 - c, n);
                        var a, c
                    }

                    function r(e, t, n, i, r, o, a) {
                        return s(t & n | ~t & i, e, t, r, o, a)
                    }

                    function o(e, t, n, i, r, o, a) {
                        return s(t & i | n & ~i, e, t, r, o, a)
                    }

                    function a(e, t, n, i, r, o, a) {
                        return s(t ^ n ^ i, e, t, r, o, a)
                    }

                    function c(e, t, n, i, r, o, a) {
                        return s(n ^ (t | ~i), e, t, r, o, a)
                    }
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    t.default = function(e) {
                        if ("string" == typeof e) {
                            const t = unescape(encodeURIComponent(e));
                            e = new Uint8Array(t.length);
                            for (let n = 0; n < t.length; ++n) e[n] = t.charCodeAt(n)
                        }
                        return function(e) {
                            const t = [],
                                n = 32 * e.length,
                                i = "0123456789abcdef";
                            for (let s = 0; s < n; s += 8) {
                                const n = e[s >> 5] >>> s % 32 & 255,
                                    r = parseInt(i.charAt(n >>> 4 & 15) + i.charAt(15 & n), 16);
                                t.push(r)
                            }
                            return t
                        }(function(e, t) {
                            e[t >> 5] |= 128 << t % 32, e[n(t) - 1] = t;
                            let s = 1732584193,
                                d = -271733879,
                                l = -1732584194,
                                h = 271733878;
                            for (let t = 0; t < e.length; t += 16) {
                                const n = s,
                                    u = d,
                                    p = l,
                                    m = h;
                                s = r(s, d, l, h, e[t], 7, -680876936), h = r(h, s, d, l, e[t + 1], 12, -389564586), l = r(l, h, s, d, e[t + 2], 17, 606105819), d = r(d, l, h, s, e[t + 3], 22, -1044525330), s = r(s, d, l, h, e[t + 4], 7, -176418897), h = r(h, s, d, l, e[t + 5], 12, 1200080426), l = r(l, h, s, d, e[t + 6], 17, -1473231341), d = r(d, l, h, s, e[t + 7], 22, -45705983), s = r(s, d, l, h, e[t + 8], 7, 1770035416), h = r(h, s, d, l, e[t + 9], 12, -1958414417), l = r(l, h, s, d, e[t + 10], 17, -42063), d = r(d, l, h, s, e[t + 11], 22, -1990404162), s = r(s, d, l, h, e[t + 12], 7, 1804603682), h = r(h, s, d, l, e[t + 13], 12, -40341101), l = r(l, h, s, d, e[t + 14], 17, -1502002290), d = r(d, l, h, s, e[t + 15], 22, 1236535329), s = o(s, d, l, h, e[t + 1], 5, -165796510), h = o(h, s, d, l, e[t + 6], 9, -1069501632), l = o(l, h, s, d, e[t + 11], 14, 643717713), d = o(d, l, h, s, e[t], 20, -373897302), s = o(s, d, l, h, e[t + 5], 5, -701558691), h = o(h, s, d, l, e[t + 10], 9, 38016083), l = o(l, h, s, d, e[t + 15], 14, -660478335), d = o(d, l, h, s, e[t + 4], 20, -405537848), s = o(s, d, l, h, e[t + 9], 5, 568446438), h = o(h, s, d, l, e[t + 14], 9, -1019803690), l = o(l, h, s, d, e[t + 3], 14, -187363961), d = o(d, l, h, s, e[t + 8], 20, 1163531501), s = o(s, d, l, h, e[t + 13], 5, -1444681467), h = o(h, s, d, l, e[t + 2], 9, -51403784), l = o(l, h, s, d, e[t + 7], 14, 1735328473), d = o(d, l, h, s, e[t + 12], 20, -1926607734), s = a(s, d, l, h, e[t + 5], 4, -378558), h = a(h, s, d, l, e[t + 8], 11, -2022574463), l = a(l, h, s, d, e[t + 11], 16, 1839030562), d = a(d, l, h, s, e[t + 14], 23, -35309556), s = a(s, d, l, h, e[t + 1], 4, -1530992060), h = a(h, s, d, l, e[t + 4], 11, 1272893353), l = a(l, h, s, d, e[t + 7], 16, -155497632), d = a(d, l, h, s, e[t + 10], 23, -1094730640), s = a(s, d, l, h, e[t + 13], 4, 681279174), h = a(h, s, d, l, e[t], 11, -358537222), l = a(l, h, s, d, e[t + 3], 16, -722521979), d = a(d, l, h, s, e[t + 6], 23, 76029189), s = a(s, d, l, h, e[t + 9], 4, -640364487), h = a(h, s, d, l, e[t + 12], 11, -421815835), l = a(l, h, s, d, e[t + 15], 16, 530742520), d = a(d, l, h, s, e[t + 2], 23, -995338651), s = c(s, d, l, h, e[t], 6, -198630844), h = c(h, s, d, l, e[t + 7], 10, 1126891415), l = c(l, h, s, d, e[t + 14], 15, -1416354905), d = c(d, l, h, s, e[t + 5], 21, -57434055), s = c(s, d, l, h, e[t + 12], 6, 1700485571), h = c(h, s, d, l, e[t + 3], 10, -1894986606), l = c(l, h, s, d, e[t + 10], 15, -1051523), d = c(d, l, h, s, e[t + 1], 21, -2054922799), s = c(s, d, l, h, e[t + 8], 6, 1873313359), h = c(h, s, d, l, e[t + 15], 10, -30611744), l = c(l, h, s, d, e[t + 6], 15, -1560198380), d = c(d, l, h, s, e[t + 13], 21, 1309151649), s = c(s, d, l, h, e[t + 4], 6, -145523070), h = c(h, s, d, l, e[t + 11], 10, -1120210379), l = c(l, h, s, d, e[t + 2], 15, 718787259), d = c(d, l, h, s, e[t + 9], 21, -343485551), s = i(s, n), d = i(d, u), l = i(l, p), h = i(h, m)
                            }
                            return [s, d, l, h]
                        }(function(e) {
                            if (0 === e.length) return [];
                            const t = 8 * e.length,
                                i = new Uint32Array(n(t));
                            for (let n = 0; n < t; n += 8) i[n >> 5] |= (255 & e[n / 8]) << n % 32;
                            return i
                        }(e), 8 * e.length))
                    }
                },
                6827: (e, t) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = function() {
                        if (!n) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                        return n(i)
                    };
                    const n = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto),
                        i = new Uint8Array(16)
                },
                3558: (e, t) => {
                    "use strict";

                    function n(e, t, n, i) {
                        switch (e) {
                            case 0:
                                return t & n ^ ~t & i;
                            case 1:
                            case 3:
                                return t ^ n ^ i;
                            case 2:
                                return t & n ^ t & i ^ n & i
                        }
                    }

                    function i(e, t) {
                        return e << t | e >>> 32 - t
                    }
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    t.default = function(e) {
                        const t = [1518500249, 1859775393, 2400959708, 3395469782],
                            s = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
                        if ("string" == typeof e) {
                            const t = unescape(encodeURIComponent(e));
                            e = [];
                            for (let n = 0; n < t.length; ++n) e.push(t.charCodeAt(n))
                        }
                        e.push(128);
                        const r = e.length / 4 + 2,
                            o = Math.ceil(r / 16),
                            a = new Array(o);
                        for (let t = 0; t < o; ++t) {
                            const n = new Uint32Array(16);
                            for (let i = 0; i < 16; ++i) n[i] = e[64 * t + 4 * i] << 24 | e[64 * t + 4 * i + 1] << 16 | e[64 * t + 4 * i + 2] << 8 | e[64 * t + 4 * i + 3];
                            a[t] = n
                        }
                        a[o - 1][14] = 8 * (e.length - 1) / Math.pow(2, 32), a[o - 1][14] = Math.floor(a[o - 1][14]), a[o - 1][15] = 8 * (e.length - 1) & 4294967295;
                        for (let e = 0; e < o; ++e) {
                            const r = new Uint32Array(80);
                            for (let t = 0; t < 16; ++t) r[t] = a[e][t];
                            for (let e = 16; e < 80; ++e) r[e] = i(r[e - 3] ^ r[e - 8] ^ r[e - 14] ^ r[e - 16], 1);
                            let o = s[0],
                                c = s[1],
                                d = s[2],
                                l = s[3],
                                h = s[4];
                            for (let e = 0; e < 80; ++e) {
                                const s = Math.floor(e / 20),
                                    a = i(o, 5) + n(s, c, d, l) + h + t[s] + r[e] >>> 0;
                                h = l, l = d, d = i(c, 30) >>> 0, c = o, o = a
                            }
                            s[0] = s[0] + o >>> 0, s[1] = s[1] + c >>> 0, s[2] = s[2] + d >>> 0, s[3] = s[3] + l >>> 0, s[4] = s[4] + h >>> 0
                        }
                        return [s[0] >> 24 & 255, s[0] >> 16 & 255, s[0] >> 8 & 255, 255 & s[0], s[1] >> 24 & 255, s[1] >> 16 & 255, s[1] >> 8 & 255, 255 & s[1], s[2] >> 24 & 255, s[2] >> 16 & 255, s[2] >> 8 & 255, 255 & s[2], s[3] >> 24 & 255, s[3] >> 16 & 255, s[3] >> 8 & 255, 255 & s[3], s[4] >> 24 & 255, s[4] >> 16 & 255, s[4] >> 8 & 255, 255 & s[4]]
                    }
                },
                4922: (e, t, n) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    var i = r(n(6827)),
                        s = r(n(825));

                    function r(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    }
                    let o, a, c = 0,
                        d = 0;
                    t.default = function(e, t, n) {
                        let r = t && n || 0;
                        const l = t || [];
                        let h = (e = e || {}).node || o,
                            u = void 0 !== e.clockseq ? e.clockseq : a;
                        if (null == h || null == u) {
                            const t = e.random || (e.rng || i.default)();
                            null == h && (h = o = [1 | t[0], t[1], t[2], t[3], t[4], t[5]]), null == u && (u = a = 16383 & (t[6] << 8 | t[7]))
                        }
                        let p = void 0 !== e.msecs ? e.msecs : Date.now(),
                            m = void 0 !== e.nsecs ? e.nsecs : d + 1;
                        const f = p - c + (m - d) / 1e4;
                        if (f < 0 && void 0 === e.clockseq && (u = u + 1 & 16383), (f < 0 || p > c) && void 0 === e.nsecs && (m = 0), m >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
                        c = p, d = m, a = u, p += 122192928e5;
                        const g = (1e4 * (268435455 & p) + m) % 4294967296;
                        l[r++] = g >>> 24 & 255, l[r++] = g >>> 16 & 255, l[r++] = g >>> 8 & 255, l[r++] = 255 & g;
                        const _ = p / 4294967296 * 1e4 & 268435455;
                        l[r++] = _ >>> 8 & 255, l[r++] = 255 & _, l[r++] = _ >>> 24 & 15 | 16, l[r++] = _ >>> 16 & 255, l[r++] = u >>> 8 | 128, l[r++] = 255 & u;
                        for (let e = 0; e < 6; ++e) l[r + e] = h[e];
                        return t || (0, s.default)(l)
                    }
                },
                6964: (e, t, n) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    var i = r(n(9137)),
                        s = r(n(489));

                    function r(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    }
                    var o = (0, i.default)("v3", 48, s.default);
                    t.default = o
                },
                9137: (e, t, n) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = function(e, t, n) {
                        function i(e, i, r, o) {
                            const a = r && o || 0;
                            if ("string" == typeof e && (e = function(e) {
                                    e = unescape(encodeURIComponent(e));
                                    const t = [];
                                    for (let n = 0; n < e.length; ++n) t.push(e.charCodeAt(n));
                                    return t
                                }(e)), "string" == typeof i && (i = function(e) {
                                    const t = [];
                                    return e.replace(/[a-fA-F0-9]{2}/g, (function(e) {
                                        t.push(parseInt(e, 16))
                                    })), t
                                }(i)), !Array.isArray(e)) throw TypeError("value must be an array of bytes");
                            if (!Array.isArray(i) || 16 !== i.length) throw TypeError("namespace must be uuid string or an Array of 16 byte values");
                            const c = n(i.concat(e));
                            if (c[6] = 15 & c[6] | t, c[8] = 63 & c[8] | 128, r)
                                for (let e = 0; e < 16; ++e) r[a + e] = c[e];
                            return r || (0, s.default)(c)
                        }
                        try {
                            i.name = e
                        } catch (e) {}
                        return i.DNS = r, i.URL = o, i
                    }, t.URL = t.DNS = void 0;
                    var i, s = (i = n(825)) && i.__esModule ? i : {
                        default: i
                    };
                    const r = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
                    t.DNS = r;
                    const o = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
                    t.URL = o
                },
                8509: (e, t, n) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    var i = r(n(6827)),
                        s = r(n(825));

                    function r(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    }
                    t.default = function(e, t, n) {
                        "string" == typeof e && (t = "binary" === e ? new Uint8Array(16) : null, e = null);
                        const r = (e = e || {}).random || (e.rng || i.default)();
                        if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {
                            const e = n || 0;
                            for (let n = 0; n < 16; ++n) t[e + n] = r[n];
                            return t
                        }
                        return (0, s.default)(r)
                    }
                },
                5669: (e, t, n) => {
                    "use strict";
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.default = void 0;
                    var i = r(n(9137)),
                        s = r(n(3558));

                    function r(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    }
                    var o = (0, i.default)("v5", 80, s.default);
                    t.default = o
                },
                5571: (e, t, n) => {
                    "use strict";
                    n.d(t, {
                        default: () => rd
                    });
                    var i = {};
                    n.r(i), n.d(i, {
                        AUTHENTICATION_REQUIRED: () => _,
                        CHAT_ERROR: () => v,
                        CONFERENCE_ACCESS_DENIED: () => R,
                        CONFERENCE_DESTROYED: () => y,
                        CONFERENCE_MAX_USERS: () => S,
                        CONFERENCE_RESTARTED: () => b,
                        CONNECTION_ERROR: () => E,
                        FOCUS_DISCONNECTED: () => A,
                        FOCUS_LEFT: () => w,
                        GRACEFUL_SHUTDOWN: () => P,
                        ICE_FAILED: () => I,
                        INCOMPATIBLE_SERVER_VERSIONS: () => M,
                        MEMBERS_ONLY_ERROR: () => T,
                        NOT_ALLOWED_ERROR: () => C,
                        OFFER_ANSWER_FAILED: () => D,
                        PASSWORD_NOT_SUPPORTED: () => N,
                        PASSWORD_REQUIRED: () => k,
                        RESERVATION_ERROR: () => O,
                        VIDEOBRIDGE_NOT_AVAILABLE: () => L
                    });
                    var s = {};
                    n.r(s), n.d(s, {
                        AUDIO_INPUT_STATE_CHANGE: () => x,
                        AUTH_STATUS_CHANGED: () => F,
                        AV_MODERATION_APPROVED: () => Ue,
                        AV_MODERATION_CHANGED: () => He,
                        AV_MODERATION_PARTICIPANT_APPROVED: () => Ge,
                        AV_MODERATION_PARTICIPANT_REJECTED: () => qe,
                        AV_MODERATION_REJECTED: () => Ve,
                        BEFORE_STATISTICS_DISPOSED: () => j,
                        BOT_TYPE_CHANGED: () => je,
                        CONFERENCE_CREATED_TIMESTAMP: () => X,
                        CONFERENCE_ERROR: () => B,
                        CONFERENCE_FAILED: () => J,
                        CONFERENCE_JOINED: () => U,
                        CONFERENCE_LEFT: () => V,
                        CONFERENCE_UNIQUE_ID_SET: () => H,
                        CONNECTION_ESTABLISHED: () => G,
                        CONNECTION_INTERRUPTED: () => q,
                        CONNECTION_RESTORED: () => K,
                        DATA_CHANNEL_OPENED: () => z,
                        DISPLAY_NAME_CHANGED: () => W,
                        DOMINANT_SPEAKER_CHANGED: () => Q,
                        DTMF_SUPPORT_CHANGED: () => Y,
                        ENDPOINT_MESSAGE_RECEIVED: () => Z,
                        ENDPOINT_STATS_RECEIVED: () => ee,
                        JVB121_STATUS: () => te,
                        KICKED: () => ne,
                        LAST_N_ENDPOINTS_CHANGED: () => se,
                        LOBBY_USER_JOINED: () => $e,
                        LOBBY_USER_LEFT: () => Je,
                        LOBBY_USER_UPDATED: () => Be,
                        LOCK_STATE_CHANGED: () => re,
                        MEMBERS_ONLY_CHANGED: () => de,
                        MESSAGE_RECEIVED: () => le,
                        NOISY_MIC: () => ue,
                        NON_PARTICIPANT_MESSAGE_RECEIVED: () => pe,
                        NO_AUDIO_INPUT: () => he,
                        P2P_STATUS: () => ve,
                        PARTCIPANT_FEATURES_CHANGED: () => ge,
                        PARTICIPANT_CONN_STATUS_CHANGED: () => fe,
                        PARTICIPANT_KICKED: () => ie,
                        PARTICIPANT_PROPERTY_CHANGED: () => _e,
                        PHONE_NUMBER_CHANGED: () => ye,
                        PRIVATE_MESSAGE_RECEIVED: () => me,
                        PROPERTIES_CHANGED: () => Se,
                        RECORDER_STATE_CHANGED: () => Ee,
                        SERVER_REGION_CHANGED: () => oe,
                        STARTED_MUTED: () => Re,
                        START_MUTED_POLICY_CHANGED: () => Te,
                        SUBJECT_CHANGED: () => Ae,
                        SUSPEND_DETECTED: () => we,
                        TALK_WHILE_MUTED: () => Pe,
                        TRACK_ADDED: () => Ie,
                        TRACK_AUDIO_LEVEL_CHANGED: () => Me,
                        TRACK_MUTE_CHANGED: () => De,
                        TRACK_REMOVED: () => Ne,
                        TRANSCRIPTION_STATUS_CHANGED: () => ke,
                        USER_JOINED: () => Oe,
                        USER_LEFT: () => Le,
                        USER_ROLE_CHANGED: () => xe,
                        USER_STATUS_CHANGED: () => Fe,
                        VIDEO_SIP_GW_AVAILABILITY_CHANGED: () => be,
                        VIDEO_SIP_GW_SESSION_STATE_CHANGED: () => Ce,
                        _MEDIA_SESSION_ACTIVE_CHANGED: () => ce,
                        _MEDIA_SESSION_STARTED: () => ae
                    });
                    var r = {};
                    n.r(r), n.d(r, {
                        CONSTRAINT_FAILED: () => Ze,
                        ELECTRON_DESKTOP_PICKER_ERROR: () => et,
                        ELECTRON_DESKTOP_PICKER_NOT_FOUND: () => tt,
                        GENERAL: () => nt,
                        NOT_FOUND: () => it,
                        PERMISSION_DENIED: () => st,
                        SCREENSHARING_GENERIC_ERROR: () => rt,
                        SCREENSHARING_USER_CANCELED: () => ot,
                        TIMEOUT: () => at,
                        TRACK_IS_DISPOSED: () => ct,
                        TRACK_NO_STREAM_FOUND: () => dt,
                        UNSUPPORTED_RESOLUTION: () => lt
                    });
                    var o = {};
                    n.r(o), n.d(o, {
                        LOCAL_TRACK_STOPPED: () => Kn,
                        NO_AUDIO_INPUT: () => Zn,
                        NO_DATA_FROM_SOURCE: () => Yn,
                        TRACK_AUDIO_LEVEL_CHANGED: () => zn,
                        TRACK_AUDIO_OUTPUT_CHANGED: () => Wn,
                        TRACK_MUTE_CHANGED: () => Qn,
                        TRACK_VIDEOTYPE_CHANGED: () => Xn
                    });
                    var a = {};
                    n.r(a), n.d(a, {
                        CONNECTION_DISCONNECTED: () => oi,
                        CONNECTION_ESTABLISHED: () => ai,
                        CONNECTION_FAILED: () => ci,
                        DISPLAY_NAME_REQUIRED: () => li,
                        WRONG_STATE: () => di
                    });
                    var c = {};
                    n.r(c), n.d(c, {
                        CONNECTION_DROPPED_ERROR: () => hi,
                        OTHER_ERROR: () => ui,
                        PASSWORD_REQUIRED: () => pi,
                        SERVER_ERROR: () => mi
                    });
                    var d = {};
                    n.r(d), n.d(d, {
                        OFF: () => rs,
                        ON: () => ss
                    });
                    var l = {};
                    n.r(l), n.d(l, {
                        LOCAL_STATS_UPDATED: () => aa,
                        REMOTE_STATS_UPDATED: () => ca
                    });
                    var h = {};
                    n.r(h), n.d(h, {
                        AUDIO_INPUT_STATE_CHANGE: () => ya,
                        DETECTOR_STATE_CHANGE: () => va,
                        NO_AUDIO_INPUT: () => Sa,
                        VAD_NOISY_DEVICE: () => Ea,
                        VAD_REPORT_PUBLISHED: () => ba,
                        VAD_SCORE_PUBLISHED: () => Ca,
                        VAD_TALK_WHILE_MUTED: () => Ta
                    });
                    var u = {};
                    n.r(u), n.d(u, {
                        E2E_RTT_CHANGED: () => ka
                    });
                    var p = {};
                    n.r(p), n.d(p, {
                        ERROR_NO_CONNECTION: () => gc,
                        ERROR_SESSION_EXISTS: () => _c,
                        STATE_FAILED: () => fc,
                        STATE_OFF: () => uc,
                        STATE_ON: () => hc,
                        STATE_PENDING: () => pc,
                        STATE_RETRYING: () => mc,
                        STATUS_AVAILABLE: () => cc,
                        STATUS_BUSY: () => lc,
                        STATUS_UNDEFINED: () => dc
                    });
                    var m = {};
                    n.r(m), n.d(m, {
                        DEVICE_LIST_CHANGED: () => Pc,
                        PERMISSIONS_CHANGED: () => Ic,
                        PERMISSION_PROMPT_IS_SHOWN: () => Mc,
                        SLOW_GET_USER_MEDIA: () => Dc
                    });
                    var f = n(7055),
                        g = n.n(f);
                    const _ = "conference.authenticationRequired",
                        v = "conference.chatError",
                        y = "conference.destroyed",
                        S = "conference.max_users",
                        E = "conference.connectionError",
                        b = "conference.restarted",
                        C = "conference.connectionError.notAllowed",
                        T = "conference.connectionError.membersOnly",
                        R = "conference.connectionError.accessDenied",
                        A = "conference.focusDisconnected",
                        w = "conference.focusLeft",
                        P = "conference.gracefulShutdown",
                        I = "conference.iceFailed",
                        M = "conference.incompatible_server_versions",
                        D = "conference.offerAnswerFailed",
                        N = "conference.passwordNotSupported",
                        k = "conference.passwordRequired",
                        O = "conference.reservationError",
                        L = "conference.videobridgeNotAvailable",
                        x = "conference.audio_input_state_changed",
                        F = "conference.auth_status_changed",
                        j = "conference.beforeStatisticsDisposed",
                        B = "conference.error",
                        J = "conference.failed",
                        U = "conference.joined",
                        V = "conference.left",
                        H = "conference.unique_id_set",
                        G = "conference.connectionEstablished",
                        q = "conference.connectionInterrupted",
                        K = "conference.connectionRestored",
                        z = "conference.dataChannelOpened",
                        W = "conference.displayNameChanged",
                        Q = "conference.dominantSpeaker",
                        X = "conference.createdTimestamp",
                        Y = "conference.dtmfSupportChanged",
                        Z = "conference.endpoint_message_received",
                        ee = "conference.endpoint_stats_received",
                        te = "conference.jvb121Status",
                        ne = "conference.kicked",
                        ie = "conference.participant_kicked",
                        se = "conference.lastNEndpointsChanged",
                        re = "conference.lock_state_changed",
                        oe = "conference.server_region_changed",
                        ae = "conference.media_session.started",
                        ce = "conference.media_session.active_changed",
                        de = "conference.membersOnlyChanged",
                        le = "conference.messageReceived",
                        he = "conference.no_audio_input",
                        ue = "conference.noisy_mic",
                        pe = "conference.non_participant_message_received",
                        me = "conference.privateMessageReceived",
                        fe = "conference.participant_conn_status_changed",
                        ge = "conference.partcipant_features_changed",
                        _e = "conference.participant_property_changed",
                        ve = "conference.p2pStatus",
                        ye = "conference.phoneNumberChanged",
                        Se = "conference.propertiesChanged",
                        Ee = "conference.recorderStateChanged",
                        be = "conference.videoSIPGWAvailabilityChanged",
                        Ce = "conference.videoSIPGWSessionStateChanged",
                        Te = "conference.start_muted_policy_changed",
                        Re = "conference.started_muted",
                        Ae = "conference.subjectChanged",
                        we = "conference.suspendDetected",
                        Pe = "conference.talk_while_muted",
                        Ie = "conference.trackAdded",
                        Me = "conference.audioLevelsChanged",
                        De = "conference.trackMuteChanged",
                        Ne = "conference.trackRemoved",
                        ke = "conference.transcriptionStatusChanged",
                        Oe = "conference.userJoined",
                        Le = "conference.userLeft",
                        xe = "conference.roleChanged",
                        Fe = "conference.statusChanged",
                        je = "conference.bot_type_changed",
                        $e = "conference.lobby.userJoined",
                        Be = "conference.lobby.userUpdated",
                        Je = "conference.lobby.userLeft",
                        Ue = "conference.av_moderation.approved",
                        Ve = "conference.av_moderation.rejected",
                        He = "conference.av_moderation.changed",
                        Ge = "conference.av_moderation.participant.approved",
                        qe = "conference.av_moderation.participant.rejected";
                    var Ke = n(7853),
                        ze = n.n(Ke),
                        We = n(6847),
                        Qe = n.n(We),
                        Xe = n(9230);
                    const Ye = "https://api.callstats.io/static/callstats-ws.min.js",
                        Ze = "gum.constraint_failed",
                        et = "gum.electron_desktop_picker_error",
                        tt = "gum.electron_desktop_picker_not_found",
                        nt = "gum.general",
                        it = "gum.not_found",
                        st = "gum.permission_denied",
                        rt = "gum.screensharing_generic_error",
                        ot = "gum.screensharing_user_canceled",
                        at = "gum.timeout",
                        ct = "track.track_is_disposed",
                        dt = "track.no_stream_found",
                        lt = "gum.unsupported_resolution",
                        ht = {};

                    function ut(e, t, n) {
                        if ("object" == typeof e && void 0 !== e.name) switch (this.gum = {
                                error: e,
                                constraints: t,
                                devices: n && Array.isArray(n) ? n.slice(0) : void 0
                            }, e.name) {
                            case "NotAllowedError":
                            case "PermissionDeniedError":
                            case "SecurityError":
                                this.name = st, this.message = ht[this.name] + (this.gum.devices || []).join(", ");
                                break;
                            case "DevicesNotFoundError":
                            case "NotFoundError":
                                this.name = it, this.message = ht[this.name] + (this.gum.devices || []).join(", ");
                                break;
                            case "ConstraintNotSatisfiedError":
                            case "OverconstrainedError": {
                                const i = e.constraintName || e.constraint;
                                t && t.video && (!n || n.indexOf("video") > -1) && ("minWidth" === i || "maxWidth" === i || "minHeight" === i || "maxHeight" === i || "width" === i || "height" === i || "deviceId" === i) ? (this.name = lt, this.message = ht[this.name] + function(e, t) {
                                    if (t && t.video && t.video.mandatory) switch (e) {
                                        case "width":
                                            return t.video.mandatory.minWidth;
                                        case "height":
                                            return t.video.mandatory.minHeight;
                                        default:
                                            return t.video.mandatory[e] || ""
                                    }
                                    return ""
                                }(i, t)) : (this.name = Ze, this.message = ht[this.name] + e.constraintName);
                                break
                            }
                            default:
                                this.name = nt, this.message = e.message || ht[this.name]
                        } else {
                            if ("string" != typeof e) throw new Error("Invalid arguments");
                            ht[e] ? (this.name = e, this.message = t || ht[e]) : this.message = e
                        }
                        this.stack = e.stack || (new Error).stack
                    }
                    ht[lt] = "Video resolution is not supported: ", ht[ot] = "User canceled screen sharing prompt", ht[rt] = "Unknown error from screensharing", ht[et] = "Unkown error from desktop picker", ht[tt] = "Failed to detect desktop picker", ht[nt] = "Generic getUserMedia error", ht[st] = "User denied permission to use device(s): ", ht[it] = "Requested device(s) was/were not found: ", ht[Ze] = "Constraint could not be satisfied: ", ht[at] = "Could not start media source. Timeout occured!", ht[ct] = "Track has been already disposed", ht[dt] = "Track does not have an associated Media Stream", ut.prototype = Object.create(Error.prototype), ut.prototype.constructor = ut;
                    const pt = ut;

                    function mt(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? Object(arguments[t]) : {},
                                i = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), i.forEach((function(t) {
                                ft(e, t, n[t])
                            }))
                        }
                        return e
                    }

                    function ft(e, t, n) {
                        return t in e ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = n, e
                    }
                    const gt = "operational",
                        _t = "page",
                        vt = "track",
                        yt = "connection.disconnected",
                        St = "ice.duration";

                    function Et(e, t) {
                        return {
                            action: e,
                            attributes: t,
                            source: "conference",
                            type: gt
                        }
                    }
                    const bt = function(e, t) {
                            const n = "connection.stage.reached";
                            return {
                                action: n,
                                actionSubject: e,
                                attributes: t,
                                source: n,
                                type: gt
                            }
                        },
                        Ct = function(e, t = {}) {
                            return {
                                type: gt,
                                source: "get.user.media",
                                action: e,
                                attributes: t
                            }
                        },
                        Tt = function(e, t = {}) {
                            return {
                                type: gt,
                                action: e,
                                source: "jingle",
                                attributes: t
                            }
                        },
                        Rt = function(e, t = {}) {
                            return {
                                type: gt,
                                action: e,
                                source: "p2p",
                                attributes: t
                            }
                        },
                        At = function(e) {
                            return {
                                type: gt,
                                action: "remotely.muted",
                                mediaType: e
                            }
                        },
                        wt = function(e) {
                            return {
                                type: gt,
                                action: "rtp.stats",
                                attributes: e
                            }
                        },
                        Pt = "statistics.audioLevel",
                        It = "statistics.before_disposed",
                        Mt = "statistics.byte_sent_stats",
                        Dt = "statistics.connectionstats",
                        Nt = "statistics.long_tasks_stats";
                    n(6522);
                    var kt = n(6466);
                    const Ot = "chrome",
                        Lt = "opera",
                        xt = "firefox",
                        Ft = "iexplorer",
                        jt = "safari",
                        $t = "nwjs",
                        Bt = "electron",
                        Jt = "react-native",
                        Ut = "unknown",
                        Vt = {
                            Chrome: Ot,
                            Chromium: Ot,
                            Opera: Lt,
                            Firefox: xt,
                            "Internet Explorer": Ft,
                            Safari: jt
                        };

                    function Ht() {
                        const e = navigator.userAgent;
                        if (e.match(/Electron/)) {
                            const t = e.match(/Electron(?:\s|\/)([\d.]+)/)[1];
                            return {
                                name: Bt,
                                version: t
                            }
                        }
                        if (void 0 !== window.JitsiMeetElectron) return {
                            name: Bt,
                            version: void 0
                        }
                    }

                    function Gt() {
                        const e = navigator.userAgent;
                        if (e.match(/JitsiMeetNW/)) {
                            const t = e.match(/JitsiMeetNW\/([\d.]+)/)[1];
                            return {
                                name: $t,
                                version: t
                            }
                        }
                    }

                    function qt() {
                        const e = navigator.userAgent.match(/\b(react[ \t_-]*native)(?:\/(\S+))?/i);
                        let t;
                        if (e || "ReactNative" === navigator.product) {
                            let n;
                            return e && e.length > 2 && (n = e[1], t = e[2]), n || (n = "react-native"), t || (t = "unknown"), {
                                name: Jt,
                                version: t
                            }
                        }
                    }
                    class Kt extends Ke {
                        constructor(...e) {
                            var t, n;
                            super(...e), n = {}, (t = "_storage") in this ? Object.defineProperty(this, t, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : this[t] = n
                        }
                        clear() {
                            this._storage = {}
                        }
                        get length() {
                            return Object.keys(this._storage).length
                        }
                        getItem(e) {
                            return this._storage[e]
                        }
                        setItem(e, t) {
                            this._storage[e] = t
                        }
                        removeItem(e) {
                            delete this._storage[e]
                        }
                        key(e) {
                            const t = Object.keys(this._storage);
                            if (!(t.length <= e)) return t[e]
                        }
                        serialize() {
                            return JSON.stringify(this._storage)
                        }
                    }
                    const zt = new class extends Ke {
                            constructor() {
                                super();
                                try {
                                    this._storage = window.localStorage, this._localStorageDisabled = !1
                                } catch (e) {}
                                this._storage || (console.warn("Local storage is disabled."), this._storage = new Kt, this._localStorageDisabled = !0)
                            }
                            isLocalStorageDisabled() {
                                return this._localStorageDisabled
                            }
                            clear() {
                                this._storage.clear(), this.emit("changed")
                            }
                            get length() {
                                return this._storage.length
                            }
                            getItem(e) {
                                return this._storage.getItem(e)
                            }
                            setItem(e, t, n = !1) {
                                this._storage.setItem(e, t), n || this.emit("changed")
                            }
                            removeItem(e) {
                                this._storage.removeItem(e), this.emit("changed")
                            }
                            key(e) {
                                return this._storage.key(e)
                            }
                            serialize() {
                                if (this.isLocalStorageDisabled()) return this._storage.serialize();
                                const e = this._storage.length,
                                    t = {};
                                for (let n = 0; n < e; n++) {
                                    const e = this._storage.key(n);
                                    t[e] = this._storage.getItem(e)
                                }
                                return JSON.stringify(t)
                            }
                        },
                        Wt = (0, f.getLogger)("modules/browser/BrowserCapabilities.js"),
                        Qt = new class extends class {
                            constructor(e) {
                                let t, n;
                                if (this._bowser = kt.getParser(navigator.userAgent), void 0 === e) {
                                    const e = function(e) {
                                        let t;
                                        const n = [qt, Ht, Gt];
                                        for (let e = 0; e < n.length; e++)
                                            if (t = n[e](), t) return t;
                                        const i = e.getBrowserName();
                                        return i in Vt ? {
                                            name: Vt[i],
                                            version: e.getBrowserVersion()
                                        } : (t = function() {
                                            const e = navigator.userAgent,
                                                t = {
                                                    name: Ut,
                                                    version: void 0
                                                };
                                            if (e.match(/Chrome/) && !e.match(/Edge/))
                                                if (e.match(/Edg(A?)/)) {
                                                    const n = e.match(/Chrome\/([\d.]+)/)[1];
                                                    Number.parseInt(n, 10) > 72 && (t.name = Ot, t.version = n)
                                                } else t.name = Ot, t.version = e.match(/Chrome\/([\d.]+)/)[1];
                                            return t
                                        }(), t || {
                                            name: Ut,
                                            version: void 0
                                        })
                                    }(this._bowser);
                                    t = e.name, n = e.version
                                } else e.name in Vt ? (t = Vt[e.name], n = e.version) : (t = Ut, n = void 0);
                                this._name = t, this._version = n
                            }
                            getName() {
                                return this._name
                            }
                            isChrome() {
                                return this._name === Ot
                            }
                            isOpera() {
                                return this._name === Lt
                            }
                            isFirefox() {
                                return this._name === xt
                            }
                            isIExplorer() {
                                return this._name === Ft
                            }
                            isSafari() {
                                return this._name === jt
                            }
                            isNWJS() {
                                return this._name === $t
                            }
                            isElectron() {
                                return this._name === Bt
                            }
                            isReactNative() {
                                return this._name === Jt
                            }
                            getVersion() {
                                return this._version
                            }
                            _checkCondition(e) {
                                if (this._version) return this._bowser.satisfies(e)
                            }
                            isVersionGreaterThan(e) {
                                return this._checkCondition({
                                    [this._name]: `>${e}`
                                })
                            }
                            isVersionLessThan(e) {
                                return this._checkCondition({
                                    [this._name]: `<${e}`
                                })
                            }
                            isVersionEqualTo(e) {
                                return this._checkCondition({
                                    [this._name]: `~${e}`
                                })
                            }
                        } {
                            constructor() {
                                super(), Wt.info(`This appears to be ${this.getName()}, ver: ${this.getVersion()}`)
                            }
                            doesVideoMuteByStreamRemove() {
                                return this.isChromiumBased() || this.isWebKitBased()
                            }
                            isChromiumBased() {
                                return (this.isChrome() || this.isElectron() || this.isNWJS() || this.isOpera()) && !this.isWebKitBased()
                            }
                            isIosBrowser() {
                                const {
                                    userAgent: e,
                                    maxTouchPoints: t,
                                    platform: n
                                } = navigator;
                                return Boolean(e.match(/iP(ad|hone|od)/i)) || t && t > 2 && /MacIntel/.test(n)
                            }
                            isWebKitBased() {
                                return this._bowser.isEngine("webkit") && void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getUserMedia && void 0 !== window.RTCRtpTransceiver && Object.keys(RTCRtpTransceiver.prototype).indexOf("currentDirection") > -1
                            }
                            isTwa() {
                                return "matchMedia" in window && window.matchMedia("(display-mode:standalone)").matches
                            }
                            isSupported() {
                                return this.isChromiumBased() && this._getChromiumBasedVersion() >= 72 || this.isFirefox() || this.isReactNative() || this.isWebKitBased()
                            }
                            isUserInteractionRequiredForUnmute() {
                                return this.isFirefox() && this.isVersionLessThan("68")
                            }
                            supportsVideoMuteOnConnInterrupted() {
                                return this.isChromiumBased() || this.isReactNative()
                            }
                            supportsBandwidthStatistics() {
                                return !this.isFirefox() && !this.isWebKitBased()
                            }
                            supportsCodecPreferences() {
                                return Boolean(window.RTCRtpTransceiver && "setCodecPreferences" in window.RTCRtpTransceiver.prototype && window.RTCRtpReceiver && void 0 !== window.RTCRtpReceiver.getCapabilities) && !this.isWebKitBased()
                            }
                            supportsDeviceChangeEvent() {
                                return navigator.mediaDevices && void 0 !== navigator.mediaDevices.ondevicechange && void 0 !== navigator.mediaDevices.addEventListener
                            }
                            supportsLocalCandidateRttStatistics() {
                                return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased()
                            }
                            supportsPerformanceObserver() {
                                return void 0 !== window.PerformanceObserver && PerformanceObserver.supportedEntryTypes.indexOf("longtask") > -1
                            }
                            supportsReceiverStats() {
                                return void 0 !== window.RTCRtpReceiver && Object.keys(RTCRtpReceiver.prototype).indexOf("getSynchronizationSources") > -1 && !this.isWebKitBased()
                            }
                            supportsRTTStatistics() {
                                return !this.isFirefox()
                            }
                            usesSdpMungingForSimulcast() {
                                return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased()
                            }
                            usesAdapter() {
                                return !this.isReactNative()
                            }
                            usesRidsForSimulcast() {
                                return !1
                            }
                            supportsGetDisplayMedia() {
                                return void 0 !== navigator.getDisplayMedia || void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getDisplayMedia
                            }
                            supportsEncodedTransform() {
                                return Boolean(window.RTCRtpScriptTransform)
                            }
                            supportsInsertableStreams() {
                                if (void 0 === window.RTCRtpSender || !window.RTCRtpSender.prototype.createEncodedStreams) return !1;
                                const e = new ReadableStream;
                                try {
                                    return window.postMessage(e, "*", [e]), !0
                                } catch (e) {
                                    return !1
                                }
                            }
                            supportsAudioRed() {
                                return Boolean(window.RTCRtpSender && window.RTCRtpSender.getCapabilities && window.RTCRtpSender.getCapabilities("audio").codecs.some((e => "audio/red" === e.mimeType)) && window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("audio").codecs.some((e => "audio/red" === e.mimeType)))
                            }
                            supportsUnifiedPlan() {
                                return !this.isReactNative()
                            }
                            supportsVADDetection() {
                                return this.isChromiumBased()
                            }
                            _getChromiumBasedVersion() {
                                if (this.isChromiumBased()) {
                                    if (this.isNWJS()) return Number.parseInt(process.versions.chromium, 10);
                                    const e = navigator.userAgent;
                                    if (e.match(/Chrome/)) return Number.parseInt(e.match(/Chrome\/([\d.]+)/)[1], 10)
                                }
                                return -1
                            }
                        };
                    var Xt = n(1795),
                        Yt = n.n(Xt);

                    function Zt(e, t, n) {
                        return t in e ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = n, e
                    }
                    const en = (0, f.getLogger)("modules/statistics/AnalyticsAdapter.js"),
                        tn = new class {
                            constructor() {
                                this.reset()
                            }
                            reset() {
                                this.disposed = !1, this.analyticsHandlers = new Set, this.cache = [], this.permanentProperties = {}, this.conferenceName = "", this.addPermanentProperties({
                                    user_agent: navigator.userAgent,
                                    browser_name: Qt.getName()
                                })
                            }
                            dispose() {
                                en.warn("Disposing of analytics adapter."), this.analyticsHandlers && this.analyticsHandlers.size > 0 && this.analyticsHandlers.forEach((e => {
                                    "function" == typeof e.dispose && e.dispose()
                                })), this.setAnalyticsHandlers([]), this.disposed = !0
                            }
                            setAnalyticsHandlers(e) {
                                if (this.disposed) return;
                                this.analyticsHandlers = new Set(e), this._setUserProperties();
                                const t = this.cache;
                                this.cache = null, t && t.forEach((e => this._sendEvent(e)))
                            }
                            _setUserProperties() {
                                this.analyticsHandlers.forEach((e => {
                                    try {
                                        e.setUserProperties(this.permanentProperties)
                                    } catch (e) {
                                        en.warn(`Error in setUserProperties method of one of the analytics handlers: ${e}`)
                                    }
                                }))
                            }
                            addPermanentProperties(e) {
                                this.permanentProperties = function(e) {
                                    for (var t = 1; t < arguments.length; t++) {
                                        var n = null != arguments[t] ? Object(arguments[t]) : {},
                                            i = Object.keys(n);
                                        "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                            return Object.getOwnPropertyDescriptor(n, e).enumerable
                                        })))), i.forEach((function(t) {
                                            Zt(e, t, n[t])
                                        }))
                                    }
                                    return e
                                }({}, this.permanentProperties, e), this._setUserProperties()
                            }
                            setConferenceName(e) {
                                this.conferenceName = e, this.addPermanentProperties({
                                    conference_name: e
                                })
                            }
                            sendEvent(e, t = {}) {
                                if (this.disposed) return;
                                let n = null;
                                "string" == typeof e ? n = {
                                    type: gt,
                                    action: e,
                                    actionSubject: e,
                                    source: e,
                                    attributes: t
                                } : "object" == typeof e && (n = e), this._verifyRequiredFields(n) ? this._sendEvent(n) : en.error(`Dropping a mis-formatted event: ${JSON.stringify(n)}`)
                            }
                            _verifyRequiredFields(e) {
                                if (!e) return !1;
                                e.type || (e.type = gt);
                                const t = e.type;
                                return t !== gt && t !== _t && "ui" !== t && t !== vt ? (en.error(`Unknown event type: ${t}`), !1) : t === _t ? Boolean(e.name) : (e.action = e.action || e.name || e.actionSubject, e.actionSubject = e.actionSubject || e.name || e.action, e.source = e.source || e.name || e.action || e.actionSubject, e.action && e.actionSubject && e.source ? !!(t !== vt || (e.objectType = e.objectType || "generic-object-type", e.containerType = e.containerType || "conference", "conference" !== e.containerType || e.containerId || (e.containerId = this.conferenceName), e.objectType && e.objectId && e.containerType && e.containerId)) || (en.error("Required field missing (containerId, containerType, objectId or objectType)"), !1) : (en.error("Required field missing (action, actionSubject or source)"), !1))
                            }
                            _maybeCacheEvent(e) {
                                return !!this.cache && (this.cache.push(e), this.cache.length > 100 && this.cache.splice(0, 1), !0)
                            }
                            _sendEvent(e) {
                                this._maybeCacheEvent(e) || this.analyticsHandlers.forEach((t => {
                                    try {
                                        t.sendEvent(e)
                                    } catch (e) {
                                        en.warn(`Error sending analytics event: ${e}`)
                                    }
                                }))
                            }
                        };
                    var nn = n(7024),
                        sn = n.n(nn);

                    function rn(e, t, n) {
                        return t in e ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = n, e
                    }
                    const on = n(7055).getLogger("modules/statistics/CallStats.js"),
                        an = "applicationLog",
                        cn = "error",
                        dn = "event",
                        ln = "mstWithUserID";
                    let hn;
                    class un {
                        static _addNewFabricCallback(e, t) {
                            un.backend && "success" !== e && on.error(`Monitoring status: ${e} msg: ${t}`)
                        }
                        static _initCallback(e, t) {
                            if (on.log(`CallStats Status: err=${e} msg=${t}`), "success" !== e) return;
                            un.backendInitialized = !0;
                            let n = !1,
                                i = null;
                            for (const e of un.fabrics.values()) e.hasFabric || (on.debug("addNewFabric - initCallback"), e._addNewFabric() && (n = !0, i || (i = e)));
                            n && un._emptyReportQueue(i)
                        }
                        static _emptyReportQueue(e) {
                            const t = e.confID,
                                n = e.peerconnection;
                            for (const i of un.reportsQueue)
                                if (i.type === cn) {
                                    const t = i.data;
                                    un._reportError(e, t.type, t.error, t.pc || n)
                                } else if (i.type === dn) {
                                const e = i.data;
                                un.backend.sendFabricEvent(i.pc || n, e.event, t, e.eventData)
                            } else if (i.type === ln) {
                                const e = i.data;
                                un.backend.associateMstWithUserID(i.pc || n, e.callStatsId, t, e.ssrc, e.usageLabel, e.containerId)
                            }
                            un.reportsQueue.length = 0
                        }
                        static _reportError(e, t, n, i) {
                            let s = n;
                            s || (on.warn("No error is passed!"), s = new Error("Unknown error")), un.backendInitialized && e ? un.backend.reportError(i, e.confID, t, s) : un.reportsQueue.push({
                                type: cn,
                                data: {
                                    error: s,
                                    pc: i,
                                    type: t
                                }
                            })
                        }
                        static _reportEvent(e, t, n) {
                            const i = e && e.peerconnection,
                                s = e && e.confID;
                            un.backendInitialized && e ? un.backend.sendFabricEvent(i, t, s, n) : un.reportsQueue.push({
                                confID: s,
                                pc: i,
                                type: dn,
                                data: {
                                    event: t,
                                    eventData: n
                                }
                            })
                        }
                        static _traceAndCatchBackendCalls(e) {
                            const t = ["associateMstWithUserID", "sendFabricEvent", "sendUserFeedback"];
                            for (const n of t) {
                                const t = e[n];
                                e[n] = function(...n) {
                                    try {
                                        return t.apply(e, n)
                                    } catch (e) {
                                        sn().callErrorHandler(e)
                                    }
                                }
                            }
                            const n = ["associateMstWithUserID", "sendFabricEvent", "sendUserFeedback"];
                            for (const t of n) {
                                const n = e[t];
                                e[t] = function(...i) {
                                    on.debug(t, i), n.apply(e, i)
                                }
                            }
                            const i = e.reportError;
                            e.reportError = function(t, n, s, ...r) {
                                s === an ? Qt.isReactNative() || console && console.debug("reportError", t, n, s) : on.debug("reportError", t, n, s, ...r);
                                try {
                                    i.call(e, t, n, s, ...r)
                                } catch (e) {
                                    s === an ? console && console.error("reportError", e) : sn().callErrorHandler(e)
                                }
                            }
                        }
                        static get fabrics() {
                            return hn || (hn = new Set), hn
                        }
                        static initBackend(e) {
                            if (un.backend) throw new Error("CallStats backend has been initialized already!");
                            try {
                                const t = callstats;
                                un.backend = new t, un._traceAndCatchBackendCalls(un.backend), un.userID = {
                                    aliasName: e.aliasName,
                                    userName: e.userName
                                }, un.callStatsID = e.callStatsID, un.callStatsSecret = e.callStatsSecret;
                                const n = function(e) {
                                    for (var t = 1; t < arguments.length; t++) {
                                        var n = null != arguments[t] ? Object(arguments[t]) : {},
                                            i = Object.keys(n);
                                        "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                            return Object.getOwnPropertyDescriptor(n, e).enumerable
                                        })))), i.forEach((function(t) {
                                            rn(e, t, n[t])
                                        }))
                                    }
                                    return e
                                }({}, e.configParams);
                                if (e.applicationName && (n.applicationVersion = `${e.applicationName} (${Qt.getName()})`), e.confID) {
                                    const t = e.confID.match(/.*\/(.*)\/.*/);
                                    n.siteID = e.siteID || t && t[1] || "/"
                                }
                                un.backend.initialize(un.callStatsID, un.callStatsSecret, un.userID, un._initCallback, void 0, n);
                                const i = e.getWiFiStatsMethod;
                                return i && (un.backend.attachWifiStatsHandler(i), i().then((e => {
                                    e && on.info("Reported wifi addresses:", JSON.parse(e).addresses)
                                })).catch((() => {}))), !0
                            } catch (e) {
                                return sn().callErrorHandler(e), un.backend = null, on.error(e), !1
                            }
                        }
                        static isBackendInitialized() {
                            return Boolean(un.backend)
                        }
                        static sendActiveDeviceListEvent(e, t) {
                            un._reportEvent(t, "activeDeviceList", e)
                        }
                        static sendApplicationLog(e, t) {
                            try {
                                un._reportError(t, an, e, t && t.peerconnection)
                            } catch (e) {
                                console && "function" == typeof console.error && console.error("sendApplicationLog failed", e)
                            }
                        }
                        static sendFeedback(e, t, n) {
                            return new Promise(((i, s) => {
                                if (un.backend) un.backend.sendUserFeedback(e, {
                                    userID: un.userID,
                                    overall: t,
                                    comment: n
                                }, ((e, t) => {
                                    "success" === e ? i(t) : s(t)
                                }));
                                else {
                                    const e = "Failed to submit feedback to CallStats - no backend";
                                    on.error(e), s(e)
                                }
                            }))
                        }
                        static sendGetUserMediaFailed(e, t) {
                            un._reportError(t, "getUserMedia", e, null)
                        }
                        static sendMuteEvent(e, t, n) {
                            let i;
                            i = "video" === t ? e ? "videoPause" : "videoResume" : e ? "audioMute" : "audioUnmute", un._reportEvent(n, i)
                        }
                        constructor(e, t) {
                            this.confID = t.confID, this.tpc = e, this.peerconnection = e.peerconnection, this.remoteUserID = t.remoteUserID || "jitsi", this.hasFabric = !1, un.fabrics.add(this), un.backendInitialized && (this._addNewFabric(), 1 === un.fabrics.size && un._emptyReportQueue(this))
                        }
                        _addNewFabric() {
                            on.info("addNewFabric", this.remoteUserID);
                            try {
                                const e = {
                                        remoteEndpointType: this.tpc.isP2P ? un.backend.endpointType.peer : un.backend.endpointType.server
                                    },
                                    t = un.backend.addNewFabric(this.peerconnection, this.remoteUserID, un.backend.fabricUsage.multiplex, this.confID, e, un._addNewFabricCallback);
                                this.hasFabric = !0;
                                const n = "success" === t.status;
                                return n || on.error("callstats fabric not initilized", t.message), n
                            } catch (e) {
                                return sn().callErrorHandler(e), !1
                            }
                        }
                        associateStreamWithVideoTag(e, t, n, i, s) {
                            if (!un.backend) return;
                            const r = t ? un.userID : n;
                            un.backendInitialized ? un.backend.associateMstWithUserID(this.peerconnection, r, this.confID, e, i, s) : un.reportsQueue.push({
                                type: ln,
                                pc: this.peerconnection,
                                data: {
                                    callStatsId: r,
                                    containerId: s,
                                    ssrc: e,
                                    usageLabel: i
                                }
                            })
                        }
                        sendDominantSpeakerEvent() {
                            un._reportEvent(this, "dominantSpeaker")
                        }
                        sendTerminateEvent() {
                            un.backendInitialized && un.backend.sendFabricEvent(this.peerconnection, un.backend.fabricEvent.fabricTerminated, this.confID), un.fabrics.delete(this)
                        }
                        sendIceConnectionFailedEvent() {
                            un._reportError(this, "iceConnectionFailure", null, this.peerconnection)
                        }
                        sendCreateOfferFailed(e) {
                            un._reportError(this, "createOffer", e, this.peerconnection)
                        }
                        sendCreateAnswerFailed(e) {
                            un._reportError(this, "createAnswer", e, this.peerconnection)
                        }
                        sendResumeOrHoldEvent(e) {
                            un._reportEvent(this, e ? "fabricResume" : "fabricHold")
                        }
                        sendScreenSharingEvent(e, t) {
                            let n;
                            t && (n = {
                                ssrc: t
                            }), un._reportEvent(this, e ? "screenShareStart" : "screenShareStop", n)
                        }
                        sendSetLocalDescFailed(e) {
                            un._reportError(this, "setLocalDescription", e, this.peerconnection)
                        }
                        sendSetRemoteDescFailed(e) {
                            un._reportError(this, "setRemoteDescription", e, this.peerconnection)
                        }
                        sendAddIceCandidateFailed(e) {
                            un._reportError(this, "addIceCandidate", e, this.peerconnection)
                        }
                    }
                    un.backend = null, un.reportsQueue = [], un.backendInitialized = !1, un.callStatsID = null, un.callStatsSecret = null, un.userID = null, window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    let pn = null;

                    function mn(e, t, n) {
                        this.stream = e, this.intervalId = null, this.intervalMilis = t, this.audioLevel = 0, this.callback = n
                    }

                    function fn(e) {
                        let t = e;
                        return e >= Number.MAX_SAFE_INTEGER && (t = 0), t + 1
                    }

                    function gn(e) {
                        return e.length > 0 ? e.reduce(((e, t) => e + t)) / e.length : 0
                    }

                    function _n(e) {
                        return e.filter((e => e >= 0))
                    }
                    window.AudioContext && (pn = new AudioContext, pn.suspend && pn.suspend()), mn.prototype.start = function() {
                        if (!mn.isLocalStatsSupported()) return;
                        pn.resume();
                        const e = pn.createAnalyser();
                        e.smoothingTimeConstant = .8, e.fftSize = 2048, pn.createMediaStreamSource(this.stream).connect(e), this.intervalId = setInterval((() => {
                            const t = new Uint8Array(e.frequencyBinCount);
                            e.getByteTimeDomainData(t);
                            const n = function(e) {
                                let t = 0;
                                const n = e.length;
                                for (let i = 0; i < n; i++) t < e[i] && (t = e[i]);
                                return parseFloat(((t - 127) / 128).toFixed(3))
                            }(t);
                            this.audioLevel = function(e, t) {
                                let n = 0;
                                const i = t - e;
                                return n = i > .2 ? t - .2 : i < -.4 ? t + .4 : e, parseFloat(n.toFixed(3))
                            }(n, this.audioLevel), this.callback(this.audioLevel)
                        }), this.intervalMilis)
                    }, mn.prototype.stop = function() {
                        this.intervalId && (clearInterval(this.intervalId), this.intervalId = null)
                    }, mn.isLocalStatsSupported = function() {
                        return Boolean(pn)
                    };
                    class vn {
                        constructor() {
                            this.average = 0, this.n = 0
                        }
                        addNext(e) {
                            "number" == typeof e && (this.n += 1, this.average = this.average + (e - this.average) / this.n)
                        }
                        getAverage() {
                            return this.average
                        }
                    }
                    const yn = (0, f.getLogger)("modules/statistics/PerformanceObserverStats.js");
                    class Sn {
                        constructor(e, t) {
                            this.eventEmitter = e, this.longTasks = 0, this.maxDuration = 0, this.performanceStatsInterval = t, this.stats = new vn
                        }
                        getLongTasksStats() {
                            return {
                                avgRatePerMinute: (60 * this.stats.getAverage()).toFixed(2),
                                maxDurationMs: this.maxDuration
                            }
                        }
                        startObserver() {
                            this.longTaskEventHandler = e => {
                                const t = e.getEntries();
                                for (const e of t) this.longTasks++, this.maxDuration = Math.max(this.maxDuration, e.duration).toFixed(3)
                            }, yn.info("Creating a Performance Observer for monitoring Long Tasks"), this.observer = new PerformanceObserver(this.longTaskEventHandler), this.observer.observe({
                                type: "longtask",
                                buffered: !0
                            });
                            const e = Date.now();
                            this.longTasksIntervalId = setInterval((() => {
                                const t = Date.now(),
                                    n = this._lastTimeStamp ? (t - this._lastTimeStamp) / 1e3 : (t - e) / 1e3,
                                    i = this.longTasks / n;
                                this.stats.addNext(i), this.eventEmitter.emit(Nt, this.getLongTasksStats()), this.longTasks = 0, this._lastTimeStamp = Date.now()
                            }), this.performanceStatsInterval)
                        }
                        stopObserver() {
                            this.observer && this.observer.disconnect(), this.longTaskEventHandler = null, this.longTasksIntervalId && (clearInterval(this.longTasksIntervalId), this.longTasksIntervalId = null)
                        }
                    }
                    const En = "audio",
                        bn = "presenter",
                        Cn = "video",
                        Tn = n(7024),
                        Rn = (0, f.getLogger)("modules/statistics/RTPStatsCollector.js");

                    function An(e, t) {
                        return !t || t <= 0 || !e || e <= 0 ? 0 : Math.round(e / t * 100)
                    }

                    function wn() {
                        this.loss = {}, this.bitrate = {
                            download: 0,
                            upload: 0
                        }, this.resolution = {}, this.framerate = 0, this.codec = ""
                    }

                    function Pn() {
                        this.bandwidth = {}, this.bitrate = {}, this.packetLoss = null, this.transport = []
                    }

                    function In(e, t, n, i) {
                        this.peerconnection = e, this.baselineAudioLevelsReport = null, this.currentAudioLevelsReport = null, this.currentStatsReport = null, this.previousStatsReport = null, this.audioLevelReportHistory = {}, this.audioLevelsIntervalId = null, this.eventEmitter = i, this.conferenceStats = new Pn, this.audioLevelsIntervalMilis = t, this.speakerList = [], this.statsIntervalId = null, this.statsIntervalMilis = n, this.ssrc2stats = new Map
                    }
                    wn.prototype.setLoss = function(e) {
                        this.loss = e || {}
                    }, wn.prototype.setResolution = function(e) {
                        this.resolution = e || {}
                    }, wn.prototype.addBitrate = function(e) {
                        this.bitrate.download += e.download, this.bitrate.upload += e.upload
                    }, wn.prototype.resetBitrate = function() {
                        this.bitrate.download = 0, this.bitrate.upload = 0
                    }, wn.prototype.setFramerate = function(e) {
                        this.framerate = e || 0
                    }, wn.prototype.setCodec = function(e) {
                        this.codec = e || ""
                    }, In.prototype.setSpeakerList = function(e) {
                        this.speakerList = e
                    }, In.prototype.stop = function() {
                        this.audioLevelsIntervalId && (clearInterval(this.audioLevelsIntervalId), this.audioLevelsIntervalId = null), this.statsIntervalId && (clearInterval(this.statsIntervalId), this.statsIntervalId = null)
                    }, In.prototype.errorCallback = function(e) {
                        Tn.callErrorHandler(e), Rn.error("Get stats error", e), this.stop()
                    }, In.prototype.start = function(e) {
                        e && (Qt.supportsReceiverStats() && Rn.info("Using RTCRtpSynchronizationSource for remote audio levels"), this.audioLevelsIntervalId = setInterval((() => {
                            if (Qt.supportsReceiverStats()) {
                                const e = this.peerconnection.getAudioLevels(this.speakerList);
                                for (const t in e)
                                    if (e.hasOwnProperty(t)) {
                                        const n = 2.5 * e[t];
                                        this.eventEmitter.emit(Pt, this.peerconnection, Number.parseInt(t, 10), n, !1)
                                    }
                            } else this.peerconnection.getStats().then((e => {
                                this.currentAudioLevelsReport = "function" == typeof(null == e ? void 0 : e.result) ? e.result() : e, this.processAudioLevelReport(), this.baselineAudioLevelsReport = this.currentAudioLevelsReport
                            })).catch((e => this.errorCallback(e)))
                        }), this.audioLevelsIntervalMilis));
                        const t = () => {
                            this.peerconnection.getStats().then((e => {
                                this.currentStatsReport = "function" == typeof(null == e ? void 0 : e.result) ? e.result() : e;
                                try {
                                    this.processStatsReport()
                                } catch (e) {
                                    Tn.callErrorHandler(e), Rn.error("Processing of RTP stats failed:", e)
                                }
                                this.previousStatsReport = this.currentStatsReport
                            })).catch((e => this.errorCallback(e)))
                        };
                        t(), this.statsIntervalId = setInterval(t, this.statsIntervalMilis)
                    }, In.prototype._processAndEmitReport = function() {
                        const e = {
                                download: 0,
                                upload: 0
                            },
                            t = {
                                download: 0,
                                upload: 0
                            };
                        let n = 0,
                            i = 0;
                        const s = {},
                            r = {},
                            o = {};
                        let a, c, d = 0,
                            l = 0,
                            h = 0,
                            u = 0;
                        for (const [p, m] of this.ssrc2stats) {
                            const f = m.loss,
                                g = f.isDownloadStream ? "download" : "upload";
                            e[g] += f.packetsTotal, t[g] += f.packetsLost, n += m.bitrate.download, i += m.bitrate.upload;
                            const _ = this.peerconnection.getTrackBySSRC(p);
                            if (_) {
                                _.isAudioTrack() ? (d += m.bitrate.download, l += m.bitrate.upload, a = m.codec) : (h += m.bitrate.download, u += m.bitrate.upload, c = m.codec);
                                const e = _.getParticipantId();
                                if (e) {
                                    const t = m.resolution;
                                    if (t.width && t.height && -1 !== t.width && -1 !== t.height) {
                                        const n = s[e] || {};
                                        n[p] = t, s[e] = n
                                    }
                                    if (0 !== m.framerate) {
                                        const t = r[e] || {};
                                        t[p] = m.framerate, r[e] = t
                                    }
                                    if (a && c) {
                                        const t = {
                                                audio: a,
                                                video: c
                                            },
                                            n = o[e] || {};
                                        n[p] = t, o[e] = n
                                    }
                                } else Rn.error(`No participant ID returned by ${_}`)
                            }
                            m.resetBitrate()
                        }
                        this.conferenceStats.bitrate = {
                            upload: i,
                            download: n
                        }, this.conferenceStats.bitrate.audio = {
                            upload: l,
                            download: d
                        }, this.conferenceStats.bitrate.video = {
                            upload: u,
                            download: h
                        }, this.conferenceStats.packetLoss = {
                            total: An(t.download + t.upload, e.download + e.upload),
                            download: An(t.download, e.download),
                            upload: An(t.upload, e.upload)
                        };
                        const p = {};
                        let m;
                        Object.keys(this.audioLevelReportHistory).forEach((e => {
                            const {
                                data: t,
                                isLocal: n
                            } = this.audioLevelReportHistory[e], i = t.reduce(((e, t) => e + t)) / t.length;
                            if (n) m = i;
                            else {
                                const t = this.peerconnection.getTrackBySSRC(Number(e));
                                if (t) {
                                    const e = t.getParticipantId();
                                    e && (p[e] = i)
                                }
                            }
                        })), this.audioLevelReportHistory = {}, this.eventEmitter.emit(Dt, this.peerconnection, {
                            bandwidth: this.conferenceStats.bandwidth,
                            bitrate: this.conferenceStats.bitrate,
                            packetLoss: this.conferenceStats.packetLoss,
                            resolution: s,
                            framerate: r,
                            codec: o,
                            transport: this.conferenceStats.transport,
                            localAvgAudioLevels: m,
                            avgAudioLevels: p
                        }), this.conferenceStats.transport = []
                    }, In.prototype.getNonNegativeValue = function(e) {
                        let t = e;
                        return "number" != typeof t && (t = Number(t)), isNaN(t) ? 0 : Math.max(0, t)
                    }, In.prototype._calculateBitrate = function(e, t, n) {
                        const i = this.getNonNegativeValue(e[n]),
                            s = this.getNonNegativeValue(t[n]),
                            r = Math.max(0, i - s),
                            o = e.timestamp - t.timestamp;
                        let a = 0;
                        return o > 0 && (a = Math.round(8 * r / o)), a
                    }, In.prototype.processStatsReport = function() {
                        if (!this.previousStatsReport) return;
                        const e = {};
                        this.currentStatsReport.forEach((t => {
                            if ("candidate-pair" === t.type && t.nominated && "succeeded" === t.state) {
                                const e = t.availableIncomingBitrate,
                                    n = t.availableOutgoingBitrate;
                                (e || n) && (this.conferenceStats.bandwidth = {
                                    download: Math.round(e / 1e3),
                                    upload: Math.round(n / 1e3)
                                });
                                const i = this.currentStatsReport.get(t.remoteCandidateId),
                                    s = this.currentStatsReport.get(t.localCandidateId);
                                if (i && s) {
                                    const e = `${Qt.isChromiumBased()?i.ip:i.address}:${i.port}`,
                                        n = `${Qt.isChromiumBased()?s.ip:s.address}:${s.port}`,
                                        r = i.protocol,
                                        o = this.conferenceStats.transport;
                                    o.some((t => t.ip === e && t.type === r && t.localip === n)) || o.push({
                                        ip: e,
                                        type: r,
                                        localip: n,
                                        p2p: this.peerconnection.isP2P,
                                        localCandidateType: s.candidateType,
                                        remoteCandidateType: i.candidateType,
                                        networkType: s.networkType,
                                        rtt: 1e3 * t.currentRoundTripTime
                                    })
                                }
                            } else if ("inbound-rtp" === t.type || "outbound-rtp" === t.type) {
                                const n = this.previousStatsReport.get(t.id),
                                    i = this.getNonNegativeValue(t.ssrc);
                                if (!n || !i) return;
                                let s = this.ssrc2stats.get(i);
                                s || (s = new wn, this.ssrc2stats.set(i, s));
                                let r = !0,
                                    o = "packetsReceived";
                                "outbound-rtp" === t.type && (r = !1, o = "packetsSent");
                                let a = t[o];
                                (!a || a < 0) && (a = 0);
                                const c = this.getNonNegativeValue(n[o]),
                                    d = Math.max(0, a - c),
                                    l = this.getNonNegativeValue(t.packetsLost),
                                    h = this.getNonNegativeValue(n.packetsLost),
                                    u = Math.max(0, l - h);
                                if (s.setLoss({
                                        packetsTotal: d + u,
                                        packetsLost: u,
                                        isDownloadStream: r
                                    }), "inbound-rtp" === t.type) {
                                    const e = {
                                            height: t.frameHeight,
                                            width: t.frameWidth
                                        },
                                        i = t.framesPerSecond;
                                    e.height && e.width && s.setResolution(e), s.setFramerate(Math.round(i || 0)), s.addBitrate({
                                        download: this._calculateBitrate(t, n, "bytesReceived"),
                                        upload: 0
                                    })
                                } else e[i] = this.getNonNegativeValue(t.bytesSent), s.addBitrate({
                                    download: 0,
                                    upload: this._calculateBitrate(t, n, "bytesSent")
                                });
                                const p = this.currentStatsReport.get(t.codecId);
                                if (p) {
                                    const e = p.mimeType.split("/")[1];
                                    e && s.setCodec(e)
                                }
                            } else if ("track" === t.type && t.kind === Cn && !t.remoteSource) {
                                const e = {
                                        height: t.frameHeight,
                                        width: t.frameWidth
                                    },
                                    n = this.peerconnection.getLocalTracks(Cn);
                                if (!(null == n ? void 0 : n.length)) return;
                                const i = this.peerconnection.getLocalSSRC(n[0]);
                                if (!i) return;
                                let s = this.ssrc2stats.get(i);
                                s || (s = new wn, this.ssrc2stats.set(i, s)), e.height && e.width && s.setResolution(e);
                                let r = t.framesPerSecond;
                                if (!r) {
                                    const e = this.previousStatsReport.get(t.id);
                                    if (e) {
                                        const n = t.timestamp - e.timestamp;
                                        n > 0 && t.framesSent && (r = (t.framesSent - e.framesSent) / n * 1e3)
                                    }
                                    if (!r) return
                                }
                                const o = this.peerconnection.getActiveSimulcastStreams();
                                r = o ? Math.round(r / o) : 0, s.setFramerate(r)
                            }
                        })), this.eventEmitter.emit(Mt, this.peerconnection, e), this._processAndEmitReport()
                    }, In.prototype.processAudioLevelReport = function() {
                        this.baselineAudioLevelsReport && this.currentAudioLevelsReport.forEach((e => {
                            if ("track" !== e.type) return;
                            const t = e.audioLevel;
                            if (!t) return;
                            const n = e.trackIdentifier,
                                i = this.peerconnection.getSsrcByTrackId(n);
                            if (i) {
                                const e = i === this.peerconnection.getLocalSSRC(this.peerconnection.getLocalTracks(En));
                                this.eventEmitter.emit(Pt, this.peerconnection, i, t, e)
                            }
                        }))
                    };
                    const Mn = n(7055).getLogger("modules/statistics/statistics.js");
                    let Dn, Nn = !1;

                    function kn(e) {
                        un.isBackendInitialized() || un.initBackend({
                            callStatsID: e.callStatsID,
                            callStatsSecret: e.callStatsSecret,
                            userName: e.userName,
                            aliasName: e.aliasName,
                            applicationName: e.applicationName,
                            getWiFiStatsMethod: e.getWiFiStatsMethod,
                            confID: e.confID,
                            siteID: e.siteID,
                            configParams: e.configParams
                        }) || Mn.error("CallStats Backend initialization failed bad")
                    }

                    function On(e, t) {
                        this.rtpStatsMap = new Map, this.eventEmitter = new(ze()), this.xmpp = e, this.options = t || {}, this.callStatsIntegrationEnabled = this.options.callStatsID && this.options.callStatsSecret && this.options.enableCallStats && !0 !== On.disableThirdPartyRequests, this.callStatsIntegrationEnabled && (this.callStatsApplicationLogsDisabled = this.options.callStatsApplicationLogsDisabled, Qt.isReactNative() ? kn(this.options) : function(e) {
                            Nn || (Yt().loadScript(e.customScriptUrl || Ye, !0, !0, void 0, (() => kn(e))), Nn = !0)
                        }(this.options), this.options.confID || Mn.warn('"confID" is not defined')), this.callsStatsInstances = new Map, On.instances.add(this)
                    }
                    On.init = function(e) {
                        On.audioLevelsEnabled = !e.disableAudioLevels, "number" == typeof e.pcStatsInterval && (On.pcStatsInterval = e.pcStatsInterval), "number" == typeof e.audioLevelsInterval && (On.audioLevelsInterval = e.audioLevelsInterval), "number" == typeof e.longTasksStatsInterval && (On.longTasksStatsInterval = e.longTasksStatsInterval), On.disableThirdPartyRequests = e.disableThirdPartyRequests
                    }, On.audioLevelsEnabled = !1, On.audioLevelsInterval = 200, On.pcStatsInterval = 1e4, On.disableThirdPartyRequests = !1, On.analytics = tn, Object.defineProperty(On, "instances", {
                        get: () => (Dn || (Dn = new Set), Dn)
                    }), On.prototype.startRemoteStats = function(e) {
                        this.stopRemoteStats(e);
                        try {
                            const t = new In(e, On.audioLevelsInterval, On.pcStatsInterval, this.eventEmitter);
                            t.start(On.audioLevelsEnabled), this.rtpStatsMap.set(e.id, t)
                        } catch (e) {
                            Mn.error(`Failed to start collecting remote statistics: ${e}`)
                        }
                    }, On.localStats = [], On.startLocalStats = function(e, t) {
                        if (!On.audioLevelsEnabled) return;
                        const n = new mn(e, On.audioLevelsInterval, t);
                        this.localStats.push(n), n.start()
                    }, On.prototype.addAudioLevelListener = function(e) {
                        On.audioLevelsEnabled && this.eventEmitter.on(Pt, e)
                    }, On.prototype.removeAudioLevelListener = function(e) {
                        On.audioLevelsEnabled && this.eventEmitter.removeListener(Pt, e)
                    }, On.prototype.addBeforeDisposedListener = function(e) {
                        this.eventEmitter.on(It, e)
                    }, On.prototype.removeBeforeDisposedListener = function(e) {
                        this.eventEmitter.removeListener(It, e)
                    }, On.prototype.addConnectionStatsListener = function(e) {
                        this.eventEmitter.on(Dt, e)
                    }, On.prototype.removeConnectionStatsListener = function(e) {
                        this.eventEmitter.removeListener(Dt, e)
                    }, On.prototype.addByteSentStatsListener = function(e) {
                        this.eventEmitter.on(Mt, e)
                    }, On.prototype.removeByteSentStatsListener = function(e) {
                        this.eventEmitter.removeListener(Mt, e)
                    }, On.prototype.addLongTasksStatsListener = function(e) {
                        this.eventEmitter.on(Nt, e)
                    }, On.prototype.attachLongTasksStats = function(e) {
                        Qt.supportsPerformanceObserver() ? (this.performanceObserverStats = new Sn(this.eventEmitter, On.longTasksStatsInterval), e.on(U, (() => this.performanceObserverStats.startObserver())), e.on(V, (() => this.performanceObserverStats.stopObserver()))) : Mn.warn("Performance observer for long tasks not supported by browser!")
                    }, On.prototype.getLongTasksStats = function() {
                        return this.performanceObserverStats ? this.performanceObserverStats.getLongTasksStats() : null
                    }, On.prototype.removeLongTasksStatsListener = function(e) {
                        this.eventEmitter.removeListener(Nt, e)
                    }, On.prototype.setSpeakerList = function(e) {
                        for (const t of Array.from(this.rtpStatsMap.values())) t.peerconnection.isP2P || t.setSpeakerList(e)
                    }, On.prototype.dispose = function() {
                        try {
                            this.callsStatsInstances.size || this.eventEmitter.emit(It);
                            for (const e of this.callsStatsInstances.values()) this.stopCallStats(e.tpc);
                            for (const e of this.rtpStatsMap.keys()) this._stopRemoteStats(e);
                            this.eventEmitter && this.eventEmitter.removeAllListeners()
                        } finally {
                            On.instances.delete(this)
                        }
                    }, On.stopLocalStats = function(e) {
                        if (On.audioLevelsEnabled)
                            for (let t = 0; t < On.localStats.length; t++)
                                if (On.localStats[t].stream === e) {
                                    On.localStats.splice(t, 1)[0].stop();
                                    break
                                }
                    }, On.prototype._stopRemoteStats = function(e) {
                        const t = this.rtpStatsMap.get(e);
                        t && (t.stop(), this.rtpStatsMap.delete(e))
                    }, On.prototype.stopRemoteStats = function(e) {
                        this._stopRemoteStats(e.id)
                    }, On.prototype.startCallStats = function(e, t) {
                        if (!this.callStatsIntegrationEnabled) return;
                        if (this.callsStatsInstances.has(e.id)) return void Mn.error("CallStats instance for ${tpc} exists already");
                        Mn.info(`Starting CallStats for ${e}...`);
                        const n = new un(e, {
                            confID: this.options.confID,
                            remoteUserID: t
                        });
                        this.callsStatsInstances.set(e.id, n)
                    }, On._getAllCallStatsInstances = function() {
                        const e = new Set;
                        for (const t of On.instances)
                            for (const n of t.callsStatsInstances.values()) e.add(n);
                        return e
                    }, On.prototype.stopCallStats = function(e) {
                        const t = this.callsStatsInstances.get(e.id);
                        t && (1 === this.callsStatsInstances.size && this.eventEmitter.emit(It), this.callsStatsInstances.delete(e.id), t.sendTerminateEvent())
                    }, On.prototype.isCallstatsEnabled = function() {
                        return this.callStatsIntegrationEnabled
                    }, On.prototype.sendConnectionResumeOrHoldEvent = function(e, t) {
                        const n = this.callsStatsInstances.get(e.id);
                        n && n.sendResumeOrHoldEvent(t)
                    }, On.prototype.sendIceConnectionFailedEvent = function(e) {
                        const t = this.callsStatsInstances.get(e.id);
                        t && t.sendIceConnectionFailedEvent()
                    }, On.prototype.sendMuteEvent = function(e, t, n) {
                        const i = e && this.callsStatsInstances.get(e.id);
                        un.sendMuteEvent(t, n, i)
                    }, On.prototype.sendScreenSharingEvent = function(e, t) {
                        for (const n of this.callsStatsInstances.values()) n.sendScreenSharingEvent(e, t)
                    }, On.prototype.sendDominantSpeakerEvent = function(e) {
                        for (const e of this.callsStatsInstances.values()) e.sendDominantSpeakerEvent();
                        this.xmpp.sendDominantSpeakerEvent(e)
                    }, On.sendActiveDeviceListEvent = function(e) {
                        const t = On._getAllCallStatsInstances();
                        if (t.size)
                            for (const n of t) un.sendActiveDeviceListEvent(e, n);
                        else un.sendActiveDeviceListEvent(e, null)
                    }, On.prototype.associateStreamWithVideoTag = function(e, t, n, i, s, r) {
                        const o = this.callsStatsInstances.get(e.id);
                        o && o.associateStreamWithVideoTag(t, n, i, s, r)
                    }, On.sendGetUserMediaFailed = function(e) {
                        const t = e instanceof pt ? function(e) {
                                const t = new Error;
                                return t.stack = e.stack, t.name = (e.name || "Unknown error") + (e.gum && e.gum.error && e.gum.error.name ? ` - ${e.gum.error.name}` : ""), t.constraintName = e.gum && e.gum.constraints ? JSON.stringify(e.gum.constraints) : "", t.message = e.message, t
                            }(e) : e,
                            n = On._getAllCallStatsInstances();
                        if (n.size)
                            for (const e of n) un.sendGetUserMediaFailed(t, e);
                        else un.sendGetUserMediaFailed(t, null)
                    }, On.prototype.sendCreateOfferFailed = function(e, t) {
                        const n = this.callsStatsInstances.get(t.id);
                        n && n.sendCreateOfferFailed(e)
                    }, On.prototype.sendCreateAnswerFailed = function(e, t) {
                        const n = this.callsStatsInstances.get(t.id);
                        n && n.sendCreateAnswerFailed(e)
                    }, On.prototype.sendSetLocalDescFailed = function(e, t) {
                        const n = this.callsStatsInstances.get(t.id);
                        n && n.sendSetLocalDescFailed(e)
                    }, On.prototype.sendSetRemoteDescFailed = function(e, t) {
                        const n = this.callsStatsInstances.get(t.id);
                        n && n.sendSetRemoteDescFailed(e)
                    }, On.prototype.sendAddIceCandidateFailed = function(e, t) {
                        const n = this.callsStatsInstances.get(t.id);
                        n && n.sendAddIceCandidateFailed(e)
                    }, On.sendLog = function(e) {
                        const t = new Set;
                        for (const e of On.instances) {
                            if (e.callStatsApplicationLogsDisabled) return;
                            e.callsStatsInstances.size && t.add(e.callsStatsInstances.values().next().value)
                        }
                        if (t.size)
                            for (const n of t) un.sendApplicationLog(e, n);
                        else un.sendApplicationLog(e, null)
                    }, On.prototype.sendFeedback = function(e, t) {
                        return On.analytics.sendEvent("feedback", {
                            rating: e,
                            comment: t
                        }), un.sendFeedback(this.options.confID, e, t)
                    }, On.LOCAL_JID = n(3523).LOCAL_JID, On.reportGlobalError = function(e) {
                        e instanceof pt && e.gum ? On.sendGetUserMediaFailed(e) : On.sendLog(e)
                    }, On.sendAnalyticsAndLog = function(e, t = {}) {
                        if (!e) return void Mn.warn("No event or event name given.");
                        let n;
                        n = "object" == typeof e ? e : {
                            name: e,
                            properties: t
                        }, Mn.log(JSON.stringify(n)), this.analytics.sendEvent(e, t)
                    }, On.sendAnalytics = function(e, t = {}) {
                        this.analytics.sendEvent(e, t)
                    };
                    var Ln = n(1278),
                        xn = n.n(Ln),
                        Fn = n(3907),
                        jn = n.n(Fn),
                        $n = n(3714),
                        Bn = n.n($n),
                        Jn = n(702),
                        Un = n.n(Jn),
                        Vn = n(3786),
                        Hn = n.n(Vn);
                    const Gn = (0, f.getLogger)("JitsiConferenceEventManager.js");

                    function qn(e) {
                        this.conference = e, this.xmppListeners = {}, e.on(De, (t => {
                            if (!t.isLocal() || !e.statistics) return;
                            const n = t.isP2P ? e.p2pJingleSession : e.jvbJingleSession,
                                i = n && n.peerconnection || null;
                            e.statistics.sendMuteEvent(i, t.isMuted(), t.getType())
                        }))
                    }
                    qn.prototype.setupChatRoomListeners = function() {
                        const e = this.conference,
                            t = e.room;
                        this.chatRoomForwarder = new(xn())(t, this.conference.eventEmitter), t.addListener(Hn().ICE_RESTARTING, (t => {
                            t.isP2P || e.rtc.closeBridgeChannel()
                        })), t.addListener(Hn().PARTICIPANT_FEATURES_CHANGED, ((t, n) => {
                            const i = e.getParticipantById(Xe.Strophe.getResourceFromJid(t));
                            i && (i.setFeatures(n), e.eventEmitter.emit(ge, i))
                        })), t.addListener(Hn().ICE_RESTART_SUCCESS, ((t, n) => {
                            !t.isP2P && e._setBridgeChannel(n, t.peerconnection)
                        })), t.addListener(Hn().AUDIO_MUTED_BY_FOCUS, (t => {
                            On.sendAnalytics(At(En)), e.mutedByFocusActor = t, e.rtc.setAudioMute(!0).then((() => {
                                e.isMutedByFocus = !0, e.mutedByFocusActor = null
                            })).catch((t => {
                                e.mutedByFocusActor = null, Gn.warn("Error while audio muting due to focus request", t)
                            }))
                        })), t.addListener(Hn().VIDEO_MUTED_BY_FOCUS, (t => {
                            On.sendAnalytics(At(Cn)), e.mutedVideoByFocusActor = t, e.rtc.setVideoMute(!0).then((() => {
                                e.isVideoMutedByFocus = !0, e.mutedVideoByFocusActor = null
                            })).catch((t => {
                                e.mutedVideoByFocusActor = null, Gn.warn("Error while video muting due to focus request", t)
                            }))
                        })), this.chatRoomForwarder.forward(Hn().SUBJECT_CHANGED, Ae), this.chatRoomForwarder.forward(Hn().MUC_JOINED, U), this.chatRoomForwarder.forward(Hn().MEETING_ID_SET, H), t.addListener(Hn().MUC_JOINED, (() => {
                            this.conference._onMucJoined(), this.conference.isJvbConnectionInterrupted = !1, Object.keys(t.connectionTimes).forEach((e => {
                                const n = bt(`conference_${e}`, {
                                    value: t.connectionTimes[e]
                                });
                                On.sendAnalytics(n)
                            })), Object.keys(t.xmpp.connectionTimes).forEach((e => {
                                const n = bt(`xmpp_${e}`, {
                                    value: t.xmpp.connectionTimes[e]
                                });
                                On.sendAnalytics(n)
                            }))
                        })), t.addListener(Hn().RENEGOTIATION_FAILED, ((t, n) => {
                            n.isP2P || e.eventEmitter.emit(J, D, t)
                        })), this.chatRoomForwarder.forward(Hn().ROOM_JOIN_ERROR, J, E), this.chatRoomForwarder.forward(Hn().ROOM_CONNECT_ERROR, J, E), this.chatRoomForwarder.forward(Hn().ROOM_CONNECT_NOT_ALLOWED_ERROR, J, C), this.chatRoomForwarder.forward(Hn().ROOM_CONNECT_MEMBERS_ONLY_ERROR, J, T), this.chatRoomForwarder.forward(Hn().ROOM_MAX_USERS_ERROR, J, S), this.chatRoomForwarder.forward(Hn().PASSWORD_REQUIRED, J, k), this.chatRoomForwarder.forward(Hn().AUTHENTICATION_REQUIRED, J, _), this.chatRoomForwarder.forward(Hn().BRIDGE_DOWN, J, L), t.addListener(Hn().BRIDGE_DOWN, (() => On.sendAnalytics(function() {
                            const e = "bridge.down";
                            return {
                                action: e,
                                actionSubject: e,
                                type: gt
                            }
                        }()))), t.addListener(Hn().CONNECTION_RESTARTED, (t => {
                            e._onConferenceRestarted(t)
                        })), this.chatRoomForwarder.forward(Hn().RESERVATION_ERROR, J, O), this.chatRoomForwarder.forward(Hn().GRACEFUL_SHUTDOWN, J, P), t.addListener(Hn().CONNECTION_ICE_FAILED, (t => {
                            e._onIceConnectionFailed(t)
                        })), this.chatRoomForwarder.forward(Hn().MUC_DESTROYED, J, y), this.chatRoomForwarder.forward(Hn().CHAT_ERROR_RECEIVED, B, v), this.chatRoomForwarder.forward(Hn().FOCUS_DISCONNECTED, J, A), t.addListener(Hn().FOCUS_LEFT, (() => {
                            On.sendAnalytics(function() {
                                const e = "focus.left";
                                return {
                                    action: e,
                                    actionSubject: e,
                                    type: gt
                                }
                            }()), e.eventEmitter.emit(J, w)
                        })), t.addListener(Hn().SESSION_ACCEPT_TIMEOUT, (e => {
                            On.sendAnalyticsAndLog(Tt("session-accept.timeout", {
                                p2p: e.isP2P
                            }))
                        })), t.addListener(Hn().RECORDER_STATE_CHANGED, ((t, n) => {
                            if (n) {
                                const i = Xe.Strophe.getResourceFromJid(n),
                                    s = e.getParticipantById(i) || i;
                                "off" === t.getStatus() ? t.setTerminator(s) : "on" === t.getStatus() && t.setInitiator(s)
                            }
                            e.eventEmitter.emit(Ee, t)
                        })), this.chatRoomForwarder.forward(Hn().TRANSCRIPTION_STATUS_CHANGED, ke), this.chatRoomForwarder.forward(Hn().VIDEO_SIP_GW_AVAILABILITY_CHANGED, be), this.chatRoomForwarder.forward(Hn().VIDEO_SIP_GW_SESSION_STATE_CHANGED, Ce), this.chatRoomForwarder.forward(Hn().PHONE_NUMBER_CHANGED, ye), t.setParticipantPropertyListener(((t, n) => {
                            const i = e.getParticipantById(n);
                            i && i.setProperty(t.tagName.substring("jitsi_participant_".length), t.value)
                        })), t.addListener(Hn().KICKED, e.onMemberKicked.bind(e)), t.addListener(Hn().SUSPEND_DETECTED, e.onSuspendDetected.bind(e)), this.chatRoomForwarder.forward(Hn().MUC_LOCK_CHANGED, re), this.chatRoomForwarder.forward(Hn().MUC_MEMBERS_ONLY_CHANGED, de), t.addListener(Hn().MUC_MEMBER_JOINED, e.onMemberJoined.bind(e)), this.chatRoomForwarder.forward(Hn().MUC_LOBBY_MEMBER_JOINED, $e), this.chatRoomForwarder.forward(Hn().MUC_LOBBY_MEMBER_UPDATED, Be), this.chatRoomForwarder.forward(Hn().MUC_LOBBY_MEMBER_LEFT, Je), t.addListener(Hn().MUC_MEMBER_BOT_TYPE_CHANGED, e._onMemberBotTypeChanged.bind(e)), t.addListener(Hn().MUC_MEMBER_LEFT, e.onMemberLeft.bind(e)), this.chatRoomForwarder.forward(Hn().MUC_LEFT, V), this.chatRoomForwarder.forward(Hn().MUC_DENIED_ACCESS, J, R), t.addListener(Hn().DISPLAY_NAME_CHANGED, e.onDisplayNameChanged.bind(e)), t.addListener(Hn().LOCAL_ROLE_CHANGED, (t => {
                            e.onLocalRoleChanged(t), e.statistics && e.isModerator() && e.on(Ee, (e => {
                                const t = {
                                    error: e.getError(),
                                    id: "recorder_status",
                                    status: e.getStatus()
                                };
                                On.sendLog(JSON.stringify(t))
                            }))
                        })), t.addListener(Hn().MUC_ROLE_CHANGED, e.onUserRoleChanged.bind(e)), t.addListener(Un().IDENTITY_UPDATED, ((t, n) => {
                            e.authEnabled = t, e.authIdentity = n, e.eventEmitter.emit(F, t, n)
                        })), t.addListener(Hn().MESSAGE_RECEIVED, ((t, n, i, s) => {
                            const r = Xe.Strophe.getResourceFromJid(t);
                            e.eventEmitter.emit(le, r, n, s)
                        })), t.addListener(Hn().PRIVATE_MESSAGE_RECEIVED, ((t, n, i, s) => {
                            const r = Xe.Strophe.getResourceFromJid(t);
                            e.eventEmitter.emit(me, r, n, s)
                        })), t.addListener(Hn().PRESENCE_STATUS, ((t, n) => {
                            const i = Xe.Strophe.getResourceFromJid(t),
                                s = e.getParticipantById(i);
                            s && s._status !== n && (s._status = n, e.eventEmitter.emit(Fe, i, n))
                        })), t.addListener(Hn().JSON_MESSAGE_RECEIVED, ((t, n) => {
                            const i = Xe.Strophe.getResourceFromJid(t),
                                s = e.getParticipantById(i);
                            s ? e.eventEmitter.emit(Z, s, n) : e.eventEmitter.emit(pe, i, n)
                        })), t.addPresenceListener("startmuted", ((t, n) => {
                            let i = !1;
                            if (e.myUserId() === n && e.isModerator()) i = !0;
                            else {
                                const t = e.getParticipantById(n);
                                t && t.isModerator() && (i = !0)
                            }
                            if (!i) return;
                            const s = "true" === t.attributes.audio,
                                r = "true" === t.attributes.video;
                            let o = !1;
                            s !== e.startMutedPolicy.audio && (e.startMutedPolicy.audio = s, o = !0), r !== e.startMutedPolicy.video && (e.startMutedPolicy.video = r, o = !0), o && e.eventEmitter.emit(Te, e.startMutedPolicy)
                        })), e.statistics && (t.addListener(Hn().CONNECTION_ICE_FAILED, (t => {
                            e.statistics.sendIceConnectionFailedEvent(t.peerconnection)
                        })), t.addListener(Hn().ADD_ICE_CANDIDATE_FAILED, ((t, n) => {
                            e.statistics.sendAddIceCandidateFailed(t, n)
                        })))
                    }, qn.prototype.setupRTCListeners = function() {
                        const e = this.conference,
                            t = e.rtc;
                        t.addListener(jn().REMOTE_TRACK_ADDED, e.onRemoteTrackAdded.bind(e)), t.addListener(jn().REMOTE_TRACK_REMOVED, e.onRemoteTrackRemoved.bind(e)), t.addListener(jn().DOMINANT_SPEAKER_CHANGED, ((t, n) => {
                            if (e.lastDominantSpeaker !== t && e.room) {
                                if (e.lastDominantSpeaker = t, e.eventEmitter.emit(Q, t, n), n && n.length) {
                                    const i = n.slice(0);
                                    e.myUserId !== t && i.splice(0, 0, t), i.length > 5 && i.splice(5, i.length - 5), e.statistics && e.statistics.setSpeakerList(i)
                                }
                                e.statistics && e.myUserId() === t && e.statistics.sendDominantSpeakerEvent(e.room.roomjid)
                            }
                        })), t.addListener(jn().DATA_CHANNEL_OPEN, (() => {
                            const t = window.performance.now(),
                                n = "data.channel.opened";
                            Gn.log(`(TIME) ${n}:\t`, t), e.room.connectionTimes[n] = t, On.sendAnalytics(bt(n, {
                                value: t
                            })), e.eventEmitter.emit(z)
                        })), t.addListener(jn().ENDPOINT_MESSAGE_RECEIVED, ((t, n) => {
                            const i = e.getParticipantById(t);
                            i ? e.eventEmitter.emit(Z, i, n) : Gn.warn(`Ignored ENDPOINT_MESSAGE_RECEIVED for not existing participant: ${t}`, n)
                        })), t.addListener(jn().ENDPOINT_STATS_RECEIVED, ((t, n) => {
                            const i = e.getParticipantById(t);
                            i ? e.eventEmitter.emit(ee, i, n) : Gn.warn(`Ignoring ENDPOINT_STATS_RECEIVED for a non-existant participant: ${t}`)
                        })), t.addListener(jn().LOCAL_UFRAG_CHANGED, ((e, t) => {
                            e.isP2P || On.sendLog(JSON.stringify({
                                id: "local_ufrag",
                                value: t
                            }))
                        })), t.addListener(jn().REMOTE_UFRAG_CHANGED, ((e, t) => {
                            e.isP2P || On.sendLog(JSON.stringify({
                                id: "remote_ufrag",
                                value: t
                            }))
                        })), t.addListener(jn().CREATE_ANSWER_FAILED, ((t, n) => {
                            e.statistics.sendCreateAnswerFailed(t, n), n.isP2P || e.eventEmitter.emit(J, D, t)
                        })), t.addListener(jn().CREATE_OFFER_FAILED, ((t, n) => {
                            e.statistics.sendCreateOfferFailed(t, n), n.isP2P || e.eventEmitter.emit(J, D, t)
                        })), t.addListener(jn().SET_LOCAL_DESCRIPTION_FAILED, ((t, n) => {
                            e.statistics.sendSetLocalDescFailed(t, n), n.isP2P || e.eventEmitter.emit(J, D, t)
                        })), t.addListener(jn().SET_REMOTE_DESCRIPTION_FAILED, ((t, n) => {
                            e.statistics.sendSetRemoteDescFailed(t, n), n.isP2P || e.eventEmitter.emit(J, D, t)
                        })), t.addListener(jn().LOCAL_TRACK_SSRC_UPDATED, ((t, n) => {
                            t.isVideoTrack() && t.videoType === Bn().DESKTOP && e.statistics.sendScreenSharingEvent(!0, n)
                        }))
                    }, qn.prototype.removeXMPPListeners = function() {
                        const e = this.conference;
                        Object.keys(this.xmppListeners).forEach((t => {
                            e.xmpp.removeListener(t, this.xmppListeners[t])
                        })), this.xmppListeners = {}
                    }, qn.prototype.setupXMPPListeners = function() {
                        const e = this.conference;
                        this._addConferenceXMPPListener(Hn().CALL_INCOMING, e.onIncomingCall.bind(e)), this._addConferenceXMPPListener(Hn().CALL_ACCEPTED, e.onCallAccepted.bind(e)), this._addConferenceXMPPListener(Hn().TRANSPORT_INFO, e.onTransportInfo.bind(e)), this._addConferenceXMPPListener(Hn().CALL_ENDED, e.onCallEnded.bind(e)), this._addConferenceXMPPListener(Hn().START_MUTED_FROM_FOCUS, ((t, n) => {
                            e.options.config.ignoreStartMuted || (e.startAudioMuted = t, e.startVideoMuted = n, e.getLocalTracks().forEach((t => {
                                switch (t.getType()) {
                                    case En:
                                        e.startAudioMuted && t.mute();
                                        break;
                                    case Cn:
                                        e.startVideoMuted && t.mute()
                                }
                            })), e.eventEmitter.emit(Re))
                        })), this._addConferenceXMPPListener(Hn().CONFERENCE_TIMESTAMP_RECEIVED, (t => {
                            e.eventEmitter.emit(X, t)
                        })), this._addConferenceXMPPListener(Hn().AV_MODERATION_CHANGED, ((t, n, i) => {
                            const s = e.getParticipants().find((e => e.getJid() === i));
                            e.eventEmitter.emit(He, {
                                enabled: t,
                                mediaType: n,
                                actor: s
                            })
                        })), this._addConferenceXMPPListener(Hn().AV_MODERATION_PARTICIPANT_APPROVED, ((t, n) => {
                            const i = e.getParticipantById(Xe.Strophe.getResourceFromJid(n));
                            i && e.eventEmitter.emit(Ge, {
                                participant: i,
                                mediaType: t
                            })
                        })), this._addConferenceXMPPListener(Hn().AV_MODERATION_PARTICIPANT_REJECTED, ((t, n) => {
                            const i = e.getParticipantById(Xe.Strophe.getResourceFromJid(n));
                            i && e.eventEmitter.emit(qe, {
                                participant: i,
                                mediaType: t
                            })
                        })), this._addConferenceXMPPListener(Hn().AV_MODERATION_APPROVED, (t => e.eventEmitter.emit(Ue, {
                            mediaType: t
                        }))), this._addConferenceXMPPListener(Hn().AV_MODERATION_REJECTED, (t => {
                            e.eventEmitter.emit(Ve, {
                                mediaType: t
                            })
                        }))
                    }, qn.prototype._addConferenceXMPPListener = function(e, t) {
                        this.xmppListeners[e] = t, this.conference.xmpp.addListener(e, t)
                    }, qn.prototype.setupStatisticsListeners = function() {
                        const e = this.conference;
                        e.statistics && (e.statistics.addAudioLevelListener(((t, n, i, s) => {
                            e.rtc.setAudioLevel(t, n, i, s)
                        })), e.statistics.addBeforeDisposedListener((() => {
                            e.eventEmitter.emit(j)
                        })), e.options.config.startSilent || e.statistics.addByteSentStatsListener(((t, n) => {
                            e.getLocalTracks(En).forEach((e => {
                                const i = t.getLocalSSRC(e);
                                i && n.hasOwnProperty(i) && e._onByteSentStatsReceived(t, n[i])
                            }))
                        })))
                    };
                    const Kn = "track.stopped",
                        zn = "track.audioLevelsChanged",
                        Wn = "track.audioOutputChanged",
                        Qn = "track.trackMuteChanged",
                        Xn = "track.videoTypeChanged",
                        Yn = "track.no_data_from_source",
                        Zn = "track.no_audio_input";

                    function ei(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? Object(arguments[t]) : {},
                                i = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), i.forEach((function(t) {
                                ti(e, t, n[t])
                            }))
                        }
                        return e
                    }

                    function ti(e, t, n) {
                        return t in e ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = n, e
                    }
                    const ni = (0, f.getLogger)("modules/connectivity/ParticipantConnectionStatus.js"),
                        ii = {
                            ACTIVE: "active",
                            INACTIVE: "inactive",
                            INTERRUPTED: "interrupted",
                            RESTORING: "restoring"
                        };
                    class si {
                        static _getNewStateForJvbMode(e, t, n, i, s) {
                            return e ? i ? ii.ACTIVE : Qt.supportsVideoMuteOnConnInterrupted() ? s ? t ? n ? ii.INTERRUPTED : ii.RESTORING : ii.INACTIVE : ii.ACTIVE : t ? ii.ACTIVE : ii.INACTIVE : ii.INTERRUPTED
                        }
                        static _getNewStateForP2PMode(e, t) {
                            return Qt.supportsVideoMuteOnConnInterrupted() ? e || !t ? ii.ACTIVE : ii.INTERRUPTED : ii.ACTIVE
                        }
                        constructor(e, t, n) {
                            this.rtc = e, this.conference = t, this.trackTimers = {}, this.connStatusFromJvb = {}, this.outOfLastNTimeout = "number" == typeof n.outOfLastNTimeout ? n.outOfLastNTimeout : 500, this.rtcMuteTimeout = "number" == typeof n.rtcMuteTimeout ? n.rtcMuteTimeout : 1e4, this.rtcMutedTimestamp = {}, ni.info(`RtcMuteTimeout set to: ${this.rtcMuteTimeout}`), this.enteredLastNTimestamp = new Map, this.restoringTimers = new Map, this.connectionStatusMap = new Map
                        }
                        _getVideoFrozenTimeout(e) {
                            return this.rtc.isInLastN(e) ? this.rtcMuteTimeout : this.outOfLastNTimeout
                        }
                        init() {
                            this._onEndpointConnStatusChanged = this.onEndpointConnStatusChanged.bind(this), this.rtc.addListener(jn().ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged), this._onP2PStatus = this.refreshConnectionStatusForAll.bind(this), this.conference.on(ve, this._onP2PStatus), this._onUserLeft = this.onUserLeft.bind(this), this.conference.on(Le, this._onUserLeft), Qt.supportsVideoMuteOnConnInterrupted() && (this._onTrackRtcMuted = this.onTrackRtcMuted.bind(this), this.rtc.addListener(jn().REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this._onTrackRtcUnmuted = this.onTrackRtcUnmuted.bind(this), this.rtc.addListener(jn().REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this._onRemoteTrackAdded = this.onRemoteTrackAdded.bind(this), this.conference.on(Ie, this._onRemoteTrackAdded), this._onRemoteTrackRemoved = this.onRemoteTrackRemoved.bind(this), this.conference.on(Ne, this._onRemoteTrackRemoved), this._onSignallingMuteChanged = this.onSignallingMuteChanged.bind(this), this._onTrackVideoTypeChanged = this.onTrackVideoTypeChanged.bind(this)), this._onLastNChanged = this._onLastNChanged.bind(this), this.conference.on(se, this._onLastNChanged), this._onLastNValueChanged = this.refreshConnectionStatusForAll.bind(this), this.rtc.on(jn().LASTN_VALUE_CHANGED, this._onLastNValueChanged)
                        }
                        dispose() {
                            this.rtc.removeListener(jn().ENDPOINT_CONN_STATUS_CHANGED, this._onEndpointConnStatusChanged), Qt.supportsVideoMuteOnConnInterrupted() && (this.rtc.removeListener(jn().REMOTE_TRACK_MUTE, this._onTrackRtcMuted), this.rtc.removeListener(jn().REMOTE_TRACK_UNMUTE, this._onTrackRtcUnmuted), this.conference.off(Ie, this._onRemoteTrackAdded), this.conference.off(Ne, this._onRemoteTrackRemoved)), this.conference.off(se, this._onLastNChanged), this.rtc.removeListener(jn().LASTN_VALUE_CHANGED, this._onLastNValueChanged), this.conference.off(ve, this._onP2PStatus), this.conference.off(Le, this._onUserLeft);
                            const e = Object.keys(this.trackTimers);
                            for (const t of e) this.clearTimeout(t), this.clearRtcMutedTimestamp(t);
                            for (const e in this.connectionStatusMap) this.connectionStatusMap.hasOwnProperty(e) && this.onUserLeft(e);
                            this.connStatusFromJvb = {}
                        }
                        onEndpointConnStatusChanged(e, t) {
                            ni.debug(`Detector RTCEvents.ENDPOINT_CONN_STATUS_CHANGED(${Date.now()}): ${e}: ${t}`), e !== this.conference.myUserId() && (this.connStatusFromJvb[e] = t, this.figureOutConnectionStatus(e))
                        }
                        _changeConnectionStatus(e, t) {
                            if (e.getConnectionStatus() !== t) {
                                const n = e.getId();
                                e._setConnectionStatus(t), ni.debug(`Emit endpoint conn status(${Date.now()}) ${n}: ${t}`), On.sendLog(JSON.stringify({
                                    id: "peer.conn.status",
                                    participant: n,
                                    status: t
                                })), this.conference.eventEmitter.emit(fe, n, t)
                            }
                        }
                        clearTimeout(e) {
                            this.trackTimers[e] && (window.clearTimeout(this.trackTimers[e]), this.trackTimers[e] = null)
                        }
                        clearRtcMutedTimestamp(e) {
                            this.rtcMutedTimestamp[e] = null
                        }
                        onRemoteTrackAdded(e) {
                            e.isLocal() || e.getType() !== Cn || (ni.debug(`Detector on remote track added for: ${e.getParticipantId()}`), e.on(Qn, this._onSignallingMuteChanged), e.on(Xn, (t => this._onTrackVideoTypeChanged(e, t))))
                        }
                        onRemoteTrackRemoved(e) {
                            if (!e.isLocal() && e.getType() === Cn) {
                                const t = e.getParticipantId();
                                ni.debug(`Detector on remote track removed: ${t}`), e.off(Qn, this._onSignallingMuteChanged), this.clearTimeout(t), this.clearRtcMutedTimestamp(t), this.figureOutConnectionStatus(t)
                            }
                        }
                        isVideoTrackFrozen(e) {
                            if (!Qt.supportsVideoMuteOnConnInterrupted()) return !1;
                            const t = e.getId(),
                                n = e.hasAnyVideoTrackWebRTCMuted(),
                                i = this.rtcMutedTimestamp[t],
                                s = this._getVideoFrozenTimeout(t);
                            return n && "number" == typeof i && Date.now() - i >= s
                        }
                        refreshConnectionStatusForAll() {
                            const e = this.conference.getParticipants();
                            for (const t of e) this.figureOutConnectionStatus(t.getId())
                        }
                        figureOutConnectionStatus(e) {
                            const t = this.conference.getParticipantById(e);
                            if (!t) return void ni.debug(`figure out conn status - no participant for: ${e}`);
                            const n = this.conference.isP2PActive(),
                                i = this._isRestoringTimedout(e),
                                s = 0 === this.conference.getLastN(),
                                r = t.isVideoMuted() || s,
                                o = this.isVideoTrackFrozen(t),
                                a = this.rtc.isInLastN(e);
                            let c = this.connStatusFromJvb[e];
                            "boolean" != typeof c && (c = !0);
                            const d = n ? si._getNewStateForP2PMode(r, o) : si._getNewStateForJvbMode(c, a, i, r, o);
                            d !== ii.RESTORING && this._clearRestoringTimer(e), ni.debug(`Figure out conn status for ${e}, is video muted: ${r} is active(jvb): ${c} video track frozen: ${o} p2p mode: ${n} is in last N: ${a} currentStatus => newStatus: ${t.getConnectionStatus()} => ${d}`);
                            const l = this.connectionStatusMap[e] || {};
                            if (!("p2p" in l) || !("connectionStatus" in l) || l.p2p !== n || l.connectionStatus !== d) {
                                const i = Date.now();
                                if (this.maybeSendParticipantConnectionStatusEvent(e, i), this.connectionStatusMap[e] = ei({}, l, {
                                        connectionStatus: d,
                                        p2p: n,
                                        startedMs: i
                                    }), !("videoType" in this.connectionStatusMap[e])) {
                                    const n = t.getTracksByMediaType(Cn);
                                    Array.isArray(n) && 0 !== n.length && (this.connectionStatusMap[e].videoType = n[0].videoType)
                                }
                            }
                            this._changeConnectionStatus(t, d)
                        }
                        maybeSendParticipantConnectionStatusEvent(e, t) {
                            const n = this.connectionStatusMap[e];
                            n && "startedMs" in n && "videoType" in n && "connectionStatus" in n && "p2p" in n && (n.value = t - n.startedMs, On.sendAnalytics(function(e = {}) {
                                return {
                                    type: gt,
                                    source: "peer.conn.status",
                                    action: "duration",
                                    attributes: e
                                }
                            }(n)))
                        }
                        _onLastNChanged(e = [], t = []) {
                            const n = Date.now();
                            ni.debug(`LastN endpoints changed leaving=${e}, entering=${t} at ${n}`), Qt.supportsVideoMuteOnConnInterrupted() || this.refreshConnectionStatusForAll();
                            for (const t of e) this.enteredLastNTimestamp.delete(t), this._clearRestoringTimer(t), Qt.supportsVideoMuteOnConnInterrupted() && this.figureOutConnectionStatus(t);
                            for (const e of t) this.enteredLastNTimestamp.set(e, n), Qt.supportsVideoMuteOnConnInterrupted() && this.figureOutConnectionStatus(e)
                        }
                        _clearRestoringTimer(e) {
                            const t = this.restoringTimers.get(e);
                            t && (clearTimeout(t), this.restoringTimers.delete(e))
                        }
                        _isRestoringTimedout(e) {
                            const t = this.enteredLastNTimestamp.get(e);
                            return !!(t && Date.now() - t >= 1e4) || (this.restoringTimers.get(e) || this.restoringTimers.set(e, setTimeout((() => this.figureOutConnectionStatus(e)), 1e4)), !1)
                        }
                        onUserLeft(e) {
                            this.maybeSendParticipantConnectionStatusEvent(e, Date.now()), delete this.connectionStatusMap[e]
                        }
                        onTrackRtcMuted(e) {
                            const t = e.getParticipantId(),
                                n = this.conference.getParticipantById(t);
                            if (ni.debug(`Detector track RTC muted: ${t}`, Date.now()), n) {
                                if (this.rtcMutedTimestamp[t] = Date.now(), !n.isVideoMuted()) {
                                    this.clearTimeout(t);
                                    const e = this._getVideoFrozenTimeout(t);
                                    this.trackTimers[t] = window.setTimeout((() => {
                                        ni.debug(`Set RTC mute timeout for: ${t}                     of ${e} ms`), this.clearTimeout(t), this.figureOutConnectionStatus(t)
                                    }), e)
                                }
                            } else ni.error(`No participant for id: ${t}`)
                        }
                        onTrackRtcUnmuted(e) {
                            const t = e.getParticipantId();
                            ni.debug(`Detector track RTC unmuted: ${t}`, Date.now()), this.clearTimeout(t), this.clearRtcMutedTimestamp(t), this.figureOutConnectionStatus(t)
                        }
                        onSignallingMuteChanged(e) {
                            const t = e.getParticipantId();
                            ni.debug(`Detector on track signalling mute changed: ${t}`, e.isMuted()), this.figureOutConnectionStatus(t)
                        }
                        onTrackVideoTypeChanged(e, t) {
                            const n = e.getParticipantId(),
                                i = Date.now();
                            this.maybeSendParticipantConnectionStatusEvent(n, i), this.connectionStatusMap[n] = ei({}, this.connectionStatusMap[n] || {}, {
                                videoType: t,
                                startedMs: i
                            })
                        }
                    }
                    class ri {
                        constructor(e, t, n, i, s, r, o, a, c) {
                            this._jid = e, this._id = Xe.Strophe.getResourceFromJid(e), this._conference = t, this._displayName = n, this._supportsDTMF = !1, this._tracks = [], this._role = "none", this._status = r, this._hidden = i, this._statsID = s, this._connectionStatus = ii.ACTIVE, this._properties = {}, this._identity = o, this._isReplacing = a, this._isReplaced = c, this._features = new Set
                        }
                        getConference() {
                            return this._conference
                        }
                        getProperty(e) {
                            return this._properties[e]
                        }
                        hasAnyVideoTrackWebRTCMuted() {
                            return this.getTracks().some((e => e.getType() === Cn && e.isWebRTCTrackMuted()))
                        }
                        _setConnectionStatus(e) {
                            this._connectionStatus = e
                        }
                        getConnectionStatus() {
                            return this._connectionStatus
                        }
                        setProperty(e, t) {
                            const n = this._properties[e];
                            t !== n && (this._properties[e] = t, this._conference.eventEmitter.emit(_e, this, e, n, t))
                        }
                        getTracks() {
                            return this._tracks.slice()
                        }
                        getTracksByMediaType(e) {
                            return this.getTracks().filter((t => t.getType() === e))
                        }
                        getId() {
                            return this._id
                        }
                        getJid() {
                            return this._jid
                        }
                        getDisplayName() {
                            return this._displayName
                        }
                        getStatsID() {
                            return this._statsID
                        }
                        getStatus() {
                            return this._status
                        }
                        isModerator() {
                            return "moderator" === this._role
                        }
                        isHidden() {
                            return this._hidden
                        }
                        isReplacing() {
                            return this._isReplacing
                        }
                        isReplaced() {
                            return this._isReplaced
                        }
                        isAudioMuted() {
                            return this._isMediaTypeMuted(En)
                        }
                        _isMediaTypeMuted(e) {
                            return this.getTracks().reduce(((t, n) => t && (n.getType() !== e || n.isMuted())), !0)
                        }
                        isVideoMuted() {
                            return this._isMediaTypeMuted(Cn)
                        }
                        getRole() {
                            return this._role
                        }
                        setRole(e) {
                            this._role = e
                        }
                        setIsReplacing(e) {
                            this._isReplacing = e
                        }
                        setIsReplaced(e) {
                            this._isReplaced = e
                        }
                        supportsDTMF() {
                            return this._supportsDTMF
                        }
                        getFeatures() {
                            return Promise.resolve(this._features)
                        }
                        hasFeature(e) {
                            return this._features.has(e)
                        }
                        setFeatures(e) {
                            this._features = e || new Set
                        }
                        getBotType() {
                            return this._botType
                        }
                        setBotType(e) {
                            this._botType = e
                        }
                    }
                    const oi = "connection.connectionDisconnected",
                        ai = "connection.connectionEstablished",
                        ci = "connection.connectionFailed",
                        di = "connection.wrongState",
                        li = "connection.display_name_required";
                    n(8623);
                    const hi = "connection.droppedError",
                        ui = "connection.otherError",
                        pi = "connection.passwordRequired",
                        mi = "connection.serverError";
                    var fi = n(6448),
                        gi = n.n(fi);
                    class _i {
                        constructor() {
                            this.promise = new Promise(((e, t) => {
                                this.resolve = (...t) => {
                                    this.clearRejectTimeout(), e(...t)
                                }, this.reject = (...e) => {
                                    this.clearRejectTimeout(), t(...e)
                                }
                            })), this.then = this.promise.then.bind(this.promise), this.catch = this.promise.catch.bind(this.promise)
                        }
                        clearRejectTimeout() {
                            clearTimeout(this._timeout)
                        }
                        setRejectTimeout(e) {
                            this._timeout = setTimeout((() => {
                                this.reject(new Error("timeout"))
                            }), e)
                        }
                    }
                    const vi = (0, f.getLogger)("modules/e2ee/E2EEContext.js"),
                        yi = Symbol("kJitsiE2EE");
                    class Si {
                        constructor() {
                            let e = "";
                            const t = document.querySelector('script[src*="lib-jitsi-meet"]');
                            if (t) {
                                const n = t.src.lastIndexOf("/");
                                e = `${t.src.substring(0,n)}/`
                            }
                            const n = new Blob([`importScripts("${e}lib-jitsi-meet.e2ee-worker.js");`], {
                                    type: "application/javascript"
                                }),
                                i = window.URL.createObjectURL(n);
                            this._worker = new Worker(i, {
                                name: "E2EE Worker"
                            }), this._worker.onerror = e => vi.error(e)
                        }
                        cleanup(e) {
                            this._worker.postMessage({
                                operation: "cleanup",
                                participantId: e
                            })
                        }
                        handleReceiver(e, t, n) {
                            if (!e[yi])
                                if (e[yi] = !0, window.RTCRtpScriptTransform) {
                                    const t = {
                                        operation: "decode",
                                        participantId: n
                                    };
                                    e.transform = new RTCRtpScriptTransform(this._worker, t)
                                } else {
                                    const t = e.createEncodedStreams();
                                    this._worker.postMessage({
                                        operation: "decode",
                                        readableStream: t.readable,
                                        writableStream: t.writable,
                                        participantId: n
                                    }, [t.readable, t.writable])
                                }
                        }
                        handleSender(e, t, n) {
                            if (!e[yi])
                                if (e[yi] = !0, window.RTCRtpScriptTransform) {
                                    const t = {
                                        operation: "encode",
                                        participantId: n
                                    };
                                    e.transform = new RTCRtpScriptTransform(this._worker, t)
                                } else {
                                    const t = e.createEncodedStreams();
                                    this._worker.postMessage({
                                        operation: "encode",
                                        readableStream: t.readable,
                                        writableStream: t.writable,
                                        participantId: n
                                    }, [t.readable, t.writable])
                                }
                        }
                        setKey(e, t, n) {
                            this._worker.postMessage({
                                operation: "setKey",
                                participantId: e,
                                key: t,
                                keyIndex: n
                            })
                        }
                    }
                    var Ei = n(298),
                        bi = n(7593);
                    bi.v1, bi.v3;
                    const Ci = bi.v4;
                    bi.v5;
                    class Ti {
                        constructor(e = new(ze())) {
                            this.eventEmitter = e, this.addEventListener = this.on = this.addListener, this.removeEventListener = this.off = this.removeListener
                        }
                        addListener(e, t) {
                            return this.eventEmitter.addListener(e, t), () => this.removeEventListener(e, t)
                        }
                        removeListener(e, t) {
                            this.eventEmitter.removeListener(e, t)
                        }
                    }
                    const Ri = (0, f.getLogger)("modules/e2ee/OlmAdapter.js"),
                        Ai = "olm",
                        wi = "error",
                        Pi = "key-info",
                        Ii = "key-info-ack",
                        Mi = "session-ack",
                        Di = "session-init",
                        Ni = Symbol("OlmData"),
                        ki = {
                            OLM_ID_KEY_READY: "olm.id_key_ready",
                            PARTICIPANT_E2EE_CHANNEL_READY: "olm.participant_e2ee_channel_ready",
                            PARTICIPANT_KEY_UPDATED: "olm.partitipant_key_updated"
                        };
                    class Oi extends Ti {
                        constructor(e) {
                            super(), this._conf = e, this._init = new _i, this._key = void 0, this._keyIndex = -1, this._reqs = new Map, this._sessionInitialization = void 0, Oi.isSupported() ? (this._bootstrapOlm(), this._conf.on(Z, this._onEndpointMessageReceived.bind(this)), this._conf.on(V, this._onConferenceLeft.bind(this)), this._conf.on(Le, this._onParticipantLeft.bind(this)), this._conf.on(_e, this._onParticipantPropertyChanged.bind(this))) : this._init.reject(new Error("Olm not supported"))
                        }
                        async initSessions() {
                            if (this._sessionInitialization) throw new Error("OlmAdapter initSessions called multiple times"); {
                                this._sessionInitialization = new _i, await this._init;
                                const e = [],
                                    t = this._conf.myUserId();
                                for (const n of this._conf.getParticipants())(await n.getFeatures()).has(Mr) && t < n.getId() && e.push(this._sendSessionInit(n));
                                await Promise.allSettled(e), this._sessionInitialization.resolve(), this._sessionInitialization = void 0
                            }
                        }
                        static isSupported() {
                            return void 0 !== window.Olm
                        }
                        async updateKey(e) {
                            this._key = e, this._keyIndex++;
                            const t = [];
                            for (const e of this._conf.getParticipants()) {
                                const n = e.getId(),
                                    i = this._getParticipantOlmData(e);
                                if (!i.session) {
                                    Ri.warn(`Tried to send key to participant ${n} but we have no session`);
                                    continue
                                }
                                const s = Ci(),
                                    r = {
                                        [Pr]: Ai,
                                        olm: {
                                            type: Pi,
                                            data: {
                                                ciphertext: this._encryptKeyInfo(i.session),
                                                uuid: s
                                            }
                                        }
                                    },
                                    o = new _i;
                                o.setRejectTimeout(5e3), o.catch((() => {
                                    this._reqs.delete(s)
                                })), this._reqs.set(s, o), t.push(o), this._sendMessage(r, n)
                            }
                            return await Promise.allSettled(t), this._keyIndex
                        }
                        updateCurrentKey(e) {
                            return this._key = e, this._keyIndex
                        }
                        clearParticipantSession(e) {
                            const t = this._getParticipantOlmData(e);
                            t.session && (t.session.free(), t.session = void 0)
                        }
                        clearAllParticipantsSessions() {
                            for (const e of this._conf.getParticipants()) this.clearParticipantSession(e)
                        }
                        async _bootstrapOlm() {
                            Ri.debug("Initializing Olm...");
                            try {
                                await Olm.init(), this._olmAccount = new Olm.Account, this._olmAccount.create();
                                const e = JSON.parse(this._olmAccount.identity_keys());
                                this._idKey = e.curve25519, Ri.debug(`Olm ${Olm.get_library_version().join(".")} initialized`), this._init.resolve(), this.eventEmitter.emit(ki.OLM_ID_KEY_READY, this._idKey)
                            } catch (e) {
                                Ri.error("Failed to initialize Olm", e), this._init.reject(e)
                            }
                        }
                        _encryptKeyInfo(e) {
                            const t = {};
                            return void 0 !== this._key && (t.key = !!this._key && Ei.fromByteArray(this._key), t.keyIndex = this._keyIndex), e.encrypt(JSON.stringify(t))
                        }
                        _getParticipantOlmData(e) {
                            return e[Ni] = e[Ni] || {}, e[Ni]
                        }
                        async _onConferenceLeft() {
                            Ri.debug("Conference left"), await this._init;
                            for (const e of this._conf.getParticipants()) this._onParticipantLeft(e.getId(), e);
                            this._olmAccount && (this._olmAccount.free(), this._olmAccount = void 0)
                        }
                        async _onEndpointMessageReceived(e, t) {
                            if (t[Pr] !== Ai) return;
                            if (!t.olm) return void Ri.warn("Incorrectly formatted message");
                            await this._init;
                            const n = t.olm,
                                i = e.getId(),
                                s = this._getParticipantOlmData(e);
                            switch (n.type) {
                                case Di:
                                    if (s.session) Ri.warn(`Participant ${i} already has a session`), this._sendError(e, "Session already established");
                                    else {
                                        const e = new Olm.Session;
                                        e.create_outbound(this._olmAccount, n.data.idKey, n.data.otKey), s.session = e;
                                        const t = {
                                            [Pr]: Ai,
                                            olm: {
                                                type: Mi,
                                                data: {
                                                    ciphertext: this._encryptKeyInfo(e),
                                                    uuid: n.data.uuid
                                                }
                                            }
                                        };
                                        this._sendMessage(t, i), this.eventEmitter.emit(ki.PARTICIPANT_E2EE_CHANNEL_READY, i)
                                    }
                                    break;
                                case Mi:
                                    if (s.session) Ri.warn(`Participant ${i} already has a session`), this._sendError(e, "No session found");
                                    else if (n.data.uuid === s.pendingSessionUuid) {
                                        const {
                                            ciphertext: e
                                        } = n.data, t = this._reqs.get(n.data.uuid), r = new Olm.Session;
                                        r.create_inbound(this._olmAccount, e.body), this._olmAccount.remove_one_time_keys(r);
                                        const o = r.decrypt(e.type, e.body);
                                        s.session = r, s.pendingSessionUuid = void 0, this.eventEmitter.emit(ki.PARTICIPANT_E2EE_CHANNEL_READY, i), this._reqs.delete(n.data.uuid), t.resolve();
                                        const a = Li(o);
                                        if (a.key) {
                                            const e = Ei.toByteArray(a.key),
                                                t = a.keyIndex;
                                            s.lastKey = e, this.eventEmitter.emit(ki.PARTICIPANT_KEY_UPDATED, i, e, t)
                                        }
                                    } else Ri.warn("Received ACK with the wrong UUID"), this._sendError(e, "Invalid UUID");
                                    break;
                                case wi:
                                    Ri.error(n.data.error);
                                    break;
                                case Pi:
                                    if (s.session) {
                                        const {
                                            ciphertext: e
                                        } = n.data, t = Li(s.session.decrypt(e.type, e.body));
                                        if (void 0 !== t.key && void 0 !== t.keyIndex) {
                                            const e = !!t.key && Ei.toByteArray(t.key),
                                                r = t.keyIndex;
                                            Qe()(s.lastKey, e) || (s.lastKey = e, this.eventEmitter.emit(ki.PARTICIPANT_KEY_UPDATED, i, e, r));
                                            const o = {
                                                [Pr]: Ai,
                                                olm: {
                                                    type: Ii,
                                                    data: {
                                                        ciphertext: this._encryptKeyInfo(s.session),
                                                        uuid: n.data.uuid
                                                    }
                                                }
                                            };
                                            this._sendMessage(o, i)
                                        }
                                    } else Ri.debug(`Received key info message from ${i} but we have no session for them!`), this._sendError(e, "No session found while processing key-info");
                                    break;
                                case Ii:
                                    if (s.session) {
                                        const {
                                            ciphertext: e
                                        } = n.data, t = Li(s.session.decrypt(e.type, e.body));
                                        if (void 0 !== t.key && void 0 !== t.keyIndex) {
                                            const e = !!t.key && Ei.toByteArray(t.key),
                                                n = t.keyIndex;
                                            Qe()(s.lastKey, e) || (s.lastKey = e, this.eventEmitter.emit(ki.PARTICIPANT_KEY_UPDATED, i, e, n))
                                        }
                                        const r = this._reqs.get(n.data.uuid);
                                        this._reqs.delete(n.data.uuid), r.resolve()
                                    } else Ri.debug(`Received key info ack message from ${i} but we have no session for them!`), this._sendError(e, "No session found while processing key-info-ack")
                            }
                        }
                        _onParticipantLeft(e, t) {
                            Ri.debug(`Participant ${e} left`), this.clearParticipantSession(t)
                        }
                        async _onParticipantPropertyChanged(e, t, n, i) {
                            if ("e2ee.enabled" === t && i && this._conf.isE2EEEnabled()) {
                                const t = this._conf.myUserId(),
                                    n = e.getId();
                                if ((await e.getFeatures()).has(Mr) && t < n) {
                                    this._sessionInitialization && await this._sessionInitialization, await this._sendSessionInit(e);
                                    const t = this._getParticipantOlmData(e),
                                        i = Ci(),
                                        s = {
                                            [Pr]: Ai,
                                            olm: {
                                                type: Pi,
                                                data: {
                                                    ciphertext: this._encryptKeyInfo(t.session),
                                                    uuid: i
                                                }
                                            }
                                        };
                                    this._sendMessage(s, n)
                                }
                            }
                        }
                        _sendError(e, t) {
                            const n = e.getId(),
                                i = {
                                    [Pr]: Ai,
                                    olm: {
                                        type: wi,
                                        data: {
                                            error: t
                                        }
                                    }
                                };
                            this._sendMessage(i, n)
                        }
                        _sendMessage(e, t) {
                            this._conf.sendMessage(e, t)
                        }
                        _sendSessionInit(e) {
                            const t = e.getId(),
                                n = this._getParticipantOlmData(e);
                            if (n.session) return Ri.warn(`Tried to send session-init to ${t} but we already have a session`), Promise.reject();
                            if (void 0 !== n.pendingSessionUuid) return Ri.warn(`Tried to send session-init to ${t} but we already have a pending session`), Promise.reject();
                            this._olmAccount.generate_one_time_keys(1);
                            const i = JSON.parse(this._olmAccount.one_time_keys()),
                                s = Object.values(i.curve25519)[0];
                            if (!s) return Promise.reject(new Error("No one-time-keys generated"));
                            this._olmAccount.mark_keys_as_published();
                            const r = Ci(),
                                o = {
                                    [Pr]: Ai,
                                    olm: {
                                        type: Di,
                                        data: {
                                            idKey: this._idKey,
                                            otKey: s,
                                            uuid: r
                                        }
                                    }
                                },
                                a = new _i;
                            return a.setRejectTimeout(5e3), a.catch((() => {
                                this._reqs.delete(r), n.pendingSessionUuid = void 0
                            })), this._reqs.set(r, a), this._sendMessage(o, t), n.pendingSessionUuid = r, a
                        }
                    }

                    function Li(e) {
                        try {
                            return JSON.parse(e)
                        } catch (e) {
                            return {}
                        }
                    }
                    Oi.events = ki;
                    const xi = (0, f.getLogger)("modules/e2ee/E2EEncryption.js");
                    class Fi {
                        constructor(e) {
                            this.conference = e, this._conferenceJoined = !1, this._enabled = !1, this._key = void 0, this._enabling = void 0, this._e2eeCtx = new Si, this._olmAdapter = new Oi(e), this._ratchetKey = gi()(this._ratchetKeyImpl, 5e3), this._rotateKey = gi()(this._rotateKeyImpl, 5e3), this.conference.on(U, (() => {
                                this._conferenceJoined = !0
                            })), this.conference.on(_e, this._onParticipantPropertyChanged.bind(this)), this.conference.on(Oe, this._onParticipantJoined.bind(this)), this.conference.on(Le, this._onParticipantLeft.bind(this)), this.conference.on(ae, this._onMediaSessionStarted.bind(this)), this.conference.on(Ie, (e => e.isLocal() && this._onLocalTrackAdded(e))), this.conference.rtc.on(jn().REMOTE_TRACK_ADDED, ((e, t) => this._setupReceiverE2EEForTrack(t, e))), this.conference.on(De, this._trackMuteChanged.bind(this)), this._olmAdapter.on(Oi.events.OLM_ID_KEY_READY, this._onOlmIdKeyReady.bind(this)), this._olmAdapter.on(Oi.events.PARTICIPANT_E2EE_CHANNEL_READY, this._onParticipantE2EEChannelReady.bind(this)), this._olmAdapter.on(Oi.events.PARTICIPANT_KEY_UPDATED, this._onParticipantKeyUpdated.bind(this))
                        }
                        static isSupported(e) {
                            return !(e.testing && e.testing.disableE2EE) && (Qt.supportsInsertableStreams() || e.enableEncodedTransformSupport && Qt.supportsEncodedTransform()) && Oi.isSupported()
                        }
                        isEnabled() {
                            return this._enabled
                        }
                        async setEnabled(e) {
                            if (e === this._enabled) return;
                            if (this._enabling && await this._enabling, this._enabling = new _i, this._enabled = e, e) await this._olmAdapter.initSessions();
                            else {
                                for (const e of this.conference.getParticipants()) this._e2eeCtx.cleanup(e.getId());
                                this._olmAdapter.clearAllParticipantsSessions()
                            }
                            this.conference.setLocalParticipantProperty("e2ee.enabled", e), this.conference._restartMediaSessions(), this._key = !!e && this._generateKey();
                            const t = await this._olmAdapter.updateKey(this._key);
                            this._e2eeCtx.setKey(this.conference.myUserId(), this._key, t), this._enabling.resolve()
                        }
                        _generateKey() {
                            return window.crypto.getRandomValues(new Uint8Array(32))
                        }
                        _onLocalTrackAdded(e) {
                            for (const t of this.conference._getMediaSessions()) this._setupSenderE2EEForTrack(t, e)
                        }
                        _onMediaSessionStarted(e) {
                            const t = this.conference.getLocalTracks();
                            for (const n of t) this._setupSenderE2EEForTrack(e, n)
                        }
                        _onOlmIdKeyReady(e) {
                            xi.debug(`Olm id key ready: ${e}`), this.conference.setLocalParticipantProperty("e2ee.idKey", e)
                        }
                        _onParticipantJoined() {
                            this._conferenceJoined && this._enabled && this._ratchetKey()
                        }
                        _onParticipantLeft(e) {
                            this._e2eeCtx.cleanup(e), this._enabled && this._rotateKey()
                        }
                        _onParticipantE2EEChannelReady(e) {
                            xi.debug(`E2EE channel with participant ${e} is ready`)
                        }
                        _onParticipantKeyUpdated(e, t, n) {
                            xi.debug(`Participant ${e} updated their key`), this._e2eeCtx.setKey(e, t, n)
                        }
                        async _onParticipantPropertyChanged(e, t, n, i) {
                            switch (t) {
                                case "e2ee.idKey":
                                    xi.debug(`Participant ${e.getId()} updated their id key: ${i}`);
                                    break;
                                case "e2ee.enabled":
                                    !i && this._enabled && (this._olmAdapter.clearParticipantSession(e), this._rotateKey())
                            }
                        }
                        async _ratchetKeyImpl() {
                            xi.debug("Ratchetting key");
                            const e = await async function(e) {
                                return crypto.subtle.importKey("raw", e, "HKDF", !1, ["deriveBits", "deriveKey"])
                            }(this._key), t = await async function(e) {
                                const t = new TextEncoder;
                                return crypto.subtle.deriveBits({
                                    name: "HKDF",
                                    salt: t.encode("JFrameRatchetKey"),
                                    hash: "SHA-256",
                                    info: new ArrayBuffer
                                }, e, 256)
                            }(e);
                            this._key = new Uint8Array(t);
                            const n = this._olmAdapter.updateCurrentKey(this._key);
                            this._e2eeCtx.setKey(this.conference.myUserId(), this._key, n)
                        }
                        async _rotateKeyImpl() {
                            xi.debug("Rotating key"), this._key = this._generateKey();
                            const e = await this._olmAdapter.updateKey(this._key);
                            this._e2eeCtx.setKey(this.conference.myUserId(), this._key, e)
                        }
                        _setupReceiverE2EEForTrack(e, t) {
                            if (!this._enabled) return;
                            const n = e.findReceiverForTrack(t.track);
                            n ? this._e2eeCtx.handleReceiver(n, t.getType(), t.getParticipantId()) : xi.warn(`Could not handle E2EE for ${t}: receiver not found in: ${e}`)
                        }
                        _setupSenderE2EEForTrack(e, t) {
                            if (!this._enabled) return;
                            const n = e.peerconnection,
                                i = n && n.findSenderForTrack(t.track);
                            i ? this._e2eeCtx.handleSender(i, t.getType(), t.getParticipantId()) : xi.warn(`Could not handle E2EE for ${t}: sender not found in ${n}`)
                        }
                        _trackMuteChanged(e) {
                            if (Qt.doesVideoMuteByStreamRemove() && e.isLocal() && e.isVideoTrack() && !e.isMuted())
                                for (const t of this.conference._getMediaSessions()) this._setupSenderE2EEForTrack(t, e)
                        }
                    }
                    var ji = n(6630),
                        $i = n.n(ji);
                    const Bi = ["category", "type", "lang", "name"],
                        Ji = ["category", "type", "lang"];

                    function Ui(e, t) {
                        let n = 0;
                        return Ji.some((i => 0 !== (n = e[i] > t[i] ? 1 : e[i] < t[i] && -1))), n
                    }

                    function Vi(e) {
                        const t = new Set,
                            n = new Set;
                        return $(e).find(">query>feature").each(((e, n) => t.add(n.getAttribute("var")))), $(e).find(">query>identity").each(((e, t) => n.add({
                            type: t.getAttribute("type"),
                            name: t.getAttribute("name"),
                            category: t.getAttribute("category")
                        }))), {
                            features: t,
                            identities: n
                        }
                    }
                    class Hi extends Ti {
                        constructor(e = {}, t = "http://jitsi.org/jitsimeet") {
                            if (super(), this.node = t, this.disco = e.disco, !this.disco) throw new Error("Missing strophe-plugins (disco plugin is required)!");
                            this.version = "", this.rooms = new Set, this.externalFeatures = new Set;
                            const n = e.emuc;
                            n.addListener(Hn().EMUC_ROOM_ADDED, (e => this._addChatRoom(e))), n.addListener(Hn().EMUC_ROOM_REMOVED, (e => this._removeChatRoom(e))), Object.keys(n.rooms).forEach((e => {
                                this._addChatRoom(n.rooms[e])
                            })), Xe.Strophe.addNamespace("CAPS", "http://jabber.org/protocol/caps"), this.disco.addFeature(Xe.Strophe.NS.CAPS)
                        }
                        addFeature(e, t = !1, n = !1) {
                            this.disco.addFeature(e), this._generateVersion(), n && !this.externalFeatures.has(e) && (this.externalFeatures.add(e), this.rooms.forEach((e => this._updateRoomWithExternalFeatures(e)))), t && this.submit()
                        }
                        removeFeature(e, t = !1, n = !1) {
                            this.disco.removeFeature(e), this._generateVersion(), n && this.externalFeatures.has(e) && (this.externalFeatures.delete(e), this.rooms.forEach((e => this._updateRoomWithExternalFeatures(e)))), t && this.submit()
                        }
                        submit() {
                            this.rooms.forEach((e => e.sendPresence()))
                        }
                        _updateRoomWithExternalFeatures(e) {
                            if (0 === this.externalFeatures.size) e.removeFromPresence("features");
                            else {
                                const t = [];
                                this.externalFeatures.forEach((e => {
                                    t.push({
                                        tagName: "feature",
                                        attributes: {
                                            var: e
                                        }
                                    })
                                })), e.addOrReplaceInPresence("features", {
                                    children: t
                                })
                            }
                        }
                        getFeaturesAndIdentities(e, t, n = 5e3) {
                            return this._getDiscoInfo(e, t, n)
                        }
                        _getDiscoInfo(e, t, n) {
                            return new Promise(((i, s) => this.disco.info(e, t, (e => {
                                i(Vi(e))
                            }), s, n)))
                        }
                        _addChatRoom(e) {
                            this.rooms.add(e), this._fixChatRoomPresenceMap(e), this._updateRoomWithExternalFeatures(e)
                        }
                        _removeChatRoom(e) {
                            this.rooms.delete(e)
                        }
                        _fixChatRoomPresenceMap(e) {
                            e.addOrReplaceInPresence("c", {
                                attributes: {
                                    xmlns: Xe.Strophe.NS.CAPS,
                                    hash: "sha-1",
                                    node: this.node,
                                    ver: this.version
                                }
                            })
                        }
                        _notifyVersionChanged() {
                            this.rooms.forEach((e => this._fixChatRoomPresenceMap(e)))
                        }
                        _generateVersion() {
                            this.version = function(e, t) {
                                const n = e.sort(Ui).reduce(((e, t) => `${Bi.reduce(((e,n,i)=>e+(0===i?"":"/")+(t[n]?t[n]:"")),"")}<`), ""),
                                    i = t.sort().reduce(((e, t) => `${e+t}<`), "");
                                return (0, Xe.b64_sha1)(n + i)
                            }(this.disco._identities, this.disco._features), this._notifyVersionChanged()
                        }
                    }
                    n(4620);
                    const Gi = "NETWORK_INFO_CHANGED",
                        qi = (0, f.getLogger)("modules/connectivity/NetworkInfo.js"),
                        Ki = new class extends Ti {
                            constructor() {
                                super(), this._current = {
                                    isOnline: !0
                                }
                            }
                            updateNetworkInfo({
                                isOnline: e
                            }) {
                                qi.debug("updateNetworkInfo", {
                                    isOnline: e
                                }), this._current = {
                                    isOnline: !0 === e
                                }, this.eventEmitter.emit(Gi, this._current)
                            }
                            isOnline() {
                                return !0 === this._current.isOnline
                            }
                        },
                        zi = (0, f.getLogger)("modules/xmpp/ResumeTask.js");
                    class Wi {
                        constructor(e) {
                            this._stropheConn = e, this._resumeRetryN = 0, this._retryDelay = void 0
                        }
                        get retryDelay() {
                            return this._retryDelay
                        }
                        schedule() {
                            this._cancelResume(), this._resumeRetryN += 1, this._networkOnlineListener = Ki.addEventListener(Gi, (({
                                isOnline: e
                            }) => {
                                e ? this._scheduleResume() : this._cancelResume()
                            })), Ki.isOnline() && this._scheduleResume()
                        }
                        _scheduleResume() {
                            this._resumeTimeout || (this._resumeRetryN = Math.min(3, this._resumeRetryN), this._retryDelay = function(e, t = 500, n = 2) {
                                return Math.floor(Math.random() * (1e3 * Math.pow(n, e) - t) + t)
                            }(this._resumeRetryN, 1500 * this._resumeRetryN, 3), zi.info(`Will try to resume the XMPP connection in ${this.retryDelay}ms`), this._resumeTimeout = setTimeout((() => this._resumeConnection()), this.retryDelay))
                        }
                        _cancelResume() {
                            this._resumeTimeout && (zi.info("Canceling connection resume task"), clearTimeout(this._resumeTimeout), this._resumeTimeout = void 0, this._retryDelay = void 0)
                        }
                        _resumeConnection() {
                            const {
                                streamManagement: e
                            } = this._stropheConn, t = e.getResumeToken();
                            if (!t) return;
                            zi.info("Trying to resume the XMPP connection");
                            const n = new URL(this._stropheConn.service);
                            let {
                                search: i
                            } = n;
                            const s = /(previd=)([\w-]+)/,
                                r = i.match(s);
                            r && -1 === r.indexOf(t) ? i = i.replace(s, `$1${t}`) : r || (i += -1 === i.indexOf("?") ? `?previd=${t}` : `&previd=${t}`), n.search = i, this._stropheConn.service = n.toString(), e.resume()
                        }
                        cancel() {
                            this._cancelResume(), this._resumeRetryN = 0, this._networkOnlineListener && (this._networkOnlineListener(), this._networkOnlineListener = null)
                        }
                    }
                    class Qi {
                        constructor() {
                            this._lastSuccess = null, this._lastFailedMessage = null
                        }
                        startTracking(e, t) {
                            const n = t.rawInput;
                            t.rawInput = (...i) => {
                                const s = i[0];
                                s.includes("failure") && (this._lastFailedMessage = s), e.connected && (this._lastSuccess = Date.now()), n.apply(t, i)
                            }
                        }
                        getLastFailedMessage() {
                            return this._lastFailedMessage
                        }
                        getTimeSinceLastSuccess() {
                            return this._lastSuccess ? Date.now() - this._lastSuccess : null
                        }
                    }

                    function Xi(e = class {}) {
                        return class extends e {
                            constructor(...e) {
                                super(...e), this.connection = null
                            }
                            init(e) {
                                this.connection = e
                            }
                        }
                    }
                    const Yi = Xi(),
                        Zi = Xi(Ti),
                        es = (0, f.getLogger)("modules/xmpp/strophe.ping.js");
                    class ts extends Yi {
                        constructor({
                            getTimeSinceLastServerResponse: e,
                            onPingThresholdExceeded: t,
                            pingOptions: n = {}
                        }) {
                            super(), this.failedPings = 0, this._onPingThresholdExceeded = t, this._getTimeSinceLastServerResponse = e, this.pingInterval = "number" == typeof n.interval ? n.interval : 1e4, this.pingTimeout = "number" == typeof n.timeout ? n.timeout : 5e3, this.pingThreshold = "number" == typeof n.threshold ? n.threshold : 2, this.pingTimestampsToKeep = Math.round(12e4 / this.pingInterval), this.pingExecIntervals = new Array(this.pingTimestampsToKeep)
                        }
                        init(e) {
                            super.init(e), Xe.Strophe.addNamespace("PING", "urn:xmpp:ping")
                        }
                        ping(e, t, n, i) {
                            this._addPingExecutionTimestamp();
                            const s = (0, Xe.$iq)({
                                type: "get",
                                to: e
                            });
                            s.c("ping", {
                                xmlns: Xe.Strophe.NS.PING
                            }), this.connection.sendIQ2(s, {
                                timeout: i
                            }).then(t, n)
                        }
                        startInterval(e) {
                            clearInterval(this.intervalId), this.intervalId = window.setInterval((() => {
                                const t = Date.now();
                                if (this._getTimeSinceLastServerResponse() < t - this._lastServerCheck) return this._addPingExecutionTimestamp(), this._lastServerCheck = t, void(this.failedPings = 0);
                                this.ping(e, (() => {
                                    this._lastServerCheck = this._getTimeSinceLastServerResponse() + Date.now(), this.failedPings = 0
                                }), (e => {
                                    this.failedPings += 1;
                                    const t = "Ping " + (e ? "error" : "timeout");
                                    this.failedPings >= this.pingThreshold ? (sn().callErrorHandler(new Error(t)), es.error(t, e), this._onPingThresholdExceeded && this._onPingThresholdExceeded()) : es.warn(t, e)
                                }), this.pingTimeout)
                            }), this.pingInterval), es.info(`XMPP pings will be sent every ${this.pingInterval} ms`)
                        }
                        stopInterval() {
                            this.intervalId && (window.clearInterval(this.intervalId), this.intervalId = null, this.failedPings = 0, es.info("Ping interval cleared"))
                        }
                        _addPingExecutionTimestamp() {
                            this.pingExecIntervals.push((new Date).getTime()), this.pingExecIntervals.length > this.pingTimestampsToKeep && this.pingExecIntervals.shift()
                        }
                        getPingSuspendTime() {
                            const e = this.pingExecIntervals.slice();
                            e.push((new Date).getTime());
                            let t = 0,
                                n = e[0];
                            return e.forEach((e => {
                                const i = e - n;
                                i > t && (t = i), n = e
                            })), t -= this.pingInterval, Math.max(t, 0)
                        }
                    }
                    const ns = (0, f.getLogger)("modules/xmpp/XmppConnection.js");
                    class is extends Ti {
                        static get Events() {
                            return {
                                CONN_STATUS_CHANGED: "CONN_STATUS_CHANGED",
                                CONN_SHARD_CHANGED: "CONN_SHARD_CHANGED"
                            }
                        }
                        static get Status() {
                            return Xe.Strophe.Status
                        }
                        constructor({
                            enableWebsocketResume: e,
                            websocketKeepAlive: t,
                            websocketKeepAliveUrl: n,
                            serviceUrl: i,
                            shard: s,
                            xmppPing: r
                        }) {
                            super(), this._options = {
                                enableWebsocketResume: void 0 === e || e,
                                pingOptions: r,
                                shard: s,
                                websocketKeepAlive: void 0 === t ? 6e4 : Number(t),
                                websocketKeepAliveUrl: n // BAO
                            }, this.$msg = Xe.$msg, this.$pres = Xe.$pres, this.$iq = Xe.$iq, this.Strophe = Xe.Strophe, this._stropheConn = new Xe.Strophe.Connection(i), this._usesWebsocket = i.startsWith("ws:") || i.startsWith("wss:"), this._stropheConn.maxRetries = 3, this._rawInputTracker = new Qi, this._rawInputTracker.startTracking(this, this._stropheConn), this._resumeTask = new Wi(this._stropheConn), this._deferredIQs = [], this.addConnectionPlugin("ping", new ts({
                                getTimeSinceLastServerResponse: () => this.getTimeSinceLastSuccess(),
                                onPingThresholdExceeded: () => this._onPingErrorThresholdExceeded(),
                                pingOptions: r
                            })), this._oneSuccessfulConnect = !1
                        }
                        get connected() {
                            const e = this._stropheConn && this._stropheConn._proto && this._stropheConn._proto.socket;
                            return (this._status === Xe.Strophe.Status.CONNECTED || this._status === Xe.Strophe.Status.ATTACHED) && (!this.isUsingWebSocket || e && e.readyState === WebSocket.OPEN)
                        }
                        get disco() {
                            return this._stropheConn.disco
                        }
                        get disconnecting() {
                            return !0 === this._stropheConn.disconnecting
                        }
                        get domain() {
                            return this._stropheConn.domain
                        }
                        get isUsingWebSocket() {
                            return this._usesWebsocket
                        }
                        get jid() {
                            return this._stropheConn.jid
                        }
                        get lastResponseHeaders() {
                            return this._stropheConn._proto && this._stropheConn._proto.lastResponseHeaders
                        }
                        get logger() {
                            return this._stropheConn.logger
                        }
                        get options() {
                            return this._stropheConn.options
                        }
                        get pingDomain() {
                            var e;
                            return (null === (e = this._options.pingOptions) || void 0 === e ? void 0 : e.domain) || this.domain
                        }
                        get service() {
                            return this._stropheConn.service
                        }
                        set shard(e) {
                            this._options.shard = e, this._oneSuccessfulConnect && this._maybeStartWSKeepAlive()
                        }
                        get status() {
                            return this._status
                        }
                        addConnectionPlugin(e, t) {
                            this[e] = t, t.init(this)
                        }
                        addHandler(...e) {
                            this._stropheConn.addHandler(...e)
                        }
                        attach(e, t, n, i, ...s) {
                            this._stropheConn.attach(e, t, n, this._stropheConnectionCb.bind(this, i), ...s)
                        }
                        connect(e, t, n, ...i) {
                            this._stropheConn.connect(e, t, this._stropheConnectionCb.bind(this, n), ...i)
                        }
                        _stropheConnectionCb(e, t, ...n) {
                            this._status = t;
                            let i = !1;
                            var s;
                            t === Xe.Strophe.Status.CONNECTED || t === Xe.Strophe.Status.ATTACHED ? (this._maybeEnableStreamResume(), this._usesWebsocket && this._oneSuccessfulConnect && this._keepAliveAndCheckShard(), this._oneSuccessfulConnect = !0, this._maybeStartWSKeepAlive(), this._processDeferredIQs(), this._resumeTask.cancel(), this.ping.startInterval((null === (s = this._options.pingOptions) || void 0 === s ? void 0 : s.domain) || this.domain)) : t === Xe.Strophe.Status.DISCONNECTED && (this.ping.stopInterval(), i = this._tryResumingConnection(), i || clearTimeout(this._wsKeepAlive)), i || (e(t, ...n), this.eventEmitter.emit(is.Events.CONN_STATUS_CHANGED, t))
                        }
                        _clearDeferredIQs() {
                            for (const e of this._deferredIQs) e.reject(new Error("disconnect"));
                            this._deferredIQs = []
                        }
                        closeWebsocket() {
                            this._stropheConn && this._stropheConn._proto && (this._stropheConn._proto._closeSocket(), this._stropheConn._proto._onClose(null))
                        }
                        disconnect(...e) {
                            this._resumeTask.cancel(), clearTimeout(this._wsKeepAlive), this._clearDeferredIQs(), this._stropheConn.disconnect(...e)
                        }
                        flush(...e) {
                            this._stropheConn.flush(...e)
                        }
                        getTimeSinceLastSuccess() {
                            return this._rawInputTracker.getTimeSinceLastSuccess()
                        }
                        getLastFailedMessage() {
                            return this._rawInputTracker.getLastFailedMessage()
                        }
                        _maybeEnableStreamResume() {
                            if (!this._options.enableWebsocketResume) return;
                            const {
                                streamManagement: e
                            } = this._stropheConn;
                            this.isUsingWebSocket ? e ? e.isSupported() ? e.getResumeToken() || (ns.info("Enabling XEP-0198 stream management"), e.enable(!0)) : ns.warn("Stream resume enabled, but XEP-0198 is not supported by the server") : ns.warn("Stream resume enabled, but Strophe streamManagement plugin is not installed") : ns.warn("Stream resume enabled, but WebSockets are not enabled")
                        }
                        _maybeStartWSKeepAlive() {
                            const {
                                websocketKeepAlive: e
                            } = this._options;
                            if (this._usesWebsocket && e > 0) {
                                this._wsKeepAlive || ns.info(`WebSocket keep alive interval: ${e}ms`), clearTimeout(this._wsKeepAlive);
                                const t = e + 60 * Math.random() * 1e3;
                                ns.debug(`Scheduling next WebSocket keep-alive in ${t}ms`), this._wsKeepAlive = setTimeout((() => this._keepAliveAndCheckShard().then((() => this._maybeStartWSKeepAlive()))), t)
                            }
                        }
                        _keepAliveAndCheckShard() {
                            const {
                                shard: e,
                                websocketKeepAliveUrl: t
                            } = this._options, n = t || this.service.replace("wss://", "https://").replace("ws://", "http://");
                            return fetch(n).then((t => {
                                if (!e) return;
                                const n = t.headers.get("x-jitsi-shard");
                                n !== e && (ns.error(`Detected that shard changed from ${e} to ${n}`), this.eventEmitter.emit(is.Events.CONN_SHARD_CHANGED))
                            })).catch((e => {
                                ns.error(`Websocket Keep alive failed for url: ${n}`, {
                                    error: e
                                })
                            }))
                        }
                        _processDeferredIQs() {
                            for (const e of this._deferredIQs)
                                if (e.iq) {
                                    clearTimeout(e.timeout);
                                    const t = Date.now() - e.start;
                                    this.sendIQ(e.iq, (t => e.resolve(t)), (t => e.reject(t)), t)
                                } this._deferredIQs = []
                        }
                        send(e) {
                            if (!this.connected) throw new Error("Not connected");
                            this._stropheConn.send(e)
                        }
                        sendIQ(e, t, n, i) {
                            if (this.connected) return this._stropheConn.sendIQ(e, t, n, i);
                            n("Not connected")
                        }
                        sendIQ2(e, {
                            timeout: t
                        }) {
                            return new Promise(((n, i) => {
                                if (this.connected) this.sendIQ(e, (e => n(e)), (e => i(e)), t);
                                else {
                                    const s = {
                                        iq: e,
                                        resolve: n,
                                        reject: i,
                                        start: Date.now(),
                                        timeout: setTimeout((() => {
                                            s.iq = void 0, i(void 0)
                                        }), t)
                                    };
                                    this._deferredIQs.push(s)
                                }
                            }))
                        }
                        _onPingErrorThresholdExceeded() {
                            this.isUsingWebSocket && (ns.warn("Ping error threshold exceeded - killing the WebSocket"), this.closeWebsocket())
                        }
                        sendPresence(e, t, n, i) {
                            this.connected ? this._stropheConn.sendPresence(e, t, n, i) : n("Not connected")
                        }
                        sendUnavailableBeacon() {
                            if (!navigator.sendBeacon || this._stropheConn.disconnecting || !this._stropheConn.connected) return !1;
                            this._stropheConn._changeConnectStatus(Xe.Strophe.Status.DISCONNECTING), this._stropheConn.disconnecting = !0;
                            const e = this._stropheConn._proto._buildBody().attrs({
                                    type: "terminate"
                                }),
                                t = (0, Xe.$pres)({
                                    xmlns: Xe.Strophe.NS.CLIENT,
                                    type: "unavailable"
                                });
                            e.cnode(t.tree());
                            const n = navigator.sendBeacon(-1 === this.service.indexOf("https://") ? `https:${this.service}` : this.service, Xe.Strophe.serialize(e.tree()));
                            return ns.info(`Successfully send unavailable beacon ${n}`), this._stropheConn._proto._abortAllRequests(), this._stropheConn._doDisconnect(), !0
                        }
                        _tryResumingConnection() {
                            const {
                                streamManagement: e
                            } = this._stropheConn;
                            return !(!e || !e.getResumeToken() || (this._resumeTask.schedule(), 0))
                        }
                    }
                    const ss = "on",
                        rs = "off",
                        os = (0, f.getLogger)("modules/xmpp/AVModeration.js");
                    class as {
                        constructor(e) {
                            this._xmpp = e.xmpp, this._mainRoom = e, this._moderationEnabledByType = {
                                [En]: !1,
                                [Cn]: !1
                            }, this._whitelistAudio = [], this._whitelistVideo = [], this._xmpp.addListener(Hn().AV_MODERATION_RECEIVED, this._onMessage.bind(this))
                        }
                        isSupported() {
                            return Boolean(this._xmpp.avModerationComponentAddress)
                        }
                        enable(e, t) {
                            if (!this.isSupported() || !this._mainRoom.isModerator()) return void os.error(`Cannot enable:${e} AV moderation supported:${this.isSupported()}, \n                moderator:${this._mainRoom.isModerator()}`);
                            if (e === this._moderationEnabledByType[t]) return void os.warn(`Moderation already in state:${e} for mediaType:${t}`);
                            const n = (0, Xe.$msg)({
                                to: this._xmpp.avModerationComponentAddress
                            });
                            n.c("av_moderation", {
                                enable: e,
                                mediaType: t
                            }).up(), this._xmpp.connection.send(n)
                        }
                        approve(e, t) {
                            if (!this.isSupported() || !this._mainRoom.isModerator()) return void os.error(`Cannot approve in AV moderation supported:${this.isSupported()}, \n                moderator:${this._mainRoom.isModerator()}`);
                            const n = (0, Xe.$msg)({
                                to: this._xmpp.avModerationComponentAddress
                            });
                            n.c("av_moderation", {
                                mediaType: e,
                                jidToWhitelist: t
                            }).up(), this._xmpp.connection.send(n)
                        }
                        reject(e, t) {
                            if (!this.isSupported() || !this._mainRoom.isModerator()) return void os.error(`Cannot reject in AV moderation supported:${this.isSupported()},\n                moderator:${this._mainRoom.isModerator()}`);
                            const n = (0, Xe.$msg)({
                                to: this._xmpp.avModerationComponentAddress
                            });
                            n.c("av_moderation", {
                                mediaType: e,
                                jidToBlacklist: t
                            }).up(), this._xmpp.connection.send(n)
                        }
                        _onMessage(e) {
                            const {
                                removed: t,
                                mediaType: n,
                                enabled: i,
                                approved: s,
                                actor: r,
                                whitelists: o
                            } = e;
                            if (o) {
                                const e = n === En ? this._whitelistAudio : this._whitelistVideo,
                                    i = Array.isArray(o[n]) ? o[n] : [];
                                t ? e.filter((e => !i.includes(e))).forEach((e => this._xmpp.eventEmitter.emit(Hn().AV_MODERATION_PARTICIPANT_REJECTED, n, e))) : i.filter((t => !e.includes(t))).forEach((e => this._xmpp.eventEmitter.emit(Hn().AV_MODERATION_PARTICIPANT_APPROVED, n, e))), n === En ? this._whitelistAudio = i : this._whitelistVideo = i
                            } else if (void 0 !== i && this._moderationEnabledByType[n] !== i) this._moderationEnabledByType[n] = i, this._xmpp.eventEmitter.emit(Hn().AV_MODERATION_CHANGED, i, n, r);
                            else if (s) {
                                const e = t ? Hn().AV_MODERATION_REJECTED : Hn().AV_MODERATION_APPROVED;
                                this._xmpp.eventEmitter.emit(e, n)
                            }
                        }
                    }
                    const cs = (0, f.getLogger)("modules/xmpp/Lobby.js"),
                        ds = "email";
                    class ls {
                        constructor(e) {
                            this.xmpp = e.xmpp, this.mainRoom = e;
                            const t = this._maybeJoinLobbyRoom.bind(this);
                            this.mainRoom.addEventListener(Hn().LOCAL_ROLE_CHANGED, t), this.mainRoom.addEventListener(Hn().MUC_MEMBERS_ONLY_CHANGED, t), this.mainRoom.addEventListener(Hn().ROOM_CONNECT_MEMBERS_ONLY_ERROR, (e => {
                                this.lobbyRoomJid = e
                            }))
                        }
                        isSupported() {
                            return this.xmpp.lobbySupported
                        }
                        enable() {
                            return this.isSupported() ? new Promise(((e, t) => {
                                this.mainRoom.setMembersOnly(!0, e, t)
                            })) : Promise.reject(new Error("Lobby not supported!"))
                        }
                        disable() {
                            this.isSupported() && this.mainRoom.isModerator() && this.lobbyRoom && this.mainRoom.membersOnlyEnabled && this.mainRoom.setMembersOnly(!1)
                        }
                        _leaveLobbyRoom() {
                            this.lobbyRoom && this.lobbyRoom.leave().then((() => {
                                this.lobbyRoom = void 0, cs.info("Lobby room left!")
                            })).catch((() => {}))
                        }
                        setLobbyRoomJid(e) {
                            this.lobbyRoomJid = e
                        }
                        _maybeJoinLobbyRoom() {
                            this.isSupported() && this.mainRoom.joined && this.mainRoom.isModerator() && this.mainRoom.membersOnlyEnabled && !this.lobbyRoom && this.join().then((() => cs.info("Joined lobby room"))).catch((e => cs.error("Failed joining lobby", e)))
                        }
                        join(e, t) {
                            const n = this.mainRoom.joined && this.mainRoom.isModerator();
                            if (!this.lobbyRoomJid) return Promise.reject(new Error("Missing lobbyRoomJid, cannot join lobby room."));
                            const i = Xe.Strophe.getNodeFromJid(this.lobbyRoomJid),
                                s = Xe.Strophe.getDomainFromJid(this.lobbyRoomJid);
                            return this.lobbyRoom = this.xmpp.createRoom(i, {
                                customDomain: s,
                                disableDiscoInfo: !0,
                                disableFocus: !0,
                                enableLobby: !1
                            }), e && this.lobbyRoom.addOrReplaceInPresence("nick", {
                                attributes: {
                                    xmlns: "http://jabber.org/protocol/nick"
                                },
                                value: e
                            }), n ? (this.lobbyRoom.addPresenceListener(ds, ((e, t) => {
                                this.mainRoom.eventEmitter.emit(Hn().MUC_LOBBY_MEMBER_UPDATED, t, {
                                    email: e.value
                                })
                            })), this.lobbyRoom.addEventListener(Hn().MUC_MEMBER_JOINED, ((e, t, n, i, s, r, o, a, c) => {
                                Object.values(this.mainRoom.members).find((e => e.jid === c)) || this.mainRoom.eventEmitter.emit(Hn().MUC_LOBBY_MEMBER_JOINED, Xe.Strophe.getResourceFromJid(e), t, o ? o.avatar : void 0)
                            })), this.lobbyRoom.addEventListener(Hn().MUC_MEMBER_LEFT, (e => {
                                this.mainRoom.eventEmitter.emit(Hn().MUC_LOBBY_MEMBER_LEFT, Xe.Strophe.getResourceFromJid(e))
                            })), this.lobbyRoom.addEventListener(Hn().MUC_DESTROYED, (() => {
                                Object.keys(this.lobbyRoom.members).forEach((e => this.mainRoom.eventEmitter.emit(Hn().MUC_LOBBY_MEMBER_LEFT, Xe.Strophe.getResourceFromJid(e)))), this.lobbyRoom.clean(), this.lobbyRoom = void 0, cs.info("Lobby room left(destroyed)!")
                            }))) : (this.lobbyRoom.addEventListener(Hn().KICKED, (e => {
                                /* if (e) BAO */return this.mainRoom.eventEmitter.emit(Hn().MUC_DENIED_ACCESS), void this.lobbyRoom.clean()
                            })), this.mainRoom.addEventListener(Hn().INVITE_MESSAGE_RECEIVED, ((e, t, n, i) => {
                                cs.debug(`Received approval to join ${e} ${t} ${n}`), e === this.mainRoom.roomjid && (this.mainRoom.join(i), this._leaveLobbyRoom())
                            })), this.lobbyRoom.addEventListener(Hn().MUC_DESTROYED, ((e, t) => {
                                t ? this.mainRoom.join() : (this.lobbyRoom.clean(), this.mainRoom.eventEmitter.emit(Hn().MUC_DESTROYED, e))
                            })), this.mainRoom.addEventListener(Hn().MUC_JOINED, (() => {
                                this._leaveLobbyRoom()
                            }))), new Promise(((e, i) => {
                                this.lobbyRoom.addEventListener(Hn().MUC_JOINED, (() => {
                                    e(), t && !n && this.lobbyRoom.addOrReplaceInPresence(ds, {
                                        value: t
                                    }) && this.lobbyRoom.sendPresence()
                                })), this.lobbyRoom.addEventListener(Hn().ROOM_JOIN_ERROR, i), this.lobbyRoom.addEventListener(Hn().ROOM_CONNECT_NOT_ALLOWED_ERROR, i), this.lobbyRoom.addEventListener(Hn().ROOM_CONNECT_ERROR, i), this.lobbyRoom.join()
                            }))
                        }
                        denyAccess(e) {
                            if (!this.isSupported() || !this.mainRoom.isModerator()) return;
                            const t = Object.keys(this.lobbyRoom.members).find((t => Xe.Strophe.getResourceFromJid(t) === e));
                            t ? this.lobbyRoom.kick(t) : cs.error(`Not found member for ${e} in lobby room.`)
                        }
                        approveAccess(e) {
                            if (!this.isSupported() || !this.mainRoom.isModerator()) return;
                            const t = Object.keys(this.lobbyRoom.members).find((t => Xe.Strophe.getResourceFromJid(t) === e));
                            if (t) {
                                const e = this.lobbyRoom.members[t].jid,
                                    n = (0, Xe.$msg)({
                                        to: this.mainRoom.roomjid
                                    }).c("x", {
                                        xmlns: "http://jabber.org/protocol/muc#user"
                                    }).c("invite", {
                                        to: e
                                    });
                                this.xmpp.connection.sendIQ(n, (() => {}), (t => {
                                    cs.error(`Error sending invite for ${e}`, t)
                                }))
                            } else cs.error(`Not found member for ${t} in lobby room.`)
                        }
                    }
                    var hs = n(9307),
                        us = n.n(hs);
                    const ps = (0, f.getLogger)("modules/settings/Settings.js");
                    let ms, fs;
                    const gs = {
                        _storage: zt,
                        init(e) {
                            this._storage = e || zt
                        },
                        get callStatsUserName() {
                            return ms || (ms = this._storage.getItem("callStatsUserName"), ms || (ms = function() {
                                const e = us().generateUsername();
                                return ps.log("generated callstats uid", e), e
                            }(), this._storage.setItem("callStatsUserName", ms))), ms
                        },
                        get machineId() {
                            if (!fs) {
                                const e = this._storage.getItem("billingId");
                                fs = e || this._storage.getItem("jitsiMeetId"), e ? this._storage.setItem("jitsiMeetId", e) : fs || (fs = function() {
                                    const e = _s() + _s() + _s() + _s();
                                    return ps.log("generated id", e), e
                                }(), this._storage.setItem("jitsiMeetId", fs))
                            }
                            return fs
                        },
                        get sessionId() {
                            return this._storage.getItem("sessionId")
                        },
                        set sessionId(e) {
                            e ? this._storage.setItem("sessionId", e) : this._storage.removeItem("sessionId")
                        }
                    };

                    function _s() {
                        return `${Math.random().toString(16)}000000000`.substr(2, 8)
                    }
                    const vs = n(702),
                        ys = n(3786),
                        Ss = n(7024),
                        Es = (0, f.getLogger)("modules/xmpp/moderator.js");

                    function bs(e) {
                        let t = 1;
                        return function(n) {
                            if (n) return void(t = 1);
                            const i = Math.pow(2, t - 1);
                            return t += 1, i * e
                        }
                    }

                    function Cs(e, t, n, i) {
                        function s(e) {
                            if (e.data && e.data.sessionId) {
                                if (e.origin !== window.location.origin) return void Es.warn(`Ignoring sessionId from different origin: ${e.origin}`);
                                gs.sessionId = e.data.sessionId
                            }
                        }
                        this.roomName = e, this.xmppService = t, this.getNextTimeout = bs(1e3), this.getNextErrorTimeout = bs(1e3), this.externalAuthEnabled = !1, this.options = i, this.sipGatewayEnabled = !1, this.eventEmitter = n, this.connection = this.xmppService.connection, window.addEventListener ? window.addEventListener("message", s, !1) : window.attachEvent("onmessage", s)
                    }
                    Cs.prototype.isExternalAuthEnabled = function() {
                        return this.externalAuthEnabled
                    }, Cs.prototype.isSipGatewayEnabled = function() {
                        return this.sipGatewayEnabled
                    }, Cs.prototype.onMucMemberLeft = function(e) {
                        "focus" === Xe.Strophe.getResourceFromJid(e) && (Es.info("Focus has left the room - leaving conference"), this.eventEmitter.emit(ys.FOCUS_LEFT))
                    }, Cs.prototype.setFocusUserJid = function(e) {
                        this.focusUserJid || (this.focusUserJid = e, Es.info(`Focus jid set to:  ${this.focusUserJid}`))
                    }, Cs.prototype.getFocusUserJid = function() {
                        return this.focusUserJid
                    }, Cs.prototype.getFocusComponent = function() {
                        let e = this.options.connection.hosts.focus;
                        return e || (e = `focus.${this.options.connection.hosts.domain}`), e
                    }, Cs.prototype.createConferenceIq = function() {
                        const e = (0, Xe.$iq)({
                                to: this.getFocusComponent(),
                                type: "set"
                            }),
                            {
                                sessionId: t
                            } = gs,
                            n = gs.machineId,
                            i = this.options.conference;
                        return Es.info(`Session ID: ${t} machine UID: ${n}`), e.c("conference", {
                            xmlns: "http://jitsi.org/protocol/focus",
                            room: this.roomName,
                            "machine-uid": n
                        }), t && e.attrs({
                            "session-id": t
                        }), e.c("property", {
                            name: "disableRtx",
                            value: Boolean(i.disableRtx)
                        }).up(), void 0 !== i.audioPacketDelay && e.c("property", {
                            name: "audioPacketDelay",
                            value: i.audioPacketDelay
                        }).up(), i.startBitrate && e.c("property", {
                            name: "startBitrate",
                            value: i.startBitrate
                        }).up(), i.minBitrate && e.c("property", {
                            name: "minBitrate",
                            value: i.minBitrate
                        }).up(), void 0 !== this.options.conference.startAudioMuted && e.c("property", {
                            name: "startAudioMuted",
                            value: this.options.conference.startAudioMuted
                        }).up(), void 0 !== this.options.conference.startVideoMuted && e.c("property", {
                            name: "startVideoMuted",
                            value: this.options.conference.startVideoMuted
                        }).up(), e.up(), e
                    }, Cs.prototype.parseSessionId = function(e) {
                        const t = $(e).find("conference").attr("session-id");
                        t && (Es.info(`Received sessionId:  ${t}`), gs.sessionId = t)
                    }, Cs.prototype.parseConfigOptions = function(e) {
                        this.setFocusUserJid($(e).find("conference").attr("focusjid"));
                        const t = $(e).find(">conference>property[name='authentication'][value='true']").length > 0;
                        Es.info(`Authentication enabled: ${t}`), this.externalAuthEnabled = $(e).find(">conference>property[name='externalAuth'][value='true']").length > 0, Es.info(`External authentication enabled: ${this.externalAuthEnabled}`), this.externalAuthEnabled || this.parseSessionId(e);
                        const n = $(e).find(">conference").attr("identity");
                        this.eventEmitter.emit(vs.IDENTITY_UPDATED, t, n), $(e).find(">conference>property[name='sipGatewayEnabled'][value='true']").length && (this.sipGatewayEnabled = !0), Es.info(`Sip gateway enabled:  ${this.sipGatewayEnabled}`)
                    }, Cs.prototype.allocateConferenceFocus = function() {
                        return new Promise((e => {
                            this.setFocusUserJid(this.options.connection.focusUserJid), this.connection.sendIQ(this.createConferenceIq(), (t => this._allocateConferenceFocusSuccess(t, e)), (t => this._allocateConferenceFocusError(t, e))), this.connection.flush()
                        }))
                    }, Cs.prototype._allocateConferenceFocusError = function(e, t) {
                        const n = $(e).find(">error>session-invalid").length || $(e).find(">error>not-acceptable").length;
                        if (n && (Es.info("Session expired! - removing"), gs.sessionId = void 0), $(e).find(">error>graceful-shutdown").length) return void this.eventEmitter.emit(ys.GRACEFUL_SHUTDOWN);
                        const i = $(e).find(">error>reservation-error");
                        if (i.length) {
                            const t = i.attr("error-code"),
                                n = $(e).find(">error>text");
                            let s;
                            return n && (s = n.text()), void this.eventEmitter.emit(ys.RESERVATION_ERROR, t, s)
                        }
                        if ($(e).find(">error>not-authorized").length) return Es.warn("Unauthorized to start the conference", e), Xe.Strophe.getDomainFromJid(e.getAttribute("to")) !== this.options.connection.hosts.anonymousdomain && (this.externalAuthEnabled = !0), void this.eventEmitter.emit(ys.AUTHENTICATION_REQUIRED);
                        const s = this.getNextErrorTimeout(),
                            r = `Focus error, retry after ${s}`;
                        Ss.callErrorHandler(new Error(r)), Es.error(r, e);
                        const o = this.getFocusComponent(),
                            a = s / 1e3;
                        n || this.eventEmitter.emit(ys.FOCUS_DISCONNECTED, o, a), this.getNextTimeout(!0), window.setTimeout((() => this.allocateConferenceFocus().then(t)), s)
                    }, Cs.prototype._allocateConferenceFocusSuccess = function(e, t) {
                        if (this.parseConfigOptions(e), this.getNextErrorTimeout(!0), "true" === $(e).find("conference").attr("ready")) this.getNextTimeout(!0), t();
                        else {
                            const e = this.getNextTimeout();
                            Es.info(`Waiting for the focus... ${e}`), window.setTimeout((() => this.allocateConferenceFocus().then(t)), e)
                        }
                    }, Cs.prototype.authenticate = function() {
                        return new Promise(((e, t) => {
                            this.connection.sendIQ(this.createConferenceIq(), (t => {
                                this.parseSessionId(t), e()
                            }), (e => t({
                                error: $(e).find("iq>error :first").prop("tagName"),
                                message: $(e).find("iq>error>text").text()
                            })))
                        }))
                    }, Cs.prototype.getLoginUrl = function(e, t) {
                        this._getLoginUrl(!1, e, t)
                    }, Cs.prototype._getLoginUrl = function(e, t, n) {
                        const i = (0, Xe.$iq)({
                                to: this.getFocusComponent(),
                                type: "get"
                            }),
                            s = {
                                xmlns: "http://jitsi.org/protocol/focus",
                                room: this.roomName,
                                "machine-uid": gs.machineId
                            };
                        let r = "auth url";

                        function o(e, t) {
                            Ss.callErrorHandler(new Error(e)), Es.error(e, t), n(t)
                        }
                        e && (s.popup = !0, r = `POPUP ${r}`), i.c("login-url", s), this.connection.sendIQ(i, (e => {
                            let n = $(e).find("login-url").attr("url");
                            n = decodeURIComponent(n), n ? (Es.info(`Got ${r}: ${n}`), t(n)) : o(`Failed to get ${r} from the focus`, e)
                        }), o.bind(void 0, `Get ${r} error`))
                    }, Cs.prototype.getPopupLoginUrl = function(e, t) {
                        this._getLoginUrl(!0, e, t)
                    }, Cs.prototype.logout = function(e) {
                        const t = (0, Xe.$iq)({
                                to: this.getFocusComponent(),
                                type: "set"
                            }),
                            {
                                sessionId: n
                            } = gs;
                        n ? (t.c("logout", {
                            xmlns: "http://jitsi.org/protocol/focus",
                            "session-id": n
                        }), this.connection.sendIQ(t, (t => {
                            let n = $(t).find("logout").attr("logout-url");
                            n && (n = decodeURIComponent(n)), Es.info(`Log out OK, url: ${n}`, t), gs.sessionId = void 0, e(n)
                        }), (e => {
                            const t = "Logout error";
                            Ss.callErrorHandler(new Error(t)), Es.error(t, e)
                        }))) : e()
                    };
                    const Ts = (0, f.getLogger)("modules/xmpp/ChatRoom.js"),
                        Rs = {
                            packet2JSON(e, t) {
                                for (const n of Array.from(e.children)) {
                                    const e = {
                                        attributes: {},
                                        children: [],
                                        tagName: n.tagName
                                    };
                                    for (const t of Array.from(n.attributes)) e.attributes[t.name] = t.value;
                                    const i = Xe.Strophe.getText(n);
                                    i && (e.value = Xe.Strophe.xmlunescape(i)), t.push(e), this.packet2JSON(n, e.children)
                                }
                            },
                            json2packet(e, t) {
                                for (let n = 0; n < e.length; n++) {
                                    const i = e[n];
                                    i && (t.c(i.tagName, i.attributes), i.value && t.t(i.value), i.children && this.json2packet(i.children, t), t.up())
                                }
                            }
                        };

                    function As(e, t) {
                        const n = [];
                        for (let i = 0; i < e.length; i++) e[i].tagName === t && n.push(e[i]);
                        return n
                    }
                    const ws = ["owner", "admin", "member"];
                    class Ps extends Ti {
                        constructor(e, t, n, i, s) {
                            super(), this.xmpp = i, this.connection = e, this.roomjid = Xe.Strophe.getBareJidFromJid(t), this.myroomjid = t, this.password = n, this.replaceParticipant = !1, Ts.info(`Joined MUC as ${this.myroomjid}`), this.members = {}, this.presMap = {}, this.presHandlers = {}, this._removeConnListeners = [], this.joined = !1, this.role = null, this.focusMucJid = null, this.noBridgeAvailable = !1, this.options = s || {}, this.moderator = new Cs(this.roomjid, this.xmpp, this.eventEmitter, {
                                connection: this.xmpp.options,
                                conference: this.options
                            }), (void 0 === this.options.enableLobby || this.options.enableLobby) && (this.lobby = new ls(this)), this.avModeration = new as(this), this.initPresenceMap(s), this.lastPresences = {}, this.phoneNumber = null, this.phonePin = null, this.connectionTimes = {}, this.participantPropertyListener = null, this.locked = !1, this.transcriptionStatus = rs
                        }
                        initPresenceMap(e = {}) {
                            this.presMap.to = this.myroomjid, this.presMap.xns = "http://jabber.org/protocol/muc", this.presMap.nodes = [], e.statsId && this.presMap.nodes.push({
                                tagName: "stats-id",
                                value: e.statsId
                            }), e.deploymentInfo && e.deploymentInfo.userRegion && this.presMap.nodes.push({
                                tagName: "region",
                                attributes: {
                                    id: e.deploymentInfo.userRegion,
                                    xmlns: "http://jitsi.org/jitsi-meet"
                                }
                            }), this.presenceUpdateTime = Date.now()
                        }
                        join(e, t) {
                            return this.password = e, this.replaceParticipant = t, new Promise((e => {
                                this.options.disableFocus && Ts.info(`Conference focus disabled for ${this.roomjid}`), (this.options.disableFocus ? Promise.resolve() : this.moderator.allocateConferenceFocus()).then((() => {
                                    this.sendPresence(!0), this._removeConnListeners.push(this.connection.addEventListener(is.Events.CONN_STATUS_CHANGED, this.onConnStatusChanged.bind(this))), e()
                                }))
                            }))
                        }
                        sendPresence(e) {
                            const t = this.presMap.to;
                            if (!this.connection || !this.connection.connected || !t || !this.joined && !e) return;
                            const n = (0, Xe.$pres)({
                                to: t
                            });
                            e && (this.replaceParticipant && n.c("flip_device").up(), n.c("x", {
                                xmlns: this.presMap.xns
                            }), this.password && n.c("password").t(this.password).up(), this.options.billingId && n.c("billingid").t(this.options.billingId).up(), n.up()), Rs.json2packet(this.presMap.nodes, n), this.presenceSyncTime = Date.now(), this.connection.send(n), e && this.connection.flush()
                        }
                        doLeave() {
                            Ts.log("do leave", this.myroomjid);
                            const e = (0, Xe.$pres)({
                                to: this.myroomjid,
                                type: "unavailable"
                            });
                            this.presMap.length = 0, !this.connection.isUsingWebSocket && this.connection.flush(), this.connection.send(e), this.connection.flush()
                        }
                        discoRoomInfo() {
                            const e = (0, Xe.$iq)({
                                type: "get",
                                to: this.roomjid
                            }).c("query", {
                                xmlns: Xe.Strophe.NS.DISCO_INFO
                            });
                            this.connection.sendIQ(e, (e => {
                                const t = 1 === $(e).find('>query>feature[var="muc_passwordprotected"]').length;
                                t !== this.locked && (this.eventEmitter.emit(Hn().MUC_LOCK_CHANGED, t), this.locked = t);
                                const n = $(e).find('>query>x[type="result"]>field[var="muc#roominfo_meetingId"]>value');
                                n.length ? this.setMeetingId(n.text()) : Ts.warn("No meeting ID from backend");
                                const i = 1 === $(e).find('>query>feature[var="muc_membersonly"]').length,
                                    s = $(e).find('>query>x[type="result"]>field[var="muc#roominfo_lobbyroom"]>value');
                                this.lobby && this.lobby.setLobbyRoomJid(s && s.length ? s.text() : void 0), i !== this.membersOnlyEnabled && (this.membersOnlyEnabled = i, this.eventEmitter.emit(Hn().MUC_MEMBERS_ONLY_CHANGED, i))
                            }), (e => {
                                sn().callErrorHandler(e), Ts.error("Error getting room info: ", e)
                            }))
                        }
                        setMeetingId(e) {
                            this.meetingId !== e && (this.meetingId && Ts.warn(`Meeting Id changed from:${this.meetingId} to:${e}`), this.meetingId = e, this.eventEmitter.emit(Hn().MEETING_ID_SET, e))
                        }
                        createNonAnonymousRoom() {
                            if (this.options.disableDiscoInfo) return;
                            const e = (0, Xe.$iq)({
                                type: "get",
                                to: this.roomjid
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#owner"
                            }).c("x", {
                                xmlns: "jabber:x:data",
                                type: "submit"
                            });
                            this.connection.sendIQ(e, (e => {
                                if (!$(e).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_whois"]').length) {
                                    const e = "non-anonymous rooms not supported";
                                    return sn().callErrorHandler(new Error(e)), void Ts.error(e)
                                }
                                const t = (0, Xe.$iq)({
                                    to: this.roomjid,
                                    type: "set"
                                }).c("query", {
                                    xmlns: "http://jabber.org/protocol/muc#owner"
                                });
                                t.c("x", {
                                    xmlns: "jabber:x:data",
                                    type: "submit"
                                }), t.c("field", {
                                    var: "FORM_TYPE"
                                }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), t.c("field", {
                                    var: "muc#roomconfig_whois"
                                }).c("value").t("anyone").up().up(), this.connection.sendIQ(t)
                            }), (e => {
                                sn().callErrorHandler(e), Ts.error("Error getting room configuration form: ", e)
                            }))
                        }
                        onConnStatusChanged(e) {
                            e === is.Status.CONNECTED && this.sendPresence()
                        }
                        onPresence(e) {
                            const t = e.getAttribute("from"),
                                n = {},
                                i = e.getElementsByTagName("status")[0];
                            i && (n.status = i.textContent || "");
                            let s = !1,
                                r = !1;
                            const o = e.getElementsByTagNameNS("http://jabber.org/protocol/muc#user", "x")[0],
                                a = o && o.getElementsByTagName("item")[0];
                            n.isReplaceParticipant = e.getElementsByTagName("flip_device").length, n.affiliation = a && a.getAttribute("affiliation"), n.role = a && a.getAttribute("role");
                            const c = a && a.getAttribute("jid");
                            n.jid = c, n.isFocus = c && 0 === c.indexOf(`${this.moderator.getFocusUserJid()}/`), n.isHiddenDomain = c && c.indexOf("@") > 0 && this.options.hiddenDomain === c.substring(c.indexOf("@") + 1, c.indexOf("/")), this.eventEmitter.emit(Hn().PRESENCE_RECEIVED, {
                                fromHiddenDomain: n.isHiddenDomain,
                                presence: e
                            });
                            const d = e.querySelector("x");
                            d && d.remove();
                            const l = [];
                            Rs.packet2JSON(e, l), this.lastPresences[t] = l;
                            const h = e => {
                                const t = {},
                                    n = e.children.find((e => "user" === e.tagName));
                                if (n) {
                                    t.user = {};
                                    for (const e of ["id", "name", "avatar"]) {
                                        const i = n.children.find((t => t.tagName === e));
                                        i && (t.user[e] = i.value)
                                    }
                                }
                                const i = e.children.find((e => "group" === e.tagName));
                                return i && (t.group = i.value), t
                            };
                            for (let e = 0; e < l.length; e++) {
                                const t = l[e];
                                switch (t.tagName) {
                                    case "bot": {
                                        const {
                                            attributes: e
                                        } = t;
                                        if (!e) break;
                                        const {
                                            type: i
                                        } = e;
                                        n.botType = i;
                                        break
                                    }
                                    case "nick":
                                        n.nick = t.value;
                                        break;
                                    case "userId":
                                        n.id = t.value;
                                        break;
                                    case "stats-id":
                                        n.statsID = t.value;
                                        break;
                                    case "identity":
                                        n.identity = h(t);
                                        break;
                                    case "features":
                                        n.features = this._extractFeatures(t);
                                        break;
                                    case "stat": {
                                        const {
                                            attributes: e
                                        } = t;
                                        if (!e) break;
                                        const {
                                            name: i
                                        } = e;
                                        "version" === i && (n.version = e.value);
                                        break
                                    }
                                }
                            }
                            if (t === this.myroomjid) {
                                const e = "owner" === n.affiliation ? n.role : "none";
                                if (this.role !== e && (this.role = e, this.eventEmitter.emit(Hn().LOCAL_ROLE_CHANGED, this.role)), !this.joined) {
                                    this.joined = !0;
                                    const e = this.connectionTimes["muc.joined"] = window.performance.now();
                                    Ts.log("(TIME) MUC joined:\t", e), this.password && (this.locked = !0), this.presenceUpdateTime >= this.presenceSyncTime && this.sendPresence(), this.eventEmitter.emit(Hn().MUC_JOINED), !this.options.disableDiscoInfo && this.discoRoomInfo()
                                }
                            } else if (void 0 === c) Ts.info("Ignoring member with undefined JID");
                            else if (void 0 === this.members[t]) this.members[t] = n, Ts.log("entered", t, n), s = void 0 !== n.status, r = void 0 !== n.version, n.isFocus ? this._initFocus(t, n.features) : (this.eventEmitter.emit(Hn().MUC_MEMBER_JOINED, t, n.nick, n.role, n.isHiddenDomain, n.statsID, n.status, n.identity, n.botType, n.jid, n.features, n.isReplaceParticipant), s = !1);
                            else {
                                const e = this.members[t];
                                e.role !== n.role && (e.role = n.role, this.eventEmitter.emit(Hn().MUC_ROLE_CHANGED, t, n.role)), e.affiliation !== n.affiliation && (e.affiliation = n.affiliation), e.botType !== n.botType && (e.botType = n.botType, this.eventEmitter.emit(Hn().MUC_MEMBER_BOT_TYPE_CHANGED, t, n.botType)), n.isFocus && (e.isFocus = !0, this._initFocus(t, n.features)), n.displayName && (e.displayName = n.displayName), e.status !== n.status && (s = !0, e.status = n.status), e.version !== n.version && (r = !0, e.version = n.version), Qe()(e.features, n.features) || (e.features = n.features, this.eventEmitter.emit(Hn().PARTICIPANT_FEATURES_CHANGED, t, n.features))
                            }
                            for (let e = 0; e < l.length; e++) {
                                const i = l[e];
                                switch (i.tagName) {
                                    case "nick":
                                        if (!n.isFocus) {
                                            const e = this.xmpp.options.displayJids ? Xe.Strophe.getResourceFromJid(t) : n.nick;
                                            this.eventEmitter.emit(Hn().DISPLAY_NAME_CHANGED, t, e)
                                        }
                                        break;
                                    case "bridgeNotAvailable":
                                        n.isFocus && !this.noBridgeAvailable && (this.noBridgeAvailable = !0, this.eventEmitter.emit(Hn().BRIDGE_DOWN));
                                        break;
                                    case "conference-properties":
                                        if (n.isFocus) {
                                            const e = {};
                                            for (let t = 0; t < i.children.length; t++) {
                                                const {
                                                    attributes: n
                                                } = i.children[t];
                                                n && n.key && (e[n.key] = n.value)
                                            }
                                            this.eventEmitter.emit(Hn().CONFERENCE_PROPERTIES_CHANGED, e), this.restartByTerminateSupported = "true" === e["support-terminate-restart"], Ts.info(`Jicofo supports restart by terminate: ${this.supportsRestartByTerminate()}`)
                                        }
                                        break;
                                    case "transcription-status": {
                                        const {
                                            attributes: e
                                        } = i;
                                        if (!e) break;
                                        const {
                                            status: t
                                        } = e;
                                        t && t !== this.transcriptionStatus && (this.transcriptionStatus = t, this.eventEmitter.emit(Hn().TRANSCRIPTION_STATUS_CHANGED, t));
                                        break
                                    }
                                    case "call-control": {
                                        const e = i.attributes;
                                        if (!e) break;
                                        this.phoneNumber = e.phone || null, this.phonePin = e.pin || null, this.eventEmitter.emit(Hn().PHONE_NUMBER_CHANGED);
                                        break
                                    }
                                    default:
                                        this.processNode(i, t)
                                }
                            }
                            s && this.eventEmitter.emit(Hn().PRESENCE_STATUS, t, n.status), r && Ts.info(`Received version for ${c}: ${n.version}`)
                        }
                        _extractFeatures(e) {
                            const t = new Set;
                            for (let n = 0; n < e.children.length; n++) {
                                const {
                                    attributes: i
                                } = e.children[n];
                                i && i.var && t.add(i.var)
                            }
                            return t
                        }
                        _initFocus(e, t) {
                            this.focusMucJid = e, this.focusFeatures = t
                        }
                        setParticipantPropertyListener(e) {
                            this.participantPropertyListener = e
                        }
                        supportsRestartByTerminate() {
                            return this.restartByTerminateSupported
                        }
                        processNode(e, t) {
                            try {
                                let n = this.presHandlers[e.tagName];
                                e.tagName.startsWith("jitsi_participant_") && (n = [this.participantPropertyListener]), n && n.forEach((n => {
                                    n(e, Xe.Strophe.getResourceFromJid(t), t)
                                }))
                            } catch (t) {
                                sn().callErrorHandler(t), Ts.error(`Error processing:${e.tagName} node.`, t)
                            }
                        }
                        sendMessage(e, t) {
                            const n = (0, Xe.$msg)({
                                to: this.roomjid,
                                type: "groupchat"
                            });
                            "body" === t ? n.c(t, {}, e) : n.c(t, {
                                xmlns: "http://jitsi.org/jitmeet"
                            }, e), this.connection.send(n), this.eventEmitter.emit(Hn().SENDING_CHAT_MESSAGE, e)
                        }
                        sendPrivateMessage(e, t, n) {
                            const i = (0, Xe.$msg)({
                                to: `${this.roomjid}/${e}`,
                                type: "chat"
                            });
                            "body" === n ? i.c(n, t).up() : i.c(n, {
                                xmlns: "http://jitsi.org/jitmeet"
                            }, t).up(), this.connection.send(i), this.eventEmitter.emit(Hn().SENDING_PRIVATE_CHAT_MESSAGE, t)
                        }
                        setSubject(e) {
                            const t = (0, Xe.$msg)({
                                to: this.roomjid,
                                type: "groupchat"
                            });
                            t.c("subject", e), this.connection.send(t)
                        }
                        onParticipantLeft(e, t) {
                            delete this.lastPresences[e], t || (this.eventEmitter.emit(Hn().MUC_MEMBER_LEFT, e), this.moderator.onMucMemberLeft(e))
                        }
                        onPresenceUnavailable(e, t) {
                            if ($(e).find('>ignore[xmlns="http://jitsi.org/jitmeet/"]').length) return !0;
                            const n = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy');
                            if (n.length) {
                                let t;
                                const i = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>destroy>reason');
                                return i.length && (t = i.text()), this.eventEmitter.emit(Hn().MUC_DESTROYED, t, n.attr("jid")), this.connection.emuc.doLeave(this.roomjid), !0
                            }
                            const i = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="110"]').length,
                                s = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="307"]').length,
                                r = Object.keys(this.members),
                                o = $(e).find("flip_device").length;
                            if (s) {
                                const n = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>actor');
                                let s, r;
                                n.length && (s = n.attr("nick"));
                                const a = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>item>reason');
                                a.length && (r = a.text()), this.eventEmitter.emit(Hn().KICKED, i, s, Xe.Strophe.getResourceFromJid(t), r, o)
                            }
                            i ? (r.forEach((e => {
                                const t = this.members[e];
                                delete this.members[e], this.onParticipantLeft(e, t.isFocus)
                            })), this.connection.emuc.doLeave(this.roomjid), s || this.eventEmitter.emit(Hn().MUC_LEFT)) : (delete this.members[t], this.onParticipantLeft(t, !1))
                        }
                        onMessage(e, t) {
                            const n = e.getAttribute("type");
                            if ("error" === n) {
                                const t = $(e).find(">error>text").text();
                                return this.eventEmitter.emit(Hn().CHAT_ERROR_RECEIVED, t), !0
                            }
                            const i = $(e).find(">body").text(),
                                s = $(e).find(">subject");
                            if (s.length) {
                                const e = s.text();
                                (e || "" === e) && (this.eventEmitter.emit(Hn().SUBJECT_CHANGED, e), Ts.log(`Subject is changed to ${e}`))
                            }
                            let r = $(e).find(">delay").attr("stamp");
                            if (!r && (r = $(e).find('>[xmlns="jabber:x:delay"]').attr("stamp"), r)) {
                                const e = r.match(/(\d{4})(\d{2})(\d{2}T\d{2}:\d{2}:\d{2})/);
                                r = `${e[1]}-${e[2]}-${e[3]}Z`
                            }
                            if (t === this.roomjid) {
                                let n;
                                if ($(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="104"]').length) this.discoRoomInfo();
                                else if ((n = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>invite')) && n.length) {
                                    const s = $(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>password');
                                    let r;
                                    s && s.length && (r = s.text()), this.eventEmitter.emit(Hn().INVITE_MESSAGE_RECEIVED, t, n.attr("from"), i, r)
                                }
                            }
                            const o = $(e).find(">json-message").text();
                            if (o) {
                                const e = this.xmpp.tryParseJSONAndVerify(o);
                                if (e && void 0 === r) return void this.eventEmitter.emit(Hn().JSON_MESSAGE_RECEIVED, t, e)
                            }
                            i && ("chat" === n ? this.eventEmitter.emit(Hn().PRIVATE_MESSAGE_RECEIVED, t, i, this.myroomjid, r) : "groupchat" === n && this.eventEmitter.emit(Hn().MESSAGE_RECEIVED, t, i, this.myroomjid, r))
                        }
                        onPresenceError(e, t) {
                            if ($(e).find('>error[type="auth"]>not-authorized[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) Ts.log("on password required", t), this.eventEmitter.emit(Hn().PASSWORD_REQUIRED);
                            else if ($(e).find('>error[type="cancel"]>not-allowed[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) Xe.Strophe.getDomainFromJid(e.getAttribute("to")) === this.xmpp.options.hosts.anonymousdomain ? this.eventEmitter.emit(Hn().ROOM_JOIN_ERROR) : (Ts.warn("onPresError ", e), this.eventEmitter.emit(Hn().ROOM_CONNECT_NOT_ALLOWED_ERROR));
                            else if ($(e).find(">error>service-unavailable").length) Ts.warn("Maximum users limit for the room has been reached", e), this.eventEmitter.emit(Hn().ROOM_MAX_USERS_ERROR);
                            else if ($(e).find('>error[type="auth"]>registration-required[xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"]').length) {
                                const t = $(e).find(">lobbyroom");
                                let n;
                                t.length && (n = t.text()), this.eventEmitter.emit(Hn().ROOM_CONNECT_MEMBERS_ONLY_ERROR, n)
                            } else Ts.warn("onPresError ", e), this.eventEmitter.emit(Hn().ROOM_CONNECT_ERROR)
                        }
                        setAffiliation(e, t) {
                            const n = (0, Xe.$iq)({
                                to: this.roomjid,
                                type: "set"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#admin"
                            }).c("item", {
                                affiliation: t,
                                nick: Xe.Strophe.getResourceFromJid(e)
                            }).c("reason").t(`Your affiliation has been changed to '${t}'.`).up().up().up();
                            this.connection.sendIQ(n, (n => Ts.log("Set affiliation of participant with jid: ", e, "to", t, n)), (e => Ts.log("Set affiliation of participant error: ", e)))
                        }
                        kick(e, t = "You have been kicked.") {
                            const n = (0, Xe.$iq)({
                                to: this.roomjid,
                                type: "set"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#admin"
                            }).c("item", {
                                nick: Xe.Strophe.getResourceFromJid(e),
                                role: "none"
                            }).c("reason").t(t).up().up().up();
                            this.connection.sendIQ(n, (t => Ts.log("Kick participant with jid: ", e, t)), (e => Ts.log("Kick participant error: ", e)))
                        }
                        lockRoom(e, t, n, i) {
                            this.connection.sendIQ((0, Xe.$iq)({
                                to: this.roomjid,
                                type: "get"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#owner"
                            }), (s => {
                                if ($(s).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_roomsecret"]').length) {
                                    const i = (0, Xe.$iq)({
                                        to: this.roomjid,
                                        type: "set"
                                    }).c("query", {
                                        xmlns: "http://jabber.org/protocol/muc#owner"
                                    });
                                    i.c("x", {
                                        xmlns: "jabber:x:data",
                                        type: "submit"
                                    }), i.c("field", {
                                        var: "FORM_TYPE"
                                    }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), i.c("field", {
                                        var: "muc#roomconfig_roomsecret"
                                    }).c("value").t(e).up().up(), i.c("field", {
                                        var: "muc#roomconfig_passwordprotectedroom"
                                    }).c("value").t(null === e || 0 === e.length ? "0" : "1").up().up(), this.membersOnlyEnabled && i.c("field", {
                                        var: "muc#roomconfig_membersonly"
                                    }).c("value").t("true").up().up(), i.c("field", {
                                        var: "muc#roomconfig_whois"
                                    }).c("value").t("anyone").up().up(), this.connection.sendIQ(i, (() => {
                                        this.password = e, t()
                                    }), n)
                                } else i()
                            }), n)
                        }
                        setMembersOnly(e, t, n) {
                            e && Object.values(this.members).filter((e => !e.isFocus)).length && Object.values(this.members).forEach((e => {
                                e.jid && !ws.includes(e.affiliation) && this.xmpp.connection.sendIQ((0, Xe.$iq)({
                                    to: this.roomjid,
                                    type: "set"
                                }).c("query", {
                                    xmlns: "http://jabber.org/protocol/muc#admin"
                                }).c("item", {
                                    affiliation: "member",
                                    jid: e.jid
                                }).up().up())
                            }));
                            const i = n || (() => {});
                            this.xmpp.connection.sendIQ((0, Xe.$iq)({
                                to: this.roomjid,
                                type: "get"
                            }).c("query", {
                                xmlns: "http://jabber.org/protocol/muc#owner"
                            }), (n => {
                                if ($(n).find('>query>x[xmlns="jabber:x:data"]>field[var="muc#roomconfig_membersonly"]').length) {
                                    const n = (0, Xe.$iq)({
                                        to: this.roomjid,
                                        type: "set"
                                    }).c("query", {
                                        xmlns: "http://jabber.org/protocol/muc#owner"
                                    });
                                    n.c("x", {
                                        xmlns: "jabber:x:data",
                                        type: "submit"
                                    }), n.c("field", {
                                        var: "FORM_TYPE"
                                    }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up(), n.c("field", {
                                        var: "muc#roomconfig_membersonly"
                                    }).c("value").t(e ? "true" : "false").up().up(), this.locked && n.c("field", {
                                        var: "muc#roomconfig_passwordprotectedroom"
                                    }).c("value").t("1").up().up(), this.xmpp.connection.sendIQ(n, t, i)
                                } else i(new Error("Setting members only room not supported!"))
                            }), i)
                        }
                        addToPresence(e, t) {
                            return this.addOrReplaceInPresence(e, t)
                        }
                        addOrReplaceInPresence(e, t) {
                            t.tagName = e;
                            const n = this.presMap.nodes.filter((t => e === t.tagName));
                            return !(1 === n.length && Qe()(n[0], t) || (this.removeFromPresence(e), this.presMap.nodes.push(t), this.presenceUpdateTime = Date.now(), 0))
                        }
                        getFromPresence(e) {
                            return this.presMap.nodes.find((t => e === t.tagName))
                        }
                        removeFromPresence(e) {
                            const t = this.presMap.nodes.filter((t => e !== t.tagName));
                            this.presMap.nodes = t, this.presenceUpdateTime = Date.now()
                        }
                        addPresenceListener(e, t) {
                            if ("function" != typeof t) throw new Error('"handler" is not a function');
                            let n = this.presHandlers[e];
                            n || (this.presHandlers[e] = n = []), -1 === n.indexOf(t) ? n.push(t) : Ts.warn(`Trying to add the same handler more than once for: ${e}`)
                        }
                        removePresenceListener(e, t) {
                            const n = this.presHandlers[e],
                                i = n ? n.indexOf(t) : -1; - 1 !== i ? n.splice(i, 1) : Ts.warn(`Handler for: ${e} was not registered`)
                        }
                        isFocus(e) {
                            const t = this.members[e];
                            return t ? t.isFocus : null
                        }
                        isModerator() {
                            return "moderator" === this.role
                        }
                        getMemberRole(e) {
                            return this.members[e] ? this.members[e].role : null
                        }
                        setVideoMute(e) {
                            this.sendVideoInfoPresence(e)
                        }
                        setAudioMute(e) {
                            this.sendAudioInfoPresence(e)
                        }
                        addAudioInfoToPresence(e) {
                            const t = "audiomuted";
                            return !(e && !this.getFromPresence(t)) && this.addOrReplaceInPresence(t, {
                                value: e.toString()
                            })
                        }
                        sendAudioInfoPresence(e) {
                            this.addAudioInfoToPresence(e) && this.sendPresence()
                        }
                        addVideoInfoToPresence(e) {
                            const t = "videomuted";
                            return !(e && !this.getFromPresence(t)) && this.addOrReplaceInPresence(t, {
                                value: e.toString()
                            })
                        }
                        sendVideoInfoPresence(e) {
                            this.addVideoInfoToPresence(e) && this.sendPresence()
                        }
                        getMediaPresenceInfo(e, t) {
                            const n = this.lastPresences[`${this.roomjid}/${e}`];
                            if (!n) return null;
                            const i = {
                                muted: !0,
                                videoType: void 0
                            };
                            let s = null;
                            if (t === En) s = As(n, "audiomuted");
                            else {
                                if (t !== Cn) return Ts.error(`Unsupported media type: ${t}`), null; {
                                    s = As(n, "videomuted");
                                    const e = As(n, "jitsi_participant_codecType"),
                                        t = As(n, "videoType");
                                    t.length > 0 && (i.videoType = t[0].value), e.length > 0 && (i.codecType = e[0].value)
                                }
                            }
                            return s.length > 0 && (i.muted = "true" === s[0].value), i
                        }
                        isSIPCallingSupported() {
                            return !!this.moderator && this.moderator.isSipGatewayEnabled()
                        }
                        dial(e) {
                            return this.connection.rayo.dial(e, "fromnumber", Xe.Strophe.getBareJidFromJid(this.myroomjid), this.password, this.focusMucJid)
                        }
                        hangup() {
                            return this.connection.rayo.hangup()
                        }
                        getLobby() {
                            return this.lobby
                        }
                        getAVModeration() {
                            return this.avModeration
                        }
                        getPhoneNumber() {
                            return this.phoneNumber
                        }
                        getPhonePin() {
                            return this.phonePin
                        }
                        getMeetingId() {
                            return this.meetingId
                        }
                        muteParticipant(e, t, n) {
                            Ts.info("set mute", t);
                            const i = (0, Xe.$iq)({
                                to: this.focusMucJid,
                                type: "set"
                            }).c("mute", {
                                xmlns: `http://jitsi.org/jitmeet/${n}`,
                                jid: e
                            }).t(t.toString()).up();
                            this.connection.sendIQ(i, (e => Ts.log("set mute", e)), (e => Ts.log("set mute error", e)))
                        }
                        onMute(e) {
                            if (e.getAttribute("from") !== this.focusMucJid) return void Ts.warn("Ignored mute from non focus peer");
                            const t = $(e).find("mute");
                            t.length && "true" === t.text() ? this.eventEmitter.emit(Hn().AUDIO_MUTED_BY_FOCUS, t.attr("actor")) : Ts.warn("Ignoring a mute request which does not explicitly specify a positive mute command.")
                        }
                        onMuteVideo(e) {
                            if (e.getAttribute("from") !== this.focusMucJid) return void Ts.warn("Ignored mute from non focus peer");
                            const t = $(e).find("mute");
                            t.length && "true" === t.text() ? this.eventEmitter.emit(Hn().VIDEO_MUTED_BY_FOCUS, t.attr("actor")) : Ts.warn("Ignoring a mute request which does not explicitly specify a positive mute command.")
                        }
                        clean() {
                            this._removeConnListeners.forEach((e => e())), this._removeConnListeners = [], this.joined = !1
                        }
                        leave() {
                            return new Promise(((e, t) => {
                                const n = setTimeout((() => s(!0)), 5e3),
                                    i = this.eventEmitter;

                                function s(r = !1) {
                                    i.removeListener(Hn().MUC_LEFT, s), clearTimeout(n), r ? t(new Error("The timeout for the confirmation about leaving the room expired.")) : e()
                                }
                                this.clean(), i.on(Hn().MUC_LEFT, s), this.doLeave()
                            }))
                        }
                    }
                    const Is = (0, f.getLogger)("modules/xmpp/strophe.emuc.js");
                    class Ms extends Zi {
                        constructor(e) {
                            super(), this.xmpp = e, this.rooms = {}
                        }
                        init(e) {
                            super.init(e), this.connection.addHandler(this.onPresence.bind(this), null, "presence", null, null, null, null), this.connection.addHandler(this.onPresenceUnavailable.bind(this), null, "presence", "unavailable", null), this.connection.addHandler(this.onPresenceError.bind(this), null, "presence", "error", null), this.connection.addHandler(this.onMessage.bind(this), null, "message", null, null), this.connection.addHandler(this.onMute.bind(this), "http://jitsi.org/jitmeet/audio", "iq", "set", null, null), this.connection.addHandler(this.onMuteVideo.bind(this), "http://jitsi.org/jitmeet/video", "iq", "set", null, null)
                        }
                        createRoom(e, t, n) {
                            const i = Xe.Strophe.getBareJidFromJid(e);
                            if (this.isRoomCreated(i)) {
                                const e = "You are already in the room!";
                                throw Is.error(e), new Error(e)
                            }
                            return this.rooms[i] = new Ps(this.connection, e, t, this.xmpp, n), this.eventEmitter.emit(Hn().EMUC_ROOM_ADDED, this.rooms[i]), this.rooms[i]
                        }
                        isRoomCreated(e) {
                            return e in this.rooms
                        }
                        doLeave(e) {
                            this.eventEmitter.emit(Hn().EMUC_ROOM_REMOVED, this.rooms[e]), delete this.rooms[e]
                        }
                        onPresence(e) {
                            const t = e.getAttribute("from");
                            if (e.getAttribute("type")) return !0;
                            const n = this.rooms[Xe.Strophe.getBareJidFromJid(t)];
                            return !n || ($(e).find('>x[xmlns="http://jabber.org/protocol/muc#user"]>status[code="201"]').length && n.createNonAnonymousRoom(), n.onPresence(e), !0)
                        }
                        onPresenceUnavailable(e) {
                            const t = e.getAttribute("from"),
                                n = this.rooms[Xe.Strophe.getBareJidFromJid(t)];
                            return !n || (n.onPresenceUnavailable(e, t), !0)
                        }
                        onPresenceError(e) {
                            const t = e.getAttribute("from"),
                                n = this.rooms[Xe.Strophe.getBareJidFromJid(t)];
                            return !n || (n.onPresenceError(e, t), !0)
                        }
                        onMessage(e) {
                            const t = e.getAttribute("from"),
                                n = this.rooms[Xe.Strophe.getBareJidFromJid(t)];
                            return !n || (n.onMessage(e, t), !0)
                        }
                        onMute(e) {
                            const t = e.getAttribute("from"),
                                n = this.rooms[Xe.Strophe.getBareJidFromJid(t)];
                            return !n || (n.onMute(e), !0)
                        }
                        onMuteVideo(e) {
                            const t = e.getAttribute("from"),
                                n = this.rooms[Xe.Strophe.getBareJidFromJid(t)];
                            return !n || (n.onMuteVideo(e), !0)
                        }
                    }
                    const Ds = (0, f.getLogger)("FeatureFlags"),
                        Ns = new class {
                            init(e) {
                                this._sourceNameSignaling = Boolean(e.sourceNameSignaling), Ds.info(`Source name signaling: ${this._sourceNameSignaling}`)
                            }
                            isSourceNameSignalingEnabled() {
                                return this._sourceNameSignaling
                            }
                        };
                    var ks = n(1002),
                        Os = n.n(ks),
                        Ls = n(1435),
                        xs = n.n(Ls);
                    const Fs = n(7055).getLogger("modules/RTC/ScreenObtainer.js"),
                        js = {
                            obtainStream: null,
                            init(e = {}) {
                                this.options = e, this.obtainStream = this._createObtainStreamMethod(), this.obtainStream || Fs.info("Desktop sharing disabled")
                            },
                            _createObtainStreamMethod() {
                                return Qt.isNWJS() ? (e, t) => {
                                    window.JitsiMeetNW.obtainDesktopStream(e, ((e, n) => {
                                        let i;
                                        i = e && "InvalidStateError" === e.name ? new pt(ot) : new pt(e, n, ["desktop"]), "function" == typeof t && t(i)
                                    }))
                                } : Qt.isElectron() ? this.obtainScreenOnElectron : Qt.isReactNative() && Qt.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMediaRN : Qt.supportsGetDisplayMedia() ? this.obtainScreenFromGetDisplayMedia : (Fs.log("Screen sharing not supported on ", Qt.getName()), null)
                            },
                            _getAudioConstraints() {
                                const {
                                    audioQuality: e
                                } = this.options;
                                return !(null == e ? void 0 : e.stereo) || {
                                    autoGainControl: !1,
                                    channelCount: 2,
                                    echoCancellation: !1,
                                    noiseSuppression: !1
                                }
                            },
                            isSupported() {
                                return null !== this.obtainStream
                            },
                            obtainScreenOnElectron(e, t) {
                                if (window.JitsiMeetScreenObtainer && window.JitsiMeetScreenObtainer.openDesktopPicker) {
                                    const {
                                        desktopSharingFrameRate: n,
                                        desktopSharingSources: i
                                    } = this.options;
                                    window.JitsiMeetScreenObtainer.openDesktopPicker({
                                        desktopSharingSources: i || ["screen", "window"]
                                    }, ((i, s, r = !1) => {
                                        if (i) {
                                            var o, a;
                                            let c = !1;
                                            if (r) {
                                                c = {};
                                                const e = this._getAudioConstraints();
                                                "boolean" != typeof e && (c = {
                                                    optional: e
                                                }), "screen" === s && (c.mandatory = {
                                                    chromeMediaSource: "desktop"
                                                })
                                            }
                                            const d = {
                                                audio: c,
                                                video: {
                                                    mandatory: {
                                                        chromeMediaSource: "desktop",
                                                        chromeMediaSourceId: i,
                                                        minFrameRate: null !== (o = null == n ? void 0 : n.min) && void 0 !== o ? o : 5,
                                                        maxFrameRate: null !== (a = null == n ? void 0 : n.max) && void 0 !== a ? a : 5,
                                                        maxWidth: window.screen.width,
                                                        maxHeight: window.screen.height
                                                    }
                                                }
                                            };
                                            navigator.mediaDevices.getUserMedia(d).then((t => e({
                                                stream: t,
                                                sourceId: i,
                                                sourceType: s
                                            })), t)
                                        } else t(new pt(ot))
                                    }), (e => t(new pt(et, e))))
                                } else t(new pt(tt))
                            },
                            obtainScreenFromGetDisplayMedia(e, t) {
                                let n;
                                n = navigator.getDisplayMedia ? navigator.getDisplayMedia.bind(navigator) : navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices);
                                const {
                                    desktopSharingFrameRate: i
                                } = this.options, s = "object" != typeof i || {
                                    frameRate: i
                                }, r = this._getAudioConstraints();
                                s.frameRate && delete s.frameRate.min;
                                const o = {
                                    video: s,
                                    audio: r,
                                    cursor: "always"
                                };
                                Fs.info("Using getDisplayMedia for screen sharing", o), n(o).then((t => {
                                    e({
                                        stream: t,
                                        sourceId: t.id
                                    })
                                })).catch((e => {
                                    const n = {
                                        errorName: e && e.name,
                                        errorMsg: e && e.message,
                                        errorStack: e && e.stack
                                    };
                                    Fs.error("getDisplayMedia error", o, n), n.errorMsg && -1 !== n.errorMsg.indexOf("denied by system") ? t(new pt(st)) : t(new pt(ot))
                                }))
                            },
                            obtainScreenFromGetDisplayMediaRN(e, t) {
                                Fs.info("Using getDisplayMedia for screen sharing"), navigator.mediaDevices.getDisplayMedia({
                                    video: !0
                                }).then((t => {
                                    e({
                                        stream: t,
                                        sourceId: t.id
                                    })
                                })).catch((() => {
                                    t(new pt(ot))
                                }))
                            },
                            setDesktopSharingFrameRate(e) {
                                Fs.info(`Setting the desktop capture rate to ${e}`), this.options.desktopSharingFrameRate = {
                                    min: 5,
                                    max: e
                                }
                            }
                        },
                        $s = (0, f.getLogger)("modules/sdp/SDPUtil.js"),
                        Bs = {
                            filterSpecialChars: e => e ? e.replace(/[\\\/\{,\}\+]/g, "") : e,
                            iceparams(e, t) {
                                let n, i, s = null;
                                return (i = Bs.findLine(e, "a=ice-ufrag:", t)) && (n = Bs.findLine(e, "a=ice-pwd:", t)) && (s = {
                                    ufrag: Bs.parseICEUfrag(i),
                                    pwd: Bs.parseICEPwd(n)
                                }), s
                            },
                            parseICEUfrag: e => e.substring(12),
                            buildICEUfrag: e => `a=ice-ufrag:${e}`,
                            parseICEPwd: e => e.substring(10),
                            buildICEPwd: e => `a=ice-pwd:${e}`,
                            parseMID: e => e.substring(6),
                            parseMSIDAttribute(e) {
                                const t = e.find((e => e.indexOf(" msid:") > 0));
                                if (!t) return;
                                const n = t.substring(t.indexOf(" msid:") + 6);
                                return Bs.filterSpecialChars(n)
                            },
                            parseMLine(e) {
                                const t = {},
                                    n = e.substring(2).split(" ");
                                return t.media = n.shift(), t.port = n.shift(), t.proto = n.shift(), "" === n[n.length - 1] && n.pop(), t.fmt = n, t
                            },
                            buildMLine: e => `m=${e.media} ${e.port} ${e.proto} ${e.fmt.join(" ")}`,
                            parseRTPMap(e) {
                                const t = {};
                                let n = e.substring(9).split(" ");
                                return t.id = n.shift(), n = n[0].split("/"), t.name = n.shift(), t.clockrate = n.shift(), t.channels = n.length ? n.shift() : "1", t
                            },
                            parseSCTPMap(e) {
                                const t = e.substring(10).split(" ");
                                return [t[0], t[1], t.length > 2 ? t[2] : null]
                            },
                            buildRTPMap(e) {
                                let t = `a=rtpmap:${e.getAttribute("id")} ${e.getAttribute("name")}/${e.getAttribute("clockrate")}`;
                                return e.getAttribute("channels") && "1" !== e.getAttribute("channels") && (t += `/${e.getAttribute("channels")}`), t
                            },
                            parseCrypto(e) {
                                const t = {},
                                    n = e.substring(9).split(" ");
                                return t.tag = n.shift(), t["crypto-suite"] = n.shift(), t["key-params"] = n.shift(), n.length && (t["session-params"] = n.join(" ")), t
                            },
                            parseFingerprint(e) {
                                const t = {},
                                    n = e.substring(14).split(" ");
                                return t.hash = n.shift(), t.fingerprint = n.shift(), t
                            },
                            parseFmtp(e) {
                                const t = [];
                                let n = e.split(" ");
                                n.shift(), n = n.join(" ").split(";");
                                for (let e = 0; e < n.length; e++) {
                                    let i = n[e].split("=")[0];
                                    for (; i.length && " " === i[0];) i = i.substring(1);
                                    const s = n[e].split("=")[1];
                                    i && s ? t.push({
                                        name: i,
                                        value: s
                                    }) : i && t.push({
                                        name: "",
                                        value: i
                                    })
                                }
                                return t
                            },
                            parseICECandidate(e) {
                                const t = {},
                                    n = e.split(" ");
                                t.foundation = n[0].substring(12), t.component = n[1], t.protocol = n[2].toLowerCase(), t.priority = n[3], t.ip = n[4], t.port = n[5], t.type = n[7], t.generation = 0;
                                for (let e = 8; e < n.length; e += 2) switch (n[e]) {
                                    case "raddr":
                                        t["rel-addr"] = n[e + 1];
                                        break;
                                    case "rport":
                                        t["rel-port"] = n[e + 1];
                                        break;
                                    case "generation":
                                        t.generation = n[e + 1];
                                        break;
                                    case "tcptype":
                                        t.tcptype = n[e + 1];
                                        break;
                                    default:
                                        $s.debug(`parseICECandidate not translating "${n[e]}" = "${n[e+1]}"`)
                                }
                                return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
                            },
                            buildICECandidate(e) {
                                let t = [`a=candidate:${e.foundation}`, e.component, e.protocol, e.priority, e.ip, e.port, "typ", e.type].join(" ");
                                switch (t += " ", e.type) {
                                    case "srflx":
                                    case "prflx":
                                    case "relay":
                                        e.hasOwnAttribute("rel-addr") && e.hasOwnAttribute("rel-port") && (t += "raddr", t += " ", t += e["rel-addr"], t += " ", t += "rport", t += " ", t += e["rel-port"], t += " ")
                                }
                                return e.hasOwnAttribute("tcptype") && (t += "tcptype", t += " ", t += e.tcptype, t += " "), t += "generation", t += " ", t += e.hasOwnAttribute("generation") ? e.generation : "0", t
                            },
                            parseSSRC(e) {
                                const t = new Map,
                                    n = e.split("\r\n");
                                for (let e = 0; e < n.length; e++)
                                    if ("a=ssrc:" === n[e].substring(0, 7)) {
                                        const i = n[e].split("a=ssrc:")[1].split(" ")[0];
                                        t.get(i) || t.set(i, []), t.get(i).push(n[e])
                                    } return t
                            },
                            parseSourceNameLine(e) {
                                const t = e.find((e => e.indexOf(" name:") > 0));
                                return null == t ? void 0 : t.substring(t.indexOf(" name:") + 6)
                            },
                            parseRTCPFB(e) {
                                const t = e.substr(10).split(" "),
                                    n = {};
                                return n.pt = t.shift(), n.type = t.shift(), n.params = t, n
                            },
                            parseExtmap(e) {
                                const t = e.substr(9).split(" "),
                                    n = {};
                                return n.value = t.shift(), -1 === n.value.indexOf("/") ? n.direction = "both" : (n.direction = n.value.substr(n.value.indexOf("/") + 1), n.value = n.value.substr(0, n.value.indexOf("/"))), n.uri = t.shift(), n.params = t, n
                            },
                            findLine(e, t, n) {
                                let i = e.split("\r\n");
                                for (let e = 0; e < i.length; e++)
                                    if (i[e].substring(0, t.length) === t) return i[e];
                                if (!n) return !1;
                                i = n.split("\r\n");
                                for (let e = 0; e < i.length; e++)
                                    if (i[e].substring(0, t.length) === t) return i[e];
                                return !1
                            },
                            findLines(e, t, n) {
                                let i = e.split("\r\n");
                                const s = [];
                                for (let e = 0; e < i.length; e++) i[e].substring(0, t.length) === t && s.push(i[e]);
                                if (s.length || !n) return s;
                                i = n.split("\r\n");
                                for (let e = 0; e < i.length; e++) i[e].substring(0, t.length) === t && s.push(i[e]);
                                return s
                            },
                            candidateToJingle(e) {
                                if (0 === e.indexOf("candidate:")) e = `a=${e}`;
                                else if ("a=candidate:" !== e.substring(0, 12)) return $s.warn("parseCandidate called with a line that is not a candidate line"), $s.warn(e), null;
                                "\r\n" === e.substring(e.length - 2) && (e = e.substring(0, e.length - 2));
                                const t = {},
                                    n = e.split(" ");
                                if ("typ" !== n[6]) return $s.warn("did not find typ in the right place"), $s.warn(e), null;
                                t.foundation = n[0].substring(12), t.component = n[1], t.protocol = n[2].toLowerCase(), t.priority = n[3], t.ip = n[4], t.port = n[5], t.type = n[7], t.generation = "0";
                                for (let e = 8; e < n.length; e += 2) switch (n[e]) {
                                    case "raddr":
                                        t["rel-addr"] = n[e + 1];
                                        break;
                                    case "rport":
                                        t["rel-port"] = n[e + 1];
                                        break;
                                    case "generation":
                                        t.generation = n[e + 1];
                                        break;
                                    case "tcptype":
                                        t.tcptype = n[e + 1];
                                        break;
                                    default:
                                        $s.debug(`not translating "${n[e]}" = "${n[e+1]}"`)
                                }
                                return t.network = "1", t.id = Math.random().toString(36).substr(2, 10), t
                            },
                            candidateFromJingle(e) {
                                let t = "a=candidate:";
                                t += e.getAttribute("foundation"), t += " ", t += e.getAttribute("component"), t += " ";
                                let n = e.getAttribute("protocol");
                                switch (Qt.isFirefox() && "ssltcp" === n.toLowerCase() && (n = "tcp"), t += n, t += " ", t += e.getAttribute("priority"), t += " ", t += e.getAttribute("ip"), t += " ", t += e.getAttribute("port"), t += " ", t += "typ", t += ` ${e.getAttribute("type")}`, t += " ", e.getAttribute("type")) {
                                    case "srflx":
                                    case "prflx":
                                    case "relay":
                                        e.getAttribute("rel-addr") && e.getAttribute("rel-port") && (t += "raddr", t += " ", t += e.getAttribute("rel-addr"), t += " ", t += "rport", t += " ", t += e.getAttribute("rel-port"), t += " ")
                                }
                                return "tcp" === n.toLowerCase() && (t += "tcptype", t += " ", t += e.getAttribute("tcptype"), t += " "), t += "generation", t += " ", t += e.getAttribute("generation") || "0", `${t}\r\n`
                            },
                            parsePrimaryVideoSsrc(e) {
                                const t = e.ssrcs.map((e => e.id)).filter(((e, t, n) => n.indexOf(e) === t)).length,
                                    n = e.ssrcGroups && e.ssrcGroups.length || 0;
                                if (t > 1 && 0 === n) return;
                                let i = null;
                                if (1 === t) i = e.ssrcs[0].id;
                                else if (2 === t) {
                                    const t = e.ssrcGroups.find((e => "FID" === e.semantics));
                                    t && (i = t.ssrcs.split(" ")[0])
                                } else if (t >= 3) {
                                    const t = e.ssrcGroups.find((e => "SIM" === e.semantics));
                                    t && (i = t.ssrcs.split(" ")[0])
                                }
                                return i
                            },
                            generateSsrc: () => $i().randomInt(1, 4294967295),
                            getSsrcAttribute(e, t, n) {
                                for (let i = 0; i < e.ssrcs.length; ++i) {
                                    const s = e.ssrcs[i];
                                    if (s.id === t && s.attribute === n) return s.value
                                }
                            },
                            parseGroupSsrcs: e => e.ssrcs.split(" ").map((e => parseInt(e, 10))),
                            getMedia: (e, t) => e.media.find((e => e.type === t)),
                            getUfrag(e) {
                                const t = e.split("\n").filter((e => e.startsWith("a=ice-ufrag:")));
                                if (t.length > 0) return t[0].substr("a=ice-ufrag:".length)
                            },
                            preferCodec(e, t) {
                                if (!e || !t) return;
                                const n = e.rtp.filter((e => e.codec && e.codec.toLowerCase() === t.toLowerCase())).map((e => e.payload));
                                if (n) {
                                    const t = e.payloads.toString().split(" ").map((e => parseInt(e, 10)));
                                    for (const e of n.reverse()) {
                                        const n = t.indexOf(e);
                                        t.splice(n, 1), t.unshift(e)
                                    }
                                    e.payloads = t.join(" ")
                                }
                            },
                            stripCodec(e, t, n = !1) {
                                if (!e || !t) return;
                                const i = [];
                                let s = [];
                                const r = t.toLowerCase() === Os().H264 && n;
                                for (const n of e.rtp) n.codec && n.codec.toLowerCase() === t.toLowerCase() && (r ? i.push(n.payload) : s.push(n.payload));
                                if (r && (s = e.fmtp.filter((e => i.indexOf(e.payload) > -1 && e.config.includes("profile-level-id=64"))).map((e => e.payload))), s.length > 0) {
                                    const t = s.map((e => `apt=${e}`)),
                                        n = e.fmtp.filter((e => -1 !== t.indexOf(e.config)));
                                    s.push(...n.map((e => e.payload)));
                                    const i = e.payloads.toString().split(" ").map(Number).filter((e => -1 === s.indexOf(e)));
                                    0 === i.length ? (e.port = 0, e.direction = xs().INACTIVE, e.payloads = "*") : e.payloads = i.join(" "), e.rtp = e.rtp.filter((e => -1 !== i.indexOf(e.payload))), e.fmtp = e.fmtp.filter((e => -1 !== i.indexOf(e.payload))), e.rtcpFb && (e.rtcpFb = e.rtcpFb.filter((e => -1 !== i.indexOf(e.payload))))
                                }
                            }
                        },
                        Js = Bs;

                    function Us(e) {
                        const t = e.split("\r\nm=");
                        for (let e = 1, n = t.length; e < n; e++) {
                            let i = `m=${t[e]}`;
                            e !== n - 1 && (i += "\r\n"), t[e] = i
                        }
                        const n = `${t.shift()}\r\n`;
                        this.media = t, this.raw = n + t.join(""), this.session = n
                    }

                    function Vs(e, t) {
                        if (!t) return !1;
                        if (e.length !== t.length) return !1;
                        for (let n = 0, i = e.length; n < i; n++)
                            if (e[n] instanceof Array && t[n] instanceof Array) {
                                if (!e[n].equals(t[n])) return !1
                            } else if (e[n] !== t[n]) return !1;
                        return !0
                    }

                    function Hs(e, t) {
                        if (this.mySDP = e, this.otherSDP = t, !e) throw new Error('"mySDP" is undefined!');
                        if (!t) throw new Error('"otherSDP" is undefined!')
                    }
                    Us.prototype.failICE = !1, Us.prototype.removeTcpCandidates = !1, Us.prototype.removeUdpCandidates = !1, Us.prototype.getMediaSsrcMap = function() {
                        const e = {};
                        for (let t = 0; t < this.media.length; t++) {
                            const n = {
                                mediaindex: t,
                                mid: Js.parseMID(Js.findLine(this.media[t], "a=mid:")),
                                ssrcs: {},
                                ssrcGroups: []
                            };
                            e[t] = n, Js.findLines(this.media[t], "a=ssrc:").forEach((e => {
                                const t = e.substring(7).split(" ")[0];
                                n.ssrcs[t] || (n.ssrcs[t] = {
                                    ssrc: t,
                                    lines: []
                                }), n.ssrcs[t].lines.push(e)
                            })), Js.findLines(this.media[t], "a=ssrc-group:").forEach((e => {
                                const t = e.indexOf(" "),
                                    i = e.substr(0, t).substr(13),
                                    s = e.substr(14 + i.length).split(" ");
                                s.length && n.ssrcGroups.push({
                                    semantics: i,
                                    ssrcs: s
                                })
                            }))
                        }
                        return e
                    }, Us.prototype.containsSSRC = function(e) {
                        const t = this.getMediaSsrcMap();
                        let n = !1;
                        return Object.keys(t).forEach((i => {
                            n || t[i].ssrcs[e] && (n = !0)
                        })), n
                    }, Us.prototype.toJingle = function(e, t) {
                        Js.findLines(this.session, "a=group:").forEach((t => {
                            const n = t.split(" "),
                                i = n.shift().substr(8);
                            e.c("group", {
                                xmlns: "urn:xmpp:jingle:apps:grouping:0",
                                semantics: i
                            });
                            for (let t = 0; t < n.length; t++) e.c("content", {
                                name: n[t]
                            }).up();
                            e.up()
                        }));
                        for (let n = 0; n < this.media.length; n++) {
                            const i = Js.parseMLine(this.media[n].split("\r\n")[0]);
                            if ("audio" !== i.media && "video" !== i.media && "application" !== i.media) continue;
                            let s;
                            const r = Js.findLine(this.media[n], "a=ssrc:");
                            s = !!r && r.substring(7).split(" ")[0], e.c("content", {
                                creator: t,
                                name: i.media
                            });
                            const o = Js.findLine(this.media[n], "a=mid:");
                            if (o) {
                                const t = Js.parseMID(o);
                                e.attrs({
                                    name: t
                                })
                            }
                            if ("audio" === i.media || "video" === i.media) {
                                e.c("description", {
                                    xmlns: "urn:xmpp:jingle:apps:rtp:1",
                                    media: i.media
                                }), s && e.attrs({
                                    ssrc: s
                                });
                                for (let t = 0; t < i.fmt.length; t++) {
                                    const s = Js.findLine(this.media[n], `a=rtpmap:${i.fmt[t]}`);
                                    e.c("payload-type", Js.parseRTPMap(s));
                                    const r = Js.findLine(this.media[n], `a=fmtp:${i.fmt[t]}`);
                                    if (r) {
                                        const t = Js.parseFmtp(r);
                                        for (let n = 0; n < t.length; n++) e.c("parameter", t[n]).up()
                                    }
                                    this.rtcpFbToJingle(n, e, i.fmt[t]), e.up()
                                }
                                if (s) {
                                    const t = Js.parseSSRC(this.media[n]);
                                    for (const [n, i] of t) {
                                        const t = Js.parseSourceNameLine(i);
                                        e.c("source", {
                                            ssrc: n,
                                            name: Ns.isSourceNameSignalingEnabled() ? t : void 0,
                                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                        });
                                        const s = Js.parseMSIDAttribute(i);
                                        s && (e.c("parameter"), e.attrs({
                                            name: "msid"
                                        }), e.attrs({
                                            value: s
                                        }), e.up()), e.up()
                                    }
                                    Js.findLines(this.media[n], "a=ssrc-group:").forEach((t => {
                                        const n = t.indexOf(" "),
                                            i = t.substr(0, n).substr(13),
                                            s = t.substr(14 + i.length).split(" ");
                                        s.length && (e.c("ssrc-group", {
                                            semantics: i,
                                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                        }), s.forEach((t => e.c("source", {
                                            ssrc: t
                                        }).up())), e.up())
                                    }))
                                }
                                const t = Js.findLines(this.media[n], "a=rid:");
                                if (t.length && Qt.usesRidsForSimulcast()) {
                                    const i = t.map((e => e.split(":")[1])).map((e => e.split(" ")[0]));
                                    i.forEach((t => {
                                        e.c("source", {
                                            rid: t,
                                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                        }), e.up()
                                    })), Js.findLine(this.media[n], "a=simulcast:") && (e.c("rid-group", {
                                        semantics: "SIM",
                                        xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                    }), i.forEach((t => {
                                        e.c("source", {
                                            rid: t
                                        }).up()
                                    })), e.up())
                                }
                                Js.findLine(this.media[n], "a=rtcp-mux") && e.c("rtcp-mux").up(), this.rtcpFbToJingle(n, e, "*");
                                const r = Js.findLines(this.media[n], "a=extmap:");
                                for (let t = 0; t < r.length; t++) {
                                    const n = Js.parseExtmap(r[t]);
                                    if (e.c("rtp-hdrext", {
                                            xmlns: "urn:xmpp:jingle:apps:rtp:rtp-hdrext:0",
                                            uri: n.uri,
                                            id: n.value
                                        }), n.hasOwnProperty("direction")) switch (n.direction) {
                                        case xs().SENDONLY:
                                            e.attrs({
                                                senders: "responder"
                                            });
                                            break;
                                        case xs().RECVONLY:
                                            e.attrs({
                                                senders: "initiator"
                                            });
                                            break;
                                        case xs().SENDRECV:
                                            e.attrs({
                                                senders: "both"
                                            });
                                            break;
                                        case xs().INACTIVE:
                                            e.attrs({
                                                senders: "none"
                                            })
                                    }
                                    e.up()
                                }
                                e.up()
                            }
                            this.transportToJingle(n, e);
                            const a = this.media[n];
                            Js.findLine(a, `a=${xs().SENDRECV}`, this.session) ? e.attrs({
                                senders: "both"
                            }) : Js.findLine(a, `a=${xs().SENDONLY}`, this.session) ? e.attrs({
                                senders: "initiator"
                            }) : Js.findLine(a, `a=${xs().RECVONLY}`, this.session) ? e.attrs({
                                senders: "responder"
                            }) : Js.findLine(a, `a=${xs().INACTIVE}`, this.session) && e.attrs({
                                senders: "none"
                            }), "0" !== i.port || Js.findLine(a, "a=bundle-only", this.session) || e.attrs({
                                senders: "rejected"
                            }), e.up()
                        }
                        return e.up(), e
                    }, Us.prototype.transportToJingle = function(e, t) {
                        t.c("transport");
                        const n = Js.findLine(this.media[e], "a=sctpmap:", this.session);
                        if (n) {
                            const e = Js.parseSCTPMap(n);
                            t.c("sctpmap", {
                                xmlns: "urn:xmpp:jingle:transports:dtls-sctp:1",
                                number: e[0],
                                protocol: e[1]
                            }), e.length > 2 && t.attrs({
                                streams: e[2]
                            }), t.up()
                        }
                        Js.findLines(this.media[e], "a=fingerprint:", this.session).forEach((n => {
                            const i = Js.parseFingerprint(n);
                            i.xmlns = "urn:xmpp:jingle:apps:dtls:0", t.c("fingerprint").t(i.fingerprint), delete i.fingerprint;
                            const s = Js.findLine(this.media[e], "a=setup:", this.session);
                            s && (i.setup = s.substr(8)), t.attrs(i), t.up()
                        }));
                        const i = Js.iceparams(this.media[e], this.session);
                        i && (i.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.attrs(i), Js.findLines(this.media[e], "a=candidate:", this.session).forEach((e => {
                            const n = Js.candidateToJingle(e);
                            this.failICE && (n.ip = "1.1.1.1");
                            const i = n && "string" == typeof n.protocol ? n.protocol.toLowerCase() : "";
                            this.removeTcpCandidates && ("tcp" === i || "ssltcp" === i) || this.removeUdpCandidates && "udp" === i || t.c("candidate", n).up()
                        }))), t.up()
                    }, Us.prototype.rtcpFbToJingle = function(e, t, n) {
                        Js.findLines(this.media[e], `a=rtcp-fb:${n}`).forEach((e => {
                            const n = Js.parseRTCPFB(e);
                            "trr-int" === n.type ? (t.c("rtcp-fb-trr-int", {
                                xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
                                value: n.params[0]
                            }), t.up()) : (t.c("rtcp-fb", {
                                xmlns: "urn:xmpp:jingle:apps:rtp:rtcp-fb:0",
                                type: n.type
                            }), n.params.length > 0 && t.attrs({
                                subtype: n.params[0]
                            }), t.up())
                        }))
                    }, Us.prototype.rtcpFbFromJingle = function(e, t) {
                        let n = "";
                        const i = e.find('>rtcp-fb-trr-int[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]');
                        return i.length && (n += "a=rtcp-fb:* trr-int ", i.attr("value") ? n += i.attr("value") : n += "0", n += "\r\n"), e.find('>rtcp-fb[xmlns="urn:xmpp:jingle:apps:rtp:rtcp-fb:0"]').each(((e, i) => {
                            n += `a=rtcp-fb:${t} ${i.getAttribute("type")}`, i.hasAttribute("subtype") && (n += ` ${i.getAttribute("subtype")}`), n += "\r\n"
                        })), n
                    }, Us.prototype.fromJingle = function(e) {
                        const t = Date.now();
                        this.raw = `v=0\r\no=- ${t} 2 IN IP4 0.0.0.0\r\ns=-\r\nt=0 0\r\n`;
                        const n = $(e).find('>group[xmlns="urn:xmpp:jingle:apps:grouping:0"]');
                        n.length && n.each(((e, t) => {
                            const n = $(t).find(">content").map(((e, t) => t.getAttribute("name"))).get();
                            n.length > 0 && (this.raw += `a=group:${t.getAttribute("semantics")||t.getAttribute("type")} ${n.join(" ")}\r\n`)
                        })), this.session = this.raw, e.find(">content").each(((e, t) => {
                            const n = this.jingle2media($(t));
                            this.media.push(n)
                        })), this.raw = this.session + this.media.join("")
                    }, Us.prototype.jingle2media = function(e) {
                        const t = e.find(">description"),
                            n = e.find('>transport[xmlns="urn:xmpp:jingle:transports:ice-udp:1"]');
                        let i = "";
                        const s = n.find('>sctpmap[xmlns="urn:xmpp:jingle:transports:dtls-sctp:1"]'),
                            r = {
                                media: t.attr("media"),
                                port: "1"
                            };
                        if ("rejected" === e.attr("senders") && (r.port = "0"), n.find('>fingerprint[xmlns="urn:xmpp:jingle:apps:dtls:0"]').length ? r.proto = s.length ? "DTLS/SCTP" : "RTP/SAVPF" : r.proto = "RTP/AVPF", s.length) {
                            i += `m=application ${r.port} DTLS/SCTP ${s.attr("number")}\r\n`, i += `a=sctpmap:${s.attr("number")} ${s.attr("protocol")}`;
                            const e = s.attr("streams");
                            i += e ? ` ${e}\r\n` : "\r\n"
                        } else r.fmt = t.find(">payload-type").map(((e, t) => t.getAttribute("id"))).get(), i += `${Js.buildMLine(r)}\r\n`;
                        switch (i += "c=IN IP4 0.0.0.0\r\n", s.length || (i += "a=rtcp:1 IN IP4 0.0.0.0\r\n"), n.length && (n.attr("ufrag") && (i += `${Js.buildICEUfrag(n.attr("ufrag"))}\r\n`), n.attr("pwd") && (i += `${Js.buildICEPwd(n.attr("pwd"))}\r\n`), n.find('>fingerprint[xmlns="urn:xmpp:jingle:apps:dtls:0"]').each(((e, t) => {
                                i += `a=fingerprint:${t.getAttribute("hash")}`, i += ` ${$(t).text()}`, i += "\r\n", t.hasAttribute("setup") && (i += `a=setup:${t.getAttribute("setup")}\r\n`)
                            }))), n.find(">candidate").each(((e, t) => {
                                let n = t.getAttribute("protocol");
                                n = "string" == typeof n ? n.toLowerCase() : "", this.removeTcpCandidates && ("tcp" === n || "ssltcp" === n) || this.removeUdpCandidates && "udp" === n || (this.failICE && t.setAttribute("ip", "1.1.1.1"), i += Js.candidateFromJingle(t))
                            })), e.attr("senders")) {
                            case "initiator":
                                i += `a=${xs().SENDONLY}\r\n`;
                                break;
                            case "responder":
                                i += `a=${xs().RECVONLY}\r\n`;
                                break;
                            case "none":
                                i += `a=${xs().INACTIVE}\r\n`;
                                break;
                            case "both":
                                i += `a=${xs().SENDRECV}\r\n`
                        }
                        return i += `a=mid:${e.attr("name")}\r\n`, t.find(">rtcp-mux").length && (i += "a=rtcp-mux\r\n"), t.find(">payload-type").each(((e, t) => {
                            i += `${Js.buildRTPMap(t)}\r\n`, $(t).find(">parameter").length && (i += `a=fmtp:${t.getAttribute("id")} `, i += $(t).find(">parameter").map(((e, t) => {
                                const n = t.getAttribute("name");
                                return (n ? `${n}=` : "") + t.getAttribute("value")
                            })).get().join("; "), i += "\r\n"), i += this.rtcpFbFromJingle($(t), t.getAttribute("id"))
                        })), i += this.rtcpFbFromJingle(t, "*"), t.find('>rtp-hdrext[xmlns="urn:xmpp:jingle:apps:rtp:rtp-hdrext:0"]').each(((e, t) => {
                            i += `a=extmap:${t.getAttribute("id")} ${t.getAttribute("uri")}\r\n`
                        })), t.find('>ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(((e, t) => {
                            const n = t.getAttribute("semantics"),
                                s = $(t).find(">source").map(((e, t) => t.getAttribute("ssrc"))).get();
                            s.length && (i += `a=ssrc-group:${n} ${s.join(" ")}\r\n`)
                        })), t.find('>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(((e, t) => {
                            const n = t.getAttribute("ssrc");
                            $(t).find(">parameter").each(((e, t) => {
                                const s = t.getAttribute("name");
                                let r = t.getAttribute("value");
                                r = Js.filterSpecialChars(r), i += `a=ssrc:${n} ${s}`, r && r.length && (i += `:${r}`), i += "\r\n"
                            }))
                        })), i
                    }, Hs.prototype.getNewMedia = function() {
                        const e = this.mySDP.getMediaSsrcMap(),
                            t = this.otherSDP.getMediaSsrcMap(),
                            n = {};
                        return Object.keys(t).forEach((i => {
                            const s = e[i],
                                r = t[i];
                            s || !r ? (Object.keys(r.ssrcs).forEach((e => {
                                (-1 === Object.keys(s.ssrcs).indexOf(e) || r.ssrcs[e].lines && s.ssrcs[e].lines && void 0 !== s.ssrcs[e].lines.find((e => -1 !== e.indexOf("msid"))) != (void 0 !== r.ssrcs[e].lines.find((e => -1 !== e.indexOf("msid"))))) && (n[i] || (n[i] = {
                                    mediaindex: r.mediaindex,
                                    mid: r.mid,
                                    ssrcs: {},
                                    ssrcGroups: []
                                }), n[i].ssrcs[e] = r.ssrcs[e])
                            })), r.ssrcGroups.forEach((e => {
                                let t = !1;
                                for (let n = 0; n < s.ssrcGroups.length; n++) {
                                    const i = s.ssrcGroups[n];
                                    if (e.semantics === i.semantics && Vs(e.ssrcs, i.ssrcs)) {
                                        t = !0;
                                        break
                                    }
                                }
                                t || (n[i] || (n[i] = {
                                    mediaindex: r.mediaindex,
                                    mid: r.mid,
                                    ssrcs: {},
                                    ssrcGroups: []
                                }), n[i].ssrcGroups.push(e))
                            }))) : n[i] = r
                        })), n
                    }, Hs.prototype.toJingle = function(e) {
                        const t = this.getNewMedia();
                        let n = !1;
                        return Object.keys(t).forEach((i => {
                            n = !0;
                            const s = t[i];
                            e.c("content", {
                                name: s.mid
                            }), e.c("description", {
                                xmlns: "urn:xmpp:jingle:apps:rtp:1",
                                media: s.mid
                            }), Object.keys(s.ssrcs).forEach((t => {
                                const n = s.ssrcs[t],
                                    i = n.lines,
                                    r = Js.parseSourceNameLine(i);
                                e.c("source", {
                                    xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                }), e.attrs({
                                    name: Ns.isSourceNameSignalingEnabled() ? r : void 0,
                                    ssrc: n.ssrc
                                });
                                const o = Js.parseMSIDAttribute(i);
                                o && (e.c("parameter"), e.attrs({
                                    name: "msid"
                                }), e.attrs({
                                    value: o
                                }), e.up()), e.up()
                            })), s.ssrcGroups.forEach((t => {
                                t.ssrcs.length && (e.c("ssrc-group", {
                                    semantics: t.semantics,
                                    xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0"
                                }), t.ssrcs.forEach((t => {
                                    e.c("source", {
                                        ssrc: t
                                    }).up()
                                })), e.up())
                            })), e.up(), e.up()
                        })), n
                    };
                    var Gs = n(8871),
                        qs = n.n(Gs);
                    const Ks = (0, f.getLogger)("modules/util/AsyncQueue.js");
                    class zs {
                        constructor() {
                            this._queue = qs().queue(this._processQueueTasks.bind(this), 1), this._stopped = !1
                        }
                        clear() {
                            this._queue.kill()
                        }
                        _processQueueTasks(e, t) {
                            try {
                                e(t)
                            } catch (e) {
                                Ks.error(`Task failed: ${null==e?void 0:e.stack}`), t(e)
                            }
                        }
                        push(e, t) {
                            this._stopped ? t && t(new Error("The queue has been stopped")) : this._queue.push(e, t)
                        }
                        shutdown() {
                            this._stopped = !0
                        }
                    }
                    var Ws = n(7285);
                    const Qs = "pending",
                        Xs = "active",
                        Ys = "ended",
                        Zs = (0, f.getLogger)("modules/xmpp/JingleSession.js");
                    class er extends Ti {
                        constructor(e, t, n, i, s, r, o) {
                            super(), this.sid = e, this.localJid = t, this.remoteJid = n, this.connection = i, this.mediaConstraints = s, this.pcConfig = r, this.isInitiator = o, this.usedrip = !0, this.dripContainer = [], this.room = null, this.state = null, this.rtc = null
                        }
                        get initiatorJid() {
                            return this.isInitiator ? this.localJid : this.remoteJid
                        }
                        get responderJid() {
                            return this.isInitiator ? this.remoteJid : this.localJid
                        }
                        initialize(e, t, n) {
                            if (null !== this.state) {
                                const e = `attempt to initiate on session ${this.sid}\n                   in state ${this.state}`;
                                throw Zs.error(e), new Error(e)
                            }
                            this.room = e, this.rtc = t, this.state = Qs, this.doInitialize(n)
                        }
                        doInitialize(e) {}
                        addIceCandidates(e) {}
                        getState() {
                            return this.state
                        }
                        addSources(e) {}
                        removeSources(e) {}
                        terminate(e, t, n) {}
                        acceptOffer(e, t, n) {}
                        _getInitiatorJid() {
                            return this.isInitiator ? this.localJid : this.remoteJid
                        }
                    }
                    const tr = "media_session.REMOTE_VIDEO_CONSTRAINTS_CHANGED",
                        nr = "signaling.peerMuted",
                        ir = "signaling.peerVideoType";
                    class sr extends Ti {
                        getSSRCOwner(e) {
                            throw new Error("not implemented")
                        }
                        getPeerMediaInfo(e, t) {
                            throw new Error("not implemented")
                        }
                    }
                    const rr = (0, f.getLogger)("modules/xmpp/SignalingLayerImpl.js");
                    class or extends sr {
                        constructor() {
                            super(), this.ssrcOwners = new Map, this.chatRoom = null
                        }
                        setChatRoom(e) {
                            const t = this.chatRoom;
                            this.chatRoom = e, t && (t.removePresenceListener("audiomuted", this._audioMuteHandler), t.removePresenceListener("videomuted", this._videoMuteHandler), t.removePresenceListener("videoType", this._videoTypeHandler)), e && (this._audioMuteHandler = (e, t) => {
                                this.eventEmitter.emit(nr, t, En, "true" === e.value)
                            }, e.addPresenceListener("audiomuted", this._audioMuteHandler), this._videoMuteHandler = (e, t) => {
                                this.eventEmitter.emit(nr, t, Cn, "true" === e.value)
                            }, e.addPresenceListener("videomuted", this._videoMuteHandler), this._videoTypeHandler = (e, t) => {
                                this.eventEmitter.emit(ir, t, e.value)
                            }, e.addPresenceListener("videoType", this._videoTypeHandler))
                        }
                        getPeerMediaInfo(e, t) {
                            if (this.chatRoom) return this.chatRoom.getMediaPresenceInfo(e, t);
                            rr.error("Requested peer media info, before room was set")
                        }
                        getSSRCOwner(e) {
                            return this.ssrcOwners.get(e)
                        }
                        setSSRCOwner(e, t) {
                            if ("number" != typeof e) throw new TypeError(`SSRC(${e}) must be a number`);
                            this.ssrcOwners.set(e, t)
                        }
                    }
                    const ar = (0, f.getLogger)("modules/xmpp/JingleSessionPC.js"),
                        cr = 1e4;
                    class dr extends er {
                        static parseVideoSenders(e) {
                            const t = e.find('>content[name="video"]');
                            if (t.length) {
                                const e = t[0].getAttribute("senders");
                                if ("both" === e || "initiator" === e || "responder" === e || "none" === e) return e
                            }
                            return null
                        }
                        static parseMaxFrameHeight(e) {
                            const t = e.find('>content[name="video"]>max-frame-height');
                            return t.length ? Number(t.text()) : null
                        }
                        constructor(e, t, n, i, s, r, o, a) {
                            super(e, t, n, i, s, r, a), this._bridgeSessionId = null, this._cachedOldLocalSdp = void 0, this._cachedNewLocalSdp = void 0, this._iceCheckingStartedTimestamp = null, this._gatheringStartedTimestamp = null, this.localRecvMaxFrameHeight = void 0, this._localVideoActive = !0, this._remoteVideoActive = !0, this._gatheringReported = !1, this.lasticecandidate = !1, this.closed = !1, this.isP2P = o, this.remoteRecvMaxFrameHeight = void 0, this.signalingLayer = new or, this.modificationQueue = new zs, this.wasConnected = !1, this.establishmentDuration = void 0, this._xmppListeners = [], this._xmppListeners.push(i.addEventListener(is.Events.CONN_STATUS_CHANGED, this.onXmppStatusChanged.bind(this))), this._removeSenderVideoConstraintsChangeListener = void 0
                        }
                        _assertNotEnded() {
                            return this.state !== Ys
                        }
                        doInitialize(e) {
                            var t, n, i;
                            this.failICE = Boolean(e.failICE), this.lasticecandidate = !1, this.options = e, this.isReconnect = !1, this.wasstable = !1, this.webrtcIceUdpDisable = Boolean(e.webrtcIceUdpDisable), this.webrtcIceTcpDisable = Boolean(e.webrtcIceTcpDisable);
                            const s = {
                                disableRtx: e.disableRtx
                            };
                            if (e.gatherStats && (s.maxstats = 300), s.capScreenshareBitrate = !1, s.enableInsertableStreams = e.enableInsertableStreams, s.videoQuality = e.videoQuality, s.forceTurnRelay = e.forceTurnRelay, s.audioQuality = e.audioQuality, s.usesUnifiedPlan = this.usesUnifiedPlan = Qt.supportsUnifiedPlan() && (Qt.isFirefox() || Qt.isWebKitBased() || (Qt.isChromiumBased() && this.isP2P ? null === (t = null === (n = e.p2p) || void 0 === n ? void 0 : n.enableUnifiedOnChrome) || void 0 === t || t : null === (i = e.enableUnifiedOnChrome) || void 0 === i || i)), this.isP2P) {
                                s.disableSimulcast = !0;
                                const t = this._abtestSuspendVideoEnabled(e);
                                void 0 !== t && (s.abtestSuspendVideo = t)
                            } else {
                                var r, o;
                                s.disableSimulcast = e.disableSimulcast || e.preferH264 && !e.disableH264 || e.videoQuality && e.videoQuality.preferredCodec === ks.H264, s.capScreenshareBitrate = s.disableSimulcast || !("number" == typeof(null === (r = e.desktopSharingFrameRate) || void 0 === r ? void 0 : r.max) && (null === (o = e.desktopSharingFrameRate) || void 0 === o ? void 0 : o.max) > 5), On.analytics.addPermanentProperties({
                                    capScreenshareBitrate: s.capScreenshareBitrate
                                })
                            }
                            e.startSilent && (s.startSilent = !0), this.peerconnection = this.rtc.createPeerConnection(this.signalingLayer, this.pcConfig, this.isP2P, s), this.peerconnection.onicecandidate = e => {
                                if (!e) return;
                                const t = e.candidate,
                                    n = window.performance.now();
                                if (t) {
                                    null === this._gatheringStartedTimestamp && (this._gatheringStartedTimestamp = n);
                                    let e = t.protocol;
                                    if ("string" == typeof e)
                                        if (e = e.toLowerCase(), "tcp" === e || "ssltcp" === e) {
                                            if (this.webrtcIceTcpDisable) return
                                        } else if ("udp" === e && this.webrtcIceUdpDisable) return
                                } else this._gatheringReported || (On.sendAnalytics(St, {
                                    phase: "gathering",
                                    value: n - this._gatheringStartedTimestamp,
                                    p2p: this.isP2P,
                                    initiator: this.isInitiator
                                }), this._gatheringReported = !0);
                                this.sendIceCandidate(t)
                            }, this.peerconnection.onsignalingstatechange = () => {
                                "stable" === this.peerconnection.signalingState ? this.wasstable = !0 : "closed" !== this.peerconnection.signalingState && "closed" !== this.peerconnection.connectionState || this.room.eventEmitter.emit(Hn().SUSPEND_DETECTED, this)
                            }, this.peerconnection.oniceconnectionstatechange = () => {
                                const e = window.performance.now();
                                let t = !1;
                                switch (this.isP2P || (this.room.connectionTimes[`ice.state.${this.peerconnection.iceConnectionState}`] = e), ar.log(`(TIME) ICE ${this.peerconnection.iceConnectionState} ${this.isP2P?"P2P":"JVB"}:\t`, e), On.sendAnalytics("ice.state.changed", {
                                        p2p: this.isP2P,
                                        state: this.peerconnection.iceConnectionState,
                                        signaling_state: this.peerconnection.signalingState,
                                        reconnect: this.isReconnect,
                                        value: e
                                    }), this.room.eventEmitter.emit(Hn().ICE_CONNECTION_STATE_CHANGED, this, this.peerconnection.iceConnectionState), this.peerconnection.iceConnectionState) {
                                    case "checking":
                                        this._iceCheckingStartedTimestamp = e;
                                        break;
                                    case "connected":
                                        if ("stable" === this.peerconnection.signalingState) {
                                            t = !0;
                                            const e = !this.options.enableIceRestart && this.room.supportsRestartByTerminate();
                                            (this.isReconnect || e) && this.room.eventEmitter.emit(Hn().CONNECTION_RESTORED, this)
                                        }
                                        if (!this.wasConnected && (this.wasstable || t || this.usesUnifiedPlan && this.isInitiator && Qt.isChromiumBased())) {
                                            On.sendAnalytics(St, {
                                                phase: "checking",
                                                value: e - this._iceCheckingStartedTimestamp,
                                                p2p: this.isP2P,
                                                initiator: this.isInitiator
                                            });
                                            const t = Math.min(this._iceCheckingStartedTimestamp, this._gatheringStartedTimestamp);
                                            this.establishmentDuration = e - t, On.sendAnalytics(St, {
                                                phase: "establishment",
                                                value: this.establishmentDuration,
                                                p2p: this.isP2P,
                                                initiator: this.isInitiator
                                            }), this.wasConnected = !0, this.room.eventEmitter.emit(Hn().CONNECTION_ESTABLISHED, this)
                                        }
                                        this.isReconnect = !1;
                                        break;
                                    case "disconnected":
                                        this.isReconnect = !0, this.wasstable && this.room.eventEmitter.emit(Hn().CONNECTION_INTERRUPTED, this);
                                        break;
                                    case "failed":
                                        this.room.eventEmitter.emit(Hn().CONNECTION_ICE_FAILED, this)
                                }
                            }, this.peerconnection.onconnectionstatechange = () => {
                                const e = this.peerconnection.iceConnectionState;
                                "failed" === this.peerconnection.connectionState && "disconnected" === e && this.room.eventEmitter.emit(Hn().CONNECTION_ICE_FAILED, this)
                            }, this.peerconnection.onnegotiationneeded = () => {
                                const e = this.peerconnection.signalingState,
                                    t = this.peerconnection.remoteDescription;
                                if (this.usesUnifiedPlan && "stable" === e && t && "string" == typeof t.sdp) {
                                    ar.debug(`${this} onnegotiationneeded fired on ${this.peerconnection} in state: ${e}`);
                                    const t = e => {
                                        const t = new Us(this.peerconnection.localDescription.sdp);
                                        this._renegotiate().then((() => {
                                            const n = new Us(this.peerconnection.localDescription.sdp);
                                            this.notifyMySSRCUpdate(t, n), e()
                                        }), e)
                                    };
                                    this.modificationQueue.push(t, (e => {
                                        e ? ar.error(`${this} onnegotiationneeded error`, e) : ar.debug(`${this} onnegotiationneeded executed - OK`)
                                    }))
                                }
                            }, this.signalingLayer.setChatRoom(this.room)
                        }
                        getRemoteRecvMaxFrameHeight() {
                            if (this.isP2P) return this.remoteRecvMaxFrameHeight
                        }
                        sendIceCandidate(e) {
                            const t = new Us(this.peerconnection.localDescription.sdp);
                            if (e && e.candidate.length && !this.lasticecandidate) {
                                const n = Js.iceparams(t.media[e.sdpMLineIndex], t.session),
                                    i = Js.candidateToJingle(e.candidate);
                                if (!n || !i) {
                                    const e = "failed to get ice && jcand";
                                    return sn().callErrorHandler(new Error(e)), void ar.error(e)
                                }
                                n.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", this.usedrip ? (0 === this.dripContainer.length && setTimeout((() => {
                                    0 !== this.dripContainer.length && (this.sendIceCandidates(this.dripContainer), this.dripContainer = [])
                                }), 150), this.dripContainer.push(e)) : this.sendIceCandidates([e])
                            } else ar.log(`${this} sendIceCandidate: last candidate`), this.lasticecandidate = !0
                        }
                        sendIceCandidates(e) {
                            if (!this._assertNotEnded("sendIceCandidates")) return;
                            ar.log(`${this} sendIceCandidates ${JSON.stringify(e)}`);
                            const t = (0, Xe.$iq)({
                                    to: this.remoteJid,
                                    type: "set"
                                }).c("jingle", {
                                    xmlns: "urn:xmpp:jingle:1",
                                    action: "transport-info",
                                    initiator: this.initiatorJid,
                                    sid: this.sid
                                }),
                                n = new Us(this.peerconnection.localDescription.sdp);
                            for (let i = 0; i < n.media.length; i++) {
                                const s = e.filter((e => e.sdpMLineIndex === i)),
                                    r = Js.parseMLine(n.media[i].split("\r\n")[0]);
                                if (s.length > 0) {
                                    const e = Js.iceparams(n.media[i], n.session);
                                    e.xmlns = "urn:xmpp:jingle:transports:ice-udp:1", t.c("content", {
                                        creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
                                        name: s[0].sdpMid ? s[0].sdpMid : r.media
                                    }).c("transport", e);
                                    for (let e = 0; e < s.length; e++) {
                                        const n = Js.candidateToJingle(s[e].candidate);
                                        this.failICE && (n.ip = "1.1.1.1"), t.c("candidate", n).up()
                                    }
                                    const o = Js.findLine(n.media[i], "a=fingerprint:", n.session);
                                    if (o) {
                                        const e = Js.parseFingerprint(o);
                                        e.required = !0, t.c("fingerprint", {
                                            xmlns: "urn:xmpp:jingle:apps:dtls:0"
                                        }).t(e.fingerprint), delete e.fingerprint, t.attrs(e), t.up()
                                    }
                                    t.up(), t.up()
                                }
                            }
                            this.connection.sendIQ(t, null, this.newJingleErrorHandler(t), cr)
                        }
                        sendIceFailedNotification() {
                            const e = (0, Xe.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "session-info",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            }).c("ice-state", {
                                xmlns: "http://jitsi.org/protocol/focus"
                            }).t("failed").up();
                            this._bridgeSessionId && e.c("bridge-session", {
                                xmlns: "http://jitsi.org/protocol/focus",
                                id: this._bridgeSessionId
                            }), this.connection.sendIQ2(e, {
                                timeout: 65
                            }).catch(this.newJingleErrorHandler(e))
                        }
                        addIceCandidates(e) {
                            if ("closed" === this.peerconnection.signalingState) return void ar.warn(`${this} Ignored add ICE candidate when in closed state`);
                            const t = [];
                            e.find(">content>transport>candidate").each(((e, n) => {
                                let i = Js.candidateFromJingle(n);
                                i = i.replace("\r\n", "").replace("a=", "");
                                const s = new RTCIceCandidate({
                                    sdpMLineIndex: 0,
                                    sdpMid: "",
                                    candidate: i
                                });
                                t.push(s)
                            })), t.length ? (ar.debug(`${this} Queued add (${t.length}) ICE candidates task`), this.modificationQueue.push((e => {
                                for (const e of t) this.peerconnection.addIceCandidate(e).then((() => ar.debug(`${this} addIceCandidate ok!`)), (e => ar.error(`${this} addIceCandidate failed!`, e)));
                                e(), ar.debug(`${this} ICE candidates task finished`)
                            }))) : ar.error(`${this} No ICE candidates to add ?`, e[0] && e[0].outerHTML)
                        }
                        readSsrcInfo(e) {
                            $(e).find('>description>source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each(((e, t) => {
                                const n = Number(t.getAttribute("ssrc"));
                                this.isP2P ? this.signalingLayer.setSSRCOwner(n, Xe.Strophe.getResourceFromJid(this.remoteJid)) : $(t).find('>ssrc-info[xmlns="http://jitsi.org/jitmeet"]').each(((e, t) => {
                                    const i = t.getAttribute("owner");
                                    var s;
                                    i && i.length && (isNaN(n) || n < 0 ? ar.warn(`${this} Invalid SSRC ${n} value received for ${i}`) : this.signalingLayer.setSSRCOwner(n, (s = i, Xe.Strophe.getResourceFromJid(s) || s)))
                                }))
                            }))
                        }
                        generateRecvonlySsrc() {
                            this.peerconnection ? this.peerconnection.generateRecvonlySsrc() : ar.error(`${this} Unable to generate recvonly SSRC - no peerconnection`)
                        }
                        getConfiguredVideoCodec() {
                            return this.peerconnection.getConfiguredVideoCodec()
                        }
                        acceptOffer(e, t, n, i) {
                            this.setOfferAnswerCycle(e, (() => {
                                this.sendSessionAccept(t, n)
                            }), n, i)
                        }
                        invite(e = []) {
                            if (!this.isInitiator) throw new Error("Trying to invite from the responder session");
                            ar.debug(`${this} Queued invite task`), this.modificationQueue.push((t => {
                                const n = [];
                                for (const t of e) n.push(this.peerconnection.addTrack(t, this.isInitiator));
                                Promise.all(n).then((() => this.peerconnection.createOffer(this.mediaConstraints))).then((e => this.peerconnection.setLocalDescription(e))).then((() => {
                                    this.sendSessionInitiate(this.peerconnection.localDescription.sdp)
                                })).then((() => t()), (e => t(e)))
                            }), (e => {
                                e ? ar.error(`${this} invite error`, e) : ar.debug(`${this} invite executed - OK`)
                            }))
                        }
                        sendSessionInitiate(e) {
                            let t = (0, Xe.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "session-initiate",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            });
                            new Us(e).toJingle(t, this.isInitiator ? "initiator" : "responder"), t = t.tree(), ar.debug(`${this} Session-initiate: `, t), this.connection.sendIQ(t, (() => {
                                ar.info(`${this} Got RESULT for "session-initiate"`)
                            }), (e => {
                                ar.error(`${this} "session-initiate" error`, e)
                            }), cr)
                        }
                        setAnswer(e) {
                            if (!this.isInitiator) throw new Error("Trying to set an answer on the responder session");
                            this.setOfferAnswerCycle(e, (() => {
                                if (ar.info(`${this} setAnswer - succeeded`), this.usesUnifiedPlan && Qt.isChromiumBased()) {
                                    const e = this.peerconnection.remoteDescription.sdp,
                                        t = new RTCSessionDescription({
                                            type: "offer",
                                            sdp: e
                                        });
                                    this._responderRenegotiate(t)
                                }
                            }), (e => {
                                ar.error(`${this} setAnswer failed: `, e)
                            }))
                        }
                        setOfferAnswerCycle(e, t, n, i = []) {
                            ar.debug(`${this} Queued setOfferAnswerCycle task`), this.modificationQueue.push((t => {
                                const n = [];
                                for (const e of i) n.push(this.peerconnection.addTrack(e, this.isInitiator));
                                const s = this._processNewJingleOfferIq(e),
                                    r = this.peerconnection.localDescription.sdp,
                                    o = $(e).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("id");
                                o !== this._bridgeSessionId && (this._bridgeSessionId = o), Promise.all(n).then((() => this._renegotiate(s.raw))).then((() => {
                                    if (this.state === Qs && (this.state = Xs, !this.isP2P || this._localVideoActive && !this.localRecvMaxFrameHeight || this.sendContentModify()), r) {
                                        const e = new Us(this.peerconnection.localDescription.sdp);
                                        this.notifyMySSRCUpdate(new Us(r), e)
                                    }
                                })).then((() => t()), (e => t(e)))
                            }), (e => {
                                e ? (ar.error(`${this} setOfferAnswerCycle task failed: ${e}`), n(e)) : (ar.debug(`${this} setOfferAnswerCycle task done`), t())
                            }))
                        }
                        setVideoCodecs(e = null, t = null) {
                            const n = this.peerconnection.getConfiguredVideoCodec();
                            if (this._assertNotEnded() && e !== n) {
                                ar.info(`${this} Switching video codec from ${n} to ${e}`), this.peerconnection.setVideoCodecs(e, t);
                                const i = e => {
                                    this._renegotiate().then((() => (ar.debug(`${this} setVideoCodecs task is done`), e())), (t => (ar.error(`${this} setVideoCodecs task failed: ${t}`), e(t))))
                                };
                                ar.debug(`${this} Queued setVideoCodecs task`), this.modificationQueue.push(i)
                            }
                        }
                        replaceTransport(e, t, n) {
                            if (this.options.enableForcedReload) {
                                const e = new Us(this.peerconnection.localDescription.sdp);
                                return this.sendTransportAccept(e, t, n), void this.room.eventEmitter.emit(Hn().CONNECTION_RESTARTED, this)
                            }
                            this.room.eventEmitter.emit(Hn().ICE_RESTARTING, this);
                            const i = e.clone();
                            e.find(">content[name='data']").attr("senders", "rejected"), e.find(">content>description>source").remove(), e.find(">content>description>ssrc-group").remove();
                            const s = e.find(">content>transport>fingerprint");
                            s.attr("hash", "sha-1"), s.text("00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00"), this.setOfferAnswerCycle(e, (() => {
                                this.setOfferAnswerCycle(i, (() => {
                                    const e = new Us(this.peerconnection.localDescription.sdp);
                                    this.sendTransportAccept(e, t, n), this.room.eventEmitter.emit(Hn().ICE_RESTART_SUCCESS, this, i)
                                }), n)
                            }), n)
                        }
                        sendSessionAccept(e, t) {
                            const n = new Us(this.peerconnection.localDescription.sdp),
                                i = (0, Xe.$iq)({
                                    to: this.remoteJid,
                                    type: "set"
                                }).c("jingle", {
                                    xmlns: "urn:xmpp:jingle:1",
                                    action: "session-accept",
                                    initiator: this.initiatorJid,
                                    responder: this.responderJid,
                                    sid: this.sid
                                });
                            this.webrtcIceTcpDisable && (n.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (n.removeUdpCandidates = !0), this.failICE && (n.failICE = !0), n.toJingle(i, this.initiatorJid === this.localJid ? "initiator" : "responder"), ar.info(`${this} Sending session-accept`), ar.debug(i.tree()), this.connection.sendIQ(i, e, this.newJingleErrorHandler(i, (e => {
                                t(e), this.room.eventEmitter.emit(Hn().SESSION_ACCEPT_TIMEOUT, this)
                            })), cr)
                        }
                        sendContentModify() {
                            const e = this.localRecvMaxFrameHeight,
                                t = this._localVideoActive ? "both" : "none";
                            let n = (0, Xe.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "content-modify",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            }).c("content", {
                                name: "video",
                                senders: t
                            });
                            void 0 !== e && (n = n.c("max-frame-height", {
                                xmlns: "http://jitsi.org/jitmeet/video"
                            }).t(e)), ar.info(`${this} sending content-modify, video senders: ${t}, max frame height: ${e}`), ar.debug(n.tree()), this.connection.sendIQ(n, null, this.newJingleErrorHandler(n), cr)
                        }
                        setReceiverVideoConstraint(e) {
                            ar.info(`${this} setReceiverVideoConstraint - max frame height: ${e}`), this.localRecvMaxFrameHeight = e, this.isP2P ? this.state === Xs && this.sendContentModify() : this.rtc.setReceiverVideoConstraint(e)
                        }
                        sendTransportAccept(e, t, n) {
                            const i = (0, Xe.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "transport-accept",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            });
                            e.media.forEach(((t, n) => {
                                const s = Js.parseMLine(t.split("\r\n")[0]);
                                i.c("content", {
                                    creator: this.initiatorJid === this.localJid ? "initiator" : "responder",
                                    name: s.media
                                }), e.transportToJingle(n, i), i.up()
                            })), ar.info(`${this} Sending transport-accept`), ar.debug(i.tree()), this.connection.sendIQ(i, t, this.newJingleErrorHandler(i, n), cr)
                        }
                        sendTransportReject(e, t) {
                            const n = (0, Xe.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "transport-reject",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            });
                            ar.info(`${this} Sending 'transport-reject'`), ar.debug(n.tree()), this.connection.sendIQ(n, e, this.newJingleErrorHandler(n, t), cr)
                        }
                        setSenderMaxBitrates() {
                            return this._assertNotEnded() ? this.peerconnection.setMaxBitRate() : Promise.resolve()
                        }
                        setSenderVideoConstraint(e) {
                            if (this._assertNotEnded()) {
                                if (ar.info(`${this} setSenderVideoConstraint: ${e}`), !this.isP2P && Qt.isReactNative() && void 0 !== e) {
                                    const t = e > 0;
                                    return this.setMediaTransferActive(!0, t)
                                }
                                return this.peerconnection.setSenderVideoConstraint(e)
                            }
                            return Promise.resolve()
                        }
                        setSenderVideoDegradationPreference() {
                            return this._assertNotEnded() ? this.peerconnection.setSenderVideoDegradationPreference() : Promise.resolve()
                        }
                        terminate(e, t, n) {
                            if (this.state !== Ys) {
                                if (!n || Boolean(n.sendSessionTerminate)) {
                                    const i = (0, Xe.$iq)({
                                        to: this.remoteJid,
                                        type: "set"
                                    }).c("jingle", {
                                        xmlns: "urn:xmpp:jingle:1",
                                        action: "session-terminate",
                                        initiator: this.initiatorJid,
                                        sid: this.sid
                                    }).c("reason").c(n && n.reason || "success").up();
                                    n && n.reasonDescription ? i.c("text").t(n.reasonDescription).up().up() : i.up(), this._bridgeSessionId && i.c("bridge-session", {
                                        xmlns: "http://jitsi.org/protocol/focus",
                                        id: this._bridgeSessionId,
                                        restart: n && !0 === n.requestRestart
                                    }).up(), ar.info(`${this} Sending session-terminate`), ar.debug(i.tree()), this.connection.sendIQ(i, e, this.newJingleErrorHandler(i, t), cr)
                                } else ar.info(`${this} Skipped sending session-terminate`);
                                this.connection.jingle.terminate(this.sid)
                            }
                        }
                        onTerminated(e, t) {
                            ar.info(`${this} Session terminated`, e, t), this._xmppListeners.forEach((e => e())), this._xmppListeners = [], this._removeSenderVideoConstraintsChangeListener && this._removeSenderVideoConstraintsChangeListener(), this.close()
                        }
                        onXmppStatusChanged(e) {
                            e === is.Status.CONNECTED && this._cachedOldLocalSdp && (ar.info(`${this} Sending SSRC update on reconnect`), this.notifyMySSRCUpdate(this._cachedOldLocalSdp, this._cachedNewLocalSdp))
                        }
                        _parseSsrcInfoFromSourceAdd(e, t) {
                            const n = [],
                                i = this;
                            return $(e).each(((e, s) => {
                                const r = $(s).attr("name");
                                let o = "";
                                $(s).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                    const e = this.getAttribute("semantics"),
                                        t = $(this).find(">source").map((function() {
                                            return this.getAttribute("ssrc")
                                        })).get();
                                    t.length && (o += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
                                })), $(s).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                    const e = $(this).attr("ssrc");
                                    t.containsSSRC(e) ? (!i.usesUnifiedPlan || !i.isP2P) && ar.warn(`${i} Source-add request for existing SSRC: ${e}`) : $(this).find(">parameter").each((function() {
                                        o += `a=ssrc:${e} ${$(this).attr("name")}`, $(this).attr("value") && $(this).attr("value").length && (o += `:${$(this).attr("value")}`), o += "\r\n"
                                    }))
                                })), t.media.forEach(((e, t) => {
                                    Js.findLine(e, `a=mid:${r}`) && (n[t] || (n[t] = ""), n[t] += o)
                                }))
                            })), n
                        }
                        addRemoteStream(e) {
                            this._addOrRemoveRemoteStream(!0, e)
                        }
                        removeRemoteStream(e) {
                            this._addOrRemoveRemoteStream(!1, e)
                        }
                        removeRemoteStreamsOnLeave(e) {
                            let t = [];
                            const n = n => {
                                const i = this.peerconnection.getRemoteSourceInfoByParticipant(e);
                                if (i.length) {
                                    const s = new Us(this.peerconnection.localDescription.sdp),
                                        r = this._processRemoteRemoveSource(i);
                                    t = this.peerconnection.removeRemoteTracks(e), this._renegotiate(r.raw).then((() => {
                                        const e = new Us(this.peerconnection.localDescription.sdp);
                                        this.notifyMySSRCUpdate(s, e), n()
                                    })).catch((e => n(e)))
                                } else n()
                            };
                            return new Promise(((i, s) => {
                                ar.debug(`${this} Queued removeRemoteStreamsOnLeave task for participant ${e}`), this.modificationQueue.push(n, (e => {
                                    e ? (ar.error(`${this} removeRemoteStreamsOnLeave error:`, e), s(e)) : (ar.info(`${this} removeRemoteStreamsOnLeave done!`), i(t))
                                }))
                            }))
                        }
                        _addOrRemoveRemoteStream(e, t) {
                            const n = e ? "addRemoteStream" : "removeRemoteStream";
                            e && this.readSsrcInfo(t), ar.debug(`${this} Queued ${n} task`), this.modificationQueue.push((i => {
                                if (!this.peerconnection.localDescription || !this.peerconnection.localDescription.sdp) {
                                    const e = `${n} - localDescription not ready yet`;
                                    return ar.error(e), void i(e)
                                }
                                ar.log(`${this} Processing ${n}`);
                                const s = new Us(this.peerconnection.localDescription.sdp),
                                    r = new Us(this.peerconnection.remoteDescription.sdp),
                                    o = e ? this._parseSsrcInfoFromSourceAdd(t, r) : this._parseSsrcInfoFromSourceRemove(t, r),
                                    a = e ? this._processRemoteAddSource(o) : this._processRemoteRemoveSource(o),
                                    c = new RTCSessionDescription({
                                        type: "offer",
                                        sdp: a.raw
                                    });
                                (e && this.usesUnifiedPlan && this.isP2P && Qt.isChromiumBased() ? this._responderRenegotiate(c) : this._renegotiate(a.raw)).then((() => {
                                    const e = new Us(this.peerconnection.localDescription.sdp);
                                    ar.log(`${this} ${n} - OK`), this.notifyMySSRCUpdate(s, e), i()
                                }), (e => {
                                    ar.error(`${this} ${n} failed:`, e), i(e)
                                }))
                            }))
                        }
                        _processNewJingleOfferIq(e) {
                            const t = new Us("");
                            return this.webrtcIceTcpDisable && (t.removeTcpCandidates = !0), this.webrtcIceUdpDisable && (t.removeUdpCandidates = !0), this.failICE && (t.failICE = !0), t.fromJingle(e), this.readSsrcInfo($(e).find(">content")), t
                        }
                        _processRemoteRemoveSource(e) {
                            const t = this.usesUnifiedPlan ? new Us(this.peerconnection.peerconnection.remoteDescription.sdp) : new Us(this.peerconnection.remoteDescription.sdp);
                            return e.forEach(((e, n) => {
                                (e = e.split("\r\n")).pop(), this.usesUnifiedPlan ? e.forEach((e => {
                                    const n = t.media.findIndex((t => t.includes(e)));
                                    if (n > -1)
                                        if ((!this.usesUnifiedPlan || this.usesUnifiedPlan && !this.isP2P) && (t.media[n] = t.media[n].replace(`${e}\r\n`, "")), this.isP2P) {
                                            var i;
                                            const e = null === (i = Js.parseMLine(t.media[n].split("\r\n")[0])) || void 0 === i ? void 0 : i.media,
                                                s = this.peerconnection.getDesiredMediaDirection(e, !1);
                                            [xs().SENDRECV, xs().SENDONLY].forEach((e => {
                                                t.media[n] = t.media[n].replace(`a=${e}`, `a=${s}`)
                                            }))
                                        } else t.media[n] = t.media[n].replace(`a=${xs().SENDONLY}`, `a=${xs().INACTIVE}`)
                                })) : e.forEach((e => {
                                    t.media[n] = t.media[n].replace(`${e}\r\n`, "")
                                }))
                            })), t.raw = t.session + t.media.join(""), t
                        }
                        _processRemoteAddSource(e) {
                            const t = new Us(this.peerconnection.remoteDescription.sdp);
                            return e.forEach(((e, n) => {
                                if (t.media[n] += e, this.isP2P && this.usesUnifiedPlan) {
                                    var i;
                                    const e = null === (i = Js.parseMLine(t.media[n].split("\r\n")[0])) || void 0 === i ? void 0 : i.media,
                                        s = this.peerconnection.getDesiredMediaDirection(e, !0);
                                    [xs().RECVONLY, xs().INACTIVE].forEach((e => {
                                        t.media[n] = t.media[n].replace(`a=${e}`, `a=${s}`)
                                    }))
                                }
                            })), t.raw = t.session + t.media.join(""), t
                        }
                        _renegotiate(e) {
                            if ("closed" === this.peerconnection.signalingState) {
                                const e = new Error("Attempted to renegotiate in state closed");
                                return this.room.eventEmitter.emit(Hn().RENEGOTIATION_FAILED, e, this), Promise.reject(e)
                            }
                            const t = e || this.peerconnection.remoteDescription.sdp;
                            if (!t) {
                                const e = new Error(`Can not renegotiate without remote description, current state: ${this.state}`);
                                return this.room.eventEmitter.emit(Hn().RENEGOTIATION_FAILED, e, this), Promise.reject(e)
                            }
                            const n = new RTCSessionDescription({
                                type: this.isInitiator ? "answer" : "offer",
                                sdp: t
                            });
                            return this.isInitiator ? this._initiatorRenegotiate(n) : this._responderRenegotiate(n)
                        }
                        _responderRenegotiate(e) {
                            return ar.debug(`${this} Renegotiate: setting remote description`), this.peerconnection.setRemoteDescription(e).then((() => (ar.debug(`${this} Renegotiate: creating answer`), this.peerconnection.createAnswer(this.mediaConstraints).then((e => (ar.debug(`${this} Renegotiate: setting local description`), this.peerconnection.setLocalDescription(e)))))))
                        }
                        _initiatorRenegotiate(e) {
                            return ar.debug(`${this} Renegotiate: creating offer`), this.peerconnection.createOffer(this.mediaConstraints).then((t => (ar.debug(`${this} Renegotiate: setting local description`), this.peerconnection.setLocalDescription(t).then((() => (ar.debug(`${this} Renegotiate: setting remote description`), this.peerconnection.setRemoteDescription(e)))))))
                        }
                        replaceTrack(e, t) {
                            const n = n => {
                                ar.debug(`${this} replaceTrack worker started. oldTrack = ${e}, newTrack = ${t}`);
                                const i = this.peerconnection.localDescription.sdp;
                                this.usesUnifiedPlan || (this.peerconnection.options.capScreenshareBitrate && e && t && t.isVideoTrack() && this.peerconnection.clearRecvonlySsrc(), !e && t && t.isVideoTrack() ? this.peerconnection.clearRecvonlySsrc() : e && e.isVideoTrack() && !t && (this.peerconnection.clearRecvonlySsrc(), this.peerconnection.generateRecvonlySsrc())), this.peerconnection.replaceTrack(e, t).then((n => {
                                    let s = Promise.resolve();
                                    return ar.debug(`${this} TPC.replaceTrack finished. shouldRenegotiate = ${n}, JingleSessionState = ${this.state}`), n && (e || t) && this.state === Xs && (s = this._renegotiate().then((() => {
                                        const e = new Us(this.peerconnection.localDescription.sdp);
                                        this.notifyMySSRCUpdate(new Us(i), e)
                                    }))), s.then((() => {
                                        if (t && t.isVideoTrack()) return ar.debug(`${this} replaceTrack worker: configuring video stream`), this.peerconnection.setSenderVideoDegradationPreference().then((() => this.peerconnection.setSenderVideoConstraint())).then((() => this.peerconnection.setMaxBitRate()))
                                    }))
                                })).then((() => n()), (e => n(e)))
                            };
                            return new Promise(((i, s) => {
                                ar.debug(`${this} Queued replaceTrack task. Old track = ${e}, new track = ${t}`), this.modificationQueue.push(n, (e => {
                                    e ? (ar.error(`${this} Replace track error:`, e), s(e)) : (ar.info(`${this}  Replace track done!`), i())
                                }))
                            }))
                        }
                        _parseSsrcInfoFromSourceRemove(e, t) {
                            const n = [];
                            return $(e).each(((e, i) => {
                                const s = $(i).attr("name");
                                let r = "";
                                $(i).find('ssrc-group[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                    const e = this.getAttribute("semantics"),
                                        t = $(this).find(">source").map((function() {
                                            return this.getAttribute("ssrc")
                                        })).get();
                                    t.length && (r += `a=ssrc-group:${e} ${t.join(" ")}\r\n`)
                                }));
                                const o = [];
                                $(i).find('source[xmlns="urn:xmpp:jingle:apps:rtp:ssma:0"]').each((function() {
                                    const e = $(this).attr("ssrc");
                                    o.push(e)
                                })), t.media.forEach(((e, t) => {
                                    Js.findLine(e, `a=mid:${s}`) && (n[t] || (n[t] = ""), o.forEach((i => {
                                        const s = Js.findLines(e, `a=ssrc:${i}`);
                                        s.length && (n[t] += `${s.join("\r\n")}\r\n`)
                                    })), n[t] += r)
                                }))
                            })), n
                        }
                        _verifyNoSSRCChanged(e, t) {
                            const n = new Us(this.peerconnection.localDescription.sdp);
                            let i = new Hs(t, n);
                            const s = i.getNewMedia();
                            if (Object.keys(s).length) return ar.error(`${this} - some SSRC were added on ${e}`, s), !1;
                            i = new Hs(n, t);
                            const r = i.getNewMedia();
                            return !Object.keys(r).length || (ar.error(`${this} - some SSRCs were removed on ${e}`, r), !1)
                        }
                        addTrackAsUnmute(e) {
                            return this._addRemoveTrackAsMuteUnmute(!1, e).then((() => {
                                if (e.isVideoTrack() && Qt.doesVideoMuteByStreamRemove()) return this.setSenderMaxBitrates().then((() => this.setSenderVideoDegradationPreference())).then((() => this.setSenderVideoConstraint()))
                            }))
                        }
                        removeTrackAsMute(e) {
                            return this._addRemoveTrackAsMuteUnmute(!0, e)
                        }
                        _addRemoveTrackAsMuteUnmute(e, t) {
                            if (!t) return Promise.reject('invalid "track" argument value');
                            const n = e ? "removeTrackMute" : "addTrackUnmute",
                                i = i => {
                                    const s = this.peerconnection;
                                    if (!s) return void i(`Error:  tried ${n} track with no active peerconnection`);
                                    const r = s.localDescription.sdp;
                                    (e ? s.removeTrackMute(t) : s.addTrackUnmute(t)).then((e => {
                                        e && r && s.remoteDescription.sdp ? this._renegotiate().then((() => {
                                            this._verifyNoSSRCChanged(n, new Us(r)), i()
                                        })) : i()
                                    }), i)
                                };
                            return ar.debug(`${this} Queued ${n} task`), new Promise(((e, t) => {
                                this.modificationQueue.push(i, (i => {
                                    i ? (ar.error(`${this} ${n} failed`), t(i)) : (ar.debug(`${this} ${n} done`), e())
                                }))
                            }))
                        }
                        setMediaTransferActive(e, t) {
                            if (!this.peerconnection) return Promise.reject('Can not modify transfer active state, before "initialize" is called');
                            const n = e ? "audio active" : "audio inactive",
                                i = t ? "video active" : "video inactive";
                            ar.info(`${this} Queued make ${i}, ${n} task`);
                            const s = n => {
                                const i = this.state === Xs,
                                    s = this.peerconnection.setAudioTransferActive(e);
                                this._localVideoActive !== t && (this._localVideoActive = t, this.isP2P && i && this.sendContentModify());
                                const r = this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive);
                                i && (s || r) ? this._renegotiate().then(n, n) : n()
                            };
                            return new Promise(((e, t) => {
                                this.modificationQueue.push(s, (s => {
                                    s ? (ar.error(`${this} Make ${i}, ${n} task failed!`), t(s)) : (ar.debug(`${this} Make ${i}, ${n} task done!`), e())
                                }))
                            }))
                        }
                        modifyContents(e) {
                            const t = dr.parseVideoSenders(e),
                                n = dr.parseMaxFrameHeight(e);
                            n && (ar.info(`${this} received remote max frame height: ${n}`), this.remoteRecvMaxFrameHeight = n, this.eventEmitter.emit(tr, this)), null !== t ? (ar.debug(`${this} queued "content-modify" task(video senders="${t}")`), this.modificationQueue.push((e => {
                                this._assertNotEnded("content-modify") && this._modifyRemoteVideoActive(t) ? this._renegotiate().then(e, e) : e()
                            }), (e => {
                                e ? ar.error(`${this} "content-modify" failed`, e) : ar.debug(`${this} "content-modify" task(video senders="${t}") done`)
                            }))) : ar.error(`${this} - failed to parse video "senders" attribute in"content-modify" action`)
                        }
                        _modifyRemoteVideoActive(e) {
                            const t = "both" === e || "initiator" === e && this.isInitiator || "responder" === e && !this.isInitiator;
                            return t !== this._remoteVideoActive && (ar.debug(`${this} new remote video active: ${t}`), this._remoteVideoActive = t), this.peerconnection.setVideoTransferActive(this._localVideoActive && this._remoteVideoActive)
                        }
                        notifyMySSRCUpdate(e, t) {
                            if (this.state !== Xs) return void ar.warn(`${this} Skipping SSRC update in '${this.state} ' state.`);
                            if (!this.connection.connected) return this._cachedOldLocalSdp || (this._cachedOldLocalSdp = e), this._cachedNewLocalSdp = t, void ar.warn(`${this} Not sending SSRC update while the signaling is disconnected`);
                            this._cachedOldLocalSdp = void 0, this._cachedNewLocalSdp = void 0;
                            let n = new Hs(t, e);
                            const i = (0, Xe.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "source-remove",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            });
                            n.toJingle(i) && (ar.info(`${this} Sending source-remove`), ar.debug(i.tree()), this.connection.sendIQ(i, null, this.newJingleErrorHandler(i), cr)), n = new Hs(e, t);
                            const s = (0, Xe.$iq)({
                                to: this.remoteJid,
                                type: "set"
                            }).c("jingle", {
                                xmlns: "urn:xmpp:jingle:1",
                                action: "source-add",
                                initiator: this.initiatorJid,
                                sid: this.sid
                            });
                            n.toJingle(s) && (ar.info(`${this} Sending source-add`), ar.debug(s.tree()), this.connection.sendIQ(s, null, this.newJingleErrorHandler(s), cr))
                        }
                        newJingleErrorHandler(e, t) {
                            return e => {
                                const n = {},
                                    i = $(e).find("error");
                                if (i.length) {
                                    n.code = i.attr("code");
                                    const t = $(e).find("error :first");
                                    t.length && (n.reason = t[0].tagName);
                                    const s = i.find(">text");
                                    s.length && (n.msg = s.text())
                                }
                                e || (n.reason = "timeout"), n.session = this.toString(), t ? t(n) : this.state === Ys && "item-not-found" === n.reason ? ar.debug(`${this} Jingle error: ${JSON.stringify(n)}`) : sn().callErrorHandler(new Error(`Jingle error: ${JSON.stringify(n)}`))
                            }
                        }
                        getIceConnectionState() {
                            return this.peerconnection.getConnectionState()
                        }
                        close() {
                            this.state = Ys, this.establishmentDuration = void 0, this.peerconnection && (this.peerconnection.onicecandidate = null, this.peerconnection.oniceconnectionstatechange = null, this.peerconnection.onnegotiationneeded = null, this.peerconnection.onsignalingstatechange = null), ar.debug(`${this} Clearing modificationQueue`), this.modificationQueue.clear(), ar.debug(`${this} Queued PC close task`), this.modificationQueue.push((e => {
                                this.signalingLayer.setChatRoom(null), this.peerconnection && this.peerconnection.close(), e(), ar.debug(`${this} PC close task done!`)
                            })), ar.debug(`${this} Shutdown modificationQueue!`), this.modificationQueue.shutdown()
                        }
                        toString() {
                            return `JingleSessionPC[session=${this.isP2P?"P2P":"JVB"},initiator=${this.isInitiator},sid=${this.sid}]`
                        }
                        _abtestSuspendVideoEnabled({
                            abTesting: e
                        }) {
                            if (!e || !e.enableSuspendVideoTest) return;
                            const t = this._getInitiatorJid();
                            return (0, Ws.integerHash)(t) % 2 == 0
                        }
                    }
                    const lr = (0, f.getLogger)("modules/xmpp/strophe.jingle.js");

                    function hr(e, t) {
                        const n = $build("source", {
                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                            ssrc: t.s,
                            name: Ns.isSourceNameSignalingEnabled() ? t.n : void 0
                        });
                        return t.m && n.c("parameter", {
                            name: "msid",
                            value: t.m
                        }).up(), n.c("ssrc-info", {
                            xmlns: "http://jitsi.org/jitmeet",
                            owner: e
                        }).up(), n.node
                    }

                    function ur(e) {
                        const t = $build("ssrc-group", {
                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                            semantics: (n = e[0], "f" === n ? "FID" : "s" === n ? "SIM" : null)
                        });
                        var n;
                        for (let n = 1; n < e.length; n++) t.c("source", {
                            xmlns: "urn:xmpp:jingle:apps:rtp:ssma:0",
                            ssrc: e[n]
                        }).up();
                        return t.node
                    }

                    function pr(e, t) {
                        var n;
                        let i;
                        try {
                            i = JSON.parse(t.textContent)
                        } catch (e) {
                            return lr.error(`json-message XML contained invalid JSON, ignoring: ${t.textContent}`), null
                        }
                        if (!(null === (n = i) || void 0 === n ? void 0 : n.sources)) return null;
                        const s = mr(e, En),
                            r = mr(e, Cn),
                            o = new Map;
                        for (const e in i.sources)
                            if (i.sources.hasOwnProperty(e)) {
                                const t = [],
                                    n = i.sources[e],
                                    d = (null == n ? void 0 : n.length) && n[0],
                                    l = (null == n ? void 0 : n.length) > 1 && n[1],
                                    h = (null == n ? void 0 : n.length) > 2 && n[2],
                                    u = (null == n ? void 0 : n.length) > 3 && n[3];
                                if (null == d ? void 0 : d.length) {
                                    var a;
                                    for (let t = 0; t < d.length; t++) r.appendChild(hr(e, d[t]));
                                    t.push(null === (a = d[0]) || void 0 === a ? void 0 : a.s)
                                }
                                if (null == l ? void 0 : l.length)
                                    for (let e = 0; e < l.length; e++) r.appendChild(ur(l[e]));
                                if (null == h ? void 0 : h.length) {
                                    var c;
                                    for (let t = 0; t < h.length; t++) s.appendChild(hr(e, h[t]));
                                    t.push(null === (c = h[0]) || void 0 === c ? void 0 : c.s)
                                }
                                if (null == u ? void 0 : u.length)
                                    for (let e = 0; e < u.length; e++) s.appendChild(ur(u[e]));
                                o.set(e, t)
                            } return o
                    }

                    function mr(e, t) {
                        const n = $(e).find("jingle")[0];
                        let i, s = $(n).find(`content[name="${t}"]`);
                        return s.length ? s = s[0] : (s = $build("content", {
                            name: t
                        }).node, n.appendChild(s)), i = $(s).find("description"), i.length ? i = i[0] : (i = $build("description", {
                            xmlns: "urn:xmpp:jingle:apps:rtp:1",
                            media: t
                        }).node, s.appendChild(i)), i
                    }

                    function fr(e) {
                        const t = $(e).find(">candidate"),
                            n = [];
                        return t.each(((e, t) => {
                            const i = t.attributes,
                                s = [];
                            for (let e = 0; e < i.length; e++) {
                                const t = i[e];
                                s.push(`${t.name}: ${t.value}`)
                            }
                            n.push(s.join(" "))
                        })), n
                    }
                    class gr extends Yi {
                        constructor(e, t, n) {
                            super(), this.xmpp = e, this.eventEmitter = t, this.sessions = {}, this.jvbIceConfig = n.jvb, this.p2pIceConfig = n.p2p, this.mediaConstraints = {
                                offerToReceiveAudio: !0,
                                offerToReceiveVideo: !0
                            }
                        }
                        init(e) {
                            super.init(e), this.connection.addHandler(this.onJingle.bind(this), "urn:xmpp:jingle:1", "iq", "set", null, null)
                        }
                        onJingle(e) {
                            const t = $(e).find("jingle").attr("sid"),
                                n = $(e).find("jingle").attr("action"),
                                i = e.getAttribute("from"),
                                s = (0, Xe.$iq)({
                                    type: "result",
                                    to: i,
                                    id: e.getAttribute("id")
                                });
                            let r = this.sessions[t];
                            if ("session-initiate" !== n) {
                                if (!r) return s.attrs({
                                    type: "error"
                                }), s.c("error", {
                                    type: "cancel"
                                }).c("item-not-found", {
                                    xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                                }).up().c("unknown-session", {
                                    xmlns: "urn:xmpp:jingle:errors:1"
                                })/* BAO , lr.warn(`invalid session id: ${t}`), lr.debug(e), this.connection.send(s), !0; */
                                if (i !== r.remoteJid) return lr.warn("jid mismatch for session id", t, r.remoteJid, e), s.attrs({
                                    type: "error"
                                }), s.c("error", {
                                    type: "cancel"
                                }).c("item-not-found", {
                                    xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                                }).up().c("unknown-session", {
                                    xmlns: "urn:xmpp:jingle:errors:1"
                                }), this.connection.send(s), !0
                            } else if (void 0 !== r) return s.attrs({
                                type: "error"
                            }), s.c("error", {
                                type: "cancel"
                            }).c("service-unavailable", {
                                xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                            }).up(), lr.warn("duplicate session id", t, e), this.connection.send(s), !0;
                            const o = window.performance.now(),
                                a = "focus" !== Xe.Strophe.getResourceFromJid(i),
                                c = $(e).find("jingle>json-message");
                            if (null == c ? void 0 : c.length) {
                                var d;
                                let t;
                                lr.info(`Found a JSON-encoded element in ${n}, translating to standard Jingle.`);
                                for (let n = 0; n < c.length; n++) t = pr(e, c[n]);
                                if (null === (d = t) || void 0 === d ? void 0 : d.size) {
                                    const e = [];
                                    for (const n of t.keys()) e.push(`${n}:[${t.get(n)}]`);
                                    lr.debug(`Received ${n} from ${i} with sources=${e.join(", ")}`)
                                }
                            }
                            switch (n) {
                                case "session-initiate": {
                                    lr.log("(TIME) received session-initiate:\t", o);
                                    const t = $(e).find("jingle>startmuted");
                                    if (a && lr.debug(`Received ${n} from ${i}`), null == t ? void 0 : t.length) {
                                        const e = t.attr(En),
                                            n = t.attr(Cn);
                                        this.eventEmitter.emit(Hn().START_MUTED_FROM_FOCUS, "true" === e, "true" === n)
                                    }
                                    const s = a ? this.p2pIceConfig : this.jvbIceConfig;
                                    r = new dr($(e).find("jingle").attr("sid"), $(e).attr("to"), i, this.connection, this.mediaConstraints, JSON.parse(JSON.stringify(s)), a, !1), this.sessions[r.sid] = r, this.eventEmitter.emit(Hn().CALL_INCOMING, r, $(e).find(">jingle"), o);
                                    break
                                }
                                case "session-accept": {
                                    const t = [],
                                        s = $(e).find("jingle>content");
                                    for (const e of s) {
                                        const n = $(e).find("description").attr("ssrc");
                                        n && t.push(n)
                                    }
                                    lr.debug(`Received ${n} from ${i} with ssrcs=${t}`), this.eventEmitter.emit(Hn().CALL_ACCEPTED, r, $(e).find(">jingle"));
                                    break
                                }
                                case "content-modify": {
                                    const t = $(e).find('jingle>content[name="video"]>max-frame-height');
                                    lr.debug(`Received ${n} from ${i} with a max-frame-height=${null==t?void 0:t.text()}`), r.modifyContents($(e).find(">jingle"));
                                    break
                                }
                                case "transport-info": {
                                    const t = fr($(e).find("jingle>content>transport"));
                                    lr.debug(`Received ${n} from ${i} for candidates=${t.join(", ")}`), this.eventEmitter.emit(Hn().TRANSPORT_INFO, r, $(e).find(">jingle"));
                                    break
                                }
                                case "session-terminate": {
                                    lr.log("terminating...", r.sid);
                                    let t = null,
                                        s = null;
                                    $(e).find(">jingle>reason").length && (t = $(e).find(">jingle>reason>:first")[0].tagName, s = $(e).find(">jingle>reason>text").text()), lr.debug(`Received ${n} from ${i} disconnect reason=${s}`), this.terminate(r.sid, t, s), this.eventEmitter.emit(Hn().CALL_ENDED, r, t, s);
                                    break
                                }
                                case "transport-replace": {
                                    var l;
                                    lr.info("(TIME) Start transport replace:\t", o);
                                    const t = $(e).find("jingle>content>transport"),
                                        s = fr(t),
                                        c = $(t).attr("ufrag"),
                                        d = $(t).attr("pwd"),
                                        h = null === (l = $(t).find(">fingerprint")) || void 0 === l ? void 0 : l.text();
                                    lr.debug(`Received ${n} from ${i} with iceUfrag=${c}, icePwd=${d}, DTLS fingerprint=${h}, candidates=${s.join(", ")}`), On.sendAnalytics(Tt("transport-replace.received", {
                                        p2p: a,
                                        value: o
                                    })), r.replaceTransport($(e).find(">jingle"), (() => {
                                        const e = window.performance.now();
                                        lr.info("(TIME) Transport replace success:\t", e), On.sendAnalytics(Tt("transport-replace.success", {
                                            p2p: a,
                                            value: e
                                        }))
                                    }), (e => {
                                        sn().callErrorHandler(e), lr.error("Transport replace failed", e), r.sendTransportReject()
                                    }));
                                    break
                                }
                                case "source-add":
                                    r.addRemoteStream($(e).find(">jingle>content"));
                                    break;
                                case "source-remove":
                                    r.removeRemoteStream($(e).find(">jingle>content"));
                                    break;
                                default:
                                    lr.warn("jingle action not implemented", n), s.attrs({
                                        type: "error"
                                    }), s.c("error", {
                                        type: "cancel"
                                    }).c("bad-request", {
                                        xmlns: "urn:ietf:params:xml:ns:xmpp-stanzas"
                                    }).up()
                            }
                            return this.connection.send(s), !0
                        }
                        newP2PJingleSession(e, t) {
                            const n = new dr($i().randomHexString(12), e, t, this.connection, this.mediaConstraints, this.p2pIceConfig, !0, !0);
                            return this.sessions[n.sid] = n, n
                        }
                        terminate(e, t, n) {
                            this.sessions.hasOwnProperty(e) && ("ended" !== this.sessions[e].state && this.sessions[e].onTerminated(t, n), delete this.sessions[e])
                        }
                        getStunAndTurnCredentials() {
                            this.connection.sendIQ((0, Xe.$iq)({
                                type: "get",
                                to: this.xmpp.options.hosts.domain
                            }).c("services", {
                                xmlns: "urn:xmpp:extdisco:2"
                            }), (e => this.onReceiveStunAndTurnCredentials(e)), (e => {
                                lr.warn("getting turn credentials with extdisco:2 failed, trying extdisco:1", e), this.connection.sendIQ((0, Xe.$iq)({
                                    type: "get",
                                    to: this.xmpp.options.hosts.domain
                                }).c("services", {
                                    xmlns: "urn:xmpp:extdisco:1"
                                }), (e => this.onReceiveStunAndTurnCredentials(e)), (e => {
                                    lr.warn("getting turn credentials failed", e), lr.warn("is mod_turncredentials or similar installed and configured?")
                                }))
                            }))
                        }
                        onReceiveStunAndTurnCredentials(e) {
                            const t = [];
                            $(e).find(">services>service").each(((e, n) => {
                                const i = {},
                                    s = (n = $(n)).attr("type");
                                switch (s) {
                                    case "stun":
                                        i.urls = `stun:${n.attr("host")}`, n.attr("port") && (i.urls += `:${n.attr("port")}`), t.push(i);
                                        break;
                                    case "turn":
                                    case "turns": {
                                        i.urls = `${s}:`, i.username = n.attr("username"), i.urls += n.attr("host"), n.attr("port") && (i.urls += `:${n.attr("port")}`);
                                        const e = n.attr("transport");
                                        e && "udp" !== e && (i.urls += `?transport=${e}`), i.credential = n.attr("password") || i.credential, t.push(i);
                                        break
                                    }
                                }
                            }));
                            const n = this.xmpp.options;
                            for (let e = t.length - 1; e > 0; e--) {
                                const n = Math.floor(Math.random() * (e + 1)),
                                    i = t[e];
                                t[e] = t[n], t[n] = i
                            }
                            let i;
                            return i = n.useTurnUdp ? e => e.urls.startsWith("turn") : e => e.urls.startsWith("turn") && e.urls.indexOf("transport=tcp") >= 0, this.jvbIceConfig.iceServers = t.filter(i), this.p2pIceConfig.iceServers = t, t.length > 0
                        }
                        getLog() {
                            const e = {};
                            return Object.keys(this.sessions).forEach((t => {
                                const n = this.sessions[t].peerconnection;
                                n && n.updateLog && (e[`jingle_${t}`] = {
                                    updateLog: n.updateLog,
                                    stats: n.stats,
                                    url: window.location.href
                                })
                            })), e
                        }
                    }
                    class _r extends Yi {
                        constructor() {
                            super(), this.log = []
                        }
                        init(e) {
                            super.init(e), this.connection.rawInput = this.logIncoming.bind(this), this.connection.rawOutput = this.logOutgoing.bind(this)
                        }
                        logIncoming(e) {
                            this.log.push([(new Date).getTime(), "incoming", e])
                        }
                        logOutgoing(e) {
                            this.log.push([(new Date).getTime(), "outgoing", e])
                        }
                    }
                    const vr = (0, f.getLogger)("modules/xmpp/strophe.rayo.js"),
                        yr = "urn:xmpp:rayo:1";
                    class Sr extends Yi {
                        init(e) {
                            super.init(e), this.connection.addHandler(this.onRayo.bind(this), yr, "iq", "set", null, null)
                        }
                        onRayo(e) {
                            vr.info("Rayo IQ", e)
                        }
                        dial(e, t, n, i, s) {
                            return new Promise(((r, o) => {
                                if (!s) return void o(new Error("Internal error!"));
                                const a = (0, Xe.$iq)({
                                    type: "set",
                                    to: s
                                });
                                a.c("dial", {
                                    xmlns: yr,
                                    to: e,
                                    from: t
                                }), a.c("header", {
                                    name: "JvbRoomName",
                                    value: n
                                }).up(), i && i.length && a.c("header", {
                                    name: "JvbRoomPassword",
                                    value: i
                                }).up(), this.connection.sendIQ(a, (e => {
                                    vr.info("Dial result ", e);
                                    const t = $(e).find("ref").attr("uri");
                                    this.callResource = t.substr("xmpp:".length), vr.info(`Received call resource: ${this.callResource}`), r()
                                }), (e => {
                                    vr.info("Dial error ", e), o(e)
                                }))
                            }))
                        }
                        hangup() {
                            return new Promise(((e, t) => {
                                if (!this.callResource) return t(new Error("No call in progress")), void vr.warn("No call in progress");
                                const n = (0, Xe.$iq)({
                                    type: "set",
                                    to: this.callResource
                                });
                                n.c("hangup", {
                                    xmlns: yr
                                }), this.connection.sendIQ(n, (t => {
                                    vr.info("Hangup result ", t), this.callResource = null, e()
                                }), (e => {
                                    vr.info("Hangup error ", e), this.callResource = null, t(new Error("Hangup error "))
                                }))
                            }))
                        }
                    }
                    const Er = (0, f.getLogger)("modules/xmpp/strophe.util.js");
                    let br = -1;
                    const Cr = /request id \d+.\d+ got 200/,
                        Tr = /request errored, status: (\d+), number of errors: \d+/,
                        Rr = (0, f.getLogger)("modules/xmpp/xmpp.js"),
                        Ar = /<failure.*><not-allowed\/><text>(.*)<\/text><\/failure>/gi;
                    const wr = [{
                            urls: "stun:meet-jit-si-turnrelay.jitsi.net:443"
                        }],
                        Pr = "type",
                        Ir = "http://jitsi.org/protocol/jigasi",
                        Mr = "https://jitsi.org/meet/e2ee";
                    class Dr extends Ti {
                        constructor(e, t) {
                            var n;
                            super(), this.connection = null, this.disconnectInProgress = !1, this.connectionTimes = {}, this.options = e, this.token = t, this.authenticatedUser = !1, Xe.Strophe.log = function(e, t) {
                                switch (Er.trace("Strophe", e, t), "string" == typeof t && -1 !== t.indexOf("Request ") && -1 !== t.indexOf("timed out (secondary), restarting") && (e = Xe.Strophe.LogLevel.WARN), e) {
                                    case Xe.Strophe.LogLevel.DEBUG:
                                        -1 !== br && Cr.test(t) && (Er.debug("Reset lastErrorStatus"), br = -1);
                                        break;
                                    case Xe.Strophe.LogLevel.WARN:
                                        Er.warn(`Strophe: ${t}`);
                                        const e = Tr.exec(t);
                                        e && 2 === e.length && (br = parseInt(e[1], 10), Er.debug(`lastErrorStatus set to: ${br}`));
                                        break;
                                    case Xe.Strophe.LogLevel.ERROR:
                                    case Xe.Strophe.LogLevel.FATAL:
                                        t = `Strophe: ${t}`, sn().callErrorHandler(new Error(t)), Er.error(t)
                                }
                            }, Xe.Strophe.getLastErrorStatus = function() {
                                return br
                            }, Xe.Strophe.getStatusString = function(e) {
                                switch (e) {
                                    case Xe.Strophe.Status.BINDREQUIRED:
                                        return "BINDREQUIRED";
                                    case Xe.Strophe.Status.ERROR:
                                        return "ERROR";
                                    case Xe.Strophe.Status.CONNECTING:
                                        return "CONNECTING";
                                    case Xe.Strophe.Status.CONNFAIL:
                                        return "CONNFAIL";
                                    case Xe.Strophe.Status.AUTHENTICATING:
                                        return "AUTHENTICATING";
                                    case Xe.Strophe.Status.AUTHFAIL:
                                        return "AUTHFAIL";
                                    case Xe.Strophe.Status.CONNECTED:
                                        return "CONNECTED";
                                    case Xe.Strophe.Status.DISCONNECTED:
                                        return "DISCONNECTED";
                                    case Xe.Strophe.Status.DISCONNECTING:
                                        return "DISCONNECTING";
                                    case Xe.Strophe.Status.ATTACHED:
                                        return "ATTACHED";
                                    default:
                                        return "unknown"
                                }
                            }, Xe.Strophe.addConnectionPlugin("logger", new _r);
                            const i = e.xmppPing || {};
                            i.domain = e.hosts.domain, this.connection = function({
                                enableWebsocketResume: e,
                                serviceUrl: t = "/http-bind",
                                shard: n,
                                token: i,
                                websocketKeepAlive: s,
                                websocketKeepAliveUrl: r,
                                xmppPing: o
                            }) {
                                return i && (t += `${-1===t.indexOf("?")?"?":"&"}token=${i}`), new is({
                                    enableWebsocketResume: e,
                                    serviceUrl: t,
                                    websocketKeepAlive: s,
                                    websocketKeepAliveUrl: r,
                                    xmppPing: o,
                                    shard: n
                                })
                            }({
                                enableWebsocketResume: e.enableWebsocketResume,
                                serviceUrl: e.serviceUrl || e.bosh,
                                token: t,
                                websocketKeepAlive: e.websocketKeepAlive,
                                websocketKeepAliveUrl: e.websocketKeepAliveUrl,
                                xmppPing: i,
                                shard: null === (n = e.deploymentInfo) || void 0 === n ? void 0 : n.shard
                            }), this.connection.on(is.Events.CONN_SHARD_CHANGED, (() => {
                                const e = {
                                    shard_changed: !0,
                                    suspend_time: this.connection.ping.getPingSuspendTime(),
                                    time_since_last_success: this.connection.getTimeSinceLastSuccess()
                                };
                                this.eventEmitter.emit(ci, ui, void 0, void 0, e)
                            })), this._initStrophePlugins(), this.caps = new Hi(this.connection, "https://jitsi.org/jitsi-meet"), this.initFeaturesList(), $(window).on("beforeunload unload", (e => {
                                this.disconnect(e).catch((() => {}))
                            }))
                        }
                        initFeaturesList() {
                            this.caps.addFeature("urn:xmpp:jingle:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:1"), this.caps.addFeature("urn:xmpp:jingle:transports:ice-udp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:dtls:0"), this.caps.addFeature("urn:xmpp:jingle:transports:dtls-sctp:1"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:audio"), this.caps.addFeature("urn:xmpp:jingle:apps:rtp:video"), this.caps.addFeature("http://jitsi.org/json-encoded-sources"), this.options.disableRtx || Qt.isFirefox() && Qt.isVersionLessThan(94) || this.caps.addFeature("urn:ietf:rfc:4588"), !0 === this.options.enableOpusRed && Qt.supportsAudioRed() && this.caps.addFeature("http://jitsi.org/opus-red"), (void 0 === this.options.enableRemb || this.options.enableRemb) && this.caps.addFeature("http://jitsi.org/remb"), Qt.isFirefox() || void 0 !== this.options.enableTcc && !this.options.enableTcc || this.caps.addFeature("http://jitsi.org/tcc"), this.caps.addFeature("urn:ietf:rfc:5761"), this.caps.addFeature("urn:ietf:rfc:5888"), Qt.isChromiumBased() && !0 === this.options.enableLipSync && (Rr.info("Lip-sync enabled !"), this.caps.addFeature("http://jitsi.org/meet/lipsync")), this.connection.rayo && this.caps.addFeature("urn:xmpp:rayo:client:1"), Fi.isSupported(this.options) && this.caps.addFeature(Mr, !1, !0)
                        }
                        getConnection() {
                            return this.connection
                        }
                        connectionHandler(e = {}, t, n) {
                            const i = window.performance.now(),
                                s = Xe.Strophe.getStatusString(t).toLowerCase();
                            if (this.connectionTimes[s] = i, Rr.log(`(TIME) Strophe ${s}${n?`[${n}]`:""}:\t`, i), this.eventEmitter.emit(Hn().CONNECTION_STATUS_CHANGED, e, t, n), t === Xe.Strophe.Status.CONNECTED || t === Xe.Strophe.Status.ATTACHED) this._sysMessageHandler && (this.connection._stropheConn.deleteHandler(this._sysMessageHandler), this._sysMessageHandler = null), this.sendDiscoInfo && this.connection.jingle.getStunAndTurnCredentials(), Rr.info(`My Jabber ID: ${this.connection.jid}`), this._resetState(), this.sendDiscoInfo && this.caps.getFeaturesAndIdentities(this.options.hosts.domain).then((({
                                features: e,
                                identities: t
                            }) => {
                                e.has(Xe.Strophe.NS.PING) || Rr.error(`Ping NOT supported by ${this.options.hosts.domain} - please enable ping in your XMPP server config`), this._processDiscoInfoIdentities(t, void 0)
                            })).catch((e => {
                                const t = "Feature discovery error";
                                sn().callErrorHandler(new Error(`${t}: ${e}`)), Rr.error(t, e)
                            })), this.sendDiscoInfo = !1, e.password && (this.authenticatedUser = !0), this.connection && this.connection.connected && Xe.Strophe.getResourceFromJid(this.connection.jid) && this.eventEmitter.emit(ai, Xe.Strophe.getResourceFromJid(this.connection.jid));
                            else if (t === Xe.Strophe.Status.CONNFAIL) "x-strophe-bad-non-anon-jid" === n ? this.anonymousConnectionFailed = !0 : this.connectionFailed = !0, this.lastErrorMsg = n, "giving-up" === n && this.eventEmitter.emit(ci, ui, n);
                            else if (t === Xe.Strophe.Status.ERROR) this.lastErrorMsg = n;
                            else if (t === Xe.Strophe.Status.DISCONNECTED) {
                                this.connection.ping.stopInterval();
                                const e = Boolean(this.disconnectInProgress),
                                    t = n || this.lastErrorMsg;
                                if (this.anonymousConnectionFailed) this.eventEmitter.emit(ci, pi);
                                else if (this.connectionFailed) this.eventEmitter.emit(ci, ui, t, void 0, this._getConnectionFailedReasonDetails());
                                else if (e) this.eventEmitter.emit(oi, t);
                                else {
                                    Rr.error("XMPP connection dropped!");
                                    const e = Xe.Strophe.getLastErrorStatus();
                                    e >= 500 && e < 600 ? this.eventEmitter.emit(ci, mi, t || "server-error", void 0, this._getConnectionFailedReasonDetails()) : this.eventEmitter.emit(ci, hi, t || "connection-dropped-error", void 0, this._getConnectionFailedReasonDetails())
                                }
                            } else if (t === Xe.Strophe.Status.AUTHFAIL) {
                                const t = this.getConnection().getLastFailedMessage();
                                this.eventEmitter.emit(ci, pi, n || this._parseConnectionFailedMessage(t), e)
                            }
                        }
                        _processDiscoInfoIdentities(e, t) {
                            e.forEach((e => {
                                if ("av_moderation" === e.type && (this.avModerationComponentAddress = e.name), "speakerstats" === e.type && (this.speakerStatsComponentAddress = e.name), "conference_duration" === e.type && (this.conferenceDurationComponentAddress = e.name), "lobbyrooms" === e.type) {
                                    this.lobbySupported = !0;
                                    const n = e => {
                                        e.forEach((e => {
                                            e.endsWith("#displayname_required") && this.eventEmitter.emit(li)
                                        }))
                                    };
                                    t ? n(t) : e.name && this.caps.getFeaturesAndIdentities(e.name, e.type).then((({
                                        features: e
                                    }) => n(e))).catch((e => Rr.warn("Error getting features from lobby.", e && e.message)))
                                }
                                "shard" === e.type && (this.options.deploymentInfo.shard = this.connection.shard = e.name), "region" === e.type && (this.options.deploymentInfo.region = this.connection.region = e.name)
                            })), (this.avModerationComponentAddress || this.speakerStatsComponentAddress || this.conferenceDurationComponentAddress) && this.connection.addHandler(this._onPrivateMessage.bind(this), null, "message", null, null)
                        }
                        _parseConnectionFailedMessage(e) {
                            if (!e) return null;
                            const t = Ar.exec(e);
                            return t ? t[1] : null
                        }
                        _connect(e, t) {
                            this._resetState(), this.sendDiscoInfo = !0, this.connection._stropheConn && this.connection._stropheConn._addSysHandler ? this._sysMessageHandler = this.connection._stropheConn._addSysHandler(this._onSystemMessage.bind(this), null, "message") : Rr.warn("Cannot attach strophe system handler, jiconop cannot operate"), this.connection.connect(e, t, this.connectionHandler.bind(this, {
                                jid: e,
                                password: t
                            }))
                        }
                        _onSystemMessage(e) {
                            if (0 === $(e).find(">services").length && 0 === $(e).find(">query").length) return;
                            this.sendDiscoInfo = !1;
                            const t = this.connection.jingle.onReceiveStunAndTurnCredentials(e),
                                {
                                    features: n,
                                    identities: i
                                } = Vi(e);
                            this._processDiscoInfoIdentities(i, n), (t || i.size > 0 || n.size > 0) && (this.connection._stropheConn.deleteHandler(this._sysMessageHandler), this._sysMessageHandler = null)
                        }
                        attach(e) {
                            this._resetState(), this.sendDiscoInfo = !0;
                            const t = this.connectionTimes.attaching = window.performance.now();
                            Rr.log("(TIME) Strophe Attaching:\t", t), this.connection.attach(e.jid, e.sid, parseInt(e.rid, 10) + 1, this.connectionHandler.bind(this, {
                                jid: e.jid,
                                password: e.password
                            }))
                        }
                        _resetState() {
                            this.anonymousConnectionFailed = !1, this.connectionFailed = !1, this.lastErrorMsg = void 0, this.disconnectInProgress = void 0
                        }
                        connect(e, t) {
                            if (!e) {
                                const {
                                    anonymousdomain: t,
                                    domain: n
                                } = this.options.hosts;
                                let i = t || n;
                                const {
                                    location: s
                                } = window;
                                if (t) {
                                    const e = s && s.search;
                                    (e && -1 !== e.indexOf("login=true") || this.token) && (i = n)
                                }
                                e = i || s && s.hostname
                            }
                            return this._connect(e, t)
                        }
                        createRoom(e, t, n) {
                            let i = `${this.getRoomJid(e,t.customDomain)}/`;
                            const s = n ? n(this.connection.jid, this.authenticatedUser) : $i().randomHexString(8).toLowerCase();
                            return Rr.info(`JID ${this.connection.jid} using MUC nickname ${s}`), i += s, this.connection.emuc.createRoom(i, null, t)
                        }
                        getRoomJid(e, t) {
                            return `${e}@${t||this.options.hosts.muc.toLowerCase()}`
                        }
                        isRoomCreated(e, t) {
                            return this.connection.emuc.isRoomCreated(this.getRoomJid(e, t))
                        }
                        getJid() {
                            return this.connection.jid
                        }
                        getJingleLog() {
                            const e = this.connection.jingle;
                            return e ? e.getLog() : {}
                        }
                        getXmppLog() {
                            return (this.connection.logger || {}).log || null
                        }
                        dial(...e) {
                            this.connection.rayo.dial(...e)
                        }
                        ping(e) {
                            return new Promise(((t, n) => {
                                this.connection.ping.ping(this.connection.pingDomain, t, n, e)
                            }))
                        }
                        getSessions() {
                            return this.connection.jingle.sessions
                        }
                        disconnect(e) {
                            return this.disconnectInProgress ? this.disconnectInProgress : this.connection ? (this.disconnectInProgress = new Promise((e => {
                                const t = (n, i) => {
                                    i === Xe.Strophe.Status.DISCONNECTED && (e(), this.eventEmitter.removeListener(Hn().CONNECTION_STATUS_CHANGED, t))
                                };
                                this.eventEmitter.on(Hn().CONNECTION_STATUS_CHANGED, t)
                            })), this._cleanupXmppConnection(e), this.disconnectInProgress) : Promise.resolve()
                        }
                        _cleanupXmppConnection(e) {
                            if (!this.connection.isUsingWebSocket && this.connection.flush(), !this.connection.isUsingWebSocket && null != e) {
                                const t = e.type;
                                if (("beforeunload" === t || "unload" === t) && (this.connection.options.sync = !0, this.connection.sendUnavailableBeacon())) return
                            }
                            this.connection.disconnect(), !0 !== this.connection.options.sync && this.connection.flush()
                        }
                        _initStrophePlugins() {
                            const e = {
                                    jvb: {
                                        iceServers: []
                                    },
                                    p2p: {
                                        iceServers: []
                                    }
                                },
                                t = this.options.p2p && this.options.p2p.stunServers || wr;
                            Array.isArray(t) && (Rr.info("P2P STUN servers: ", t), e.p2p.iceServers = t), this.options.p2p && this.options.p2p.iceTransportPolicy && (Rr.info("P2P ICE transport policy: ", this.options.p2p.iceTransportPolicy), e.p2p.iceTransportPolicy = this.options.p2p.iceTransportPolicy), this.connection.addConnectionPlugin("emuc", new Ms(this)), this.connection.addConnectionPlugin("jingle", new gr(this, this.eventEmitter, e)), this.connection.addConnectionPlugin("rayo", new Sr)
                        }
                        _getConnectionFailedReasonDetails() {
                            const e = {};
                            if (this.options.deploymentInfo && this.options.deploymentInfo.shard && this.connection.lastResponseHeaders) {
                                const t = this.connection.lastResponseHeaders.trim().split(/[\r\n]+/),
                                    n = {};
                                t.forEach((e => {
                                    const t = e.split(": "),
                                        i = t.shift(),
                                        s = t.join(": ");
                                    n[i] = s
                                })), e.shard_changed = this.options.deploymentInfo.shard !== n["x-jitsi-shard"]
                            }
                            return e.suspend_time = this.connection.ping.getPingSuspendTime(), e.time_since_last_success = this.connection.getTimeSinceLastSuccess(), e
                        }
                        sendDominantSpeakerEvent(e) {
                            if (!this.speakerStatsComponentAddress || !e) return;
                            const t = (0, Xe.$msg)({
                                to: this.speakerStatsComponentAddress
                            });
                            t.c("speakerstats", {
                                xmlns: "http://jitsi.org/jitmeet",
                                room: e
                            }).up(), this.connection.send(t)
                        }
                        tryParseJSONAndVerify(e) {
                            if (!e) return !1;
                            try {
                                const t = JSON.parse(e);
                                if (t && "object" == typeof t) {
                                    const e = t[Pr];
                                    if (void 0 !== e) return t;
                                    Rr.debug("parsing valid json but does not have correct structure", "topic: ", e)
                                }
                            } catch (t) {
                                return Rr.error(`Error parsing json ${e}`, t), !1
                            }
                            return !1
                        }
                        _onPrivateMessage(e) {
                            const t = e.getAttribute("from");
                            if (t !== this.speakerStatsComponentAddress && t !== this.conferenceDurationComponentAddress && t !== this.avModerationComponentAddress) return !0;
                            const n = $(e).find(">json-message").text(),
                                i = this.tryParseJSONAndVerify(n);
                            return !i || ("speakerstats" === i[Pr] && i.users ? this.eventEmitter.emit(Hn().SPEAKER_STATS_RECEIVED, i.users) : "conference_duration" === i[Pr] && i.created_timestamp ? this.eventEmitter.emit(Hn().CONFERENCE_TIMESTAMP_RECEIVED, i.created_timestamp) : "av_moderation" === i[Pr] && this.eventEmitter.emit(Hn().AV_MODERATION_RECEIVED, i), !0)
                        }
                    }

                    function Nr({
                        id: e,
                        password: t,
                        onCreateResource: n,
                        onLoginSuccessful: i,
                        roomPassword: s
                    }) {
                        let r, o = !1,
                            a = new Dr(this.connection.options);
                        const c = new Promise(((c, d) => {
                            r = d, a.addListener(oi, (() => {
                                a = void 0
                            })), a.addListener(ai, (() => {
                                o || (i && i(), a.createRoom(this.options.name, this.options.config, n).moderator.authenticate().then((() => {
                                    a && a.disconnect(), o || (this.join(s), c())
                                })).catch((({
                                    error: e,
                                    message: t
                                }) => {
                                    a.disconnect(), d({
                                        authenticationError: e,
                                        message: t
                                    })
                                })))
                            })), a.addListener(ci, ((e, t, n) => {
                                d({
                                    connectionError: e,
                                    credentials: n,
                                    message: t
                                }), a = void 0
                            })), o || a.connect(e, t)
                        }));
                        return c.cancel = () => {
                            o = !0, r({}), a && a.disconnect()
                        }, c
                    }
                    const kr = (0, f.getLogger)("modules/RTC/CodecSelection.js");
                    class Or {
                        constructor(e, t) {
                            this.conference = e, this.options = t, this.disabledCodec = t.disabledCodec === Os().VP8 ? void 0 : this._getCodecMimeType(t.disabledCodec);
                            const n = this._getCodecMimeType(t.jvbCodec),
                                i = this._getCodecMimeType(t.p2pCodec);
                            this.jvbPreferredCodec = n && this._isCodecSupported(n) ? n : Os().VP8, this.p2pPreferredCodec = i && this._isCodecSupported(i) ? i : Os().VP8, kr.debug(`Codec preferences for the conference are JVB: ${this.jvbPreferredCodec},\n            P2P: ${this.p2pPreferredCodec}`), Qt.isFirefox() && this.jvbPreferredCodec === Os().VP9 && (this.jvbPreferredCodec = Os().VP8), this.conference.on(Oe, (() => this._selectPreferredCodec())), this.conference.on(Le, (() => this._selectPreferredCodec())), this.conference.on(ae, (e => this._onMediaSessionStared(e)))
                        }
                        _getCodecMimeType(e) {
                            return "string" == typeof e ? Object.values(Os()).find((t => t === e.toLowerCase())) : null
                        }
                        _isCodecSupported(e) {
                            return !(!Qt.isFirefox() && !Qt.isReactNative()) || window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("video").codecs.some((t => t.mimeType.toLowerCase() === `video/${e}`))
                        }
                        _onMediaSessionStared(e) {
                            const t = e.isP2P ? this.p2pPreferredCodec : this.jvbPreferredCodec,
                                n = this.disabledCodec && this._isCodecSupported(this.disabledCodec) ? this.disabledCodec : null;
                            this._selectPreferredCodec(e, t, n)
                        }
                        _selectPreferredCodec(e = null, t = null, n = null) {
                            const i = e || this.conference.jvbJingleSession,
                                s = t || this.jvbPreferredCodec;
                            let r = s;
                            if (i && !i.isP2P && !this.options.enforcePreferredCodec) {
                                const e = this.conference.getParticipants().map((e => e.getId()));
                                for (const t of e) {
                                    const e = i.signalingLayer.getPeerMediaInfo(t, Cn),
                                        n = null == e ? void 0 : e.codecType;
                                    !n || n === s || Qt.isFirefox() && n === Os().VP9 || (r = n)
                                }
                            }
                            i && i.setVideoCodecs(r, n)
                        }
                        getPreferredCodec() {
                            return this.jvbPreferredCodec
                        }
                    }
                    var Lr = n(8878),
                        xr = n.n(Lr);

                    function Fr(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? Object(arguments[t]) : {},
                                i = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), i.forEach((function(t) {
                                jr(e, t, n[t])
                            }))
                        }
                        return e
                    }

                    function jr(e, t, n) {
                        return t in e ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = n, e
                    }
                    const $r = (0, f.getLogger)("modules/RTC/BridgeChannel.js");
                    class Br {
                        constructor(e, t, n) {
                            if (!e && !t) throw new TypeError("At least peerconnection or wsUrl must be given");
                            if (e && t) throw new TypeError("Just one of peerconnection or wsUrl must be given");
                            if (e ? $r.debug("constructor() with peerconnection") : $r.debug(`constructor() with wsUrl:"${t}"`), this._channel = null, this._eventEmitter = n, this._mode = null, this._areRetriesEnabled = !1, this._closedFromClient = !1, e) {
                                const t = e.createDataChannel("JVB data channel", {
                                    protocol: "http://jitsi.org/protocols/colibri"
                                });
                                this._handleChannel(t), this._mode = "datachannel"
                            } else t && (this._areRetriesEnabled = !0, this._wsUrl = t, this._initWebSocket())
                        }
                        _initWebSocket() {
                            const e = new WebSocket(this._wsUrl);
                            this._handleChannel(e), this._mode = "websocket"
                        }
                        _startConnectionRetries() {
                            let e = 1;
                            const t = () => {
                                this.isOpen() || (this._initWebSocket(this._wsUrl), e = Math.min(2 * e, 60), this._retryTimeout = setTimeout(t, 1e3 * e))
                            };
                            this._retryTimeout = setTimeout(t, 1e3 * e)
                        }
                        _stopConnectionRetries() {
                            this._retryTimeout && (clearTimeout(this._retryTimeout), this._retryTimeout = void 0)
                        }
                        _retryWebSocketConnection(e) {
                            if (!this._areRetriesEnabled) return;
                            const {
                                code: t,
                                reason: n
                            } = e;
                            On.sendAnalytics(function(e, t) {
                                return {
                                    type: gt,
                                    action: "bridge-channel.error",
                                    attributes: {
                                        code: e,
                                        reason: t
                                    }
                                }
                            }(t, n)), this._areRetriesEnabled = !1, this._eventEmitter.once(jn().DATA_CHANNEL_OPEN, (() => {
                                this._stopConnectionRetries(), this._areRetriesEnabled = !0
                            })), this._startConnectionRetries()
                        }
                        get mode() {
                            return this._mode
                        }
                        close() {
                            if (this._closedFromClient = !0, this._stopConnectionRetries(), this._areRetriesEnabled = !1, this._channel) {
                                try {
                                    this._channel.close()
                                } catch (e) {}
                                this._channel = null
                            }
                        }
                        isOpen() {
                            return this._channel && ("open" === this._channel.readyState || this._channel.readyState === WebSocket.OPEN)
                        }
                        sendEndpointStatsMessage(e) {
                            this._send(Fr({
                                colibriClass: "EndpointStats"
                            }, e))
                        }
                        sendMessage(e, t) {
                            this._send({
                                colibriClass: "EndpointMessage",
                                msgPayload: t,
                                to: e
                            })
                        }
                        sendSetLastNMessage(e) {
                            $r.log(`Sending lastN=${e}.`), this._send({
                                colibriClass: "LastNChangedEvent",
                                lastN: e
                            })
                        }
                        sendSelectedEndpointsMessage(e) {
                            $r.log(`Sending selected endpoints: ${e}.`), this._send({
                                colibriClass: "SelectedEndpointsChangedEvent",
                                selectedEndpoints: e
                            })
                        }
                        sendReceiverVideoConstraintMessage(e) {
                            $r.log(`Sending ReceiverVideoConstraint with maxFrameHeight=${e}px`), this._send({
                                colibriClass: "ReceiverVideoConstraint",
                                maxFrameHeight: e
                            })
                        }
                        sendNewReceiverVideoConstraintsMessage(e) {
                            $r.log(`Sending ReceiverVideoConstraints with ${JSON.stringify(e)}`), this._send(Fr({
                                colibriClass: "ReceiverVideoConstraints"
                            }, e))
                        }
                        sendVideoTypeMessage(e) {
                            $r.debug(`Sending VideoTypeMessage with video type as ${e}`), this._send({
                                colibriClass: "VideoTypeMessage",
                                videoType: e
                            })
                        }
                        _handleChannel(e) {
                            const t = this._eventEmitter;
                            e.onopen = () => {
                                $r.info(`${this._mode} channel opened`), t.emit(jn().DATA_CHANNEL_OPEN)
                            }, e.onerror = e => {
                                "websocket" !== this._mode && $r.error(`Channel error: ${e.message}`)
                            }, e.onmessage = ({
                                data: e
                            }) => {
                                let n;
                                try {
                                    n = JSON.parse(e)
                                } catch (t) {
                                    return sn().callErrorHandler(t), void $r.error("Failed to parse channel message as JSON: ", e, t)
                                }
                                const i = n.colibriClass;
                                switch (i) {
                                    case "DominantSpeakerEndpointChangeEvent": {
                                        const {
                                            dominantSpeakerEndpoint: e,
                                            previousSpeakers: i = []
                                        } = n;
                                        $r.debug(`Dominant speaker: ${e}, previous speakers: ${i}`), t.emit(jn().DOMINANT_SPEAKER_CHANGED, e, i);
                                        break
                                    }
                                    case "EndpointConnectivityStatusChangeEvent": {
                                        const e = n.endpoint,
                                            i = "true" === n.active;
                                        $r.info(`Endpoint connection status changed: ${e} active=${i}`), t.emit(jn().ENDPOINT_CONN_STATUS_CHANGED, e, i);
                                        break
                                    }
                                    case "EndpointMessage":
                                        t.emit(jn().ENDPOINT_MESSAGE_RECEIVED, n.from, n.msgPayload);
                                        break;
                                    case "EndpointStats":
                                        t.emit(jn().ENDPOINT_STATS_RECEIVED, n.from, n);
                                        break;
                                    case "LastNEndpointsChangeEvent": {
                                        const e = n.lastNEndpoints;
                                        $r.info(`New forwarded endpoints: ${e}`), t.emit(jn().LASTN_ENDPOINT_CHANGED, e);
                                        break
                                    }
                                    case "SenderVideoConstraints": {
                                        const e = n.videoConstraints;
                                        e && ($r.info(`SenderVideoConstraints: ${JSON.stringify(e)}`), t.emit(jn().SENDER_VIDEO_CONSTRAINTS_CHANGED, e));
                                        break
                                    }
                                    case "ServerHello":
                                        $r.info(`Received ServerHello, version=${n.version}.`);
                                        break;
                                    default:
                                        $r.debug("Channel JSON-formatted message: ", n), t.emit(`rtc.datachannel.${i}`, n)
                                }
                            }, e.onclose = e => {
                                $r.info("Channel closed by " + (this._closedFromClient ? "client" : "server")), "websocket" === this._mode && (this._closedFromClient || ($r.error(`Channel closed: ${e.code} ${e.reason}`), this._retryWebSocketConnection(e))), this._channel = null
                            }, this._channel = e
                        }
                        _send(e) {
                            const t = this._channel;
                            if (!this.isOpen()) throw $r.error("Bridge Channel send: no opened channel."), new Error("No opened channel");
                            t.send(JSON.stringify(e))
                        }
                    }
                    var Jr = n(8774),
                        Ur = n.n(Jr),
                        Vr = n(4276),
                        Hr = n.n(Vr),
                        Gr = n(1507),
                        qr = n.n(Gr);
                    const Kr = (0, f.getLogger)("modules/RTC/RTCUtils.js");
                    Qt.usesAdapter() && n(740);
                    const zr = new(ze()),
                        Wr = {
                            video: {
                                height: {
                                    ideal: 720,
                                    max: 720,
                                    min: 180
                                },
                                width: {
                                    ideal: 1280,
                                    max: 1280,
                                    min: 320
                                }
                            }
                        };
                    let Qr = "default",
                        Xr = !1,
                        Yr = !1,
                        Zr = !1,
                        eo = !1,
                        to = !1,
                        no = null;
                    const io = document.createElement("audio"),
                        so = void 0 !== io.setSinkId;
                    let ro, oo = [];

                    function ao() {}

                    function co(e, t) {
                        const n = Boolean(t) && t.getAudioTracks().length > 0,
                            i = Boolean(t) && t.getVideoTracks().length > 0,
                            s = {}; - 1 !== e.indexOf("video") && (s.video = i), -1 !== e.indexOf("audio") && (s.audio = n), zr.emit(jn().PERMISSIONS_CHANGED, s)
                    }

                    function lo(e) {
                        const t = e.filter((e => "audioinput" === e.kind)).length,
                            n = e.filter((e => "audiooutput" === e.kind)).length,
                            i = e.filter((e => "videoinput" === e.kind)).length,
                            s = e.filter((e => "videooutput" === e.kind)).length;
                        e.forEach((e => {
                            const r = {
                                audio_input_device_count: t,
                                audio_output_device_count: n,
                                video_input_device_count: i,
                                video_output_device_count: s,
                                device_id: e.deviceId,
                                device_group_id: e.groupId,
                                device_kind: e.kind,
                                device_label: e.label
                            };
                            On.sendAnalytics("available.device", r)
                        }))
                    }

                    function ho(e) {
                        (function(e) {
                            return e.length !== oo.length || e.map(t).sort().join("") !== oo.map(t).sort().join("");

                            function t(e) {
                                return JSON.stringify({
                                    kind: e.kind,
                                    deviceId: e.deviceId,
                                    groupId: e.groupId,
                                    label: e.label,
                                    facing: e.facing
                                })
                            }
                        })(e) && (oo = e.slice(0), Kr.info("list of media devices has changed:", oo), lo(oo), zr.emit(jn().DEVICE_LIST_WILL_CHANGE, oo), zr.emit(jn().DEVICE_LIST_CHANGED, oo))
                    }
                    const uo = new class extends Ti {
                            constructor() {
                                super(zr)
                            }
                            init(e = {}) {
                                var t, n;
                                "boolean" == typeof e.disableAEC && (Zr = e.disableAEC, Kr.info(`Disable AEC: ${Zr}`)), "boolean" == typeof e.disableNS && (eo = e.disableNS, Kr.info(`Disable NS: ${eo}`)), "boolean" == typeof e.disableAP && (Yr = e.disableAP, Kr.info(`Disable AP: ${Yr}`)), "boolean" == typeof e.disableAGC && (to = e.disableAGC, Kr.info(`Disable AGC: ${to}`)), "boolean" == typeof(null === (t = e.audioQuality) || void 0 === t ? void 0 : t.stereo) && (no = e.audioQuality.stereo, Kr.info(`Stereo: ${no}`)), window.clearInterval(ro), ro = void 0, Qt.isReactNative() ? (this.RTCPeerConnectionType = RTCPeerConnection, this.attachMediaStream = void 0, this.getStreamID = function({
                                    id: e
                                }) {
                                    return "number" == typeof e ? e : Js.filterSpecialChars(e)
                                }, this.getTrackID = ({
                                    id: e
                                }) => e) : (this.RTCPeerConnectionType = RTCPeerConnection, this.attachMediaStream = (n = (e, t) => {
                                    e && (e.srcObject = t)
                                }, function(e, t) {
                                    const i = n.apply(uo, arguments);
                                    return t && uo.isDeviceChangeAvailable("output") && t.getAudioTracks && t.getAudioTracks().length && Xr && e.setSinkId(uo.getAudioOutputDevice()).catch((function(t) {
                                        const n = new pt(t, null, ["audiooutput"]);
                                        sn().callUnhandledRejectionHandler({
                                            promise: this,
                                            reason: n
                                        }), Kr.warn("Failed to set audio output device for the element. Default audio output device will be used instead", e, n)
                                    })), i
                                }), this.getStreamID = ({
                                    id: e
                                }) => e, this.getTrackID = ({
                                    id: e
                                }) => e), this.pcConstraints = Qt.isChromiumBased() || Qt.isReactNative() ? {
                                    optional: [{
                                        googScreencastMinBitrate: 100
                                    }, {
                                        googCpuOveruseDetection: !0
                                    }]
                                } : {}, js.init(e), this.isDeviceListAvailable() && this.enumerateDevices((e => {
                                    oo = e.slice(0), Kr.debug("Available devices: ", oo), lo(oo), zr.emit(jn().DEVICE_LIST_AVAILABLE, oo), Qt.supportsDeviceChangeEvent() ? navigator.mediaDevices.addEventListener("devicechange", (() => this.enumerateDevices(ao))) : ro = window.setInterval((() => this.enumerateDevices(ao)), 3e3)
                                }))
                            }
                            enumerateDevices(e) {
                                navigator.mediaDevices.enumerateDevices().then((t => {
                                    ho(t), e(t)
                                })).catch((t => {
                                    Kr.warn(`Failed to  enumerate devices. ${t}`), ho([]), e([])
                                }))
                            }
                            _getUserMedia(e, t = {}, n = 0) {
                                return new Promise(((i, s) => {
                                    let r, o = !1;
                                    "number" == typeof n && !isNaN(n) && n > 0 && (r = setTimeout((() => {
                                        o = !0, r = void 0, s(new pt(at))
                                    }), n)), navigator.mediaDevices.getUserMedia(t).then((t => {
                                        Kr.log("onUserMediaSuccess"), co(e, t), o || (void 0 !== r && clearTimeout(r), i(t))
                                    })).catch((n => {
                                        Kr.warn(`Failed to get access to local media. ${n} ${JSON.stringify(t)}`);
                                        const i = new pt(n, t, e);
                                        o || (void 0 !== r && clearTimeout(r), s(n)), i.name === st && co(e, void 0)
                                    }))
                                }))
                            }
                            _getDesktopMedia() {
                                return js.isSupported() ? new Promise(((e, t) => {
                                    js.obtainStream((t => {
                                        e(t)
                                    }), (e => {
                                        t(e)
                                    }))
                                })) : Promise.reject(new Error("Desktop sharing is not supported!"))
                            }
                            _getMissingTracks(e = [], t) {
                                const n = [],
                                    i = e.includes("audio"),
                                    s = t && t.getAudioTracks().length > 0;
                                i && !s && n.push("audio");
                                const r = e.includes("video"),
                                    o = t && t.getVideoTracks().length > 0;
                                return r && !o && n.push("video"), n
                            }
                            obtainAudioAndVideoPermissions(e) {
                                const {
                                    timeout: t
                                } = e, n = function(e, t) {
                                    if (null == e) return {};
                                    var n, i, s = function(e, t) {
                                        if (null == e) return {};
                                        var n, i, s = {},
                                            r = Object.keys(e);
                                        for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || (s[n] = e[n]);
                                        return s
                                    }(e, t);
                                    if (Object.getOwnPropertySymbols) {
                                        var r = Object.getOwnPropertySymbols(e);
                                        for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (s[n] = e[n])
                                    }
                                    return s
                                }(e, ["timeout"]), i = [], s = function() {
                                    if (-1 === (n.devices || []).indexOf("desktop")) return Promise.resolve();
                                    const {
                                        desktopSharingSourceDevice: e
                                    } = n;
                                    if (e) {
                                        const n = oo && oo.find((t => "videoinput" === t.kind && (t.deviceId === e || t.label === e)));
                                        if (!n) return Promise.reject(new pt({
                                            name: "ConstraintNotSatisfiedError"
                                        }, {}, [e]));
                                        const i = ["video"],
                                            s = {
                                                video: {
                                                    deviceId: n.deviceId
                                                }
                                            };
                                        return this._getUserMedia(i, s, t).then((e => ({
                                            sourceType: "device",
                                            stream: e
                                        })))
                                    }
                                    return this._getDesktopMedia()
                                }.bind(this), r = function() {
                                    const e = (n.devices || ["audio", "video"]).filter((e => "audio" === e || "video" === e));
                                    if (!e.length) return Promise.resolve();
                                    const i = function(e = [], t = {}) {
                                        const n = Hr()(t.constraints || Wr);
                                        if (e.indexOf("video") >= 0) {
                                            if (qr()[t.resolution]) {
                                                const e = qr()[t.resolution];
                                                n.video.height = {
                                                    ideal: e.height
                                                }, n.video.width = {
                                                    ideal: e.width
                                                }
                                            }
                                            if (n.video || (n.video = {}), Qt.isWebKitBased() && (n.video.height && n.video.height.ideal ? n.video.height = {
                                                    ideal: n.video.height.ideal
                                                } : Kr.warn("Ideal camera height missing, camera may not start properly"), n.video.width && n.video.width.ideal ? n.video.width = {
                                                    ideal: n.video.width.ideal
                                                } : Kr.warn("Ideal camera width missing, camera may not start properly")), t.cameraDeviceId) n.video.deviceId = t.cameraDeviceId;
                                            else {
                                                const e = t.facingMode || Ur().USER;
                                                n.video.facingMode = e
                                            }
                                        } else n.video = !1;
                                        return e.indexOf("audio") >= 0 ? (n.audio && "boolean" != typeof n.audio || (n.audio = {}), n.audio = {
                                            autoGainControl: !to && !Yr,
                                            deviceId: t.micDeviceId,
                                            echoCancellation: !Zr && !Yr,
                                            noiseSuppression: !eo && !Yr
                                        }, no && Object.assign(n.audio, {
                                            channelCount: 2
                                        })) : n.audio = !1, n
                                    }(e, n);
                                    return Kr.info("Got media constraints: ", JSON.stringify(i)), this._getUserMedia(e, i, t)
                                }.bind(this);
                                return s().then((function(e) {
                                    if (!e) return;
                                    const {
                                        stream: t,
                                        sourceId: n,
                                        sourceType: s
                                    } = e, r = t.getAudioTracks();
                                    if (r.length) {
                                        const e = new MediaStream(r);
                                        i.push({
                                            stream: e,
                                            sourceId: n,
                                            sourceType: s,
                                            track: e.getAudioTracks()[0]
                                        })
                                    }
                                    const o = t.getVideoTracks();
                                    if (o.length) {
                                        const e = new MediaStream(o);
                                        i.push({
                                            stream: e,
                                            sourceId: n,
                                            sourceType: s,
                                            track: e.getVideoTracks()[0],
                                            videoType: Bn().DESKTOP
                                        })
                                    }
                                })).then(r).then((function(e) {
                                    if (!e) return;
                                    const t = e.getAudioTracks();
                                    if (t.length) {
                                        const e = new MediaStream(t);
                                        i.push({
                                            stream: e,
                                            track: e.getAudioTracks()[0],
                                            effects: n.effects
                                        })
                                    }
                                    const s = e.getVideoTracks();
                                    if (s.length) {
                                        const e = new MediaStream(s);
                                        i.push({
                                            stream: e,
                                            track: e.getVideoTracks()[0],
                                            videoType: Bn().CAMERA,
                                            effects: n.effects
                                        })
                                    }
                                })).then((() => i)).catch((e => (i.forEach((({
                                    stream: e
                                }) => {
                                    this.stopMediaStream(e)
                                })), Promise.reject(e))))
                            }
                            isDeviceListAvailable() {
                                return Boolean(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices)
                            }
                            isDeviceChangeAvailable(e) {
                                return "output" === e || "audiooutput" === e ? so : "audioinput" !== e && "input" !== e || !Qt.isIosBrowser()
                            }
                            stopMediaStream(e) {
                                e && (e.getTracks().forEach((e => {
                                    e.stop && e.stop()
                                })), e.stop && e.stop(), e.release && e.release())
                            }
                            isDesktopSharingEnabled() {
                                return js.isSupported()
                            }
                            setAudioOutputDevice(e) {
                                return this.isDeviceChangeAvailable("output") ? io.setSinkId(e).then((() => {
                                    Qr = e, Xr = !0, Kr.log(`Audio output device set to ${e}`), zr.emit(jn().AUDIO_OUTPUT_DEVICE_CHANGED, e)
                                })) : Promise.reject(new Error("Audio output device change is not supported"))
                            }
                            setDesktopSharingFrameRate(e) {
                                js.setDesktopSharingFrameRate(e)
                            }
                            getAudioOutputDevice() {
                                return Qr
                            }
                            getCurrentlyAvailableMediaDevices() {
                                return oo
                            }
                            arePermissionsGrantedForAvailableDevices() {
                                return oo.some((e => Boolean(e.label)))
                            }
                            getEventDataForActiveDevice(e) {
                                const t = [],
                                    n = {
                                        deviceId: e.deviceId,
                                        kind: e.kind,
                                        label: e.label,
                                        groupId: e.groupId
                                    };
                                return t.push(n), {
                                    deviceList: t
                                }
                            }
                            setSuspendVideo(e, t) {
                                e.optional || (e.optional = []), e.optional = e.optional.filter((e => !e.hasOwnProperty("googSuspendBelowMinBitrate"))), t && e.optional.push({
                                    googSuspendBelowMinBitrate: "true"
                                })
                            }
                        },
                        po = uo,
                        mo = (0, f.getLogger)("modules/RTC/JitsiTrack.js"),
                        fo = {
                            track_mute: "onmute",
                            track_unmute: "onunmute",
                            track_ended: "onended"
                        };
                    class go extends(ze()) {
                        constructor(e, t, n, i, s, r) {
                            super(), this.addEventListener = this.addListener, this.removeEventListener = this.off = this.removeListener, this.containers = [], this.conference = e, this.audioLevel = -1, this.type = s, this.track = n, this.videoType = r, this.handlers = new Map, this.disposed = !1, this._streamInactiveHandler = i, this._setStream(t)
                        }
                        _addMediaStreamInactiveHandler(e) {
                            Qt.isFirefox() ? this.track.onended = e : this.stream.oninactive = e
                        }
                        _setHandler(e, t) {
                            if (fo.hasOwnProperty(e)) {
                                if (t ? this.handlers.set(e, t) : this.handlers.delete(e), this.stream)
                                    for (const n of this.stream.getTracks()) n[fo[e]] = t
                            } else mo.error(`Invalid handler type ${e}`)
                        }
                        _unregisterHandlers() {
                            if (this.stream) {
                                for (const e of this.handlers.keys())
                                    for (const t of this.stream.getVideoTracks()) t[fo[e]] = void 0;
                                this._streamInactiveHandler && this._addMediaStreamInactiveHandler(void 0)
                            } else mo.warn(`${this}: unable to unregister handlers - no stream object`)
                        }
                        _setStream(e) {
                            if (this.stream !== e && (this.stream = e, this.stream)) {
                                for (const e of this.handlers.keys()) this._setHandler(e, this.handlers.get(e));
                                this._streamInactiveHandler && this._addMediaStreamInactiveHandler(this._streamInactiveHandler)
                            }
                        }
                        getVideoType() {
                            return this.videoType
                        }
                        getType() {
                            return this.type
                        }
                        isAudioTrack() {
                            return this.getType() === En
                        }
                        isWebRTCTrackMuted() {
                            return this.track && this.track.muted
                        }
                        isVideoTrack() {
                            return this.getType() === Cn
                        }
                        isLocal() {
                            throw new Error("Not implemented by subclass")
                        }
                        isLocalAudioTrack() {
                            return this.isAudioTrack() && this.isLocal()
                        }
                        getOriginalStream() {
                            return this.stream
                        }
                        getStreamId() {
                            return this.stream ? this.stream.id : null
                        }
                        getTrack() {
                            return this.track
                        }
                        getTrackLabel() {
                            return this.track.label
                        }
                        getTrackId() {
                            return this.track ? this.track.id : null
                        }
                        getUsageLabel() {
                            return this.isAudioTrack() ? "mic" : this.videoType ? this.videoType : "default"
                        }
                        _maybeFireTrackAttached(e) {
                            this.conference && e && this.conference._onTrackAttach(this, e)
                        }
                        attach(e) {
                            this.stream && (this._onTrackAttach(e), po.attachMediaStream(e, this.stream)), this.containers.push(e), this._maybeFireTrackAttached(e), this._attachTTFMTracker(e)
                        }
                        detach(e) {
                            for (let t = this.containers, n = t.length - 1; n >= 0; --n) {
                                const i = t[n];
                                e || (this._onTrackDetach(i), po.attachMediaStream(i, null)), e && i !== e || t.splice(n, 1)
                            }
                            e && (this._onTrackDetach(e), po.attachMediaStream(e, null))
                        }
                        _onTrackAttach(e) {}
                        _onTrackDetach(e) {}
                        _attachTTFMTracker(e) {}
                        dispose() {
                            return this.removeAllListeners(), this.disposed = !0, Promise.resolve()
                        }
                        isScreenSharing() {}
                        getId() {
                            return this.stream ? po.getStreamID(this.stream) : null
                        }
                        isActive() {
                            return void 0 === this.stream.active || this.stream.active
                        }
                        setAudioLevel(e, t) {
                            let n = e;
                            Qt.supportsReceiverStats() && void 0 !== t && this.isMuted() && (n = 0), this.audioLevel !== n ? (this.audioLevel = n, this.emit(zn, n, t)) : 0 === this.audioLevel && 0 === n && this.isLocal() && !this.isWebRTCTrackMuted() && this.emit(Zn, n)
                        }
                        getMSID() {
                            const e = this.getStreamId(),
                                t = this.getTrackId();
                            return e && t ? `${e} ${t}` : null
                        }
                        setAudioOutput(e) {
                            return po.isDeviceChangeAvailable("output") ? this.isVideoTrack() ? Promise.resolve() : Promise.all(this.containers.map((t => t.setSinkId(e).catch((e => {
                                throw mo.warn("Failed to change audio output device on element. Default or previously set audio output device will be used.", t, e), e
                            }))))).then((() => {
                                this.emit(Wn, e)
                            })) : Promise.reject(new Error("Audio output device change is not supported"))
                        }
                    }
                    const _o = (0, f.getLogger)("modules/RTC/JitsiLocalTrack.js");
                    class vo extends go {
                        constructor({
                            deviceId: e,
                            facingMode: t,
                            mediaType: n,
                            resolution: i,
                            rtcId: s,
                            sourceId: r,
                            sourceType: o,
                            stream: a,
                            track: c,
                            videoType: d,
                            effects: l = []
                        }) {
                            super(null, a, c, (() => this.emit(Kn)), n, d), this._setEffectInProgress = !1;
                            const h = l.find((e => e.isEnabled(this)));
                            h && this._startStreamEffect(h), this.rtcId = s, this.sourceId = r, this.sourceType = o, this.resolution = c.getSettings().height, this.maxEnabledResolution = i, this._constraints = c.getConstraints(), Object.keys(this._constraints).length || d !== Bn().CAMERA || (this._constraints = {
                                height: c.getSettings().height,
                                width: c.getSettings().width
                            }), this.deviceId = e, this._prevSetMuted = Promise.resolve(), this._facingMode = t, this._trackEnded = !1, this._hasSentData = !1, this._testDataSent = !0, this._realDeviceId = "" === this.deviceId ? void 0 : this.deviceId, this._trackMutedTS = 0, this._onDeviceListWillChange = e => {
                                const t = this._realDeviceId;
                                this._setRealDeviceIdFromDeviceList(e), (void 0 === this.getTrack().readyState && void 0 !== this._realDeviceId && !e.find((e => e.deviceId === this._realDeviceId)) || void 0 !== t && void 0 === this._realDeviceId) && (this._trackEnded = !0)
                            }, this.isAudioTrack() && po.isDeviceChangeAvailable("output") && (this._onAudioOutputDeviceChanged = this.setAudioOutput.bind(this), po.addListener(jn().AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged)), po.addListener(jn().DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._initNoDataFromSourceHandlers()
                        }
                        isEnded() {
                            return this.isVideoTrack() && this.isMuted() ? this._trackEnded : "ended" === this.getTrack().readyState || this._trackEnded
                        }
                        _initNoDataFromSourceHandlers() {
                            this._isNoDataFromSourceEventsEnabled() && (this._setHandler("track_mute", (() => {
                                this._trackMutedTS = window.performance.now(), this._fireNoDataFromSourceEvent()
                            })), this._setHandler("track_unmute", (() => {
                                this._fireNoDataFromSourceEvent(), On.sendAnalyticsAndLog("track.unmuted", {
                                    media_type: this.getType(),
                                    track_type: "local",
                                    value: window.performance.now() - this._trackMutedTS
                                })
                            })), this.isVideoTrack() && this.videoType === Bn().CAMERA && this._setHandler("track_ended", (() => {
                                this.isReceivingData() || this._fireNoDataFromSourceEvent()
                            })))
                        }
                        _isNoDataFromSourceEventsEnabled() {
                            return !this.isVideoTrack() || this.videoType !== Bn().DESKTOP
                        }
                        _fireNoDataFromSourceEvent() {
                            const e = !this.isReceivingData();
                            this.emit(Yn, e), On.sendAnalytics(function(e, t) {
                                return {
                                    attributes: {
                                        media_type: e,
                                        value: t
                                    },
                                    action: "track.no.data.from.source",
                                    type: gt
                                }
                            }(this.getType(), e)), On.sendLog(JSON.stringify({
                                name: Yn,
                                log: e
                            }))
                        }
                        _setRealDeviceIdFromDeviceList(e) {
                            const t = this.getTrack(),
                                n = `${t.kind}input`;
                            let i = e.find((e => e.kind === n && e.label === t.label));
                            if (!i && "default" === this._realDeviceId) {
                                const s = (t.label || "").replace("Default - ", "");
                                i = e.find((e => e.kind === n && e.label === s))
                            }
                            this._realDeviceId = i ? i.deviceId : void 0
                        }
                        _setStream(e) {
                            super._setStream(e), e ? (this.storedMSID = this.getMSID(), _o.debug(`Setting new MSID: ${this.storedMSID} on ${this}`)) : _o.debug(`Setting 'null' stream on ${this}`)
                        }
                        _startStreamEffect(e) {
                            this._streamEffect = e, this._originalStream = this.stream, this._setStream(this._streamEffect.startEffect(this._originalStream)), this.track = this.stream.getTracks()[0]
                        }
                        _stopStreamEffect() {
                            this._streamEffect && (this._streamEffect.stopEffect(), this._setStream(this._originalStream), this._originalStream = null, this.track = this.stream ? this.stream.getTracks()[0] : null)
                        }
                        _switchStreamEffect(e) {
                            this._streamEffect && (this._stopStreamEffect(), this._streamEffect = void 0), e && this._startStreamEffect(e)
                        }
                        setEffect(e) {
                            if (void 0 === this._streamEffect && void 0 === e) return Promise.resolve();
                            if (void 0 !== e && !e.isEnabled(this)) return Promise.reject(new Error("Incompatible effect instance!"));
                            if (!0 === this._setEffectInProgress) return Promise.reject(new Error("setEffect already in progress!"));
                            if (this.isMuted() && !this.isAudioTrack()) return this._streamEffect = e, Promise.resolve();
                            const t = this.conference;
                            return t ? (this._setEffectInProgress = !0, t.removeTrack(this).then((() => (this._switchStreamEffect(e), this.isVideoTrack() && this.containers.forEach((e => po.attachMediaStream(e, this.stream))), t.addTrack(this)))).then((() => {
                                this._setEffectInProgress = !1
                            })).catch((e => {
                                throw this._setEffectInProgress = !1, this._switchStreamEffect(), _o.error("Failed to switch to the new stream!", e), e
                            }))) : (this._switchStreamEffect(e), this.isVideoTrack() && this.containers.forEach((e => po.attachMediaStream(e, this.stream))), Promise.resolve())
                        }
                        mute() {
                            return this._queueSetMuted(!0)
                        }
                        unmute() {
                            return this._queueSetMuted(!1)
                        }
                        _queueSetMuted(e) {
                            const t = this._setMuted.bind(this, e);
                            return this._prevSetMuted = this._prevSetMuted.then(t, t), this._prevSetMuted
                        }
                        _setMuted(e) {
                            if (this.isMuted() === e) return Promise.resolve();
                            if (this.disposed) return Promise.reject(new pt(ct));
                            let t = Promise.resolve();
                            const n = () => _o.info(`Mute ${this}: ${e}`);
                            if (this.isAudioTrack() || this.videoType === Bn().DESKTOP || !Qt.doesVideoMuteByStreamRemove()) n(), this._streamEffect && this._streamEffect.setMuted ? this._streamEffect.setMuted(e) : this.track && (this.track.enabled = !e);
                            else if (e) t = new Promise(((e, t) => {
                                n(), this._removeStreamFromConferenceAsMute((() => {
                                    this._streamEffect && this._stopStreamEffect(), this._unregisterHandlers(), this.stopStream(), this._setStream(null), e()
                                }), t)
                            }));
                            else {
                                n();
                                const e = {
                                    cameraDeviceId: this.getDeviceId(),
                                    devices: [Cn],
                                    effects: this._streamEffect ? [this._streamEffect] : [],
                                    facingMode: this.getCameraFacingMode()
                                };
                                t = po.obtainAudioAndVideoPermissions(Object.assign({}, e, {
                                    constraints: {
                                        video: this._constraints
                                    }
                                })), t = t.then((e => {
                                    const t = this.getType() === bn ? Cn : this.getType(),
                                        n = e.find((e => e.track.kind === t));
                                    if (!n) throw new pt(dt);
                                    return this._setStream(n.stream), this.track = n.track, this.videoType !== n.videoType && (_o.warn(`${this}: video type has changed after unmute!`, this.videoType, n.videoType), this.videoType = n.videoType), this._streamEffect && this._startStreamEffect(this._streamEffect), this.containers.map((e => po.attachMediaStream(e, this.stream))), this._addStreamToConferenceAsUnmute()
                                }))
                            }
                            return t.then((() => {
                                this._sendMuteStatus(e), this.emit(Qn, this)
                            }))
                        }
                        _addStreamToConferenceAsUnmute() {
                            return this.conference ? new Promise(((e, t) => {
                                this.conference._addLocalTrackAsUnmute(this).then(e, (e => t(new Error(e))))
                            })) : Promise.resolve()
                        }
                        _removeStreamFromConferenceAsMute(e, t) {
                            this.conference ? this.conference._removeLocalTrackAsMute(this).then(e, (e => t(new Error(e)))) : e()
                        }
                        _sendMuteStatus(e) {
                            this.conference && this.conference.room && this.conference.room[this.isAudioTrack() ? "setAudioMute" : "setVideoMute"](e)
                        }
                        dispose() {
                            let e = Promise.resolve();
                            return this._streamEffect && (e = this.setEffect()), this.conference && (e = e.then((() => this.conference.removeTrack(this)))), this.stream && (this.stopStream(), this.detach()), po.removeListener(jn().DEVICE_LIST_WILL_CHANGE, this._onDeviceListWillChange), this._onAudioOutputDeviceChanged && po.removeListener(jn().AUDIO_OUTPUT_DEVICE_CHANGED, this._onAudioOutputDeviceChanged), e.then((() => super.dispose()))
                        }
                        isMuted() {
                            return !this.stream || !(!this.isVideoTrack() || this.isActive()) || (this._streamEffect && this._streamEffect.isMuted ? this._streamEffect.isMuted() : !this.track || !this.track.enabled)
                        }
                        _setConference(e) {
                            this.conference = e;
                            for (let e = 0; e < this.containers.length; e++) this._maybeFireTrackAttached(this.containers[e])
                        }
                        isLocal() {
                            return !0
                        }
                        getDeviceId() {
                            return this._realDeviceId || this.deviceId
                        }
                        getParticipantId() {
                            return this.conference && this.conference.myUserId()
                        }
                        _onByteSentStatsReceived(e, t) {
                            t > 0 && (this._hasSentData = !0);
                            const n = e.getConnectionState();
                            this._testDataSent && "connected" === n && (setTimeout((() => {
                                this._hasSentData || (_o.warn(`${this} 'bytes sent' <= 0:                         ${t}`), On.analytics.sendEvent("track.no-bytes-sent", {
                                    media_type: this.getType()
                                }))
                            }), 3e3), this._testDataSent = !1)
                        }
                        getCameraFacingMode() {
                            if (this.isVideoTrack() && this.videoType === Bn().CAMERA) {
                                var e, t;
                                const n = null === (e = (t = this.track).getSettings) || void 0 === e ? void 0 : e.call(t);
                                return n && "facingMode" in n ? n.facingMode : void 0 !== this._facingMode ? this._facingMode : Ur().USER
                            }
                        }
                        stopStream() {
                            this._stopStreamInProgress = !0;
                            try {
                                po.stopMediaStream(this.stream)
                            } finally {
                                this._stopStreamInProgress = !1
                            }
                        }
                        _switchCamera() {
                            this.isVideoTrack() && this.videoType === Bn().CAMERA && "function" == typeof this.track._switchCamera && (this.track._switchCamera(), this._facingMode = this._facingMode === Ur().ENVIRONMENT ? Ur().USER : Ur().ENVIRONMENT)
                        }
                        isReceivingData() {
                            return !(!this.isVideoTrack() || !this.isMuted() && !this._stopStreamInProgress && this.videoType !== Bn().DESKTOP) || !!this.stream && (this._effectEnabled ? this._originalStream : this.stream).getTracks().some((e => !("readyState" in e && "live" !== e.readyState || "muted" in e && !0 === e.muted)))
                        }
                        toString() {
                            return `LocalTrack[${this.rtcId},${this.getType()}]`
                        }
                    }
                    var yo = n(7546);
                    const So = function(e, t) {
                            return void 0 !== e && void 0 !== e.media && Array.isArray(e.media) && e.media.forEach((e => {
                                e.sources && e.sources.length && (e.ssrcs = [], e.sources.forEach((t => {
                                    Object.keys(t).forEach((n => {
                                        "id" !== n && e.ssrcs.push({
                                            id: t.id,
                                            attribute: n,
                                            value: t[n]
                                        })
                                    }))
                                })), delete e.sources), e.ssrcGroups && e.ssrcGroups.length && e.ssrcGroups.forEach((e => {
                                    void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.ssrcs = e.ssrcs.join(" "))
                                }))
                            })), yo.write(e, t)
                        },
                        Eo = function(e) {
                            const t = yo.parse(e);
                            return void 0 !== t && void 0 !== t.media && Array.isArray(t.media) && t.media.forEach((e => {
                                void 0 !== e.ssrcs && Array.isArray(e.ssrcs) && (e.sources = [], e.ssrcs.forEach((t => {
                                    const n = e.sources.findIndex((e => e.id === t.id));
                                    if (n > -1) e.sources[n][t.attribute] = t.value;
                                    else {
                                        const n = {
                                            id: t.id
                                        };
                                        n[t.attribute] = t.value, e.sources.push(n)
                                    }
                                })), delete e.ssrcs), void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach((e => {
                                    "string" == typeof e.ssrcs && (e.ssrcs = e.ssrcs.split(" "))
                                }))
                            })), t
                        },
                        bo = ["audio", "video", "data"],
                        Co = e => e.find((e => "SIM" === e.semantics)),
                        To = e => e.find((e => "FID" === e.semantics));

                    function Ro(e, t, n, i) {
                        if (!e || !t) return;
                        const s = e => i.find((t => t.id.toString() === e));
                        t.ssrcs.forEach((t => {
                            e.sources.push(s(t));
                            const i = n[parseInt(t, 10)].find((e => "FID" === e.semantics));
                            if (i) {
                                const n = i.ssrcs.find((e => e !== t));
                                e.sources.push(s(n)), e.ssrcGroups.push(i)
                            }
                        })), e.ssrcGroups.push(t)
                    }

                    function Ao(e, t, n, i) {
                        if (!e || !t) return;
                        if (e.sources = [], e.ssrcGroups = [], !n[t.id]) return e.sources.push(t), void(e.msid = t.msid);
                        const s = Co(n[t.id]),
                            r = To(n[t.id]);
                        if (s) Ro(e, s, n, i);
                        else if (r) {
                            const s = r.ssrcs.find((e => e !== t)),
                                o = Co(n[s]);
                            o ? Ro(e, o, n, i) : (r.ssrcs.forEach((t => {
                                e.sources.push((e => i.find((t => t.id.toString() === e)))(t))
                            })), e.ssrcGroups.push(r))
                        }
                        e.msid = e.sources[0].msid
                    }

                    function wo(e, t, n) {
                        if (!n.find((t => !!t.sources && t.sources.some((t => t.id === e.id))))) {
                            if (!t[e.id]) return !1;
                            const i = Co(t[e.id]),
                                s = To(t[e.id]);
                            return i ? n.some((e => e.sources && e.sources.some((e => e.id.toString() === i.ssrcs[0])))) : !(!s || e.id.toString() === s.ssrcs[0]) && wo({
                                id: s.ssrcs[0]
                            }, t, n)
                        }
                        return !0
                    }
                    class Po {
                        toPlanB(e) {
                            if (!e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
                            const t = Eo(e.sdp);
                            if (!t.media || !t.media.length) return console.warn("The description has no media."), e;
                            if (t.media.every((e => -1 !== bo.indexOf(e.mid)))) return console.warn("The description does not look like unified plan sdp"), e;
                            const n = {},
                                i = t.media;
                            t.media = [], i.forEach((e => {
                                const t = e.type;
                                if ("application" === t) return e.mid = "data", void(n[e.mid] = e);
                                if (void 0 === n[t]) {
                                    const i = Vr(e);
                                    i.sources && Array.isArray(i.sources) && i.sources.forEach((t => {
                                        e.msid ? t.msid = e.msid : delete t.msid
                                    })), i.ssrcGroups && e.msid || (i.ssrcGroups = []), delete i.msid, i.mid = t, n[t] = i
                                } else e.msid && (e.sources && Array.isArray(e.sources) && (n[t].sources = (n[t].sources || []).concat(e.sources)), void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && (n[t].ssrcGroups = n[t].ssrcGroups.concat(e.ssrcGroups)))
                            })), t.media = Object.values(n);
                            const s = [];
                            Object.values(n).forEach((e => {
                                "inactive" !== e.direction && s.push(e.mid)
                            })), t.groups.forEach((e => {
                                "BUNDLE" === e.type && (e.mids = s.join(" "))
                            })), t.msidSemantic = {
                                semantic: "WMS",
                                token: "*"
                            };
                            const r = So(t);
                            return new RTCSessionDescription({
                                type: e.type,
                                sdp: r
                            })
                        }
                        toUnifiedPlan(e, t = null) {
                            if (!e || "string" != typeof e.sdp) return console.warn("An empty description was passed as an argument."), e;
                            const n = Eo(e.sdp);
                            if (!n.media || !n.media.length) return console.warn("The description has no media."), e;
                            if (n.media.length > 3 || n.media.every((e => -1 === bo.indexOf(e.mid)))) return console.warn("The description does not look like plan-b"), e;
                            const i = t ? Eo(t.sdp) : null,
                                s = function(e, t) {
                                    if (!e || !t || 0 === e.media.length || 0 === t.media.length) return !1;
                                    const n = e.media[0],
                                        i = t.media[0];
                                    return n.iceUfrag !== i.iceUfrag || n.icePwd !== i.icePwd
                                }(n, i),
                                r = n.media[0].iceUfrag,
                                o = n.media[0].icePwd,
                                a = n.media[0].fingerprint,
                                c = {};
                            n.media.forEach((e => {
                                const t = e.type;
                                if ("application" === t) {
                                    if (!i || !i.media) {
                                        const t = Vr(e);
                                        return t.mid = Object.keys(c).length.toString(), void(c[e.mid] = t)
                                    }
                                    const n = i.media.findIndex((e => e.type === t));
                                    return void(n && (i.media[n] = e, i.media[n].mid = n))
                                }
                                const n = function(e) {
                                    const t = {};
                                    return e && Array.isArray(e) ? (e.forEach((e => {
                                        e.ssrcs && Array.isArray(e.ssrcs) && e.ssrcs.forEach((n => {
                                            void 0 === t[n] && (t[n] = []), t[n].push(e)
                                        }))
                                    })), t) : t
                                }(e.ssrcGroups);
                                if (e.sources) e.sources.forEach(((t, s) => {
                                    if (!t.msid) return;
                                    if (!i || !i.media) {
                                        if (wo(t, n, Object.values(c))) return;
                                        const i = Vr(e);
                                        return i.mid = Object.keys(c).length.toString(), i.direction = s || "sendonly" === e.direction ? "sendonly" : "sendrecv", i.bundleOnly = void 0, Ao(i, t, n, e.sources), void(c[i.mid] = i)
                                    }
                                    if (wo(t, n, i.media)) return;
                                    const r = Vr(e);
                                    r.mid = i.media.length.toString(), r.direction = "sendonly", Ao(r, t, n, e.sources), i.media.push(r)
                                }));
                                else if (!i) {
                                    const t = Vr(e);
                                    t.mid = Object.keys(c).length.toString(), c[e.mid] = t
                                }
                            })), n.media = i ? i.media : Object.values(c);
                            const d = [];
                            n.media.forEach((e => {
                                d.push(e.mid), s && (e.iceUfrag = r, e.icePwd = o, e.fingerprint = a)
                            })), n.groups.forEach((e => {
                                "BUNDLE" === e.type && (e.mids = d.join(" "))
                            })), n.msidSemantic = {
                                semantic: "WMS",
                                token: "*"
                            }, n.origin.sessionVersion++;
                            const l = So(n);
                            return new RTCSessionDescription({
                                type: e.type,
                                sdp: l
                            })
                        }
                    }
                    var Io = n(1810);

                    function Mo(e) {
                        return parseInt(e.ssrcs.split(" ")[0], 10)
                    }

                    function Do(e) {
                        return parseInt(e.ssrcs.split(" ")[1], 10)
                    }

                    function No(e) {
                        return e.ssrcs ? e.ssrcs.map((e => e.id)).filter(((e, t, n) => n.indexOf(e) === t)).length : 0
                    }
                    class ko {
                        constructor(e) {
                            if (!e) throw new Error("mLine is undefined");
                            this.mLine = e
                        }
                        get ssrcs() {
                            return this.mLine.ssrcs || (this.mLine.ssrcs = []), this.mLine.ssrcs
                        }
                        set ssrcs(e) {
                            this.mLine.ssrcs = e
                        }
                        get direction() {
                            return this.mLine.direction
                        }
                        set direction(e) {
                            this.mLine.direction = e
                        }
                        get ssrcGroups() {
                            return this.mLine.ssrcGroups || (this.mLine.ssrcGroups = []), this.mLine.ssrcGroups
                        }
                        set ssrcGroups(e) {
                            this.mLine.ssrcGroups = e
                        }
                        getSSRCAttrValue(e, t) {
                            const n = this.ssrcs.find((n => n.id === e && n.attribute === t));
                            return n && n.value
                        }
                        removeSSRC(e) {
                            this.mLine.ssrcs && this.mLine.ssrcs.length && (this.mLine.ssrcs = this.mLine.ssrcs.filter((t => t.id !== e)))
                        }
                        addSSRCAttribute(e) {
                            this.ssrcs.push(e)
                        }
                        findGroup(e, t) {
                            return this.ssrcGroups.find((n => n.semantics === e && (!t || t === n.ssrcs)))
                        }
                        findGroups(e) {
                            return this.ssrcGroups.filter((t => t.semantics === e))
                        }
                        findGroupByPrimarySSRC(e, t) {
                            return this.ssrcGroups.find((n => n.semantics === e && Mo(n) === t))
                        }
                        findSSRCByMSID(e) {
                            return this.ssrcs.find((t => "msid" === t.attribute && (null === e || t.value === e)))
                        }
                        getSSRCCount() {
                            return No(this.mLine)
                        }
                        containsAnySSRCGroups() {
                            return void 0 !== this.mLine.ssrcGroups
                        }
                        getPrimaryVideoSsrc() {
                            const e = this.mLine.type;
                            if ("video" !== e) throw new Error(`getPrimarySsrc doesn't work with '${e}'`);
                            if (1 === No(this.mLine)) return this.mLine.ssrcs[0].id;
                            if (this.mLine.ssrcGroups) {
                                const e = this.findGroup("SIM");
                                if (e) return Mo(e);
                                const t = this.findGroup("FID");
                                if (t) return Mo(t);
                                const n = this.findGroup("FEC-FR");
                                if (n) return Mo(n)
                            }
                        }
                        getRtxSSRC(e) {
                            const t = this.findGroupByPrimarySSRC("FID", e);
                            return t && Do(t)
                        }
                        getSSRCs() {
                            return this.ssrcs.map((e => e.id)).filter(((e, t, n) => n.indexOf(e) === t))
                        }
                        getPrimaryVideoSSRCs() {
                            const e = this.mLine.type;
                            if ("video" !== e) throw new Error(`getPrimaryVideoSSRCs doesn't work with ${e}`);
                            const t = this.getSSRCs();
                            for (const e of this.ssrcGroups)
                                if ("FID" === e.semantics || "FEC-FR" === e.semantics) {
                                    const n = Do(e);
                                    t.splice(t.indexOf(n), 1)
                                } return t
                        }
                        dumpSSRCGroups() {
                            return JSON.stringify(this.mLine.ssrcGroups)
                        }
                        removeGroupsWithSSRC(e) {
                            this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter((t => -1 === t.ssrcs.indexOf(`${e}`))))
                        }
                        removeGroupsBySemantics(e) {
                            this.mLine.ssrcGroups && (this.mLine.ssrcGroups = this.mLine.ssrcGroups.filter((t => t.semantics !== e)))
                        }
                        replaceSSRC(e, t) {
                            this.mLine.ssrcs && this.mLine.ssrcs.forEach((n => {
                                n.id === e && (n.id = t)
                            }))
                        }
                        addSSRCGroup(e) {
                            this.ssrcGroups.push(e)
                        }
                    }
                    class Oo {
                        constructor(e) {
                            this.parsedSDP = Io.parse(e)
                        }
                        selectMedia(e) {
                            const t = this.parsedSDP.media.find((t => t.type === e));
                            return t ? new ko(t) : null
                        }
                        toRawSDP() {
                            return Io.write(this.parsedSDP)
                        }
                    }
                    const Lo = (0, f.getLogger)("modules/sdp/LocalSdpMunger.js");
                    class xo {
                        constructor(e, t) {
                            this.tpc = e, this.localEndpointId = t
                        }
                        _addMutedLocalVideoTracksToSDP(e) {
                            const t = this.tpc.getLocalTracks(Cn);
                            if (!t.length) return !1;
                            1 !== t.length && Lo.error(`${this.tpc} there is more than 1 video track ! Strange things may happen !`, t);
                            const n = e.selectMedia("video");
                            if (!n) return Lo.debug(`${this.tpc} unable to hack local video track SDP- no "video" media`), !1;
                            let i = !1;
                            for (const e of t) {
                                const t = e.isMuted(),
                                    s = e.getOriginalStream(),
                                    r = e.videoType === Bn().CAMERA,
                                    o = s && this.tpc.isMediaStreamInPc(s);
                                if (!r || !t && o) continue;
                                const a = this.tpc.isSimulcastOn() ? this.tpc.simulcast.ssrcCache : [this.tpc.sdpConsistency.cachedPrimarySsrc];
                                if (!a.length) {
                                    Lo.error(`No SSRCs stored for: ${e} in ${this.tpc}`);
                                    continue
                                }
                                i = !0, n.direction = xs().SENDRECV;
                                const c = `injected-${a[0]}`;
                                for (const t of a) n.removeSSRC(t), n.addSSRCAttribute({
                                    id: t,
                                    attribute: "cname",
                                    value: c
                                }), n.addSSRCAttribute({
                                    id: t,
                                    attribute: "msid",
                                    value: e.storedMSID
                                });
                                if (a.length > 1) {
                                    const e = {
                                        ssrcs: a.join(" "),
                                        semantics: "SIM"
                                    };
                                    n.findGroup(e.semantics, e.ssrcs) || n.addSSRCGroup(e)
                                }
                                this.tpc.options.disableRtx || this.tpc.rtxModifier.modifyRtxSsrcs2(n)
                            }
                            return i
                        }
                        _generateMsidAttribute(e, t, n = null) {
                            if (!e || !t) return Lo.warn(`Unable to munge local MSID - track id=${t} or media type=${e} is missing`), null;
                            const i = this.tpc.id;
                            return "-" !== n && n ? `${n}-${i} ${t}-${i}` : `${this.localEndpointId}-${e}-${i} ${t}-${i}`
                        }
                        _transformMediaIdentifiers(e) {
                            var t;
                            const n = this.tpc.id;
                            for (const t of e.ssrcs) switch (t.attribute) {
                                case "cname":
                                case "label":
                                case "mslabel":
                                    t.value = t.value && `${t.value}-${n}`;
                                    break;
                                case "msid":
                                    if (t.value) {
                                        const n = t.value.split(" ");
                                        var i;
                                        2 === n.length ? t.value = this._generateMsidAttribute(null === (i = e.mLine) || void 0 === i ? void 0 : i.type, n[1], n[0]) : Lo.warn(`Unable to munge local MSID - weird format detected: ${t.value}`)
                                    }
                            }
                            if (!this.tpc.usesUnifiedPlan()) return;
                            const s = null === (t = e.mLine) || void 0 === t ? void 0 : t.direction;
                            if (s === xs().RECVONLY || s === xs().INACTIVE) e.ssrcs = void 0, e.ssrcGroups = void 0;
                            else {
                                var r, o, a;
                                const t = null === (r = e.mLine) || void 0 === r ? void 0 : r.msid,
                                    n = t && t.split(" ")[1],
                                    i = [...new Set(null === (o = e.mLine) || void 0 === o || null === (a = o.ssrcs) || void 0 === a ? void 0 : a.map((e => e.id)))];
                                for (const t of i)
                                    if (!e.ssrcs.find((e => e.id === t && "msid" === e.attribute))) {
                                        var c;
                                        const i = this._generateMsidAttribute(null === (c = e.mLine) || void 0 === c ? void 0 : c.type, n);
                                        e.ssrcs.push({
                                            id: t,
                                            attribute: "msid",
                                            value: i
                                        })
                                    }
                            }
                        }
                        maybeAddMutedLocalVideoTracksToSDP(e) {
                            if (!e) throw new Error("No local description passed in.");
                            const t = new Oo(e.sdp);
                            return this._addMutedLocalVideoTracksToSDP(t) ? new RTCSessionDescription({
                                type: e.type,
                                sdp: t.toRawSDP()
                            }) : e
                        }
                        transformStreamIdentifiers(e) {
                            if (!e || !e.sdp || !e.type) return e;
                            const t = new Oo(e.sdp),
                                n = t.selectMedia("audio");
                            n && (this._transformMediaIdentifiers(n), this._injectSourceNames(n));
                            const i = t.selectMedia("video");
                            return i && (this._transformMediaIdentifiers(i), this._injectSourceNames(i)), new RTCSessionDescription({
                                type: e.type,
                                sdp: t.toRawSDP()
                            })
                        }
                        _injectSourceNames(e) {
                            var t, n, i;
                            if (!Ns.isSourceNameSignalingEnabled()) return;
                            const s = [...new Set(null === (t = e.mLine) || void 0 === t || null === (n = t.ssrcs) || void 0 === n ? void 0 : n.map((e => e.id)))],
                                r = null === (i = e.mLine) || void 0 === i ? void 0 : i.type;
                            if (!r) throw new Error("_transformMediaIdentifiers - no media type in mediaSection");
                            for (const t of s)
                                if (!e.ssrcs.find((e => e.id === t && "name" === e.attribute))) {
                                    const n = r.substring(0, 1);
                                    e.ssrcs.push({
                                        id: t,
                                        attribute: "name",
                                        value: `${this.localEndpointId}-${n}0`
                                    })
                                }
                        }
                    }
                    const Fo = (0, f.getLogger)("modules/sdp/RtxModifier.js");

                    function jo(e, t, n) {
                        const i = t.id,
                            s = t.msid,
                            r = t.cname,
                            o = e.getRtxSSRC(i);
                        o !== n && (o && (e.removeSSRC(o), e.removeGroupsWithSSRC(o)), e.addSSRCAttribute({
                            id: n,
                            attribute: "cname",
                            value: r
                        }), e.addSSRCAttribute({
                            id: n,
                            attribute: "msid",
                            value: s
                        }), e.addSSRCGroup({
                            semantics: "FID",
                            ssrcs: `${i} ${n}`
                        }))
                    }
                    class $o {
                        constructor() {
                            this.correspondingRtxSsrcs = new Map
                        }
                        clearSsrcCache() {
                            this.correspondingRtxSsrcs.clear()
                        }
                        setSsrcCache(e) {
                            Fo.debug("Setting ssrc cache to ", e), this.correspondingRtxSsrcs = e
                        }
                        modifyRtxSsrcs(e) {
                            const t = new Oo(e),
                                n = t.selectMedia("video");
                            return n ? this.modifyRtxSsrcs2(n) ? t.toRawSDP() : e : (Fo.debug(`No 'video' media found in the sdp: ${e}`), e)
                        }
                        modifyRtxSsrcs2(e) {
                            if ("recvonly" === e.direction) return !1;
                            if (e.getSSRCCount() < 1) return !1;
                            const t = e.getPrimaryVideoSSRCs();
                            for (const n of t) {
                                const t = e.getSSRCAttrValue(n, "msid"),
                                    i = e.getSSRCAttrValue(n, "cname");
                                let s = this.correspondingRtxSsrcs.get(n);
                                if (!s) {
                                    s = e.getRtxSSRC(n) || Js.generateSsrc(), this.correspondingRtxSsrcs.set(n, s)
                                }
                                jo(e, {
                                    id: n,
                                    cname: i,
                                    msid: t
                                }, s)
                            }
                            return !0
                        }
                        stripRtx(e) {
                            const t = new Oo(e),
                                n = t.selectMedia("video");
                            if (!n) return Fo.debug(`No 'video' media found in the sdp: ${e}`), e;
                            if ("recvonly" === n.direction) return Fo.debug("RtxModifier doing nothing, video m line is recvonly"), e;
                            if (n.getSSRCCount() < 1) return Fo.debug("RtxModifier doing nothing, no video ssrcs present"), e;
                            if (!n.containsAnySSRCGroups()) return Fo.debug("RtxModifier doing nothing, no video ssrcGroups present"), e;
                            const i = n.findGroups("FID");
                            n.removeGroupsBySemantics("FID");
                            for (const e of i) {
                                const t = Do(e);
                                n.removeSSRC(t)
                            }
                            return t.toRawSDP()
                        }
                    }
                    const Bo = (0, f.getLogger)("modules/sdp/SdpConsistency.js");
                    class Jo {
                        constructor(e) {
                            this.clearVideoSsrcCache(), this.logPrefix = e
                        }
                        clearVideoSsrcCache() {
                            this.cachedPrimarySsrc = null, this.injectRecvOnly = !1
                        }
                        setPrimarySsrc(e) {
                            if ("number" != typeof e) throw new Error("Primary SSRC must be a number!");
                            this.cachedPrimarySsrc = e
                        }
                        hasPrimarySsrcCached() {
                            return Boolean(this.cachedPrimarySsrc)
                        }
                        makeVideoPrimarySsrcsConsistent(e) {
                            const t = new Oo(e),
                                n = t.selectMedia("video");
                            if (!n) return Bo.debug(`${this.logPrefix} no 'video' media found in the sdp: ${e}`), e;
                            if ("recvonly" === n.direction) this.cachedPrimarySsrc && this.injectRecvOnly ? n.addSSRCAttribute({
                                id: this.cachedPrimarySsrc,
                                attribute: "cname",
                                value: `recvonly-${this.cachedPrimarySsrc}`
                            }) : Bo.info(`${this.logPrefix} no SSRC found for the recvonly video stream!`);
                            else {
                                const t = n.getPrimaryVideoSsrc();
                                if (!t) return Bo.info(`${this.logPrefix} sdp-consistency couldn't parse new primary ssrc`), e;
                                if (this.cachedPrimarySsrc) {
                                    n.replaceSSRC(t, this.cachedPrimarySsrc);
                                    for (const e of n.ssrcGroups)
                                        if ("FID" === e.semantics) {
                                            const n = Mo(e),
                                                i = Do(e);
                                            n === t && (e.ssrcs = `${this.cachedPrimarySsrc} ${i}`)
                                        }
                                } else this.cachedPrimarySsrc = t;
                                this.injectRecvOnly = !0
                            }
                            return t.toRawSDP()
                        }
                    }
                    const Uo = n(7055).getLogger("modules/RTC/JitsiRemoteTrack.js"),
                        Vo = n(3907);
                    let Ho = !1,
                        Go = !1;
                    const qo = ["abort", "canplaythrough", "ended", "error"];
                    class Ko extends go {
                        constructor(e, t, n, i, s, r, o, a, c, d) {
                            if (super(t, i, s, (() => {}), r, o), this.rtc = e, "number" != typeof a) throw new TypeError(`SSRC ${a} is not a number`);
                            this.ssrc = a, this.ownerEndpointId = n, this.muted = c, this.isP2P = d, Uo.debug(`New remote track added: ${this}`), this.hasBeenMuted = c, this.rtc && this.track && this._bindTrackHandlers(), this._containerHandlers = {}, qo.forEach((e => {
                                this._containerHandlers[e] = this._containerEventHandler.bind(this, e)
                            }))
                        }
                        _bindTrackHandlers() {
                            this.track.addEventListener("mute", (() => this._onTrackMute())), this.track.addEventListener("unmute", (() => this._onTrackUnmute())), this.track.addEventListener("ended", (() => {
                                Uo.debug(`"onended" event(${Date.now()}): ${this}`)
                            }))
                        }
                        _onTrackMute() {
                            Uo.debug(`"onmute" event(${Date.now()}): ${this}`), this.rtc.eventEmitter.emit(Vo.REMOTE_TRACK_MUTE, this)
                        }
                        _onTrackUnmute() {
                            Uo.debug(`"onunmute" event(${Date.now()}): ${this}`), this.rtc.eventEmitter.emit(Vo.REMOTE_TRACK_UNMUTE, this)
                        }
                        setMute(e) {
                            this.muted !== e && (e && (this.hasBeenMuted = !0), this.stream && (this.stream.muted = e), this.muted = e, this.emit(Qn, this))
                        }
                        isMuted() {
                            return this.muted
                        }
                        getParticipantId() {
                            return this.ownerEndpointId
                        }
                        isLocal() {
                            return !1
                        }
                        getSSRC() {
                            return this.ssrc
                        }
                        _setVideoType(e) {
                            this.videoType !== e && (this.videoType = e, this.emit(Xn, e))
                        }
                        _playCallback() {
                            const e = this.isVideoTrack() ? "video" : "audio",
                                t = window.performance.now();
                            console.log(`(TIME) Render ${e}:\t`, t), this.conference.getConnectionTimes()[`${e}.render`] = t;
                            const n = window.connectionTimes["obtainPermissions.start"],
                                i = window.connectionTimes["obtainPermissions.end"],
                                s = isNaN(i) || isNaN(n) ? 0 : i - n,
                                r = t - (this.conference.getConnectionTimes()["session.initiate"] - this.conference.getConnectionTimes()["muc.joined"]) - s;
                            var o;
                            this.conference.getConnectionTimes()[`${e}.ttfm`] = r, console.log(`(TIME) TTFM ${e}:\t`, r), On.sendAnalytics((o = {
                                media_type: e,
                                muted: this.hasBeenMuted,
                                value: r
                            }, bt("ttfm", o)))
                        }
                        _attachTTFMTracker(e) {
                            Ho && this.isAudioTrack() || Go && this.isVideoTrack() || (this.isAudioTrack() && (Ho = !0), this.isVideoTrack() && (Go = !0), e.addEventListener("canplay", this._playCallback.bind(this)))
                        }
                        _onTrackAttach(e) {
                            qo.forEach((t => {
                                e.addEventListener(t, this._containerHandlers[t])
                            }))
                        }
                        _onTrackDetach(e) {
                            qo.forEach((t => {
                                e.removeEventListener(t, this._containerHandlers[t])
                            }))
                        }
                        _containerEventHandler(e) {
                            Uo.debug(`${e} handler was called for a container with attached ${this}`)
                        }
                        _getStatus() {
                            const {
                                enabled: e,
                                muted: t,
                                readyState: n
                            } = this.track;
                            return `readyState: ${n}, muted: ${t}, enabled: ${e}`
                        }
                        toString() {
                            return `RemoteTrack[userID: ${this.getParticipantId()}, type: ${this.getType()}, ssrc: ${this.getSSRC()}, p2p: ${this.isP2P}, status: ${this._getStatus()}]`
                        }
                    }
                    const zo = (0, f.getLogger)("modules/RTC/TPCUtils.js"),
                        Wo = ["1", "2", "3"];
                    class Qo {
                        constructor(e, t) {
                            this.pc = e, this.videoBitrates = t.VP8 || t, this.localStreamEncodingsConfig = [{
                                active: !0,
                                maxBitrate: Qt.isFirefox() ? this.videoBitrates.high : this.videoBitrates.low,
                                rid: "1",
                                scaleResolutionDownBy: Qt.isFirefox() ? 1 : 4
                            }, {
                                active: !0,
                                maxBitrate: this.videoBitrates.standard,
                                rid: "2",
                                scaleResolutionDownBy: 2
                            }, {
                                active: !0,
                                maxBitrate: Qt.isFirefox() ? this.videoBitrates.low : this.videoBitrates.high,
                                rid: "3",
                                scaleResolutionDownBy: Qt.isFirefox() ? 4 : 1
                            }]
                        }
                        _findTransceiver(e, t = null) {
                            let n = null;
                            return !t || t && Qt.doesVideoMuteByStreamRemove() && t.isVideoTrack() && t.isMuted() ? n = this.pc.peerconnection.getTransceivers().find((t => {
                                var n, i;
                                return (null === (n = t.receiver) || void 0 === n || null === (i = n.track) || void 0 === i ? void 0 : i.kind) === e
                            })) : t && (n = this.pc.peerconnection.getTransceivers().find((e => {
                                var n, i;
                                return (null === (n = e.sender) || void 0 === n || null === (i = n.track) || void 0 === i ? void 0 : i.id) === t.getTrackId()
                            }))), n
                        }
                        _getStreamEncodings(e) {
                            return this.pc.isSimulcastOn() && e.isVideoTrack() ? this.localStreamEncodingsConfig : e.isVideoTrack() ? [{
                                active: !0,
                                maxBitrate: this.videoBitrates.high
                            }] : [{
                                active: !0
                            }]
                        }
                        ensureCorrectOrderOfSsrcs(e) {
                            const t = Io.parse(e.sdp);
                            return t.media.forEach((e => {
                                if (e.type === En) return;
                                if (!e.ssrcGroups || !e.ssrcGroups.length) return;
                                let t = [];
                                const n = new Set;
                                e.ssrcGroups.map((e => e.ssrcs.split(" ").filter(Boolean).forEach((e => n.add(e))))), n.forEach((n => {
                                    const i = e.ssrcs.filter((e => e.id.toString() === n));
                                    t = t.concat(i)
                                })), e.ssrcs = t
                            })), new RTCSessionDescription({
                                type: e.type,
                                sdp: Io.write(t)
                            })
                        }
                        insertUnifiedPlanSimulcastReceive(e) {
                            if (Qt.usesSdpMungingForSimulcast()) return e;
                            const t = Io.parse(e.sdp),
                                n = t.media.findIndex((e => e.type === Cn));
                            if (t.media[n].rids && (t.media[n].simulcast_03 || t.media[n].simulcast)) return t.media.forEach(((e, i) => {
                                e.type === Cn && i !== n && (t.media[i].rids = void 0, t.media[i].simulcast = void 0, t.media[i].simulcast_03 = void 0)
                            })), new RTCSessionDescription({
                                type: e.type,
                                sdp: Io.write(t)
                            });
                            t.media[n].rids = [{
                                id: "1",
                                direction: "recv"
                            }, {
                                id: "2",
                                direction: "recv"
                            }, {
                                id: "3",
                                direction: "recv"
                            }];
                            const i = Qt.isFirefox() && Qt.isVersionGreaterThan(71) ? `recv ${Wo.join(";")}` : `recv rid=${Wo.join(";")}`;
                            return t.media[n].simulcast_03 = {
                                value: i
                            }, new RTCSessionDescription({
                                type: e.type,
                                sdp: Io.write(t)
                            })
                        }
                        addTrack(e, t) {
                            const n = e.getTrack();
                            if (t) {
                                const t = {
                                    direction: xs().SENDRECV,
                                    streams: [e.getOriginalStream()],
                                    sendEncodings: []
                                };
                                Qt.isFirefox() || (t.sendEncodings = this._getStreamEncodings(e)), this.pc.peerconnection.addTransceiver(n, t)
                            } else this.pc.peerconnection.addTrack(n)
                        }
                        addTrackUnmute(e) {
                            const t = e.getType(),
                                n = e.getTrack(),
                                i = this._findTransceiver(t);
                            return i ? (zo.debug(`${this.pc} Adding ${e}`), i.sender.replaceTrack(n)) : Promise.reject(new Error(`RTCRtpTransceiver for ${t} not found`))
                        }
                        getLocalStreamHeightConstraints(e) {
                            if (Qt.isReactNative()) return null;
                            const t = [],
                                {
                                    height: n = 720
                                } = e.getSettings();
                            for (const e of this.localStreamEncodingsConfig) t.push(n / e.scaleResolutionDownBy);
                            return t
                        }
                        removeTrackMute(e) {
                            const t = e.getType(),
                                n = this._findTransceiver(t, e);
                            return n ? (zo.debug(`${this.pc} Removing ${e}`), n.sender.replaceTrack(null)) : Promise.reject(new Error(`RTCRtpTransceiver for ${t} not found`))
                        }
                        replaceTrack(e, t) {
                            if (e && t) {
                                const n = t.getType(),
                                    i = t.getOriginalStream();
                                if (!i) return this.pc.localTracks.delete(e.rtcId), this.pc.localTracks.set(t.rtcId, t), Promise.resolve();
                                const s = this._findTransceiver(n, e),
                                    r = t.getTrack();
                                return s ? (zo.debug(`${this.pc} Replacing ${e} with ${t}`), s.sender.replaceTrack(r).then((() => {
                                    const n = this.pc.localSSRCs.get(e.rtcId);
                                    this.pc.localTracks.delete(e.rtcId), this.pc.localSSRCs.delete(e.rtcId), this.pc._addedStreams = this.pc._addedStreams.filter((e => e !== i)), this.pc.localTracks.set(t.rtcId, t), this.pc._addedStreams.push(i), this.pc.localSSRCs.set(t.rtcId, n)
                                }))) : Promise.reject(new Error("replace track failed"))
                            }
                            return e && !t ? this.removeTrackMute(e).then((() => {
                                const t = e.getType(),
                                    n = this._findTransceiver(t);
                                n && (n.direction = xs().RECVONLY), this.pc.localTracks.delete(e.rtcId), this.pc.localSSRCs.delete(e.rtcId)
                            })) : t && !e ? this.addTrackUnmute(t).then((() => {
                                const e = t.getType(),
                                    n = this._findTransceiver(e, t);
                                return n && (n.direction = xs().SENDRECV), (Qt.usesSdpMungingForSimulcast() ? Promise.resolve() : this.setEncodings(t)).then((() => {
                                    this.pc.localTracks.set(t.rtcId, t)
                                }))
                            })) : (zo.info(`${this.pc} TPCUtils.replaceTrack called with no new track and no old track`), Promise.resolve())
                        }
                        setAudioTransferActive(e) {
                            this.setMediaTransferActive(En, e)
                        }
                        setEncodings(e) {
                            var t, n;
                            const i = e.getType(),
                                s = this._findTransceiver(i, e),
                                r = null == s || null === (t = s.sender) || void 0 === t ? void 0 : t.getParameters();
                            return (null == r || null === (n = r.encodings) || void 0 === n ? void 0 : n.length) ? (r.encodings = this._getStreamEncodings(e), s.sender.setParameters(r)) : Promise.resolve()
                        }
                        setMediaTransferActive(e, t) {
                            const n = this.pc.peerconnection.getTransceivers().filter((t => t.receiver && t.receiver.track && t.receiver.track.kind === e)),
                                i = this.pc.getLocalTracks(e);
                            zo.info(`${this.pc} ${t?"Enabling":"Suspending"} ${e} media transfer.`), n.forEach(((e, n) => {
                                t ? 0 === n && i.length ? e.direction = xs().SENDRECV : e.direction = xs().RECVONLY : e.direction = xs().INACTIVE
                            }))
                        }
                        setVideoTransferActive(e) {
                            this.setMediaTransferActive(Cn, e)
                        }
                        updateEncodingsResolution(e) {
                            var t;
                            Qt.isWebKitBased() && e.encodings && Array.isArray(e.encodings) && ((t = e.encodings).every((e => void 0 !== e.scaleResolutionDownBy && e.scaleResolutionDownBy === t[0].scaleResolutionDownBy)) && e.encodings.forEach(((e, t) => {
                                e.scaleResolutionDownBy = this.localStreamEncodingsConfig[t].scaleResolutionDownBy
                            })))
                        }
                    }
                    const Xo = (0, f.getLogger)("modules/RTC/TraceablePeerConnection.js"),
                        Yo = 25e5;

                    function Zo(e, t, i, s, r, o, a) {
                        this.audioTransferActive = !(!0 === a.startSilent), this._dtmfSender = void 0, this._dtmfTonesQueue = [], this.videoTransferActive = !0, this.rtc = e, this.id = t, this.isP2P = o, this.remoteTracks = new Map, this.localTracks = new Map, this._addedStreams = [], this.localSSRCs = new Map, this.localUfrag = null, this.remoteUfrag = null, this.signalingLayer = i, this._peerVideoTypeChanged = this._peerVideoTypeChanged.bind(this), this.signalingLayer.on(ir, this._peerVideoTypeChanged), this._peerMutedChanged = this._peerMutedChanged.bind(this), this.signalingLayer.on(nr, this._peerMutedChanged), this.options = a;
                        const c = r || {};
                        c.optional = c.optional || [], Array.isArray(c.optional) ? c.optional.push({
                            rtcStatsSFUP2P: this.isP2P
                        }) : Xo.warn("Optional param is not an array, rtcstats p2p data is omitted."), this.peerconnection = new po.RTCPeerConnectionType(s, c);
                        const d = {
                            low: 2e5,
                            standard: 7e5,
                            high: Yo
                        };
                        this.videoBitrates = this.options.videoQuality && this.options.videoQuality.maxBitratesVideo ? this.options.videoQuality.maxBitratesVideo : d, this.tpcUtils = new Qo(this, this.videoBitrates), this.updateLog = [], this.stats = {}, this.statsinterval = null, this._capScreenshareBitrate = this.options.capScreenshareBitrate, this._usesUnifiedPlan = a.usesUnifiedPlan, this._usesTransceiverCodecPreferences = Qt.supportsCodecPreferences() && this._usesUnifiedPlan, this._usesTransceiverCodecPreferences && Xo.info("Using RTCRtpTransceiver#setCodecPreferences for codec selection"), this.maxstats = a.maxstats, this.interop = new Po;
                        const l = n(9340);
                        this.simulcast = new l({
                            numOfLayers: Wo.length,
                            explodeRemoteSimulcast: !1,
                            usesUnifiedPlan: this._usesUnifiedPlan
                        }), this.sdpConsistency = new Jo(this.toString()), this.localSdpMunger = new xo(this, this.rtc.getLocalEndpointId()), this.eventEmitter = e.eventEmitter, this.rtxModifier = new $o, this.senderVideoMaxHeight = null, this.trace = (e, t) => {
                            Xo.debug(e, t), this.updateLog.push({
                                time: new Date,
                                type: e,
                                value: t || ""
                            })
                        }, this.onicecandidate = null, this.peerconnection.onicecandidate = e => {
                            this.trace("onicecandidate", JSON.stringify(e.candidate, null, " ")), null !== this.onicecandidate && this.onicecandidate(e)
                        }, this._usesUnifiedPlan ? (this.onTrack = e => {
                            const t = e.streams[0];
                            this._remoteTrackAdded(t, e.track, e.transceiver), t.addEventListener("removetrack", (e => {
                                this._remoteTrackRemoved(t, e.track)
                            }))
                        }, this.peerconnection.addEventListener("track", this.onTrack)) : (this.peerconnection.onaddstream = e => this._remoteStreamAdded(e.stream), this.peerconnection.onremovestream = e => this._remoteStreamRemoved(e.stream)), this.onsignalingstatechange = null, this.peerconnection.onsignalingstatechange = e => {
                            this.trace("onsignalingstatechange", this.signalingState), null !== this.onsignalingstatechange && this.onsignalingstatechange(e)
                        }, this.oniceconnectionstatechange = null, this.peerconnection.oniceconnectionstatechange = e => {
                            this.trace("oniceconnectionstatechange", this.iceConnectionState), null !== this.oniceconnectionstatechange && this.oniceconnectionstatechange(e)
                        }, this.onnegotiationneeded = null, this.peerconnection.onnegotiationneeded = e => {
                            this.trace("onnegotiationneeded"), null !== this.onnegotiationneeded && this.onnegotiationneeded(e)
                        }, this.onconnectionstatechange = null, this.peerconnection.onconnectionstatechange = e => {
                            this.trace("onconnectionstatechange", this.connectionState), null !== this.onconnectionstatechange && this.onconnectionstatechange(e)
                        }, this.ondatachannel = null, this.peerconnection.ondatachannel = e => {
                            this.trace("ondatachannel"), null !== this.ondatachannel && this.ondatachannel(e)
                        }, this.maxstats && (this.statsinterval = window.setInterval((() => {
                            this.getStats().then((e => {
                                if ("function" == typeof(null == e ? void 0 : e.result)) {
                                    const t = e.result();
                                    for (let e = 0; e < t.length; ++e) {
                                        const n = t[e];
                                        n.names().forEach((e => {
                                            this._processStat(n, e, n.stat(e))
                                        }))
                                    }
                                } else e.forEach((e => this._processStat(e, "", e)))
                            }))
                        }), 1e3)), Xo.info(`Create new ${this}`)
                    }
                    Zo.prototype._processStat = function(e, t, n) {
                        const i = `${e.id}-${t}`;
                        let s = this.stats[i];
                        const r = new Date;
                        s || (this.stats[i] = s = {
                            startTime: r,
                            endTime: r,
                            values: [],
                            times: []
                        }), s.values.push(n), s.times.push(r.getTime()), s.values.length > this.maxstats && (s.values.shift(), s.times.shift()), s.endTime = r
                    };
                    const ea = function(e) {
                        return null == e ? "" : `type: ${e.type}\r\n${e.sdp}`
                    };
                    Zo.prototype.getConnectionState = function() {
                        const e = this.peerconnection.iceConnectionState;
                        return "completed" === e ? "connected" : e
                    }, Zo.prototype.getDesiredMediaDirection = function(e, t = !1) {
                        const n = this.hasAnyTracksOfType(e);
                        return this._usesUnifiedPlan ? t ? n ? xs().SENDRECV : xs().SENDONLY : n ? xs().RECVONLY : xs().INACTIVE : (e === En ? this.audioTransferActive : this.videoTransferActive) ? n ? xs().SENDRECV : xs().RECVONLY : xs().INACTIVE
                    }, Zo.prototype._getReceiversByEndpointIds = function(e, t) {
                        let n = [],
                            i = [];
                        for (const i of e) n = n.concat(this.getRemoteTracks(i, t));
                        const s = n.map((e => {
                            var t;
                            return null === (t = e.track) || void 0 === t ? void 0 : t.id
                        }));
                        return i = this.peerconnection.getReceivers().filter((e => e.track && e.track.kind === t && s.find((t => t === e.track.id)))), i
                    }, Zo.prototype.isSimulcastOn = function() {
                        return !this.options.disableSimulcast
                    }, Zo.prototype._peerVideoTypeChanged = function(e, t) {
                        if (!e) return void Xo.error(`${this} No endpointID on peerVideoTypeChanged`);
                        const n = this.getRemoteTracks(e, Cn);
                        n.length && n[0]._setVideoType(t)
                    }, Zo.prototype._peerMutedChanged = function(e, t, n) {
                        if (!e) return void Xo.error(`${this} On peerMuteChanged - no endpoint ID`);
                        const i = this.getRemoteTracks(e, t);
                        i.length && i[0].setMute(n)
                    }, Zo.prototype.getAudioLevels = function(e = []) {
                        const t = {};
                        return (e.length ? this._getReceiversByEndpointIds(e, En) : this.peerconnection.getReceivers().filter((e => e.track && e.track.kind === En && e.track.enabled))).forEach((e => {
                            const n = e.getSynchronizationSources();
                            n && n.length && (t[n[0].source] = n[0].audioLevel)
                        })), t
                    }, Zo.prototype.getLocalTracks = function(e) {
                        let t = Array.from(this.localTracks.values());
                        return void 0 !== e && (t = t.filter((t => t.getType() === e))), t
                    }, Zo.prototype.getLocalVideoTrack = function() {
                        return this.getLocalTracks(Cn)[0]
                    }, Zo.prototype.hasAnyTracksOfType = function(e) {
                        if (!e) throw new Error('"mediaType" is required');
                        return this.getLocalTracks(e).length > 0
                    }, Zo.prototype.getRemoteTracks = function(e, t) {
                        const n = [],
                            i = e ? [e] : this.remoteTracks.keys();
                        for (const e of i) {
                            const i = this.remoteTracks.get(e);
                            if (i)
                                for (const e of i.keys())
                                    if (!t || t === e) {
                                        const t = i.get(e);
                                        t && n.push(t)
                                    }
                        }
                        return n
                    }, Zo.prototype.getRemoteSourceInfoByParticipant = function(e) {
                        const t = [],
                            n = this.getRemoteTracks(e);
                        if (!(null == n ? void 0 : n.length)) return t;
                        const i = n.map((e => e.getSSRC())),
                            s = new Us(this.remoteDescription.sdp);
                        return i.forEach(((e, n) => {
                            for (const i of s.media) {
                                let s = "",
                                    r = Js.findLines(i, `a=ssrc:${e}`);
                                if (r.length) {
                                    t[n] || (t[n] = "");
                                    const o = Js.findLines(i, `a=ssrc-group:FID ${e}`);
                                    if (o.length) {
                                        const e = o[0].split(" ")[2];
                                        s += `${o[0]}\r\n`, r = r.concat(Js.findLines(i, `a=ssrc:${e}`))
                                    }
                                    t[n] += `${r.join("\r\n")}\r\n`, t[n] += s
                                }
                            }
                        })), t
                    }, Zo.prototype.getTargetVideoBitrates = function() {
                        const e = this.getConfiguredVideoCodec();
                        return this.videoBitrates[e.toUpperCase()] || this.videoBitrates
                    }, Zo.prototype.getTrackBySSRC = function(e) {
                        if ("number" != typeof e) throw new Error(`SSRC ${e} is not a number`);
                        for (const t of this.localTracks.values())
                            if (this.getLocalSSRC(t) === e) return t;
                        for (const t of this.getRemoteTracks())
                            if (t.getSSRC() === e) return t;
                        return null
                    }, Zo.prototype.getSsrcByTrackId = function(e) {
                        const t = t => t.getTrack().id === e,
                            n = this.getLocalTracks().find(t);
                        if (n) return this.getLocalSSRC(n);
                        const i = this.getRemoteTracks().find(t);
                        return i ? i.getSSRC() : null
                    }, Zo.prototype._remoteStreamAdded = function(e) {
                        const t = oa.getStreamID(e);
                        if (!oa.isUserStreamById(t)) return void Xo.info(`${this} ignored remote 'stream added' event for non-user stream[id=${t}]`);
                        Qt.isChromiumBased() && (e.onaddtrack = t => {
                            this._remoteTrackAdded(e, t.track)
                        }, e.onremovetrack = t => {
                            this._remoteTrackRemoved(e, t.track)
                        });
                        const n = e.getAudioTracks();
                        for (const t of n) this._remoteTrackAdded(e, t);
                        const i = e.getVideoTracks();
                        for (const t of i) this._remoteTrackAdded(e, t)
                    }, Zo.prototype._remoteTrackAdded = function(e, t, n = null) {
                        const i = oa.getStreamID(e),
                            s = t.kind;
                        if (!this.isP2P && !oa.isUserStreamById(i)) return void Xo.info(`${this} ignored remote 'stream added' event for non-user stream[id=${i}]`);
                        if (Xo.info(`${this} adding remote track for stream[id=${i},type=${s}]`), !s) return void nn.callErrorHandler(new Error(`MediaType undefined for remote track, stream id: ${i}`));
                        const r = this._usesUnifiedPlan ? new Us(this.peerconnection.remoteDescription.sdp) : new Us(this.remoteDescription.sdp);
                        let o;
                        if (this._usesUnifiedPlan)
                            if (n && n.mid) {
                                const e = n.mid;
                                o = r.media.filter((t => Js.findLine(t, `a=mid:${e}`)))
                            } else o = r.media.filter((e => {
                                const t = Js.findLine(e, "a=msid:");
                                return void 0 !== t && i === t.substring(7).split(" ")[0]
                            }));
                        else o = r.media.filter((e => e.startsWith(`m=${s}`)));
                        if (!o.length) return void nn.callErrorHandler(new Error(`No media lines found in remote SDP for remote stream[id=${i},type=${s}]`));
                        let a = Js.findLines(o[0], "a=ssrc:");
                        if (a = a.filter((e => -1 !== e.indexOf(`msid:${i}`))), !a.length) return void nn.callErrorHandler(new Error(`No SSRC lines found in remote SDP for remote stream[msid=${i},type=${s}]`));
                        const c = a[0].substring(7).split(" ")[0],
                            d = Number(c),
                            l = this.signalingLayer.getSSRCOwner(d);
                        if (isNaN(d) || d < 0) return void nn.callErrorHandler(new Error(`Invalid SSRC for remote stream[ssrc=${d},id=${i},type=${s}]`));
                        if (!l) return void nn.callErrorHandler(new Error(`No SSRC owner known for remote stream[ssrc=${d},id=${i},type=${s}]`));
                        Xo.info(`${this} creating remote track[endpoint=${l},ssrc=${d},type=${s}]`);
                        const h = this.signalingLayer.getPeerMediaInfo(l, s);
                        if (!h) return void nn.callErrorHandler(new Error(`${this}: no peer media info available for ${l}`));
                        const u = h.muted,
                            p = h.videoType;
                        this._createRemoteTrack(l, e, t, s, p, d, u)
                    }, Zo.prototype._createRemoteTrack = function(e, t, n, i, s, r, o) {
                        let a = this.remoteTracks.get(e);
                        a || (a = new Map, this.remoteTracks.set(e, a));
                        const c = a.get(i);
                        if (c && c.getTrack() === n) return void Xo.info(`${this} ignored duplicated track event for track[endpoint=${e},type=${i}]`);
                        c && (Xo.error(`${this} received a second remote track for track[endpoint=${e},type=${i}]deleting the existing track`), this._remoteTrackRemoved(c.getOriginalStream(), c.getTrack()));
                        const d = new Ko(this.rtc, this.rtc.conference, e, t, n, i, s, r, o, this.isP2P);
                        a.set(i, d), this.eventEmitter.emit(jn().REMOTE_TRACK_ADDED, d, this)
                    }, Zo.prototype._remoteStreamRemoved = function(e) {
                        if (!oa.isUserStream(e)) {
                            const t = oa.getStreamID(e);
                            return void Xo.info(`Ignored remote 'stream removed' event for stream[id=${t}]`)
                        }
                        const t = e.getVideoTracks();
                        for (const n of t) this._remoteTrackRemoved(e, n);
                        const n = e.getAudioTracks();
                        for (const t of n) this._remoteTrackRemoved(e, t)
                    }, Zo.prototype._remoteTrackRemoved = function(e, t) {
                        const n = oa.getStreamID(e),
                            i = t && oa.getTrackID(t);
                        oa.isUserStreamById(n) ? (Xo.info(`${this} remote track removed stream[id=${n},trackId=${i}]`), n ? i ? this._removeRemoteTrackById(n, i) || Xo.warn(`${this} Removed track not found for stream[id=${n},trackId=${i}]`) : nn.callErrorHandler(new Error(`${this} remote track removal failed - no track ID`)) : nn.callErrorHandler(new Error(`${this} remote track removal failed - no stream ID`))) : Xo.info(`${this} ignored remote 'stream removed' event for non-user stream[id=${n}]`)
                    }, Zo.prototype._getRemoteTrackById = function(e, t) {
                        for (const n of this.remoteTracks.values())
                            for (const i of n.values())
                                if (i.getStreamId() == e && i.getTrackId() == t) return i
                    }, Zo.prototype.removeRemoteTracks = function(e) {
                        const t = [],
                            n = this.remoteTracks.get(e);
                        if (n) {
                            const i = n.get(En),
                                s = n.get(Cn);
                            i && t.push(i), s && t.push(s), this.remoteTracks.delete(e)
                        }
                        return Xo.debug(`${this} removed remote tracks[endpoint=${e},count=${t.length}`), t
                    }, Zo.prototype._removeRemoteTrack = function(e) {
                        e.dispose();
                        const t = e.getParticipantId(),
                            n = this.remoteTracks.get(t);
                        n ? n.delete(e.getType()) || Xo.error(`${this} Failed to remove ${e} - type mapping messed up ?`) : Xo.error(`${this} removeRemoteTrack: no remote tracks map for endpoint=${t}`), this.eventEmitter.emit(jn().REMOTE_TRACK_REMOVED, e)
                    }, Zo.prototype._removeRemoteTrackById = function(e, t) {
                        const n = this._getRemoteTrackById(e, t);
                        return n && this._removeRemoteTrack(n), n
                    }, Zo.prototype._extractSSRCMap = function(e) {
                        const t = new Map,
                            n = new Map;
                        if ("object" != typeof e || null === e || "string" != typeof e.sdp) return Xo.warn("An empty description was passed as an argument"), t;
                        const i = Io.parse(e.sdp);
                        if (!Array.isArray(i.media)) return t;
                        let s = i.media;
                        this._usesUnifiedPlan && (s = [], [En, Cn].forEach((e => {
                            const t = i.media.find((t => t.type === e));
                            t && s.push(t)
                        })));
                        for (const e of s) {
                            if (!Array.isArray(e.ssrcs)) continue;
                            if (Array.isArray(e.ssrcGroups))
                                for (const t of e.ssrcGroups)
                                    if (void 0 !== t.semantics && void 0 !== t.ssrcs) {
                                        const e = t.ssrcs.split(" ").map((e => parseInt(e, 10))),
                                            i = e[0];
                                        t.ssrcs = e, n.has(i) || n.set(i, []), n.get(i).push(t)
                                    } let i = e.ssrcs;
                            i = this._usesUnifiedPlan ? i.filter((e => "cname" === e.attribute)) : i.filter((e => "msid" === e.attribute));
                            for (const s of i) {
                                const i = this._usesUnifiedPlan ? e.type : s.value,
                                    r = s.id;
                                let o = t.get(i);
                                if (o || (o = {
                                        ssrcs: [],
                                        groups: [],
                                        msid: i
                                    }, t.set(i, o)), o.ssrcs.push(r), n.has(r)) {
                                    const e = n.get(r);
                                    for (const t of e) o.groups.push(t)
                                }
                            }
                        }
                        return t
                    };
                    Zo.prototype.getLocalSSRC = function(e) {
                        const t = this._getSSRC(e.rtcId);
                        return t && t.ssrcs[0]
                    }, Zo.prototype._injectSsrcGroupForUnifiedSimulcast = function(e) {
                        const t = Io.parse(e.sdp),
                            n = t.media.find((e => "video" === e.type));
                        n.ssrcGroups = n.ssrcGroups || [];
                        const i = n.ssrcGroups.filter((e => "FID" === e.semantics));
                        if (n.simulcast || n.simulcast_03) {
                            const t = [];
                            if (i && i.length ? i.forEach((e => {
                                    t.push(e.ssrcs.split(" ")[0])
                                })) : n.ssrcs.forEach((e => {
                                    "msid" === e.attribute && t.push(e.id)
                                })), n.ssrcGroups.find((e => "SIM" === e.semantics))) return e;
                            n.ssrcGroups.push({
                                semantics: "SIM",
                                ssrcs: t.join(" ")
                            })
                        }
                        return new RTCSessionDescription({
                            type: e.type,
                            sdp: Io.write(t)
                        })
                    };
                    const ta = {
                        signalingState() {
                            return this.peerconnection.signalingState
                        },
                        iceConnectionState() {
                            return this.peerconnection.iceConnectionState
                        },
                        connectionState() {
                            return this.peerconnection.connectionState
                        },
                        localDescription() {
                            let e = this.peerconnection.localDescription;
                            return e ? (this.trace("getLocalDescription::preTransform", ea(e)), this._usesUnifiedPlan && !this.isP2P ? (e = this.interop.toPlanB(e), this.trace("getLocalDescription::postTransform (Plan B)", ea(e)), e = this._injectSsrcGroupForUnifiedSimulcast(e), this.trace("getLocalDescription::postTransform (inject ssrc group)", ea(e))) : this._usesUnifiedPlan || (Qt.doesVideoMuteByStreamRemove() && (e = this.localSdpMunger.maybeAddMutedLocalVideoTracksToSDP(e), Xo.debug("getLocalDescription::postTransform (munge local SDP)", e)), e = function(e, t) {
                                if (!e) throw new Error("No local description passed in.");
                                const n = new Oo(e.sdp),
                                    i = n.selectMedia(En);
                                let s = !1;
                                i && i.direction !== xs().SENDRECV && (t.startSilent ? i.direction = xs().INACTIVE : i.direction = xs().SENDRECV, s = !0);
                                const r = n.selectMedia(Cn);
                                return r && r.direction !== xs().SENDRECV && (r.direction = xs().SENDRECV, s = !0), s ? new RTCSessionDescription({
                                    type: e.type,
                                    sdp: n.toRawSDP()
                                }) : e
                            }(e, this.options)), e = this.localSdpMunger.transformStreamIdentifiers(e), e) : (Xo.debug(`${this} getLocalDescription no localDescription found`), {})
                        },
                        remoteDescription() {
                            let e = this.peerconnection.remoteDescription;
                            return e ? (this.trace("getRemoteDescription::preTransform", ea(e)), this._usesUnifiedPlan && (this.isP2P ? e = this._adjustRemoteMediaDirection(e) : (e = this.interop.toPlanB(e), this.trace("getRemoteDescription::postTransform (Plan B)", ea(e)))), e) : (Xo.debug(`${this} getRemoteDescription no remoteDescription found`), {})
                        }
                    };
                    Object.keys(ta).forEach((e => {
                        Object.defineProperty(Zo.prototype, e, {
                            get: ta[e]
                        })
                    })), Zo.prototype._getSSRC = function(e) {
                        return this.localSSRCs.get(e)
                    }, Zo.prototype._isSharingLowFpsScreen = function() {
                        return this._isSharingScreen() && this._capScreenshareBitrate
                    }, Zo.prototype._isSharingScreen = function() {
                        const e = this.getLocalVideoTrack();
                        return e && e.videoType === $n.DESKTOP
                    }, Zo.prototype._mungeCodecOrder = function(e) {
                        if (!this.codecPreference) return e;
                        const t = Io.parse(e.sdp),
                            n = t.media.find((e => e.type === this.codecPreference.mediaType));
                        if (!n) return e;
                        if (this.codecPreference.enable)
                            if (Js.preferCodec(n, this.codecPreference.mimeType), this.codecPreference.mimeType === ks.H264 && Qt.isReactNative() && this.isP2P && Js.stripCodec(n, this.codecPreference.mimeType, !0), this.codecPreference.mimeType === ks.VP9 && this.getConfiguredVideoCodec() === ks.VP9) {
                                const e = this.videoBitrates.VP9 || this.videoBitrates,
                                    t = e.high ? e.high : Yo,
                                    i = Math.floor((this._isSharingScreen() ? Yo : t) / 1e3);
                                n.bandwidth = [{
                                    type: "AS",
                                    limit: i
                                }]
                            } else n.bandwidth = void 0;
                        else Js.stripCodec(n, this.codecPreference.mimeType);
                        return new RTCSessionDescription({
                            type: e.type,
                            sdp: Io.write(t)
                        })
                    }, Zo.prototype.containsTrack = function(e) {
                        if (e.isLocal()) return this.localTracks.has(e.rtcId);
                        const t = e.getParticipantId(),
                            n = this.remoteTracks.get(t);
                        return Boolean(n && n.get(e.getType()) === e)
                    }, Zo.prototype.addTrack = function(e, t = !1) {
                        const n = e.rtcId;
                        if (Xo.info(`${this} adding ${e}`), this.localTracks.has(n)) return Promise.reject(new Error(`${e} is already in ${this}`));
                        if (this.localTracks.set(n, e), this._usesUnifiedPlan) try {
                            this.tpcUtils.addTrack(e, t)
                        } catch (t) {
                            return Xo.error(`${this} Adding track=${e} failed: ${null==t?void 0:t.message}`), Promise.reject(t)
                        } else {
                            const t = e.getOriginalStream();
                            if (t) this._addStream(t);
                            else if (!Qt.doesVideoMuteByStreamRemove() || e.isAudioTrack() || e.isVideoTrack() && !e.isMuted()) return Promise.reject(new Error(`${this} no WebRTC stream for track=${e}`));
                            if (Qt.doesVideoMuteByStreamRemove() && e.isVideoTrack() && e.isMuted()) {
                                const t = this.generateNewStreamSSRCInfo(e);
                                this.sdpConsistency.setPrimarySsrc(t.ssrcs[0]);
                                const n = t.groups.find((e => "SIM" === e.semantics));
                                n && this.simulcast.setSsrcCache(n.ssrcs);
                                const i = t.groups.filter((e => "FID" === e.semantics));
                                if (i) {
                                    const e = new Map;
                                    i.forEach((t => {
                                        const n = t.ssrcs[0],
                                            i = t.ssrcs[1];
                                        e.set(n, i)
                                    })), this.rtxModifier.setSsrcCache(e)
                                }
                            }
                        }
                        let i = Promise.resolve();
                        return Qt.isFirefox() && (i = i.then((() => this.tpcUtils.setEncodings(e)))), i
                    }, Zo.prototype.addTrackUnmute = function(e) {
                        if (!this._assertTrackBelongs("addTrackUnmute", e)) return Promise.reject("Track not found on the peerconnection");
                        Xo.info(`${this} Adding track=${e} as unmute`);
                        const t = e.getOriginalStream();
                        return t ? this._usesUnifiedPlan ? this.tpcUtils.addTrackUnmute(e) : (this._addStream(t), Promise.resolve(!0)) : (Xo.error(`${this} Unable to add track=${e} as unmute - no WebRTC stream`), Promise.reject("Stream not found"))
                    }, Zo.prototype._addStream = function(e) {
                        this.peerconnection.addStream(e), this._addedStreams.push(e)
                    }, Zo.prototype._removeStream = function(e) {
                        this.peerconnection.removeStream(e), this._addedStreams = this._addedStreams.filter((t => t !== e))
                    }, Zo.prototype._assertTrackBelongs = function(e, t) {
                        const n = this.localTracks.has(t.rtcId);
                        return n || Xo.error(`${this} ${e}: track=${t} does not belong to pc`), n
                    }, Zo.prototype.getConfiguredVideoCodec = function() {
                        var e;
                        const t = null === (e = this.peerconnection.localDescription) || void 0 === e ? void 0 : e.sdp,
                            n = ks.VP8;
                        if (!t) return n;
                        const i = Io.parse(t).media.find((e => e.type === Cn)).rtp[0].codec;
                        return i ? Object.values(ks).find((e => e === i.toLowerCase())) : n
                    }, Zo.prototype.setDesktopSharingFrameRate = function(e) {
                        const t = e <= 5;
                        this._capScreenshareBitrate = this.isSimulcastOn() && t
                    }, Zo.prototype.setVideoCodecs = function(e = null, t = null) {
                        const n = null === t,
                            i = t || e;
                        this.codecPreference && (e || t) ? (this.codecPreference.enable = n, this.codecPreference.mimeType = i) : e || t ? this.codecPreference = {
                            enable: n,
                            mediaType: Cn,
                            mimeType: i
                        } : Xo.warn(`${this} Invalid codec settings[preferred=${e},disabled=${t}],\n            atleast one value is needed`)
                    }, Zo.prototype.isMediaStreamInPc = function(e) {
                        return this._addedStreams.indexOf(e) > -1
                    }, Zo.prototype.removeTrack = function(e) {
                        const t = e.getOriginalStream();
                        this.trace("removeStream", e.rtcId, t ? t.id : void 0), this._assertTrackBelongs("removeStream", e) && (this.localTracks.delete(e.rtcId), this.localSSRCs.delete(e.rtcId), t && this.peerconnection.removeStream(t))
                    }, Zo.prototype.findSenderByKind = function(e) {
                        return this.peerconnection.getSenders().find((t => t.track && t.track.kind === e))
                    }, Zo.prototype.findReceiverForTrack = function(e) {
                        return this.peerconnection.getReceivers().find((t => t.track === e))
                    }, Zo.prototype.findSenderForTrack = function(e) {
                        return this.peerconnection.getSenders().find((t => t.track === e))
                    }, Zo.prototype.replaceTrack = function(e, t) {
                        if (this._usesUnifiedPlan) return Xo.debug(`${this} TPC.replaceTrack using unified plan`), this.tpcUtils.replaceTrack(e, t).then((() => this.isSimulcastOn() && Qt.usesSdpMungingForSimulcast() || this.isP2P));
                        Xo.debug(`${this} TPC.replaceTrack using plan B`);
                        let n = Promise.resolve();
                        return e && this.removeTrack(e), t && (n = this.addTrack(t)), n.then((() => !0))
                    }, Zo.prototype.removeTrackMute = function(e) {
                        const t = e.getOriginalStream();
                        return this.trace("removeStreamMute", e.rtcId, t ? t.id : null), this._assertTrackBelongs("removeStreamMute", e) ? this._usesUnifiedPlan ? this.tpcUtils.removeTrackMute(e) : t ? (Xo.info(`${this} Removing track=${e} as mute`), this._removeStream(t), Promise.resolve(!0)) : (Xo.error(`${this} removeStreamMute - no WebRTC stream for track=${e}`), Promise.reject("Stream not found")) : Promise.reject("Track not found in the peerconnection")
                    }, Zo.prototype.createDataChannel = function(e, t) {
                        return this.trace("createDataChannel", e, t), this.peerconnection.createDataChannel(e, t)
                    }, Zo.prototype._ensureSimulcastGroupIsLast = function(e) {
                        let t = e.sdp;
                        const n = t.indexOf("m=video"),
                            i = t.indexOf("a=ssrc-group:SIM", n);
                        let s = t.lastIndexOf("a=ssrc-group");
                        if (-1 === i || -1 === s || s === i) return e;
                        const r = t.indexOf("\r\n", i),
                            o = t.substring(i, r + 2);
                        t = t.replace(o, ""), s = t.lastIndexOf("a=ssrc-group");
                        const a = t.indexOf("\r\n", s),
                            c = t.slice(0, a),
                            d = o.trim(),
                            l = t.slice(a);
                        return t = `${c}\r\n${d}${l}`, new RTCSessionDescription({
                            type: e.type,
                            sdp: t
                        })
                    }, Zo.prototype._adjustLocalMediaDirection = function(e) {
                        const t = new Oo(e.sdp);
                        let n = !1;
                        const i = t.selectMedia(En);
                        if (i) {
                            const e = this.getDesiredMediaDirection(En);
                            i.direction !== e && (i.direction = e, Xo.info(`${this} Adjusted local audio direction to ${e}`), n = !0)
                        } else Xo.warn(`${this} No "audio" media found in the local description`);
                        const s = t.selectMedia(Cn);
                        if (s) {
                            const e = this.getDesiredMediaDirection(Cn);
                            s.direction !== e && (s.direction = e, Xo.info(`${this} Adjusted local video direction to ${e}`), n = !0)
                        } else Xo.warn(`${this} No "video" media found in the local description`);
                        return n ? new RTCSessionDescription({
                            type: e.type,
                            sdp: t.toRawSDP()
                        }) : e
                    }, Zo.prototype._adjustRemoteMediaDirection = function(e) {
                        const t = new Oo(e.sdp);
                        return [En, Cn].forEach((e => {
                            const n = t.selectMedia(e),
                                i = this.hasAnyTracksOfType(e),
                                s = this.getRemoteTracks(null, e).length > 0;
                            n.direction = i && s ? xs().SENDRECV : i ? xs().RECVONLY : s ? xs().SENDONLY : xs().INACTIVE
                        })), new RTCSessionDescription({
                            type: e.type,
                            sdp: t.toRawSDP()
                        })
                    }, Zo.prototype._mungeOpus = function(e) {
                        const {
                            audioQuality: t
                        } = this.options;
                        if (!(null == t ? void 0 : t.stereo) && !(null == t ? void 0 : t.opusMaxAverageBitrate)) return e;
                        const n = Io.parse(e.sdp),
                            i = n.media;
                        for (const e of i)
                            if ("audio" === e.type) {
                                const {
                                    payload: n
                                } = e.rtp.find((e => e.codec === ks.OPUS));
                                if (!n) continue;
                                let i = e.fmtp.find((e => e.payload === n));
                                i || (i = {
                                    payload: n,
                                    config: ""
                                });
                                const s = Io.parseParams(i.config);
                                let r = !1;
                                if ((null == t ? void 0 : t.stereo) && (s.stereo = 1, r = !0), (null == t ? void 0 : t.opusMaxAverageBitrate) && (s.maxaveragebitrate = t.opusMaxAverageBitrate, r = !0), !r) continue;
                                let o = "";
                                for (const e of Object.keys(s)) o += `${e}=${s[e]}; `;
                                i.config = o.trim()
                            } return new RTCSessionDescription({
                            type: e.type,
                            sdp: Io.write(n)
                        })
                    }, Zo.prototype.setLocalDescription = function(e) {
                        let t = e;
                        return this.trace("setLocalDescription::preTransform", ea(t)), t = this._mungeOpus(t), this._usesUnifiedPlan ? this.isP2P || (t = this.interop.toUnifiedPlan(t), this.trace("setLocalDescription::postTransform (Unified Plan)", ea(t))) : (t = this._adjustLocalMediaDirection(t), t = this._ensureSimulcastGroupIsLast(t)), this._usesTransceiverCodecPreferences || (t = this._mungeCodecOrder(t)), new Promise(((e, n) => {
                            this.peerconnection.setLocalDescription(t).then((() => {
                                this.trace("setLocalDescriptionOnSuccess");
                                const n = Js.getUfrag(t.sdp);
                                n !== this.localUfrag && (this.localUfrag = n, this.eventEmitter.emit(jn().LOCAL_UFRAG_CHANGED, this, n)), e()
                            }), (e => {
                                this.trace("setLocalDescriptionOnFailure", e), this.eventEmitter.emit(jn().SET_LOCAL_DESCRIPTION_FAILED, e, this), n(e)
                            }))
                        }))
                    }, Zo.prototype.setAudioTransferActive = function(e) {
                        Xo.debug(`${this} audio transfer active: ${e}`);
                        const t = this.audioTransferActive !== e;
                        return this.audioTransferActive = e, this._usesUnifiedPlan ? (this.tpcUtils.setAudioTransferActive(e), !1) : t
                    }, Zo.prototype.setSenderVideoDegradationPreference = function() {
                        if (!this.peerconnection.getSenders) return Xo.debug(`${this} Browser does not support RTCRtpSender`), Promise.resolve();
                        const e = this.getLocalVideoTrack(),
                            t = this.findSenderByKind(Cn);
                        if (!t) return Promise.resolve();
                        const n = t.getParameters(),
                            i = this._isSharingLowFpsScreen() ? "maintain-resolution" : "maintain-framerate";
                        return Xo.info(`${this} Setting a degradation preference [preference=${i},track=${e}`), n.degradationPreference = i, this.tpcUtils.updateEncodingsResolution(n), t.setParameters(n)
                    }, Zo.prototype.setMaxBitRate = function() {
                        var e, t, n;
                        if (this.getConfiguredVideoCodec() === ks.VP9 || !window.RTCRtpSender) return Promise.resolve();
                        const i = this.getLocalVideoTrack();
                        if (!i) return Promise.resolve();
                        const s = i.getVideoType();
                        if (!((null === (e = this.options) || void 0 === e || null === (t = e.videoQuality) || void 0 === t ? void 0 : t.maxBitratesVideo) || this._isSharingLowFpsScreen() || this._usesUnifiedPlan)) return Promise.resolve();
                        const r = i._originalStream && i._originalStream.id !== i.getStreamId(),
                            o = this.findSenderByKind(Cn);
                        if (!o) return Promise.resolve();
                        const a = o.getParameters();
                        if (!(null === (n = a.encodings) || void 0 === n ? void 0 : n.length)) return Promise.resolve();
                        if (this.isSimulcastOn()) {
                            for (const e in a.encodings)
                                if (a.encodings.hasOwnProperty(e)) {
                                    const t = this._isSharingLowFpsScreen() ? r ? Yo : 5e5 : s === $n.DESKTOP && Qt.isChromiumBased() ? void 0 : this.tpcUtils.localStreamEncodingsConfig[e].maxBitrate;
                                    Xo.info(`${this} Setting a max bitrate of ${t} bps on layer ${this.tpcUtils.localStreamEncodingsConfig[e].rid}`), a.encodings[e].maxBitrate = t
                                }
                        } else {
                            var c;
                            let e = null === (c = this.getTargetVideoBitrates()) || void 0 === c ? void 0 : c.high;
                            if (s === $n.CAMERA) {
                                const t = this.senderVideoMaxHeight ? Math.floor(i.resolution / this.senderVideoMaxHeight) : 1,
                                    n = this.tpcUtils.localStreamEncodingsConfig.find((e => e.scaleResolutionDownBy === t));
                                n && (Xo.info(`${this} Setting max bitrate=${n.maxBitrate} bps on track=${i}`), e = n.maxBitrate)
                            }
                            a.encodings[0].maxBitrate = e
                        }
                        return this.tpcUtils.updateEncodingsResolution(a), o.setParameters(a)
                    }, Zo.prototype.setRemoteDescription = function(e) {
                        if (this.trace("setRemoteDescription::preTransform", ea(e)), e = this._mungeOpus(e), this._usesUnifiedPlan) {
                            if (!this.isP2P) {
                                const t = this.peerconnection.remoteDescription;
                                e = this.interop.toUnifiedPlan(e, t), this.trace("setRemoteDescription::postTransform (Unified)", ea(e)), this.isSimulcastOn() && (e = this.simulcast.mungeRemoteDescription(e), e = this.tpcUtils.insertUnifiedPlanSimulcastReceive(e), this.trace("setRemoteDescription::postTransform (sim receive)", ea(e)))
                            }
                        } else this.isSimulcastOn() && (e = this.simulcast.mungeRemoteDescription(e, !0), this.trace("setRemoteDescription::postTransform (simulcast)", ea(e))), e = function(e) {
                            if ("object" != typeof e || null === e || "string" != typeof e.sdp) return Xo.warn("An empty description was passed as an argument"), e;
                            const t = n(1810),
                                i = t.parse(e.sdp);
                            void 0 !== i && void 0 !== i.media && Array.isArray(i.media) && i.media.forEach((e => {
                                const t = [],
                                    n = [];
                                if (void 0 !== e.ssrcGroups && Array.isArray(e.ssrcGroups) && e.ssrcGroups.forEach((e => {
                                        void 0 !== e.semantics && "FID" === e.semantics && void 0 !== e.ssrcs && t.push(Number(e.ssrcs.split(" ")[0]))
                                    })), Array.isArray(e.ssrcs)) {
                                    let i;
                                    for (i = 0; i < e.ssrcs.length; i++) "object" == typeof e.ssrcs[i] && void 0 !== e.ssrcs[i].id && t.indexOf(e.ssrcs[i].id) >= 0 && (n.push(e.ssrcs[i]), delete e.ssrcs[i]);
                                    for (i = 0; i < e.ssrcs.length; i++) void 0 !== e.ssrcs[i] && n.push(e.ssrcs[i]);
                                    e.ssrcs = function(e = []) {
                                        if (!Qt.isChrome() || !Qt.isVersionGreaterThan(70)) return e;
                                        let t = [...e];
                                        return e.filter((e => "mslabel" === e.attribute && "-" === e.value)).map((e => e.id)).forEach((e => {
                                            const n = t.find((t => t.id === e && "cname" === t.attribute));
                                            n.value = `${xs().RECVONLY}-${e}`, t = t.filter((t => t.id !== e)), t.push(n)
                                        })), t
                                    }(n)
                                }
                            }));
                            const s = t.write(i);
                            return new RTCSessionDescription({
                                type: e.type,
                                sdp: s
                            })
                        }(e);
                        return e = this._mungeCodecOrder(e), this._usesUnifiedPlan && (e = this.tpcUtils.ensureCorrectOrderOfSsrcs(e)), new Promise(((t, n) => {
                            this.peerconnection.setRemoteDescription(e).then((() => {
                                this.trace("setRemoteDescriptionOnSuccess");
                                const n = Js.getUfrag(e.sdp);
                                n !== this.remoteUfrag && (this.remoteUfrag = n, this.eventEmitter.emit(jn().REMOTE_UFRAG_CHANGED, this, n)), t()
                            }), (e => {
                                this.trace("setRemoteDescriptionOnFailure", e), this.eventEmitter.emit(jn().SET_REMOTE_DESCRIPTION_FAILED, e, this), n(e)
                            }))
                        }))
                    }, Zo.prototype.setSenderVideoConstraint = function(e = null) {
                        var t;
                        if (e < 0) throw new Error(`Invalid frameHeight: ${e}`);
                        if (Qt.isReactNative()) return Promise.resolve();
                        const n = null === e ? this.senderVideoMaxHeight : e;
                        if (this.senderVideoMaxHeight = n, null === n) return Promise.resolve();
                        Xo.log(`${this} senderVideoMaxHeight: ${n}`);
                        const i = this.getLocalVideoTrack();
                        if (!i || i.isMuted()) return Promise.resolve();
                        const s = this.findSenderByKind(Cn);
                        if (!s) return Promise.resolve();
                        const r = s.getParameters();
                        if (!(null == r || null === (t = r.encodings) || void 0 === t ? void 0 : t.length)) return Promise.resolve();
                        if (this.isSimulcastOn()) {
                            this.encodingsEnabledState = this.tpcUtils.getLocalStreamHeightConstraints(i.track).map((e => e <= n));
                            const e = this.tpcUtils.localStreamEncodingsConfig.findIndex((e => 4 === e.scaleResolutionDownBy));
                            if (n > 0 && -1 !== e && (this.encodingsEnabledState[e] = !0), this._isSharingLowFpsScreen() && this._usesUnifiedPlan && !Qt.isWebKitBased()) {
                                const e = Qt.isFirefox() ? 0 : this.encodingsEnabledState.length - 1;
                                this.encodingsEnabledState = this.encodingsEnabledState.map(((t, n) => n === e))
                            }
                            for (const e in r.encodings) r.encodings.hasOwnProperty(e) && (r.encodings[e].active = this.encodingsEnabledState[e]);
                            this.tpcUtils.updateEncodingsResolution(r)
                        } else n > 0 ? (r.encodings[0].scaleResolutionDownBy = i.videoType === $n.DESKTOP || i.resolution <= n ? 1 : Math.floor(i.resolution / n), r.encodings[0].active = !0) : (r.encodings[0].scaleResolutionDownBy = void 0, r.encodings[0].active = !1);
                        return Xo.info(`${this} setting max height=${n},encodings=${JSON.stringify(r.encodings)}`), s.setParameters(r).then((() => {
                            if (i.maxEnabledResolution = n, this.eventEmitter.emit(jn().LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED, i), this.isP2P || !this.isSimulcastOn()) return this.setMaxBitRate()
                        }))
                    }, Zo.prototype.setVideoTransferActive = function(e) {
                        Xo.debug(`${this} video transfer active: ${e}`);
                        const t = this.videoTransferActive !== e;
                        return this.videoTransferActive = e, this._usesUnifiedPlan ? (this.tpcUtils.setVideoTransferActive(e), !1) : t
                    }, Zo.prototype.sendTones = function(e, t = 200, n = 200) {
                        if (!this._dtmfSender) {
                            if (this.peerconnection.getSenders) {
                                const e = this.peerconnection.getSenders().find((e => e.dtmf));
                                this._dtmfSender = e && e.dtmf, this._dtmfSender && Xo.info(`${this} initialized DTMFSender using getSenders`)
                            }
                            if (!this._dtmfSender) {
                                const e = Array.from(this.localTracks.values()).find((e => e.isAudioTrack()));
                                this.peerconnection.createDTMFSender && e && (this._dtmfSender = this.peerconnection.createDTMFSender(e.getTrack())), this._dtmfSender && Xo.info(`${this} initialized DTMFSender using deprecated createDTMFSender`)
                            }
                            this._dtmfSender && (this._dtmfSender.ontonechange = this._onToneChange.bind(this))
                        }
                        if (this._dtmfSender) {
                            if (this._dtmfSender.toneBuffer) return void this._dtmfTonesQueue.push({
                                tones: e,
                                duration: t,
                                interToneGap: n
                            });
                            this._dtmfSender.insertDTMF(e, t, n)
                        } else Xo.warn(`${this} sendTones - failed to select DTMFSender`)
                    }, Zo.prototype._onToneChange = function(e) {
                        if (this._dtmfSender && "" === e.tone && this._dtmfTonesQueue.length) {
                            const {
                                tones: e,
                                duration: t,
                                interToneGap: n
                            } = this._dtmfTonesQueue.shift();
                            this._dtmfSender.insertDTMF(e, t, n)
                        }
                    }, Zo.prototype.generateRecvonlySsrc = function() {
                        const e = Js.generateSsrc();
                        Xo.info(`${this} generated new recvonly SSRC=${e}`), this.sdpConsistency.setPrimarySsrc(e)
                    }, Zo.prototype.clearRecvonlySsrc = function() {
                        Xo.info(`${this} Clearing primary video SSRC!`), this.sdpConsistency.clearVideoSsrcCache()
                    }, Zo.prototype.close = function() {
                        this.trace("stop"), this.signalingLayer.off(nr, this._peerMutedChanged), this.signalingLayer.off(ir, this._peerVideoTypeChanged), this._usesUnifiedPlan && this.peerconnection.removeEventListener("track", this.onTrack);
                        for (const e of this.remoteTracks.values())
                            for (const t of e.values()) this._removeRemoteTrack(t);
                        this.remoteTracks.clear(), this._addedStreams = [], this._dtmfSender = null, this._dtmfTonesQueue = [], this.rtc._removePeerConnection(this) || Xo.error(`${this} RTC._removePeerConnection returned false`), null !== this.statsinterval && (window.clearInterval(this.statsinterval), this.statsinterval = null), Xo.info(`${this} Closing peerconnection`), this.peerconnection.close()
                    }, Zo.prototype.createAnswer = function(e) {
                        return this._createOfferOrAnswer(!1, e)
                    }, Zo.prototype.createOffer = function(e) {
                        return this._createOfferOrAnswer(!0, e)
                    }, Zo.prototype._createOfferOrAnswer = function(e, t) {
                        const n = e ? "Offer" : "Answer";
                        this.trace(`create${n}`, JSON.stringify(t, null, " "));
                        const i = (e, t, i) => {
                                try {
                                    this.trace(`create${n}OnSuccess::preTransform`, ea(e)), this._usesUnifiedPlan || (this.hasAnyTracksOfType(Cn) || this.sdpConsistency.hasPrimarySsrcCached() || this.generateRecvonlySsrc(), e = new RTCSessionDescription({
                                        type: e.type,
                                        sdp: this.sdpConsistency.makeVideoPrimarySsrcsConsistent(e.sdp)
                                    }), this.trace(`create${n}OnSuccess::postTransform (make primary audio/video ssrcs consistent)`, ea(e)));
                                    const i = this.getLocalVideoTrack();
                                    this.isSimulcastOn() && Qt.usesSdpMungingForSimulcast() && ((null == i ? void 0 : i.getVideoType()) === $n.CAMERA || this._usesUnifiedPlan || !this._isSharingLowFpsScreen()) && (e = this.simulcast.mungeLocalDescription(e), this.trace(`create${n}OnSuccess::postTransform (simulcast)`, ea(e))), !this.options.disableRtx && Qt.usesSdpMungingForSimulcast() && (e = new RTCSessionDescription({
                                        type: e.type,
                                        sdp: this.rtxModifier.modifyRtxSsrcs(e.sdp)
                                    }), this.trace(`create${n}OnSuccess::postTransform (rtx modifier)`, ea(e)));
                                    const s = this._extractSSRCMap(e);
                                    this._processLocalSSRCsMap(s), t(e)
                                } catch (t) {
                                    this.trace(`create${n}OnError`, t), this.trace(`create${n}OnError`, ea(e)), Xo.error(`${this} create${n}OnError`, t, ea(e)), i(t)
                                }
                            },
                            s = (t, i) => {
                                this.trace(`create${n}OnFailure`, t);
                                const s = e ? jn().CREATE_OFFER_FAILED : jn().CREATE_ANSWER_FAILED;
                                this.eventEmitter.emit(s, t, this), i(t)
                            };
                        if (this._usesTransceiverCodecPreferences) {
                            const e = this.peerconnection.getTransceivers().find((e => {
                                var t, n;
                                return e.receiver && (null === (t = e.receiver) || void 0 === t || null === (n = t.track) || void 0 === n ? void 0 : n.kind) === Cn
                            }));
                            if (e) {
                                var r, o, a;
                                let t = null === (r = RTCRtpReceiver.getCapabilities(Cn)) || void 0 === r ? void 0 : r.codecs;
                                const n = null === (o = this.codecPreference) || void 0 === o ? void 0 : o.mimeType,
                                    i = null === (a = this.codecPreference) || void 0 === a ? void 0 : a.enable;
                                t && n && i ? t.sort((e => e.mimeType.toLowerCase() === `${Cn}/${n}` ? -1 : 1)) : t && n && (t = t.filter((e => e.mimeType.toLowerCase() !== `${Cn}/${n}`)));
                                try {
                                    e.setCodecPreferences(t)
                                } catch (e) {
                                    Xo.warn(`${this} Setting codec[preference=${n},enable=${i}] failed`, e)
                                }
                            }
                        }
                        return new Promise(((n, r) => {
                            let o;
                            o = e ? this.peerconnection.createOffer(t) : this.peerconnection.createAnswer(t), o.then((e => i(e, n, r)), (e => s(e, r)))
                        }))
                    }, Zo.prototype._extractPrimarySSRC = function(e) {
                        return e && e.groups && e.groups.length ? e.groups[0].ssrcs[0] : e && e.ssrcs && e.ssrcs.length ? e.ssrcs[0] : null
                    }, Zo.prototype._processLocalSSRCsMap = function(e) {
                        for (const t of this.localTracks.values()) {
                            const n = this._usesUnifiedPlan ? t.getType() : t.storedMSID;
                            if (e.has(n)) {
                                const i = e.get(n);
                                if (!i) return void Xo.error(`${this} No SSRC found for stream=${n}`);
                                const s = this.localSSRCs.get(t.rtcId),
                                    r = this._extractPrimarySSRC(i),
                                    o = this._extractPrimarySSRC(s);
                                r !== o && (o && Xo.error(`${this} Overwriting SSRC for track=${t}] with ssrc=${i}`), this.localSSRCs.set(t.rtcId, i), this.eventEmitter.emit(jn().LOCAL_TRACK_SSRC_UPDATED, t, r))
                            } else t.isVideoTrack() || t.isMuted() || Xo.warn(`${this} No SSRCs found in the local SDP for track=${t}, stream=${n}`)
                        }
                    }, Zo.prototype.addIceCandidate = function(e) {
                        return this.trace("addIceCandidate", JSON.stringify({
                            candidate: e.candidate,
                            sdpMid: e.sdpMid,
                            sdpMLineIndex: e.sdpMLineIndex,
                            usernameFragment: e.usernameFragment
                        }, null, " ")), this.peerconnection.addIceCandidate(e)
                    }, Zo.prototype.getActiveSimulcastStreams = function() {
                        let e = 1;
                        var t;
                        return this.isSimulcastOn() && this.encodingsEnabledState ? e = null === (t = this.encodingsEnabledState.filter((e => Boolean(e)))) || void 0 === t ? void 0 : t.length : this.isSimulcastOn() && (e = Wo.length), e
                    }, Zo.prototype.getStats = function() {
                        return this.peerconnection.getStats()
                    }, Zo.prototype.generateNewStreamSSRCInfo = function(e) {
                        const t = e.rtcId;
                        let n = this._getSSRC(t);
                        if (n && Xo.error(`${this} Overwriting local SSRCs for track id=${t}`), !this.isSimulcastOn() || e.getVideoType() !== $n.CAMERA && this._isSharingLowFpsScreen()) n = {
                            ssrcs: [Js.generateSsrc()],
                            groups: []
                        };
                        else {
                            n = {
                                ssrcs: [],
                                groups: []
                            };
                            for (let e = 0; e < Wo.length; e++) n.ssrcs.push(Js.generateSsrc());
                            n.groups.push({
                                ssrcs: n.ssrcs.slice(),
                                semantics: "SIM"
                            })
                        }
                        if (!this.options.disableRtx) {
                            const e = n.ssrcs.length;
                            for (let t = 0; t < e; ++t) {
                                const e = n.ssrcs[t],
                                    i = Js.generateSsrc();
                                n.ssrcs.push(i), n.groups.push({
                                    ssrcs: [e, i],
                                    semantics: "FID"
                                })
                            }
                        }
                        return n.msid = e.storedMSID, this.localSSRCs.set(t, n), n
                    }, Zo.prototype.usesUnifiedPlan = function() {
                        return this._usesUnifiedPlan
                    }, Zo.prototype.toString = function() {
                        return `TPC[id=${this.id},type=${this.isP2P?"P2P":"JVB"}]`
                    };
                    const na = (0, f.getLogger)("modules/RTC/RTC.js");
                    let ia = 0,
                        sa = 0;

                    function ra(e = []) {
                        return e.map((e => {
                            const {
                                sourceId: t,
                                sourceType: n,
                                stream: i,
                                track: s,
                                videoType: r,
                                effects: o
                            } = e, {
                                deviceId: a,
                                facingMode: c
                            } = s.getSettings();
                            return sa = fn(sa), new vo({
                                deviceId: a,
                                facingMode: c,
                                mediaType: s.kind,
                                rtcId: sa,
                                sourceId: t,
                                sourceType: n,
                                stream: i,
                                track: s,
                                videoType: r || null,
                                effects: o
                            })
                        }))
                    }
                    class oa extends Ti {
                        constructor(e, t = {}) {
                            super(), this.conference = e, this.peerConnections = new Map, this.localTracks = [], this.options = t, this._channel = null, this._lastN = void 0, this._lastNEndpoints = null, this._maxFrameHeight = void 0, this._selectedEndpoints = null, this._lastNChangeListener = this._onLastNChanged.bind(this), this._onDeviceListChanged = this._onDeviceListChanged.bind(this), this._updateAudioOutputForAudioTracks = this._updateAudioOutputForAudioTracks.bind(this), this._videoType = xr().NONE, po.isDeviceChangeAvailable("output") && (po.addListener(jn().AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), po.addListener(jn().DEVICE_LIST_CHANGED, this._onDeviceListChanged))
                        }
                        destroy() {
                            po.removeListener(jn().AUDIO_OUTPUT_DEVICE_CHANGED, this._updateAudioOutputForAudioTracks), po.removeListener(jn().DEVICE_LIST_CHANGED, this._onDeviceListChanged), this._channelOpenListener && this.removeListener(jn().DATA_CHANNEL_OPEN, this._channelOpenListener)
                        }
                        static createLocalTracks(e) {
                            return ra(e)
                        }
                        static obtainAudioAndVideoPermissions(e) {
                            return po.obtainAudioAndVideoPermissions(e).then((e => ra(e)))
                        }
                        initializeBridgeChannel(e, t) {
                            this._channel = new Br(e, t, this.eventEmitter), this._channelOpenListener = () => {
                                const e = (e, t, n) => {
                                    sn().callErrorHandler(e), na.error(`Cannot send ${t}(${JSON.stringify(n)}) endpoint message`, e)
                                };
                                if (this._receiverVideoConstraints) try {
                                    this._channel.sendNewReceiverVideoConstraintsMessage(this._receiverVideoConstraints)
                                } catch (t) {
                                    e(t, "ReceiverVideoConstraints", this._receiverVideoConstraints)
                                }
                                if (this._selectedEndpoints) try {
                                    this._channel.sendSelectedEndpointsMessage(this._selectedEndpoints)
                                } catch (t) {
                                    e(t, "SelectedEndpointsChangedEvent", this._selectedEndpoints)
                                }
                                if (void 0 !== this._maxFrameHeight) try {
                                    this._channel.sendReceiverVideoConstraintMessage(this._maxFrameHeight)
                                } catch (t) {
                                    e(t, "ReceiverVideoConstraint", this._maxFrameHeight)
                                }
                                if (void 0 !== this._lastN && -1 !== this._lastN) try {
                                    this._channel.sendSetLastNMessage(this._lastN)
                                } catch (t) {
                                    e(t, "LastNChangedEvent", this._lastN)
                                }
                                try {
                                    this._channel.sendVideoTypeMessage(this._videoType)
                                } catch (t) {
                                    e(t, "VideoTypeMessage", this._videoType)
                                }
                                this.removeListener(jn().DATA_CHANNEL_OPEN, this._channelOpenListener), this._channelOpenListener = null
                            }, this.addListener(jn().DATA_CHANNEL_OPEN, this._channelOpenListener), this.addListener(jn().LASTN_ENDPOINT_CHANGED, this._lastNChangeListener)
                        }
                        _onDeviceListChanged() {
                            this._updateAudioOutputForAudioTracks(po.getAudioOutputDevice())
                        }
                        _onLastNChanged(e = []) {
                            const t = this._lastNEndpoints || [];
                            let n = [],
                                i = [];
                            this._lastNEndpoints = e, n = t.filter((e => !this.isInLastN(e))), i = e.filter((e => -1 === t.indexOf(e))), this.conference.eventEmitter.emit(se, n, i)
                        }
                        onCallEnded() {
                            this._channel && (this._channel && "websocket" === this._channel.mode && this._channel.close(), this._channel = null)
                        }
                        setDesktopSharingFrameRate(e) {
                            po.setDesktopSharingFrameRate(e)
                        }
                        setNewReceiverVideoConstraints(e) {
                            this._receiverVideoConstraints = e, this._channel && this._channel.isOpen() && this._channel.sendNewReceiverVideoConstraintsMessage(e)
                        }
                        setReceiverVideoConstraint(e) {
                            this._maxFrameHeight = e, this._channel && this._channel.isOpen() && this._channel.sendReceiverVideoConstraintMessage(e)
                        }
                        setVideoType(e) {
                            this._videoType !== e && (this._videoType = e, this._channel && this._channel.isOpen() && this._channel.sendVideoTypeMessage(e))
                        }
                        selectEndpoints(e) {
                            this._selectedEndpoints = e, this._channel && this._channel.isOpen() && this._channel.sendSelectedEndpointsMessage(e)
                        }
                        static addListener(e, t) {
                            po.addListener(e, t)
                        }
                        static removeListener(e, t) {
                            po.removeListener(e, t)
                        }
                        static init(e = {}) {
                            return this.options = e, po.init(this.options)
                        }
                        createPeerConnection(e, t, n, i) {
                            const s = JSON.parse(JSON.stringify(po.pcConstraints));
                            void 0 !== i.abtestSuspendVideo && (po.setSuspendVideo(s, i.abtestSuspendVideo), On.analytics.addPermanentProperties({
                                abtestSuspendVideo: i.abtestSuspendVideo
                            })), i.enableInsertableStreams && (na.debug("E2EE - setting insertable streams constraints"), t.encodedInsertableStreams = !0), (Qt.isReactNative() || Qt.isChromiumBased() && !i.usesUnifiedPlan) && (na.debug("WebRTC application is running in plan-b mode"), t.sdpSemantics = "plan-b"), i.forceTurnRelay && (t.iceTransportPolicy = "relay"), t.bundlePolicy = "max-bundle", ia = fn(ia);
                            const r = new Zo(this, ia, e, t, s, n, i);
                            return this.peerConnections.set(r.id, r), r
                        }
                        _removePeerConnection(e) {
                            const t = e.id;
                            return !!this.peerConnections.has(t) && (this.peerConnections.delete(t), !0)
                        }
                        addLocalTrack(e) {
                            if (!e) throw new Error("track must not be null nor undefined");
                            this.localTracks.push(e), e.conference = this.conference
                        }
                        getLocalVideoTrack() {
                            const e = this.getLocalTracks(Cn);
                            return e.length ? e[0] : void 0
                        }
                        getLocalAudioTrack() {
                            const e = this.getLocalTracks(En);
                            return e.length ? e[0] : void 0
                        }
                        getLocalEndpointId() {
                            return this.conference.myUserId()
                        }
                        getLocalTracks(e) {
                            let t = this.localTracks.slice();
                            return void 0 !== e && (t = t.filter((t => t.getType() === e))), t
                        }
                        getRemoteTracks(e) {
                            let t = [];
                            for (const n of this.peerConnections.values()) {
                                const i = n.getRemoteTracks(void 0, e);
                                i && (t = t.concat(i))
                            }
                            return t
                        }
                        setAudioMute(e) {
                            const t = [];
                            return this.getLocalTracks(En).forEach((n => {
                                t.push(e ? n.mute() : n.unmute())
                            })), Promise.all(t)
                        }
                        setVideoMute(e) {
                            const t = [];
                            return this.getLocalTracks(Cn).concat(this.getLocalTracks(bn)).forEach((n => {
                                t.push(e ? n.mute() : n.unmute())
                            })), Promise.all(t)
                        }
                        removeLocalTrack(e) {
                            const t = this.localTracks.indexOf(e); - 1 !== t && this.localTracks.splice(t, 1)
                        }
                        static attachMediaStream(e, t) {
                            return po.attachMediaStream(e, t)
                        }
                        static getStreamID(e) {
                            return po.getStreamID(e)
                        }
                        static getTrackID(e) {
                            return po.getTrackID(e)
                        }
                        static isDeviceListAvailable() {
                            return po.isDeviceListAvailable()
                        }
                        static isDeviceChangeAvailable(e) {
                            return po.isDeviceChangeAvailable(e)
                        }
                        static isWebRtcSupported() {
                            return Qt.isSupported()
                        }
                        static getAudioOutputDevice() {
                            return po.getAudioOutputDevice()
                        }
                        static getCurrentlyAvailableMediaDevices() {
                            return po.getCurrentlyAvailableMediaDevices()
                        }
                        static arePermissionsGrantedForAvailableDevices() {
                            return po.arePermissionsGrantedForAvailableDevices()
                        }
                        static getEventDataForActiveDevice(e) {
                            return po.getEventDataForActiveDevice(e)
                        }
                        static setAudioOutputDevice(e) {
                            return po.setAudioOutputDevice(e)
                        }
                        static isUserStream(e) {
                            return oa.isUserStreamById(po.getStreamID(e))
                        }
                        static isUserStreamById(e) {
                            return e && "mixedmslabel" !== e && "default" !== e
                        }
                        static enumerateDevices(e) {
                            po.enumerateDevices(e)
                        }
                        static stopMediaStream(e) {
                            po.stopMediaStream(e)
                        }
                        static isDesktopSharingEnabled() {
                            return po.isDesktopSharingEnabled()
                        }
                        closeBridgeChannel() {
                            this._channel && (this._channel.close(), this._channel = null, this.removeListener(jn().LASTN_ENDPOINT_CHANGED, this._lastNChangeListener))
                        }
                        setAudioLevel(e, t, n, i) {
                            const s = e.getTrackBySSRC(t);
                            s && (s.isAudioTrack() ? (s.isLocal() !== i && na.error(`${s} was expected to ${i?"be":"not be"} local`), s.setAudioLevel(n, e)) : na.warn(`Received audio level for non-audio track: ${t}`))
                        }
                        sendChannelMessage(e, t) {
                            if (!this._channel) throw new Error("Channel support is disabled!");
                            this._channel.sendMessage(e, t)
                        }
                        sendEndpointStatsMessage(e) {
                            this._channel && this._channel.isOpen() && this._channel.sendEndpointStatsMessage(e)
                        }
                        setLastN(e) {
                            this._lastN !== e && (this._lastN = e, this._channel && this._channel.isOpen() && this._channel.sendSetLastNMessage(e), this.eventEmitter.emit(jn().LASTN_VALUE_CHANGED, e))
                        }
                        isInLastN(e) {
                            return !this._lastNEndpoints || this._lastNEndpoints.indexOf(e) > -1
                        }
                        _updateAudioOutputForAudioTracks(e) {
                            const t = this.getRemoteTracks(En);
                            for (const n of t) n.setAudioOutput(e)
                        }
                    }
                    const aa = "cq.local_stats_updated",
                        ca = "cq.remote_stats_updated",
                        da = n(1507),
                        la = n(3714),
                        ha = n(3786),
                        ua = (0, f.getLogger)("modules/connectivity/ConnectionQuality.js"),
                        pa = [{
                            width: 1920,
                            height: 1080,
                            layers: 3,
                            target: "high",
                            targetRN: 4e6
                        }, {
                            width: 1280,
                            height: 720,
                            layers: 3,
                            target: "high",
                            targetRN: 25e5
                        }, {
                            width: 960,
                            height: 540,
                            layers: 3,
                            target: "standard",
                            targetRN: 9e5
                        }, {
                            width: 640,
                            height: 360,
                            layers: 2,
                            target: "standard",
                            targetRN: 5e5
                        }, {
                            width: 480,
                            height: 270,
                            layers: 2,
                            target: "low",
                            targetRN: 35e4
                        }, {
                            width: 320,
                            height: 180,
                            layers: 1,
                            target: "low",
                            targetRN: 15e4
                        }];
                    let ma = 800;
                    class fa {
                        constructor(e, t, n) {
                            var i;
                            this.eventEmitter = t, this._conference = e, this._localStats = {
                                connectionQuality: 100,
                                jvbRTT: void 0
                            }, this._lastConnectionQualityUpdate = -1, this._options = n, this._remoteStats = {}, this._timeIceConnected = -1, this._timeVideoUnmuted = -1, (null === (i = this._options.config) || void 0 === i ? void 0 : i.startBitrate) > 0 && (ma = this._options.config.startBitrate), e.on(q, (() => {
                                this._updateLocalConnectionQuality(0), this.eventEmitter.emit(aa, this._localStats), this._broadcastLocalStats()
                            })), e.room.addListener(ha.ICE_CONNECTION_STATE_CHANGED, ((e, t) => {
                                e.isP2P || "connected" !== t || (this._timeIceConnected = window.performance.now())
                            })), e.on(Z, ((e, t) => {
                                "stats" === t.type && this._updateRemoteStats(e.getId(), t.values)
                            })), e.on(ee, ((e, t) => {
                                this._updateRemoteStats(e.getId(), t)
                            })), e.statistics.addConnectionStatsListener(this._updateLocalStats.bind(this)), e.on(De, (e => {
                                e.isVideoTrack() && (e.isMuted() ? this._timeVideoUnmuted = -1 : this._maybeUpdateUnmuteTime())
                            })), e.on(Ie, (e => {
                                e.isVideoTrack() && !e.isMuted() && this._maybeUpdateUnmuteTime()
                            })), e.rtc.on(Fn.LOCAL_TRACK_MAX_ENABLED_RESOLUTION_CHANGED, (e => {
                                this._localStats.maxEnabledResolution = e.maxEnabledResolution
                            })), e.on(oe, (e => {
                                this._localStats.serverRegion = e
                            })), e.on(Se, (e => {
                                this._localStats.bridgeCount = Number((e || {})["bridge-count"])
                            }))
                        }
                        _maybeUpdateUnmuteTime() {
                            this._timeVideoUnmuted < 0 && (this._timeVideoUnmuted = window.performance.now())
                        }
                        _calculateConnectionQuality(e, t, n) {
                            const i = da[n];
                            let s, r = 100;
                            if (this._localStats.packetLoss && (s = this._localStats.packetLoss.upload, t && (s *= .5)), t || !i || e === la.DESKTOP || this._timeIceConnected < 0 || this._timeVideoUnmuted < 0) void 0 === s ? (ua.error("Cannot calculate connection quality, unknown packet loss."), r = 100) : r = s <= 2 ? 100 : s <= 4 ? 70 : s <= 6 ? 50 : s <= 8 ? 30 : s <= 12 ? 10 : 0;
                            else {
                                const e = this._conference.getActivePeerConnection();
                                if (e) {
                                    var o, a;
                                    const t = e.isSimulcastOn(),
                                        n = e.getTargetVideoBitrates();
                                    n.codec = e.getConfiguredVideoCodec();
                                    const s = window.performance.now() - Math.max(this._timeVideoUnmuted, this._timeIceConnected),
                                        c = null !== (o = null === (a = this._options.config) || void 0 === a ? void 0 : a.pcStatsInterval) && void 0 !== o ? o : 1e4;
                                    let d = function(e, t, n, i) {
                                        let s = 0,
                                            r = Math.min(t.height, t.width),
                                            o = pa.find((e => e.height <= r));
                                        if (o && e && i.codec === Os().VP8)
                                            for (r = o.height; r >= 180; r /= 2) {
                                                const e = r;
                                                if (o = pa.find((t => t.height === e)), !o) break;
                                                s += Qt.isReactNative() ? o.targetRN : i[o.target]
                                            } else o && (s = Qt.isReactNative() ? o.targetRN : i[o.target]);
                                        return Math.min(s / 1e3, function(e) {
                                            return e > 6e4 ? Number.MAX_SAFE_INTEGER : ma * Math.pow(1.08, e / 1e3)
                                        }(Math.max(0, n - 1e3)))
                                    }(t, i, s, n);
                                    d = Math.min(d, 2500), s > c && (r = 100 * this._localStats.bitrate.upload / d)
                                }
                                s && s >= 10 && (r = Math.min(r, 30))
                            }
                            if (this._lastConnectionQualityUpdate > 0) {
                                const e = 2,
                                    t = this._localStats.connectionQuality,
                                    n = (window.performance.now() - this._lastConnectionQualityUpdate) / 1e3;
                                r = Math.min(r, t + n * e)
                            }
                            return Math.min(100, r)
                        }
                        _updateLocalConnectionQuality(e) {
                            this._localStats.connectionQuality = e, this._lastConnectionQualityUpdate = window.performance.now()
                        }
                        _broadcastLocalStats() {
                            const e = {
                                bitrate: this._localStats.bitrate,
                                packetLoss: this._localStats.packetLoss,
                                connectionQuality: this._localStats.connectionQuality,
                                jvbRTT: this._localStats.jvbRTT,
                                serverRegion: this._localStats.serverRegion,
                                maxEnabledResolution: this._localStats.maxEnabledResolution,
                                avgAudioLevels: this._localStats.localAvgAudioLevels
                            };
                            try {
                                this._conference.sendEndpointStatsMessage(e)
                            } catch (e) {}
                        }
                        _updateLocalStats(e, t) {
                            if (!e.isP2P) {
                                const e = t.transport && t.transport.length && t.transport[0].rtt;
                                this._localStats.jvbRTT = e || void 0
                            }
                            if (e !== this._conference.getActivePeerConnection()) return;
                            let n;
                            const i = !this._conference.isConnectionInterrupted(),
                                s = this._conference.getLocalVideoTrack(),
                                r = s ? s.videoType : void 0,
                                o = !s || s.isMuted(),
                                a = s ? Math.min(s.resolution, s.maxEnabledResolution) : null;
                            for (n in o || this._maybeUpdateUnmuteTime(), t) t.hasOwnProperty(n) && (this._localStats[n] = t[n]);
                            i && this._updateLocalConnectionQuality(this._calculateConnectionQuality(r, o, a)), this.eventEmitter.emit(aa, this._localStats), this._broadcastLocalStats()
                        }
                        _updateRemoteStats(e, t) {
                            this._remoteStats[e] = {
                                bitrate: t.bitrate,
                                packetLoss: t.packetLoss,
                                connectionQuality: t.connectionQuality,
                                jvbRTT: t.jvbRTT,
                                serverRegion: t.serverRegion,
                                maxEnabledResolution: t.maxEnabledResolution,
                                avgAudioLevels: t.avgAudioLevels
                            }, this.eventEmitter.emit(ca, e, this._remoteStats[e])
                        }
                        getStats() {
                            return this._localStats
                        }
                    }
                    const ga = (0, f.getLogger)("modules/connectivity/IceFailedHandling.js");
                    class _a {
                        constructor(e) {
                            this._conference = e
                        }
                        _actOnIceFailed() {
                            const {
                                enableForcedReload: e,
                                enableIceRestart: t
                            } = this._conference.options.config, n = void 0 !== t && !t, i = this._conference.room.supportsRestartByTerminate(), s = i && !t;
                            if (ga.info(`ICE failed, enableForcedReload: ${e}, enableIceRestart: ${t}, supports restart by terminate: ${i}`), n || !t && !i || e) {
                                ga.info("ICE failed, but ICE restarts are disabled");
                                const t = e ? b : I;
                                return void this._conference.eventEmitter.emit(J, t)
                            }
                            const r = this._conference.jvbJingleSession,
                                o = r && r.getIceConnectionState();
                            r ? "connected" === o ? ga.info("ICE connection restored - not sending ICE failed") : (ga.info(`Sending ICE failed - the connection did not recover, ICE state: ${o}, use 'session-terminate': ${s}`), s ? this._conference.jvbJingleSession.terminate((() => {
                                ga.info("session-terminate for ice restart - done")
                            }), (e => {
                                ga.error(`session-terminate for ice restart - error: ${e.message}`)
                            }), {
                                reason: "connectivity-error",
                                reasonDescription: "ICE FAILED",
                                requestRestart: !0,
                                sendSessionTerminate: !0
                            }) : this._conference.jvbJingleSession.sendIceFailedNotification()) : ga.warn("Not sending ICE failed - no JVB connection")
                        }
                        start() {
                            this._conference.xmpp.ping(65e3).then((() => {
                                this._canceled || (this._iceFailedTimeout = window.setTimeout((() => {
                                    this._iceFailedTimeout = void 0, this._actOnIceFailed()
                                }), 2e3))
                            }), (e => {
                                ga.error("PING error/timeout - not sending ICE failed", e)
                            }))
                        }
                        cancel() {
                            this._canceled = !0, window.clearTimeout(this._iceFailedTimeout)
                        }
                    }
                    const va = "detector_state_change",
                        ya = "audio_input_state_changed",
                        Sa = "no_audio_input_detected",
                        Ea = "detection.vad_noise_device",
                        ba = "vad-report-published",
                        Ca = "detection.vad_score_published",
                        Ta = "detection.vad_talk_while_muted";
                    class Ra extends(ze()) {
                        constructor(e) {
                            super(), this._conference = e, this._timeoutTrigger = null, this._hasAudioInput = null, Qt.supportsReceiverStats() || e.statistics.addAudioLevelListener(this._audioLevel.bind(this)), e.on(Ie, this._trackAdded.bind(this))
                        }
                        _clearTriggerTimeout() {
                            clearTimeout(this._timeoutTrigger), this._timeoutTrigger = null
                        }
                        _handleAudioInputStateChange(e) {
                            const t = 0 !== e;
                            null !== this._hasAudioInput && this._hasAudioInput === t || (this._hasAudioInput = t, this.emit(ya, this._hasAudioInput))
                        }
                        _handleNoAudioInputDetection(e) {
                            this._eventFired || (0 !== e || this._timeoutTrigger ? 0 !== e && this._timeoutTrigger && this._clearTriggerTimeout() : this._timeoutTrigger = setTimeout((() => {
                                this._eventFired = !0, this.emit(Sa)
                            }), 4e3))
                        }
                        _audioLevel(e, t, n, i) {
                            if (!i || !this._audioTrack) return;
                            const s = e.localSSRCs.get(this._audioTrack.rtcId);
                            s && s.ssrcs.includes(t) && (this._handleAudioInputStateChange(n), this._handleNoAudioInputDetection(n))
                        }
                        _trackAdded(e) {
                            e.isLocalAudioTrack() && (this._audioTrack = e, this._eventFired = !1, this._clearTriggerTimeout(), Qt.supportsReceiverStats() && (e.on(Zn, (e => {
                                this._handleNoAudioInputDetection(e)
                            })), e.on(zn, (e => {
                                this._handleNoAudioInputDetection(e), this._handleAudioInputStateChange(e)
                            }))))
                        }
                    }
                    class Aa {
                        constructor(e) {
                            this.conference = e, e.addEventListener(Me, this._audioLevel.bind(this)), this.myUserID = this.conference.myUserId()
                        }
                        _audioLevel(e, t) {
                            !this.conference.isP2PActive() || t <= .6 || e === this.myUserID && this.conference.getLocalAudioTrack().isMuted() || this.conference.rtc.eventEmitter.emit(jn().DOMINANT_SPEAKER_CHANGED, e)
                        }
                    }

                    function wa(e) {
                        const t = window.AudioContext || window.webkitAudioContext;
                        if (t) return new t(e)
                    }
                    class Pa extends(ze()) {
                        constructor(e, t, n) {
                            super(), this._procNodeSampleRate = e, this._vadProcessor = t, this._localTrack = n, this._bufferResidue = new Float32Array([]), this._audioContext = wa({
                                sampleRate: t.getRequiredPCMFrequency()
                            }), this._vadSampleSize = t.getSampleLength(), this._onAudioProcess = this._onAudioProcess.bind(this), this._initializeAudioContext()
                        }
                        static create(e, t, n) {
                            return oa.obtainAudioAndVideoPermissions({
                                devices: ["audio"],
                                micDeviceId: e
                            }).then((i => {
                                if (!i[0]) throw new Error(`Failed to create jitsi local track for device id: ${e}`);
                                return new Pa(t, n, i[0])
                            }))
                        }
                        _initializeAudioContext() {
                            this._audioSource = this._audioContext.createMediaStreamSource(this._localTrack.stream), this._audioProcessingNode = this._audioContext.createScriptProcessor(this._procNodeSampleRate, 1, 1)
                        }
                        _onAudioProcess(e) {
                            const t = e.inputBuffer.getChannelData(0),
                                n = [...this._bufferResidue, ...t],
                                i = Date.now();
                            let s = 0;
                            for (; s + this._vadSampleSize < n.length; s += this._vadSampleSize) {
                                const e = n.slice(s, s + this._vadSampleSize),
                                    t = this._vadProcessor.calculateAudioFrameVAD(e.slice());
                                this.emit(Ca, {
                                    timestamp: i,
                                    score: t,
                                    pcmData: e,
                                    deviceId: this._localTrack.getDeviceId()
                                })
                            }
                            this._bufferResidue = n.slice(s, n.length)
                        }
                        _connectAudioGraph() {
                            this._audioProcessingNode.onaudioprocess = this._onAudioProcess, this._audioSource.connect(this._audioProcessingNode), this._audioProcessingNode.connect(this._audioContext.destination)
                        }
                        _disconnectAudioGraph() {
                            this._audioProcessingNode.onaudioprocess = () => {}, this._audioProcessingNode.disconnect(), this._audioSource.disconnect()
                        }
                        _cleanupResources() {
                            this._disconnectAudioGraph(), this._localTrack.stopStream()
                        }
                        getDeviceId() {
                            return this._localTrack.getDeviceId()
                        }
                        getTrackLabel() {
                            return this._localTrack.getDeviceLabel()
                        }
                        start() {
                            this._connectAudioGraph()
                        }
                        stop() {
                            this._disconnectAudioGraph(), this._bufferResidue = []
                        }
                        destroy() {
                            this._destroyed || (this._cleanupResources(), this._destroyed = !0)
                        }
                    }
                    const Ia = (0, f.getLogger)("modules/detection/VADAudioAnalyser.js");
                    class Ma extends Ke.EventEmitter {
                        constructor(e, t) {
                            super(), this._createVADProcessor = t, this._vadEmitter = null, this._isVADEmitterRunning = !1, this._detectionServices = [], this._vadInitTracker = Promise.resolve(), this._processVADScore = this._processVADScore.bind(this), e.on(Ie, this._trackAdded.bind(this)), e.on(Ne, this._trackRemoved.bind(this)), e.on(De, this._trackMuteChanged.bind(this))
                        }
                        addVADDetectionService(e) {
                            this._detectionServices.push(e), e.on(va, (() => {
                                !this._detectionServices.filter((e => !0 === e.isActive())).length && this._isVADEmitterRunning ? this._stopVADEmitter() : this._isVADEmitterRunning || this._startVADEmitter()
                            }))
                        }
                        _startVADEmitter() {
                            this._vadEmitter && (this._vadEmitter.on(Ca, this._processVADScore), this._vadEmitter.start(), this._isVADEmitterRunning = !0)
                        }
                        _stopVADEmitter() {
                            this._vadEmitter && (this._vadEmitter.removeListener(Ca, this._processVADScore), this._vadEmitter.stop()), this._isVADEmitterRunning = !1
                        }
                        _processVADScore(e) {
                            for (const t of this._detectionServices) t.processVADScore(e)
                        }
                        _changeDetectorsMuteState(e) {
                            for (const t of this._detectionServices) t.changeMuteState(e)
                        }
                        _trackAdded(e) {
                            e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then((() => this._createVADProcessor())).then((t => Pa.create(e.getDeviceId(), 4096, t))).then((t => {
                                Ia.debug("Created VAD emitter for track: ", e.getTrackLabel()), this._vadEmitter = t, this._changeDetectorsMuteState(e.isMuted())
                            })).catch((e => {
                                Ia.warn("Failed to start VADAudioAnalyser", e)
                            })))
                        }
                        _trackMuteChanged(e) {
                            e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then((() => {
                                this._changeDetectorsMuteState(e.isMuted())
                            })))
                        }
                        _trackRemoved(e) {
                            e.isLocalAudioTrack() && (this._vadInitTracker = this._vadInitTracker.then((() => {
                                Ia.debug("Removing track from VAD detection - ", e.getTrackLabel()), this._vadEmitter && (this._stopVADEmitter(), this._vadEmitter.destroy(), this._vadEmitter = null);
                                for (const e of this._detectionServices) e.reset()
                            })))
                        }
                    }
                    class Da extends Ke.EventEmitter {
                        constructor() {
                            super(), this._processing = !1, this._scoreArray = [], this._audioLvlArray = [], this._active = !1, this._calculateNoisyScore = this._calculateNoisyScore.bind(this)
                        }
                        _calculateNoisyScore() {
                            const e = gn(this._scoreArray),
                                t = gn(this._audioLvlArray);
                            e < .2 && t > .04 && (this.emit(Ea), this._setActiveState(!1)), this.reset()
                        }
                        _recordValues(e, t) {
                            this._scoreArray.push(e), this._audioLvlArray.push(t)
                        }
                        _setActiveState(e) {
                            this._active = e, this.emit(va, this._active)
                        }
                        changeMuteState(e) {
                            this._setActiveState(!e), this.reset()
                        }
                        isActive() {
                            return this._active
                        }
                        reset() {
                            this._processing = !1, this._scoreArray = [], this._audioLvlArray = [], clearTimeout(this._processTimeout)
                        }
                        processVADScore(e) {
                            if (this._active)
                                if (this._processing) {
                                    const t = _n(e.pcmData);
                                    this._recordValues(e.score, gn(t))
                                } else if (e.score < .2) {
                                const t = gn(_n(e.pcmData));
                                t > .02 && (this._processing = !0, this._recordValues(e.score, t), this._processTimeout = setTimeout(this._calculateNoisyScore, 1500))
                            }
                        }
                    }
                    class Na extends Ke.EventEmitter {
                        constructor() {
                            super(), this._processing = !1, this._scoreArray = [], this._active = !1, this._calculateVADScore = this._calculateVADScore.bind(this)
                        }
                        _calculateVADScore() {
                            gn(this._scoreArray) > .6 && (this.emit(Ta), this._setActiveState(!1)), this.reset()
                        }
                        _setActiveState(e) {
                            this._active = e, this.emit(va, this._active)
                        }
                        changeMuteState(e) {
                            this._setActiveState(e), this.reset()
                        }
                        isActive() {
                            return this._active
                        }
                        processVADScore(e) {
                            this._active && (this._processing ? this._scoreArray.push(e.score) : e.score > .9 && (this._processing = !0, this._scoreArray.push(e.score), this._processTimeout = setTimeout(this._calculateVADScore, 700)))
                        }
                        reset() {
                            this._processing = !1, this._scoreArray = [], clearTimeout(this._processTimeout)
                        }
                    }
                    const ka = "e2eping.e2e_rtt_changed",
                        Oa = (0, f.getLogger)("modules/e2eping/e2eping.js"),
                        La = "e2e-ping-request",
                        xa = "e2e-ping-response";
                    class Fa {
                        constructor(e, t) {
                            this.participant = e, this.e2eping = t, this.id = e.getId(), this.requests = {}, this.lastRequestId = 1, this.clearIntervals = this.clearIntervals.bind(this), this.sendRequest = this.sendRequest.bind(this), this.handleResponse = this.handleResponse.bind(this), this.maybeSendAnalytics = this.maybeSendAnalytics.bind(this), this.sendAnalytics = this.sendAnalytics.bind(this), t.isDataChannelOpen && this.sendRequest(), this.pingInterval = window.setInterval(this.sendRequest, t.pingIntervalMs), this.analyticsInterval = window.setTimeout(this.maybeSendAnalytics, this.e2eping.analyticsIntervalMs)
                        }
                        clearIntervals() {
                            this.pingInterval && window.clearInterval(this.pingInterval), this.analyticsInterval && window.clearInterval(this.analyticsInterval)
                        }
                        sendRequest() {
                            const e = this.lastRequestId++,
                                t = {
                                    type: La,
                                    id: e
                                };
                            this.e2eping.sendMessage(t, this.id), this.requests[e] = {
                                id: e,
                                timeSent: window.performance.now()
                            }
                        }
                        handleResponse(e) {
                            const t = this.requests[e.id];
                            t && (t.rtt = window.performance.now() - t.timeSent, this.e2eping.eventEmitter.emit(ka, this.participant, t.rtt)), this.maybeSendAnalytics()
                        }
                        maybeSendAnalytics() {
                            const e = window.performance.now();
                            let t, n, i = 1 / 0;
                            for (n in this.requests) this.requests.hasOwnProperty(n) && (t = this.requests[n], t.timeSent < e - this.e2eping.analyticsIntervalMs ? delete this.requests[n] : t.rtt && (i = Math.min(i, t.rtt)));
                            i < 1 / 0 && this.sendAnalytics(i)
                        }
                        sendAnalytics(e) {
                            On.sendAnalytics(function(e, t, n) {
                                return {
                                    attributes: {
                                        participant_id: e,
                                        region: t,
                                        rtt: n
                                    },
                                    name: "e2e_rtt",
                                    type: gt
                                }
                            }(this.id, this.participant.getProperty("region"), e))
                        }
                    }
                    class ja {
                        constructor(e, t, n) {
                            this.conference = e, this.eventEmitter = e.eventEmitter, this.sendMessage = n, this.pingIntervalMs = 1e4, this.analyticsIntervalMs = 6e4, this.participants = {}, this.isDataChannelOpen = !1, t && t.e2eping && ("number" == typeof t.e2eping.pingInterval && (this.pingIntervalMs = t.e2eping.pingInterval), "number" == typeof t.e2eping.analyticsInterval && (this.analyticsIntervalMs = t.e2eping.analyticsInterval), this.analyticsIntervalMs > 0 && this.analyticsIntervalMs < this.pingIntervalMs && (this.analyticsIntervalMs = this.pingIntervalMs)), Oa.info(`Initializing e2e ping; pingInterval=${this.pingIntervalMs}, analyticsInterval=${this.analyticsIntervalMs}.`), this.participantJoined = this.participantJoined.bind(this), e.on(Oe, this.participantJoined), this.participantLeft = this.participantLeft.bind(this), e.on(Le, this.participantLeft), this.messageReceived = this.messageReceived.bind(this), e.on(Z, this.messageReceived), this.dataChannelOpened = this.dataChannelOpened.bind(this), e.on(z, this.dataChannelOpened)
                        }
                        dataChannelOpened() {
                            this.isDataChannelOpen = !0;
                            for (const e in this.participants)
                                if (this.participants.hasOwnProperty(e)) {
                                    const t = this.participants[e];
                                    window.setTimeout(t.sendRequest, 200)
                                }
                        }
                        messageReceived(e, t) {
                            t.type === La ? this.handleRequest(e.getId(), t) : t.type === xa && this.handleResponse(e.getId(), t)
                        }
                        participantJoined(e, t) {
                            this.pingIntervalMs <= 0 || (this.participants[e] && (Oa.info(`Participant wrapper already exists for ${e}. Clearing.`), this.participants[e].clearIntervals(), delete this.participants[e]), this.participants[e] = new Fa(t, this))
                        }
                        participantLeft(e) {
                            this.pingIntervalMs <= 0 || this.participants[e] && (this.participants[e].clearIntervals(), delete this.participants[e])
                        }
                        handleRequest(e, t) {
                            if (t && t.id) {
                                const n = {
                                    type: xa,
                                    id: t.id
                                };
                                this.sendMessage(n, e)
                            } else Oa.info(`Received an invalid e2e ping request from ${e}.`)
                        }
                        handleResponse(e, t) {
                            const n = this.participants[e];
                            n && n.handleResponse(t)
                        }
                        stop() {
                            Oa.info("Stopping e2eping"), this.conference.off(Oe, this.participantJoined), this.conference.off(Le, this.participantLeft), this.conference.off(Z, this.messageReceived), this.conference.off(z, this.dataChannelOpened);
                            for (const e in this.participants) this.participants.hasOwnProperty(e) && this.participants[e].clearIntervals();
                            this.participants = {}
                        }
                    }
                    const $a = (0, f.getLogger)("modules/event/Jvb121EventGenerator.js");
                    class Ba {
                        constructor(e) {
                            this._conference = e, this._jvb121 = !0, this._conference.addEventListener(Oe, (() => this.evaluateStatus())), this._conference.addEventListener(Le, (() => this.evaluateStatus())), this._conference.addEventListener(ve, (() => this.evaluateStatus()))
                        }
                        evaluateStatus() {
                            const e = this._jvb121,
                                t = !this._conference.isP2PActive() && this._conference.getParticipantCount() <= 2;
                            e !== t && (this._jvb121 = t, $a.debug(`JVB121 status ${e} => ${t}`), this._conference.eventEmitter.emit(te, e, t))
                        }
                    }
                    const Ja = (0, f.getLogger)("modules/qualitycontrol/ReceiveVideoController.js");
                    class Ua {
                        constructor() {
                            this._defaultConstraints = {
                                maxHeight: 180
                            }, this._lastN = -1, this._maxFrameHeight = 2160, this._selectedEndpoints = [], this._receiverVideoConstraints = {
                                constraints: {},
                                defaultConstraints: this.defaultConstraints,
                                lastN: this._lastN,
                                onStageEndpoints: [],
                                selectedEndpoints: this._selectedEndpoints
                            }
                        }
                        get constraints() {
                            return this._receiverVideoConstraints.lastN = this._lastN, this._selectedEndpoints.length ? (this._receiverVideoConstraints.constraints = {}, this._selectedEndpoints.length > 1 ? (this._receiverVideoConstraints.defaultConstraints = {
                                maxHeight: this._maxFrameHeight
                            }, this._receiverVideoConstraints.onStageEndpoints = [], this._receiverVideoConstraints.selectedEndpoints = []) : (this._receiverVideoConstraints.constraints[this._selectedEndpoints[0]] = {
                                maxHeight: this._maxFrameHeight
                            }, this._receiverVideoConstraints.defaultConstraints = this._defaultConstraints, this._receiverVideoConstraints.onStageEndpoints = this._selectedEndpoints, this._receiverVideoConstraints.selectedEndpoints = []), this._receiverVideoConstraints) : this._receiverVideoConstraints
                        }
                        updateLastN(e) {
                            const t = this._lastN !== e;
                            return t && (this._lastN = e, Ja.debug(`Updating ReceiverVideoConstraints lastN(${e})`)), t
                        }
                        updateReceiveResolution(e) {
                            const t = this._maxFrameHeight !== e;
                            return t && (this._maxFrameHeight = e, Ja.debug(`Updating receive maxFrameHeight: ${e}`)), t
                        }
                        updateReceiverVideoConstraints(e) {
                            const t = !Qe()(this._receiverVideoConstraints, e);
                            return t && (this._receiverVideoConstraints = e, Ja.debug(`Updating ReceiverVideoConstraints ${JSON.stringify(e)}`)), t
                        }
                        updateSelectedEndpoints(e) {
                            Ja.debug(`Updating selected endpoints: ${JSON.stringify(e)}`), this._selectedEndpoints = e
                        }
                    }
                    class Va {
                        constructor(e, t) {
                            var n, i;
                            this._conference = e, this._rtc = t;
                            const {
                                config: s
                            } = e.options;
                            this._lastN = null !== (n = null == s ? void 0 : s.startLastN) && void 0 !== n ? n : (null == s ? void 0 : s.channelLastN) || -1, this._maxFrameHeight = 2160, null === (i = null == s ? void 0 : s.useNewBandwidthAllocationStrategy) || void 0 === i || i ? (this._receiverVideoConstraints = new Ua, this._receiverVideoConstraints.updateLastN(this._lastN) && this._rtc.setNewReceiverVideoConstraints(this._receiverVideoConstraints.constraints)) : this._rtc.setLastN(this._lastN), this._selectedEndpoints = [], this._conference.on(ae, (e => this._onMediaSessionStarted(e)))
                        }
                        _onMediaSessionStarted(e) {
                            e.isP2P || !this._receiverVideoConstraints ? e.setReceiverVideoConstraint(this._maxFrameHeight) : (this._receiverVideoConstraints.updateReceiveResolution(this._maxFrameHeight), this._rtc.setNewReceiverVideoConstraints(this._receiverVideoConstraints.constraints))
                        }
                        getLastN() {
                            return this._lastN
                        }
                        selectEndpoints(e) {
                            if (this._selectedEndpoints = e, this._receiverVideoConstraints) {
                                const t = e.filter((e => e !== this._conference.myUserId())),
                                    n = JSON.parse(JSON.stringify(this._receiverVideoConstraints.constraints));
                                t.length && this._receiverVideoConstraints.updateSelectedEndpoints(t);
                                const i = this._receiverVideoConstraints.constraints;
                                Qe()(i, n) || this._rtc.setNewReceiverVideoConstraints(i)
                            } else this._rtc.selectEndpoints(e)
                        }
                        setLastN(e) {
                            if (this._lastN !== e) {
                                if (this._lastN = e, this._receiverVideoConstraints) return void(this._receiverVideoConstraints.updateLastN(e) && this._rtc.setNewReceiverVideoConstraints(this._receiverVideoConstraints.constraints));
                                this._rtc.setLastN(e)
                            }
                        }
                        setPreferredReceiveMaxFrameHeight(e) {
                            this._maxFrameHeight = e;
                            for (const t of this._conference._getMediaSessions()) t.isP2P || !this._receiverVideoConstraints ? e && t.setReceiverVideoConstraint(e) : this._receiverVideoConstraints.updateReceiveResolution(e) && this._rtc.setNewReceiverVideoConstraints(this._receiverVideoConstraints.constraints)
                        }
                        setReceiverConstraints(e) {
                            if (this._receiverVideoConstraints || (this._receiverVideoConstraints = new Ua), this._receiverVideoConstraints.updateReceiverVideoConstraints(e)) {
                                var t, n;
                                this._lastN = null !== (t = e.lastN) && void 0 !== t ? t : this._lastN, this._selectedEndpoints = null !== (n = e.selectedEndpoints) && void 0 !== n ? n : this._selectedEndpoints, this._rtc.setNewReceiverVideoConstraints(e);
                                const r = this._conference._getMediaSessions().find((e => e.isP2P));
                                if (r) {
                                    var i;
                                    let t = null === (i = Object.values(e.constraints)[0]) || void 0 === i ? void 0 : i.maxHeight;
                                    var s;
                                    t || (t = null === (s = e.defaultConstraints) || void 0 === s ? void 0 : s.maxHeight), t && r.setReceiverVideoConstraint(t)
                                }
                            }
                        }
                    }
                    class Ha {
                        constructor(e, t) {
                            var n, i, s;
                            this.conference = e, this.layerSuspensionEnabled = null === (n = null === (i = e.options) || void 0 === i || null === (s = i.config) || void 0 === s ? void 0 : s.enableLayerSuspension) || void 0 === n || n, this.rtc = t, this.conference.on(ae, (e => this._onMediaSessionStarted(e))), this.conference.on(ce, (() => this._propagateSendMaxFrameHeight())), this.rtc.on(jn().SENDER_VIDEO_CONSTRAINTS_CHANGED, (e => {
                                var t;
                                (null === (t = this._senderVideoConstraints) || void 0 === t ? void 0 : t.idealHeight) !== e.idealHeight && (this._senderVideoConstraints = e, this._propagateSendMaxFrameHeight())
                            }))
                        }
                        _onMediaSessionStarted(e) {
                            e.addListener(tr, (e => {
                                e === this.conference._getActiveMediaSession() && this._propagateSendMaxFrameHeight()
                            })), e.setSenderVideoDegradationPreference(), e.setSenderMaxBitrates()
                        }
                        _propagateSendMaxFrameHeight() {
                            const e = this.selectSendMaxFrameHeight(),
                                t = [];
                            if (e >= 0)
                                for (const n of this.conference._getMediaSessions()) t.push(n.setSenderVideoConstraint(e));
                            return Promise.all(t)
                        }
                        selectSendMaxFrameHeight() {
                            var e;
                            const t = this.conference._getActiveMediaSession(),
                                n = t ? t.isP2P ? t.getRemoteRecvMaxFrameHeight() : this.layerSuspensionEnabled ? null === (e = this._senderVideoConstraints) || void 0 === e ? void 0 : e.idealHeight : void 0 : void 0;
                            return this.preferredSendMaxFrameHeight >= 0 && n >= 0 ? Math.min(this.preferredSendMaxFrameHeight, n) : n >= 0 ? n : this.preferredSendMaxFrameHeight
                        }
                        setPreferredSendMaxFrameHeight(e) {
                            return this.preferredSendMaxFrameHeight = e, this._propagateSendMaxFrameHeight()
                        }
                    }
                    const Ga = {
                        getFocusRecordingUpdate(e) {
                            const t = e && e.getElementsByTagName("jibri-recording-status")[0];
                            if (t) return {
                                error: t.getAttribute("failure_reason"),
                                initiator: t.getAttribute("initiator"),
                                recordingMode: t.getAttribute("recording_mode"),
                                sessionID: t.getAttribute("session_id"),
                                status: t.getAttribute("status")
                            }
                        },
                        getHiddenDomainUpdate(e) {
                            const t = e.getElementsByTagName("live-stream-view-url")[0],
                                n = t && t.textContent,
                                i = e.getElementsByTagName("mode")[0],
                                s = i && i.textContent && i.textContent.toLowerCase(),
                                r = e.getElementsByTagName("session_id")[0];
                            return {
                                liveStreamViewURL: n,
                                mode: s,
                                sessionID: r && r.textContent
                            }
                        },
                        getSessionIdFromIq(e) {
                            const t = e && e.getElementsByTagName("jibri")[0];
                            return t && t.getAttribute("session_id")
                        },
                        getSessionId(e) {
                            const t = e.getElementsByTagName("session_id")[0];
                            return t && t.textContent
                        },
                        isFromFocus: e => e.getAttribute("from").includes("focus")
                    };
                    class qa {
                        constructor(e = {}) {
                            this._connection = e.connection, this._mode = e.mode, this._setSessionID(e.sessionID), this.setStatus(e.status)
                        }
                        getError() {
                            return this._error
                        }
                        getID() {
                            return this._sessionID
                        }
                        getInitiator() {
                            return this._initiator
                        }
                        getLiveStreamViewURL() {
                            return this._liveStreamViewURL
                        }
                        getStatus() {
                            return this._status
                        }
                        getTerminator() {
                            return this._terminator
                        }
                        getMode() {
                            return this._mode
                        }
                        setError(e) {
                            this._error = e
                        }
                        setLiveStreamViewURL(e) {
                            this._liveStreamViewURL = e
                        }
                        setStatus(e) {
                            this._status = e
                        }
                        setInitiator(e) {
                            this._initiator = e
                        }
                        setTerminator(e) {
                            this._terminator = e
                        }
                        start({
                            appData: e,
                            broadcastId: t,
                            focusMucJid: n,
                            streamId: i
                        }) {
                            return new Promise(((s, r) => {
                                this._connection.sendIQ(this._createIQ({
                                    action: "start",
                                    appData: e,
                                    focusMucJid: n,
                                    broadcastId: t,
                                    streamId: i
                                }), (e => {
                                    this.setStatus("pending"), this._setSessionID(Ga.getSessionIdFromIq(e)), s()
                                }), (e => {
                                    this._setErrorFromIq(e), r(e)
                                }))
                            }))
                        }
                        stop({
                            focusMucJid: e
                        }) {
                            return new Promise(((t, n) => {
                                this._connection.sendIQ(this._createIQ({
                                    action: "stop",
                                    focusMucJid: e
                                }), t, n)
                            }))
                        }
                        _createIQ({
                            action: e,
                            appData: t,
                            broadcastId: n,
                            focusMucJid: i,
                            streamId: s
                        }) {
                            return (0, Xe.$iq)({
                                to: i,
                                type: "set"
                            }).c("jibri", {
                                xmlns: "http://jitsi.org/protocol/jibri",
                                action: e,
                                app_data: t,
                                recording_mode: this._mode,
                                streamid: s,
                                you_tube_broadcast_id: n
                            }).up()
                        }
                        _setErrorFromIq(e) {
                            const t = e.getElementsByTagName("error")[0];
                            this.setError(t.children[0].tagName)
                        }
                        _setSessionID(e) {
                            this._sessionID = e
                        }
                    }

                    function Ka(e, t, n) {
                        return t in e ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = n, e
                    }
                    const za = (0, f.getLogger)("modules/recording/RecordingManager.js"),
                        Wa = (0, f.getLogger)("modules/statistics/AudioOutputProblemDetector.js");
                    class Qa {
                        constructor(e) {
                            this._conference = e, this._localAudioLevelCache = {}, this._reportedParticipants = [], this._audioProblemCandidates = {}, this._numberOfRemoteAudioLevelsReceived = {}, this._onLocalAudioLevelsReport = this._onLocalAudioLevelsReport.bind(this), this._onRemoteAudioLevelReceived = this._onRemoteAudioLevelReceived.bind(this), this._clearUserData = this._clearUserData.bind(this), this._conference.on(ca, this._onRemoteAudioLevelReceived), this._conference.statistics.addConnectionStatsListener(this._onLocalAudioLevelsReport), this._conference.on(Le, this._clearUserData)
                        }
                        _onRemoteAudioLevelReceived(e, {
                            avgAudioLevels: t
                        }) {
                            const n = this._numberOfRemoteAudioLevelsReceived[e] + 1 || 0;
                            if (this._numberOfRemoteAudioLevelsReceived[e] = n, -1 !== this._reportedParticipants.indexOf(e) || e in this._audioProblemCandidates || t <= 0 || n < 3) return;
                            const i = this._conference.getParticipantById(e);
                            if (i && i.getTracksByMediaType(En).length > 0 && i.isAudioMuted()) return;
                            const s = this._localAudioLevelCache[e];
                            Array.isArray(s) && !s.every((e => 0 === e)) || (this._audioProblemCandidates[e] = {
                                remoteAudioLevels: t,
                                localAudioLevels: []
                            })
                        }
                        _onLocalAudioLevelsReport(e, {
                            avgAudioLevels: t
                        }) {
                            e === this._conference.getActivePeerConnection() && (Object.keys(t).forEach((e => {
                                if (-1 !== this._reportedParticipants.indexOf(e)) return;
                                const n = this._localAudioLevelCache[e];
                                Array.isArray(n) ? n.length >= 2 && n.shift() : this._localAudioLevelCache[e] = [], this._localAudioLevelCache[e].push(t[e])
                            })), Object.keys(this._audioProblemCandidates).forEach((e => {
                                const {
                                    localAudioLevels: n,
                                    remoteAudioLevels: i
                                } = this._audioProblemCandidates[e];
                                if (n.push(t[e]), 2 === n.length) {
                                    if (n.every((e => void 0 === e || 0 === e))) {
                                        const t = JSON.stringify(n);
                                        On.sendAnalytics(function(e, t, n) {
                                            return {
                                                type: gt,
                                                action: "audio.output.problem",
                                                attributes: {
                                                    userID: e,
                                                    localAudioLevels: t,
                                                    remoteAudioLevels: n
                                                }
                                            }
                                        }(e, t, i)), Wa.warn(`A potential problem is detected with the audio output for participant ${e}, local audio levels: ${t}, remote audio levels: ${i}`), this._reportedParticipants.push(e), this._clearUserData(e)
                                    }
                                    delete this._audioProblemCandidates[e]
                                }
                            })))
                        }
                        _clearUserData(e) {
                            delete this._localAudioLevelCache[e]
                        }
                        dispose() {
                            this._conference.off(ca, this._onRemoteAudioLevelReceived), this._conference.off(Le, this._clearUserData), this._conference.statistics.removeConnectionStatsListener(this._onLocalAudioLevelsReport), this._localAudioLevelCache = void 0, this._audioProblemCandidates = void 0, this._reportedParticipants = void 0, this._numberOfRemoteAudioLevelsReceived = void 0, this._conference = void 0
                        }
                    }
                    const Xa = (0, f.getLogger)("modules/statistics/AvgRTPStatsReporter.js");
                    class Ya {
                        constructor(e) {
                            this.name = e, this.count = 0, this.sum = 0, this.samples = []
                        }
                        addNext(e) {
                            "number" != typeof e ? Xa.error(`${this.name} - invalid value for idx: ${this.count}`, e) : isNaN(e) || (this.sum += e, this.samples.push(e), this.count += 1)
                        }
                        calculate() {
                            return this.sum / this.count
                        }
                        appendReport(e) {
                            e[`${this.name}_avg`] = this.calculate(), e[`${this.name}_samples`] = JSON.stringify(this.samples)
                        }
                        reset() {
                            this.samples = [], this.sum = 0, this.count = 0
                        }
                    }
                    class Za {
                        constructor(e, t, n) {
                            this.isP2P = t, this._n = n, this._sampleIdx = 0, this._avgRTT = new Ya("rtt"), this._avgRemoteRTTMap = new Map, this._avgRtpStatsReporter = e, this._avgEnd2EndRTT = void 0, this._onConnectionStats = (e, t) => {
                                this.isP2P === e.isP2P && this._calculateAvgStats(t)
                            };
                            const i = e._conference;
                            i.statistics.addConnectionStatsListener(this._onConnectionStats), this.isP2P || (this._onUserLeft = e => this._avgRemoteRTTMap.delete(e), i.on(Le, this._onUserLeft), this._onRemoteStatsUpdated = (e, t) => this._processRemoteStats(e, t), i.on(ca, this._onRemoteStatsUpdated))
                        }
                        _calculateAvgStats(e) {
                            if (e) {
                                if (Qt.supportsRTTStatistics() && e.transport && e.transport.length && this._avgRTT.addNext(e.transport[0].rtt), this._sampleIdx += 1, this._sampleIdx >= this._n) {
                                    if (Qt.supportsRTTStatistics()) {
                                        const t = this._avgRtpStatsReporter._conference,
                                            n = {
                                                p2p: this.isP2P,
                                                conference_size: t.getParticipantCount()
                                            };
                                        if (e.transport && e.transport.length && Object.assign(n, {
                                                local_candidate_type: e.transport[0].localCandidateType,
                                                remote_candidate_type: e.transport[0].remoteCandidateType,
                                                transport_type: e.transport[0].type
                                            }), this._avgRTT.appendReport(n), this.isP2P) {
                                            const e = this._avgRtpStatsReporter.jvbStatsMonitor._avgEnd2EndRTT;
                                            isNaN(e) || (n.rtt_diff = this._avgRTT.calculate() - e)
                                        } else {
                                            const e = this._calculateAvgRemoteRTT(),
                                                t = this._avgRTT.calculate();
                                            this._avgEnd2EndRTT = t + e, isNaN(t) || isNaN(e) || (n.end2end_rtt_avg = this._avgEnd2EndRTT)
                                        }
                                        On.sendAnalytics(wt(n))
                                    }
                                    this._resetAvgStats()
                                }
                            } else Xa.error("No stats")
                        }
                        _calculateAvgRemoteRTT() {
                            let e = 0,
                                t = 0;
                            for (const n of this._avgRemoteRTTMap.values()) {
                                const i = n.calculate();
                                isNaN(i) || (t += i, e += 1, n.reset())
                            }
                            return t / e
                        }
                        _processRemoteStats(e, t) {
                            const n = "number" == typeof t.jvbRTT;
                            let i = this._avgRemoteRTTMap.get(e);
                            !i && n && (i = new Ya(`${e}_stat_rtt`), this._avgRemoteRTTMap.set(e, i)), n ? i.addNext(t.jvbRTT) : i && this._avgRemoteRTTMap.delete(e)
                        }
                        _resetAvgStats() {
                            this._avgRTT.reset(), this._avgRemoteRTTMap && this._avgRemoteRTTMap.clear(), this._sampleIdx = 0
                        }
                        dispose() {
                            const e = this._avgRtpStatsReporter._conference;
                            e.statistics.removeConnectionStatsListener(this._onConnectionStats), this.isP2P || (e.off(ca, this._onRemoteStatsUpdated), e.off(Le, this._onUserLeft))
                        }
                    }
                    class ec {
                        constructor(e, t) {
                            this._n = t, t > 0 ? (Xa.info(`Avg RTP stats will be calculated every ${t} samples`), this._sampleIdx = 0, this._conference = e, this._avgAudioBitrateUp = new Ya("bitrate_audio_upload"), this._avgAudioBitrateDown = new Ya("bitrate_audio_download"), this._avgVideoBitrateUp = new Ya("bitrate_video_upload"), this._avgVideoBitrateDown = new Ya("bitrate_video_download"), this._avgBandwidthUp = new Ya("bandwidth_upload"), this._avgBandwidthDown = new Ya("bandwidth_download"), this._avgPacketLossTotal = new Ya("packet_loss_total"), this._avgPacketLossUp = new Ya("packet_loss_upload"), this._avgPacketLossDown = new Ya("packet_loss_download"), this._avgRemoteFPS = new Ya("framerate_remote"), this._avgRemoteScreenFPS = new Ya("framerate_screen_remote"), this._avgLocalFPS = new Ya("framerate_local"), this._avgLocalScreenFPS = new Ya("framerate_screen_local"), this._avgRemoteCameraPixels = new Ya("pixels_remote"), this._avgRemoteScreenPixels = new Ya("pixels_screen_remote"), this._avgLocalCameraPixels = new Ya("pixels_local"), this._avgLocalScreenPixels = new Ya("pixels_screen_local"), this._avgCQ = new Ya("connection_quality"), this._cachedTransportStats = void 0, this._onLocalStatsUpdated = e => {
                                this._calculateAvgStats(e), this._maybeSendTransportAnalyticsEvent(e)
                            }, e.on(aa, this._onLocalStatsUpdated), this._onP2PStatusChanged = () => {
                                Xa.debug("Resetting average stats calculation"), this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats(), this.p2pStatsMonitor._resetAvgStats()
                            }, e.on(ve, this._onP2PStatusChanged), this._onJvb121StatusChanged = (e, t) => {
                                !0 === t && (Xa.info("Resetting JVB avg RTP stats"), this._resetAvgJvbStats())
                            }, e.on(te, this._onJvb121StatusChanged), this.jvbStatsMonitor = new Za(this, !1, t), this.p2pStatsMonitor = new Za(this, !0, t)) : Xa.info("Avg RTP stats reports are disabled.")
                        }
                        _calculateAvgStats(e) {
                            if (!e) return void Xa.error("No stats");
                            const t = this._conference.isP2PActive(),
                                n = this._conference.getParticipantCount();
                            if (!t && n < 2) return;
                            const i = e.bitrate,
                                s = e.bandwidth,
                                r = e.packetLoss,
                                o = e.framerate,
                                a = e.resolution;
                            if (i)
                                if (s)
                                    if (r)
                                        if (o)
                                            if (a) {
                                                if (this._avgAudioBitrateUp.addNext(i.audio.upload), this._avgAudioBitrateDown.addNext(i.audio.download), this._avgVideoBitrateUp.addNext(i.video.upload), this._avgVideoBitrateDown.addNext(i.video.download), Qt.supportsBandwidthStatistics() && (this._avgBandwidthUp.addNext(s.upload), this._avgBandwidthDown.addNext(s.download)), this._avgPacketLossUp.addNext(r.upload), this._avgPacketLossDown.addNext(r.download), this._avgPacketLossTotal.addNext(r.total), this._avgCQ.addNext(e.connectionQuality), o && (this._avgRemoteFPS.addNext(this._calculateAvgVideoFps(o, !1, $n.CAMERA)), this._avgRemoteScreenFPS.addNext(this._calculateAvgVideoFps(o, !1, $n.DESKTOP)), this._avgLocalFPS.addNext(this._calculateAvgVideoFps(o, !0, $n.CAMERA)), this._avgLocalScreenFPS.addNext(this._calculateAvgVideoFps(o, !0, $n.DESKTOP))), a && (this._avgRemoteCameraPixels.addNext(this._calculateAvgVideoPixels(a, !1, $n.CAMERA)), this._avgRemoteScreenPixels.addNext(this._calculateAvgVideoPixels(a, !1, $n.DESKTOP)), this._avgLocalCameraPixels.addNext(this._calculateAvgVideoPixels(a, !0, $n.CAMERA)), this._avgLocalScreenPixels.addNext(this._calculateAvgVideoPixels(a, !0, $n.DESKTOP))), this._sampleIdx += 1, this._sampleIdx >= this._n) {
                                                    const i = {
                                                        p2p: t,
                                                        conference_size: n
                                                    };
                                                    e.transport && e.transport.length && Object.assign(i, {
                                                        local_candidate_type: e.transport[0].localCandidateType,
                                                        remote_candidate_type: e.transport[0].remoteCandidateType,
                                                        transport_type: e.transport[0].type
                                                    }), this._avgAudioBitrateUp.appendReport(i), this._avgAudioBitrateDown.appendReport(i), this._avgVideoBitrateUp.appendReport(i), this._avgVideoBitrateDown.appendReport(i), Qt.supportsBandwidthStatistics() && (this._avgBandwidthUp.appendReport(i), this._avgBandwidthDown.appendReport(i)), this._avgPacketLossUp.appendReport(i), this._avgPacketLossDown.appendReport(i), this._avgPacketLossTotal.appendReport(i), this._avgRemoteFPS.appendReport(i), isNaN(this._avgRemoteScreenFPS.calculate()) || this._avgRemoteScreenFPS.appendReport(i), this._avgLocalFPS.appendReport(i), isNaN(this._avgLocalScreenFPS.calculate()) || this._avgLocalScreenFPS.appendReport(i), this._avgRemoteCameraPixels.appendReport(i), isNaN(this._avgRemoteScreenPixels.calculate()) || this._avgRemoteScreenPixels.appendReport(i), this._avgLocalCameraPixels.appendReport(i), isNaN(this._avgLocalScreenPixels.calculate()) || this._avgLocalScreenPixels.appendReport(i), this._avgCQ.appendReport(i), On.sendAnalytics(wt(i)), this._resetAvgStats()
                                                }
                                            } else Xa.error("No resolution");
                            else Xa.error('No "framerate"');
                            else Xa.error('No "packetloss"');
                            else Xa.error('No "bandwidth"');
                            else Xa.error('No "bitrate"')
                        }
                        _calculateAvgVideoPixels(e, t, n) {
                            let i = 0,
                                s = 0;
                            const r = this._conference.myUserId();
                            for (const o of Object.keys(e))
                                if (t ? o === r : o !== r) {
                                    const r = t ? null : this._conference.getParticipantById(o),
                                        a = e[o];
                                    if ((t || r) && a) {
                                        const e = this._calculatePeerAvgVideoPixels(a, r, n);
                                        isNaN(e) || (i += e, s += 1)
                                    }
                                } return i / s
                        }
                        _calculatePeerAvgVideoPixels(e, t, n) {
                            let i = Object.keys(e).map((e => Number(e))),
                                s = null;
                            const r = this._conference.getActivePeerConnection();
                            t ? (s = t.getTracksByMediaType(Cn), s && (i = i.filter((e => s.find((t => !t.isMuted() && t.getSSRC() === e && t.videoType === n)))))) : (s = this._conference.getLocalTracks(Cn), i = i.filter((e => s.find((t => !t.isMuted() && r.getLocalSSRC(t) === e && t.videoType === n)))));
                            let o = 0,
                                a = 0;
                            for (const t of i) {
                                const n = Number(e[t].height) * Number(e[t].width);
                                !isNaN(n) && n > 0 && (o += n, a += 1)
                            }
                            return o / a
                        }
                        _calculateAvgVideoFps(e, t, n) {
                            let i = 0,
                                s = 0;
                            const r = this._conference.myUserId();
                            for (const o of Object.keys(e))
                                if (t ? o === r : o !== r) {
                                    const r = t ? null : this._conference.getParticipantById(o),
                                        a = e[o];
                                    if ((t || r) && a) {
                                        const e = this._calculatePeerAvgVideoFps(a, r, n);
                                        isNaN(e) || (i += e, s += 1)
                                    }
                                } return i / s
                        }
                        _calculatePeerAvgVideoFps(e, t, n) {
                            let i = Object.keys(e).map((e => Number(e))),
                                s = null;
                            const r = this._conference.getActivePeerConnection();
                            t ? (s = t.getTracksByMediaType(Cn), s && (i = i.filter((e => s.find((t => !t.isMuted() && t.getSSRC() === e && t.videoType === n)))))) : (s = this._conference.getLocalTracks(Cn), i = i.filter((e => s.find((t => !t.isMuted() && r.getLocalSSRC(t) === e && t.videoType === n)))));
                            let o = 0,
                                a = 0;
                            for (const t of i) {
                                const n = Number(e[t]);
                                !isNaN(n) && n > 0 && (o += n, a += 1)
                            }
                            return o / a
                        }
                        _maybeSendTransportAnalyticsEvent(e) {
                            if (!e || !e.transport || !e.transport.length) return;
                            const t = {
                                p2p: e.transport[0].p2p,
                                local_candidate_type: e.transport[0].localCandidateType,
                                remote_candidate_type: e.transport[0].remoteCandidateType,
                                transport_type: e.transport[0].type
                            };
                            this._cachedTransportStats && Qe()(t, this._cachedTransportStats) || (this._cachedTransportStats = t, On.sendAnalytics({
                                type: gt,
                                action: "transport.stats",
                                attributes: t
                            }))
                        }
                        _resetAvgJvbStats() {
                            this._resetAvgStats(), this.jvbStatsMonitor._resetAvgStats()
                        }
                        _resetAvgStats() {
                            this._avgAudioBitrateUp.reset(), this._avgAudioBitrateDown.reset(), this._avgVideoBitrateUp.reset(), this._avgVideoBitrateDown.reset(), this._avgBandwidthUp.reset(), this._avgBandwidthDown.reset(), this._avgPacketLossUp.reset(), this._avgPacketLossDown.reset(), this._avgPacketLossTotal.reset(), this._avgRemoteFPS.reset(), this._avgRemoteScreenFPS.reset(), this._avgLocalFPS.reset(), this._avgLocalScreenFPS.reset(), this._avgRemoteCameraPixels.reset(), this._avgRemoteScreenPixels.reset(), this._avgLocalCameraPixels.reset(), this._avgLocalScreenPixels.reset(), this._avgCQ.reset(), this._sampleIdx = 0
                        }
                        dispose() {
                            this._conference.off(ve, this._onP2PStatusChanged), this._conference.off(aa, this._onLocalStatsUpdated), this._conference.off(te, this._onJvb121StatusChanged), this.jvbStatsMonitor.dispose(), this.p2pStatsMonitor.dispose()
                        }
                    }
                    var tc = n(9765),
                        nc = n.n(tc);
                    class ic {
                        constructor(e) {
                            this.stats = {
                                users: {},
                                dominantSpeakerId: null
                            };
                            const t = e.myUserId();
                            this.stats.users[t] = new(nc())(t, null, !0), this.conference = e, e.addEventListener(Q, this._onDominantSpeaker.bind(this)), e.addEventListener(Oe, this._onUserJoin.bind(this)), e.addEventListener(Le, this._onUserLeave.bind(this)), e.addEventListener(W, this._onDisplayNameChange.bind(this)), e.xmpp && e.xmpp.addListener(Hn().SPEAKER_STATS_RECEIVED, this._updateStats.bind(this))
                        }
                        _onDominantSpeaker(e) {
                            const t = this.stats.users[this.stats.dominantSpeakerId],
                                n = this.stats.users[e];
                            t && t.setDominantSpeaker(!1), n && n.setDominantSpeaker(!0), this.stats.dominantSpeakerId = e
                        }
                        _onUserJoin(e, t) {
                            t.isHidden() || this.stats.users[e] || (this.stats.users[e] = new(nc())(e, t.getDisplayName()))
                        }
                        _onUserLeave(e) {
                            const t = this.stats.users[e];
                            t && t.markAsHasLeft()
                        }
                        _onDisplayNameChange(e, t) {
                            const n = this.stats.users[e];
                            n && n.setDisplayName(t)
                        }
                        getStats() {
                            return this.stats.users
                        }
                        _updateStats(e) {
                            for (const t in e) {
                                let n;
                                const i = this.conference.getParticipantById(t);
                                i && i.isHidden() || (this.stats.users[t] ? (n = this.stats.users[t], n.getDisplayName() || n.setDisplayName(e[t].displayName)) : (n = new(nc())(t, e[t].displayName), this.stats.users[t] = n, n.markAsHasLeft())), n.totalDominantSpeakerTime = e[t].totalDominantSpeakerTime
                            }
                        }
                    }
                    var sc = n(6563),
                        rc = n.n(sc);
                    const oc = n(7055).getLogger("modules/version/ComponentsVersions.js");

                    function ac(e) {
                        this.versions = {}, this.conference = e, this.conference.addCommandListener("versions", this.processVersions.bind(this))
                    }
                    ac.prototype.processVersions = function(e, t, n) {
                        if (!this.conference.isFocus(n)) return void oc.warn(`Received versions not from the focus user: ${e}`, n);
                        const i = [];
                        e.children.forEach((e => {
                            const t = e.attributes.name,
                                n = e.value;
                            this.versions[t] !== n && (this.versions[t] = n, oc.info(`Got ${t} version: ${n}`), i.push({
                                id: "component_version",
                                component: t,
                                version: n
                            }))
                        })), i.length > 0 && On.sendLog(JSON.stringify(i))
                    }, ac.prototype.getComponentVersion = function(e) {
                        return this.versions[e]
                    };
                    const cc = "available",
                        dc = "undefined",
                        lc = "busy",
                        hc = "on",
                        uc = "off",
                        pc = "pending",
                        mc = "retrying",
                        fc = "failed",
                        gc = "error_no_connection",
                        _c = "error_session_already_exists",
                        vc = (0, f.getLogger)("modules/videosipgw/JitsiVideoSIPGWSession.js"),
                        yc = "STATE_CHANGED";
                    class Sc extends Ti {
                        constructor(e, t, n) {
                            super(), this.sipAddress = e, this.displayName = t, this.chatRoom = n, this.state = void 0
                        }
                        stop() {
                            this.state !== uc && this.state !== fc ? this._sendJibriIQ("stop") : vc.warn("Video SIP GW session already stopped or failed!")
                        }
                        start() {
                            this.state !== hc && this.state !== uc && this.state !== pc && this.state !== mc ? this._sendJibriIQ("start") : vc.warn("Video SIP GW session already started!")
                        }
                        setState(e, t) {
                            if (e === this.state) return;
                            const n = this.state;
                            this.state = e, this.eventEmitter.emit(yc, {
                                address: this.sipAddress,
                                failureReason: t,
                                oldState: n,
                                newState: this.state,
                                displayName: this.displayName
                            })
                        }
                        addStateListener(e) {
                            this.addListener(yc, e)
                        }
                        removeStateListener(e) {
                            this.removeListener(yc, e)
                        }
                        _sendJibriIQ(e) {
                            const t = {
                                xmlns: "http://jitsi.org/protocol/jibri",
                                action: e,
                                sipaddress: this.sipAddress
                            };
                            t.displayname = this.displayName;
                            const n = (0, Xe.$iq)({
                                to: this.chatRoom.focusMucJid,
                                type: "set"
                            }).c("jibri", t).up();
                            vc.debug(`${e} video SIP GW session`, n.nodeTree), this.chatRoom.connection.sendIQ(n, (() => {}), (t => {
                                vc.error(`Failed to ${e} video SIP GW session, error: `, t), this.setState(fc)
                            }))
                        }
                    }
                    const Ec = (0, f.getLogger)("modules/videosipgw/VideoSIPGW.js");
                    class bc {
                        constructor(e) {
                            this.chatRoom = e, this.eventEmitter = e.eventEmitter, Ec.debug("creating VideoSIPGW"), this.sessions = {}, this.sessionStateChangeListener = this.sessionStateChanged.bind(this), e.addPresenceListener("jibri-sip-call-state", this.handleJibriSIPState.bind(this))
                        }
                        handleJibriSIPState(e) {
                            const t = e.attributes;
                            if (!t) return;
                            Ec.debug("Handle video sip gw state : ", t);
                            const n = t.state;
                            if (n !== this.state) switch (n) {
                                case hc:
                                case uc:
                                case pc:
                                case mc:
                                case fc: {
                                    const e = t.sipaddress;
                                    if (!e) return;
                                    const i = this.sessions[e];
                                    i ? i.setState(n, t.failure_reason) : Ec.warn("Video SIP GW session not found:", e)
                                }
                            }
                        }
                        createVideoSIPGWSession(e, t) {
                            if (this.sessions[e]) return Ec.warn("There was already a Video SIP GW session for address", e), new Error(_c);
                            const n = new Sc(e, t, this.chatRoom);
                            return n.addStateListener(this.sessionStateChangeListener), this.sessions[e] = n, n
                        }
                        sessionStateChanged(e) {
                            const t = e.address;
                            if (e.newState === uc || e.newState === fc) {
                                const e = this.sessions[t];
                                if (!e) return void Ec.error("Missing Video SIP GW session with address:", t);
                                e.removeStateListener(this.sessionStateChangeListener), delete this.sessions[t]
                            }
                            this.eventEmitter.emit(Hn().VIDEO_SIP_GW_SESSION_STATE_CHANGED, e)
                        }
                    }

                    function Cc(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? Object(arguments[t]) : {},
                                i = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), i.forEach((function(t) {
                                Tc(e, t, n[t])
                            }))
                        }
                        return e
                    }

                    function Tc(e, t, n) {
                        return t in e ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = n, e
                    }
                    const Rc = (0, f.getLogger)("JitsiConference.js");

                    function Ac(e) {
                        var t;
                        if (!e.name || e.name.toLowerCase() !== e.name) {
                            const e = "Invalid conference name (no conference name passed or it contains invalid characters like capital letters)!";
                            throw Rc.error(e), new Error(e)
                        }
                        if (this.connection = e.connection, this.xmpp = null === (t = this.connection) || void 0 === t ? void 0 : t.xmpp, this.xmpp.isRoomCreated(e.name, e.customDomain)) {
                            const e = "A coference with the same name has already been created!";
                            throw delete this.connection, delete this.xmpp, Rc.error(e), new Error(e)
                        }
                        this.eventEmitter = new(ze()), this.options = e, this.eventManager = new qn(this), this.participants = {}, this._init(e), this.componentsVersions = new ac(this), this.jvbJingleSession = null, this.lastDominantSpeaker = null, this.dtmfManager = null, this.somebodySupportsDTMF = !1, this.authEnabled = !1, this.startAudioMuted = !1, this.startVideoMuted = !1, this.startMutedPolicy = {
                            audio: !1,
                            video: !1
                        }, this.isMutedByFocus = !1, this.mutedByFocusActor = null, this.isVideoMutedByFocus = !1, this.mutedVideoByFocusActor = null, this.wasStopped = !1, this.properties = {}, this.connectionQuality = new fa(this, this.eventEmitter, e), this.avgRtpStatsReporter = new ec(this, e.config.avgRtpStatsN || 15), e.config.disableAudioLevels || (this._audioOutputProblemDetector = new Qa(this)), this.isJvbConnectionInterrupted = !1, this.speakerStatsCollector = new ic(this), this.deferredStartP2PTask = null;
                        const n = parseInt(e.config.p2p && e.config.p2p.backToP2PDelay, 10);
                        this.backToP2PDelay = isNaN(n) ? 5 : n, Rc.info(`backToP2PDelay: ${this.backToP2PDelay}`), this.isP2PConnectionInterrupted = !1, this.p2p = !1, this.p2pJingleSession = null, this.videoSIPGWHandler = new bc(this.room), this.recordingManager = new class {
                            constructor(e) {
                                this._sessions = {}, this._chatRoom = e, this.onPresence = this.onPresence.bind(this), this._chatRoom.eventEmitter.addListener(Hn().PRESENCE_RECEIVED, this.onPresence)
                            }
                            getSession(e) {
                                return this._sessions[e]
                            }
                            onPresence({
                                fromHiddenDomain: e,
                                presence: t
                            }) {
                                Ga.isFromFocus(t) ? this._handleFocusPresence(t) : e && this._handleJibriPresence(t)
                            }
                            startRecording(e) {
                                const t = new qa(function(e) {
                                    for (var t = 1; t < arguments.length; t++) {
                                        var n = null != arguments[t] ? Object(arguments[t]) : {},
                                            i = Object.keys(n);
                                        "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                            return Object.getOwnPropertyDescriptor(n, e).enumerable
                                        })))), i.forEach((function(t) {
                                            Ka(e, t, n[t])
                                        }))
                                    }
                                    return e
                                }({}, e, {
                                    connection: this._chatRoom.connection
                                }));
                                return t.start({
                                    appData: e.appData,
                                    broadcastId: e.broadcastId,
                                    focusMucJid: this._chatRoom.focusMucJid,
                                    streamId: e.streamId
                                }).then((() => (this.getSession(t.getID()) || (this._addSession(t), this._emitSessionUpdate(t)), t))).catch((e => (this._emitSessionUpdate(t), Promise.reject(e))))
                            }
                            stopRecording(e) {
                                const t = this.getSession(e);
                                return t ? t.stop({
                                    focusMucJid: this._chatRoom.focusMucJid
                                }) : Promise.reject(new Error("Could not find session"))
                            }
                            _addSession(e) {
                                this._sessions[e.getID()] = e
                            }
                            _createSession(e, t, n) {
                                const i = new qa({
                                    connection: this._chatRoom.connection,
                                    focusMucJid: this._chatRoom.focusMucJid,
                                    mode: n,
                                    sessionID: e,
                                    status: t
                                });
                                return this._addSession(i), i
                            }
                            _emitSessionUpdate(e, t) {
                                this._chatRoom.eventEmitter.emit(Hn().RECORDER_STATE_CHANGED, e, t)
                            }
                            _handleFocusPresence(e) {
                                const t = Ga.getFocusRecordingUpdate(e);
                                if (!t) return;
                                const {
                                    error: n,
                                    initiator: i,
                                    recordingMode: s,
                                    sessionID: r,
                                    status: o
                                } = t;
                                let a = this.getSession(r);
                                a || "off" !== o ? a && a.getStatus() === o && a.getError() === n ? za.warn("Ignoring duplicate presence update: ", JSON.stringify(t)) : (a || (a = this._createSession(r, o, s)), a.setStatus(o), n && a.setError(n), this._emitSessionUpdate(a, i)) : za.warn("Ignoring recording presence update", "Received a new session with status off.")
                            }
                            _handleJibriPresence(e) {
                                const {
                                    liveStreamViewURL: t,
                                    mode: n,
                                    sessionID: i
                                } = Ga.getHiddenDomainUpdate(e);
                                if (!i) return void za.warn("Ignoring potential jibri presence due to no session id.");
                                let s = this.getSession(i);
                                s || (s = this._createSession(i, "", n)), s.setLiveStreamViewURL(t), this._emitSessionUpdate(s)
                            }
                        }(this.room), this._conferenceJoinAnalyticsEventSent = void 0, this.isE2EESupported() && (Rc.info("End-to-End Encryption is supported"), this._e2eEncryption = new Fi(this))
                    }

                    function wc(e, t, n) {
                        this.appID = e, this.token = t, this.options = n, this.xmpp = new Dr(n, t), this.addEventListener(ci, ((e, t, n, i) => {
                            On.sendAnalyticsAndLog(function(e, t, n) {
                                return {
                                    type: gt,
                                    action: "connection.failed",
                                    attributes: mt({
                                        error_type: e,
                                        error_message: t
                                    }, n)
                                }
                            }(e, t, i))
                        })), this.addEventListener(oi, (e => {
                            e && On.sendAnalytics(yt, {
                                message: e
                            }), On.sendLog(JSON.stringify({
                                id: yt,
                                msg: e
                            }))
                        }))
                    }
                    Ac.prototype.constructor = Ac, Ac.resourceCreator = function(e, t) {
                        let n;
                        return t ? n = $i().randomHexString(8).toLowerCase() : (n = Xe.Strophe.getNodeFromJid(e).substr(0, 8).toLowerCase(), /[0-9a-f]{8}/g.test(n) || (n = $i().randomHexString(8).toLowerCase())), n
                    }, Ac.prototype._init = function(e = {}) {
                        this.eventManager.setupXMPPListeners();
                        const {
                            config: t
                        } = this.options, n = {
                            disabledCodec: t.videoQuality ? t.videoQuality.disabledCodec : t.p2p && t.p2p.disableH264 && Os().H264,
                            enforcePreferredCodec: t.videoQuality && t.videoQuality.enforcePreferredCodec,
                            jvbCodec: t.videoQuality && t.videoQuality.preferredCodec || t.preferH264 && Os().H264,
                            p2pCodec: t.p2p ? t.p2p.preferredCodec || t.p2p.preferH264 && Os().H264 : Os().VP8
                        };
                        this.codecSelection = new Or(this, n), this._statsCurrentId = t.statisticsId ? t.statisticsId : gs.callStatsUserName, this.room = this.xmpp.createRoom(this.options.name, Cc({}, t, {
                            statsId: this._statsCurrentId
                        }), Ac.resourceCreator), this._onIceConnectionInterrupted = this._onIceConnectionInterrupted.bind(this), this.room.addListener(Vn.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), this._onIceConnectionRestored = this._onIceConnectionRestored.bind(this), this.room.addListener(Vn.CONNECTION_RESTORED, this._onIceConnectionRestored), this._onIceConnectionEstablished = this._onIceConnectionEstablished.bind(this), this.room.addListener(Vn.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), this._updateProperties = this._updateProperties.bind(this), this.room.addListener(Vn.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), this._sendConferenceJoinAnalyticsEvent = this._sendConferenceJoinAnalyticsEvent.bind(this), this.room.addListener(Vn.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent), this.e2eping = new ja(this, t, ((e, t) => {
                            try {
                                this.sendMessage(e, t, !0)
                            } catch (e) {
                                Rc.warn("Failed to send E2E ping request or response.", e && e.msg)
                            }
                        })), this.rtc || (this.rtc = new oa(this, e), this.eventManager.setupRTCListeners()), this.receiveVideoController = new Va(this, this.rtc), this.sendVideoController = new Ha(this, this.rtc), this.participantConnectionStatus = new si(this.rtc, this, {
                            rtcMuteTimeout: t._peerConnStatusRtcMuteTimeout,
                            outOfLastNTimeout: t._peerConnStatusOutOfLastNTimeout
                        }), this.participantConnectionStatus.init();
                        let i = !0;
                        if (t.testing && t.testing.callStatsThreshold && (i = 100 * Math.random() <= t.testing.callStatsThreshold), this.statistics || (this.statistics = new On(this.xmpp, {
                                aliasName: this._statsCurrentId,
                                userName: t.statisticsDisplayName ? t.statisticsDisplayName : this.myUserId(),
                                confID: t.confID || `${this.connection.options.hosts.domain}/${this.options.name}`,
                                siteID: t.siteID,
                                customScriptUrl: t.callStatsCustomScriptUrl,
                                callStatsID: t.callStatsID,
                                callStatsSecret: t.callStatsSecret,
                                callStatsApplicationLogsDisabled: t.callStatsApplicationLogsDisabled,
                                enableCallStats: i,
                                roomName: this.options.name,
                                applicationName: t.applicationName,
                                getWiFiStatsMethod: t.getWiFiStatsMethod,
                                configParams: t.callStatsConfigParams
                            }), On.analytics.addPermanentProperties({
                                callstats_name: this._statsCurrentId
                            }), t.longTasksStatsInterval && this.statistics.attachLongTasksStats(this)), this.eventManager.setupChatRoomListeners(), this.eventManager.setupStatisticsListeners(), t.enableTalkWhileMuted && Qt.supportsVADDetection())
                            if (t.createVADProcessor) {
                                Rc.info("Using VAD detection for generating talk while muted events"), this._audioAnalyser || (this._audioAnalyser = new Ma(this, t.createVADProcessor));
                                const e = new Na;
                                e.on(Ta, (() => this.eventEmitter.emit(Pe))), this._audioAnalyser.addVADDetectionService(e)
                            } else Rc.warn("No VAD Processor was provided. Talk while muted detection service was not initialized!");
                        if (t.enableNoisyMicDetection && Qt.supportsVADDetection())
                            if (t.createVADProcessor) {
                                this._audioAnalyser || (this._audioAnalyser = new Ma(this, t.createVADProcessor));
                                const e = new Da;
                                e.on(Ea, (() => this.eventEmitter.emit(ue))), this._audioAnalyser.addVADDetectionService(e)
                            } else Rc.warn("No VAD Processor was provided. Noisy microphone detection service was not initialized!");
                        t.enableNoAudioDetection && (this._noAudioSignalDetection = new Ra(this), this._noAudioSignalDetection.on(Sa, (() => {
                            this.eventEmitter.emit(he)
                        })), this._noAudioSignalDetection.on(ya, (e => {
                            this.eventEmitter.emit(x, e)
                        }))), "channelLastN" in t && this.setLastN(t.channelLastN), this.jvb121Status = new Ba(this), this.p2pDominantSpeakerDetection = new Aa(this), t && t.deploymentInfo && t.deploymentInfo.userRegion && this.setLocalParticipantProperty("region", t.deploymentInfo.userRegion), this.setLocalParticipantProperty("codecType", this.codecSelection.getPreferredCodec()), t && t.transcriptionLanguage && "en-US" !== t.transcriptionLanguage && this.setLocalParticipantProperty("transcription_language", t.transcriptionLanguage)
                    }, Ac.prototype.join = function(e, t = !1) {
                        this.room && this.room.join(e, t).then((() => this._maybeSetSITimeout()))
                    }, Ac.prototype.authenticateAndUpgradeRole = function(e) {
                        return Nr.call(this, Cc({}, e, {
                            onCreateResource: Ac.resourceCreator
                        }))
                    }, Ac.prototype.isJoined = function() {
                        return this.room && this.room.joined
                    }, Ac.prototype.isP2PEnabled = function() {
                        return Boolean(this.options.config.p2p && this.options.config.p2p.enabled) || void 0 === this.options.config.p2p
                    }, Ac.prototype.isP2PTestModeEnabled = function() {
                        return Boolean(this.options.config.testing && this.options.config.testing.p2pTestMode)
                    }, Ac.prototype.leave = function() {
                        if (this.participantConnectionStatus && (this.participantConnectionStatus.dispose(), this.participantConnectionStatus = null), this.avgRtpStatsReporter && (this.avgRtpStatsReporter.dispose(), this.avgRtpStatsReporter = null), this._audioOutputProblemDetector && (this._audioOutputProblemDetector.dispose(), this._audioOutputProblemDetector = null), this.e2eping && (this.e2eping.stop(), this.e2eping = null), this.getLocalTracks().forEach((e => this.onLocalTrackRemoved(e))), this.rtc.closeBridgeChannel(), this._sendConferenceLeftAnalyticsEvent(), this.statistics && this.statistics.dispose(), this._delayedIceFailed && this._delayedIceFailed.cancel(), this._maybeClearSITimeout(), this.jvbJingleSession && (this.jvbJingleSession.close(), this.jvbJingleSession = null), this.p2pJingleSession && (this.p2pJingleSession.close(), this.p2pJingleSession = null), this.room) {
                            const e = this.room;
                            return e.removeListener(Vn.CONNECTION_INTERRUPTED, this._onIceConnectionInterrupted), e.removeListener(Vn.CONNECTION_RESTORED, this._onIceConnectionRestored), e.removeListener(Vn.CONNECTION_ESTABLISHED, this._onIceConnectionEstablished), e.removeListener(Vn.CONFERENCE_PROPERTIES_CHANGED, this._updateProperties), e.removeListener(Vn.MEETING_ID_SET, this._sendConferenceJoinAnalyticsEvent), this.eventManager.removeXMPPListeners(), this.room = null, e.leave().then((() => {
                                this.rtc && this.rtc.destroy()
                            })).catch((e => {
                                throw this.getParticipants().forEach((e => this.onMemberLeft(e.getJid()))), e
                            }))
                        }
                        return Promise.reject(new Error("The conference is has been already left"))
                    }, Ac.prototype._getActiveMediaSession = function() {
                        return this.isP2PActive() ? this.p2pJingleSession : this.jvbJingleSession
                    }, Ac.prototype._getMediaSessions = function() {
                        const e = [];
                        return this.jvbJingleSession && e.push(this.jvbJingleSession), this.p2pJingleSession && e.push(this.p2pJingleSession), e
                    }, Ac.prototype._sendBridgeVideoTypeMessage = function(e) {
                        let t = !e || e.isMuted() ? xr().NONE : e.getVideoType();
                        t === xr().DESKTOP && this._desktopSharingFrameRate > 5 && (t = xr().DESKTOP_HIGH_FPS), this.rtc.setVideoType(t)
                    }, Ac.prototype.getName = function() {
                        return this.options.name
                    }, Ac.prototype.getConnection = function() {
                        return this.connection
                    }, Ac.prototype.isAuthEnabled = function() {
                        return this.authEnabled
                    }, Ac.prototype.isLoggedIn = function() {
                        return Boolean(this.authIdentity)
                    }, Ac.prototype.getAuthLogin = function() {
                        return this.authIdentity
                    }, Ac.prototype.isExternalAuthEnabled = function() {
                        return this.room && this.room.moderator.isExternalAuthEnabled()
                    }, Ac.prototype.getExternalAuthUrl = function(e) {
                        return new Promise(((t, n) => {
                            this.isExternalAuthEnabled() ? e ? this.room.moderator.getPopupLoginUrl(t, n) : this.room.moderator.getLoginUrl(t, n) : n()
                        }))
                    }, Ac.prototype.getLocalTracks = function(e) {
                        let t = [];
                        return this.rtc && (t = this.rtc.getLocalTracks(e)), t
                    }, Ac.prototype.getLocalAudioTrack = function() {
                        return this.rtc ? this.rtc.getLocalAudioTrack() : null
                    }, Ac.prototype.getLocalVideoTrack = function() {
                        return this.rtc ? this.rtc.getLocalVideoTrack() : null
                    }, Ac.prototype.getPerformanceStats = function() {
                        return {
                            longTasksStats: this.statistics.getLongTasksStats()
                        }
                    }, Ac.prototype.on = function(e, t) {
                        this.eventEmitter && this.eventEmitter.on(e, t)
                    }, Ac.prototype.off = function(e, t) {
                        this.eventEmitter && this.eventEmitter.removeListener(e, t)
                    }, Ac.prototype.addEventListener = Ac.prototype.on, Ac.prototype.removeEventListener = Ac.prototype.off, Ac.prototype.addCommandListener = function(e, t) {
                        this.room && this.room.addPresenceListener(e, t)
                    }, Ac.prototype.removeCommandListener = function(e, t) {
                        this.room && this.room.removePresenceListener(e, t)
                    }, Ac.prototype.sendTextMessage = function(e, t = "body") {
                        this.room && this.room.sendMessage(e, t)
                    }, Ac.prototype.sendPrivateTextMessage = function(e, t, n = "body") {
                        this.room && this.room.sendPrivateMessage(e, t, n)
                    }, Ac.prototype.sendCommand = function(e, t) {
                        this.room ? this.room.addOrReplaceInPresence(e, t) && this.room.sendPresence() : Rc.warn("Not sending a command, room not initialized.")
                    }, Ac.prototype.sendCommandOnce = function(e, t) {
                        this.sendCommand(e, t), this.removeCommand(e)
                    }, Ac.prototype.removeCommand = function(e) {
                        this.room && this.room.removeFromPresence(e)
                    }, Ac.prototype.setDisplayName = function(e) {
                        if (this.room) {
                            const t = "nick";
                            if (!e && !this.room.getFromPresence(t)) return;
                            this.room.addOrReplaceInPresence(t, {
                                attributes: {
                                    xmlns: "http://jabber.org/protocol/nick"
                                },
                                value: e
                            }) && this.room.sendPresence()
                        }
                    }, Ac.prototype.setSubject = function(e) {
                        this.room && this.isModerator() ? this.room.setSubject(e) : Rc.warn(`Failed to set subject, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
                    }, Ac.prototype.getTranscriber = function() {
                        if (void 0 === this.transcriber) {
                            this.transcriber = new(rc());
                            const e = this.getLocalTracks(En);
                            for (const t of e) this.transcriber.addTrack(t);
                            const t = this.rtc.getRemoteTracks(En);
                            for (const e of t) this.transcriber.addTrack(e)
                        }
                        return this.transcriber
                    }, Ac.prototype.getTranscriptionStatus = function() {
                        return this.room.transcriptionStatus
                    }, Ac.prototype.addTrack = function(e) {
                        const t = e.getType(),
                            n = this.rtc.getLocalTracks(t);
                        return n.length > 0 ? e === n[0] ? Promise.resolve(e) : Promise.reject(new Error(`Cannot add second ${t} track to the conference`)) : this.replaceTrack(null, e)
                    }, Ac.prototype._fireAudioLevelChangeEvent = function(e, t) {
                        const n = this.getActivePeerConnection();
                        t && n !== t || this.eventEmitter.emit(Me, this.myUserId(), e)
                    }, Ac.prototype._fireMuteChangeEvent = function(e) {
                        let t;
                        if (this.isMutedByFocus && e.isAudioTrack() && !e.isMuted() ? (this.isMutedByFocus = !1, this.room.muteParticipant(this.room.myroomjid, !1, En)) : this.isVideoMutedByFocus && e.isVideoTrack() && !e.isMuted() && (this.isVideoMutedByFocus = !1, this.room.muteParticipant(this.room.myroomjid, !1, Cn)), this.mutedByFocusActor && e.isAudioTrack()) {
                            const e = Xe.Strophe.getResourceFromJid(this.mutedByFocusActor);
                            t = this.participants[e]
                        } else if (this.mutedVideoByFocusActor && e.isVideoTrack()) {
                            const e = Xe.Strophe.getResourceFromJid(this.mutedVideoByFocusActor);
                            t = this.participants[e]
                        }
                        e.isVideoTrack() && !Qt.doesVideoMuteByStreamRemove() && this._sendBridgeVideoTypeMessage(e), this.eventEmitter.emit(De, e, t)
                    }, Ac.prototype._getInitialLocalTracks = function() {
                        return this.getLocalTracks().filter((e => {
                            const t = e.getType();
                            return !(t !== En || this.isStartAudioMuted() && !Qt.isWebKitBased() && !Qt.isReactNative()) || t === Cn && !this.isStartVideoMuted()
                        }))
                    }, Ac.prototype.onLocalTrackRemoved = function(e) {
                        e._setConference(null), this.rtc.removeLocalTrack(e), e.removeEventListener(Qn, e.muteHandler), e.removeEventListener(zn, e.audioLevelHandler), e.isVideoTrack() && e.videoType === Bn().DESKTOP && this.statistics.sendScreenSharingEvent(!1), this.eventEmitter.emit(Ne, e)
                    }, Ac.prototype.removeTrack = function(e) {
                        return this.replaceTrack(e, null)
                    }, Ac.prototype.replaceTrack = function(e, t) {
                        const n = this === (null == e ? void 0 : e.conference);
                        return n && e.disposed || t && t.disposed ? Promise.reject(new pt(ct)) : (e && !n && Rc.warn(`JitsiConference.replaceTrack oldTrack (${e} does not belong to this conference`), this._doReplaceTrack(n ? e : null, t).then((() => (n && this.onLocalTrackRemoved(e), t && this._setupNewTrack(t), (n && (null == e ? void 0 : e.isVideoTrack()) || (null == t ? void 0 : t.isVideoTrack())) && this._sendBridgeVideoTypeMessage(t), null !== t && (this.isMutedByFocus || this.isVideoMutedByFocus) && this._fireMuteChangeEvent(t), Promise.resolve()))).catch((e => (Rc.error(`replaceTrack failed: ${null==e?void 0:e.stack}`), Promise.reject(e)))))
                    }, Ac.prototype._doReplaceTrack = function(e, t) {
                        const n = [];
                        return this.jvbJingleSession ? n.push(this.jvbJingleSession.replaceTrack(e, t)) : Rc.info("_doReplaceTrack - no JVB JingleSession"), this.p2pJingleSession ? n.push(this.p2pJingleSession.replaceTrack(e, t)) : Rc.info("_doReplaceTrack - no P2P JingleSession"), Promise.all(n)
                    }, Ac.prototype._setupNewTrack = function(e) {
                        if (e.isAudioTrack() || e.isVideoTrack() && e.videoType !== Bn().DESKTOP) {
                            const t = oa.getCurrentlyAvailableMediaDevices().find((t => t.kind === `${e.getTrack().kind}input` && t.label === e.getTrack().label));
                            t && On.sendActiveDeviceListEvent(oa.getEventDataForActiveDevice(t))
                        }
                        if (e.isVideoTrack()) {
                            const t = "videoType";
                            (e.videoType !== Bn().CAMERA || this.room.getFromPresence(t)) && this.sendCommand(t, {
                                value: e.videoType
                            })
                        }
                        this.rtc.addLocalTrack(e), e.isAudioTrack() ? this.room.setAudioMute(e.isMuted()) : this.room.setVideoMute(e.isMuted()), e.muteHandler = this._fireMuteChangeEvent.bind(this, e), e.audioLevelHandler = this._fireAudioLevelChangeEvent.bind(this), e.addEventListener(Qn, e.muteHandler), e.addEventListener(zn, e.audioLevelHandler), e._setConference(this), this.eventEmitter.emit(Ie, e)
                    }, Ac.prototype._addLocalTrackAsUnmute = function(e) {
                        const t = [];
                        return this.jvbJingleSession ? t.push(this.jvbJingleSession.addTrackAsUnmute(e)) : Rc.debug("Add local MediaStream as unmute - no JVB Jingle session started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.addTrackAsUnmute(e)) : Rc.debug("Add local MediaStream as unmute - no P2P Jingle session started yet"), Promise.allSettled(t).then((() => {
                            e.isVideoTrack() && this._sendBridgeVideoTypeMessage(e)
                        }))
                    }, Ac.prototype._removeLocalTrackAsMute = function(e) {
                        const t = [];
                        return this.jvbJingleSession ? t.push(this.jvbJingleSession.removeTrackAsMute(e)) : Rc.debug("Remove local MediaStream - no JVB JingleSession started yet"), this.p2pJingleSession ? t.push(this.p2pJingleSession.removeTrackAsMute(e)) : Rc.debug("Remove local MediaStream - no P2P JingleSession started yet"), Promise.allSettled(t).then((() => {
                            e.isVideoTrack() && this._sendBridgeVideoTypeMessage()
                        }))
                    }, Ac.prototype.getRole = function() {
                        return this.room.role
                    }, Ac.prototype.isHidden = function() {
                        return this.connection ? Xe.Strophe.getDomainFromJid(this.connection.getJid()) === this.options.config.hiddenDomain : null
                    }, Ac.prototype.isModerator = function() {
                        return this.room ? this.room.isModerator() : null
                    }, Ac.prototype.lock = function(e) {
                        return this.isModerator() ? new Promise(((t, n) => {
                            this.room.lockRoom(e || "", (() => t()), (e => n(e)), (() => n(N)))
                        })) : Promise.reject(new Error("You are not moderator."))
                    }, Ac.prototype.unlock = function() {
                        return this.lock()
                    }, Ac.prototype.selectParticipant = function(e) {
                        this.selectParticipants([e])
                    }, Ac.prototype.selectParticipants = function(e) {
                        if (!Array.isArray(e)) throw new Error("Invalid argument; participantIds must be an array.");
                        this.receiveVideoController.selectEndpoints(e)
                    }, Ac.prototype.getLastN = function() {
                        return this.receiveVideoController.getLastN()
                    }, Ac.prototype.setLastN = function(e) {
                        if (!Number.isInteger(e) && !Number.parseInt(e, 10)) throw new Error(`Invalid value for lastN: ${e}`);
                        const t = Number(e);
                        if (t < -1) throw new RangeError("lastN cannot be smaller than -1");
                        if (this.receiveVideoController.setLastN(t), this.p2pJingleSession) {
                            const e = 0 !== t;
                            this.p2pJingleSession.setMediaTransferActive(!0, e).catch((t => {
                                Rc.error(`Failed to adjust video transfer status (${e})`, t)
                            }))
                        }
                    }, Ac.prototype.isInLastN = function(e) {
                        return this.rtc.isInLastN(e)
                    }, Ac.prototype.getParticipants = function() {
                        return Object.values(this.participants)
                    }, Ac.prototype.getParticipantCount = function(e = !1) {
                        let t = this.getParticipants();
                        return e || (t = t.filter((e => !e.isHidden()))), t.length + 1
                    }, Ac.prototype.getParticipantById = function(e) {
                        return this.participants[e]
                    }, Ac.prototype.grantOwner = function(e) {
                        const t = this.getParticipantById(e);
                        t && this.room.setAffiliation(t.getJid(), "owner")
                    }, Ac.prototype.revokeOwner = function(e) {
                        const t = this.getParticipantById(e),
                            n = this.myUserId() === e,
                            i = this.isMembersOnly() ? "member" : "none";
                        n ? this.room.setAffiliation(this.room.myroomjid, i) : t && this.room.setAffiliation(t.getJid(), i)
                    }, Ac.prototype.kickParticipant = function(e, t) {
                        const n = this.getParticipantById(e);
                        n && this.room.kick(n.getJid(), t)
                    }, Ac.prototype._maybeClearSITimeout = function() {
                        this._sessionInitiateTimeout && (this.jvbJingleSession || this.getParticipantCount() < 2) && (window.clearTimeout(this._sessionInitiateTimeout), this._sessionInitiateTimeout = null)
                    }, Ac.prototype._maybeSetSITimeout = function() {
                        !this.jvbJingleSession && this.getParticipantCount() >= 2 && !this._sessionInitiateTimeout && (this._sessionInitiateTimeout = window.setTimeout((() => {
                            this._sessionInitiateTimeout = null, On.sendAnalytics(Tt("session-initiate.timeout", {
                                p2p: !1,
                                value: 5e3
                            }))
                        }), 5e3))
                    }, Ac.prototype.muteParticipant = function(e, t) {
                        const n = t || En;
                        if (n !== En && n !== Cn) return void Rc.error(`Unsupported media type: ${n}`);
                        const i = this.getParticipantById(e);
                        i && this.room.muteParticipant(i.getJid(), !0, n)
                    }, Ac.prototype.onMemberJoined = function(e, t, n, i, s, r, o, a, c, d, l) {
                        const h = Xe.Strophe.getResourceFromJid(e);
                        if ("focus" === h || this.myUserId() === h) return;
                        const u = new ri(e, this, t, i, s, r, o);
                        u.setRole(n), u.setBotType(a), u.setFeatures(d), u.setIsReplacing(l), this.participants[h] = u, this.eventEmitter.emit(Oe, h, u), this._updateFeatures(u), this.isJoined() && this._maybeStartOrStopP2P(), this._maybeSetSITimeout()
                    }, Ac.prototype._onMucJoined = function() {
                        this._maybeStartOrStopP2P()
                    }, Ac.prototype._updateFeatures = function(e) {
                        e.getFeatures().then((t => {
                            e._supportsDTMF = t.has("urn:xmpp:jingle:dtmf:0"), this.updateDTMFSupport(), t.has(Ir) && e.setProperty("features_jigasi", !0), t.has(Mr) && e.setProperty("features_e2ee", !0)
                        })).catch((() => !1))
                    }, Ac.prototype._onMemberBotTypeChanged = function(e, t) {
                        const n = this.getParticipants().find((t => t.getJid() === e));
                        if (n) {
                            n.setBotType(t);
                            const i = Xe.Strophe.getResourceFromJid(e);
                            this.eventEmitter.emit(je, i, t)
                        }
                        n.getBotType() || this._maybeStartOrStopP2P()
                    }, Ac.prototype.onMemberLeft = function(e) {
                        const t = Xe.Strophe.getResourceFromJid(e);
                        if ("focus" === t || this.myUserId() === t) return;
                        const n = this.participants[t];
                        delete this.participants[t];
                        const i = this._getMediaSessions(),
                            s = [];
                        for (const e of i) s.push(e.removeRemoteStreamsOnLeave(t));
                        Promise.allSettled(s).then((e => {
                            let i = [];
                            e.map((e => e.value)).forEach((e => {
                                e && (i = i.concat(e))
                            })), i.forEach((e => {
                                this.eventEmitter.emit(Ne, e)
                            })), n && this.eventEmitter.emit(Le, t, n), null !== this.room && (this._maybeStartOrStopP2P(!0), this._maybeClearSITimeout())
                        }))
                    }, Ac.prototype.onMemberKicked = function(e, t, n, i, s) {
                        if (t === this.myUserId()) return;
                        const r = this.participants[t];
                        if (e) return this.eventEmitter.emit(ne, r, i, s), void this.leave();
                        const o = this.participants[n];
                        o.setIsReplaced(s), this.eventEmitter.emit(ie, r, o, i)
                    }, Ac.prototype.onLocalRoleChanged = function(e) {
                        this.eventEmitter.emit(xe, this.myUserId(), e)
                    }, Ac.prototype.onUserRoleChanged = function(e, t) {
                        const n = Xe.Strophe.getResourceFromJid(e),
                            i = this.getParticipantById(n);
                        i && (i.setRole(t), this.eventEmitter.emit(xe, n, t))
                    }, Ac.prototype.onDisplayNameChanged = function(e, t) {
                        const n = Xe.Strophe.getResourceFromJid(e),
                            i = this.getParticipantById(n);
                        i && i._displayName !== t && (i._displayName = t, this.eventEmitter.emit(W, n, t))
                    }, Ac.prototype.onRemoteTrackAdded = function(e) {
                        if (e.isP2P && !this.isP2PActive()) return void Rc.info("Trying to add remote P2P track, when not in P2P - IGNORED");
                        if (!e.isP2P && this.isP2PActive()) return void Rc.info("Trying to add remote JVB track, when in P2P - IGNORED");
                        const t = e.getParticipantId(),
                            n = this.getParticipantById(t);
                        if (!n) return void Rc.error(`No participant found for id: ${t}`);
                        n._tracks.push(e), this.transcriber && this.transcriber.addTrack(e);
                        const i = this.eventEmitter;
                        e.addEventListener(Qn, (() => i.emit(De, e))), e.addEventListener(zn, ((e, n) => {
                            this.getActivePeerConnection() === n && i.emit(Me, t, e)
                        })), i.emit(Ie, e)
                    }, Ac.prototype.onCallAccepted = function(e, t) {
                        this.p2pJingleSession === e && (Rc.info("P2P setAnswer"), this.p2pJingleSession.setAnswer(t), this.eventEmitter.emit(ae, this.p2pJingleSession))
                    }, Ac.prototype.onTransportInfo = function(e, t) {
                        this.p2pJingleSession === e && (Rc.info("P2P addIceCandidates"), this.p2pJingleSession.addIceCandidates(t))
                    }, Ac.prototype.onRemoteTrackRemoved = function(e) {
                        this.getParticipants().forEach((t => {
                            const n = t.getTracks();
                            for (let i = 0; i < n.length; i++)
                                if (n[i] === e) {
                                    t._tracks.splice(i, 1), this.eventEmitter.emit(Ne, e), this.transcriber && this.transcriber.removeTrack(e);
                                    break
                                }
                        }), this)
                    }, Ac.prototype._onIncomingCallP2P = function(e, t) {
                        let n;
                        !this.isP2PEnabled() && !this.isP2PTestModeEnabled() || Qt.isFirefox() || Qt.isWebKitBased() ? n = {
                            reason: "decline",
                            reasonDescription: "P2P disabled",
                            errorMsg: "P2P mode disabled in the configuration"
                        } : this.p2pJingleSession ? n = {
                            reason: "busy",
                            reasonDescription: "P2P already in progress",
                            errorMsg: 'Duplicated P2P "session-initiate"'
                        } : this._shouldBeInP2PMode() || (n = {
                            reason: "decline",
                            reasonDescription: "P2P requirements not met",
                            errorMsg: 'Received P2P "session-initiate" when should not be in P2P mode'
                        }, On.sendAnalytics(Tt("decline"))), n ? this._rejectIncomingCall(e, n) : this._acceptP2PIncomingCall(e, t)
                    }, Ac.prototype.onIncomingCall = function(e, t, n) {
                        if (e.isP2P) this._onIncomingCallP2P(e, t);
                        else {
                            if (!this.isFocus(e.remoteJid)) {
                                const t = "Rejecting session-initiate from non-focus.";
                                return void this._rejectIncomingCall(e, {
                                    reason: "security-error",
                                    reasonDescription: t,
                                    errorMsg: t
                                })
                            }
                            this._acceptJvbIncomingCall(e, t, n)
                        }
                    }, Ac.prototype._acceptJvbIncomingCall = function(e, t, n) {
                        this.jvbJingleSession = e, this.room.connectionTimes["session.initiate"] = n, this._sendConferenceJoinAnalyticsEvent(), this.wasStopped && On.sendAnalyticsAndLog(Tt("restart", {
                            p2p: !1
                        }));
                        const i = $(t).find('>bridge-session[xmlns="http://jitsi.org/protocol/focus"]').attr("region");
                        this.eventEmitter.emit(oe, i), this._maybeClearSITimeout(), On.sendAnalytics(Tt("session-initiate.received", {
                            p2p: !1,
                            value: n
                        }));
                        try {
                            e.initialize(this.room, this.rtc, Cc({}, this.options.config, {
                                enableInsertableStreams: this.isE2EEEnabled()
                            }))
                        } catch (e) {
                            return sn().callErrorHandler(e), void Rc.error(e)
                        }
                        this._setBridgeChannel(t, e.peerconnection);
                        const s = this._getInitialLocalTracks();
                        try {
                            e.acceptOffer(t, (() => {
                                this.isP2PActive() && this.jvbJingleSession && this._suspendMediaTransferForJvbConnection(), this.eventEmitter.emit(ae, e), this.isP2PActive() || this.eventEmitter.emit(ce, e)
                            }), (e => {
                                sn().callErrorHandler(e), Rc.error("Failed to accept incoming Jingle session", e)
                            }), s), this._desktopSharingFrameRate && e.peerconnection.setDesktopSharingFrameRate(this._desktopSharingFrameRate), Rc.info("Starting CallStats for JVB connection..."), this.statistics.startCallStats(this.jvbJingleSession.peerconnection, "jitsi"), this.statistics.startRemoteStats(this.jvbJingleSession.peerconnection)
                        } catch (e) {
                            sn().callErrorHandler(e), Rc.error(e)
                        }
                    }, Ac.prototype._setBridgeChannel = function(e, t) {
                        let n = null;
                        const i = $(e).find(">content>transport>web-socket").first();
                        1 === i.length && (n = i[0].getAttribute("url")), n ? this.rtc.initializeBridgeChannel(null, n) : this.rtc.initializeBridgeChannel(t, null)
                    }, Ac.prototype._rejectIncomingCall = function(e, t) {
                        t && t.errorMsg && sn().callErrorHandler(new Error(t.errorMsg)), e.terminate(null, (e => {
                            Rc.warn("An error occurred while trying to terminate invalid Jingle session", e)
                        }), {
                            reason: t && t.reason,
                            reasonDescription: t && t.reasonDescription,
                            sendSessionTerminate: !0
                        })
                    }, Ac.prototype.onCallEnded = function(e, t, n) {
                        Rc.info(`Call ended: ${t} - ${n} P2P ?${e.isP2P}`), e === this.jvbJingleSession ? (this.wasStopped = !0, On.sendAnalytics(Tt("terminate", {
                            p2p: !1
                        })), this.statistics && (this.statistics.stopRemoteStats(this.jvbJingleSession.peerconnection), Rc.info("Stopping JVB CallStats"), this.statistics.stopCallStats(this.jvbJingleSession.peerconnection)), this.jvbJingleSession = null, this.rtc.onCallEnded()) : e === this.p2pJingleSession ? ("decline" === t && "force JVB121" === n ? (Rc.info("In forced JVB 121 mode..."), On.analytics.addPermanentProperties({
                            forceJvb121: !0
                        })) : "connectivity-error" === t && "ICE FAILED" === n && On.analytics.addPermanentProperties({
                            p2pFailed: !0
                        }), this._stopP2PSession()) : Rc.error("Received onCallEnded for invalid session", e.sid, e.remoteJid, t, n)
                    }, Ac.prototype.onSuspendDetected = function(e) {
                        e.isP2P || (this.leave(), this.eventEmitter.emit(we))
                    }, Ac.prototype.updateDTMFSupport = function() {
                        let e = !1;
                        const t = this.getParticipants();
                        for (let n = 0; n < t.length; n += 1)
                            if (t[n].supportsDTMF()) {
                                e = !0;
                                break
                            } e !== this.somebodySupportsDTMF && (this.somebodySupportsDTMF = e, this.eventEmitter.emit(Y, e))
                    }, Ac.prototype.isDTMFSupported = function() {
                        return this.somebodySupportsDTMF
                    }, Ac.prototype.myUserId = function() {
                        return this.room && this.room.myroomjid ? Xe.Strophe.getResourceFromJid(this.room.myroomjid) : null
                    }, Ac.prototype.sendTones = function(e, t, n) {
                        const i = this.getActivePeerConnection();
                        i ? i.sendTones(e, t, n) : Rc.warn("cannot sendTones: no peer connection")
                    }, Ac.prototype.startRecording = function(e) {
                        return this.room ? this.recordingManager.startRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
                    }, Ac.prototype.stopRecording = function(e) {
                        return this.room ? this.recordingManager.stopRecording(e) : Promise.reject(new Error("The conference is not created yet!"))
                    }, Ac.prototype.isSIPCallingSupported = function() {
                        return !!this.room && this.room.isSIPCallingSupported()
                    }, Ac.prototype.dial = function(e) {
                        return this.room ? this.room.dial(e) : new Promise(((e, t) => {
                            t(new Error("The conference is not created yet!"))
                        }))
                    }, Ac.prototype.hangup = function() {
                        return this.room ? this.room.hangup() : new Promise(((e, t) => {
                            t(new Error("The conference is not created yet!"))
                        }))
                    }, Ac.prototype.startTranscriber = function() {
                        return this.dial("jitsi_meet_transcribe")
                    }, Ac.prototype.stopTranscriber = Ac.prototype.hangup, Ac.prototype.getPhoneNumber = function() {
                        return this.room ? this.room.getPhoneNumber() : null
                    }, Ac.prototype.getPhonePin = function() {
                        return this.room ? this.room.getPhonePin() : null
                    }, Ac.prototype.getMeetingUniqueId = function() {
                        if (this.room) return this.room.getMeetingId()
                    }, Ac.prototype.getActivePeerConnection = function() {
                        const e = this.isP2PActive() ? this.p2pJingleSession : this.jvbJingleSession;
                        return e ? e.peerconnection : null
                    }, Ac.prototype.getConnectionState = function() {
                        const e = this.getActivePeerConnection();
                        return e ? e.getConnectionState() : null
                    }, Ac.prototype.setStartMutedPolicy = function(e) {
                        this.isModerator() ? (this.startMutedPolicy = e, this.room.addOrReplaceInPresence("startmuted", {
                            attributes: {
                                audio: e.audio,
                                video: e.video,
                                xmlns: "http://jitsi.org/jitmeet/start-muted"
                            }
                        }) && this.room.sendPresence()) : Rc.warn(`Failed to set start muted policy, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
                    }, Ac.prototype.getStartMutedPolicy = function() {
                        return this.startMutedPolicy
                    }, Ac.prototype.isStartAudioMuted = function() {
                        return this.startAudioMuted
                    }, Ac.prototype.isStartVideoMuted = function() {
                        return this.startVideoMuted
                    }, Ac.prototype.getConnectionTimes = function() {
                        return this.room.connectionTimes
                    }, Ac.prototype.setLocalParticipantProperty = function(e, t) {
                        this.sendCommand(`jitsi_participant_${e}`, {
                            value: t
                        })
                    }, Ac.prototype.removeLocalParticipantProperty = function(e) {
                        this.removeCommand(`jitsi_participant_${e}`), this.room.sendPresence()
                    }, Ac.prototype.getLocalParticipantProperty = function(e) {
                        const t = this.room.presMap.nodes.find((t => t.tagName === `jitsi_participant_${e}`));
                        return t ? t.value : void 0
                    }, Ac.prototype.sendFeedback = function(e, t) {
                        return this.statistics.sendFeedback(e, t)
                    }, Ac.prototype.isCallstatsEnabled = function() {
                        return this.statistics.isCallstatsEnabled()
                    }, Ac.prototype.getSsrcByTrack = function(e) {
                        var t;
                        return e.isLocal() ? null === (t = this.getActivePeerConnection()) || void 0 === t ? void 0 : t.getLocalSSRC(e) : e.getSSRC()
                    }, Ac.prototype._onTrackAttach = function(e, t) {
                        const n = e.isLocal();
                        let i = null;
                        const s = e.isP2P,
                            r = s ? e.getParticipantId() : "jitsi",
                            o = s ? this.p2pJingleSession && this.p2pJingleSession.peerconnection : this.jvbJingleSession && this.jvbJingleSession.peerconnection;
                        n ? o && (i = o.getLocalSSRC(e)) : i = e.getSSRC(), t.id && i && o && this.statistics.associateStreamWithVideoTag(o, i, n, r, e.getUsageLabel(), t.id)
                    }, Ac.prototype.sendApplicationLog = function(e) {
                        On.sendLog(e)
                    }, Ac.prototype.isFocus = function(e) {
                        return this.room ? this.room.isFocus(e) : null
                    }, Ac.prototype._fireIncompatibleVersionsEvent = function() {
                        this.eventEmitter.emit(J, M)
                    }, Ac.prototype.sendEndpointMessage = function(e, t) {
                        this.rtc.sendChannelMessage(e, t)
                    }, Ac.prototype.sendEndpointStatsMessage = function(e) {
                        this.rtc.sendEndpointStatsMessage(e)
                    }, Ac.prototype.broadcastEndpointMessage = function(e) {
                        this.sendEndpointMessage("", e)
                    }, Ac.prototype.sendMessage = function(e, t = "", n = !1) {
                        const i = typeof e;
                        if ("object" === i || !n && "string" === i)
                            if (n) this.sendEndpointMessage(t, e);
                            else {
                                let n = e,
                                    s = "body";
                                if ("object" === i) {
                                    s = "json-message", n.hasOwnProperty(Pr) || (n[Pr] = "");
                                    try {
                                        n = JSON.stringify(n)
                                    } catch (e) {
                                        return void Rc.error("Can not send a message, stringify failed: ", e)
                                    }
                                }
                                t ? this.sendPrivateTextMessage(t, n, s) : this.sendTextMessage(n, s)
                            }
                        else Rc.error(`Can not send a message of type ${i}`)
                    }, Ac.prototype.isConnectionInterrupted = function() {
                        return this.isP2PActive() ? this.isP2PConnectionInterrupted : this.isJvbConnectionInterrupted
                    }, Ac.prototype._onConferenceRestarted = function(e) {
                        !e.isP2P && this.options.config.enableForcedReload && this.eventEmitter.emit(J, b)
                    }, Ac.prototype._onIceConnectionInterrupted = function(e) {
                        e.isP2P ? this.isP2PConnectionInterrupted = !0 : this.isJvbConnectionInterrupted = !0, e.isP2P === this.isP2PActive() && this.eventEmitter.emit(q)
                    }, Ac.prototype._onIceConnectionFailed = function(e) {
                        e.isP2P ? (On.analytics.addPermanentProperties({
                            p2pFailed: !0
                        }), this.p2pJingleSession && On.sendAnalyticsAndLog(Rt("failed", {
                            initiator: this.p2pJingleSession.isInitiator
                        })), this._stopP2PSession("connectivity-error", "ICE FAILED")) : e && this.jvbJingleSession === e && (this._delayedIceFailed = new _a(this), this._delayedIceFailed.start(e))
                    }, Ac.prototype._onIceConnectionRestored = function(e) {
                        e.isP2P ? this.isP2PConnectionInterrupted = !1 : (this.isJvbConnectionInterrupted = !1, this._delayedIceFailed && this._delayedIceFailed.cancel()), e.isP2P === this.isP2PActive() && this.eventEmitter.emit(K)
                    }, Ac.prototype._acceptP2PIncomingCall = function(e, t) {
                        this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = e, this._sendConferenceJoinAnalyticsEvent(), this.p2pJingleSession.initialize(this.room, this.rtc, Cc({}, this.options.config, {
                            enableInsertableStreams: this.isE2EEEnabled()
                        })), Rc.info("Starting CallStats for P2P connection...");
                        let n = Xe.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);
                        const i = this.participants[n];
                        i && (n = i.getStatsID() || n), this.statistics.startCallStats(this.p2pJingleSession.peerconnection, n);
                        const s = this.getLocalTracks();
                        this.p2pJingleSession.acceptOffer(t, (() => {
                            Rc.debug('Got RESULT for P2P "session-accept"'), this.eventEmitter.emit(ae, this.p2pJingleSession)
                        }), (e => {
                            Rc.error("Failed to accept incoming P2P Jingle session", e)
                        }), s)
                    }, Ac.prototype._addRemoteJVBTracks = function() {
                        this._addRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
                    }, Ac.prototype._addRemoteP2PTracks = function() {
                        this._addRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
                    }, Ac.prototype._addRemoteTracks = function(e, t) {
                        for (const n of t) Rc.info(`Adding remote ${e} track: ${n}`), this.onRemoteTrackAdded(n)
                    }, Ac.prototype._onIceConnectionEstablished = function(e) {
                        null !== this.p2pJingleSession && (this.p2pEstablishmentDuration = this.p2pJingleSession.establishmentDuration), null !== this.jvbJingleSession && (this.jvbEstablishmentDuration = this.jvbJingleSession.establishmentDuration);
                        let t = !1;
                        const n = this.options.config.forceJVB121Ratio;
                        if (e.isP2P ? this.p2pJingleSession !== e ? (Rc.error("CONNECTION_ESTABLISHED - wrong P2P session instance ?!"), t = !0) : !e.isInitiator && "number" == typeof n && Math.random() < n && (Rc.info(`Forcing JVB 121 mode (ratio=${n})...`), On.analytics.addPermanentProperties({
                                forceJvb121: !0
                            }), this._stopP2PSession("decline", "force JVB121"), t = !0) : t = !0, !isNaN(this.p2pEstablishmentDuration) && !isNaN(this.jvbEstablishmentDuration)) {
                            const e = this.p2pEstablishmentDuration - this.jvbEstablishmentDuration;
                            On.sendAnalytics("ice.establishment.duration.diff", {
                                value: e
                            })
                        }
                        e.isP2P === this.isP2PActive() && this.eventEmitter.emit(G), t || (this._setP2PStatus(!0), this.jvbJingleSession ? this._removeRemoteJVBTracks() : Rc.info("Not removing remote JVB tracks - no session yet"), this._addRemoteP2PTracks(), this.jvbJingleSession && this._suspendMediaTransferForJvbConnection(), Rc.info("Starting remote stats with p2p connection"), this.statistics.startRemoteStats(this.p2pJingleSession.peerconnection), On.sendAnalyticsAndLog(Rt("established", {
                            initiator: this.p2pJingleSession.isInitiator
                        })))
                    }, Ac.prototype._updateProperties = function(e = {}) {
                        const t = !Qe()(e, this.properties);
                        this.properties = e, t && (this.eventEmitter.emit(Se, this.properties), ["bridge-count", "created-ms"].forEach((t => {
                            void 0 !== e[t] && On.analytics.addPermanentProperties({
                                [t.replace("-", "_")]: e[t]
                            })
                        })))
                    }, Ac.prototype.getProperty = function(e) {
                        return this.properties[e]
                    }, Ac.prototype._maybeClearDeferredStartP2P = function() {
                        this.deferredStartP2PTask && (Rc.info("Cleared deferred start P2P task"), clearTimeout(this.deferredStartP2PTask), this.deferredStartP2PTask = null)
                    }, Ac.prototype._removeRemoteJVBTracks = function() {
                        this._removeRemoteTracks("JVB", this.jvbJingleSession.peerconnection.getRemoteTracks())
                    }, Ac.prototype._removeRemoteP2PTracks = function() {
                        this._removeRemoteTracks("P2P", this.p2pJingleSession.peerconnection.getRemoteTracks())
                    }, Ac.prototype._removeRemoteTracks = function(e, t) {
                        for (const n of t) Rc.info(`Removing remote ${e} track: ${n}`), this.onRemoteTrackRemoved(n)
                    }, Ac.prototype._resumeMediaTransferForJvbConnection = function() {
                        Rc.info("Resuming media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!0, !0).then((() => {
                            Rc.info("Resumed media transfer over the JVB connection!")
                        }), (e => {
                            Rc.error("Failed to resume media transfer over the JVB connection:", e)
                        }))
                    }, Ac.prototype._setP2PStatus = function(e) {
                        if (this.p2p !== e) {
                            if (this.p2p = e, e) {
                                Rc.info("Peer to peer connection established!"), On.analytics.addPermanentProperties({
                                    p2pFailed: !1,
                                    forceJvb121: !1
                                });
                                const e = 0 !== this.getLastN();
                                this.p2pJingleSession.setMediaTransferActive(!0, e).catch((t => {
                                    Rc.error(`Failed to sync up P2P video transfer status(${e})`, t)
                                }))
                            } else Rc.info("Peer to peer connection closed!");
                            this.jvbJingleSession && this.statistics.sendConnectionResumeOrHoldEvent(this.jvbJingleSession.peerconnection, !e), this.dtmfManager = null, this.eventEmitter.emit(ve, this, this.p2p), this.eventEmitter.emit(ce, this._getActiveMediaSession()), this.eventEmitter.emit(this.isConnectionInterrupted() ? q : K)
                        } else Rc.debug(`Called _setP2PStatus with the same status: ${e}`)
                    }, Ac.prototype._startP2PSession = function(e) {
                        if (this._maybeClearDeferredStartP2P(), this.p2pJingleSession) return void Rc.error("P2P session already started!");
                        this.isP2PConnectionInterrupted = !1, this.p2pJingleSession = this.xmpp.connection.jingle.newP2PJingleSession(this.room.myroomjid, e), Rc.info("Created new P2P JingleSession", this.room.myroomjid, e), this._sendConferenceJoinAnalyticsEvent(), this.p2pJingleSession.initialize(this.room, this.rtc, Cc({}, this.options.config, {
                            enableInsertableStreams: this.isE2EEEnabled()
                        })), Rc.info("Starting CallStats for P2P connection...");
                        let t = Xe.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid);
                        const n = this.participants[t];
                        n && (t = n.getStatsID() || t), this.statistics.startCallStats(this.p2pJingleSession.peerconnection, t);
                        const i = this.getLocalTracks();
                        this.p2pJingleSession.invite(i)
                    }, Ac.prototype._suspendMediaTransferForJvbConnection = function() {
                        Rc.info("Suspending media transfer over the JVB connection..."), this.jvbJingleSession.setMediaTransferActive(!1, !1).then((() => {
                            Rc.info("Suspended media transfer over the JVB connection !")
                        }), (e => {
                            Rc.error("Failed to suspend media transfer over the JVB connection:", e)
                        }))
                    }, Ac.prototype._maybeStartOrStopP2P = function(e) {
                        if (!this.isP2PEnabled() || this.isP2PTestModeEnabled() || Qt.isFirefox() || Qt.isWebKitBased()) return void Rc.info("Auto P2P disabled");
                        const t = this.getParticipants(),
                            n = t.length,
                            i = this._shouldBeInP2PMode();
                        if (!i && this.deferredStartP2PTask && this._maybeClearDeferredStartP2P(), !this.p2pJingleSession && i) {
                            const i = n && t[0],
                                s = this.myUserId(),
                                r = i.getId();
                            if (s > r) return void Rc.debug("I'm the bigger peersId - the other peer should start P2P", s, r);
                            if (s === r) return void Rc.error("The same IDs ? ", s, r);
                            const o = i.getJid();
                            if (e) {
                                if (this.deferredStartP2PTask) return void Rc.error("Deferred start P2P task's been set already!");
                                Rc.info(`Will start P2P with: ${o} after ${this.backToP2PDelay} seconds...`), this.deferredStartP2PTask = setTimeout(this._startP2PSession.bind(this, o), 1e3 * this.backToP2PDelay)
                            } else Rc.info(`Will start P2P with: ${o}`), this._startP2PSession(o)
                        } else this.p2pJingleSession && !i && (Rc.info(`Will stop P2P with: ${this.p2pJingleSession.remoteJid}`), this.p2pJingleSession.isInitiator && n > 1 && On.sendAnalyticsAndLog(Rt("switch.to.jvb")), this._stopP2PSession())
                    }, Ac.prototype._shouldBeInP2PMode = function() {
                        const e = this.getParticipants(),
                            t = e.length,
                            n = void 0 !== e.find((e => "poltergeist" === e.getBotType() || e.hasFeature(Ir))),
                            i = 1 === t && !n;
                        return Rc.debug(`P2P? peerCount: ${t}, hasBotPeer: ${n} => ${i}`), i
                    }, Ac.prototype._stopP2PSession = function(e, t) {
                        if (!this.p2pJingleSession) return void Rc.error("No P2P session to be stopped!");
                        const n = this.isP2PActive();
                        n && (this.jvbJingleSession && this._resumeMediaTransferForJvbConnection(), this._removeRemoteP2PTracks()), Rc.info("Stopping remote stats for P2P connection"), this.statistics.stopRemoteStats(this.p2pJingleSession.peerconnection), Rc.info("Stopping CallStats for P2P connection"), this.statistics.stopCallStats(this.p2pJingleSession.peerconnection), this.p2pJingleSession.terminate((() => {
                            Rc.info("P2P session terminate RESULT")
                        }), (t => {
                            e && Rc.error("An error occurred while trying to terminate P2P Jingle session", t)
                        }), {
                            reason: e || "success",
                            reasonDescription: t || "Turing off P2P session",
                            sendSessionTerminate: this.room && this.getParticipantById(Xe.Strophe.getResourceFromJid(this.p2pJingleSession.remoteJid))
                        }), this.p2pJingleSession = null, this._setP2PStatus(!1), n && (this.jvbJingleSession ? this._addRemoteJVBTracks() : Rc.info("Not adding remote JVB tracks - no session yet"))
                    }, Ac.prototype.isP2PActive = function() {
                        return this.p2p
                    }, Ac.prototype.getP2PConnectionState = function() {
                        return this.isP2PActive() ? this.p2pJingleSession.peerconnection.getConnectionState() : null
                    }, Ac.prototype.setDesktopSharingFrameRate = function(e) {
                        return "number" != typeof e || isNaN(e) ? (Rc.error(`Invalid value ${e} specified for desktop capture frame rate`), !1) : (this._desktopSharingFrameRate = e, this.jvbJingleSession && this.jvbJingleSession.peerconnection.setDesktopSharingFrameRate(e), this.rtc.setDesktopSharingFrameRate(e), !0)
                    }, Ac.prototype.startP2PSession = function() {
                        const e = this.getParticipants();
                        if (1 !== e.length) throw new Error("There must be exactly 1 participant to start the P2P session !"); {
                            const t = e[0].getJid();
                            this._startP2PSession(t)
                        }
                    }, Ac.prototype.stopP2PSession = function() {
                        this._stopP2PSession()
                    }, Ac.prototype.getSpeakerStats = function() {
                        return this.speakerStatsCollector.getStats()
                    }, Ac.prototype.setReceiverConstraints = function(e) {
                        this.receiveVideoController.setReceiverConstraints(e)
                    }, Ac.prototype.setReceiverVideoConstraint = function(e) {
                        this.receiveVideoController.setPreferredReceiveMaxFrameHeight(e)
                    }, Ac.prototype.setSenderVideoConstraint = function(e) {
                        return this.sendVideoController.setPreferredSendMaxFrameHeight(e)
                    }, Ac.prototype.createVideoSIPGWSession = function(e, t) {
                        return this.room ? this.videoSIPGWHandler.createVideoSIPGWSession(e, t) : new Error(gc)
                    }, Ac.prototype._sendConferenceJoinAnalyticsEvent = function() {
                        const e = this.getMeetingUniqueId();
                        !this._conferenceJoinAnalyticsEventSent && e && null !== this.getActivePeerConnection() && (On.sendAnalytics(Et("joined", {
                            meetingId: e,
                            participantId: `${e}.${this._statsCurrentId}`
                        })), this._conferenceJoinAnalyticsEventSent = Date.now())
                    }, Ac.prototype._sendConferenceLeftAnalyticsEvent = function() {
                        const e = this.getMeetingUniqueId();
                        e && this._conferenceJoinAnalyticsEventSent && On.sendAnalytics(Et("left", {
                            meetingId: e,
                            participantId: `${e}.${this._statsCurrentId}`,
                            stats: {
                                duration: Math.floor((Date.now() - this._conferenceJoinAnalyticsEventSent) / 1e3),
                                perf: this.getPerformanceStats()
                            }
                        }))
                    }, Ac.prototype._restartMediaSessions = function() {
                        this.p2pJingleSession && this.stopP2PSession(), this.jvbJingleSession && this.jvbJingleSession.terminate(null, (e => {
                            Rc.warn("An error occurred while trying to terminate the JVB session", e)
                        }), {
                            reason: "success",
                            reasonDescription: "restart required",
                            requestRestart: !0,
                            sendSessionTerminate: !0
                        }), this._maybeStartOrStopP2P(!1)
                    }, Ac.prototype.isE2EEEnabled = function() {
                        return Boolean(this._e2eEncryption && this._e2eEncryption.isEnabled())
                    }, Ac.prototype.isE2EESupported = function() {
                        return Fi.isSupported(this.options.config)
                    }, Ac.prototype.toggleE2EE = function(e) {
                        this.isE2EESupported() ? this._e2eEncryption.setEnabled(e) : Rc.warn("Cannot enable / disable E2EE: platform is not supported.")
                    }, Ac.prototype.isLobbySupported = function() {
                        return Boolean(this.room && this.room.getLobby().isSupported())
                    }, Ac.prototype.isMembersOnly = function() {
                        return Boolean(this.room && this.room.membersOnlyEnabled)
                    }, Ac.prototype.enableLobby = function() {
                        return this.room && this.isModerator() ? this.room.getLobby().enable() : Promise.reject(new Error("The conference not started or user is not moderator"))
                    }, Ac.prototype.disableLobby = function() {
                        this.room && this.isModerator() ? this.room.getLobby().disable() : Rc.warn(`Failed to disable lobby, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator"}`)
                    }, Ac.prototype.joinLobby = function(e, t) {
                        return this.room ? this.room.getLobby().join(e, t) : Promise.reject(new Error("The conference not started"))
                    }, Ac.prototype.lobbyDenyAccess = function(e) {
                        this.room && this.room.getLobby().denyAccess(e)
                    }, Ac.prototype.lobbyApproveAccess = function(e) {
                        this.room && this.room.getLobby().approveAccess(e)
                    }, Ac.prototype.isAVModerationSupported = function() {
                        return Boolean(this.room && this.room.getAVModeration().isSupported())
                    }, Ac.prototype.enableAVModeration = function(e) {
                        this.room && this.isModerator() && (e === En || e === Cn) ? this.room.getAVModeration().enable(!0, e) : Rc.warn(`Failed to enable AV moderation, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
                    }, Ac.prototype.disableAVModeration = function(e) {
                        this.room && this.isModerator() && (e === En || e === Cn) ? this.room.getAVModeration().enable(!1, e) : Rc.warn(`Failed to disable AV moderation, ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
                    }, Ac.prototype.avModerationApprove = function(e, t) {
                        if (this.room && this.isModerator() && (e === En || e === Cn)) {
                            const n = this.getParticipantById(t);
                            if (!n) return;
                            this.room.getAVModeration().approve(e, n.getJid())
                        } else Rc.warn(`AV moderation approve skipped , ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
                    }, Ac.prototype.avModerationReject = function(e, t) {
                        if (this.room && this.isModerator() && (e === En || e === Cn)) {
                            const n = this.getParticipantById(t);
                            if (!n) return;
                            this.room.getAVModeration().reject(e, n.getJid())
                        } else Rc.warn(`AV moderation reject skipped , ${this.room?"":"not in a room, "}${this.isModerator()?"":"participant is not a moderator, "}${this.room&&this.isModerator()?"wrong media type passed":""}`)
                    }, wc.prototype.connect = function(e = {}) {
                        this.xmpp.connect(e.id, e.password)
                    }, wc.prototype.attach = function(e) {
                        this.xmpp.attach(e)
                    }, wc.prototype.disconnect = function(...e) {
                        return this.xmpp.disconnect(...e)
                    }, wc.prototype.getJid = function() {
                        return this.xmpp.getJid()
                    }, wc.prototype.setToken = function(e) {
                        this.token = e
                    }, wc.prototype.initJitsiConference = function(e, t) {
                        return new Ac({
                            name: e,
                            config: t,
                            connection: this
                        })
                    }, wc.prototype.addEventListener = function(e, t) {
                        this.xmpp.addListener(e, t)
                    }, wc.prototype.removeEventListener = function(e, t) {
                        this.xmpp.removeListener(e, t)
                    }, wc.prototype.getConnectionTimes = function() {
                        return this.xmpp.connectionTimes
                    }, wc.prototype.addFeature = function(e, t = !1) {
                        this.xmpp.caps.addFeature(e, t, !0)
                    }, wc.prototype.removeFeature = function(e, t = !1) {
                        this.xmpp.caps.removeFeature(e, t, !0)
                    }, wc.prototype.getLogs = function() {
                        const e = this.xmpp.getJingleLog(),
                            t = {};
                        t.time = new Date, t.url = window.location.href, t.ua = navigator.userAgent;
                        const n = this.xmpp.getXmppLog();
                        return n && (t.xmpp = n), e.metadata = t, e
                    };
                    const Pc = "mediaDevices.devicechange",
                        Ic = "rtc.permissions_changed",
                        Mc = "mediaDevices.permissionPromptIsShown",
                        Dc = "mediaDevices.slowGetUserMedia";

                    function Nc(e, t, n) {
                        return t in e ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = n, e
                    }
                    const kc = "microphone",
                        Oc = "camera",
                        Lc = new class {
                            constructor() {
                                this._eventEmitter = new(ze()), this._permissions = {}, oa.addListener(jn().DEVICE_LIST_CHANGED, (e => this._eventEmitter.emit(Pc, e))), oa.addListener(jn().DEVICE_LIST_AVAILABLE, (e => this._logOutputDevice(this.getAudioOutputDevice(), e))), oa.addListener(jn().PERMISSIONS_CHANGED, (e => this._handlePermissionsChange(e))), this._permissionsApiSupported = new Promise((e => {
                                    if (!navigator.permissions) return void e(!1);
                                    const t = this,
                                        n = [];
                                    n.push(navigator.permissions.query({
                                        name: Oc
                                    }).then((e => (this._handlePermissionsChange({
                                        [Cn]: this._parsePermissionState(e)
                                    }), e.onchange = function() {
                                        try {
                                            t._handlePermissionsChange({
                                                [Cn]: t._parsePermissionState(this)
                                            })
                                        } catch (e) {}
                                    }, !0))).catch((() => !1))), n.push(navigator.permissions.query({
                                        name: kc
                                    }).then((e => (this._handlePermissionsChange({
                                        [En]: this._parsePermissionState(e)
                                    }), e.onchange = function() {
                                        try {
                                            t._handlePermissionsChange({
                                                [En]: t._parsePermissionState(this)
                                            })
                                        } catch (e) {}
                                    }, !0))).catch((() => !1))), Promise.all(n).then((t => e(t.every((e => e)))))
                                }))
                            }
                            _parsePermissionState(e = {}) {
                                const t = e.state || e.status;
                                if ("string" != typeof t) throw new TypeError;
                                return "granted" === t
                            }
                            _handlePermissionsChange(e) {
                                [En, Cn].some((t => t in e && e[t] !== this._permissions[t])) && (this._permissions = function(e) {
                                    for (var t = 1; t < arguments.length; t++) {
                                        var n = null != arguments[t] ? Object(arguments[t]) : {},
                                            i = Object.keys(n);
                                        "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                            return Object.getOwnPropertyDescriptor(n, e).enumerable
                                        })))), i.forEach((function(t) {
                                            Nc(e, t, n[t])
                                        }))
                                    }
                                    return e
                                }({}, this._permissions, e), this._eventEmitter.emit(Ic, this._permissions), (this._permissions[En] || this._permissions[Cn]) && this.enumerateDevices((() => {})))
                            }
                            _logOutputDevice(e, t) {
                                const n = t.find((t => "audiooutput" === t.kind && t.deviceId === e));
                                n && On.sendActiveDeviceListEvent(oa.getEventDataForActiveDevice(n))
                            }
                            enumerateDevices(e) {
                                oa.enumerateDevices(e)
                            }
                            isDeviceListAvailable() {
                                return oa.isDeviceListAvailable()
                            }
                            isDeviceChangeAvailable(e) {
                                return oa.isDeviceChangeAvailable(e)
                            }
                            isDevicePermissionGranted(e) {
                                return new Promise((t => {
                                    e in this._permissions ? t(this._permissions[e]) : this._permissionsApiSupported.then((n => {
                                        if (!n) return void t(!1);
                                        const i = [];
                                        switch (e) {
                                            case Cn:
                                                i.push(navigator.permissions.query({
                                                    name: Oc
                                                }));
                                                break;
                                            case En:
                                                i.push(navigator.permissions.query({
                                                    name: kc
                                                }));
                                                break;
                                            default:
                                                i.push(navigator.permissions.query({
                                                    name: Oc
                                                })), i.push(navigator.permissions.query({
                                                    name: kc
                                                }))
                                        }
                                        Promise.all(i).then((e => t(e.every((e => {
                                            try {
                                                return this._parsePermissionState(e)
                                            } catch (e) {
                                                return !1
                                            }
                                        })))), (() => t(!1)))
                                    }))
                                }))
                            }
                            isMultipleAudioInputSupported() {
                                return !(Qt.isFirefox() || Qt.isIosBrowser())
                            }
                            getAudioOutputDevice() {
                                return oa.getAudioOutputDevice()
                            }
                            setAudioOutputDevice(e) {
                                return oa.getCurrentlyAvailableMediaDevices().length > 0 && this._logOutputDevice(e, oa.getCurrentlyAvailableMediaDevices()), oa.setAudioOutputDevice(e)
                            }
                            addEventListener(e, t) {
                                this._eventEmitter.addListener(e, t)
                            }
                            removeEventListener(e, t) {
                                this._eventEmitter.removeListener(e, t)
                            }
                            emitEvent(e, ...t) {
                                this._eventEmitter.emit(e, ...t)
                            }
                        },
                        xc = (0, f.getLogger)("modules/detection/ActiveDeviceDetector.js");

                    function Fc(e) {
                        for (const t of e) t.stopStream()
                    }
                    const jc = "connection-error-encountered",
                        $c = "session-initiate",
                        Bc = "session-terminate";

                    function Jc(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? Object(arguments[t]) : {},
                                i = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), i.forEach((function(t) {
                                Uc(e, t, n[t])
                            }))
                        }
                        return e
                    }

                    function Uc(e, t, n) {
                        return t in e ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = n, e
                    }
                    const Vc = (0, f.getLogger)("modules/proxyconnection/ProxyConnectionPC.js");
                    class Hc {
                        constructor(e = {}) {
                            this._options = Jc({
                                pcConfig: {},
                                isInitiator: !1,
                                receiveAudio: !1,
                                receiveVideo: !1
                            }, e), this._tracks = [], this._peerConnection = null, this._onError = this._onError.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this), this._onSendMessage = this._onSendMessage.bind(this)
                        }
                        getPeerJid() {
                            return this._options.peerJid
                        }
                        processMessage(e) {
                            switch (e.attr("action")) {
                                case "session-accept":
                                    this._onSessionAccept(e);
                                    break;
                                case $c:
                                    this._onSessionInitiate(e);
                                    break;
                                case Bc:
                                    this._onSessionTerminate(e);
                                    break;
                                case "transport-info":
                                    this._onTransportInfo(e)
                            }
                        }
                        start(e = []) {
                            this._peerConnection || (this._tracks = this._tracks.concat(e), this._peerConnection = this._createPeerConnection(), this._peerConnection.invite(e))
                        }
                        stop() {
                            this._peerConnection && this._peerConnection.terminate(), this._onSessionTerminate()
                        }
                        _createPeerConnection() {
                            const e = {
                                    connected: !0,
                                    jingle: {
                                        terminate: () => {}
                                    },
                                    sendIQ: this._onSendMessage,
                                    addEventListener: () => () => {}
                                },
                                t = Jc({
                                    iceServers: wr
                                }, this._options.pcConfig),
                                n = {
                                    addPresenceListener: () => {},
                                    connectionTimes: [],
                                    eventEmitter: {
                                        emit: e => {
                                            switch (e) {
                                                case Hn().CONNECTION_ICE_FAILED:
                                                case Hn().CONNECTION_FAILED:
                                                    this._onError(jc, e)
                                            }
                                        }
                                    },
                                    getMediaPresenceInfo: () => ({}),
                                    removePresenceListener: () => {},
                                    supportsRestartByTerminate: () => !1
                                };
                            this._rtc = new oa({
                                myUserId: () => ""
                            }, {}), this._rtc.addListener(jn().REMOTE_TRACK_ADDED, this._onRemoteStream);
                            const i = new dr(void 0, void 0, this._options.peerJid, e, {
                                offerToReceiveAudio: this._options.receiveAudio,
                                offerToReceiveVideo: this._options.receiveVideo
                            }, t, !0, this._options.isInitiator);
                            return i.initialize(n, this._rtc, {}), i
                        }
                        _onError(e, t = "") {
                            this._options.onError(this._options.peerJid, e, t)
                        }
                        _onRemoteStream(e) {
                            this._tracks.push(e), this._options.onRemoteStream(e)
                        }
                        _onSendMessage(e) {
                            this._options.onSendMessage(this._options.peerJid, e)
                        }
                        _onSessionAccept(e) {
                            this._peerConnection ? this._peerConnection.setAnswer(e) : Vc.error("Received an answer when no peer connection exists.")
                        }
                        _onSessionInitiate(e) {
                            this._peerConnection ? Vc.error("Received an offer when an offer was already sent.") : (this._peerConnection = this._createPeerConnection(), this._peerConnection.acceptOffer(e, (() => {}), (() => this._onError(this._options.peerJid, jc, "session initiate error"))))
                        }
                        _onSessionTerminate() {
                            this._tracks.forEach((e => e.dispose())), this._tracks = [], this._peerConnection && this._peerConnection.onTerminated(), this._rtc && (this._rtc.removeListener(jn().REMOTE_TRACK_ADDED, this._onRemoteStream), this._rtc.destroy())
                        }
                        _onTransportInfo(e) {
                            this._peerConnection.addIceCandidates(e)
                        }
                    }

                    function Gc(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = null != arguments[t] ? Object(arguments[t]) : {},
                                i = Object.keys(n);
                            "function" == typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                return Object.getOwnPropertyDescriptor(n, e).enumerable
                            })))), i.forEach((function(t) {
                                qc(e, t, n[t])
                            }))
                        }
                        return e
                    }

                    function qc(e, t, n) {
                        return t in e ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = n, e
                    }
                    const Kc = (0, f.getLogger)("modules/proxyconnection/ProxyConnectionService.js"),
                        zc = "preCallTestResults",
                        Wc = new(ze());
                    let Qc = !1,
                        Xc = null;
                    const Yc = {
                        init: async function(e) {
                            if (Qc) throw new Error("Precall Test already initialized");
                            const {
                                callStatsID: t,
                                callStatsSecret: n,
                                disableThirdPartyRequests: i
                            } = e;
                            if (!t || !n || i) throw new Error("Callstats is disabled");
                            return await
                            function(e) {
                                if (!Qt.isReactNative()) return new Promise((t => {
                                    Yt().loadScript(e.callStatsCustomScriptUrl || Ye, !0, !0, void 0, t)
                                }))
                            }(e), Xc = new window.callstats,
                                function(e) {
                                    return new Promise(((t, n) => {
                                        const i = e.callStatsID,
                                            s = e.callStatsSecret,
                                            r = e.statisticsId || e.statisticsDisplayName || gs.callStatsUserName;
                                        Xc.initialize(i, s, r, ((e, i) => {
                                            "success" === e ? (Xc.on(zc, ((...e) => {
                                                Wc.emit(zc, ...e)
                                            })), Qc = !0, t()) : n({
                                                status: e,
                                                message: i
                                            })
                                        }), null, {
                                            disablePrecalltest: !0
                                        })
                                    }))
                                }(e)
                        },
                        execute: function() {
                            return Qc ? new Promise(((e, t) => {
                                Wc.on(zc, ((n, i) => {
                                    "success" === n ? e(i) : t({
                                        status: n,
                                        payload: i
                                    })
                                })), Xc.makePrecallTest()
                            })) : Promise.reject("uninitialized")
                        }
                    };
                    var Zc = n(287),
                        ed = n.n(Zc);
                    const td = (0, f.getLogger)("modules/webaudio/AudioMixer.js");
                    class nd {
                        constructor() {
                            this._started = !1, this._streamsToMix = [], this._streamMSSArray = []
                        }
                        addMediaStream(e) {
                            e.getAudioTracks() || td.warn("Added MediaStream doesn't contain audio tracks."), this._streamsToMix.push(e)
                        }
                        start() {
                            if (this._started) return this._mixedMSD.stream;
                            if (this._audioContext = wa(), !this._streamsToMix.length) return td.warn("No MediaStream's added to AudioMixer, nothing will happen."), null;
                            this._started = !0, this._mixedMSD = this._audioContext.createMediaStreamDestination();
                            for (const e of this._streamsToMix) {
                                const t = this._audioContext.createMediaStreamSource(e);
                                t.connect(this._mixedMSD), this._streamMSSArray.push(t)
                            }
                            return this._mixedMSD.stream
                        }
                        reset() {
                            this._started = !1, this._streamsToMix = [];
                            for (const e of this._streamMSSArray) e.disconnect();
                            this._streamMSSArray = [], this._audioContext && (this._audioContext = void 0)
                        }
                    }
                    const id = g().getLogger("JitsiMeetJS.js");

                    function sd(e) {
                        const t = {
                            audio_requested: e.devices.includes("audio"),
                            video_requested: e.devices.includes("video"),
                            screen_sharing_requested: e.devices.includes("desktop")
                        };
                        return t.video_requested && (t.resolution = e.resolution), t
                    }
                    const rd = function(e) {
                        return "object" == typeof window.JitsiMeetJS ? Object.assign({}, window.JitsiMeetJS, e) : e
                    }({
                        version: "bf0d5b5ec2",
                        JitsiConnection: wc,
                        ProxyConnectionService: class {
                            constructor(e = {}) {
                                const {
                                    jitsiConnection: t
                                } = e, n = function(e, t) {
                                    if (null == e) return {};
                                    var n, i, s = function(e, t) {
                                        if (null == e) return {};
                                        var n, i, s = {},
                                            r = Object.keys(e);
                                        for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || (s[n] = e[n]);
                                        return s
                                    }(e, t);
                                    if (Object.getOwnPropertySymbols) {
                                        var r = Object.getOwnPropertySymbols(e);
                                        for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (s[n] = e[n])
                                    }
                                    return s
                                }(e, ["jitsiConnection"]);
                                this._options = Gc({
                                    pcConfig: t && t.xmpp.connection.jingle.p2pIceConfig
                                }, n), this._peerConnection = null, this._onFatalError = this._onFatalError.bind(this), this._onSendMessage = this._onSendMessage.bind(this), this._onRemoteStream = this._onRemoteStream.bind(this)
                            }
                            processMessage(e) {
                                const t = e.from;
                                if (!t) return;
                                if (this._peerConnection && this._peerConnection.getPeerJid() !== t) return void this._onFatalError(t, jc, "rejected");
                                const n = this._convertStringToXML(e.data.iq),
                                    i = n && n.find("jingle"),
                                    s = i && i.attr("action");
                                s === $c && (this._peerConnection = this._createPeerConnection(t, {
                                    isInitiator: !1,
                                    receiveVideo: !0
                                })), this._peerConnection && this._peerConnection.processMessage(i), s !== jc && "unavailable" !== s && s !== Bc || this._selfCloseConnection()
                            }
                            start(e, t = []) {
                                this._peerConnection = this._createPeerConnection(e, {
                                    isInitiator: !0,
                                    receiveVideo: !1
                                }), this._peerConnection.start(t)
                            }
                            stop() {
                                this._peerConnection && this._peerConnection.stop(), this._peerConnection = null
                            }
                            _convertStringToXML(e) {
                                try {
                                    const t = (new DOMParser).parseFromString(e, "text/xml");
                                    return $(t)
                                } catch (e) {
                                    return Kc.error("Attempted to convert incorrectly formatted xml"), null
                                }
                            }
                            _createPeerConnection(e, t = {}) {
                                if (!e) throw new Error("Cannot create ProxyConnectionPC without a peer.");
                                const n = Gc({
                                    pcConfig: this._options.pcConfig,
                                    onError: this._onFatalError,
                                    onRemoteStream: this._onRemoteStream,
                                    onSendMessage: this._onSendMessage,
                                    peerJid: e
                                }, t);
                                return new Hc(n)
                            }
                            _onFatalError(e, t, n = "") {
                                Kc.error("Received a proxy connection error", e, t, n);
                                const i = (0, Xe.$iq)({
                                    to: e,
                                    type: "set"
                                }).c("jingle", {
                                    xmlns: "urn:xmpp:jingle:1",
                                    action: t
                                }).c("details").t(n).up();
                                this._onSendMessage(e, i), this._peerConnection && this._peerConnection.getPeerJid() === e && this._selfCloseConnection()
                            }
                            _onRemoteStream(e) {
                                if (!this._options.onRemoteStream) return Kc.error("Remote track received without callback."), void e.dispose();
                                const t = e.isVideoTrack();
                                let n;
                                t && (n = this._options.convertVideoToDesktop ? Bn().DESKTOP : Bn().CAMERA);
                                const i = e.getOriginalStream(),
                                    s = oa.createLocalTracks([{
                                        deviceId: `proxy:${this._peerConnection.getPeerJid()}`,
                                        mediaType: t ? Cn : En,
                                        sourceType: "proxy",
                                        stream: i,
                                        track: i.getVideoTracks()[0],
                                        videoType: n
                                    }]);
                                this._options.onRemoteStream(s[0])
                            }
                            _onSendMessage(e, t) {
                                if (this._options.onSendMessage) try {
                                    const n = (new XMLSerializer).serializeToString(t.nodeTree || t);
                                    this._options.onSendMessage(e, {
                                        iq: n
                                    })
                                } catch (e) {
                                    Kc.error("Attempted to send an incorrectly formatted iq.")
                                }
                            }
                            _selfCloseConnection() {
                                this.stop(), this._options.onConnectionClosed && this._options.onConnectionClosed()
                            }
                        },
                        constants: {
                            participantConnectionStatus: ii,
                            recording: {
                                error: {
                                    BUSY: "busy",
                                    ERROR: "error",
                                    RESOURCE_CONSTRAINT: "resource-constraint",
                                    SERVICE_UNAVAILABLE: "service-unavailable"
                                },
                                mode: {
                                    FILE: "file",
                                    STREAM: "stream"
                                },
                                status: {
                                    OFF: "off",
                                    ON: "on",
                                    PENDING: "pending"
                                }
                            },
                            sipVideoGW: p,
                            transcriptionStatus: d
                        },
                        events: {
                            conference: s,
                            connection: a,
                            detection: h,
                            track: o,
                            mediaDevices: m,
                            connectionQuality: l,
                            e2eping: u
                        },
                        errors: {
                            conference: i,
                            connection: c,
                            track: r
                        },
                        errorTypes: {
                            JitsiTrackError: pt
                        },
                        logLevels: g().levels,
                        mediaDevices: Lc,
                        analytics: On.analytics,
                        init(e = {}) {
                            gs.init(e.externalStorage), On.init(e), Ns.init({
                                sourceNameSignaling: e.sourceNameSignaling
                            }), window.connectionTimes || (window.connectionTimes = {}), !0 !== e.enableAnalyticsLogging && (id.warn("Analytics disabled, disposing."), this.analytics.dispose()), e.enableWindowOnErrorHandler && sn().addHandler(this.getGlobalOnErrorHandler.bind(this));
                            const t = e.deploymentInfo;
                            if (t && Object.keys(t).length > 0) {
                                const e = {};
                                for (const n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
                                e.id = "deployment_info", On.sendLog(JSON.stringify(e))
                            }
                            if (this.version) {
                                const e = {
                                    id: "component_version",
                                    component: "lib-jitsi-meet",
                                    version: this.version
                                };
                                On.sendLog(JSON.stringify(e))
                            }
                            return oa.init(e)
                        },
                        isDesktopSharingEnabled: () => oa.isDesktopSharingEnabled(),
                        isWebRtcSupported: () => oa.isWebRtcSupported(),
                        setLogLevel(e) {
                            g().setLogLevel(e)
                        },
                        setLogLevelById(e, t) {
                            g().setLogLevelById(e, t)
                        },
                        addGlobalLogTransport(e) {
                            g().addGlobalTransport(e)
                        },
                        removeGlobalLogTransport(e) {
                            g().removeGlobalTransport(e)
                        },
                        setGlobalLogOptions(e) {
                            g().setGlobalOptions(e)
                        },
                        createLocalTracks(e = {}, t) {
                            let n = !1;
                            const {
                                firePermissionPromptIsShownEvent: i,
                                fireSlowPromiseEvent: s
                            } = e, r = function(e, t) {
                                if (null == e) return {};
                                var n, i, s = function(e, t) {
                                    if (null == e) return {};
                                    var n, i, s = {},
                                        r = Object.keys(e);
                                    for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || (s[n] = e[n]);
                                    return s
                                }(e, t);
                                if (Object.getOwnPropertySymbols) {
                                    var r = Object.getOwnPropertySymbols(e);
                                    for (i = 0; i < r.length; i++) n = r[i], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (s[n] = e[n])
                                }
                                return s
                            }(e, ["firePermissionPromptIsShownEvent", "fireSlowPromiseEvent"]);
                            return !i && !t || oa.arePermissionsGrantedForAvailableDevices() ? s && window.setTimeout((() => {
                                n || Lc.emitEvent(Dc)
                            }), 1e3) : Lc.emitEvent(Mc, Qt.getName()), window.connectionTimes || (window.connectionTimes = {}), window.connectionTimes["obtainPermissions.start"] = window.performance.now(), oa.obtainAudioAndVideoPermissions(r).then((e => {
                                if (n = !0, window.connectionTimes["obtainPermissions.end"] = window.performance.now(), On.sendAnalytics(Ct("success", sd(r))), !oa.options.disableAudioLevels)
                                    for (let t = 0; t < e.length; t++) {
                                        const n = e[t],
                                            i = n.getOriginalStream();
                                        n.getType() === En && (On.startLocalStats(i, n.setAudioLevel.bind(n)), n.addEventListener(Kn, (() => {
                                            On.stopLocalStats(i)
                                        })))
                                    }
                                const t = oa.getCurrentlyAvailableMediaDevices();
                                if (t)
                                    for (let n = 0; n < e.length; n++) e[n]._setRealDeviceIdFromDeviceList(t);
                                for (const t of e) t.type === Cn && "desktop" === t.videoType && this.setVideoTrackContentHints(t.track, "detail");
                                return e
                            })).catch((t => {
                                if (n = !0, t.name === ot) {
                                    const e = {
                                        id: "screensharing_user_canceled",
                                        message: t.message
                                    };
                                    On.sendLog(JSON.stringify(e)), On.sendAnalytics(Ct("warning", {
                                        reason: "extension install user canceled"
                                    }))
                                } else if (t.name === it) {
                                    const n = {
                                        id: "usermedia_missing_device",
                                        status: t.gum.devices
                                    };
                                    On.sendLog(JSON.stringify(n));
                                    const i = sd(e);
                                    i.reason = "device not found", i.devices = t.gum.devices.join("."), On.sendAnalytics(Ct("error", i))
                                } else {
                                    On.sendGetUserMediaFailed(t);
                                    const n = sd(e);
                                    n.reason = t.name, On.sendAnalytics(Ct("error", n))
                                }
                                return window.connectionTimes["obtainPermissions.end"] = window.performance.now(), Promise.reject(t)
                            }))
                        },
                        createTrackVADEmitter: (e, t, n) => Pa.create(e, t, n),
                        createAudioMixer: () => new nd,
                        getActiveAudioDevice: () => new Promise((e => {
                            oa.enumerateDevices((t => {
                                const n = t.filter((e => "audioinput" === e.kind)),
                                    i = [];
                                for (const e of n) {
                                    const t = oa.obtainAudioAndVideoPermissions({
                                        devices: ["audio"],
                                        micDeviceId: e.deviceId
                                    }).then((e => {
                                        const t = e[0],
                                            n = t.getOriginalStream();
                                        return On.startLocalStats(n, t.setAudioLevel.bind(t)), t.addEventListener(Kn, (() => {
                                            On.stopLocalStats(n)
                                        })), t
                                    }));
                                    i.push(t)
                                }
                                Promise.allSettled(i).then((t => {
                                    const n = t.filter((e => "fulfilled" === e.status)),
                                        i = t.filter((e => "rejected" === e.status)),
                                        s = n.map((e => e.value)),
                                        r = i.map((e => e.value));
                                    for (const e of r) xc.error("Failed to acquire audio device with error: ", e);
                                    for (const t of s) t.on(zn, (n => {
                                        n > .008 && (Fc(s), e({
                                            deviceId: t.deviceId,
                                            deviceLabel: t.track.label
                                        }))
                                    }));
                                    setTimeout((() => {
                                        Fc(s), e({
                                            deviceId: "",
                                            deviceLabel: ""
                                        })
                                    }), 3e3)
                                }))
                            }))
                        })),
                        isDeviceListAvailable() {
                            return id.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceListAvailable instead"), this.mediaDevices.isDeviceListAvailable()
                        },
                        isDeviceChangeAvailable(e) {
                            return id.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.isDeviceChangeAvailable instead"), this.mediaDevices.isDeviceChangeAvailable(e)
                        },
                        isMultipleAudioInputSupported() {
                            return this.mediaDevices.isMultipleAudioInputSupported()
                        },
                        isCollectingLocalStats: () => On.audioLevelsEnabled && mn.isLocalStatsSupported(),
                        enumerateDevices(e) {
                            id.warn("This method is deprecated, use JitsiMeetJS.mediaDevices.enumerateDevices instead"), this.mediaDevices.enumerateDevices(e)
                        },
                        getGlobalOnErrorHandler(e, t, n, i, s) {
                            id.error(`UnhandledError: ${e}`, `Script: ${t}`, `Line: ${n}`, `Column: ${i}`, "StackTrace: ", s), On.reportGlobalError(s)
                        },
                        setNetworkInfo({
                            isOnline: e
                        }) {
                            Ki.updateNetworkInfo({
                                isOnline: e
                            })
                        },
                        setVideoTrackContentHints(e, t) {
                            "contentHint" in e ? (e.contentHint = t, e.contentHint !== t && id.debug("Invalid video track contentHint")) : id.debug("MediaStreamTrack contentHint attribute not supported")
                        },
                        precallTest: Yc,
                        util: {
                            AuthUtil: ed(),
                            ScriptUtil: Yt(),
                            browser: Qt
                        }
                    })
                }
            },
            __webpack_module_cache__ = {};

        function __webpack_require__(e) {
            var t = __webpack_module_cache__[e];
            if (void 0 !== t) return t.exports;
            var n = __webpack_module_cache__[e] = {
                id: e,
                loaded: !1,
                exports: {}
            };
            return __webpack_modules__[e].call(n.exports, n, n.exports, __webpack_require__), n.loaded = !0, n.exports
        }
        __webpack_require__.amdO = {}, __webpack_require__.n = e => {
            var t = e && e.__esModule ? () => e.default : () => e;
            return __webpack_require__.d(t, {
                a: t
            }), t
        }, __webpack_require__.d = (e, t) => {
            for (var n in t) __webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, {
                enumerable: !0,
                get: t[n]
            })
        }, __webpack_require__.g = function() {
            if ("object" == typeof globalThis) return globalThis;
            try {
                return this || new Function("return this")()
            } catch (e) {
                if ("object" == typeof window) return window
            }
        }(), __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), __webpack_require__.r = e => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, __webpack_require__.nmd = e => (e.paths = [], e.children || (e.children = []), e);
        var __webpack_exports__ = __webpack_require__(2809);
        return __webpack_exports__
    })()
}));
